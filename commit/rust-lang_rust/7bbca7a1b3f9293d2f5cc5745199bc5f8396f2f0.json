{"sha": "7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYmNhN2ExYjNmOTI5M2QyZjVjYzU3NDUxOTliYzVmODM5NmYyZjA=", "commit": {"author": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-08-24T09:19:53Z"}, "committer": {"name": "Zac Pullar-Strecker", "email": "zacmps@gmail.com", "date": "2020-08-24T09:20:13Z"}, "message": "Merge remote-tracking branch 'upstream/master' into 503-hover-doc-links", "tree": {"sha": "bdb47765991cb973b2cd5481a088fac636bd326c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdb47765991cb973b2cd5481a088fac636bd326c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "html_url": "https://github.com/rust-lang/rust/commit/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/comments", "author": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zacps", "id": 9827696, "node_id": "MDQ6VXNlcjk4Mjc2OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/9827696?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zacps", "html_url": "https://github.com/zacps", "followers_url": "https://api.github.com/users/zacps/followers", "following_url": "https://api.github.com/users/zacps/following{/other_user}", "gists_url": "https://api.github.com/users/zacps/gists{/gist_id}", "starred_url": "https://api.github.com/users/zacps/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zacps/subscriptions", "organizations_url": "https://api.github.com/users/zacps/orgs", "repos_url": "https://api.github.com/users/zacps/repos", "events_url": "https://api.github.com/users/zacps/events{/privacy}", "received_events_url": "https://api.github.com/users/zacps/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca464650eeaca6195891199a93f4f76cf3e7e697", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca464650eeaca6195891199a93f4f76cf3e7e697", "html_url": "https://github.com/rust-lang/rust/commit/ca464650eeaca6195891199a93f4f76cf3e7e697"}, {"sha": "e65d48d1fb3d4d91d9dc1148a7a836ff5c9a3c87", "url": "https://api.github.com/repos/rust-lang/rust/commits/e65d48d1fb3d4d91d9dc1148a7a836ff5c9a3c87", "html_url": "https://github.com/rust-lang/rust/commit/e65d48d1fb3d4d91d9dc1148a7a836ff5c9a3c87"}], "stats": {"total": 17400, "additions": 9796, "deletions": 7604}, "files": [{"sha": "f6b0b66bfe738fbbeba7d7eea8d7daede0b16754", "filename": ".cargo/config", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/.cargo%2Fconfig", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/.cargo%2Fconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.cargo%2Fconfig?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,3 +3,6 @@ xtask = \"run --package xtask --bin xtask --\"\n install-ra = \"run --package xtask --bin xtask -- install\" # for backwards compat\n tq = \"test -- -q\"\n qt = \"tq\"\n+\n+[target.x86_64-pc-windows-msvc]\n+linker = \"rust-lld\""}, {"sha": "7c2f752d69aee7356d90a0edd166790f5326512d", "filename": ".gitattributes", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,5 @@\n * text=auto eol=lf\n-crates/ra_syntax/test_data/** -text eof=LF\n+crates/syntax/test_data/** -text eof=LF\n # Older git versions try to fix line endings on images, this prevents it.\n *.png binary\n *.jpg binary"}, {"sha": "73892ddaa297a34d7e719f8028db7f944bbbb701", "filename": ".github/FUNDING.yml", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/.github%2FFUNDING.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/.github%2FFUNDING.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FFUNDING.yml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,12 +1,2 @@\n-# These are supported funding model platforms\n-\n-github: # Replace with up to 4 GitHub Sponsors-enabled usernames e.g., [user1, user2]\n-patreon: # Replace with a single Patreon username\n+github: rust-analyzer\n open_collective: rust-analyzer\n-ko_fi: # Replace with a single Ko-fi username\n-tidelift: # Replace with a single Tidelift platform-name/package-name e.g., npm/babel\n-community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry\n-liberapay: # Replace with a single Liberapay username\n-issuehunt: # Replace with a single IssueHunt username\n-otechie: # Replace with a single Otechie username\n-custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']"}, {"sha": "fb077e28d587107eeb21664d83cf56e948ebf6cf", "filename": ".github/workflows/ci.yaml", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/.github%2Fworkflows%2Fci.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/.github%2Fworkflows%2Fci.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yaml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -16,20 +16,6 @@ env:\n   RUSTUP_MAX_RETRIES: 10\n \n jobs:\n-  # rust-audit:\n-  #   name: Audit Rust vulnerabilities\n-  #   runs-on: ubuntu-latest\n-  #   steps:\n-  #   - name: Checkout repository\n-  #     uses: actions/checkout@v2\n-\n-  #   - uses: actions-rs/install@v0.1\n-  #     with:\n-  #       crate: cargo-audit\n-  #       use-tool-cache: true\n-\n-  #   - run: cargo audit\n-\n   rust:\n     name: Rust\n     runs-on: ${{ matrix.os }}\n@@ -84,15 +70,14 @@ jobs:\n     - name: Prepare cache\n       run: cargo xtask pre-cache\n \n-    - name: Prepare cache 2\n-      if: matrix.os == 'windows-latest'\n-      run: Remove-Item ./target/debug/xtask.exe, ./target/debug/deps/xtask.exe\n-\n-  # Weird target to catch non-portable code\n-  rust-power:\n-    name: Rust Power\n+  # Weird targets to catch non-portable code\n+  rust-cross:\n+    name: Rust Cross\n     runs-on: ubuntu-latest\n \n+    env:\n+      targets: \"powerpc-unknown-linux-gnu x86_64-unknown-linux-musl\"\n+\n     steps:\n     - name: Checkout repository\n       uses: actions/checkout@v2\n@@ -103,7 +88,9 @@ jobs:\n         toolchain: stable\n         profile: minimal\n         override: true\n-        target: 'powerpc-unknown-linux-gnu'\n+\n+    - name: Install Rust targets\n+      run: rustup target add ${{ env.targets }}\n \n     - name: Cache cargo directories\n       uses: actions/cache@v2\n@@ -114,14 +101,17 @@ jobs:\n         key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}\n \n     - name: Check\n-      run: cargo check --target=powerpc-unknown-linux-gnu --all-targets\n+      run: |\n+        for target in ${{ env.targets }}; do\n+          cargo check --target=$target --all-targets\n+        done\n \n   typescript:\n     name: TypeScript\n     strategy:\n       fail-fast: false\n       matrix:\n-        os: [ubuntu-latest, windows-latest, macos-latest]\n+        os: [ubuntu-latest, windows-latest]\n \n     runs-on: ${{ matrix.os }}\n "}, {"sha": "1f8e7a29d3298d305dd291cc695f3c2bf7309711", "filename": "Cargo.lock", "status": "modified", "additions": 410, "deletions": 417, "changes": 827, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -15,15 +15,6 @@ version = \"0.2.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ee2a4ec343196209d6594e19543ae87a39f96d5534d7174822a3ad825dd6ed7e\"\n \n-[[package]]\n-name = \"aho-corasick\"\n-version = \"0.7.13\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"043164d8ba5c4c3035fec9bbee8647c0261d788f3474306f93bb65901cae0e86\"\n-dependencies = [\n- \"memchr\",\n-]\n-\n [[package]]\n name = \"ansi_term\"\n version = \"0.12.1\"\n@@ -45,12 +36,33 @@ version = \"0.12.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"33954243bd79057c2de7338850b85983a44588021f8a5fee574a8888c6de4344\"\n \n+[[package]]\n+name = \"arena\"\n+version = \"0.0.0\"\n+\n [[package]]\n name = \"arrayvec\"\n version = \"0.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n \n+[[package]]\n+name = \"assists\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"base_db\",\n+ \"either\",\n+ \"hir\",\n+ \"ide_db\",\n+ \"itertools\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test_utils\",\n+ \"text_edit\",\n+]\n+\n [[package]]\n name = \"atty\"\n version = \"0.2.14\"\n@@ -64,9 +76,9 @@ dependencies = [\n \n [[package]]\n name = \"autocfg\"\n-version = \"1.0.0\"\n+version = \"1.0.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d\"\n+checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"backtrace\"\n@@ -88,6 +100,21 @@ version = \"0.12.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3441f0f7b02788e948e47f457ca01f1d7e6d92c693bc132c22b087d3141c03ff\"\n \n+[[package]]\n+name = \"base_db\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cfg\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"salsa\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test_utils\",\n+ \"tt\",\n+ \"vfs\",\n+]\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.2.1\"\n@@ -113,9 +140,19 @@ dependencies = [\n \n [[package]]\n name = \"cc\"\n-version = \"1.0.58\"\n+version = \"1.0.59\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f9a06fb2e53271d7c279ec1efea6ab691c35a2ae67ec0d91d7acec0caf13b518\"\n+checksum = \"66120af515773fb005778dc07c261bd201ec8ce50bd6e7144c927753fe013381\"\n+\n+[[package]]\n+name = \"cfg\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"mbe\",\n+ \"rustc-hash\",\n+ \"syntax\",\n+ \"tt\",\n+]\n \n [[package]]\n name = \"cfg-if\"\n@@ -125,9 +162,9 @@ checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.19.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"654c611946ba2629c5028cb7708687af975faf2c29d731824cb294c873df4697\"\n+checksum = \"c3cb438e961fd7f1183dc5e0bdcfd09253bf9b90592cf665d1ce6787d8a4908f\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -137,19 +174,19 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.19.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0a5341fbc654ca886b73b804a36aebf0e621057ccc1a68e9815b5b39b3ac9ae8\"\n+checksum = \"bb332abfcb015b148c6fbab39b1d13282745b0f7f312019dd8e138f5f3f0855d\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-recursive\"\n-version = \"0.19.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4484807b155b5a411e6135d330295f9ba5042e2920b8712c6574ca6ea91e9ee5\"\n+checksum = \"e7c7673f10c5fa1acf7fa07d4f4c5917cbcf161ed3a952d14530c79950de32d2\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -160,9 +197,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.19.0\"\n+version = \"0.23.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"281f82facd2538997fbe52132b1941ed213d266748215c31d15f62a8664429ad\"\n+checksum = \"802de4eff72e5a5d2828e6c07224c74d66949dc6308aff025d0ae2871a11b4eb\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -177,9 +214,9 @@ dependencies = [\n \n [[package]]\n name = \"chrono\"\n-version = \"0.4.13\"\n+version = \"0.4.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c74d84029116787153e02106bf53e66828452a4b325cc8652b788b5967c0a0b6\"\n+checksum = \"942f72db697d8767c22d46a598e01f2d3b475501ea43d0db4f16d90259182d0b\"\n dependencies = [\n  \"num-integer\",\n  \"num-traits\",\n@@ -279,15 +316,15 @@ checksum = \"524cbf6897b527295dff137cec09ecf3a05f4fddffd7dfcd1585403449e74198\"\n \n [[package]]\n name = \"drop_bomb\"\n-version = \"0.1.4\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"69b26e475fd29098530e709294e94e661974c851aed42512793f120fed4e199f\"\n+checksum = \"9bda8e21c04aca2ae33ffc2fd8c23134f3cac46db123ba97bd9d3f3b8a4a85e1\"\n \n [[package]]\n name = \"either\"\n-version = \"1.5.3\"\n+version = \"1.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb1f6b1ce1c140482ea30ddd3335fc0024ac7ee112895426e0a629a6c20adfe3\"\n+checksum = \"cd56b59865bce947ac5958779cfa508f6c3b9497cc762b7e24a12d11ccde2c4f\"\n \n [[package]]\n name = \"ena\"\n@@ -308,19 +345,20 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"expect\"\n+name = \"expect-test\"\n version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a3e383741ea1982866572109d1a8c807bd36aad91fca701489fdca56ef92b3b8\"\n dependencies = [\n  \"difference\",\n  \"once_cell\",\n- \"stdx\",\n ]\n \n [[package]]\n name = \"filetime\"\n-version = \"0.2.11\"\n+version = \"0.2.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e500da2fab70bdc43f8f0e0b350a227f31c72311c56aba48f01d5cd62bb0345b\"\n+checksum = \"3ed85775dcc68644b5c950ac06a2b23768d3bc9390464151aaf27136998dcf9e\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n@@ -336,9 +374,9 @@ checksum = \"37ab347416e802de484e4d03c7316c48f1ecb56574dfd4a46a80f173ce1de04d\"\n \n [[package]]\n name = \"flate2\"\n-version = \"1.0.16\"\n+version = \"1.0.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"68c90b0fc46cf89d227cc78b40e494ff81287a92dd07631e5af0d06fe3cf885e\"\n+checksum = \"766d0e77a2c1502169d4a93ff3b8c15a71fd946cd0126309752104e5f3c46d94\"\n dependencies = [\n  \"cfg-if\",\n  \"crc32fast\",\n@@ -348,14 +386,14 @@ dependencies = [\n \n [[package]]\n name = \"flycheck\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n dependencies = [\n  \"cargo_metadata\",\n  \"crossbeam-channel\",\n  \"jod-thread\",\n  \"log\",\n- \"ra_toolchain\",\n  \"serde_json\",\n+ \"toolchain\",\n ]\n \n [[package]]\n@@ -418,9 +456,9 @@ dependencies = [\n \n [[package]]\n name = \"hashbrown\"\n-version = \"0.8.1\"\n+version = \"0.8.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34f595585f103464d8d2f6e9864682d74c1601fed5e07d62b1c9058dba8246fb\"\n+checksum = \"e91b62f79061a0bc2e046024cb7ba44b08419ed238ecbd9adbd787434b9e8c25\"\n dependencies = [\n  \"autocfg\",\n ]\n@@ -443,6 +481,98 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"hir\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arrayvec\",\n+ \"base_db\",\n+ \"either\",\n+ \"hir_def\",\n+ \"hir_expand\",\n+ \"hir_ty\",\n+ \"itertools\",\n+ \"log\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"tt\",\n+ \"url\",\n+]\n+\n+[[package]]\n+name = \"hir_def\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"anymap\",\n+ \"arena\",\n+ \"base_db\",\n+ \"cfg\",\n+ \"drop_bomb\",\n+ \"either\",\n+ \"expect-test\",\n+ \"fst\",\n+ \"hir_expand\",\n+ \"indexmap\",\n+ \"itertools\",\n+ \"log\",\n+ \"mbe\",\n+ \"once_cell\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"smallvec\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test_utils\",\n+ \"tt\",\n+]\n+\n+[[package]]\n+name = \"hir_expand\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena\",\n+ \"base_db\",\n+ \"either\",\n+ \"log\",\n+ \"mbe\",\n+ \"parser\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"syntax\",\n+ \"test_utils\",\n+ \"tt\",\n+]\n+\n+[[package]]\n+name = \"hir_ty\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arena\",\n+ \"arrayvec\",\n+ \"base_db\",\n+ \"chalk-ir\",\n+ \"chalk-recursive\",\n+ \"chalk-solve\",\n+ \"ena\",\n+ \"expect-test\",\n+ \"hir_def\",\n+ \"hir_expand\",\n+ \"itertools\",\n+ \"log\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"scoped-tls\",\n+ \"smallvec\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test_utils\",\n+ \"tracing\",\n+ \"tracing-subscriber\",\n+ \"tracing-tree\",\n+]\n+\n [[package]]\n name = \"home\"\n version = \"0.5.3\"\n@@ -452,6 +582,51 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"ide\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"assists\",\n+ \"base_db\",\n+ \"cfg\",\n+ \"either\",\n+ \"expect-test\",\n+ \"hir\",\n+ \"ide_db\",\n+ \"indexmap\",\n+ \"itertools\",\n+ \"log\",\n+ \"oorandom\",\n+ \"profile\",\n+ \"pulldown-cmark\",\n+ \"pulldown-cmark-to-cmark\",\n+ \"rustc-hash\",\n+ \"ssr\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test_utils\",\n+ \"text_edit\",\n+]\n+\n+[[package]]\n+name = \"ide_db\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"base_db\",\n+ \"either\",\n+ \"fst\",\n+ \"hir\",\n+ \"log\",\n+ \"once_cell\",\n+ \"profile\",\n+ \"rayon\",\n+ \"rustc-hash\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test_utils\",\n+ \"text_edit\",\n+]\n+\n [[package]]\n name = \"idna\"\n version = \"0.2.0\"\n@@ -465,9 +640,9 @@ dependencies = [\n \n [[package]]\n name = \"indexmap\"\n-version = \"1.5.0\"\n+version = \"1.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5b88cd59ee5f71fea89a62248fc8f387d44400cefe05ef548466d61ced9029a7\"\n+checksum = \"86b45e59b16c76b11bf9738fd5d38879d3bd28ad292d7b313608becb17ae2df9\"\n dependencies = [\n  \"autocfg\",\n  \"hashbrown\",\n@@ -547,15 +722,15 @@ checksum = \"e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646\"\n \n [[package]]\n name = \"lazycell\"\n-version = \"1.2.1\"\n+version = \"1.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n+checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.74\"\n+version = \"0.2.76\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a2f02823cf78b754822df5f7f268fb59822e7296276d3e069d8e8cb26a14bd10\"\n+checksum = \"755456fae044e6fa1ebbbd1b3e902ae19e73097ed4ed87bb79934a867c007bc3\"\n \n [[package]]\n name = \"libloading\"\n@@ -568,9 +743,9 @@ dependencies = [\n \n [[package]]\n name = \"libmimalloc-sys\"\n-version = \"0.1.15\"\n+version = \"0.1.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a27252ec1d0c4e0dd6142cbc572da50b363ab56fc334f7aa8fadf295b2e24e74\"\n+checksum = \"677c4be79b14bd72496b87789b702ba02cd1a9f16a59369fe847082fd03efd88\"\n dependencies = [\n  \"cmake\",\n ]\n@@ -595,9 +770,9 @@ dependencies = [\n \n [[package]]\n name = \"lsp-server\"\n-version = \"0.3.3\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53b4ace8ebe5d2aff3687ce0ed507f6020d6a47a7de2b0d3d664ea237ffb0c62\"\n+checksum = \"87fce8851309a325974ec76efe7c9d954d152c9ff4fded6520eb3c96d0aa3a96\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"log\",\n@@ -640,6 +815,19 @@ version = \"2.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"60302e4db3a61da70c0cb7991976248362f30319e88850c487b9b95bbf059e00\"\n \n+[[package]]\n+name = \"mbe\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"parser\",\n+ \"rustc-hash\",\n+ \"smallvec\",\n+ \"syntax\",\n+ \"test_utils\",\n+ \"tt\",\n+]\n+\n [[package]]\n name = \"memchr\"\n version = \"2.3.3\"\n@@ -667,9 +855,9 @@ dependencies = [\n \n [[package]]\n name = \"mimalloc\"\n-version = \"0.1.19\"\n+version = \"0.1.20\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6c52de2069999f01bd26436564dbe7de3a87898feeb7a0d0ff9eb20a05bb7ca0\"\n+checksum = \"00759bcf69082fa629ae8823fcc72f7454a90c6476110297a1ae5fb3a559e474\"\n dependencies = [\n  \"libmimalloc-sys\",\n ]\n@@ -794,9 +982,9 @@ checksum = \"1ab52be62400ca80aa00285d25253d7f7c437b7375c4de678f5405d3afe82ca5\"\n \n [[package]]\n name = \"once_cell\"\n-version = \"1.4.0\"\n+version = \"1.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0b631f7e854af39a1739f401cf34a8a013dfe09eac4fa4dba91e9768bd28168d\"\n+checksum = \"260e51e7efe62b592207e9e13a68e43692a7a279171d6ba57abd208bf23645ad\"\n \n [[package]]\n name = \"oorandom\"\n@@ -830,9 +1018,16 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"parser\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"drop_bomb\",\n+]\n+\n [[package]]\n name = \"paths\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n \n [[package]]\n name = \"percent-encoding\"\n@@ -842,19 +1037,19 @@ checksum = \"d4fd5641d01c8f18a23da7b6fe29298ff4b55afcccdf78973b24cf3175fee32e\"\n \n [[package]]\n name = \"perf-event\"\n-version = \"0.4.4\"\n+version = \"0.4.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"76c42ba5d85a2f4472b99f475fb60cf336d9b4c85b1ea8bb300fef2e3c7c8f89\"\n+checksum = \"273069d0b956939ba75e8b5663328b9b7f0dc2e262b3306c6be66c4d87e2240a\"\n dependencies = [\n  \"libc\",\n  \"perf-event-open-sys\",\n ]\n \n [[package]]\n name = \"perf-event-open-sys\"\n-version = \"0.3.1\"\n+version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"95db63e37862bc1b842135d2234ef9418f222cc660c6752f45e7cf9ddfb97f96\"\n+checksum = \"66f37842e29d92d05872a3c0271ba6717842695ecb896cb2e147a825c804b207\"\n dependencies = [\n  \"libc\",\n ]\n@@ -871,9 +1066,9 @@ dependencies = [\n \n [[package]]\n name = \"pico-args\"\n-version = \"0.3.3\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1b1eee8b1f4966c8343d7ca0f5a8452cd35d5610a2e0efbe2a68cae44bef2046\"\n+checksum = \"28b9b4df73455c861d7cbf8be42f01d3b373ed7f02e378d55fa84eafc6f638b1\"\n \n [[package]]\n name = \"plain\"\n@@ -891,362 +1086,97 @@ dependencies = [\n ]\n \n [[package]]\n-name = \"pulldown-cmark\"\n-version = \"0.7.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ca36dea94d187597e104a5c8e4b07576a8a45aa5db48a65e12940d3eb7461f55\"\n-dependencies = [\n- \"bitflags\",\n- \"memchr\",\n- \"unicase\",\n-]\n-\n-[[package]]\n-name = \"pulldown-cmark-to-cmark\"\n-version = \"5.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"32accf4473121d8c0b508ca5673363703762d6cc59cf25af1df48f653346f736\"\n-dependencies = [\n- \"pulldown-cmark\",\n-]\n-\n-[[package]]\n-name = \"quote\"\n-version = \"1.0.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"aa563d17ecb180e500da1cfd2b028310ac758de548efdd203e18f283af693f37\"\n-dependencies = [\n- \"proc-macro2\",\n-]\n-\n-[[package]]\n-name = \"ra_arena\"\n-version = \"0.1.0\"\n-\n-[[package]]\n-name = \"ra_assists\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"either\",\n- \"itertools\",\n- \"ra_db\",\n- \"ra_fmt\",\n- \"ra_hir\",\n- \"ra_ide_db\",\n- \"ra_prof\",\n- \"ra_syntax\",\n- \"ra_text_edit\",\n- \"rustc-hash\",\n- \"stdx\",\n- \"test_utils\",\n-]\n-\n-[[package]]\n-name = \"ra_cfg\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"ra_mbe\",\n- \"ra_syntax\",\n- \"ra_tt\",\n- \"rustc-hash\",\n-]\n-\n-[[package]]\n-name = \"ra_db\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"ra_cfg\",\n- \"ra_prof\",\n- \"ra_syntax\",\n- \"ra_tt\",\n- \"rustc-hash\",\n- \"salsa\",\n- \"stdx\",\n- \"test_utils\",\n- \"vfs\",\n-]\n-\n-[[package]]\n-name = \"ra_fmt\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"itertools\",\n- \"ra_syntax\",\n-]\n-\n-[[package]]\n-name = \"ra_hir\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"arrayvec\",\n- \"either\",\n- \"itertools\",\n- \"log\",\n- \"ra_db\",\n- \"ra_hir_def\",\n- \"ra_hir_expand\",\n- \"ra_hir_ty\",\n- \"ra_prof\",\n- \"ra_syntax\",\n- \"ra_tt\",\n- \"rustc-hash\",\n- \"stdx\",\n- \"url\",\n-]\n-\n-[[package]]\n-name = \"ra_hir_def\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"anymap\",\n- \"drop_bomb\",\n- \"either\",\n- \"expect\",\n- \"fst\",\n- \"indexmap\",\n- \"itertools\",\n- \"log\",\n- \"once_cell\",\n- \"ra_arena\",\n- \"ra_cfg\",\n- \"ra_db\",\n- \"ra_hir_expand\",\n- \"ra_mbe\",\n- \"ra_prof\",\n- \"ra_syntax\",\n- \"ra_tt\",\n- \"rustc-hash\",\n- \"smallvec\",\n- \"stdx\",\n- \"test_utils\",\n-]\n-\n-[[package]]\n-name = \"ra_hir_expand\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"either\",\n- \"log\",\n- \"ra_arena\",\n- \"ra_db\",\n- \"ra_mbe\",\n- \"ra_parser\",\n- \"ra_prof\",\n- \"ra_syntax\",\n- \"ra_tt\",\n- \"rustc-hash\",\n- \"test_utils\",\n-]\n-\n-[[package]]\n-name = \"ra_hir_ty\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"arrayvec\",\n- \"chalk-ir\",\n- \"chalk-recursive\",\n- \"chalk-solve\",\n- \"ena\",\n- \"expect\",\n- \"itertools\",\n- \"log\",\n- \"ra_arena\",\n- \"ra_db\",\n- \"ra_hir_def\",\n- \"ra_hir_expand\",\n- \"ra_prof\",\n- \"ra_syntax\",\n- \"rustc-hash\",\n- \"scoped-tls\",\n- \"smallvec\",\n- \"stdx\",\n- \"test_utils\",\n- \"tracing\",\n- \"tracing-subscriber\",\n- \"tracing-tree\",\n-]\n-\n-[[package]]\n-name = \"ra_ide\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"either\",\n- \"expect\",\n- \"indexmap\",\n- \"itertools\",\n- \"log\",\n- \"oorandom\",\n- \"pulldown-cmark\",\n- \"pulldown-cmark-to-cmark\",\n- \"ra_assists\",\n- \"ra_cfg\",\n- \"ra_db\",\n- \"ra_fmt\",\n- \"ra_hir\",\n- \"ra_ide_db\",\n- \"ra_prof\",\n- \"ra_ssr\",\n- \"ra_syntax\",\n- \"ra_text_edit\",\n- \"rustc-hash\",\n- \"stdx\",\n- \"test_utils\",\n-]\n-\n-[[package]]\n-name = \"ra_ide_db\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"either\",\n- \"fst\",\n- \"log\",\n- \"once_cell\",\n- \"ra_db\",\n- \"ra_hir\",\n- \"ra_prof\",\n- \"ra_syntax\",\n- \"ra_text_edit\",\n- \"rayon\",\n- \"rustc-hash\",\n- \"stdx\",\n- \"test_utils\",\n-]\n-\n-[[package]]\n-name = \"ra_mbe\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"log\",\n- \"ra_parser\",\n- \"ra_syntax\",\n- \"ra_tt\",\n- \"rustc-hash\",\n- \"smallvec\",\n- \"test_utils\",\n-]\n-\n-[[package]]\n-name = \"ra_parser\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"drop_bomb\",\n-]\n-\n-[[package]]\n-name = \"ra_proc_macro\"\n-version = \"0.1.0\"\n+name = \"proc_macro_api\"\n+version = \"0.0.0\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"jod-thread\",\n  \"log\",\n- \"ra_tt\",\n  \"serde\",\n  \"serde_json\",\n+ \"tt\",\n ]\n \n [[package]]\n-name = \"ra_proc_macro_srv\"\n-version = \"0.1.0\"\n+name = \"proc_macro_srv\"\n+version = \"0.0.0\"\n dependencies = [\n  \"cargo_metadata\",\n  \"difference\",\n  \"goblin\",\n  \"libloading\",\n+ \"mbe\",\n  \"memmap\",\n- \"ra_mbe\",\n- \"ra_proc_macro\",\n- \"ra_toolchain\",\n- \"ra_tt\",\n+ \"proc_macro_api\",\n+ \"proc_macro_test\",\n  \"serde_derive\",\n  \"test_utils\",\n+ \"toolchain\",\n+ \"tt\",\n ]\n \n [[package]]\n-name = \"ra_prof\"\n-version = \"0.1.0\"\n+name = \"proc_macro_test\"\n+version = \"0.0.0\"\n+\n+[[package]]\n+name = \"profile\"\n+version = \"0.0.0\"\n dependencies = [\n+ \"arena\",\n  \"backtrace\",\n  \"cfg-if\",\n  \"libc\",\n  \"once_cell\",\n  \"perf-event\",\n- \"ra_arena\",\n ]\n \n [[package]]\n-name = \"ra_project_model\"\n-version = \"0.1.0\"\n+name = \"project_model\"\n+version = \"0.0.0\"\n dependencies = [\n  \"anyhow\",\n+ \"arena\",\n+ \"base_db\",\n  \"cargo_metadata\",\n+ \"cfg\",\n  \"log\",\n  \"paths\",\n- \"ra_arena\",\n- \"ra_cfg\",\n- \"ra_db\",\n- \"ra_proc_macro\",\n- \"ra_toolchain\",\n+ \"proc_macro_api\",\n  \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n  \"stdx\",\n+ \"toolchain\",\n ]\n \n [[package]]\n-name = \"ra_ssr\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"expect\",\n- \"ra_db\",\n- \"ra_hir\",\n- \"ra_ide_db\",\n- \"ra_syntax\",\n- \"ra_text_edit\",\n- \"rustc-hash\",\n- \"test_utils\",\n-]\n-\n-[[package]]\n-name = \"ra_syntax\"\n-version = \"0.1.0\"\n-dependencies = [\n- \"arrayvec\",\n- \"expect\",\n- \"itertools\",\n- \"once_cell\",\n- \"ra_parser\",\n- \"ra_text_edit\",\n- \"rayon\",\n- \"rowan\",\n- \"rustc-ap-rustc_lexer\",\n- \"rustc-hash\",\n- \"serde\",\n- \"smol_str\",\n- \"stdx\",\n- \"test_utils\",\n- \"walkdir\",\n-]\n-\n-[[package]]\n-name = \"ra_text_edit\"\n-version = \"0.1.0\"\n+name = \"pulldown-cmark\"\n+version = \"0.7.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ca36dea94d187597e104a5c8e4b07576a8a45aa5db48a65e12940d3eb7461f55\"\n dependencies = [\n- \"text-size\",\n+ \"bitflags\",\n+ \"memchr\",\n+ \"unicase\",\n ]\n \n [[package]]\n-name = \"ra_toolchain\"\n-version = \"0.1.0\"\n+name = \"pulldown-cmark-to-cmark\"\n+version = \"5.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"32accf4473121d8c0b508ca5673363703762d6cc59cf25af1df48f653346f736\"\n dependencies = [\n- \"home\",\n+ \"pulldown-cmark\",\n ]\n \n [[package]]\n-name = \"ra_tt\"\n-version = \"0.1.0\"\n+name = \"quote\"\n+version = \"1.0.7\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aa563d17ecb180e500da1cfd2b028310ac758de548efdd203e18f283af693f37\"\n dependencies = [\n- \"smol_str\",\n- \"stdx\",\n+ \"proc-macro2\",\n ]\n \n [[package]]\n@@ -1286,10 +1216,7 @@ version = \"1.3.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9c3780fcf44b193bc4d09f36d2a3c87b251da4a046c87795a0d35f4f927ad8e6\"\n dependencies = [\n- \"aho-corasick\",\n- \"memchr\",\n  \"regex-syntax\",\n- \"thread_local\",\n ]\n \n [[package]]\n@@ -1322,55 +1249,55 @@ dependencies = [\n \n [[package]]\n name = \"rust-analyzer\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n dependencies = [\n  \"anyhow\",\n+ \"base_db\",\n+ \"cfg\",\n  \"crossbeam-channel\",\n  \"env_logger\",\n- \"expect\",\n+ \"expect-test\",\n  \"flycheck\",\n+ \"hir\",\n+ \"hir_def\",\n+ \"hir_ty\",\n+ \"ide\",\n+ \"ide_db\",\n  \"itertools\",\n  \"jod-thread\",\n  \"log\",\n  \"lsp-server\",\n  \"lsp-types\",\n+ \"mbe\",\n  \"mimalloc\",\n  \"oorandom\",\n  \"parking_lot\",\n  \"pico-args\",\n- \"ra_cfg\",\n- \"ra_db\",\n- \"ra_hir\",\n- \"ra_hir_def\",\n- \"ra_hir_ty\",\n- \"ra_ide\",\n- \"ra_ide_db\",\n- \"ra_mbe\",\n- \"ra_proc_macro_srv\",\n- \"ra_prof\",\n- \"ra_project_model\",\n- \"ra_ssr\",\n- \"ra_syntax\",\n- \"ra_text_edit\",\n- \"ra_toolchain\",\n- \"ra_tt\",\n+ \"proc_macro_srv\",\n+ \"profile\",\n+ \"project_model\",\n  \"rayon\",\n  \"rustc-hash\",\n  \"serde\",\n  \"serde_json\",\n+ \"ssr\",\n  \"stdx\",\n+ \"syntax\",\n  \"test_utils\",\n+ \"text_edit\",\n  \"threadpool\",\n+ \"toolchain\",\n+ \"tt\",\n  \"vfs\",\n  \"vfs-notify\",\n  \"winapi 0.3.9\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"671.0.0\"\n+version = \"673.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"22e1221f3bfa2943c942cf8da319ab2346887f8757778c29c7f1822cd27b521f\"\n+checksum = \"f6b71fa1285bdefe5fb61e59b63d6cc246abf337f4acafdd620d721bc488e671\"\n dependencies = [\n  \"unicode-xid\",\n ]\n@@ -1395,9 +1322,9 @@ checksum = \"71d301d4193d031abdd79ff7e3dd721168a9572ef3fe51a1517aba235bd8f86e\"\n \n [[package]]\n name = \"salsa\"\n-version = \"0.15.1\"\n+version = \"0.15.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d4cdc109fcc9e9450c7ef47fb7474e99bffd51799da03ed0a6c7f0e2cb3848a6\"\n+checksum = \"9ab29056d4fb4048a5f0d169c9b6e5526160c9ec37aded5a6879c2c9c445a8e4\"\n dependencies = [\n  \"crossbeam-utils\",\n  \"indexmap\",\n@@ -1412,9 +1339,9 @@ dependencies = [\n \n [[package]]\n name = \"salsa-macros\"\n-version = \"0.15.0\"\n+version = \"0.15.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2c280ac85b15ac214b86ac4b407626a48e6a1c4f90769a582fec74aa57942b9f\"\n+checksum = \"a1c3aec007c63c4ed4cd7a018529fb0b5575c4562575fc6a40d6cd2ae0b792ef\"\n dependencies = [\n  \"heck\",\n  \"proc-macro2\",\n@@ -1481,18 +1408,18 @@ checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n [[package]]\n name = \"serde\"\n-version = \"1.0.114\"\n+version = \"1.0.115\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5317f7588f0a5078ee60ef675ef96735a1442132dc645eb1d12c018620ed8cd3\"\n+checksum = \"e54c9a88f2da7238af84b5101443f0c0d0a3bbdc455e34a5c9497b1903ed55d5\"\n dependencies = [\n  \"serde_derive\",\n ]\n \n [[package]]\n name = \"serde_derive\"\n-version = \"1.0.114\"\n+version = \"1.0.115\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2a0be94b04690fbaed37cddffc5c134bf537c8e3329d53e982fe04c374978f8e\"\n+checksum = \"609feed1d0a73cc36a0182a840a9b37b4a82f0b1150369f0536a9e3f2a31dc48\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1538,9 +1465,9 @@ checksum = \"c111b5bd5695e56cffe5129854aa230b39c93a305372fdbb2668ca2394eea9f8\"\n \n [[package]]\n name = \"smallvec\"\n-version = \"1.4.1\"\n+version = \"1.4.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3757cb9d89161a2f24e1cf78efa0c1fcff485d18e3f55e0aa3480824ddaa0f3f\"\n+checksum = \"fbee7696b84bbf3d89a1c2eccff0850e3047ed46bfcd2e92c29a2d074d57e252\"\n \n [[package]]\n name = \"smol_str\"\n@@ -1551,15 +1478,30 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"ssr\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"base_db\",\n+ \"expect-test\",\n+ \"hir\",\n+ \"ide_db\",\n+ \"itertools\",\n+ \"rustc-hash\",\n+ \"syntax\",\n+ \"test_utils\",\n+ \"text_edit\",\n+]\n+\n [[package]]\n name = \"stdx\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.36\"\n+version = \"1.0.38\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4cdb98bcb1f9d81d07b536179c269ea15999b5d14ea958196413869445bb5250\"\n+checksum = \"e69abc24912995b3038597a7a593be5053eb0fb44f3cc5beec0deb421790c1f4\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1578,6 +1520,27 @@ dependencies = [\n  \"unicode-xid\",\n ]\n \n+[[package]]\n+name = \"syntax\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"arrayvec\",\n+ \"expect-test\",\n+ \"itertools\",\n+ \"once_cell\",\n+ \"parser\",\n+ \"rayon\",\n+ \"rowan\",\n+ \"rustc-ap-rustc_lexer\",\n+ \"rustc-hash\",\n+ \"serde\",\n+ \"smol_str\",\n+ \"stdx\",\n+ \"test_utils\",\n+ \"text_edit\",\n+ \"walkdir\",\n+]\n+\n [[package]]\n name = \"termcolor\"\n version = \"1.1.0\"\n@@ -1589,7 +1552,7 @@ dependencies = [\n \n [[package]]\n name = \"test_utils\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n dependencies = [\n  \"difference\",\n  \"rustc-hash\",\n@@ -1604,6 +1567,13 @@ version = \"1.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"f03e7efdedc3bc78cb2337f1e2785c39e45f5ef762d9e4ebb137fff7380a6d8a\"\n \n+[[package]]\n+name = \"text_edit\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"text-size\",\n+]\n+\n [[package]]\n name = \"thin-dst\"\n version = \"1.1.0\"\n@@ -1640,15 +1610,22 @@ dependencies = [\n \n [[package]]\n name = \"tinyvec\"\n-version = \"0.3.3\"\n+version = \"0.3.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53953d2d3a5ad81d9f844a32f14ebb121f50b650cd59d0ee2a07cf13c617efed\"\n+checksum = \"238ce071d267c5710f9d31451efec16c5ee22de34df17cc05e56cbc92e967117\"\n+\n+[[package]]\n+name = \"toolchain\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"home\",\n+]\n \n [[package]]\n name = \"tracing\"\n-version = \"0.1.17\"\n+version = \"0.1.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"dbdf4ccd1652592b01286a5dbe1e2a77d78afaa34beadd9872a5f7396f92aaa9\"\n+checksum = \"6d79ca061b032d6ce30c660fded31189ca0b9922bf483cd70759f13a2d86786c\"\n dependencies = [\n  \"cfg-if\",\n  \"tracing-attributes\",\n@@ -1657,9 +1634,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-attributes\"\n-version = \"0.1.9\"\n+version = \"0.1.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f0693bf8d6f2bf22c690fc61a9d21ac69efdbb894a17ed596b9af0f01e64b84b\"\n+checksum = \"80e0ccfc3378da0cce270c946b676a376943f5cd16aeba64568e7939806f4ada\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -1668,9 +1645,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-core\"\n-version = \"0.1.11\"\n+version = \"0.1.14\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94ae75f0d28ae10786f3b1895c55fe72e79928fd5ccdebb5438c75e93fec178f\"\n+checksum = \"db63662723c316b43ca36d833707cc93dff82a02ba3d7e354f342682cc8b3545\"\n dependencies = [\n  \"lazy_static\",\n ]\n@@ -1698,9 +1675,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-subscriber\"\n-version = \"0.2.9\"\n+version = \"0.2.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e4f5dd7095c2481b7b3cbed71c8de53085fb3542bc3c2b4c73cba43e8f11c7ba\"\n+checksum = \"abd165311cc4d7a555ad11cc77a37756df836182db0d81aac908c8184c584f40\"\n dependencies = [\n  \"ansi_term\",\n  \"chrono\",\n@@ -1711,16 +1688,17 @@ dependencies = [\n  \"serde_json\",\n  \"sharded-slab\",\n  \"smallvec\",\n+ \"thread_local\",\n  \"tracing-core\",\n  \"tracing-log\",\n  \"tracing-serde\",\n ]\n \n [[package]]\n name = \"tracing-tree\"\n-version = \"0.1.4\"\n+version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"37ee7f0f53ed2093971a698db799ef56a2dfd89b32e3aeb5165f0e637a02be04\"\n+checksum = \"e1a3dc4774db3a6b2d66a4f8d8de670e874ec3ed55615860c994927419b32c5f\"\n dependencies = [\n  \"ansi_term\",\n  \"atty\",\n@@ -1730,11 +1708,19 @@ dependencies = [\n  \"tracing-subscriber\",\n ]\n \n+[[package]]\n+name = \"tt\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"smol_str\",\n+ \"stdx\",\n+]\n+\n [[package]]\n name = \"ungrammar\"\n-version = \"0.1.0\"\n+version = \"1.1.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0ee12e4891ab3acc2d95d5023022ace22020247bb8a8d1ece875a443f7dab37d\"\n+checksum = \"bab6142ac77be714b1ea78faca6efaed5478c50724786b0fe80d8528d10692b3\"\n \n [[package]]\n name = \"unicase\"\n@@ -1795,7 +1781,7 @@ checksum = \"b5a972e5669d67ba988ce3dc826706fb0a8b01471c088cb0b6110b805cc36aed\"\n \n [[package]]\n name = \"vfs\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n dependencies = [\n  \"fst\",\n  \"paths\",\n@@ -1804,7 +1790,7 @@ dependencies = [\n \n [[package]]\n name = \"vfs-notify\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n dependencies = [\n  \"crossbeam-channel\",\n  \"jod-thread\",\n@@ -1870,6 +1856,12 @@ version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\"\n \n+[[package]]\n+name = \"write-json\"\n+version = \"0.1.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"06069a848f95fceae3e5e03c0ddc8cb78452b56654ee0c8e68f938cf790fb9e3\"\n+\n [[package]]\n name = \"ws2_32-sys\"\n version = \"0.2.1\"\n@@ -1891,4 +1883,5 @@ dependencies = [\n  \"quote\",\n  \"ungrammar\",\n  \"walkdir\",\n+ \"write-json\",\n ]"}, {"sha": "218581d9d0ca16dbd6f8a376480697f9b218aac0", "filename": "Cargo.toml", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,37 +2,34 @@\n members = [ \"crates/*\", \"xtask/\" ]\n \n [profile.dev]\n-# disabling debug info speeds up builds a bunch,\n+# Disabling debug info speeds up builds a bunch,\n # and we don't rely on it for debugging that much.\n debug = 0\n \n+[profile.dev.package]\n+# These speed up local tests.\n+rowan.opt-level = 3\n+rustc-hash.opt-level = 3\n+smol_str.opt-level = 3\n+text-size.opt-level = 3\n+# This speeds up `cargo xtask dist`.\n+miniz_oxide.opt-level = 3\n+\n [profile.release]\n incremental = true\n-debug = 0 # set this to 1 or 2 to get more useful backtraces in debugger\n-\n-# ideally, we would use `build-override` here, but some crates are also\n-# needed at run-time and we end up compiling them twice\n-[profile.release.package.proc-macro2]\n-opt-level = 0\n-[profile.release.package.quote]\n-opt-level = 0\n-[profile.release.package.syn]\n-opt-level = 0\n-[profile.release.package.serde_derive]\n-opt-level = 0\n-[profile.release.package.chalk-derive]\n-opt-level = 0\n-[profile.release.package.salsa-macros]\n-opt-level = 0\n-[profile.release.package.tracing-attributes]\n-opt-level = 0\n-[profile.release.package.xtask]\n-opt-level = 0\n+debug = 0 # Set this to 1 or 2 to get more useful backtraces in debugger.\n \n-# Gzipping the artifacts is up to 10 times faster with optimizations (`cargo xtask dist`).\n-# `miniz_oxide` is the direct dependency of `flate2` which does all the heavy lifting\n-[profile.dev.package.miniz_oxide]\n-opt-level = 3\n+# Ideally, we would use `build-override` here, but some crates are also\n+# needed at run-time and we end up compiling them twice.\n+[profile.release.package]\n+chalk-derive.opt-level = 0\n+proc-macro2.opt-level = 0\n+quote.opt-level = 0\n+salsa-macros.opt-level = 0\n+serde_derive.opt-level = 0\n+syn.opt-level = 0\n+tracing-attributes.opt-level = 0\n+xtask.opt-level = 0\n \n [patch.'crates-io']\n # rowan = { path = \"../rowan\" }"}, {"sha": "264e4da7073013f5a6c5b83b88a7fc483e89b844", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -39,7 +39,7 @@ https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Frls-2.2E0\n \n * Website: https://rust-analyzer.github.io/\n * Metrics: https://rust-analyzer.github.io/metrics/\n-* API docs: https://rust-analyzer.github.io/rust-analyzer/ra_ide/\n+* API docs: https://rust-analyzer.github.io/rust-analyzer/ide/\n \n ## License\n "}, {"sha": "4c980a24d3d4839ce69f5e8ae435fd08c64e88e8", "filename": "bors.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/bors.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/bors.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bors.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,8 @@\n status = [\n     \"Rust (ubuntu-latest)\",\n     \"Rust (windows-latest)\",\n-    \"Rust (macos-latest)\",\n+    # \"Rust (macos-latest)\",\n     \"TypeScript (ubuntu-latest)\",\n     \"TypeScript (windows-latest)\",\n-    \"TypeScript (macos-latest)\",\n ]\n delete_merged_branches = true"}, {"sha": "f2bb5cc4567b7e158f70dc716a9da00201fb1507", "filename": "crates/arena/Cargo.toml", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Farena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Farena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Farena%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n [package]\n-edition = \"2018\"\n-name = \"ra_arena\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n+name = \"arena\"\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false", "previous_filename": "crates/ra_arena/Cargo.toml"}, {"sha": "3169aa5b8cc4d25f4f8a058784af309b3a144f46", "filename": "crates/arena/src/lib.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Farena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Farena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Farena%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_arena/src/lib.rs"}, {"sha": "0f33907c0aee2572d17c571ae2d0a0672be0f752", "filename": "crates/arena/src/map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Farena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Farena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Farena%2Fsrc%2Fmap.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_arena/src/map.rs"}, {"sha": "a560a35c7e8942f42ad2ab2f78a3319fa83de448", "filename": "crates/assists/Cargo.toml", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -0,0 +1,23 @@\n+[package]\n+name = \"assists\"\n+version = \"0.0.0\"\n+license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+rustc-hash = \"1.1.0\"\n+itertools = \"0.9.0\"\n+either = \"1.5.3\"\n+\n+stdx = { path = \"../stdx\" }\n+syntax = { path = \"../syntax\" }\n+text_edit = { path = \"../text_edit\" }\n+profile = { path = \"../profile\" }\n+base_db = { path = \"../base_db\" }\n+ide_db = { path = \"../ide_db\" }\n+hir = { path = \"../hir\" }\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "cda2abfb9c2fdf49ff322a248c8bf30729150cf0", "filename": "crates/assists/src/assist_config.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fassist_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fassist_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fassist_config.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_assists/src/assist_config.rs"}, {"sha": "11c171fc2d6f5b3bcafd6aaa814517c411fe6d0d", "filename": "crates/assists/src/assist_context.rs", "status": "renamed", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fassist_context.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,19 +3,19 @@\n use std::mem;\n \n use algo::find_covering_element;\n+use base_db::{FileId, FileRange};\n use hir::Semantics;\n-use ra_db::{FileId, FileRange};\n-use ra_fmt::{leading_indent, reindent};\n-use ra_ide_db::{\n+use ide_db::{\n+    label::Label,\n     source_change::{SourceChange, SourceFileEdit},\n     RootDatabase,\n };\n-use ra_syntax::{\n+use syntax::{\n     algo::{self, find_node_at_offset, SyntaxRewriter},\n-    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxNode, SyntaxToken, TextRange, TextSize,\n+    AstNode, SourceFile, SyntaxElement, SyntaxKind, SyntaxToken, TextRange, TextSize,\n     TokenAtOffset,\n };\n-use ra_text_edit::TextEditBuilder;\n+use text_edit::{TextEdit, TextEditBuilder};\n \n use crate::{\n     assist_config::{AssistConfig, SnippetCap},\n@@ -73,6 +73,10 @@ impl<'a> AssistContext<'a> {\n         self.sema.db\n     }\n \n+    pub(crate) fn source_file(&self) -> &SourceFile {\n+        &self.source_file\n+    }\n+\n     // NB, this ignores active selection.\n     pub(crate) fn offset(&self) -> TextSize {\n         self.frange.range.start()\n@@ -154,8 +158,9 @@ impl Assists {\n         if !self.is_allowed(&id) {\n             return None;\n         }\n-        let label = Assist::new(id, label.into(), None, target);\n-        self.add_impl(label, f)\n+        let label = Label::new(label.into());\n+        let assist = Assist { id, label, group: None, target };\n+        self.add_impl(assist, f)\n     }\n \n     pub(crate) fn add_group(\n@@ -169,12 +174,12 @@ impl Assists {\n         if !self.is_allowed(&id) {\n             return None;\n         }\n-\n-        let label = Assist::new(id, label.into(), Some(group.clone()), target);\n-        self.add_impl(label, f)\n+        let label = Label::new(label.into());\n+        let assist = Assist { id, label, group: Some(group.clone()), target };\n+        self.add_impl(assist, f)\n     }\n \n-    fn add_impl(&mut self, label: Assist, f: impl FnOnce(&mut AssistBuilder)) -> Option<()> {\n+    fn add_impl(&mut self, assist: Assist, f: impl FnOnce(&mut AssistBuilder)) -> Option<()> {\n         let source_change = if self.resolve {\n             let mut builder = AssistBuilder::new(self.file);\n             f(&mut builder);\n@@ -183,7 +188,7 @@ impl Assists {\n             None\n         };\n \n-        self.buf.push((label, source_change));\n+        self.buf.push((assist, source_change));\n         Some(())\n     }\n \n@@ -210,7 +215,7 @@ pub(crate) struct AssistBuilder {\n impl AssistBuilder {\n     pub(crate) fn new(file_id: FileId) -> AssistBuilder {\n         AssistBuilder {\n-            edit: TextEditBuilder::default(),\n+            edit: TextEdit::builder(),\n             file_id,\n             is_snippet: false,\n             change: SourceChange::default(),\n@@ -265,20 +270,6 @@ impl AssistBuilder {\n     pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n         algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n     }\n-    /// Replaces specified `node` of text with a given string, reindenting the\n-    /// string to maintain `node`'s existing indent.\n-    // FIXME: remove in favor of ra_syntax::edit::IndentLevel::increase_indent\n-    pub(crate) fn replace_node_and_indent(\n-        &mut self,\n-        node: &SyntaxNode,\n-        replace_with: impl Into<String>,\n-    ) {\n-        let mut replace_with = replace_with.into();\n-        if let Some(indent) = leading_indent(node) {\n-            replace_with = reindent(&replace_with, &indent)\n-        }\n-        self.replace(node.text_range(), replace_with)\n-    }\n     pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n         let node = rewriter.rewrite_root().unwrap();\n         let new = rewriter.rewrite(&node);", "previous_filename": "crates/ra_assists/src/assist_context.rs"}, {"sha": "5216862ba52d2f767ba0a3350f7d8d1e88d2bc93", "filename": "crates/assists/src/ast_transform.rs", "status": "renamed", "additions": 40, "deletions": 46, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fast_transform.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,13 +2,24 @@\n use rustc_hash::FxHashMap;\n \n use hir::{HirDisplay, PathResolution, SemanticsScope};\n-use ra_syntax::{\n+use syntax::{\n     algo::SyntaxRewriter,\n     ast::{self, AstNode},\n };\n \n+pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n+    SyntaxRewriter::from_fn(|element| match element {\n+        syntax::SyntaxElement::Node(n) => {\n+            let replacement = transformer.get_substitution(&n)?;\n+            Some(replacement.into())\n+        }\n+        _ => None,\n+    })\n+    .rewrite_ast(&node)\n+}\n+\n pub trait AstTransform<'a> {\n-    fn get_substitution(&self, node: &ra_syntax::SyntaxNode) -> Option<ra_syntax::SyntaxNode>;\n+    fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode>;\n \n     fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a>;\n     fn or<T: AstTransform<'a> + 'a>(self, other: T) -> Box<dyn AstTransform<'a> + 'a>\n@@ -22,7 +33,7 @@ pub trait AstTransform<'a> {\n struct NullTransformer;\n \n impl<'a> AstTransform<'a> for NullTransformer {\n-    fn get_substitution(&self, _node: &ra_syntax::SyntaxNode) -> Option<ra_syntax::SyntaxNode> {\n+    fn get_substitution(&self, _node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n         None\n     }\n     fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n@@ -32,7 +43,7 @@ impl<'a> AstTransform<'a> for NullTransformer {\n \n pub struct SubstituteTypeParams<'a> {\n     source_scope: &'a SemanticsScope<'a>,\n-    substs: FxHashMap<hir::TypeParam, ast::TypeRef>,\n+    substs: FxHashMap<hir::TypeParam, ast::Type>,\n     previous: Box<dyn AstTransform<'a> + 'a>,\n }\n \n@@ -51,7 +62,7 @@ impl<'a> SubstituteTypeParams<'a> {\n             // this is a trait impl, so we need to skip the first type parameter -- this is a bit hacky\n             .skip(1)\n             // The actual list of trait type parameters may be longer than the one\n-            // used in the `impl` block due to trailing default type parametrs.\n+            // used in the `impl` block due to trailing default type parameters.\n             // For that case we extend the `substs` with an empty iterator so we\n             // can still hit those trailing values and check if they actually have\n             // a default type. If they do, go for that type from `hir` to `ast` so\n@@ -63,7 +74,7 @@ impl<'a> SubstituteTypeParams<'a> {\n                     let default = k.default(source_scope.db)?;\n                     Some((\n                         k,\n-                        ast::make::type_ref(\n+                        ast::make::ty(\n                             &default\n                                 .display_source_code(source_scope.db, source_scope.module()?.into())\n                                 .ok()?,\n@@ -79,35 +90,35 @@ impl<'a> SubstituteTypeParams<'a> {\n         };\n \n         // FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n-        // trait ref, and then go from the types in the substs back to the syntax)\n-        fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::TypeRef>> {\n-            let target_trait = impl_def.target_trait()?;\n+        // trait ref, and then go from the types in the substs back to the syntax).\n+        fn get_syntactic_substs(impl_def: ast::Impl) -> Option<Vec<ast::Type>> {\n+            let target_trait = impl_def.trait_()?;\n             let path_type = match target_trait {\n-                ast::TypeRef::PathType(path) => path,\n+                ast::Type::PathType(path) => path,\n                 _ => return None,\n             };\n-            let type_arg_list = path_type.path()?.segment()?.type_arg_list()?;\n+            let generic_arg_list = path_type.path()?.segment()?.generic_arg_list()?;\n+\n             let mut result = Vec::new();\n-            for type_arg in type_arg_list.type_args() {\n-                let type_arg: ast::TypeArg = type_arg;\n-                result.push(type_arg.type_ref()?);\n+            for generic_arg in generic_arg_list.generic_args() {\n+                match generic_arg {\n+                    ast::GenericArg::TypeArg(type_arg) => result.push(type_arg.ty()?),\n+                    ast::GenericArg::AssocTypeArg(_)\n+                    | ast::GenericArg::LifetimeArg(_)\n+                    | ast::GenericArg::ConstArg(_) => (),\n+                }\n             }\n+\n             Some(result)\n         }\n     }\n-    fn get_substitution_inner(\n-        &self,\n-        node: &ra_syntax::SyntaxNode,\n-    ) -> Option<ra_syntax::SyntaxNode> {\n-        let type_ref = ast::TypeRef::cast(node.clone())?;\n+    fn get_substitution_inner(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n+        let type_ref = ast::Type::cast(node.clone())?;\n         let path = match &type_ref {\n-            ast::TypeRef::PathType(path_type) => path_type.path()?,\n+            ast::Type::PathType(path_type) => path_type.path()?,\n             _ => return None,\n         };\n-        // FIXME: use `hir::Path::from_src` instead.\n-        #[allow(deprecated)]\n-        let path = hir::Path::from_ast(path)?;\n-        let resolution = self.source_scope.resolve_hir_path(&path)?;\n+        let resolution = self.source_scope.speculative_resolve(&path)?;\n         match resolution {\n             hir::PathResolution::TypeParam(tp) => Some(self.substs.get(&tp)?.syntax().clone()),\n             _ => None,\n@@ -116,7 +127,7 @@ impl<'a> SubstituteTypeParams<'a> {\n }\n \n impl<'a> AstTransform<'a> for SubstituteTypeParams<'a> {\n-    fn get_substitution(&self, node: &ra_syntax::SyntaxNode) -> Option<ra_syntax::SyntaxNode> {\n+    fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n         self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))\n     }\n     fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n@@ -135,29 +146,23 @@ impl<'a> QualifyPaths<'a> {\n         Self { target_scope, source_scope, previous: Box::new(NullTransformer) }\n     }\n \n-    fn get_substitution_inner(\n-        &self,\n-        node: &ra_syntax::SyntaxNode,\n-    ) -> Option<ra_syntax::SyntaxNode> {\n+    fn get_substitution_inner(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n         // FIXME handle value ns?\n         let from = self.target_scope.module()?;\n         let p = ast::Path::cast(node.clone())?;\n         if p.segment().and_then(|s| s.param_list()).is_some() {\n             // don't try to qualify `Fn(Foo) -> Bar` paths, they are in prelude anyway\n             return None;\n         }\n-        // FIXME: use `hir::Path::from_src` instead.\n-        #[allow(deprecated)]\n-        let hir_path = hir::Path::from_ast(p.clone());\n-        let resolution = self.source_scope.resolve_hir_path(&hir_path?)?;\n+        let resolution = self.source_scope.speculative_resolve(&p)?;\n         match resolution {\n             PathResolution::Def(def) => {\n                 let found_path = from.find_use_path(self.source_scope.db.upcast(), def)?;\n                 let mut path = path_to_ast(found_path);\n \n                 let type_args = p\n                     .segment()\n-                    .and_then(|s| s.type_arg_list())\n+                    .and_then(|s| s.generic_arg_list())\n                     .map(|arg_list| apply(self, arg_list));\n                 if let Some(type_args) = type_args {\n                     let last_segment = path.segment().unwrap();\n@@ -175,19 +180,8 @@ impl<'a> QualifyPaths<'a> {\n     }\n }\n \n-pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n-    SyntaxRewriter::from_fn(|element| match element {\n-        ra_syntax::SyntaxElement::Node(n) => {\n-            let replacement = transformer.get_substitution(&n)?;\n-            Some(replacement.into())\n-        }\n-        _ => None,\n-    })\n-    .rewrite_ast(&node)\n-}\n-\n impl<'a> AstTransform<'a> for QualifyPaths<'a> {\n-    fn get_substitution(&self, node: &ra_syntax::SyntaxNode) -> Option<ra_syntax::SyntaxNode> {\n+    fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n         self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))\n     }\n     fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {", "previous_filename": "crates/ra_assists/src/ast_transform.rs"}, {"sha": "8757fa33f262e7616b88937c9d2dfebeaeea8ea0", "filename": "crates/assists/src/handlers/add_custom_impl.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,10 +1,10 @@\n-use ra_syntax::{\n+use itertools::Itertools;\n+use syntax::{\n     ast::{self, AstNode},\n     Direction, SmolStr,\n     SyntaxKind::{IDENT, WHITESPACE},\n     TextRange, TextSize,\n };\n-use stdx::SepBy;\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n@@ -61,9 +61,9 @@ pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<\n             .filter(|t| t != trait_token.text())\n             .collect::<Vec<SmolStr>>();\n         let has_more_derives = !new_attr_input.is_empty();\n-        let new_attr_input = new_attr_input.iter().sep_by(\", \").surround_with(\"(\", \")\").to_string();\n \n         if has_more_derives {\n+            let new_attr_input = format!(\"({})\", new_attr_input.iter().format(\", \"));\n             builder.replace(input.syntax().text_range(), new_attr_input);\n         } else {\n             let attr_range = attr.syntax().text_range();", "previous_filename": "crates/ra_assists/src/handlers/add_custom_impl.rs"}, {"sha": "563cbf505f46ca49f8fcc893be4637692ce5c8d8", "filename": "crates/assists/src/handlers/add_explicit_type.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,5 @@\n use hir::HirDisplay;\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode, LetStmt, NameOwner},\n     TextRange,\n };\n@@ -27,7 +27,7 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     let expr = let_stmt.initializer()?;\n     // Must be a binding\n     let pat = match let_stmt.pat()? {\n-        ast::Pat::BindPat(bind_pat) => bind_pat,\n+        ast::Pat::IdentPat(bind_pat) => bind_pat,\n         _ => return None,\n     };\n     let pat_range = pat.syntax().text_range();\n@@ -46,7 +46,7 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext) -> Optio\n     // and it has no placeholders\n     let ascribed_ty = let_stmt.ty();\n     if let Some(ty) = &ascribed_ty {\n-        if ty.syntax().descendants().find_map(ast::PlaceholderType::cast).is_none() {\n+        if ty.syntax().descendants().find_map(ast::InferType::cast).is_none() {\n             return None;\n         }\n     }", "previous_filename": "crates/ra_assists/src/handlers/add_explicit_type.rs"}, {"sha": "83a2ada9a288f42d6518235145087d452cd7ee74", "filename": "crates/assists/src/handlers/add_missing_impl_members.rs", "status": "renamed", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,5 @@\n use hir::HasSource;\n-use ra_syntax::{\n+use syntax::{\n     ast::{\n         self,\n         edit::{self, AstNodeEdit, IndentLevel},\n@@ -48,7 +48,6 @@ enum AddMissingImplMembersMode {\n //     fn foo(&self) -> u32 {\n //         ${0:todo!()}\n //     }\n-//\n // }\n // ```\n pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -89,8 +88,8 @@ pub(crate) fn add_missing_impl_members(acc: &mut Assists, ctx: &AssistContext) -\n // impl Trait for () {\n //     Type X = ();\n //     fn foo(&self) {}\n-//     $0fn bar(&self) {}\n //\n+//     $0fn bar(&self) {}\n // }\n // ```\n pub(crate) fn add_missing_default_members(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -110,7 +109,7 @@ fn add_missing_impl_members_inner(\n     assist_id: &'static str,\n     label: &'static str,\n ) -> Option<()> {\n-    let _p = ra_prof::profile(\"add_missing_impl_members_inner\");\n+    let _p = profile::span(\"add_missing_impl_members_inner\");\n     let impl_def = ctx.find_node_at_offset::<ast::Impl>()?;\n     let impl_item_list = impl_def.assoc_item_list()?;\n \n@@ -240,15 +239,18 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n+\n     $0type Output;\n+\n     const CONST: usize = 42;\n+\n     fn foo(&self) {\n         todo!()\n     }\n+\n     fn baz(&self) {\n         todo!()\n     }\n-\n }\"#,\n         );\n     }\n@@ -281,10 +283,10 @@ struct S;\n \n impl Foo for S {\n     fn bar(&self) {}\n+\n     fn foo(&self) {\n         ${0:todo!()}\n     }\n-\n }\"#,\n         );\n     }\n@@ -599,6 +601,7 @@ trait Foo {\n struct S;\n impl Foo for S {\n     $0type Output;\n+\n     fn foo(&self) {\n         todo!()\n     }\n@@ -705,6 +708,58 @@ trait Tr {\n \n impl Tr for () {\n     $0type Ty;\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_whitespace_fixup_preserves_bad_tokens() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+trait Tr {\n+    fn foo();\n+}\n+\n+impl Tr for ()<|> {\n+    +++\n+}\"#,\n+            r#\"\n+trait Tr {\n+    fn foo();\n+}\n+\n+impl Tr for () {\n+    fn foo() {\n+        ${0:todo!()}\n+    }\n+    +++\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_whitespace_fixup_preserves_comments() {\n+        check_assist(\n+            add_missing_impl_members,\n+            r#\"\n+trait Tr {\n+    fn foo();\n+}\n+\n+impl Tr for ()<|> {\n+    // very important\n+}\"#,\n+            r#\"\n+trait Tr {\n+    fn foo();\n+}\n+\n+impl Tr for () {\n+    fn foo() {\n+        ${0:todo!()}\n+    }\n+    // very important\n }\"#,\n         )\n     }", "previous_filename": "crates/ra_assists/src/handlers/add_missing_impl_members.rs"}, {"sha": "f4f997d8e19c460da8c993a9f4d1d4471bd9919c", "filename": "crates/assists/src/handlers/add_turbo_fish.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_turbo_fish.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,5 @@\n-use ra_ide_db::defs::{classify_name_ref, Definition, NameRefClass};\n-use ra_syntax::{ast, AstNode, SyntaxKind, T};\n+use ide_db::defs::{classify_name_ref, Definition, NameRefClass};\n+use syntax::{ast, AstNode, SyntaxKind, T};\n use test_utils::mark;\n \n use crate::{\n@@ -41,7 +41,7 @@ pub(crate) fn add_turbo_fish(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n     let name_ref = ast::NameRef::cast(ident.parent())?;\n     let def = match classify_name_ref(&ctx.sema, &name_ref)? {\n         NameRefClass::Definition(def) => def,\n-        NameRefClass::FieldShorthand { .. } => return None,\n+        NameRefClass::ExternCrate(_) | NameRefClass::FieldShorthand { .. } => return None,\n     };\n     let fun = match def {\n         Definition::ModuleDef(hir::ModuleDef::Function(it)) => it,", "previous_filename": "crates/ra_assists/src/handlers/add_turbo_fish.rs"}, {"sha": "1a6fdafda2c876098ca7d8bbb5ca76454213be02", "filename": "crates/assists/src/handlers/apply_demorgan.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,10 +1,10 @@\n-use ra_syntax::ast::{self, AstNode};\n+use syntax::ast::{self, AstNode};\n \n use crate::{utils::invert_boolean_expression, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: apply_demorgan\n //\n-// Apply [De Morgan's law](https://en.wikipedia.org/wiki/De_Morgan%27s_laws).\n+// Apply https://en.wikipedia.org/wiki/De_Morgan%27s_laws[De Morgan's law].\n // This transforms expressions of the form `!l || !r` into `!(l && r)`.\n // This also works with `&&`. This assist can only be applied with the cursor\n // on either `||` or `&&`, with both operands being a negation of some kind.", "previous_filename": "crates/ra_assists/src/handlers/apply_demorgan.rs"}, {"sha": "c4770f33611f32012f641dfbcaed18c1b3193914", "filename": "crates/assists/src/handlers/auto_import.rs", "status": "renamed", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,13 +5,12 @@ use hir::{\n     AsAssocItem, AssocItemContainer, ModPath, Module, ModuleDef, PathResolution, Semantics, Trait,\n     Type,\n };\n-use ra_ide_db::{imports_locator, RootDatabase};\n-use ra_prof::profile;\n-use ra_syntax::{\n+use ide_db::{imports_locator, RootDatabase};\n+use rustc_hash::FxHashSet;\n+use syntax::{\n     ast::{self, AstNode},\n     SyntaxNode,\n };\n-use rustc_hash::FxHashSet;\n \n use crate::{\n     utils::insert_use_statement, AssistContext, AssistId, AssistKind, Assists, GroupLabel,\n@@ -54,7 +53,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n             |builder| {\n                 insert_use_statement(\n                     &auto_import_assets.syntax_under_caret,\n-                    &import,\n+                    &import.to_string(),\n                     ctx,\n                     builder.text_edit_builder(),\n                 );\n@@ -130,7 +129,7 @@ impl AutoImportAssets {\n     }\n \n     fn search_for_imports(&self, ctx: &AssistContext) -> BTreeSet<ModPath> {\n-        let _p = profile(\"auto_import::search_for_imports\");\n+        let _p = profile::span(\"auto_import::search_for_imports\");\n         let db = ctx.db();\n         let current_crate = self.module_with_name_to_import.krate();\n         imports_locator::find_imports(&ctx.sema, current_crate, &self.get_search_query())\n@@ -240,7 +239,7 @@ impl ImportCandidate {\n             return None;\n         }\n         Some(Self::TraitMethod(\n-            sema.type_of_expr(&method_call.expr()?)?,\n+            sema.type_of_expr(&method_call.receiver()?)?,\n             method_call.name_ref()?.syntax().to_string(),\n         ))\n     }", "previous_filename": "crates/ra_assists/src/handlers/auto_import.rs"}, {"sha": "be480943c549219f127cc5f082c6f8041e6d1764", "filename": "crates/assists/src/handlers/change_return_type_to_result.rs", "status": "renamed", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fchange_return_type_to_result.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,10 +1,12 @@\n-use ra_syntax::{\n-    ast::{self, BlockExpr, Expr, LoopBodyOwner},\n+use std::iter;\n+\n+use syntax::{\n+    ast::{self, make, BlockExpr, Expr, LoopBodyOwner},\n     AstNode, SyntaxNode,\n };\n+use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n-use test_utils::mark;\n \n // Assist: change_return_type_to_result\n //\n@@ -44,7 +46,13 @@ pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContex\n             tail_return_expr_collector.collect_tail_exprs(block_expr);\n \n             for ret_expr_arg in tail_return_expr_collector.exprs_to_wrap {\n-                builder.replace_node_and_indent(&ret_expr_arg, format!(\"Ok({})\", ret_expr_arg));\n+                let ok_wrapped = make::expr_call(\n+                    make::expr_path(make::path_unqualified(make::path_segment(make::name_ref(\n+                        \"Ok\",\n+                    )))),\n+                    make::arg_list(iter::once(ret_expr_arg.clone())),\n+                );\n+                builder.replace_ast(ret_expr_arg, ok_wrapped);\n             }\n \n             match ctx.config.snippet_cap {\n@@ -60,7 +68,7 @@ pub(crate) fn change_return_type_to_result(acc: &mut Assists, ctx: &AssistContex\n }\n \n struct TailReturnCollector {\n-    exprs_to_wrap: Vec<SyntaxNode>,\n+    exprs_to_wrap: Vec<ast::Expr>,\n }\n \n impl TailReturnCollector {\n@@ -74,6 +82,7 @@ impl TailReturnCollector {\n             let expr = match &stmt {\n                 ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n                 ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+                ast::Stmt::Item(_) => continue,\n             };\n             if let Some(expr) = &expr {\n                 self.handle_exprs(expr, collect_break);\n@@ -85,7 +94,8 @@ impl TailReturnCollector {\n             if let Some(last_exprs) = get_tail_expr_from_block(&expr) {\n                 for last_expr in last_exprs {\n                     let last_expr = match last_expr {\n-                        NodeType::Node(expr) | NodeType::Leaf(expr) => expr,\n+                        NodeType::Node(expr) => expr,\n+                        NodeType::Leaf(expr) => expr.syntax().clone(),\n                     };\n \n                     if let Some(last_expr) = Expr::cast(last_expr.clone()) {\n@@ -94,6 +104,7 @@ impl TailReturnCollector {\n                         let expr_stmt = match &expr_stmt {\n                             ast::Stmt::ExprStmt(stmt) => stmt.expr(),\n                             ast::Stmt::LetStmt(stmt) => stmt.initializer(),\n+                            ast::Stmt::Item(_) => None,\n                         };\n                         if let Some(expr) = &expr_stmt {\n                             self.handle_exprs(expr, collect_break);\n@@ -111,12 +122,12 @@ impl TailReturnCollector {\n             }\n             Expr::ReturnExpr(ret_expr) => {\n                 if let Some(ret_expr_arg) = &ret_expr.expr() {\n-                    self.exprs_to_wrap.push(ret_expr_arg.syntax().clone());\n+                    self.exprs_to_wrap.push(ret_expr_arg.clone());\n                 }\n             }\n             Expr::BreakExpr(break_expr) if collect_break => {\n                 if let Some(break_expr_arg) = &break_expr.expr() {\n-                    self.exprs_to_wrap.push(break_expr_arg.syntax().clone());\n+                    self.exprs_to_wrap.push(break_expr_arg.clone());\n                 }\n             }\n             Expr::IfExpr(if_expr) => {\n@@ -164,14 +175,11 @@ impl TailReturnCollector {\n                     NodeType::Leaf(expr) => {\n                         self.exprs_to_wrap.push(expr.clone());\n                     }\n-                    NodeType::Node(expr) => match &Expr::cast(expr.clone()) {\n-                        Some(last_expr) => {\n-                            self.fetch_tail_exprs(last_expr);\n-                        }\n-                        None => {\n-                            self.exprs_to_wrap.push(expr.clone());\n+                    NodeType::Node(expr) => {\n+                        if let Some(last_expr) = Expr::cast(expr.clone()) {\n+                            self.fetch_tail_exprs(&last_expr);\n                         }\n-                    },\n+                    }\n                 }\n             }\n         }\n@@ -180,7 +188,7 @@ impl TailReturnCollector {\n \n #[derive(Debug)]\n enum NodeType {\n-    Leaf(SyntaxNode),\n+    Leaf(ast::Expr),\n     Node(SyntaxNode),\n }\n \n@@ -231,26 +239,26 @@ fn get_tail_expr_from_block(expr: &Expr) -> Option<Vec<NodeType>> {\n \n             Some(arms)\n         }\n-        Expr::BreakExpr(expr) => expr.expr().map(|e| vec![NodeType::Leaf(e.syntax().clone())]),\n+        Expr::BreakExpr(expr) => expr.expr().map(|e| vec![NodeType::Leaf(e)]),\n         Expr::ReturnExpr(ret_expr) => Some(vec![NodeType::Node(ret_expr.syntax().clone())]),\n-        Expr::CallExpr(call_expr) => Some(vec![NodeType::Leaf(call_expr.syntax().clone())]),\n-        Expr::Literal(lit_expr) => Some(vec![NodeType::Leaf(lit_expr.syntax().clone())]),\n-        Expr::TupleExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::ArrayExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::ParenExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::PathExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::Label(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::RecordExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::IndexExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::MethodCallExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::AwaitExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::CastExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::RefExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::PrefixExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::RangeExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::BinExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::MacroCall(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n-        Expr::BoxExpr(expr) => Some(vec![NodeType::Leaf(expr.syntax().clone())]),\n+\n+        Expr::CallExpr(_)\n+        | Expr::Literal(_)\n+        | Expr::TupleExpr(_)\n+        | Expr::ArrayExpr(_)\n+        | Expr::ParenExpr(_)\n+        | Expr::PathExpr(_)\n+        | Expr::RecordExpr(_)\n+        | Expr::IndexExpr(_)\n+        | Expr::MethodCallExpr(_)\n+        | Expr::AwaitExpr(_)\n+        | Expr::CastExpr(_)\n+        | Expr::RefExpr(_)\n+        | Expr::PrefixExpr(_)\n+        | Expr::RangeExpr(_)\n+        | Expr::BinExpr(_)\n+        | Expr::MacroCall(_)\n+        | Expr::BoxExpr(_) => Some(vec![NodeType::Leaf(expr.clone())]),\n         _ => None,\n     }\n }", "previous_filename": "crates/ra_assists/src/handlers/change_return_type_to_result.rs"}, {"sha": "32dc053789073514a783b59b59591f7a2dc6fd59", "filename": "crates/assists/src/handlers/change_visibility.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fchange_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fchange_visibility.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, NameOwner, VisibilityOwner},\n     AstNode,\n     SyntaxKind::{CONST, ENUM, FN, MODULE, STATIC, STRUCT, TRAIT, VISIBILITY},", "previous_filename": "crates/ra_assists/src/handlers/change_visibility.rs"}, {"sha": "7fd78e9d47052d500b1b09d90d11a38fda1a5bee", "filename": "crates/assists/src/handlers/early_return.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fearly_return.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use std::{iter::once, ops::RangeInclusive};\n \n-use ra_syntax::{\n+use syntax::{\n     algo::replace_children,\n     ast::{\n         self,\n@@ -51,11 +51,11 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n     // Check if there is an IfLet that we can handle.\n     let if_let_pat = match cond.pat() {\n         None => None, // No IfLet, supported.\n-        Some(ast::Pat::TupleStructPat(pat)) if pat.args().count() == 1 => {\n+        Some(ast::Pat::TupleStructPat(pat)) if pat.fields().count() == 1 => {\n             let path = pat.path()?;\n             match path.qualifier() {\n                 None => {\n-                    let bound_ident = pat.args().next().unwrap();\n+                    let bound_ident = pat.fields().next().unwrap();\n                     Some((path, bound_ident))\n                 }\n                 Some(_) => return None,\n@@ -123,7 +123,7 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n                         let happy_arm = {\n                             let pat = make::tuple_struct_pat(\n                                 path,\n-                                once(make::bind_pat(make::name(\"it\")).into()),\n+                                once(make::ident_pat(make::name(\"it\")).into()),\n                             );\n                             let expr = {\n                                 let name_ref = make::name_ref(\"it\");\n@@ -136,15 +136,15 @@ pub(crate) fn convert_to_guarded_return(acc: &mut Assists, ctx: &AssistContext)\n \n                         let sad_arm = make::match_arm(\n                             // FIXME: would be cool to use `None` or `Err(_)` if appropriate\n-                            once(make::placeholder_pat().into()),\n+                            once(make::wildcard_pat().into()),\n                             early_expression,\n                         );\n \n                         make::expr_match(cond_expr, make::match_arm_list(vec![happy_arm, sad_arm]))\n                     };\n \n                     let let_stmt = make::let_stmt(\n-                        make::bind_pat(make::name(&bound_ident.syntax().to_string())).into(),\n+                        make::ident_pat(make::name(&bound_ident.syntax().to_string())).into(),\n                         Some(match_expr),\n                     );\n                     let let_stmt = let_stmt.indent(if_indent_level);", "previous_filename": "crates/ra_assists/src/handlers/early_return.rs"}, {"sha": "81d0af2f353485735d44ae64ed80f79493732e2d", "filename": "crates/assists/src/handlers/expand_glob_import.rs", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -0,0 +1,385 @@\n+use either::Either;\n+use hir::{AssocItem, MacroDef, ModuleDef, Name, PathResolution, ScopeDef, SemanticsScope};\n+use ide_db::{\n+    defs::{classify_name_ref, Definition, NameRefClass},\n+    RootDatabase,\n+};\n+use syntax::{algo, ast, match_ast, AstNode, SyntaxNode, SyntaxToken, T};\n+\n+use crate::{\n+    assist_context::{AssistBuilder, AssistContext, Assists},\n+    AssistId, AssistKind,\n+};\n+\n+// Assist: expand_glob_import\n+//\n+// Expands glob imports.\n+//\n+// ```\n+// mod foo {\n+//     pub struct Bar;\n+//     pub struct Baz;\n+// }\n+//\n+// use foo::*<|>;\n+//\n+// fn qux(bar: Bar, baz: Baz) {}\n+// ```\n+// ->\n+// ```\n+// mod foo {\n+//     pub struct Bar;\n+//     pub struct Baz;\n+// }\n+//\n+// use foo::{Baz, Bar};\n+//\n+// fn qux(bar: Bar, baz: Baz) {}\n+// ```\n+pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let star = ctx.find_token_at_offset(T![*])?;\n+    let mod_path = find_mod_path(&star)?;\n+    let module = match ctx.sema.resolve_path(&mod_path)? {\n+        PathResolution::Def(ModuleDef::Module(it)) => it,\n+        _ => return None,\n+    };\n+\n+    let source_file = ctx.source_file();\n+    let scope = ctx.sema.scope_at_offset(source_file.syntax(), ctx.offset());\n+\n+    let defs_in_mod = find_defs_in_mod(ctx, scope, module)?;\n+    let name_refs_in_source_file =\n+        source_file.syntax().descendants().filter_map(ast::NameRef::cast).collect();\n+    let used_names = find_used_names(ctx, defs_in_mod, name_refs_in_source_file);\n+\n+    let parent = star.parent().parent()?;\n+    acc.add(\n+        AssistId(\"expand_glob_import\", AssistKind::RefactorRewrite),\n+        \"Expand glob import\",\n+        parent.text_range(),\n+        |builder| {\n+            replace_ast(builder, &parent, mod_path, used_names);\n+        },\n+    )\n+}\n+\n+fn find_mod_path(star: &SyntaxToken) -> Option<ast::Path> {\n+    star.ancestors().find_map(|n| ast::UseTree::cast(n).and_then(|u| u.path()))\n+}\n+\n+#[derive(PartialEq)]\n+enum Def {\n+    ModuleDef(ModuleDef),\n+    MacroDef(MacroDef),\n+}\n+\n+impl Def {\n+    fn name(&self, db: &RootDatabase) -> Option<Name> {\n+        match self {\n+            Def::ModuleDef(def) => def.name(db),\n+            Def::MacroDef(def) => def.name(db),\n+        }\n+    }\n+}\n+\n+fn find_defs_in_mod(\n+    ctx: &AssistContext,\n+    from: SemanticsScope<'_>,\n+    module: hir::Module,\n+) -> Option<Vec<Def>> {\n+    let module_scope = module.scope(ctx.db(), from.module());\n+\n+    let mut defs = vec![];\n+    for (_, def) in module_scope {\n+        match def {\n+            ScopeDef::ModuleDef(def) => defs.push(Def::ModuleDef(def)),\n+            ScopeDef::MacroDef(def) => defs.push(Def::MacroDef(def)),\n+            _ => continue,\n+        }\n+    }\n+\n+    Some(defs)\n+}\n+\n+fn find_used_names(\n+    ctx: &AssistContext,\n+    defs_in_mod: Vec<Def>,\n+    name_refs_in_source_file: Vec<ast::NameRef>,\n+) -> Vec<Name> {\n+    let defs_in_source_file = name_refs_in_source_file\n+        .iter()\n+        .filter_map(|r| classify_name_ref(&ctx.sema, r))\n+        .filter_map(|rc| match rc {\n+            NameRefClass::Definition(Definition::ModuleDef(def)) => Some(Def::ModuleDef(def)),\n+            NameRefClass::Definition(Definition::Macro(def)) => Some(Def::MacroDef(def)),\n+            _ => None,\n+        })\n+        .collect::<Vec<Def>>();\n+\n+    defs_in_mod\n+        .iter()\n+        .filter(|def| {\n+            if let Def::ModuleDef(ModuleDef::Trait(tr)) = def {\n+                for item in tr.items(ctx.db()) {\n+                    if let AssocItem::Function(f) = item {\n+                        if defs_in_source_file.contains(&Def::ModuleDef(ModuleDef::Function(f))) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            defs_in_source_file.contains(def)\n+        })\n+        .filter_map(|d| d.name(ctx.db()))\n+        .collect()\n+}\n+\n+fn replace_ast(\n+    builder: &mut AssistBuilder,\n+    node: &SyntaxNode,\n+    path: ast::Path,\n+    used_names: Vec<Name>,\n+) {\n+    let replacement: Either<ast::UseTree, ast::UseTreeList> = match used_names.as_slice() {\n+        [name] => Either::Left(ast::make::use_tree(\n+            ast::make::path_from_text(&format!(\"{}::{}\", path, name)),\n+            None,\n+            None,\n+            false,\n+        )),\n+        names => Either::Right(ast::make::use_tree_list(names.iter().map(|n| {\n+            ast::make::use_tree(ast::make::path_from_text(&n.to_string()), None, None, false)\n+        }))),\n+    };\n+\n+    let mut replace_node = |replacement: Either<ast::UseTree, ast::UseTreeList>| {\n+        algo::diff(node, &replacement.either(|u| u.syntax().clone(), |ut| ut.syntax().clone()))\n+            .into_text_edit(builder.text_edit_builder());\n+    };\n+\n+    match_ast! {\n+        match node {\n+            ast::UseTree(use_tree) => {\n+                replace_node(replacement);\n+            },\n+            ast::UseTreeList(use_tree_list) => {\n+                replace_node(replacement);\n+            },\n+            ast::Use(use_item) => {\n+                builder.replace_ast(use_item, ast::make::use_(replacement.left_or_else(|ut| ast::make::use_tree(path, Some(ut), None, false))));\n+            },\n+            _ => {},\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn expanding_glob_import() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::*<|>;\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::{Baz, Bar, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_existing_explicit_names() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::{*<|>, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+            r\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+    pub struct Qux;\n+\n+    pub fn f() {}\n+}\n+\n+use foo::{Baz, Bar, f};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_nested_glob_import() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+mod foo {\n+    mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    mod baz {\n+        pub fn g() {}\n+    }\n+}\n+\n+use foo::{bar::{*<|>, f}, baz::*};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+}\n+\",\n+            r\"\n+mod foo {\n+    mod bar {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+\n+        pub fn f() {}\n+    }\n+\n+    mod baz {\n+        pub fn g() {}\n+    }\n+}\n+\n+use foo::{bar::{Baz, Bar, f}, baz::*};\n+\n+fn qux(bar: Bar, baz: Baz) {\n+    f();\n+    g();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_macro_defs() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+//- /lib.rs crate:foo\n+#[macro_export]\n+macro_rules! bar {\n+    () => ()\n+}\n+\n+pub fn baz() {}\n+\n+//- /main.rs crate:main deps:foo\n+use foo::*<|>;\n+\n+fn main() {\n+    bar!();\n+    baz();\n+}\n+\",\n+            r\"\n+use foo::{bar, baz};\n+\n+fn main() {\n+    bar!();\n+    baz();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_glob_import_with_trait_method_uses() {\n+        check_assist(\n+            expand_glob_import,\n+            r\"\n+//- /lib.rs crate:foo\n+pub trait Tr {\n+    fn method(&self) {}\n+}\n+impl Tr for () {}\n+\n+//- /main.rs crate:main deps:foo\n+use foo::*<|>;\n+\n+fn main() {\n+    ().method();\n+}\n+\",\n+            r\"\n+use foo::Tr;\n+\n+fn main() {\n+    ().method();\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn expanding_is_not_applicable_if_cursor_is_not_in_star_token() {\n+        check_assist_not_applicable(\n+            expand_glob_import,\n+            r\"\n+    mod foo {\n+        pub struct Bar;\n+        pub struct Baz;\n+        pub struct Qux;\n+    }\n+\n+    use foo::Bar<|>;\n+\n+    fn qux(bar: Bar, baz: Baz) {}\n+    \",\n+        )\n+    }\n+}"}, {"sha": "c1124b9e2fb9fb84b76f354bee4a8ab702d2fbe4", "filename": "crates/assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "renamed", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,13 +1,12 @@\n+use base_db::FileId;\n use hir::{EnumVariant, Module, ModuleDef, Name};\n-use ra_db::FileId;\n-use ra_fmt::leading_indent;\n-use ra_ide_db::{defs::Definition, search::Reference, RootDatabase};\n-use ra_syntax::{\n+use ide_db::{defs::Definition, search::Reference, RootDatabase};\n+use rustc_hash::FxHashSet;\n+use syntax::{\n     algo::find_node_at_offset,\n-    ast::{self, ArgListOwner, AstNode, NameOwner, VisibilityOwner},\n-    SourceFile, SyntaxNode, TextRange, TextSize,\n+    ast::{self, edit::IndentLevel, ArgListOwner, AstNode, NameOwner, VisibilityOwner},\n+    SourceFile, TextRange, TextSize,\n };\n-use rustc_hash::FxHashSet;\n \n use crate::{\n     assist_context::AssistBuilder, utils::insert_use_statement, AssistContext, AssistId,\n@@ -54,7 +53,7 @@ pub(crate) fn extract_struct_from_enum_variant(\n         target,\n         |builder| {\n             let definition = Definition::ModuleDef(ModuleDef::EnumVariant(variant_hir));\n-            let res = definition.find_usages(&ctx.sema, None);\n+            let res = definition.usages(&ctx.sema).all();\n             let start_offset = variant.parent_enum().syntax().text_range().start();\n             let mut visited_modules_set = FxHashSet::default();\n             visited_modules_set.insert(current_module);\n@@ -72,7 +71,7 @@ pub(crate) fn extract_struct_from_enum_variant(\n             }\n             extract_struct_def(\n                 builder,\n-                enum_ast.syntax(),\n+                &enum_ast,\n                 &variant_name,\n                 &field_list.to_string(),\n                 start_offset,\n@@ -107,14 +106,20 @@ fn insert_import(\n     if let Some(mut mod_path) = mod_path {\n         mod_path.segments.pop();\n         mod_path.segments.push(variant_hir_name.clone());\n-        insert_use_statement(path.syntax(), &mod_path, ctx, builder.text_edit_builder());\n+        insert_use_statement(\n+            path.syntax(),\n+            &mod_path.to_string(),\n+            ctx,\n+            builder.text_edit_builder(),\n+        );\n     }\n     Some(())\n }\n \n+// FIXME: this should use strongly-typed `make`, rather than string manipulation.\n fn extract_struct_def(\n     builder: &mut AssistBuilder,\n-    enum_ast: &SyntaxNode,\n+    enum_: &ast::Enum,\n     variant_name: &str,\n     variant_list: &str,\n     start_offset: TextSize,\n@@ -126,11 +131,7 @@ fn extract_struct_def(\n     } else {\n         \"\".to_string()\n     };\n-    let indent = if let Some(indent) = leading_indent(enum_ast) {\n-        indent.to_string()\n-    } else {\n-        \"\".to_string()\n-    };\n+    let indent = IndentLevel::from_node(enum_.syntax());\n     let struct_def = format!(\n         r#\"{}struct {}{};\n ", "previous_filename": "crates/ra_assists/src/handlers/extract_struct_from_enum_variant.rs"}, {"sha": "d2ae137cdd3a84fd77455b8e06972e20dd49985e", "filename": "crates/assists/src/handlers/extract_variable.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,11 +1,11 @@\n-use ra_syntax::{\n+use stdx::format_to;\n+use syntax::{\n     ast::{self, AstNode},\n     SyntaxKind::{\n-        BLOCK_EXPR, BREAK_EXPR, COMMENT, LAMBDA_EXPR, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n+        BLOCK_EXPR, BREAK_EXPR, CLOSURE_EXPR, COMMENT, LOOP_EXPR, MATCH_ARM, PATH_EXPR, RETURN_EXPR,\n     },\n     SyntaxNode,\n };\n-use stdx::format_to;\n use test_utils::mark;\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n@@ -148,7 +148,7 @@ impl Anchor {\n             }\n \n             if let Some(parent) = node.parent() {\n-                if parent.kind() == MATCH_ARM || parent.kind() == LAMBDA_EXPR {\n+                if parent.kind() == MATCH_ARM || parent.kind() == CLOSURE_EXPR {\n                     return Some(Anchor::WrapInBlock(node));\n                 }\n             }", "previous_filename": "crates/ra_assists/src/handlers/extract_variable.rs"}, {"sha": "3d9bdb2bf79dec3867c93490e82d487d1a3bb0ba", "filename": "crates/assists/src/handlers/fill_match_arms.rs", "status": "renamed", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Ffill_match_arms.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n use std::iter;\n \n use hir::{Adt, HasSource, ModuleDef, Semantics};\n+use ide_db::RootDatabase;\n use itertools::Itertools;\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::ast::{self, make, AstNode, MatchArm, NameOwner, Pat};\n+use syntax::ast::{self, make, AstNode, MatchArm, NameOwner, Pat};\n use test_utils::mark;\n \n use crate::{\n@@ -43,7 +43,7 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n \n     let mut arms: Vec<MatchArm> = match_arm_list.arms().collect();\n     if arms.len() == 1 {\n-        if let Some(Pat::PlaceholderPat(..)) = arms[0].pat() {\n+        if let Some(Pat::WildcardPat(..)) = arms[0].pat() {\n             arms.clear();\n         }\n     }\n@@ -116,17 +116,15 @@ pub(crate) fn fill_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option<\n             match (first_new_arm, ctx.config.snippet_cap) {\n                 (Some(first_new_arm), Some(cap)) => {\n                     let extend_lifetime;\n-                    let cursor = match first_new_arm\n-                        .syntax()\n-                        .descendants()\n-                        .find_map(ast::PlaceholderPat::cast)\n-                    {\n-                        Some(it) => {\n-                            extend_lifetime = it.syntax().clone();\n-                            Cursor::Replace(&extend_lifetime)\n-                        }\n-                        None => Cursor::Before(first_new_arm.syntax()),\n-                    };\n+                    let cursor =\n+                        match first_new_arm.syntax().descendants().find_map(ast::WildcardPat::cast)\n+                        {\n+                            Some(it) => {\n+                                extend_lifetime = it.syntax().clone();\n+                                Cursor::Replace(&extend_lifetime)\n+                            }\n+                            None => Cursor::Before(first_new_arm.syntax()),\n+                        };\n                     let snippet = render_snippet(cap, new_arm_list.syntax(), cursor);\n                     builder.replace_snippet(cap, old_range, snippet);\n                 }\n@@ -152,7 +150,7 @@ fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n     let first_node_text = |pat: &Pat| pat.syntax().first_child().map(|node| node.text());\n \n     let pat_head = match pat {\n-        Pat::BindPat(bind_pat) => {\n+        Pat::IdentPat(bind_pat) => {\n             if let Some(p) = bind_pat.pat() {\n                 first_node_text(&p)\n             } else {\n@@ -199,12 +197,11 @@ fn build_pat(db: &RootDatabase, module: hir::Module, var: hir::EnumVariant) -> O\n     // FIXME: use HIR for this; it doesn't currently expose struct vs. tuple vs. unit variants though\n     let pat: ast::Pat = match var.source(db).value.kind() {\n         ast::StructKind::Tuple(field_list) => {\n-            let pats =\n-                iter::repeat(make::placeholder_pat().into()).take(field_list.fields().count());\n+            let pats = iter::repeat(make::wildcard_pat().into()).take(field_list.fields().count());\n             make::tuple_struct_pat(path, pats).into()\n         }\n         ast::StructKind::Record(field_list) => {\n-            let pats = field_list.fields().map(|f| make::bind_pat(f.name().unwrap()).into());\n+            let pats = field_list.fields().map(|f| make::ident_pat(f.name().unwrap()).into());\n             make::record_pat(path, pats).into()\n         }\n         ast::StructKind::Unit => make::path_pat(path),", "previous_filename": "crates/ra_assists/src/handlers/fill_match_arms.rs"}, {"sha": "7cd76ea06594f9fa1ed2356141e492316144d733", "filename": "crates/assists/src/handlers/fix_visibility.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n+use base_db::FileId;\n use hir::{db::HirDatabase, HasSource, HasVisibility, PathResolution};\n-use ra_db::FileId;\n-use ra_syntax::{ast, AstNode, TextRange, TextSize};\n+use syntax::{ast, AstNode, TextRange, TextSize};\n \n use crate::{utils::vis_offset, AssistContext, AssistId, AssistKind, Assists};\n use ast::VisibilityOwner;\n@@ -121,7 +121,7 @@ fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext) ->\n             Some(cap) => match current_visibility {\n                 Some(current_visibility) => builder.replace_snippet(\n                     cap,\n-                    dbg!(current_visibility.syntax()).text_range(),\n+                    current_visibility.syntax().text_range(),\n                     format!(\"$0{}\", missing_visibility),\n                 ),\n                 None => builder.insert_snippet(cap, offset, format!(\"$0{} \", missing_visibility)),", "previous_filename": "crates/ra_assists/src/handlers/fix_visibility.rs"}, {"sha": "404f06133d7e19f40639815943f047f3e7f7deb3", "filename": "crates/assists/src/handlers/flip_binexpr.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fflip_binexpr.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::ast::{AstNode, BinExpr, BinOp};\n+use syntax::ast::{AstNode, BinExpr, BinOp};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n ", "previous_filename": "crates/ra_assists/src/handlers/flip_binexpr.rs"}, {"sha": "5c69db53e564af28d329c3cbdab3aaf0db46302b", "filename": "crates/assists/src/handlers/flip_comma.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fflip_comma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fflip_comma.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{algo::non_trivia_sibling, Direction, T};\n+use syntax::{algo::non_trivia_sibling, Direction, T};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n ", "previous_filename": "crates/ra_assists/src/handlers/flip_comma.rs"}, {"sha": "347e79b1dadedaae3b10184964f28e68db4fb3b7", "filename": "crates/assists/src/handlers/flip_trait_bound.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fflip_trait_bound.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{\n+use syntax::{\n     algo::non_trivia_sibling,\n     ast::{self, AstNode},\n     Direction, T,", "previous_filename": "crates/ra_assists/src/handlers/flip_trait_bound.rs"}, {"sha": "314504e15ce37e8ab92ad2ca7f2bae071444469f", "filename": "crates/assists/src/handlers/generate_derive.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_derive.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     SyntaxKind::{COMMENT, WHITESPACE},\n     TextSize,", "previous_filename": "crates/ra_assists/src/handlers/generate_derive.rs"}, {"sha": "7f04b95725a8b3622463710d61cd7b50cf9661af", "filename": "crates/assists/src/handlers/generate_from_impl_for_enum.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_from_impl_for_enum.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,5 @@\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::ast::{self, AstNode, NameOwner};\n+use ide_db::RootDatabase;\n+use syntax::ast::{self, AstNode, NameOwner};\n use test_utils::mark;\n \n use crate::{utils::FamousDefs, AssistContext, AssistId, AssistKind, Assists};\n@@ -34,7 +34,7 @@ pub(crate) fn generate_from_impl_for_enum(acc: &mut Assists, ctx: &AssistContext\n     }\n     let field_type = field_list.fields().next()?.ty()?;\n     let path = match field_type {\n-        ast::TypeRef::PathType(it) => it,\n+        ast::Type::PathType(it) => it,\n         _ => return None,\n     };\n ", "previous_filename": "crates/ra_assists/src/handlers/generate_from_impl_for_enum.rs"}, {"sha": "b38d640581caee331ed88d98836ab4fe65fa57e2", "filename": "crates/assists/src/handlers/generate_function.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,14 +1,14 @@\n+use base_db::FileId;\n use hir::HirDisplay;\n-use ra_db::FileId;\n-use ra_syntax::{\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n         make, ArgListOwner, AstNode, ModuleItemOwner,\n     },\n     SyntaxKind, SyntaxNode, TextSize,\n };\n-use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     assist_config::SnippetCap,\n@@ -142,7 +142,7 @@ impl FunctionBuilder {\n         let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n         let visibility = if self.needs_pub { Some(make::visibility_pub_crate()) } else { None };\n         let mut fn_def =\n-            make::fn_def(visibility, self.fn_name, self.type_params, self.params, fn_body);\n+            make::fn_(visibility, self.fn_name, self.type_params, self.params, fn_body);\n         let leading_ws;\n         let trailing_ws;\n ", "previous_filename": "crates/ra_assists/src/handlers/generate_function.rs"}, {"sha": "9989109b5aefbb7e51b70e0207c58852bb632b66", "filename": "crates/assists/src/handlers/generate_impl.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_impl.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,6 @@\n-use ra_syntax::ast::{self, AstNode, GenericParamsOwner, NameOwner};\n-use stdx::{format_to, SepBy};\n+use itertools::Itertools;\n+use stdx::format_to;\n+use syntax::ast::{self, AstNode, GenericParamsOwner, NameOwner};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -50,7 +51,7 @@ pub(crate) fn generate_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()\n                     .filter_map(|it| it.name())\n                     .map(|it| it.text().clone());\n \n-                let generic_params = lifetime_params.chain(type_params).sep_by(\", \");\n+                let generic_params = lifetime_params.chain(type_params).format(\", \");\n                 format_to!(buf, \"<{}>\", generic_params)\n             }\n             match ctx.config.snippet_cap {", "previous_filename": "crates/ra_assists/src/handlers/generate_impl.rs"}, {"sha": "7db10f276863712cb70664733a8096a61272c531", "filename": "crates/assists/src/handlers/generate_new.rs", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fgenerate_new.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,10 @@\n use hir::Adt;\n-use ra_syntax::{\n+use itertools::Itertools;\n+use stdx::format_to;\n+use syntax::{\n     ast::{self, AstNode, GenericParamsOwner, NameOwner, StructKind, VisibilityOwner},\n     T,\n };\n-use stdx::{format_to, SepBy};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -52,8 +53,8 @@ pub(crate) fn generate_new(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n         let params = field_list\n             .fields()\n             .filter_map(|f| Some(format!(\"{}: {}\", f.name()?.syntax(), f.ty()?.syntax())))\n-            .sep_by(\", \");\n-        let fields = field_list.fields().filter_map(|f| f.name()).sep_by(\", \");\n+            .format(\", \");\n+        let fields = field_list.fields().filter_map(|f| f.name()).format(\", \");\n \n         format_to!(buf, \"    {}fn new({}) -> Self {{ Self {{ {} }} }}\", vis, params, fields);\n \n@@ -102,7 +103,7 @@ fn generate_impl_text(strukt: &ast::Struct, code: &str) -> String {\n             .map(|it| it.text().clone());\n         let type_params =\n             type_params.type_params().filter_map(|it| it.name()).map(|it| it.text().clone());\n-        format_to!(buf, \"<{}>\", lifetime_params.chain(type_params).sep_by(\", \"))\n+        format_to!(buf, \"<{}>\", lifetime_params.chain(type_params).format(\", \"))\n     }\n \n     format_to!(buf, \" {{\\n{}\\n}}\\n\", code);", "previous_filename": "crates/ra_assists/src/handlers/generate_new.rs"}, {"sha": "164bbce86fcb76775feab25a72db884b106c0228", "filename": "crates/assists/src/handlers/inline_local_variable.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Finline_local_variable.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,5 @@\n-use ra_ide_db::defs::Definition;\n-use ra_syntax::{\n+use ide_db::defs::Definition;\n+use syntax::{\n     ast::{self, AstNode, AstToken},\n     TextRange,\n };\n@@ -29,7 +29,7 @@ use crate::{\n pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let let_stmt = ctx.find_node_at_offset::<ast::LetStmt>()?;\n     let bind_pat = match let_stmt.pat()? {\n-        ast::Pat::BindPat(pat) => pat,\n+        ast::Pat::IdentPat(pat) => pat,\n         _ => return None,\n     };\n     if bind_pat.mut_token().is_some() {\n@@ -44,7 +44,7 @@ pub(crate) fn inline_local_variable(acc: &mut Assists, ctx: &AssistContext) -> O\n \n     let def = ctx.sema.to_def(&bind_pat)?;\n     let def = Definition::Local(def);\n-    let refs = def.find_usages(&ctx.sema, None);\n+    let refs = def.usages(&ctx.sema).all();\n     if refs.is_empty() {\n         mark::hit!(test_not_applicable_if_variable_unused);\n         return None;", "previous_filename": "crates/ra_assists/src/handlers/inline_local_variable.rs"}, {"sha": "5f623e5f7add2db2ce8c413b2e68e3674a981a78", "filename": "crates/assists/src/handlers/introduce_named_lifetime.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fintroduce_named_lifetime.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,8 +1,8 @@\n-use ra_syntax::{\n+use rustc_hash::FxHashSet;\n+use syntax::{\n     ast::{self, GenericParamsOwner, NameOwner},\n     AstNode, SyntaxKind, TextRange, TextSize,\n };\n-use rustc_hash::FxHashSet;\n \n use crate::{assist_context::AssistBuilder, AssistContext, AssistId, AssistKind, Assists};\n \n@@ -68,7 +68,7 @@ fn generate_fn_def_assist(\n         let fn_params_without_lifetime: Vec<_> = param_list\n             .params()\n             .filter_map(|param| match param.ty() {\n-                Some(ast::TypeRef::ReferenceType(ascribed_type))\n+                Some(ast::Type::RefType(ascribed_type))\n                     if ascribed_type.lifetime_token() == None =>\n                 {\n                     Some(ascribed_type.amp_token()?.text_range().end())", "previous_filename": "crates/ra_assists/src/handlers/introduce_named_lifetime.rs"}, {"sha": "f0e04753891836d7cc97133e8323744ec9e46dde", "filename": "crates/assists/src/handlers/invert_if.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Finvert_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Finvert_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Finvert_if.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode},\n     T,\n };", "previous_filename": "crates/ra_assists/src/handlers/invert_if.rs"}, {"sha": "35b884206f28c9c6fce969a626dbc2423ede7439", "filename": "crates/assists/src/handlers/merge_imports.rs", "status": "renamed", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,13 +1,14 @@\n use std::iter::successors;\n \n-use ra_syntax::{\n+use syntax::{\n     algo::{neighbor, skip_trivia_token, SyntaxRewriter},\n     ast::{self, edit::AstNodeEdit, make},\n     AstNode, Direction, InsertPosition, SyntaxElement, T,\n };\n \n use crate::{\n     assist_context::{AssistContext, Assists},\n+    utils::next_prev,\n     AssistId, AssistKind,\n };\n \n@@ -66,10 +67,6 @@ pub(crate) fn merge_imports(acc: &mut Assists, ctx: &AssistContext) -> Option<()\n     )\n }\n \n-fn next_prev() -> impl Iterator<Item = Direction> {\n-    [Direction::Next, Direction::Prev].iter().copied()\n-}\n-\n fn try_merge_trees(old: &ast::UseTree, new: &ast::UseTree) -> Option<ast::UseTree> {\n     let lhs_path = old.path()?;\n     let rhs_path = new.path()?;\n@@ -164,6 +161,33 @@ use std::fmt::{Display, Debug};\n         );\n     }\n \n+    #[test]\n+    fn merge_self1() {\n+        check_assist(\n+            merge_imports,\n+            r\"\n+use std::fmt<|>;\n+use std::fmt::Display;\n+\",\n+            r\"\n+use std::fmt::{self, Display};\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn merge_self2() {\n+        check_assist(\n+            merge_imports,\n+            r\"\n+use std::{fmt, <|>fmt::Display};\n+\",\n+            r\"\n+use std::{fmt::{Display, self}};\n+\",\n+        );\n+    }\n+\n     #[test]\n     fn test_merge_nested() {\n         check_assist(", "previous_filename": "crates/ra_assists/src/handlers/merge_imports.rs"}, {"sha": "c347eb40efaf2b9d23226386ef837b7e1d87ac9b", "filename": "crates/assists/src/handlers/merge_match_arms.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fmerge_match_arms.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use std::iter::successors;\n \n-use ra_syntax::{\n+use syntax::{\n     algo::neighbor,\n     ast::{self, AstNode},\n     Direction,\n@@ -86,7 +86,7 @@ pub(crate) fn merge_match_arms(acc: &mut Assists, ctx: &AssistContext) -> Option\n }\n \n fn contains_placeholder(a: &ast::MatchArm) -> bool {\n-    matches!(a.pat(), Some(ast::Pat::PlaceholderPat(..)))\n+    matches!(a.pat(), Some(ast::Pat::WildcardPat(..)))\n }\n \n #[cfg(test)]", "previous_filename": "crates/ra_assists/src/handlers/merge_match_arms.rs"}, {"sha": "e2e461520dcfff9239bc0d3173962d5c952ab959", "filename": "crates/assists/src/handlers/move_bounds.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fmove_bounds.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, edit::AstNodeEdit, make, AstNode, NameOwner, TypeBoundsOwner},\n     match_ast,\n     SyntaxKind::*,", "previous_filename": "crates/ra_assists/src/handlers/move_bounds.rs"}, {"sha": "452115fe6721882d49cb79a518531bc40c6a82f4", "filename": "crates/assists/src/handlers/move_guard.rs", "status": "renamed", "additions": 107, "deletions": 117, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fmove_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fmove_guard.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,5 @@\n-use ra_syntax::{\n-    ast::{AstNode, IfExpr, MatchArm},\n+use syntax::{\n+    ast::{edit::AstNodeEdit, make, AstNode, IfExpr, MatchArm},\n     SyntaxKind::WHITESPACE,\n };\n \n@@ -25,7 +25,9 @@ use crate::{AssistContext, AssistId, AssistKind, Assists};\n //\n // fn handle(action: Action) {\n //     match action {\n-//         Action::Move { distance } => if distance > 10 { foo() },\n+//         Action::Move { distance } => if distance > 10 {\n+//             foo()\n+//         },\n //         _ => (),\n //     }\n // }\n@@ -35,9 +37,13 @@ pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) ->\n     let guard = match_arm.guard()?;\n     let space_before_guard = guard.syntax().prev_sibling_or_token();\n \n-    let guard_conditions = guard.expr()?;\n+    let guard_condition = guard.expr()?;\n     let arm_expr = match_arm.expr()?;\n-    let buf = format!(\"if {} {{ {} }}\", guard_conditions.syntax().text(), arm_expr.syntax().text());\n+    let if_expr = make::expr_if(\n+        make::condition(guard_condition, None),\n+        make::block_expr(None, Some(arm_expr.clone())),\n+    )\n+    .indent(arm_expr.indent_level());\n \n     let target = guard.syntax().text_range();\n     acc.add(\n@@ -53,7 +59,7 @@ pub(crate) fn move_guard_to_arm_body(acc: &mut Assists, ctx: &AssistContext) ->\n             };\n \n             edit.delete(guard.syntax().text_range());\n-            edit.replace_node_and_indent(arm_expr.syntax(), buf);\n+            edit.replace_ast(arm_expr, if_expr);\n         },\n     )\n }\n@@ -134,16 +140,14 @@ mod tests {\n         check_assist_target(\n             move_guard_to_arm_body,\n             r#\"\n-            fn f() {\n-                let t = 'a';\n-                let chars = \"abcd\";\n-                match t {\n-                    '\\r' <|>if chars.clone().next() == Some('\\n') => false,\n-                    _ => true\n-                }\n-            }\n-            \"#,\n-            r#\"if chars.clone().next() == Some('\\n')\"#,\n+fn main() {\n+    match 92 {\n+        x <|>if x > 10 => false,\n+        _ => true\n+    }\n+}\n+\"#,\n+            r#\"if x > 10\"#,\n         );\n     }\n \n@@ -152,25 +156,23 @@ mod tests {\n         check_assist(\n             move_guard_to_arm_body,\n             r#\"\n-            fn f() {\n-                let t = 'a';\n-                let chars = \"abcd\";\n-                match t {\n-                    '\\r' <|>if chars.clone().next() == Some('\\n') => false,\n-                    _ => true\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        x <|>if x > 10 => false,\n+        _ => true\n+    }\n+}\n+\"#,\n             r#\"\n-            fn f() {\n-                let t = 'a';\n-                let chars = \"abcd\";\n-                match t {\n-                    '\\r' => if chars.clone().next() == Some('\\n') { false },\n-                    _ => true\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        x => if x > 10 {\n+            false\n+        },\n+        _ => true\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -179,21 +181,23 @@ mod tests {\n         check_assist(\n             move_guard_to_arm_body,\n             r#\"\n-            fn f() {\n-                match x {\n-                    <|>y @ 4 | y @ 5    if y > 5 => true,\n-                    _ => false\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        <|>x @ 4 | x @ 5    if x > 5 => true,\n+        _ => false\n+    }\n+}\n+\"#,\n             r#\"\n-            fn f() {\n-                match x {\n-                    y @ 4 | y @ 5 => if y > 5 { true },\n-                    _ => false\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        x @ 4 | x @ 5 => if x > 5 {\n+            true\n+        },\n+        _ => false\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -202,25 +206,21 @@ mod tests {\n         check_assist(\n             move_arm_cond_to_match_guard,\n             r#\"\n-            fn f() {\n-                let t = 'a';\n-                let chars = \"abcd\";\n-                match t {\n-                    '\\r' => if chars.clone().next() == Some('\\n') { <|>false },\n-                    _ => true\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        x => if x > 10 { <|>false },\n+        _ => true\n+    }\n+}\n+\"#,\n             r#\"\n-            fn f() {\n-                let t = 'a';\n-                let chars = \"abcd\";\n-                match t {\n-                    '\\r' if chars.clone().next() == Some('\\n') => false,\n-                    _ => true\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        x if x > 10 => false,\n+        _ => true\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -229,15 +229,13 @@ mod tests {\n         check_assist_not_applicable(\n             move_arm_cond_to_match_guard,\n             r#\"\n-            fn f() {\n-                let t = 'a';\n-                let chars = \"abcd\";\n-                match t {\n-                    '\\r' => if let Some(_) = chars.clone().next() { <|>false },\n-                    _ => true\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        x => if let 62 = x { <|>false },\n+        _ => true\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -246,25 +244,21 @@ mod tests {\n         check_assist(\n             move_arm_cond_to_match_guard,\n             r#\"\n-            fn f() {\n-                let t = 'a';\n-                let chars = \"abcd\";\n-                match t {\n-                    '\\r' => if chars.clone().next().is_some() { <|> },\n-                    _ => true\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        x => if x > 10 { <|> },\n+        _ => true\n+    }\n+}\n+\"#,\n             r#\"\n-            fn f() {\n-                let t = 'a';\n-                let chars = \"abcd\";\n-                match t {\n-                    '\\r' if chars.clone().next().is_some() => {  },\n-                    _ => true\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        x if x > 10 => {  },\n+        _ => true\n+    }\n+}\n+\"#,\n         );\n     }\n \n@@ -273,31 +267,27 @@ mod tests {\n         check_assist(\n             move_arm_cond_to_match_guard,\n             r#\"\n-            fn f() {\n-                let mut t = 'a';\n-                let chars = \"abcd\";\n-                match t {\n-                    '\\r' => if chars.clone().next().is_some() {\n-                        t = 'e';<|>\n-                        false\n-                    },\n-                    _ => true\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        x => if x > 10 {\n+            92;<|>\n+            false\n+        },\n+        _ => true\n+    }\n+}\n+\"#,\n             r#\"\n-            fn f() {\n-                let mut t = 'a';\n-                let chars = \"abcd\";\n-                match t {\n-                    '\\r' if chars.clone().next().is_some() => {\n-                        t = 'e';\n-                        false\n-                    },\n-                    _ => true\n-                }\n-            }\n-            \"#,\n+fn main() {\n+    match 92 {\n+        x if x > 10 => {\n+            92;\n+            false\n+        },\n+        _ => true\n+    }\n+}\n+\"#,\n         );\n     }\n }", "previous_filename": "crates/ra_assists/src/handlers/move_guard.rs"}, {"sha": "9ddd116e015567ae58a2f67d47dca2c79236c934", "filename": "crates/assists/src/handlers/raw_string.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fraw_string.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use std::borrow::Cow;\n \n-use ra_syntax::{\n+use syntax::{\n     ast::{self, HasQuotes, HasStringValue},\n     AstToken,\n     SyntaxKind::{RAW_STRING, STRING},\n@@ -173,7 +173,7 @@ fn test_required_hashes() {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use test_utils::mark;\n \n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};", "previous_filename": "crates/ra_assists/src/handlers/raw_string.rs"}, {"sha": "4e252edf02d797c1dc895ec0bc93dbdadbf030d2", "filename": "crates/assists/src/handlers/remove_dbg.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_dbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_dbg.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode},\n     TextRange, TextSize, T,\n };\n@@ -82,9 +82,10 @@ fn is_valid_macrocall(macro_call: &ast::MacroCall, macro_name: &str) -> Option<b\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n     use crate::tests::{check_assist, check_assist_not_applicable, check_assist_target};\n \n+    use super::*;\n+\n     #[test]\n     fn test_remove_dbg() {\n         check_assist(remove_dbg, \"<|>dbg!(1 + 1)\", \"1 + 1\");", "previous_filename": "crates/ra_assists/src/handlers/remove_dbg.rs"}, {"sha": "44f41daa92d772bf93fa476043546728f82928d3", "filename": "crates/assists/src/handlers/remove_mut.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_mut.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{SyntaxKind, TextRange, T};\n+use syntax::{SyntaxKind, TextRange, T};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n ", "previous_filename": "crates/ra_assists/src/handlers/remove_mut.rs"}, {"sha": "5fccca54b802b65518c19ff24f3531dd9f1bb117", "filename": "crates/assists/src/handlers/remove_unused_param.rs", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fremove_unused_param.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -0,0 +1,131 @@\n+use ide_db::{defs::Definition, search::Reference};\n+use syntax::{\n+    algo::find_node_at_range,\n+    ast::{self, ArgListOwner},\n+    AstNode, SyntaxNode, TextRange, T,\n+};\n+use test_utils::mark;\n+\n+use crate::{\n+    assist_context::AssistBuilder, utils::next_prev, AssistContext, AssistId, AssistKind, Assists,\n+};\n+\n+// Assist: remove_unused_param\n+//\n+// Removes unused function parameter.\n+//\n+// ```\n+// fn frobnicate(x: i32<|>) {}\n+//\n+// fn main() {\n+//     frobnicate(92);\n+// }\n+// ```\n+// ->\n+// ```\n+// fn frobnicate() {}\n+//\n+// fn main() {\n+//     frobnicate();\n+// }\n+// ```\n+pub(crate) fn remove_unused_param(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n+    let param: ast::Param = ctx.find_node_at_offset()?;\n+    let ident_pat = match param.pat()? {\n+        ast::Pat::IdentPat(it) => it,\n+        _ => return None,\n+    };\n+    let func = param.syntax().ancestors().find_map(ast::Fn::cast)?;\n+    let param_position = func.param_list()?.params().position(|it| it == param)?;\n+\n+    let fn_def = {\n+        let func = ctx.sema.to_def(&func)?;\n+        Definition::ModuleDef(func.into())\n+    };\n+\n+    let param_def = {\n+        let local = ctx.sema.to_def(&ident_pat)?;\n+        Definition::Local(local)\n+    };\n+    if param_def.usages(&ctx.sema).at_least_one() {\n+        mark::hit!(keep_used);\n+        return None;\n+    }\n+    acc.add(\n+        AssistId(\"remove_unused_param\", AssistKind::Refactor),\n+        \"Remove unused parameter\",\n+        param.syntax().text_range(),\n+        |builder| {\n+            builder.delete(range_with_coma(param.syntax()));\n+            for usage in fn_def.usages(&ctx.sema).all() {\n+                process_usage(ctx, builder, usage, param_position);\n+            }\n+        },\n+    )\n+}\n+\n+fn process_usage(\n+    ctx: &AssistContext,\n+    builder: &mut AssistBuilder,\n+    usage: Reference,\n+    arg_to_remove: usize,\n+) -> Option<()> {\n+    let source_file = ctx.sema.parse(usage.file_range.file_id);\n+    let call_expr: ast::CallExpr =\n+        find_node_at_range(source_file.syntax(), usage.file_range.range)?;\n+    if call_expr.expr()?.syntax().text_range() != usage.file_range.range {\n+        return None;\n+    }\n+    let arg = call_expr.arg_list()?.args().nth(arg_to_remove)?;\n+\n+    builder.edit_file(usage.file_range.file_id);\n+    builder.delete(range_with_coma(arg.syntax()));\n+\n+    Some(())\n+}\n+\n+fn range_with_coma(node: &SyntaxNode) -> TextRange {\n+    let up_to = next_prev().find_map(|dir| {\n+        node.siblings_with_tokens(dir)\n+            .filter_map(|it| it.into_token())\n+            .find(|it| it.kind() == T![,])\n+    });\n+    let up_to = up_to.map_or(node.text_range(), |it| it.text_range());\n+    node.text_range().cover(up_to)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn remove_unused() {\n+        check_assist(\n+            remove_unused_param,\n+            r#\"\n+fn a() { foo(9, 2) }\n+fn foo(x: i32, <|>y: i32) { x; }\n+fn b() { foo(9, 2,) }\n+\"#,\n+            r#\"\n+fn a() { foo(9) }\n+fn foo(x: i32) { x; }\n+fn b() { foo(9, ) }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn keep_used() {\n+        mark::check!(keep_used);\n+        check_assist_not_applicable(\n+            remove_unused_param,\n+            r#\"\n+fn foo(x: i32, <|>y: i32) { y; }\n+fn main() { foo(9, 2) }\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "527f457a79384e8d365040a65d64f4fcd4b55f11", "filename": "crates/assists/src/handlers/reorder_fields.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,8 +2,8 @@ use itertools::Itertools;\n use rustc_hash::FxHashMap;\n \n use hir::{Adt, ModuleDef, PathResolution, Semantics, Struct};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{algo, ast, match_ast, AstNode, SyntaxKind, SyntaxKind::*, SyntaxNode};\n+use ide_db::RootDatabase;\n+use syntax::{algo, ast, match_ast, AstNode, SyntaxKind, SyntaxKind::*, SyntaxNode};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n \n@@ -57,7 +57,7 @@ fn reorder<R: AstNode>(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n fn get_fields_kind(node: &SyntaxNode) -> Vec<SyntaxKind> {\n     match node.kind() {\n         RECORD_EXPR => vec![RECORD_EXPR_FIELD],\n-        RECORD_PAT => vec![RECORD_FIELD_PAT, BIND_PAT],\n+        RECORD_PAT => vec![RECORD_PAT_FIELD, IDENT_PAT],\n         _ => vec![],\n     }\n }\n@@ -66,7 +66,7 @@ fn get_field_name(node: &SyntaxNode) -> String {\n     let res = match_ast! {\n         match node {\n             ast::RecordExprField(field) => field.field_name().map(|it| it.to_string()),\n-            ast::RecordFieldPat(field) => field.field_name().map(|it| it.to_string()),\n+            ast::RecordPatField(field) => field.field_name().map(|it| it.to_string()),\n             _ => None,\n         }\n     };", "previous_filename": "crates/ra_assists/src/handlers/reorder_fields.rs"}, {"sha": "79097621e645f0277db4eabd3bc978167cd88d57", "filename": "crates/assists/src/handlers/replace_if_let_with_match.rs", "status": "renamed", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_if_let_with_match.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,4 @@\n-use ra_fmt::unwrap_trivial_block;\n-use ra_syntax::{\n+use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n@@ -8,7 +7,10 @@ use ra_syntax::{\n     AstNode,\n };\n \n-use crate::{utils::TryEnum, AssistContext, AssistId, AssistKind, Assists};\n+use crate::{\n+    utils::{unwrap_trivial_block, TryEnum},\n+    AssistContext, AssistId, AssistKind, Assists,\n+};\n \n // Assist: replace_if_let_with_match\n //\n@@ -65,7 +67,7 @@ pub(crate) fn replace_if_let_with_match(acc: &mut Assists, ctx: &AssistContext)\n                         .type_of_pat(&pat)\n                         .and_then(|ty| TryEnum::from_ty(&ctx.sema, &ty))\n                         .map(|it| it.sad_pattern())\n-                        .unwrap_or_else(|| make::placeholder_pat().into());\n+                        .unwrap_or_else(|| make::wildcard_pat().into());\n                     let else_expr = unwrap_trivial_block(else_block);\n                     make::match_arm(vec![pattern], else_expr)\n                 };", "previous_filename": "crates/ra_assists/src/handlers/replace_if_let_with_match.rs"}, {"sha": "ed6d0c29be8dc6d75d2f8ddf2f83d0785431a3af", "filename": "crates/assists/src/handlers/replace_let_with_if_let.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_let_with_if_let.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use std::iter::once;\n \n-use ra_syntax::{\n+use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n@@ -50,10 +50,10 @@ pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) ->\n         target,\n         |edit| {\n             let with_placeholder: ast::Pat = match happy_variant {\n-                None => make::placeholder_pat().into(),\n+                None => make::wildcard_pat().into(),\n                 Some(var_name) => make::tuple_struct_pat(\n                     make::path_unqualified(make::path_segment(make::name_ref(var_name))),\n-                    once(make::placeholder_pat().into()),\n+                    once(make::wildcard_pat().into()),\n                 )\n                 .into(),\n             };\n@@ -62,8 +62,7 @@ pub(crate) fn replace_let_with_if_let(acc: &mut Assists, ctx: &AssistContext) ->\n             let if_ = make::expr_if(make::condition(init, Some(with_placeholder)), block);\n             let stmt = make::expr_stmt(if_);\n \n-            let placeholder =\n-                stmt.syntax().descendants().find_map(ast::PlaceholderPat::cast).unwrap();\n+            let placeholder = stmt.syntax().descendants().find_map(ast::WildcardPat::cast).unwrap();\n             let stmt = stmt.replace_descendant(placeholder.into(), original_pat);\n \n             edit.replace_ast(ast::Stmt::from(let_stmt), ast::Stmt::from(stmt));", "previous_filename": "crates/ra_assists/src/handlers/replace_let_with_if_let.rs"}, {"sha": "470e5f8ff752bfcd6928de55c2250ff351e9d0bd", "filename": "crates/assists/src/handlers/replace_qualified_name_with_use.rs", "status": "renamed", "additions": 63, "deletions": 29, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_qualified_name_with_use.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,5 @@\n-use hir;\n-use ra_syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SmolStr, SyntaxNode};\n+use syntax::{algo::SyntaxRewriter, ast, match_ast, AstNode, SyntaxNode, TextRange};\n+use test_utils::mark;\n \n use crate::{\n     utils::{find_insert_use_container, insert_use_statement},\n@@ -28,25 +28,36 @@ pub(crate) fn replace_qualified_name_with_use(\n     if path.syntax().ancestors().find_map(ast::Use::cast).is_some() {\n         return None;\n     }\n-\n-    let hir_path = ctx.sema.lower_path(&path)?;\n-    let segments = collect_hir_path_segments(&hir_path)?;\n-    if segments.len() < 2 {\n+    if path.qualifier().is_none() {\n+        mark::hit!(dont_import_trivial_paths);\n         return None;\n     }\n+    let path_to_import = path.to_string().clone();\n+    let path_to_import = match path.segment()?.generic_arg_list() {\n+        Some(generic_args) => {\n+            let generic_args_start =\n+                generic_args.syntax().text_range().start() - path.syntax().text_range().start();\n+            &path_to_import[TextRange::up_to(generic_args_start)]\n+        }\n+        None => path_to_import.as_str(),\n+    };\n \n     let target = path.syntax().text_range();\n     acc.add(\n         AssistId(\"replace_qualified_name_with_use\", AssistKind::RefactorRewrite),\n         \"Replace qualified path with use\",\n         target,\n         |builder| {\n-            let path_to_import = hir_path.mod_path().clone();\n             let container = match find_insert_use_container(path.syntax(), ctx) {\n                 Some(c) => c,\n                 None => return,\n             };\n-            insert_use_statement(path.syntax(), &path_to_import, ctx, builder.text_edit_builder());\n+            insert_use_statement(\n+                path.syntax(),\n+                &path_to_import.to_string(),\n+                ctx,\n+                builder.text_edit_builder(),\n+            );\n \n             // Now that we've brought the name into scope, re-qualify all paths that could be\n             // affected (that is, all paths inside the node we added the `use` to).\n@@ -58,26 +69,6 @@ pub(crate) fn replace_qualified_name_with_use(\n     )\n }\n \n-fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n-    let mut ps = Vec::<SmolStr>::with_capacity(10);\n-    match path.kind() {\n-        hir::PathKind::Abs => ps.push(\"\".into()),\n-        hir::PathKind::Crate => ps.push(\"crate\".into()),\n-        hir::PathKind::Plain => {}\n-        hir::PathKind::Super(0) => ps.push(\"self\".into()),\n-        hir::PathKind::Super(lvl) => {\n-            let mut chain = \"super\".to_string();\n-            for _ in 0..*lvl {\n-                chain += \"::super\";\n-            }\n-            ps.push(chain.into());\n-        }\n-        hir::PathKind::DollarCrate(_) => return None,\n-    }\n-    ps.extend(path.segments().iter().map(|it| it.name.to_string().into()));\n-    Some(ps)\n-}\n-\n /// Adds replacements to `re` that shorten `path` in all descendants of `node`.\n fn shorten_paths(rewriter: &mut SyntaxRewriter<'static>, node: SyntaxNode, path: ast::Path) {\n     for child in node.children() {\n@@ -467,7 +458,8 @@ impl Debug for Foo {\n     }\n \n     #[test]\n-    fn test_replace_not_applicable_one_segment() {\n+    fn dont_import_trivial_paths() {\n+        mark::check!(dont_import_trivial_paths);\n         check_assist_not_applicable(\n             replace_qualified_name_with_use,\n             r\"\n@@ -639,6 +631,48 @@ use std::fmt::{self, Display};\n \n fn main() {\n     fmt;\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_replace_pub_use() {\n+        check_assist(\n+            replace_qualified_name_with_use,\n+            r\"\n+pub use std::fmt;\n+\n+impl std::io<|> for Foo {\n+}\n+    \",\n+            r\"\n+use std::io;\n+\n+pub use std::fmt;\n+\n+impl io for Foo {\n+}\n+    \",\n+        );\n+    }\n+\n+    #[test]\n+    fn does_not_replace_pub_crate_use() {\n+        check_assist(\n+            replace_qualified_name_with_use,\n+            r\"\n+pub(crate) use std::fmt;\n+\n+impl std::io<|> for Foo {\n+}\n+    \",\n+            r\"\n+use std::io;\n+\n+pub(crate) use std::fmt;\n+\n+impl io for Foo {\n }\n     \",\n         );", "previous_filename": "crates/ra_assists/src/handlers/replace_qualified_name_with_use.rs"}, {"sha": "4043c219cde34885e4d93cb9b4727df53a9ae2a4", "filename": "crates/assists/src/handlers/replace_unwrap_with_match.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Freplace_unwrap_with_match.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use std::iter;\n \n-use ra_syntax::{\n+use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n@@ -42,7 +42,7 @@ pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext)\n     if name.text() != \"unwrap\" {\n         return None;\n     }\n-    let caller = method_call.expr()?;\n+    let caller = method_call.receiver()?;\n     let ty = ctx.sema.type_of_expr(&caller)?;\n     let happy_variant = TryEnum::from_ty(&ctx.sema, &ty)?.happy_case();\n     let target = method_call.syntax().text_range();\n@@ -52,15 +52,15 @@ pub(crate) fn replace_unwrap_with_match(acc: &mut Assists, ctx: &AssistContext)\n         target,\n         |builder| {\n             let ok_path = make::path_unqualified(make::path_segment(make::name_ref(happy_variant)));\n-            let it = make::bind_pat(make::name(\"a\")).into();\n+            let it = make::ident_pat(make::name(\"a\")).into();\n             let ok_tuple = make::tuple_struct_pat(ok_path, iter::once(it)).into();\n \n             let bind_path = make::path_unqualified(make::path_segment(make::name_ref(\"a\")));\n             let ok_arm = make::match_arm(iter::once(ok_tuple), make::expr_path(bind_path));\n \n             let unreachable_call = make::expr_unreachable();\n             let err_arm =\n-                make::match_arm(iter::once(make::placeholder_pat().into()), unreachable_call);\n+                make::match_arm(iter::once(make::wildcard_pat().into()), unreachable_call);\n \n             let match_arm_list = make::match_arm_list(vec![ok_arm, err_arm]);\n             let match_expr = make::expr_match(caller.clone(), match_arm_list)", "previous_filename": "crates/ra_assists/src/handlers/replace_unwrap_with_match.rs"}, {"sha": "15e67eaa19f8f0ee8d09006be9ee102d74f185fb", "filename": "crates/assists/src/handlers/split_import.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Fsplit_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fsplit_import.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use std::iter::successors;\n \n-use ra_syntax::{ast, AstNode, T};\n+use syntax::{ast, AstNode, T};\n \n use crate::{AssistContext, AssistId, AssistKind, Assists};\n ", "previous_filename": "crates/ra_assists/src/handlers/split_import.rs"}, {"sha": "3851aeb3e7459fc0a8c101293588fb24ec1a3006", "filename": "crates/assists/src/handlers/unwrap_block.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Fhandlers%2Funwrap_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Funwrap_block.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,13 +1,12 @@\n-use ra_fmt::unwrap_trivial_block;\n-use ra_syntax::{\n+use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n     },\n     AstNode, TextRange, T,\n };\n \n-use crate::{AssistContext, AssistId, AssistKind, Assists};\n+use crate::{utils::unwrap_trivial_block, AssistContext, AssistId, AssistKind, Assists};\n \n // Assist: unwrap_block\n //", "previous_filename": "crates/ra_assists/src/handlers/unwrap_block.rs"}, {"sha": "2e0d191a609deb5c063091b28464fbc868ef3d49", "filename": "crates/assists/src/lib.rs", "status": "renamed", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-//! `ra_assists` crate provides a bunch of code assists, also known as code\n+//! `assists` crate provides a bunch of code assists, also known as code\n //! actions (in LSP) or intentions (in IntelliJ).\n //!\n //! An assist is a micro-refactoring, which is automatically activated in\n@@ -17,10 +17,10 @@ mod tests;\n pub mod utils;\n pub mod ast_transform;\n \n+use base_db::FileRange;\n use hir::Semantics;\n-use ra_db::FileRange;\n-use ra_ide_db::{source_change::SourceChange, RootDatabase};\n-use ra_syntax::TextRange;\n+use ide_db::{label::Label, source_change::SourceChange, RootDatabase};\n+use syntax::TextRange;\n \n pub(crate) use crate::assist_context::{AssistContext, Assists};\n \n@@ -68,7 +68,7 @@ pub struct GroupLabel(pub String);\n pub struct Assist {\n     pub id: AssistId,\n     /// Short description of the assist, as shown in the UI.\n-    pub label: String,\n+    pub label: Label,\n     pub group: Option<GroupLabel>,\n     /// Target ranges are used to sort assists: the smaller the target range,\n     /// the more specific assist is, and so it should be sorted first.\n@@ -113,17 +113,6 @@ impl Assist {\n         });\n         acc.finish_resolved()\n     }\n-\n-    pub(crate) fn new(\n-        id: AssistId,\n-        label: String,\n-        group: Option<GroupLabel>,\n-        target: TextRange,\n-    ) -> Assist {\n-        // FIXME: make fields private, so that this invariant can't be broken\n-        assert!(label.starts_with(|c: char| c.is_uppercase()));\n-        Assist { id, label, group, target }\n-    }\n }\n \n mod handlers {\n@@ -140,6 +129,7 @@ mod handlers {\n     mod change_return_type_to_result;\n     mod change_visibility;\n     mod early_return;\n+    mod expand_glob_import;\n     mod extract_struct_from_enum_variant;\n     mod extract_variable;\n     mod fill_match_arms;\n@@ -162,6 +152,7 @@ mod handlers {\n     mod raw_string;\n     mod remove_dbg;\n     mod remove_mut;\n+    mod remove_unused_param;\n     mod reorder_fields;\n     mod replace_if_let_with_match;\n     mod replace_let_with_if_let;\n@@ -181,6 +172,7 @@ mod handlers {\n             change_return_type_to_result::change_return_type_to_result,\n             change_visibility::change_visibility,\n             early_return::convert_to_guarded_return,\n+            expand_glob_import::expand_glob_import,\n             extract_struct_from_enum_variant::extract_struct_from_enum_variant,\n             extract_variable::extract_variable,\n             fill_match_arms::fill_match_arms,\n@@ -207,6 +199,7 @@ mod handlers {\n             raw_string::remove_hash,\n             remove_dbg::remove_dbg,\n             remove_mut::remove_mut,\n+            remove_unused_param::remove_unused_param,\n             reorder_fields::reorder_fields,\n             replace_if_let_with_match::replace_if_let_with_match,\n             replace_let_with_if_let::replace_let_with_if_let,", "previous_filename": "crates/ra_assists/src/lib.rs"}, {"sha": "ba1fb543b879df9f47b8ae20eacc0d7702e8b794", "filename": "crates/assists/src/tests.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n mod generated;\n \n+use base_db::{fixture::WithFixture, FileId, FileRange, SourceDatabaseExt};\n use hir::Semantics;\n-use ra_db::{fixture::WithFixture, FileId, FileRange, SourceDatabaseExt};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::TextRange;\n+use ide_db::RootDatabase;\n+use syntax::TextRange;\n use test_utils::{assert_eq_text, extract_offset, extract_range};\n \n use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind, Assists};\n@@ -20,7 +20,7 @@ pub(crate) fn check_assist(assist: Handler, ra_fixture_before: &str, ra_fixture_\n \n // FIXME: instead of having a separate function here, maybe use\n // `extract_ranges` and mark the target as `<target> </target>` in the\n-// fixuture?\n+// fixture?\n pub(crate) fn check_assist_target(assist: Handler, ra_fixture: &str, target: &str) {\n     check(assist, ra_fixture, ExpectedResult::Target(target));\n }", "previous_filename": "crates/ra_assists/src/tests.rs"}, {"sha": "04c8fd1f94e38c4e6ec4d3f5a42794f172c9da62", "filename": "crates/assists/src/tests/generated.rs", "status": "renamed", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Ftests%2Fgenerated.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -82,8 +82,8 @@ trait Trait {\n impl Trait for () {\n     Type X = ();\n     fn foo(&self) {}\n-    $0fn bar(&self) {}\n \n+    $0fn bar(&self) {}\n }\n \"#####,\n     )\n@@ -115,7 +115,6 @@ impl Trait<u32> for () {\n     fn foo(&self) -> u32 {\n         ${0:todo!()}\n     }\n-\n }\n \"#####,\n     )\n@@ -228,6 +227,33 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_expand_glob_import() {\n+    check_doc_test(\n+        \"expand_glob_import\",\n+        r#####\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+}\n+\n+use foo::*<|>;\n+\n+fn qux(bar: Bar, baz: Baz) {}\n+\"#####,\n+        r#####\"\n+mod foo {\n+    pub struct Bar;\n+    pub struct Baz;\n+}\n+\n+use foo::{Baz, Bar};\n+\n+fn qux(bar: Bar, baz: Baz) {}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_extract_struct_from_enum_variant() {\n     check_doc_test(\n@@ -663,7 +689,9 @@ enum Action { Move { distance: u32 }, Stop }\n \n fn handle(action: Action) {\n     match action {\n-        Action::Move { distance } => if distance > 10 { foo() },\n+        Action::Move { distance } => if distance > 10 {\n+            foo()\n+        },\n         _ => (),\n     }\n }\n@@ -722,6 +750,27 @@ impl Walrus {\n     )\n }\n \n+#[test]\n+fn doctest_remove_unused_param() {\n+    check_doc_test(\n+        \"remove_unused_param\",\n+        r#####\"\n+fn frobnicate(x: i32<|>) {}\n+\n+fn main() {\n+    frobnicate(92);\n+}\n+\"#####,\n+        r#####\"\n+fn frobnicate() {}\n+\n+fn main() {\n+    frobnicate();\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_reorder_fields() {\n     check_doc_test(", "previous_filename": "crates/ra_assists/src/tests/generated.rs"}, {"sha": "d071d6502fa88a16a7681fc12e21838e597d6bb3", "filename": "crates/assists/src/utils.rs", "status": "renamed", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,19 +4,57 @@ pub(crate) mod insert_use;\n use std::{iter, ops};\n \n use hir::{Adt, Crate, Enum, ScopeDef, Semantics, Trait, Type};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n+use ide_db::RootDatabase;\n+use itertools::Itertools;\n+use rustc_hash::FxHashSet;\n+use syntax::{\n     ast::{self, make, NameOwner},\n-    AstNode,\n+    AstNode, Direction,\n     SyntaxKind::*,\n     SyntaxNode, TextSize, T,\n };\n-use rustc_hash::FxHashSet;\n \n use crate::assist_config::SnippetCap;\n \n pub(crate) use insert_use::{find_insert_use_container, insert_use_statement};\n \n+pub(crate) fn unwrap_trivial_block(block: ast::BlockExpr) -> ast::Expr {\n+    extract_trivial_expression(&block)\n+        .filter(|expr| !expr.syntax().text().contains_char('\\n'))\n+        .unwrap_or_else(|| block.into())\n+}\n+\n+pub fn extract_trivial_expression(block: &ast::BlockExpr) -> Option<ast::Expr> {\n+    let has_anything_else = |thing: &SyntaxNode| -> bool {\n+        let mut non_trivial_children =\n+            block.syntax().children_with_tokens().filter(|it| match it.kind() {\n+                WHITESPACE | T!['{'] | T!['}'] => false,\n+                _ => it.as_node() != Some(thing),\n+            });\n+        non_trivial_children.next().is_some()\n+    };\n+\n+    if let Some(expr) = block.expr() {\n+        if has_anything_else(expr.syntax()) {\n+            return None;\n+        }\n+        return Some(expr);\n+    }\n+    // Unwrap `{ continue; }`\n+    let (stmt,) = block.statements().next_tuple()?;\n+    if let ast::Stmt::ExprStmt(expr_stmt) = stmt {\n+        if has_anything_else(expr_stmt.syntax()) {\n+            return None;\n+        }\n+        let expr = expr_stmt.expr()?;\n+        match expr.syntax().kind() {\n+            CONTINUE_EXPR | BREAK_EXPR | RETURN_EXPR => return Some(expr),\n+            _ => (),\n+        }\n+    }\n+    None\n+}\n+\n #[derive(Clone, Copy, Debug)]\n pub(crate) enum Cursor<'a> {\n     Replace(&'a SyntaxNode),\n@@ -111,11 +149,8 @@ pub(crate) fn resolve_target_trait(\n     sema: &Semantics<RootDatabase>,\n     impl_def: &ast::Impl,\n ) -> Option<hir::Trait> {\n-    let ast_path = impl_def\n-        .target_trait()\n-        .map(|it| it.syntax().clone())\n-        .and_then(ast::PathType::cast)?\n-        .path()?;\n+    let ast_path =\n+        impl_def.trait_().map(|it| it.syntax().clone()).and_then(ast::PathType::cast)?.path()?;\n \n     match sema.resolve_path(&ast_path) {\n         Some(hir::PathResolution::Def(hir::ModuleDef::Trait(def))) => Some(def),\n@@ -184,10 +219,10 @@ impl TryEnum {\n         match self {\n             TryEnum::Result => make::tuple_struct_pat(\n                 make::path_unqualified(make::path_segment(make::name_ref(\"Err\"))),\n-                iter::once(make::placeholder_pat().into()),\n+                iter::once(make::wildcard_pat().into()),\n             )\n             .into(),\n-            TryEnum::Option => make::bind_pat(make::name(\"None\")).into(),\n+            TryEnum::Option => make::ident_pat(make::name(\"None\")).into(),\n         }\n     }\n \n@@ -260,7 +295,7 @@ pub use prelude::*;\n             .find(|dep| &dep.name.to_string() == std_crate)?\n             .krate;\n \n-        let mut module = std_crate.root_module(db)?;\n+        let mut module = std_crate.root_module(db);\n         for segment in path {\n             module = module.children(db).find_map(|child| {\n                 let name = child.name(db)?;\n@@ -276,3 +311,7 @@ pub use prelude::*;\n         Some(def)\n     }\n }\n+\n+pub(crate) fn next_prev() -> impl Iterator<Item = Direction> {\n+    [Direction::Next, Direction::Prev].iter().copied()\n+}", "previous_filename": "crates/ra_assists/src/utils.rs"}, {"sha": "49096a67c7aef3e266392a6c865124a7b683e876", "filename": "crates/assists/src/utils/insert_use.rs", "status": "renamed", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,17 +2,18 @@\n // FIXME: rewrite according to the plan, outlined in\n // https://github.com/rust-analyzer/rust-analyzer/issues/3301#issuecomment-592931553\n \n-use hir::{self, ModPath};\n-use ra_syntax::{\n-    ast::{self, NameOwner},\n-    AstNode, Direction, SmolStr,\n+use std::iter::successors;\n+\n+use either::Either;\n+use syntax::{\n+    ast::{self, NameOwner, VisibilityOwner},\n+    AstNode, AstToken, Direction, SmolStr,\n     SyntaxKind::{PATH, PATH_SEGMENT},\n-    SyntaxNode, T,\n+    SyntaxNode, SyntaxToken, T,\n };\n-use ra_text_edit::TextEditBuilder;\n+use text_edit::TextEditBuilder;\n \n use crate::assist_context::AssistContext;\n-use either::Either;\n \n /// Determines the containing syntax node in which to insert a `use` statement affecting `position`.\n pub(crate) fn find_insert_use_container(\n@@ -33,11 +34,11 @@ pub(crate) fn find_insert_use_container(\n pub(crate) fn insert_use_statement(\n     // Ideally the position of the cursor, used to\n     position: &SyntaxNode,\n-    path_to_import: &ModPath,\n+    path_to_import: &str,\n     ctx: &AssistContext,\n     builder: &mut TextEditBuilder,\n ) {\n-    let target = path_to_import.to_string().split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n+    let target = path_to_import.split(\"::\").map(SmolStr::new).collect::<Vec<_>>();\n     let container = find_insert_use_container(position, ctx);\n \n     if let Some(container) = container {\n@@ -378,6 +379,7 @@ fn best_action_for_target(\n     let best_action = container\n         .children()\n         .filter_map(ast::Use::cast)\n+        .filter(|u| u.visibility().is_none())\n         .filter_map(|it| it.use_tree())\n         .map(|u| walk_use_tree_for_best_action(&mut storage, None, u, target))\n         .fold(None, |best, a| match best {\n@@ -441,7 +443,7 @@ fn make_assist_add_new_use(\n     edit: &mut TextEditBuilder,\n ) {\n     if let Some(anchor) = anchor {\n-        let indent = ra_fmt::leading_indent(anchor);\n+        let indent = leading_indent(anchor);\n         let mut buf = String::new();\n         if after {\n             buf.push_str(\"\\n\");\n@@ -523,3 +525,22 @@ fn make_assist_add_nested_import(\n         edit.insert(end, \"}\".to_string());\n     }\n }\n+\n+/// If the node is on the beginning of the line, calculate indent.\n+fn leading_indent(node: &SyntaxNode) -> Option<SmolStr> {\n+    for token in prev_tokens(node.first_token()?) {\n+        if let Some(ws) = ast::Whitespace::cast(token.clone()) {\n+            let ws_text = ws.text();\n+            if let Some(pos) = ws_text.rfind('\\n') {\n+                return Some(ws_text[pos + 1..].into());\n+            }\n+        }\n+        if token.text().contains('\\n') {\n+            break;\n+        }\n+    }\n+    return None;\n+    fn prev_tokens(token: SyntaxToken) -> impl Iterator<Item = SyntaxToken> {\n+        successors(token.prev_token(), |token| token.prev_token())\n+    }\n+}", "previous_filename": "crates/ra_assists/src/utils/insert_use.rs"}, {"sha": "7347d7528ccabba48d4fae546859379273243eb5", "filename": "crates/base_db/Cargo.toml", "status": "renamed", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fbase_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fbase_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,21 +1,21 @@\n [package]\n-edition = \"2018\"\n-name = \"ra_db\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n+name = \"base_db\"\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false\n \n [dependencies]\n-salsa = \"0.15.0\"\n+salsa = \"0.15.2\"\n rustc-hash = \"1.1.0\"\n \n-ra_syntax = { path = \"../ra_syntax\" }\n-ra_cfg = { path = \"../ra_cfg\" }\n-ra_prof = { path = \"../ra_prof\" }\n-ra_tt = { path = \"../ra_tt\" }\n+syntax = { path = \"../syntax\" }\n+cfg = { path = \"../cfg\" }\n+profile = { path = \"../profile\" }\n+tt = { path = \"../tt\" }\n test_utils = { path = \"../test_utils\" }\n vfs = { path = \"../vfs\" }\n stdx = { path = \"../stdx\" }", "previous_filename": "crates/ra_db/Cargo.toml"}, {"sha": "7420a1976f49a465d7cf0a79e3dd6551d4c03dbb", "filename": "crates/base_db/src/cancellation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fbase_db%2Fsrc%2Fcancellation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fbase_db%2Fsrc%2Fcancellation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Fcancellation.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_db/src/cancellation.rs"}, {"sha": "5ff8ead0e5ed90c071fc1a488b8e7090753bd7a6", "filename": "crates/base_db/src/fixture.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -59,7 +59,7 @@\n //! ```\n use std::{str::FromStr, sync::Arc};\n \n-use ra_cfg::CfgOptions;\n+use cfg::CfgOptions;\n use rustc_hash::FxHashMap;\n use test_utils::{extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER};\n use vfs::{file_set::FileSet, VfsPath};", "previous_filename": "crates/ra_db/src/fixture.rs"}, {"sha": "f3d65cdf02f510cd13b69efc466077f20d06fb01", "filename": "crates/base_db/src/input.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fbase_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fbase_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Finput.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -8,10 +8,10 @@\n \n use std::{fmt, iter::FromIterator, ops, str::FromStr, sync::Arc};\n \n-use ra_cfg::CfgOptions;\n-use ra_syntax::SmolStr;\n-use ra_tt::TokenExpander;\n+use cfg::CfgOptions;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use syntax::SmolStr;\n+use tt::TokenExpander;\n use vfs::file_set::FileSet;\n \n pub use vfs::FileId;\n@@ -156,7 +156,7 @@ impl CrateGraph {\n         display_name: Option<String>,\n         cfg_options: CfgOptions,\n         env: Env,\n-        proc_macro: Vec<(SmolStr, Arc<dyn ra_tt::TokenExpander>)>,\n+        proc_macro: Vec<(SmolStr, Arc<dyn tt::TokenExpander>)>,\n     ) -> CrateId {\n         let proc_macro =\n             proc_macro.into_iter().map(|(name, it)| ProcMacro { name, expander: it }).collect();", "previous_filename": "crates/ra_db/src/input.rs"}, {"sha": "ee3415850654d4b2739985290e0b9f4da2d89922", "filename": "crates/base_db/src/lib.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fbase_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fbase_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,13 +1,12 @@\n-//! ra_db defines basic database traits. The concrete DB is defined by ra_ide.\n+//! base_db defines basic database traits. The concrete DB is defined by ide.\n mod cancellation;\n mod input;\n pub mod fixture;\n \n use std::{panic, sync::Arc};\n \n-use ra_prof::profile;\n-use ra_syntax::{ast, Parse, SourceFile, TextRange, TextSize};\n use rustc_hash::FxHashSet;\n+use syntax::{ast, Parse, SourceFile, TextRange, TextSize};\n \n pub use crate::{\n     cancellation::Canceled,\n@@ -113,7 +112,7 @@ pub trait SourceDatabase: CheckCanceled + FileLoader + std::fmt::Debug {\n }\n \n fn parse_query(db: &dyn SourceDatabase, file_id: FileId) -> Parse<ast::SourceFile> {\n-    let _p = profile(\"parse_query\").detail(|| format!(\"{:?}\", file_id));\n+    let _p = profile::span(\"parse_query\").detail(|| format!(\"{:?}\", file_id));\n     let text = db.file_text(file_id);\n     SourceFile::parse(&*text)\n }", "previous_filename": "crates/ra_db/src/lib.rs"}, {"sha": "d2ea551d18a0331559ca0641f14f29d403bf8401", "filename": "crates/cfg/Cargo.toml", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fcfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fcfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,18 +1,18 @@\n [package]\n-edition = \"2018\"\n-name = \"ra_cfg\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n+name = \"cfg\"\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false\n \n [dependencies]\n rustc-hash = \"1.1.0\"\n \n-ra_syntax = { path = \"../ra_syntax\" }\n-tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n+tt = { path = \"../tt\" }\n \n [dev-dependencies]\n-mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n+mbe = { path = \"../mbe\" }\n+syntax = { path = \"../syntax\" }", "previous_filename": "crates/ra_cfg/Cargo.toml"}, {"sha": "336fe25bc9c4a3f58d0b1cb300612bd0dbfaaac0", "filename": "crates/cfg/src/cfg_expr.rs", "status": "renamed", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,7 +4,7 @@\n \n use std::slice::Iter as SliceIter;\n \n-use ra_syntax::SmolStr;\n+use tt::SmolStr;\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum CfgExpr {\n@@ -86,17 +86,15 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n mod tests {\n     use super::*;\n \n-    use mbe::{ast_to_token_tree, TokenMap};\n-    use ra_syntax::ast::{self, AstNode};\n-\n-    fn get_token_tree_generated(input: &str) -> (tt::Subtree, TokenMap) {\n-        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n-        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-        ast_to_token_tree(&tt).unwrap()\n-    }\n+    use mbe::ast_to_token_tree;\n+    use syntax::ast::{self, AstNode};\n \n     fn assert_parse_result(input: &str, expected: CfgExpr) {\n-        let (tt, _) = get_token_tree_generated(input);\n+        let (tt, _) = {\n+            let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+            ast_to_token_tree(&tt).unwrap()\n+        };\n         let cfg = CfgExpr::parse(&tt);\n         assert_eq!(cfg, expected);\n     }", "previous_filename": "crates/ra_cfg/src/cfg_expr.rs"}, {"sha": "a9d50e698ab115a734db8933ae0f39202dfb7282", "filename": "crates/cfg/src/lib.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fcfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fcfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n-//! ra_cfg defines conditional compiling options, `cfg` attibute parser and evaluator\n+//! cfg defines conditional compiling options, `cfg` attibute parser and evaluator\n \n mod cfg_expr;\n \n-use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n+use tt::SmolStr;\n \n pub use cfg_expr::CfgExpr;\n ", "previous_filename": "crates/ra_cfg/src/lib.rs"}, {"sha": "77775630dc7aefc4a52487883cffb824c2abc0e1", "filename": "crates/expect/Cargo.toml", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca464650eeaca6195891199a93f4f76cf3e7e697/crates%2Fexpect%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ca464650eeaca6195891199a93f4f76cf3e7e697/crates%2Fexpect%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2FCargo.toml?ref=ca464650eeaca6195891199a93f4f76cf3e7e697", "patch": "@@ -1,14 +0,0 @@\n-[package]\n-name = \"expect\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n-edition = \"2018\"\n-license = \"MIT OR Apache-2.0\"\n-\n-[lib]\n-doctest = false\n-\n-[dependencies]\n-once_cell = \"1\"\n-difference = \"2\"\n-stdx = { path = \"../stdx\" }"}, {"sha": "21a458d477c56414408fa7b8d4306e64c0ba6c77", "filename": "crates/expect/src/lib.rs", "status": "removed", "additions": 0, "deletions": 356, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/ca464650eeaca6195891199a93f4f76cf3e7e697/crates%2Fexpect%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca464650eeaca6195891199a93f4f76cf3e7e697/crates%2Fexpect%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fexpect%2Fsrc%2Flib.rs?ref=ca464650eeaca6195891199a93f4f76cf3e7e697", "patch": "@@ -1,356 +0,0 @@\n-//! Snapshot testing library, see\n-//! https://github.com/rust-analyzer/rust-analyzer/pull/5101\n-use std::{\n-    collections::HashMap,\n-    env, fmt, fs, mem,\n-    ops::Range,\n-    panic,\n-    path::{Path, PathBuf},\n-    sync::Mutex,\n-};\n-\n-use difference::Changeset;\n-use once_cell::sync::Lazy;\n-use stdx::{lines_with_ends, trim_indent};\n-\n-const HELP: &str = \"\n-You can update all `expect![[]]` tests by running:\n-\n-    env UPDATE_EXPECT=1 cargo test\n-\n-To update a single test, place the cursor on `expect` token and use `run` feature of rust-analyzer.\n-\";\n-\n-fn update_expect() -> bool {\n-    env::var(\"UPDATE_EXPECT\").is_ok()\n-}\n-\n-/// expect![[r#\"inline snapshot\"#]]\n-#[macro_export]\n-macro_rules! expect {\n-    [[$data:literal]] => {$crate::Expect {\n-        position: $crate::Position {\n-            file: file!(),\n-            line: line!(),\n-            column: column!(),\n-        },\n-        data: $data,\n-    }};\n-    [[]] => { $crate::expect![[\"\"]] };\n-}\n-\n-/// expect_file![\"/crates/foo/test_data/bar.html\"]\n-#[macro_export]\n-macro_rules! expect_file {\n-    [$path:expr] => {$crate::ExpectFile {\n-        path: std::path::PathBuf::from($path)\n-    }};\n-}\n-\n-#[derive(Debug)]\n-pub struct Expect {\n-    pub position: Position,\n-    pub data: &'static str,\n-}\n-\n-#[derive(Debug)]\n-pub struct ExpectFile {\n-    pub path: PathBuf,\n-}\n-\n-#[derive(Debug)]\n-pub struct Position {\n-    pub file: &'static str,\n-    pub line: u32,\n-    pub column: u32,\n-}\n-\n-impl fmt::Display for Position {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}:{}:{}\", self.file, self.line, self.column)\n-    }\n-}\n-\n-impl Expect {\n-    pub fn assert_eq(&self, actual: &str) {\n-        let trimmed = self.trimmed();\n-        if &trimmed == actual {\n-            return;\n-        }\n-        Runtime::fail_expect(self, &trimmed, actual);\n-    }\n-    pub fn assert_debug_eq(&self, actual: &impl fmt::Debug) {\n-        let actual = format!(\"{:#?}\\n\", actual);\n-        self.assert_eq(&actual)\n-    }\n-\n-    fn trimmed(&self) -> String {\n-        if !self.data.contains('\\n') {\n-            return self.data.to_string();\n-        }\n-        trim_indent(self.data)\n-    }\n-\n-    fn locate(&self, file: &str) -> Location {\n-        let mut target_line = None;\n-        let mut line_start = 0;\n-        for (i, line) in lines_with_ends(file).enumerate() {\n-            if i == self.position.line as usize - 1 {\n-                let pat = \"expect![[\";\n-                let offset = line.find(pat).unwrap();\n-                let literal_start = line_start + offset + pat.len();\n-                let indent = line.chars().take_while(|&it| it == ' ').count();\n-                target_line = Some((literal_start, indent));\n-                break;\n-            }\n-            line_start += line.len();\n-        }\n-        let (literal_start, line_indent) = target_line.unwrap();\n-        let literal_length =\n-            file[literal_start..].find(\"]]\").expect(\"Couldn't find matching `]]` for `expect![[`.\");\n-        let literal_range = literal_start..literal_start + literal_length;\n-        Location { line_indent, literal_range }\n-    }\n-}\n-\n-impl ExpectFile {\n-    pub fn assert_eq(&self, actual: &str) {\n-        let expected = self.read();\n-        if actual == expected {\n-            return;\n-        }\n-        Runtime::fail_file(self, &expected, actual);\n-    }\n-    pub fn assert_debug_eq(&self, actual: &impl fmt::Debug) {\n-        let actual = format!(\"{:#?}\\n\", actual);\n-        self.assert_eq(&actual)\n-    }\n-    fn read(&self) -> String {\n-        fs::read_to_string(self.abs_path()).unwrap_or_default().replace(\"\\r\\n\", \"\\n\")\n-    }\n-    fn write(&self, contents: &str) {\n-        fs::write(self.abs_path(), contents).unwrap()\n-    }\n-    fn abs_path(&self) -> PathBuf {\n-        WORKSPACE_ROOT.join(&self.path)\n-    }\n-}\n-\n-#[derive(Default)]\n-struct Runtime {\n-    help_printed: bool,\n-    per_file: HashMap<&'static str, FileRuntime>,\n-}\n-static RT: Lazy<Mutex<Runtime>> = Lazy::new(Default::default);\n-\n-impl Runtime {\n-    fn fail_expect(expect: &Expect, expected: &str, actual: &str) {\n-        let mut rt = RT.lock().unwrap_or_else(|poisoned| poisoned.into_inner());\n-        if update_expect() {\n-            println!(\"\\x1b[1m\\x1b[92mupdating\\x1b[0m: {}\", expect.position);\n-            rt.per_file\n-                .entry(expect.position.file)\n-                .or_insert_with(|| FileRuntime::new(expect))\n-                .update(expect, actual);\n-            return;\n-        }\n-        rt.panic(expect.position.to_string(), expected, actual);\n-    }\n-\n-    fn fail_file(expect: &ExpectFile, expected: &str, actual: &str) {\n-        let mut rt = RT.lock().unwrap_or_else(|poisoned| poisoned.into_inner());\n-        if update_expect() {\n-            println!(\"\\x1b[1m\\x1b[92mupdating\\x1b[0m: {}\", expect.path.display());\n-            expect.write(actual);\n-            return;\n-        }\n-        rt.panic(expect.path.display().to_string(), expected, actual);\n-    }\n-\n-    fn panic(&mut self, position: String, expected: &str, actual: &str) {\n-        let print_help = !mem::replace(&mut self.help_printed, true);\n-        let help = if print_help { HELP } else { \"\" };\n-\n-        let diff = Changeset::new(actual, expected, \"\\n\");\n-\n-        println!(\n-            \"\\n\n-\\x1b[1m\\x1b[91merror\\x1b[97m: expect test failed\\x1b[0m\n-   \\x1b[1m\\x1b[34m-->\\x1b[0m {}\n-{}\n-\\x1b[1mExpect\\x1b[0m:\n-----\n-{}\n-----\n-\n-\\x1b[1mActual\\x1b[0m:\n-----\n-{}\n-----\n-\n-\\x1b[1mDiff\\x1b[0m:\n-----\n-{}\n-----\n-\",\n-            position, help, expected, actual, diff\n-        );\n-        // Use resume_unwind instead of panic!() to prevent a backtrace, which is unnecessary noise.\n-        panic::resume_unwind(Box::new(()));\n-    }\n-}\n-\n-struct FileRuntime {\n-    path: PathBuf,\n-    original_text: String,\n-    patchwork: Patchwork,\n-}\n-\n-impl FileRuntime {\n-    fn new(expect: &Expect) -> FileRuntime {\n-        let path = WORKSPACE_ROOT.join(expect.position.file);\n-        let original_text = fs::read_to_string(&path).unwrap();\n-        let patchwork = Patchwork::new(original_text.clone());\n-        FileRuntime { path, original_text, patchwork }\n-    }\n-    fn update(&mut self, expect: &Expect, actual: &str) {\n-        let loc = expect.locate(&self.original_text);\n-        let patch = format_patch(loc.line_indent.clone(), actual);\n-        self.patchwork.patch(loc.literal_range, &patch);\n-        fs::write(&self.path, &self.patchwork.text).unwrap()\n-    }\n-}\n-\n-#[derive(Debug)]\n-struct Location {\n-    line_indent: usize,\n-    literal_range: Range<usize>,\n-}\n-\n-#[derive(Debug)]\n-struct Patchwork {\n-    text: String,\n-    indels: Vec<(Range<usize>, usize)>,\n-}\n-\n-impl Patchwork {\n-    fn new(text: String) -> Patchwork {\n-        Patchwork { text, indels: Vec::new() }\n-    }\n-    fn patch(&mut self, mut range: Range<usize>, patch: &str) {\n-        self.indels.push((range.clone(), patch.len()));\n-        self.indels.sort_by_key(|(delete, _insert)| delete.start);\n-\n-        let (delete, insert) = self\n-            .indels\n-            .iter()\n-            .take_while(|(delete, _)| delete.start < range.start)\n-            .map(|(delete, insert)| (delete.end - delete.start, insert))\n-            .fold((0usize, 0usize), |(x1, y1), (x2, y2)| (x1 + x2, y1 + y2));\n-\n-        for pos in &mut [&mut range.start, &mut range.end] {\n-            **pos -= delete;\n-            **pos += insert;\n-        }\n-\n-        self.text.replace_range(range, &patch);\n-    }\n-}\n-\n-fn format_patch(line_indent: usize, patch: &str) -> String {\n-    let mut max_hashes = 0;\n-    let mut cur_hashes = 0;\n-    for byte in patch.bytes() {\n-        if byte != b'#' {\n-            cur_hashes = 0;\n-            continue;\n-        }\n-        cur_hashes += 1;\n-        max_hashes = max_hashes.max(cur_hashes);\n-    }\n-    let hashes = &\"#\".repeat(max_hashes + 1);\n-    let indent = &\" \".repeat(line_indent);\n-    let is_multiline = patch.contains('\\n');\n-\n-    let mut buf = String::new();\n-    buf.push('r');\n-    buf.push_str(hashes);\n-    buf.push('\"');\n-    if is_multiline {\n-        buf.push('\\n');\n-    }\n-    let mut final_newline = false;\n-    for line in lines_with_ends(patch) {\n-        if is_multiline && !line.trim().is_empty() {\n-            buf.push_str(indent);\n-            buf.push_str(\"    \");\n-        }\n-        buf.push_str(line);\n-        final_newline = line.ends_with('\\n');\n-    }\n-    if final_newline {\n-        buf.push_str(indent);\n-    }\n-    buf.push('\"');\n-    buf.push_str(hashes);\n-    buf\n-}\n-\n-static WORKSPACE_ROOT: Lazy<PathBuf> = Lazy::new(|| {\n-    let my_manifest =\n-        env::var(\"CARGO_MANIFEST_DIR\").unwrap_or_else(|_| env!(\"CARGO_MANIFEST_DIR\").to_owned());\n-    // Heuristic, see https://github.com/rust-lang/cargo/issues/3946\n-    Path::new(&my_manifest)\n-        .ancestors()\n-        .filter(|it| it.join(\"Cargo.toml\").exists())\n-        .last()\n-        .unwrap()\n-        .to_path_buf()\n-});\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_format_patch() {\n-        let patch = format_patch(0, \"hello\\nworld\\n\");\n-        expect![[r##\"\n-            r#\"\n-                hello\n-                world\n-            \"#\"##]]\n-        .assert_eq(&patch);\n-\n-        let patch = format_patch(4, \"single line\");\n-        expect![[r##\"r#\"single line\"#\"##]].assert_eq(&patch);\n-    }\n-\n-    #[test]\n-    fn test_patchwork() {\n-        let mut patchwork = Patchwork::new(\"one two three\".to_string());\n-        patchwork.patch(4..7, \"zwei\");\n-        patchwork.patch(0..3, \"\u043e\u0434\u0438\u043d\");\n-        patchwork.patch(8..13, \"3\");\n-        expect![[r#\"\n-            Patchwork {\n-                text: \"\u043e\u0434\u0438\u043d zwei 3\",\n-                indels: [\n-                    (\n-                        0..3,\n-                        8,\n-                    ),\n-                    (\n-                        4..7,\n-                        4,\n-                    ),\n-                    (\n-                        8..13,\n-                        1,\n-                    ),\n-                ],\n-            }\n-        \"#]]\n-        .assert_debug_eq(&patchwork);\n-    }\n-}"}, {"sha": "262a66e4e3dba9d3871fbe9972512eab17dc68cc", "filename": "crates/flycheck/Cargo.toml", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fflycheck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fflycheck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n [package]\n-edition = \"2018\"\n name = \"flycheck\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false\n@@ -14,4 +14,5 @@ log = \"0.4.8\"\n cargo_metadata = \"0.11.1\"\n serde_json = \"1.0.48\"\n jod-thread = \"0.1.1\"\n-ra_toolchain = { path = \"../ra_toolchain\" }\n+\n+toolchain = { path = \"../toolchain\" }"}, {"sha": "16078d10434d304d9047c35fa3b27cc3ef0e5a12", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-//! cargo_check provides the functionality needed to run `cargo check` or\n+//! Flycheck provides the functionality needed to run `cargo check` or\n //! another compatible command (f.x. clippy) in a background thread and provide\n //! LSP diagnostics based on the output of the command.\n \n@@ -147,6 +147,12 @@ impl FlycheckActor {\n                     // avoid busy-waiting.\n                     let cargo_handle = self.cargo_handle.take().unwrap();\n                     let res = cargo_handle.join();\n+                    if res.is_err() {\n+                        log::error!(\n+                            \"Flycheck failed to run the following command: {:?}\",\n+                            self.check_command()\n+                        )\n+                    }\n                     self.send(Message::Progress(Progress::DidFinish(res)));\n                 }\n                 Event::CheckEvent(Some(message)) => match message {\n@@ -187,7 +193,7 @@ impl FlycheckActor {\n                 extra_args,\n                 features,\n             } => {\n-                let mut cmd = Command::new(ra_toolchain::cargo());\n+                let mut cmd = Command::new(toolchain::cargo());\n                 cmd.arg(command);\n                 cmd.args(&[\"--workspace\", \"--message-format=json\", \"--manifest-path\"])\n                     .arg(self.workspace_root.join(\"Cargo.toml\"));\n@@ -253,7 +259,7 @@ impl CargoHandle {\n             return Err(io::Error::new(\n                 io::ErrorKind::Other,\n                 format!(\n-                    \"Cargo watcher failed,the command produced no valid metadata (exit code: {:?})\",\n+                    \"Cargo watcher failed, the command produced no valid metadata (exit code: {:?})\",\n                     exit_status\n                 ),\n             ));"}, {"sha": "d0ddca27fc074389059fe6c7f258ad86af2cc4ae", "filename": "crates/hir/Cargo.toml", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -0,0 +1,26 @@\n+[package]\n+name = \"hir\"\n+version = \"0.0.0\"\n+license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+log = \"0.4.8\"\n+rustc-hash = \"1.1.0\"\n+either = \"1.5.3\"\n+arrayvec = \"0.5.1\"\n+itertools = \"0.9.0\"\n+url = \"2.1.1\"\n+\n+stdx = { path = \"../stdx\" }\n+syntax = { path = \"../syntax\" }\n+base_db = { path = \"../base_db\" }\n+profile = { path = \"../profile\" }\n+hir_expand = { path = \"../hir_expand\" }\n+hir_def = { path = \"../hir_def\" }\n+hir_ty = { path = \"../hir_ty\" }\n+tt = { path = \"../tt\" }"}, {"sha": "9395efe4f2a1cb501480b5ace098a13478e0f755", "filename": "crates/hir/src/code_model.rs", "status": "renamed", "additions": 101, "deletions": 23, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,14 +2,18 @@\n use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n+use base_db::{CrateId, Edition, FileId};\n use either::Either;\n use hir_def::{\n+    adt::ReprKind,\n     adt::StructKind,\n     adt::VariantData,\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     expr::{BindingAnnotation, Pat, PatId},\n     import_map,\n+    lang_item::LangItemTarget,\n+    path::ModPath,\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n@@ -29,15 +33,13 @@ use hir_ty::{\n     method_resolution, ApplicationTy, CallableDefId, Canonical, FnSig, GenericPredicate,\n     InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n };\n-use ra_db::{CrateId, Edition, FileId};\n-use ra_prof::profile;\n-use ra_syntax::{\n-    ast::{self, AttrsOwner, NameOwner},\n-    AstNode,\n-};\n-use ra_tt::{Ident, Leaf, Literal, TokenTree};\n use rustc_hash::FxHashSet;\n use stdx::impl_from;\n+use syntax::{\n+    ast::{self, AttrsOwner, NameOwner},\n+    AstNode, SmolStr,\n+};\n+use tt::{Ident, Leaf, Literal, TokenTree};\n \n use crate::{\n     db::{DefDatabase, HirDatabase},\n@@ -85,9 +87,9 @@ impl Crate {\n             .collect()\n     }\n \n-    pub fn root_module(self, db: &dyn HirDatabase) -> Option<Module> {\n+    pub fn root_module(self, db: &dyn HirDatabase) -> Module {\n         let module_id = db.crate_def_map(self.id).root;\n-        Some(Module::new(self, module_id))\n+        Module::new(self, module_id)\n     }\n \n     pub fn root_file(self, db: &dyn HirDatabase) -> FileId {\n@@ -126,7 +128,7 @@ impl Crate {\n     /// Try to get the root URL of the documentation of a crate.\n     pub fn get_doc_url(self: &Crate, db: &dyn HirDatabase) -> Option<String> {\n         // Look for #![doc(html_root_url = \"...\")]\n-        let attrs = db.attrs(AttrDef::from(self.root_module(db)?).into());\n+        let attrs = db.attrs(AttrDef::from(self.root_module(db)).into());\n         let doc_attr_q = attrs.by_key(\"doc\");\n \n         let doc_url = if doc_attr_q.exists() {\n@@ -348,7 +350,7 @@ impl Module {\n     }\n \n     pub fn diagnostics(self, db: &dyn HirDatabase, sink: &mut DiagnosticSink) {\n-        let _p = profile(\"Module::diagnostics\");\n+        let _p = profile::span(\"Module::diagnostics\");\n         let crate_def_map = db.crate_def_map(self.id.krate);\n         crate_def_map.add_diagnostics(db.upcast(), self.id.local_id, sink);\n         for decl in self.declarations(db) {\n@@ -389,11 +391,7 @@ impl Module {\n \n     /// Finds a path that can be used to refer to the given item from within\n     /// this module, if possible.\n-    pub fn find_use_path(\n-        self,\n-        db: &dyn DefDatabase,\n-        item: impl Into<ItemInNs>,\n-    ) -> Option<hir_def::path::ModPath> {\n+    pub fn find_use_path(self, db: &dyn DefDatabase, item: impl Into<ItemInNs>) -> Option<ModPath> {\n         hir_def::find_path::find_path(db, item.into(), self.into())\n     }\n }\n@@ -476,6 +474,10 @@ impl Struct {\n         Type::from_def(db, self.id.lookup(db.upcast()).container.module(db.upcast()).krate, self.id)\n     }\n \n+    pub fn repr(self, db: &dyn HirDatabase) -> Option<ReprKind> {\n+        db.struct_data(self.id).repr.clone()\n+    }\n+\n     fn variant_data(self, db: &dyn HirDatabase) -> Arc<VariantData> {\n         db.struct_data(self.id).variant_data.clone()\n     }\n@@ -710,12 +712,20 @@ impl Function {\n         db.function_data(self.id).name.clone()\n     }\n \n-    pub fn has_self_param(self, db: &dyn HirDatabase) -> bool {\n-        db.function_data(self.id).has_self_param\n+    pub fn self_param(self, db: &dyn HirDatabase) -> Option<SelfParam> {\n+        if !db.function_data(self.id).has_self_param {\n+            return None;\n+        }\n+        Some(SelfParam { func: self.id })\n     }\n \n-    pub fn params(self, db: &dyn HirDatabase) -> Vec<TypeRef> {\n-        db.function_data(self.id).params.clone()\n+    pub fn params(self, db: &dyn HirDatabase) -> Vec<Param> {\n+        db.function_data(self.id)\n+            .params\n+            .iter()\n+            .skip(if self.self_param(db).is_some() { 1 } else { 0 })\n+            .map(|_| Param { _ty: () })\n+            .collect()\n     }\n \n     pub fn is_unsafe(self, db: &dyn HirDatabase) -> bool {\n@@ -727,6 +737,45 @@ impl Function {\n     }\n }\n \n+// Note: logically, this belongs to `hir_ty`, but we are not using it there yet.\n+pub enum Access {\n+    Shared,\n+    Exclusive,\n+    Owned,\n+}\n+\n+impl From<Mutability> for Access {\n+    fn from(mutability: Mutability) -> Access {\n+        match mutability {\n+            Mutability::Shared => Access::Shared,\n+            Mutability::Mut => Access::Exclusive,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SelfParam {\n+    func: FunctionId,\n+}\n+\n+pub struct Param {\n+    _ty: (),\n+}\n+\n+impl SelfParam {\n+    pub fn access(self, db: &dyn HirDatabase) -> Access {\n+        let func_data = db.function_data(self.func);\n+        func_data\n+            .params\n+            .first()\n+            .map(|param| match *param {\n+                TypeRef::Reference(_, mutability) => mutability.into(),\n+                _ => Access::Owned,\n+            })\n+            .unwrap_or(Access::Owned)\n+    }\n+}\n+\n impl HasVisibility for Function {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n         let function_data = db.function_data(self.id);\n@@ -856,7 +905,7 @@ pub struct MacroDef {\n impl MacroDef {\n     /// FIXME: right now, this just returns the root module of the crate that\n     /// defines this macro. The reasons for this is that macros are expanded\n-    /// early, in `ra_hir_expand`, where modules simply do not exist yet.\n+    /// early, in `hir_expand`, where modules simply do not exist yet.\n     pub fn module(self, db: &dyn HirDatabase) -> Option<Module> {\n         let krate = self.id.krate?;\n         let module_id = db.crate_def_map(krate).root;\n@@ -924,6 +973,13 @@ where\n }\n \n impl AssocItem {\n+    pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n+        match self {\n+            AssocItem::Function(it) => Some(it.name(db)),\n+            AssocItem::Const(it) => it.name(db),\n+            AssocItem::TypeAlias(it) => Some(it.name(db)),\n+        }\n+    }\n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n         match self {\n             AssocItem::Function(f) => f.module(db),\n@@ -1047,7 +1103,7 @@ impl Local {\n         Type::new(db, krate, def, ty)\n     }\n \n-    pub fn source(self, db: &dyn HirDatabase) -> InFile<Either<ast::BindPat, ast::SelfParam>> {\n+    pub fn source(self, db: &dyn HirDatabase) -> InFile<Either<ast::IdentPat, ast::SelfParam>> {\n         let (_body, source_map) = db.body_with_source_map(self.parent.into());\n         let src = source_map.pat_syntax(self.pat_id).unwrap(); // Hmm...\n         let root = src.file_syntax(db.upcast());\n@@ -1160,7 +1216,7 @@ impl ImplDef {\n             .value\n             .attrs()\n             .filter_map(|it| {\n-                let path = hir_def::path::ModPath::from_src(it.path()?, &hygenic)?;\n+                let path = ModPath::from_src(it.path()?, &hygenic)?;\n                 if path.as_ident()?.to_string() == \"derive\" {\n                     Some(it)\n                 } else {\n@@ -1277,6 +1333,15 @@ impl Type {\n         db.trait_solve(self.krate, goal).is_some()\n     }\n \n+    pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n+        let lang_item = db.lang_item(self.krate, SmolStr::new(\"copy\"));\n+        let copy_trait = match lang_item {\n+            Some(LangItemTarget::TraitId(it)) => it,\n+            _ => return false,\n+        };\n+        self.impls_trait(db, copy_trait.into(), &[])\n+    }\n+\n     pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n         let def = match self.ty.value {\n             Ty::Apply(ApplicationTy { ctor: TypeCtor::FnDef(def), parameters: _ }) => Some(def),\n@@ -1298,6 +1363,19 @@ impl Type {\n         )\n     }\n \n+    pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n+        let adt_id = match self.ty.value {\n+            Ty::Apply(ApplicationTy { ctor: TypeCtor::Adt(adt_id), .. }) => adt_id,\n+            _ => return false,\n+        };\n+\n+        let adt = adt_id.into();\n+        match adt {\n+            Adt::Struct(s) => matches!(s.repr(db), Some(ReprKind::Packed)),\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_raw_ptr(&self) -> bool {\n         matches!(&self.ty.value, Ty::Apply(ApplicationTy { ctor: TypeCtor::RawPtr(..), .. }))\n     }", "previous_filename": "crates/ra_hir/src/code_model.rs"}, {"sha": "07333c453f0e0c9f902ae0d636d7e0b94fdd61e7", "filename": "crates/hir/src/db.rs", "status": "renamed", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdb.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -13,14 +13,7 @@ pub use hir_expand::db::{\n     AstDatabase, AstDatabaseStorage, AstIdMapQuery, InternEagerExpansionQuery, InternMacroQuery,\n     MacroArgTextQuery, MacroDefQuery, MacroExpandQuery, ParseMacroQuery,\n };\n-pub use hir_ty::db::{\n-    AssociatedTyDataQuery, AssociatedTyValueQuery, CallableItemSignatureQuery, FieldTypesQuery,\n-    GenericDefaultsQuery, GenericPredicatesForParamQuery, GenericPredicatesQuery, HirDatabase,\n-    HirDatabaseStorage, ImplDatumQuery, ImplSelfTyQuery, ImplTraitQuery, InferQueryQuery,\n-    InherentImplsInCrateQuery, InternTypeParamIdQuery, ReturnTypeImplTraitsQuery, StructDatumQuery,\n-    TraitDatumQuery, TraitImplsInCrateQuery, TraitImplsInDepsQuery, TraitSolveQuery, TyQuery,\n-    ValueTyQuery,\n-};\n+pub use hir_ty::db::*;\n \n #[test]\n fn hir_database_is_object_safe() {", "previous_filename": "crates/ra_hir/src/db.rs"}, {"sha": "363164b9b4a68bc98c5afb5e1b465a6b1ac64785", "filename": "crates/hir/src/diagnostics.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,8 +1,6 @@\n //! FIXME: write short doc here\n pub use hir_def::diagnostics::UnresolvedModule;\n-pub use hir_expand::diagnostics::{\n-    AstDiagnostic, Diagnostic, DiagnosticSink, DiagnosticSinkBuilder,\n-};\n+pub use hir_expand::diagnostics::{Diagnostic, DiagnosticSink, DiagnosticSinkBuilder};\n pub use hir_ty::diagnostics::{\n     MismatchedArgCount, MissingFields, MissingMatchArms, MissingOkInTailExpr, NoSuchField,\n };", "previous_filename": "crates/ra_hir/src/diagnostics.rs"}, {"sha": "a53ac1e080be98d15222b2996dcbd74fbaebc7c6", "filename": "crates/hir/src/from_id.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Ffrom_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Ffrom_id.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -29,7 +29,7 @@ macro_rules! from_id {\n }\n \n from_id![\n-    (ra_db::CrateId, crate::Crate),\n+    (base_db::CrateId, crate::Crate),\n     (hir_def::ModuleId, crate::Module),\n     (hir_def::StructId, crate::Struct),\n     (hir_def::UnionId, crate::Union),", "previous_filename": "crates/ra_hir/src/from_id.rs"}, {"sha": "3bad2338a273b7805da53374e17fe15181f6ebfe", "filename": "crates/hir/src/has_source.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fhas_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fhas_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fhas_source.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,12 +1,12 @@\n-//! FIXME: write short doc here\n+//! Provides set of implementation for hir's objects that allows get back location in file.\n \n use either::Either;\n use hir_def::{\n     nameres::{ModuleOrigin, ModuleSource},\n     src::{HasChildSource, HasSource as _},\n     Lookup, VariantId,\n };\n-use ra_syntax::ast;\n+use syntax::ast;\n \n use crate::{\n     db::HirDatabase, Const, Enum, EnumVariant, Field, FieldSource, Function, ImplDef, MacroDef,", "previous_filename": "crates/ra_hir/src/has_source.rs"}, {"sha": "ae2f1fd4d33ef51b7951d973100f385ab94657a1", "filename": "crates/hir/src/lib.rs", "status": "renamed", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -9,11 +9,11 @@\n //! It is written in \"OO\" style. Each type is self contained (as in, it knows it's\n //! parents and full context). It should be \"clean code\".\n //!\n-//! `ra_hir_*` crates are the implementation of the compiler logic.\n+//! `hir_*` crates are the implementation of the compiler logic.\n //! They are written in \"ECS\" style, with relatively little abstractions.\n //! Many types are not self-contained, and explicitly use local indexes, arenas, etc.\n //!\n-//! `ra_hir` is what insulates the \"we don't know how to actually write an incremental compiler\"\n+//! `hir` is what insulates the \"we don't know how to actually write an incremental compiler\"\n //! from the ide with completions, hovers, etc. It is a (soft, internal) boundary:\n //! https://www.tedinski.com/2018/02/06/system-boundaries.html.\n \n@@ -33,10 +33,10 @@ mod has_source;\n \n pub use crate::{\n     code_model::{\n-        Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrDef, Callable, CallableKind, Const,\n-        Crate, CrateDependency, DefWithBody, Docs, Enum, EnumVariant, Field, FieldSource, Function,\n-        GenericDef, HasAttrs, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, ScopeDef,\n-        Static, Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n+        Access, Adt, AsAssocItem, AssocItem, AssocItemContainer, AttrDef, Callable, CallableKind,\n+        Const, Crate, CrateDependency, DefWithBody, Docs, Enum, EnumVariant, Field, FieldSource,\n+        Function, GenericDef, HasAttrs, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef,\n+        ScopeDef, Static, Struct, Trait, Type, TypeAlias, TypeParam, Union, VariantDef, Visibility,\n     },\n     has_source::HasSource,\n     link_rewrite::resolve_doc_link,\n@@ -51,13 +51,19 @@ pub use hir_def::{\n     docs::Documentation,\n     item_scope::ItemInNs,\n     nameres::ModuleSource,\n-    path::{ModPath, Path, PathKind},\n-    type_ref::Mutability,\n+    path::ModPath,\n+    type_ref::{Mutability, TypeRef},\n };\n pub use hir_expand::{\n-    hygiene::Hygiene,\n-    name::{AsName, Name},\n-    HirFileId, InFile, MacroCallId, MacroCallLoc, MacroDefId, /* FIXME */\n-    MacroFile, Origin,\n+    name::AsName, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc,\n+    /* FIXME */ MacroDefId, MacroFile, Origin,\n };\n pub use hir_ty::display::HirDisplay;\n+\n+// These are negative re-exports: pub using these names is forbidden, they\n+// should remain private to hir internals.\n+#[allow(unused)]\n+use {\n+    hir_def::path::{Path, PathKind},\n+    hir_expand::hygiene::Hygiene,\n+};", "previous_filename": "crates/ra_hir/src/lib.rs"}, {"sha": "dad3a39cfe74cac2f8d7b29f13920ec6cd9f0442", "filename": "crates/hir/src/link_rewrite.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Flink_rewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Flink_rewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flink_rewrite.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -7,7 +7,7 @@ use url::Url;\n \n use crate::{db::HirDatabase, Adt, AsName, Crate, Hygiene, ItemInNs, ModPath, ModuleDef};\n use hir_def::{db::DefDatabase, resolver::Resolver};\n-use ra_syntax::ast::Path;\n+use syntax::ast::Path;\n \n pub fn resolve_doc_link<T: Resolvable + Clone, D: DefDatabase + HirDatabase>(\n     db: &D,", "previous_filename": "crates/ra_hir/src/link_rewrite.rs"}, {"sha": "1594d4f0ff9937fb00054a2b5769869eb6b7373d", "filename": "crates/hir/src/semantics.rs", "status": "renamed", "additions": 151, "deletions": 63, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,30 +4,29 @@ mod source_to_def;\n \n use std::{cell::RefCell, fmt, iter::successors};\n \n+use base_db::{FileId, FileRange};\n use hir_def::{\n-    resolver::{self, HasResolver, Resolver},\n+    resolver::{self, HasResolver, Resolver, TypeNs},\n     AsMacroCall, FunctionId, TraitId, VariantId,\n };\n-use hir_expand::{diagnostics::AstDiagnostic, hygiene::Hygiene, ExpansionInfo};\n+use hir_expand::{hygiene::Hygiene, name::AsName, ExpansionInfo};\n use hir_ty::associated_type_shorthand_candidates;\n use itertools::Itertools;\n-use ra_db::{FileId, FileRange};\n-use ra_prof::profile;\n-use ra_syntax::{\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use syntax::{\n     algo::{find_node_at_offset, skip_trivia_token},\n     ast, AstNode, Direction, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n-use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n+    code_model::Access,\n     db::HirDatabase,\n     diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n-    source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n-    AssocItem, Callable, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module,\n-    ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n+    source_analyzer::{resolve_hir_path, SourceAnalyzer},\n+    AssocItem, Callable, Crate, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef,\n+    Module, ModuleDef, Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam, VariantDef,\n };\n-use resolver::TypeNs;\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum PathResolution {\n@@ -109,24 +108,16 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.parse(file_id)\n     }\n \n-    pub fn ast<T: AstDiagnostic + Diagnostic>(&self, d: &T) -> <T as AstDiagnostic>::AST {\n-        let file_id = d.source().file_id;\n-        let root = self.db.parse_or_expand(file_id).unwrap();\n-        self.imp.cache(root, file_id);\n-        d.ast(self.db.upcast())\n-    }\n-\n     pub fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n         self.imp.expand(macro_call)\n     }\n-\n-    pub fn expand_hypothetical(\n+    pub fn speculative_expand(\n         &self,\n         actual_macro_call: &ast::MacroCall,\n         hypothetical_args: &ast::TokenTree,\n         token_to_map: SyntaxToken,\n     ) -> Option<(SyntaxNode, SyntaxToken)> {\n-        self.imp.expand_hypothetical(actual_macro_call, hypothetical_args, token_to_map)\n+        self.imp.speculative_expand(actual_macro_call, hypothetical_args, token_to_map)\n     }\n \n     pub fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n@@ -145,8 +136,8 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.original_range(node)\n     }\n \n-    pub fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n-        self.imp.diagnostics_range(diagnostics)\n+    pub fn diagnostics_display_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n+        self.imp.diagnostics_display_range(diagnostics)\n     }\n \n     pub fn ancestors_with_macros(&self, node: SyntaxNode) -> impl Iterator<Item = SyntaxNode> + '_ {\n@@ -216,7 +207,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_record_field(field)\n     }\n \n-    pub fn resolve_record_field_pat(&self, field: &ast::RecordFieldPat) -> Option<Field> {\n+    pub fn resolve_record_field_pat(&self, field: &ast::RecordPatField) -> Option<Field> {\n         self.imp.resolve_record_field_pat(field)\n     }\n \n@@ -228,15 +219,15 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.resolve_path(path)\n     }\n \n-    pub fn resolve_variant(&self, record_lit: ast::RecordExpr) -> Option<VariantDef> {\n-        self.imp.resolve_variant(record_lit).map(VariantDef::from)\n+    pub fn resolve_extern_crate(&self, extern_crate: &ast::ExternCrate) -> Option<Crate> {\n+        self.imp.resolve_extern_crate(extern_crate)\n     }\n \n-    pub fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n-        self.imp.lower_path(path)\n+    pub fn resolve_variant(&self, record_lit: ast::RecordExpr) -> Option<VariantDef> {\n+        self.imp.resolve_variant(record_lit).map(VariantDef::from)\n     }\n \n-    pub fn resolve_bind_pat_to_const(&self, pat: &ast::BindPat) -> Option<ModuleDef> {\n+    pub fn resolve_bind_pat_to_const(&self, pat: &ast::IdentPat) -> Option<ModuleDef> {\n         self.imp.resolve_bind_pat_to_const(pat)\n     }\n \n@@ -275,6 +266,18 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn assert_contains_node(&self, node: &SyntaxNode) {\n         self.imp.assert_contains_node(node)\n     }\n+\n+    pub fn is_unsafe_method_call(&self, method_call_expr: &ast::MethodCallExpr) -> bool {\n+        self.imp.is_unsafe_method_call(method_call_expr)\n+    }\n+\n+    pub fn is_unsafe_ref_expr(&self, ref_expr: &ast::RefExpr) -> bool {\n+        self.imp.is_unsafe_ref_expr(ref_expr)\n+    }\n+\n+    pub fn is_unsafe_ident_pat(&self, ident_pat: &ast::IdentPat) -> bool {\n+        self.imp.is_unsafe_ident_pat(ident_pat)\n+    }\n }\n \n impl<'db> SemanticsImpl<'db> {\n@@ -302,7 +305,7 @@ impl<'db> SemanticsImpl<'db> {\n         Some(node)\n     }\n \n-    fn expand_hypothetical(\n+    fn speculative_expand(\n         &self,\n         actual_macro_call: &ast::MacroCall,\n         hypothetical_args: &ast::TokenTree,\n@@ -324,7 +327,7 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n-        let _p = profile(\"descend_into_macros\");\n+        let _p = profile::span(\"descend_into_macros\");\n         let parent = token.parent();\n         let parent = self.find_file(parent);\n         let sa = self.analyze2(parent.as_ref(), None);\n@@ -372,10 +375,11 @@ impl<'db> SemanticsImpl<'db> {\n         original_range(self.db, node.as_ref())\n     }\n \n-    fn diagnostics_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n-        let src = diagnostics.source();\n+    fn diagnostics_display_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n+        let src = diagnostics.display_source();\n         let root = self.db.parse_or_expand(src.file_id).unwrap();\n         let node = src.value.to_node(&root);\n+        self.cache(root, src.file_id);\n         original_range(self.db, src.with_value(&node))\n     }\n \n@@ -429,7 +433,7 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(field.syntax()).resolve_record_field(self.db, field)\n     }\n \n-    fn resolve_record_field_pat(&self, field: &ast::RecordFieldPat) -> Option<Field> {\n+    fn resolve_record_field_pat(&self, field: &ast::RecordPatField) -> Option<Field> {\n         self.analyze(field.syntax()).resolve_record_field_pat(self.db, field)\n     }\n \n@@ -443,16 +447,22 @@ impl<'db> SemanticsImpl<'db> {\n         self.analyze(path.syntax()).resolve_path(self.db, path)\n     }\n \n-    fn resolve_variant(&self, record_lit: ast::RecordExpr) -> Option<VariantId> {\n-        self.analyze(record_lit.syntax()).resolve_variant(self.db, record_lit)\n+    fn resolve_extern_crate(&self, extern_crate: &ast::ExternCrate) -> Option<Crate> {\n+        let krate = self.scope(extern_crate.syntax()).krate()?;\n+        krate.dependencies(self.db).into_iter().find_map(|dep| {\n+            if dep.name == extern_crate.name_ref()?.as_name() {\n+                Some(dep.krate)\n+            } else {\n+                None\n+            }\n+        })\n     }\n \n-    fn lower_path(&self, path: &ast::Path) -> Option<Path> {\n-        let src = self.find_file(path.syntax().clone());\n-        Path::from_src(path.clone(), &Hygiene::new(self.db.upcast(), src.file_id.into()))\n+    fn resolve_variant(&self, record_lit: ast::RecordExpr) -> Option<VariantId> {\n+        self.analyze(record_lit.syntax()).resolve_variant(self.db, record_lit)\n     }\n \n-    fn resolve_bind_pat_to_const(&self, pat: &ast::BindPat) -> Option<ModuleDef> {\n+    fn resolve_bind_pat_to_const(&self, pat: &ast::IdentPat) -> Option<ModuleDef> {\n         self.analyze(pat.syntax()).resolve_bind_pat_to_const(self.db, pat)\n     }\n \n@@ -481,18 +491,19 @@ impl<'db> SemanticsImpl<'db> {\n     fn scope(&self, node: &SyntaxNode) -> SemanticsScope<'db> {\n         let node = self.find_file(node.clone());\n         let resolver = self.analyze2(node.as_ref(), None).resolver;\n-        SemanticsScope { db: self.db, resolver }\n+        SemanticsScope { db: self.db, file_id: node.file_id, resolver }\n     }\n \n     fn scope_at_offset(&self, node: &SyntaxNode, offset: TextSize) -> SemanticsScope<'db> {\n         let node = self.find_file(node.clone());\n         let resolver = self.analyze2(node.as_ref(), Some(offset)).resolver;\n-        SemanticsScope { db: self.db, resolver }\n+        SemanticsScope { db: self.db, file_id: node.file_id, resolver }\n     }\n \n     fn scope_for_def(&self, def: Trait) -> SemanticsScope<'db> {\n+        let file_id = self.db.lookup_intern_trait(def.id).id.file_id;\n         let resolver = def.id.resolver(self.db.upcast());\n-        SemanticsScope { db: self.db, resolver }\n+        SemanticsScope { db: self.db, file_id, resolver }\n     }\n \n     fn analyze(&self, node: &SyntaxNode) -> SourceAnalyzer {\n@@ -501,7 +512,7 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn analyze2(&self, src: InFile<&SyntaxNode>, offset: Option<TextSize>) -> SourceAnalyzer {\n-        let _p = profile(\"Semantics::analyze2\");\n+        let _p = profile::span(\"Semantics::analyze2\");\n \n         let container = match self.with_ctx(|ctx| ctx.find_container(src)) {\n             Some(it) => it,\n@@ -559,6 +570,91 @@ impl<'db> SemanticsImpl<'db> {\n         });\n         InFile::new(file_id, node)\n     }\n+\n+    fn is_unsafe_method_call(&self, method_call_expr: &ast::MethodCallExpr) -> bool {\n+        method_call_expr\n+            .receiver()\n+            .and_then(|expr| {\n+                let field_expr = match expr {\n+                    ast::Expr::FieldExpr(field_expr) => field_expr,\n+                    _ => return None,\n+                };\n+                let ty = self.type_of_expr(&field_expr.expr()?)?;\n+                if !ty.is_packed(self.db) {\n+                    return None;\n+                }\n+\n+                let func = self.resolve_method_call(&method_call_expr).map(Function::from)?;\n+                let res = match func.self_param(self.db)?.access(self.db) {\n+                    Access::Shared | Access::Exclusive => true,\n+                    Access::Owned => false,\n+                };\n+                Some(res)\n+            })\n+            .unwrap_or(false)\n+    }\n+\n+    fn is_unsafe_ref_expr(&self, ref_expr: &ast::RefExpr) -> bool {\n+        ref_expr\n+            .expr()\n+            .and_then(|expr| {\n+                let field_expr = match expr {\n+                    ast::Expr::FieldExpr(field_expr) => field_expr,\n+                    _ => return None,\n+                };\n+                let expr = field_expr.expr()?;\n+                self.type_of_expr(&expr)\n+            })\n+            // Binding a reference to a packed type is possibly unsafe.\n+            .map(|ty| ty.is_packed(self.db))\n+            .unwrap_or(false)\n+\n+        // FIXME This needs layout computation to be correct. It will highlight\n+        // more than it should with the current implementation.\n+    }\n+\n+    fn is_unsafe_ident_pat(&self, ident_pat: &ast::IdentPat) -> bool {\n+        if !ident_pat.ref_token().is_some() {\n+            return false;\n+        }\n+\n+        ident_pat\n+            .syntax()\n+            .parent()\n+            .and_then(|parent| {\n+                // `IdentPat` can live under `RecordPat` directly under `RecordPatField` or\n+                // `RecordPatFieldList`. `RecordPatField` also lives under `RecordPatFieldList`,\n+                // so this tries to lookup the `IdentPat` anywhere along that structure to the\n+                // `RecordPat` so we can get the containing type.\n+                let record_pat = ast::RecordPatField::cast(parent.clone())\n+                    .and_then(|record_pat| record_pat.syntax().parent())\n+                    .or_else(|| Some(parent.clone()))\n+                    .and_then(|parent| {\n+                        ast::RecordPatFieldList::cast(parent)?\n+                            .syntax()\n+                            .parent()\n+                            .and_then(ast::RecordPat::cast)\n+                    });\n+\n+                // If this doesn't match a `RecordPat`, fallback to a `LetStmt` to see if\n+                // this is initialized from a `FieldExpr`.\n+                if let Some(record_pat) = record_pat {\n+                    self.type_of_pat(&ast::Pat::RecordPat(record_pat))\n+                } else if let Some(let_stmt) = ast::LetStmt::cast(parent) {\n+                    let field_expr = match let_stmt.initializer()? {\n+                        ast::Expr::FieldExpr(field_expr) => field_expr,\n+                        _ => return None,\n+                    };\n+\n+                    self.type_of_expr(&field_expr.expr()?)\n+                } else {\n+                    None\n+                }\n+            })\n+            // Binding a reference to a packed type is possibly unsafe.\n+            .map(|ty| ty.is_packed(self.db))\n+            .unwrap_or(false)\n+    }\n }\n \n pub trait ToDef: AstNode + Clone {\n@@ -594,7 +690,7 @@ to_def_impls![\n     (crate::EnumVariant, ast::Variant, enum_variant_to_def),\n     (crate::TypeParam, ast::TypeParam, type_param_to_def),\n     (crate::MacroDef, ast::MacroCall, macro_call_to_def), // this one is dubious, not all calls are macros\n-    (crate::Local, ast::BindPat, bind_pat_to_def),\n+    (crate::Local, ast::IdentPat, bind_pat_to_def),\n ];\n \n fn find_root(node: &SyntaxNode) -> SyntaxNode {\n@@ -604,6 +700,7 @@ fn find_root(node: &SyntaxNode) -> SyntaxNode {\n #[derive(Debug)]\n pub struct SemanticsScope<'a> {\n     pub db: &'a dyn HirDatabase,\n+    file_id: HirFileId,\n     resolver: Resolver,\n }\n \n@@ -612,6 +709,10 @@ impl<'a> SemanticsScope<'a> {\n         Some(Module { id: self.resolver.module()? })\n     }\n \n+    pub fn krate(&self) -> Option<Crate> {\n+        Some(Crate { id: self.resolver.krate()? })\n+    }\n+\n     /// Note: `FxHashSet<TraitId>` should be treated as an opaque type, passed into `Type\n     // FIXME: rename to visible_traits to not repeat scope?\n     pub fn traits_in_scope(&self) -> FxHashSet<TraitId> {\n@@ -643,25 +744,12 @@ impl<'a> SemanticsScope<'a> {\n         })\n     }\n \n-    pub fn resolve_hir_path(&self, path: &Path) -> Option<PathResolution> {\n-        resolve_hir_path(self.db, &self.resolver, path)\n-    }\n-\n-    /// Resolves a path where we know it is a qualifier of another path.\n-    ///\n-    /// For example, if we have:\n-    /// ```\n-    /// mod my {\n-    ///     pub mod foo {\n-    ///         struct Bar;\n-    ///     }\n-    ///\n-    ///     pub fn foo() {}\n-    /// }\n-    /// ```\n-    /// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n-    pub fn resolve_hir_path_qualifier(&self, path: &Path) -> Option<PathResolution> {\n-        resolve_hir_path_qualifier(self.db, &self.resolver, path)\n+    /// Resolve a path as-if it was written at the given scope. This is\n+    /// necessary a heuristic, as it doesn't take hygiene into account.\n+    pub fn speculative_resolve(&self, path: &ast::Path) -> Option<PathResolution> {\n+        let hygiene = Hygiene::new(self.db.upcast(), self.file_id);\n+        let path = Path::from_src(path.clone(), &hygiene)?;\n+        resolve_hir_path(self.db, &self.resolver, &path)\n     }\n }\n ", "previous_filename": "crates/ra_hir/src/semantics.rs"}, {"sha": "5918b9541be2ecd0c79ace07e72a8cbb451167b2", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "renamed", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,6 @@\n //! Maps *syntax* of various definitions to their semantic ids.\n \n+use base_db::FileId;\n use hir_def::{\n     child_by_source::ChildBySource,\n     dyn_map::DynMap,\n@@ -9,14 +10,12 @@ use hir_def::{\n     ModuleId, StaticId, StructId, TraitId, TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::AsName, AstId, MacroDefKind};\n-use ra_db::FileId;\n-use ra_prof::profile;\n-use ra_syntax::{\n+use rustc_hash::FxHashMap;\n+use stdx::impl_from;\n+use syntax::{\n     ast::{self, NameOwner},\n     match_ast, AstNode, SyntaxNode,\n };\n-use rustc_hash::FxHashMap;\n-use stdx::impl_from;\n \n use crate::{db::HirDatabase, InFile, MacroDefId};\n \n@@ -29,7 +28,7 @@ pub(super) struct SourceToDefCtx<'a, 'b> {\n \n impl SourceToDefCtx<'_, '_> {\n     pub(super) fn file_to_def(&mut self, file: FileId) -> Option<ModuleId> {\n-        let _p = profile(\"SourceBinder::to_module_def\");\n+        let _p = profile::span(\"SourceBinder::to_module_def\");\n         let (krate, local_id) = self.db.relevant_crates(file).iter().find_map(|&crate_id| {\n             let crate_def_map = self.db.crate_def_map(crate_id);\n             let local_id = crate_def_map.modules_for_file(file).next()?;\n@@ -39,7 +38,7 @@ impl SourceToDefCtx<'_, '_> {\n     }\n \n     pub(super) fn module_to_def(&mut self, src: InFile<ast::Module>) -> Option<ModuleId> {\n-        let _p = profile(\"module_to_def\");\n+        let _p = profile::span(\"module_to_def\");\n         let parent_declaration = src\n             .as_ref()\n             .map(|it| it.syntax())\n@@ -106,7 +105,7 @@ impl SourceToDefCtx<'_, '_> {\n     }\n     pub(super) fn bind_pat_to_def(\n         &mut self,\n-        src: InFile<ast::BindPat>,\n+        src: InFile<ast::IdentPat>,\n     ) -> Option<(DefWithBodyId, PatId)> {\n         let container = self.find_pat_container(src.as_ref().map(|it| it.syntax()))?;\n         let (_body, source_map) = self.db.body_with_source_map(container);", "previous_filename": "crates/ra_hir/src/semantics/source_to_def.rs"}, {"sha": "1d13c4f1d3b7d276b883e0f9edb6e52a59ec9c1a", "filename": "crates/hir/src/source_analyzer.rs", "status": "renamed", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -13,6 +13,7 @@ use hir_def::{\n         Body, BodySourceMap,\n     },\n     expr::{ExprId, Pat, PatId},\n+    path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     AsMacroCall, DefWithBodyId, FieldId, FunctionId, LocalFieldId, VariantId,\n };\n@@ -21,17 +22,16 @@ use hir_ty::{\n     diagnostics::{record_literal_missing_fields, record_pattern_missing_fields},\n     InferenceResult, Substs, Ty,\n };\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode},\n     SyntaxNode, TextRange, TextSize,\n };\n \n use crate::{\n     db::HirDatabase, semantics::PathResolution, Adt, Const, EnumVariant, Field, Function, Local,\n-    MacroDef, ModPath, ModuleDef, Path, PathKind, Static, Struct, Trait, Type, TypeAlias,\n-    TypeParam,\n+    MacroDef, ModuleDef, Static, Struct, Trait, Type, TypeAlias, TypeParam,\n };\n-use ra_db::CrateId;\n+use base_db::CrateId;\n \n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n /// original source files. It should not be used inside the HIR itself.\n@@ -182,7 +182,7 @@ impl SourceAnalyzer {\n     pub(crate) fn resolve_record_field_pat(\n         &self,\n         _db: &dyn HirDatabase,\n-        field: &ast::RecordFieldPat,\n+        field: &ast::RecordPatField,\n     ) -> Option<Field> {\n         let pat_id = self.pat_id(&field.pat()?)?;\n         let struct_field = self.infer.as_ref()?.record_field_pat_resolution(pat_id)?;\n@@ -202,7 +202,7 @@ impl SourceAnalyzer {\n     pub(crate) fn resolve_bind_pat_to_const(\n         &self,\n         db: &dyn HirDatabase,\n-        pat: &ast::BindPat,\n+        pat: &ast::IdentPat,\n     ) -> Option<ModuleDef> {\n         let pat_id = self.pat_id(&pat.clone().into())?;\n         let body = self.body.as_ref()?;\n@@ -265,8 +265,7 @@ impl SourceAnalyzer {\n         }\n \n         // This must be a normal source file rather than macro file.\n-        let hir_path =\n-            crate::Path::from_src(path.clone(), &Hygiene::new(db.upcast(), self.file_id))?;\n+        let hir_path = Path::from_src(path.clone(), &Hygiene::new(db.upcast(), self.file_id))?;\n \n         // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we\n         // trying to resolve foo::bar.\n@@ -451,7 +450,7 @@ fn adjust(\n pub(crate) fn resolve_hir_path(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n-    path: &crate::Path,\n+    path: &Path,\n ) -> Option<PathResolution> {\n     let types =\n         resolver.resolve_path_in_type_ns_fully(db.upcast(), path.mod_path()).map(|ty| match ty {\n@@ -509,10 +508,10 @@ pub(crate) fn resolve_hir_path(\n /// }\n /// ```\n /// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n-pub(crate) fn resolve_hir_path_qualifier(\n+fn resolve_hir_path_qualifier(\n     db: &dyn HirDatabase,\n     resolver: &Resolver,\n-    path: &crate::Path,\n+    path: &Path,\n ) -> Option<PathResolution> {\n     let items = resolver\n         .resolve_module_path_in_items(db.upcast(), path.mod_path())", "previous_filename": "crates/ra_hir/src/source_analyzer.rs"}, {"sha": "57745322fd8d432f95557b8c34ea7ab81bc1affc", "filename": "crates/hir_def/Cargo.toml", "status": "renamed", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n [package]\n-edition = \"2018\"\n-name = \"ra_hir_def\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n+name = \"hir_def\"\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false\n@@ -21,16 +21,15 @@ indexmap = \"1.4.0\"\n smallvec = \"1.4.0\"\n \n stdx = { path = \"../stdx\" }\n-\n-ra_arena = { path = \"../ra_arena\" }\n-ra_db = { path = \"../ra_db\" }\n-ra_syntax = { path = \"../ra_syntax\" }\n-ra_prof = { path = \"../ra_prof\" }\n-hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n+arena = { path = \"../arena\" }\n+base_db = { path = \"../base_db\" }\n+syntax = { path = \"../syntax\" }\n+profile = { path = \"../profile\" }\n+hir_expand = { path = \"../hir_expand\" }\n test_utils = { path = \"../test_utils\" }\n-mbe = { path = \"../ra_mbe\", package = \"ra_mbe\" }\n-ra_cfg = { path = \"../ra_cfg\" }\n-tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n+mbe = { path = \"../mbe\" }\n+cfg = { path = \"../cfg\" }\n+tt = { path = \"../tt\" }\n \n [dev-dependencies]\n-expect = { path = \"../expect\" }\n+expect-test = \"0.1\"", "previous_filename": "crates/ra_hir_def/Cargo.toml"}, {"sha": "d69ff2fc79e760a0829cc2cae4bc0f7f0e952eab", "filename": "crates/hir_def/src/adt.rs", "status": "renamed", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fadt.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,18 +2,19 @@\n \n use std::sync::Arc;\n \n+use arena::{map::ArenaMap, Arena};\n use either::Either;\n use hir_expand::{\n     name::{AsName, Name},\n     InFile,\n };\n-use ra_arena::{map::ArenaMap, Arena};\n-use ra_syntax::ast::{self, NameOwner, VisibilityOwner};\n+use syntax::ast::{self, NameOwner, VisibilityOwner};\n+use tt::{Delimiter, DelimiterKind, Leaf, Subtree, TokenTree};\n \n use crate::{\n     body::{CfgExpander, LowerCtx},\n     db::DefDatabase,\n-    item_tree::{Field, Fields, ItemTree},\n+    item_tree::{AttrOwner, Field, Fields, ItemTree, ModItem},\n     src::HasChildSource,\n     src::HasSource,\n     trace::Trace,\n@@ -22,13 +23,14 @@ use crate::{\n     EnumId, HasModule, LocalEnumVariantId, LocalFieldId, Lookup, ModuleId, StructId, UnionId,\n     VariantId,\n };\n-use ra_cfg::CfgOptions;\n+use cfg::CfgOptions;\n \n /// Note that we use `StructData` for unions as well!\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct StructData {\n     pub name: Name,\n     pub variant_data: Arc<VariantData>,\n+    pub repr: Option<ReprKind>,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -58,26 +60,58 @@ pub struct FieldData {\n     pub visibility: RawVisibility,\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ReprKind {\n+    Packed,\n+    Other,\n+}\n+\n+fn repr_from_value(item_tree: &ItemTree, of: AttrOwner) -> Option<ReprKind> {\n+    item_tree.attrs(of).by_key(\"repr\").tt_values().find_map(parse_repr_tt)\n+}\n+\n+fn parse_repr_tt(tt: &Subtree) -> Option<ReprKind> {\n+    match tt.delimiter {\n+        Some(Delimiter { kind: DelimiterKind::Parenthesis, .. }) => {}\n+        _ => return None,\n+    }\n+\n+    let mut it = tt.token_trees.iter();\n+    match it.next()? {\n+        TokenTree::Leaf(Leaf::Ident(ident)) if ident.text == \"packed\" => Some(ReprKind::Packed),\n+        _ => Some(ReprKind::Other),\n+    }\n+}\n+\n impl StructData {\n     pub(crate) fn struct_data_query(db: &dyn DefDatabase, id: StructId) -> Arc<StructData> {\n         let loc = id.lookup(db);\n         let item_tree = db.item_tree(loc.id.file_id);\n+        let repr = repr_from_value(&item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.module(db).krate].cfg_options.clone();\n \n         let strukt = &item_tree[loc.id.value];\n         let variant_data = lower_fields(&item_tree, &cfg_options, &strukt.fields);\n-\n-        Arc::new(StructData { name: strukt.name.clone(), variant_data: Arc::new(variant_data) })\n+        Arc::new(StructData {\n+            name: strukt.name.clone(),\n+            variant_data: Arc::new(variant_data),\n+            repr,\n+        })\n     }\n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n         let loc = id.lookup(db);\n         let item_tree = db.item_tree(loc.id.file_id);\n+        let repr = repr_from_value(&item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.module(db).krate].cfg_options.clone();\n \n         let union = &item_tree[loc.id.value];\n         let variant_data = lower_fields(&item_tree, &cfg_options, &union.fields);\n \n-        Arc::new(StructData { name: union.name.clone(), variant_data: Arc::new(variant_data) })\n+        Arc::new(StructData {\n+            name: union.name.clone(),\n+            variant_data: Arc::new(variant_data),\n+            repr,\n+        })\n     }\n }\n ", "previous_filename": "crates/ra_hir_def/src/adt.rs"}, {"sha": "dea552a605a4bbf664accf316a8f5a341eb535fd", "filename": "crates/hir_def/src/attr.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,11 +2,11 @@\n \n use std::{ops, sync::Arc};\n \n+use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n use hir_expand::{hygiene::Hygiene, AstId, InFile};\n use mbe::ast_to_token_tree;\n-use ra_cfg::{CfgExpr, CfgOptions};\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     SmolStr,\n };", "previous_filename": "crates/ra_hir_def/src/attr.rs"}, {"sha": "9a9a605ddb943055492a0c667329d4db4ddc6068", "filename": "crates/hir_def/src/body.rs", "status": "renamed", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,15 +5,14 @@ pub mod scope;\n \n use std::{mem, ops::Index, sync::Arc};\n \n+use arena::{map::ArenaMap, Arena};\n+use base_db::CrateId;\n+use cfg::CfgOptions;\n use drop_bomb::DropBomb;\n use either::Either;\n use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, AstId, HirFileId, InFile, MacroDefId};\n-use ra_arena::{map::ArenaMap, Arena};\n-use ra_cfg::CfgOptions;\n-use ra_db::CrateId;\n-use ra_prof::profile;\n-use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n+use syntax::{ast, AstNode, AstPtr};\n use test_utils::mark;\n \n pub(crate) use lower::LowerCtx;\n@@ -228,7 +227,7 @@ impl Body {\n         db: &dyn DefDatabase,\n         def: DefWithBodyId,\n     ) -> (Arc<Body>, Arc<BodySourceMap>) {\n-        let _p = profile(\"body_with_source_map_query\");\n+        let _p = profile::span(\"body_with_source_map_query\");\n         let mut params = None;\n \n         let (file_id, module, body) = match def {\n@@ -321,7 +320,7 @@ impl BodySourceMap {\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::{fixture::WithFixture, SourceDatabase};\n+    use base_db::{fixture::WithFixture, SourceDatabase};\n     use test_utils::mark;\n \n     use crate::ModuleDefId;", "previous_filename": "crates/ra_hir_def/src/body.rs"}, {"sha": "30ac12a12e431369112ad294b514db88c393c2f6", "filename": "crates/hir_def/src/body/lower.rs", "status": "renamed", "additions": 69, "deletions": 54, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Flower.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,16 +1,19 @@\n //! Transforms `ast::Expr` into an equivalent `hir_def::expr::Expr`\n //! representation.\n \n+use std::{any::type_name, sync::Arc};\n+\n+use arena::Arena;\n use either::Either;\n use hir_expand::{\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n     HirFileId, MacroDefId, MacroDefKind,\n };\n-use ra_arena::Arena;\n-use ra_syntax::{\n+use rustc_hash::FxHashMap;\n+use syntax::{\n     ast::{\n-        self, ArgListOwner, ArrayExprKind, LiteralKind, LoopBodyOwner, ModuleItemOwner, NameOwner,\n+        self, ArgListOwner, ArrayExprKind, AstChildren, LiteralKind, LoopBodyOwner, NameOwner,\n         SlicePatComponents,\n     },\n     AstNode, AstPtr,\n@@ -35,9 +38,6 @@ use crate::{\n };\n \n use super::{ExprSource, PatSource};\n-use ast::AstChildren;\n-use rustc_hash::FxHashMap;\n-use std::{any::type_name, sync::Arc};\n \n pub(crate) struct LowerCtx {\n     hygiene: Hygiene,\n@@ -224,9 +224,22 @@ impl ExprCollector<'_> {\n                     self.alloc_expr(Expr::Unsafe { body }, syntax_ptr)\n                 }\n                 // FIXME: we need to record these effects somewhere...\n-                ast::Effect::Async(_) | ast::Effect::Label(_) => {\n-                    self.collect_block_opt(e.block_expr())\n-                }\n+                ast::Effect::Label(label) => match e.block_expr() {\n+                    Some(block) => {\n+                        let res = self.collect_block(block);\n+                        match &mut self.body.exprs[res] {\n+                            Expr::Block { label: block_label, .. } => {\n+                                *block_label =\n+                                    label.lifetime_token().map(|t| Name::new_lifetime(&t))\n+                            }\n+                            _ => unreachable!(),\n+                        }\n+                        res\n+                    }\n+                    None => self.missing_expr(),\n+                },\n+                // FIXME: we need to record these effects somewhere...\n+                ast::Effect::Async(_) => self.collect_block_opt(e.block_expr()),\n             },\n             ast::Expr::BlockExpr(e) => self.collect_block(e),\n             ast::Expr::LoopExpr(e) => {\n@@ -316,15 +329,15 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::Call { callee, args }, syntax_ptr)\n             }\n             ast::Expr::MethodCallExpr(e) => {\n-                let receiver = self.collect_expr_opt(e.expr());\n+                let receiver = self.collect_expr_opt(e.receiver());\n                 let args = if let Some(arg_list) = e.arg_list() {\n                     arg_list.args().map(|e| self.collect_expr(e)).collect()\n                 } else {\n                     Vec::new()\n                 };\n                 let method_name = e.name_ref().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let generic_args =\n-                    e.type_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx(), it));\n+                    e.generic_arg_list().and_then(|it| GenericArgs::from_ast(&self.ctx(), it));\n                 self.alloc_expr(\n                     Expr::MethodCall { receiver, method_name, args, generic_args },\n                     syntax_ptr,\n@@ -460,7 +473,7 @@ impl ExprCollector<'_> {\n                     self.alloc_expr(Expr::Missing, syntax_ptr)\n                 }\n             }\n-            ast::Expr::LambdaExpr(e) => {\n+            ast::Expr::ClosureExpr(e) => {\n                 let mut args = Vec::new();\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n@@ -483,7 +496,7 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n             }\n             ast::Expr::TupleExpr(e) => {\n-                let exprs = e.exprs().map(|expr| self.collect_expr(expr)).collect();\n+                let exprs = e.fields().map(|expr| self.collect_expr(expr)).collect();\n                 self.alloc_expr(Expr::Tuple { exprs }, syntax_ptr)\n             }\n             ast::Expr::BoxExpr(e) => {\n@@ -556,9 +569,6 @@ impl ExprCollector<'_> {\n                     }\n                 }\n             }\n-\n-            // FIXME implement HIR for these:\n-            ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n         }\n     }\n \n@@ -601,26 +611,35 @@ impl ExprCollector<'_> {\n         self.collect_block_items(&block);\n         let statements = block\n             .statements()\n-            .map(|s| match s {\n-                ast::Stmt::LetStmt(stmt) => {\n-                    let pat = self.collect_pat_opt(stmt.pat());\n-                    let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n-                    let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n-                    Statement::Let { pat, type_ref, initializer }\n-                }\n-                ast::Stmt::ExprStmt(stmt) => Statement::Expr(self.collect_expr_opt(stmt.expr())),\n+            .filter_map(|s| {\n+                let stmt = match s {\n+                    ast::Stmt::LetStmt(stmt) => {\n+                        let pat = self.collect_pat_opt(stmt.pat());\n+                        let type_ref = stmt.ty().map(|it| TypeRef::from_ast(&self.ctx(), it));\n+                        let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n+                        Statement::Let { pat, type_ref, initializer }\n+                    }\n+                    ast::Stmt::ExprStmt(stmt) => {\n+                        Statement::Expr(self.collect_expr_opt(stmt.expr()))\n+                    }\n+                    ast::Stmt::Item(_) => return None,\n+                };\n+                Some(stmt)\n             })\n             .collect();\n         let tail = block.expr().map(|e| self.collect_expr(e));\n-        let label = block.label().and_then(|l| l.lifetime_token()).map(|t| Name::new_lifetime(&t));\n-        self.alloc_expr(Expr::Block { statements, tail, label }, syntax_node_ptr)\n+        self.alloc_expr(Expr::Block { statements, tail, label: None }, syntax_node_ptr)\n     }\n \n     fn collect_block_items(&mut self, block: &ast::BlockExpr) {\n         let container = ContainerId::DefWithBodyId(self.def);\n \n         let items = block\n-            .items()\n+            .statements()\n+            .filter_map(|stmt| match stmt {\n+                ast::Stmt::Item(it) => Some(it),\n+                ast::Stmt::LetStmt(_) | ast::Stmt::ExprStmt(_) => None,\n+            })\n             .filter_map(|item| {\n                 let (def, name): (ModuleDefId, Option<ast::Name>) = match item {\n                     ast::Item::Fn(def) => {\n@@ -704,7 +723,7 @@ impl ExprCollector<'_> {\n \n     fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n         let pattern = match &pat {\n-            ast::Pat::BindPat(bp) => {\n+            ast::Pat::IdentPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n                 let annotation =\n                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n@@ -743,7 +762,7 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::TupleStructPat(p) => {\n                 let path = p.path().and_then(|path| self.expander.parse_path(path));\n-                let (args, ellipsis) = self.collect_tuple_pat(p.args());\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n@@ -761,40 +780,36 @@ impl ExprCollector<'_> {\n             }\n             ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat()),\n             ast::Pat::TuplePat(p) => {\n-                let (args, ellipsis) = self.collect_tuple_pat(p.args());\n+                let (args, ellipsis) = self.collect_tuple_pat(p.fields());\n                 Pat::Tuple { args, ellipsis }\n             }\n-            ast::Pat::PlaceholderPat(_) => Pat::Wild,\n+            ast::Pat::WildcardPat(_) => Pat::Wild,\n             ast::Pat::RecordPat(p) => {\n                 let path = p.path().and_then(|path| self.expander.parse_path(path));\n-                let record_field_pat_list =\n-                    p.record_field_pat_list().expect(\"every struct should have a field list\");\n-                let mut fields: Vec<_> = record_field_pat_list\n-                    .bind_pats()\n-                    .filter_map(|bind_pat| {\n-                        let ast_pat =\n-                            ast::Pat::cast(bind_pat.syntax().clone()).expect(\"bind pat is a pat\");\n+                let args: Vec<_> = p\n+                    .record_pat_field_list()\n+                    .expect(\"every struct should have a field list\")\n+                    .fields()\n+                    .filter_map(|f| {\n+                        let ast_pat = f.pat()?;\n                         let pat = self.collect_pat(ast_pat);\n-                        let name = bind_pat.name()?.as_name();\n+                        let name = f.field_name()?.as_name();\n                         Some(RecordFieldPat { name, pat })\n                     })\n                     .collect();\n-                let iter = record_field_pat_list.record_field_pats().filter_map(|f| {\n-                    let ast_pat = f.pat()?;\n-                    let pat = self.collect_pat(ast_pat);\n-                    let name = f.field_name()?.as_name();\n-                    Some(RecordFieldPat { name, pat })\n-                });\n-                fields.extend(iter);\n \n-                let ellipsis = record_field_pat_list.dotdot_token().is_some();\n+                let ellipsis = p\n+                    .record_pat_field_list()\n+                    .expect(\"every struct should have a field list\")\n+                    .dotdot_token()\n+                    .is_some();\n \n-                Pat::Record { path, args: fields, ellipsis }\n+                Pat::Record { path, args, ellipsis }\n             }\n             ast::Pat::SlicePat(p) => {\n                 let SlicePatComponents { prefix, slice, suffix } = p.components();\n \n-                // FIXME properly handle `DotDotPat`\n+                // FIXME properly handle `RestPat`\n                 Pat::Slice {\n                     prefix: prefix.into_iter().map(|p| self.collect_pat(p)).collect(),\n                     slice: slice.map(|p| self.collect_pat(p)),\n@@ -811,10 +826,10 @@ impl ExprCollector<'_> {\n                     Pat::Missing\n                 }\n             }\n-            ast::Pat::DotDotPat(_) => {\n-                // `DotDotPat` requires special handling and should not be mapped\n+            ast::Pat::RestPat(_) => {\n+                // `RestPat` requires special handling and should not be mapped\n                 // to a Pat. Here we are using `Pat::Missing` as a fallback for\n-                // when `DotDotPat` is mapped to `Pat`, which can easily happen\n+                // when `RestPat` is mapped to `Pat`, which can easily happen\n                 // when the source code being analyzed has a malformed pattern\n                 // which includes `..` in a place where it isn't valid.\n \n@@ -838,10 +853,10 @@ impl ExprCollector<'_> {\n     fn collect_tuple_pat(&mut self, args: AstChildren<ast::Pat>) -> (Vec<PatId>, Option<usize>) {\n         // Find the location of the `..`, if there is one. Note that we do not\n         // consider the possiblity of there being multiple `..` here.\n-        let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::DotDotPat(_)));\n+        let ellipsis = args.clone().position(|p| matches!(p, ast::Pat::RestPat(_)));\n         // We want to skip the `..` pattern here, since we account for it above.\n         let args = args\n-            .filter(|p| !matches!(p, ast::Pat::DotDotPat(_)))\n+            .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n             .map(|p| self.collect_pat(p))\n             .collect();\n ", "previous_filename": "crates/ra_hir_def/src/body/lower.rs"}, {"sha": "9142bc05b8d836251389c1c1fe292b01826063e9", "filename": "crates/hir_def/src/body/scope.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody%2Fscope.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,8 +1,8 @@\n //! Name resolution for expressions.\n use std::sync::Arc;\n \n+use arena::{Arena, Idx};\n use hir_expand::name::Name;\n-use ra_arena::{Arena, Idx};\n use rustc_hash::FxHashMap;\n \n use crate::{\n@@ -169,9 +169,9 @@ fn compute_expr_scopes(expr: ExprId, body: &Body, scopes: &mut ExprScopes, scope\n \n #[cfg(test)]\n mod tests {\n+    use base_db::{fixture::WithFixture, FileId, SourceDatabase};\n     use hir_expand::{name::AsName, InFile};\n-    use ra_db::{fixture::WithFixture, FileId, SourceDatabase};\n-    use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n+    use syntax::{algo::find_node_at_offset, ast, AstNode};\n     use test_utils::{assert_eq_text, extract_offset, mark};\n \n     use crate::{db::DefDatabase, test_db::TestDB, FunctionId, ModuleDefId};", "previous_filename": "crates/ra_hir_def/src/body/scope.rs"}, {"sha": "0f872b5c047487140eff04e8ea57db9cb9b77659", "filename": "crates/hir_def/src/builtin_type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbuiltin_type.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_def/src/builtin_type.rs"}, {"sha": "dcb00a1d9a0ba916cc83b3bcc0015f7a9c79aab7", "filename": "crates/hir_def/src/child_by_source.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_def/src/child_by_source.rs"}, {"sha": "9a8eb4edec7ce8827047f1657fbe9263d9f1df5f", "filename": "crates/hir_def/src/data.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,8 +3,7 @@\n use std::sync::Arc;\n \n use hir_expand::{name::Name, InFile};\n-use ra_prof::profile;\n-use ra_syntax::ast;\n+use syntax::ast;\n \n use crate::{\n     attr::Attrs,\n@@ -133,7 +132,7 @@ pub struct ImplData {\n \n impl ImplData {\n     pub(crate) fn impl_data_query(db: &dyn DefDatabase, id: ImplId) -> Arc<ImplData> {\n-        let _p = profile(\"impl_data_query\");\n+        let _p = profile::span(\"impl_data_query\");\n         let impl_loc = id.lookup(db);\n \n         let item_tree = db.item_tree(impl_loc.id.file_id);", "previous_filename": "crates/ra_hir_def/src/data.rs"}, {"sha": "6d694de11568714a81792efb7d1d2b0adc6e86b1", "filename": "crates/hir_def/src/db.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdb.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,10 +1,9 @@\n //! Defines database & queries for name resolution.\n use std::sync::Arc;\n \n+use base_db::{salsa, CrateId, SourceDatabase, Upcast};\n use hir_expand::{db::AstDatabase, HirFileId};\n-use ra_db::{salsa, CrateId, SourceDatabase, Upcast};\n-use ra_prof::profile;\n-use ra_syntax::SmolStr;\n+use syntax::SmolStr;\n \n use crate::{\n     adt::{EnumData, StructData},\n@@ -116,6 +115,6 @@ pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n }\n \n fn crate_def_map_wait(db: &impl DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {\n-    let _p = profile(\"crate_def_map:wait\");\n+    let _p = profile::span(\"crate_def_map:wait\");\n     db.crate_def_map_query(krate)\n }", "previous_filename": "crates/ra_hir_def/src/db.rs"}, {"sha": "3e19d9117a907e1975b0093c176e480d1cfadb8e", "filename": "crates/hir_def/src/diagnostics.rs", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,8 +2,8 @@\n \n use std::any::Any;\n \n-use hir_expand::diagnostics::Diagnostic;\n-use ra_syntax::{ast, AstPtr, SyntaxNodePtr};\n+use hir_expand::diagnostics::{Diagnostic, DiagnosticCode};\n+use syntax::{ast, AstPtr, SyntaxNodePtr};\n \n use hir_expand::{HirFileId, InFile};\n \n@@ -15,10 +15,13 @@ pub struct UnresolvedModule {\n }\n \n impl Diagnostic for UnresolvedModule {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unresolved-module\")\n+    }\n     fn message(&self) -> String {\n         \"unresolved module\".to_string()\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile::new(self.file, self.decl.clone().into())\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {", "previous_filename": "crates/ra_hir_def/src/diagnostics.rs"}, {"sha": "e9a02b11bb60cd28fda131e804df03f907ea5f01", "filename": "crates/hir_def/src/docs.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fdocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fdocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdocs.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -6,7 +6,7 @@\n use std::sync::Arc;\n \n use either::Either;\n-use ra_syntax::ast;\n+use syntax::ast;\n \n use crate::{\n     db::DefDatabase,", "previous_filename": "crates/ra_hir_def/src/docs.rs"}, {"sha": "6f269d7b01fec1645d62e7f79bef846b9f57af6f", "filename": "crates/hir_def/src/dyn_map.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fdyn_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fdyn_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdyn_map.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_def/src/dyn_map.rs"}, {"sha": "c94b3a36f57c73f9bfe767dc9ae0f4d1d5ad732f", "filename": "crates/hir_def/src/expr.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fexpr.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -12,9 +12,9 @@\n //!\n //! See also a neighboring `body` module.\n \n+use arena::{Idx, RawId};\n use hir_expand::name::Name;\n-use ra_arena::{Idx, RawId};\n-use ra_syntax::ast::RangeOp;\n+use syntax::ast::RangeOp;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt},\n@@ -197,7 +197,7 @@ pub enum ArithOp {\n     BitAnd,\n }\n \n-pub use ra_syntax::ast::PrefixOp as UnaryOp;\n+pub use syntax::ast::PrefixOp as UnaryOp;\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Array {\n     ElementList(Vec<ExprId>),", "previous_filename": "crates/ra_hir_def/src/expr.rs"}, {"sha": "ac2c54ac53645e7e84ba2bc2bfaa138e6dc583fc", "filename": "crates/hir_def/src/find_path.rs", "status": "renamed", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Ffind_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ffind_path.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,6 @@\n //! An algorithm to find a path to refer to a certain item.\n \n use hir_expand::name::{known, AsName, Name};\n-use ra_prof::profile;\n use rustc_hash::FxHashSet;\n use test_utils::mark;\n \n@@ -18,7 +17,7 @@ use crate::{\n /// Find a path that can be used to refer to a certain item. This can depend on\n /// *from where* you're referring to the item, hence the `from` parameter.\n pub fn find_path(db: &dyn DefDatabase, item: ItemInNs, from: ModuleId) -> Option<ModPath> {\n-    let _p = profile(\"find_path\");\n+    let _p = profile::span(\"find_path\");\n     find_path_inner(db, item, from, MAX_PATH_LEN)\n }\n \n@@ -215,7 +214,7 @@ fn find_local_import_locations(\n     item: ItemInNs,\n     from: ModuleId,\n ) -> Vec<(ModuleId, Name)> {\n-    let _p = profile(\"find_local_import_locations\");\n+    let _p = profile::span(\"find_local_import_locations\");\n \n     // `from` can import anything below `from` with visibility of at least `from`, and anything\n     // above `from` with any visibility. That means we do not need to descend into private siblings\n@@ -293,9 +292,9 @@ fn find_local_import_locations(\n \n #[cfg(test)]\n mod tests {\n+    use base_db::fixture::WithFixture;\n     use hir_expand::hygiene::Hygiene;\n-    use ra_db::fixture::WithFixture;\n-    use ra_syntax::ast::AstNode;\n+    use syntax::ast::AstNode;\n     use test_utils::mark;\n \n     use crate::test_db::TestDB;\n@@ -308,12 +307,9 @@ mod tests {\n     fn check_found_path(ra_fixture: &str, path: &str) {\n         let (db, pos) = TestDB::with_position(ra_fixture);\n         let module = db.module_for_file(pos.file_id);\n-        let parsed_path_file = ra_syntax::SourceFile::parse(&format!(\"use {};\", path));\n-        let ast_path = parsed_path_file\n-            .syntax_node()\n-            .descendants()\n-            .find_map(ra_syntax::ast::Path::cast)\n-            .unwrap();\n+        let parsed_path_file = syntax::SourceFile::parse(&format!(\"use {};\", path));\n+        let ast_path =\n+            parsed_path_file.syntax_node().descendants().find_map(syntax::ast::Path::cast).unwrap();\n         let mod_path = ModPath::from_src(ast_path, &Hygiene::new_unhygienic()).unwrap();\n \n         let crate_def_map = db.crate_def_map(module.krate);\n@@ -442,12 +438,12 @@ mod tests {\n         // already in scope.\n         check_found_path(\n             r#\"\n-            //- /main.rs crate:main deps:ra_syntax\n+            //- /main.rs crate:main deps:syntax\n \n-            use ra_syntax::ast;\n+            use syntax::ast;\n             <|>\n \n-            //- /lib.rs crate:ra_syntax\n+            //- /lib.rs crate:syntax\n             pub mod ast {\n                 pub enum ModuleItem {\n                     A, B, C,\n@@ -459,18 +455,18 @@ mod tests {\n \n         check_found_path(\n             r#\"\n-            //- /main.rs crate:main deps:ra_syntax\n+            //- /main.rs crate:main deps:syntax\n \n             <|>\n \n-            //- /lib.rs crate:ra_syntax\n+            //- /lib.rs crate:syntax\n             pub mod ast {\n                 pub enum ModuleItem {\n                     A, B, C,\n                 }\n             }\n         \"#,\n-            \"ra_syntax::ast::ModuleItem\",\n+            \"syntax::ast::ModuleItem\",\n         );\n     }\n ", "previous_filename": "crates/ra_hir_def/src/find_path.rs"}, {"sha": "835fe3fbdc696530f7645a3e019c7a557b78121f", "filename": "crates/hir_def/src/generics.rs", "status": "renamed", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fgenerics.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,15 +4,14 @@\n //! in rustc.\n use std::sync::Arc;\n \n+use arena::{map::ArenaMap, Arena};\n+use base_db::FileId;\n use either::Either;\n use hir_expand::{\n     name::{name, AsName, Name},\n     InFile,\n };\n-use ra_arena::{map::ArenaMap, Arena};\n-use ra_db::FileId;\n-use ra_prof::profile;\n-use ra_syntax::ast::{self, GenericParamsOwner, NameOwner, TypeBoundsOwner};\n+use syntax::ast::{self, GenericParamsOwner, NameOwner, TypeBoundsOwner};\n \n use crate::{\n     body::LowerCtx,\n@@ -73,7 +72,7 @@ impl GenericParams {\n         db: &dyn DefDatabase,\n         def: GenericDefId,\n     ) -> Arc<GenericParams> {\n-        let _p = profile(\"generic_params_query\");\n+        let _p = profile::span(\"generic_params_query\");\n \n         let generics = match def {\n             GenericDefId::FunctionId(id) => {\n@@ -253,7 +252,7 @@ impl GenericParams {\n \n     fn fill_where_predicates(&mut self, lower_ctx: &LowerCtx, where_clause: ast::WhereClause) {\n         for pred in where_clause.predicates() {\n-            let type_ref = match pred.type_ref() {\n+            let type_ref = match pred.ty() {\n                 Some(type_ref) => type_ref,\n                 None => continue,\n             };\n@@ -270,7 +269,7 @@ impl GenericParams {\n         bound: ast::TypeBound,\n         type_ref: TypeRef,\n     ) {\n-        if bound.question_token().is_some() {\n+        if bound.question_mark_token().is_some() {\n             // FIXME: remove this bound\n             return;\n         }", "previous_filename": "crates/ra_hir_def/src/generics.rs"}, {"sha": "a442fb63a1be5d1ca1be51ae63ee6abf82a25766", "filename": "crates/hir_def/src/import_map.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,12 +2,12 @@\n \n use std::{cmp::Ordering, fmt, hash::BuildHasherDefault, sync::Arc};\n \n+use base_db::CrateId;\n use fst::{self, Streamer};\n use indexmap::{map::Entry, IndexMap};\n-use ra_db::CrateId;\n-use ra_syntax::SmolStr;\n use rustc_hash::{FxHashMap, FxHasher};\n use smallvec::SmallVec;\n+use syntax::SmolStr;\n \n use crate::{\n     db::DefDatabase,\n@@ -56,7 +56,7 @@ pub struct ImportMap {\n \n impl ImportMap {\n     pub fn import_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<Self> {\n-        let _p = ra_prof::profile(\"import_map_query\");\n+        let _p = profile::span(\"import_map_query\");\n         let def_map = db.crate_def_map(krate);\n         let mut import_map = Self::default();\n \n@@ -254,7 +254,7 @@ pub fn search_dependencies<'a>(\n     krate: CrateId,\n     query: Query,\n ) -> Vec<ItemInNs> {\n-    let _p = ra_prof::profile(\"search_dependencies\").detail(|| format!(\"{:?}\", query));\n+    let _p = profile::span(\"search_dependencies\").detail(|| format!(\"{:?}\", query));\n \n     let graph = db.crate_graph();\n     let import_maps: Vec<_> =\n@@ -327,8 +327,8 @@ pub fn search_dependencies<'a>(\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n-    use ra_db::{fixture::WithFixture, SourceDatabase, Upcast};\n+    use base_db::{fixture::WithFixture, SourceDatabase, Upcast};\n+    use expect_test::{expect, Expect};\n \n     use crate::{test_db::TestDB, AssocContainerId, Lookup};\n ", "previous_filename": "crates/ra_hir_def/src/import_map.rs"}, {"sha": "f1e9dfd5b14d37a8a282593df6892187692885d0", "filename": "crates/hir_def/src/item_scope.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,9 +3,9 @@\n \n use std::collections::hash_map::Entry;\n \n+use base_db::CrateId;\n use hir_expand::name::Name;\n use once_cell::sync::Lazy;\n-use ra_db::CrateId;\n use rustc_hash::{FxHashMap, FxHashSet};\n use test_utils::mark;\n ", "previous_filename": "crates/ra_hir_def/src/item_scope.rs"}, {"sha": "e14722caebb59875a9dc596e135209f9de73ae83", "filename": "crates/hir_def/src/item_tree.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -13,6 +13,7 @@ use std::{\n     sync::Arc,\n };\n \n+use arena::{Arena, Idx, RawId};\n use ast::{AstNode, AttrsOwner, NameOwner, StructKind};\n use either::Either;\n use hir_expand::{\n@@ -21,10 +22,9 @@ use hir_expand::{\n     name::{name, AsName, Name},\n     HirFileId, InFile,\n };\n-use ra_arena::{Arena, Idx, RawId};\n-use ra_syntax::{ast, match_ast};\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n+use syntax::{ast, match_ast};\n use test_utils::mark;\n \n use crate::{\n@@ -77,7 +77,7 @@ pub struct ItemTree {\n \n impl ItemTree {\n     pub fn item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {\n-        let _p = ra_prof::profile(\"item_tree_query\").detail(|| format!(\"{:?}\", file_id));\n+        let _p = profile::span(\"item_tree_query\").detail(|| format!(\"{:?}\", file_id));\n         let syntax = if let Some(node) = db.parse_or_expand(file_id) {\n             node\n         } else {", "previous_filename": "crates/ra_hir_def/src/item_tree.rs"}, {"sha": "391ab5d3928ab9ca5752cd18284e5c0c25c4bd17", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,13 +2,13 @@\n \n use std::{collections::hash_map::Entry, mem, sync::Arc};\n \n+use arena::map::ArenaMap;\n use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, HirFileId};\n-use ra_arena::map::ArenaMap;\n-use ra_syntax::{\n+use smallvec::SmallVec;\n+use syntax::{\n     ast::{self, ModuleItemOwner},\n     SyntaxNode,\n };\n-use smallvec::SmallVec;\n \n use crate::{\n     attr::Attrs,\n@@ -448,8 +448,8 @@ impl Ctx {\n     fn lower_impl(&mut self, impl_def: &ast::Impl) -> Option<FileItemTreeId<Impl>> {\n         let generic_params =\n             self.lower_generic_params_and_inner_items(GenericsOwner::Impl, impl_def);\n-        let target_trait = impl_def.target_trait().map(|tr| self.lower_type_ref(&tr));\n-        let target_type = self.lower_type_ref(&impl_def.target_type()?);\n+        let target_trait = impl_def.trait_().map(|tr| self.lower_type_ref(&tr));\n+        let target_type = self.lower_type_ref(&impl_def.self_ty()?);\n         let is_negative = impl_def.excl_token().is_some();\n \n         // We cannot use `assoc_items()` here as that does not include macro calls.\n@@ -648,10 +648,10 @@ impl Ctx {\n         self.data().vis.alloc(vis)\n     }\n \n-    fn lower_type_ref(&self, type_ref: &ast::TypeRef) -> TypeRef {\n+    fn lower_type_ref(&self, type_ref: &ast::Type) -> TypeRef {\n         TypeRef::from_ast(&self.body_ctx, type_ref.clone())\n     }\n-    fn lower_type_ref_opt(&self, type_ref: Option<ast::TypeRef>) -> TypeRef {\n+    fn lower_type_ref_opt(&self, type_ref: Option<ast::Type>) -> TypeRef {\n         type_ref.map(|ty| self.lower_type_ref(&ty)).unwrap_or(TypeRef::Error)\n     }\n ", "previous_filename": "crates/ra_hir_def/src/item_tree/lower.rs"}, {"sha": "620e697d4a101af5cf0360321ba9291bc1f6a4fd", "filename": "crates/hir_def/src/item_tree/tests.rs", "status": "renamed", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,10 +1,10 @@\n-use expect::{expect, Expect};\n+use base_db::fixture::WithFixture;\n+use expect_test::{expect, Expect};\n use hir_expand::{db::AstDatabase, HirFileId, InFile};\n-use ra_db::fixture::WithFixture;\n-use ra_syntax::{ast, AstNode};\n use rustc_hash::FxHashSet;\n use std::sync::Arc;\n use stdx::format_to;\n+use syntax::{ast, AstNode};\n \n use crate::{db::DefDatabase, test_db::TestDB};\n \n@@ -228,31 +228,31 @@ fn smoke() {\n \n             top-level items:\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n-            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"a\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: false, is_prelude: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Use>(0) }\n+            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"a\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: false, is_prelude: false, ast_id: FileAstId::<syntax::ast::generated::nodes::Use>(0) }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n-            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"b\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: true, is_prelude: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Use>(0) }\n+            Import { path: ModPath { kind: Plain, segments: [Name(Text(\"b\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: true, is_prelude: false, ast_id: FileAstId::<syntax::ast::generated::nodes::Use>(0) }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"ext_crate\"))] }, input: None }]) }]\n-            ExternCrate { path: ModPath { kind: Plain, segments: [Name(Text(\"krate\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_macro_use: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ExternCrate>(1) }\n+            ExternCrate { path: ModPath { kind: Plain, segments: [Name(Text(\"krate\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_macro_use: false, ast_id: FileAstId::<syntax::ast::generated::nodes::ExternCrate>(1) }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_trait\"))] }, input: None }]) }]\n-            Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [TypeAlias(Idx::<TypeAlias>(0)), Const(Idx::<Const>(0)), Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Trait>(2) }\n+            Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [TypeAlias(Idx::<TypeAlias>(0)), Const(Idx::<Const>(0)), Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Trait>(2) }\n             > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_ty\"))] }, input: None }]) }]\n-            > TypeAlias { name: Name(Text(\"AssocTy\")), visibility: RawVisibilityId(\"pub(self)\"), bounds: [Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Tr\"))] }, generic_args: [Some(GenericArgs { args: [Type(Tuple([]))], has_self_type: false, bindings: [] })] })], generic_params: GenericParamsId(4294967295), type_ref: None, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::TypeAlias>(8) }\n+            > TypeAlias { name: Name(Text(\"AssocTy\")), visibility: RawVisibilityId(\"pub(self)\"), bounds: [Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Tr\"))] }, generic_args: [Some(GenericArgs { args: [Type(Tuple([]))], has_self_type: false, bindings: [] })] })], generic_params: GenericParamsId(4294967295), type_ref: None, ast_id: FileAstId::<syntax::ast::generated::nodes::TypeAlias>(8) }\n             > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_const\"))] }, input: None }]) }]\n-            > Const { name: Some(Name(Text(\"CONST\"))), visibility: RawVisibilityId(\"pub(self)\"), type_ref: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"u8\"))] }, generic_args: [None] }), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Const>(9) }\n+            > Const { name: Some(Name(Text(\"CONST\"))), visibility: RawVisibilityId(\"pub(self)\"), type_ref: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"u8\"))] }, generic_args: [None] }), ast_id: FileAstId::<syntax::ast::generated::nodes::Const>(9) }\n             > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_method\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Shared)], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(10) }\n+            > Function { name: Name(Text(\"method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Shared)], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(10) }\n             > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_dfl_method\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"dfl_method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Mut)], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(11) }\n+            > Function { name: Name(Text(\"dfl_method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Mut)], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(11) }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct0\"))] }, input: None }]) }]\n-            Struct { name: Name(Text(\"Struct0\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), fields: Unit, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Struct>(3), kind: Unit }\n+            Struct { name: Name(Text(\"Struct0\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), fields: Unit, ast_id: FileAstId::<syntax::ast::generated::nodes::Struct>(3), kind: Unit }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct1\"))] }, input: None }]) }]\n-            Struct { name: Name(Text(\"Struct1\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(2), fields: Tuple(IdRange::<ra_hir_def::item_tree::Field>(0..1)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Struct>(4), kind: Tuple }\n+            Struct { name: Name(Text(\"Struct1\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(2), fields: Tuple(IdRange::<hir_def::item_tree::Field>(0..1)), ast_id: FileAstId::<syntax::ast::generated::nodes::Struct>(4), kind: Tuple }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct2\"))] }, input: None }]) }]\n-            Struct { name: Name(Text(\"Struct2\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(3), fields: Record(IdRange::<ra_hir_def::item_tree::Field>(1..2)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Struct>(5), kind: Record }\n+            Struct { name: Name(Text(\"Struct2\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(3), fields: Record(IdRange::<hir_def::item_tree::Field>(1..2)), ast_id: FileAstId::<syntax::ast::generated::nodes::Struct>(5), kind: Record }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"en\"))] }, input: None }]) }]\n-            Enum { name: Name(Text(\"En\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), variants: IdRange::<ra_hir_def::item_tree::Variant>(0..1), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Enum>(6) }\n+            Enum { name: Name(Text(\"En\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), variants: IdRange::<hir_def::item_tree::Variant>(0..1), ast_id: FileAstId::<syntax::ast::generated::nodes::Enum>(6) }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"un\"))] }, input: None }]) }]\n-            Union { name: Name(Text(\"Un\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), fields: Record(IdRange::<ra_hir_def::item_tree::Field>(3..4)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Union>(7) }\n+            Union { name: Name(Text(\"Un\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), fields: Record(IdRange::<hir_def::item_tree::Field>(3..4)), ast_id: FileAstId::<syntax::ast::generated::nodes::Union>(7) }\n         \"##]],\n     );\n }\n@@ -274,13 +274,13 @@ fn simple_inner_items() {\n             inner attrs: Attrs { entries: None }\n \n             top-level items:\n-            Impl { generic_params: GenericParamsId(0), target_trait: Some(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"D\"))] }, generic_args: [None] })), target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Response\"))] }, generic_args: [Some(GenericArgs { args: [Type(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"T\"))] }, generic_args: [None] }))], has_self_type: false, bindings: [] })] }), is_negative: false, items: [Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Impl>(0) }\n-            > Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(1) }\n+            Impl { generic_params: GenericParamsId(0), target_trait: Some(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"D\"))] }, generic_args: [None] })), target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Response\"))] }, generic_args: [Some(GenericArgs { args: [Type(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"T\"))] }, generic_args: [None] }))], has_self_type: false, bindings: [] })] }), is_negative: false, items: [Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Impl>(0) }\n+            > Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n \n             inner items:\n \n-            for AST FileAstId::<ra_syntax::ast::generated::nodes::Item>(2):\n-            Function { name: Name(Text(\"end\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(2) }\n+            for AST FileAstId::<syntax::ast::generated::nodes::Item>(2):\n+            Function { name: Name(Text(\"end\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n \n         \"#]],\n     );\n@@ -303,9 +303,9 @@ fn extern_attrs() {\n \n             top-level items:\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n-            Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: true, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(1) }\n+            Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: true, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n-            Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: true, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(2) }\n+            Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: true, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n         \"##]],\n     );\n }\n@@ -327,11 +327,11 @@ fn trait_attrs() {\n \n             top-level items:\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"trait_attr\"))] }, input: None }]) }]\n-            Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Trait>(0) }\n+            Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Trait>(0) }\n             > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(1) }\n+            > Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n             > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(2) }\n+            > Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n         \"##]],\n     );\n }\n@@ -353,11 +353,11 @@ fn impl_attrs() {\n \n             top-level items:\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"impl_attr\"))] }, input: None }]) }]\n-            Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Ty\"))] }, generic_args: [None] }), is_negative: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Impl>(0) }\n+            Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Ty\"))] }, generic_args: [None] }), is_negative: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<syntax::ast::generated::nodes::Impl>(0) }\n             > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(1) }\n+            > Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n             > #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n-            > Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(2) }\n+            > Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(2) }\n         \"##]],\n     );\n }\n@@ -408,13 +408,13 @@ fn inner_item_attrs() {\n             inner attrs: Attrs { entries: None }\n \n             top-level items:\n-            Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(0) }\n+            Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(0) }\n \n             inner items:\n \n-            for AST FileAstId::<ra_syntax::ast::generated::nodes::Item>(1):\n+            for AST FileAstId::<syntax::ast::generated::nodes::Item>(1):\n             #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_inner\"))] }, input: None }]) }]\n-            Function { name: Name(Text(\"inner\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Fn>(1) }\n+            Function { name: Name(Text(\"inner\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], is_varargs: false, ret_type: Tuple([]), ast_id: FileAstId::<syntax::ast::generated::nodes::Fn>(1) }\n \n         \"##]],\n     );\n@@ -432,8 +432,8 @@ fn assoc_item_macros() {\n             inner attrs: Attrs { entries: None }\n \n             top-level items:\n-            Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"S\"))] }, generic_args: [None] }), is_negative: false, items: [MacroCall(Idx::<MacroCall>(0))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::Impl>(0) }\n-            > MacroCall { name: None, path: ModPath { kind: Plain, segments: [Name(Text(\"items\"))] }, is_export: false, is_local_inner: false, is_builtin: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::MacroCall>(1) }\n+            Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"S\"))] }, generic_args: [None] }), is_negative: false, items: [MacroCall(Idx::<MacroCall>(0))], ast_id: FileAstId::<syntax::ast::generated::nodes::Impl>(0) }\n+            > MacroCall { name: None, path: ModPath { kind: Plain, segments: [Name(Text(\"items\"))] }, is_export: false, is_local_inner: false, is_builtin: false, ast_id: FileAstId::<syntax::ast::generated::nodes::MacroCall>(1) }\n         \"#]],\n     );\n }", "previous_filename": "crates/ra_hir_def/src/item_tree/tests.rs"}, {"sha": "40a5d92b5076766c3b21099c626b4d4fde20c15f", "filename": "crates/hir_def/src/keys.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fkeys.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,8 +3,8 @@\n use std::marker::PhantomData;\n \n use hir_expand::{InFile, MacroDefId};\n-use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n+use syntax::{ast, AstNode, AstPtr};\n \n use crate::{\n     dyn_map::{DynMap, Policy},", "previous_filename": "crates/ra_hir_def/src/keys.rs"}, {"sha": "063eadccb2dbd3043ad6bc7d5502a3fac5e97995", "filename": "crates/hir_def/src/lang_item.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flang_item.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,9 +4,8 @@\n //! features, such as Fn family of traits.\n use std::sync::Arc;\n \n-use ra_prof::profile;\n-use ra_syntax::SmolStr;\n use rustc_hash::FxHashMap;\n+use syntax::SmolStr;\n \n use crate::{\n     db::DefDatabase, AdtId, AttrDefId, CrateId, EnumId, FunctionId, ImplId, ModuleDefId, ModuleId,\n@@ -79,7 +78,7 @@ impl LangItems {\n \n     /// Salsa query. This will look for lang items in a specific crate.\n     pub(crate) fn crate_lang_items_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<LangItems> {\n-        let _p = profile(\"crate_lang_items_query\");\n+        let _p = profile::span(\"crate_lang_items_query\");\n \n         let mut lang_items = LangItems::default();\n \n@@ -98,7 +97,7 @@ impl LangItems {\n         db: &dyn DefDatabase,\n         module: ModuleId,\n     ) -> Option<Arc<LangItems>> {\n-        let _p = profile(\"module_lang_items_query\");\n+        let _p = profile::span(\"module_lang_items_query\");\n         let mut lang_items = LangItems::default();\n         lang_items.collect_lang_items(db, module);\n         if lang_items.items.is_empty() {\n@@ -115,7 +114,7 @@ impl LangItems {\n         start_crate: CrateId,\n         item: SmolStr,\n     ) -> Option<LangItemTarget> {\n-        let _p = profile(\"lang_item_query\");\n+        let _p = profile::span(\"lang_item_query\");\n         let lang_items = db.crate_lang_items(start_crate);\n         let start_crate_target = lang_items.items.get(&item);\n         if let Some(target) = start_crate_target {", "previous_filename": "crates/ra_hir_def/src/lang_item.rs"}, {"sha": "f24a1dd77cc2566f38cccb6cc4637cbe2b7de63b", "filename": "crates/hir_def/src/lib.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -52,13 +52,13 @@ mod test_db;\n \n use std::hash::{Hash, Hasher};\n \n+use arena::Idx;\n+use base_db::{impl_intern_key, salsa, CrateId};\n use hir_expand::{\n     ast_id_map::FileAstId, eager::expand_eager_macro, hygiene::Hygiene, AstId, HirFileId, InFile,\n     MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n-use ra_arena::Idx;\n-use ra_db::{impl_intern_key, salsa, CrateId};\n-use ra_syntax::ast;\n+use syntax::ast;\n \n use crate::builtin_type::BuiltinType;\n use item_tree::{", "previous_filename": "crates/ra_hir_def/src/lib.rs"}, {"sha": "bf302172d05f58d7460fcc190b9b14503a69dc8a", "filename": "crates/hir_def/src/nameres.rs", "status": "renamed", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -56,13 +56,12 @@ mod tests;\n \n use std::sync::Arc;\n \n+use arena::Arena;\n+use base_db::{CrateId, Edition, FileId};\n use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile};\n-use ra_arena::Arena;\n-use ra_db::{CrateId, Edition, FileId};\n-use ra_prof::profile;\n-use ra_syntax::ast;\n use rustc_hash::FxHashMap;\n use stdx::format_to;\n+use syntax::ast;\n \n use crate::{\n     db::DefDatabase,\n@@ -172,7 +171,7 @@ pub struct ModuleData {\n \n impl CrateDefMap {\n     pub(crate) fn crate_def_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<CrateDefMap> {\n-        let _p = profile(\"crate_def_map_query\").detail(|| {\n+        let _p = profile::span(\"crate_def_map_query\").detail(|| {\n             db.crate_graph()[krate]\n                 .display_name\n                 .as_ref()\n@@ -289,7 +288,7 @@ pub enum ModuleSource {\n \n mod diagnostics {\n     use hir_expand::diagnostics::DiagnosticSink;\n-    use ra_syntax::{ast, AstPtr};\n+    use syntax::{ast, AstPtr};\n \n     use crate::{db::DefDatabase, diagnostics::UnresolvedModule, nameres::LocalModuleId, AstId};\n ", "previous_filename": "crates/ra_hir_def/src/nameres.rs"}, {"sha": "3e99c8773741f0d40199f43677364b400e155e11", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,6 +3,8 @@\n //! `DefCollector::collect` contains the fixed-point iteration loop which\n //! resolves imports and expands macros.\n \n+use base_db::{CrateId, FileId, ProcMacroId};\n+use cfg::CfgOptions;\n use hir_expand::{\n     ast_id_map::FileAstId,\n     builtin_derive::find_builtin_derive,\n@@ -11,10 +13,8 @@ use hir_expand::{\n     proc_macro::ProcMacroExpander,\n     HirFileId, MacroCallId, MacroDefId, MacroDefKind,\n };\n-use ra_cfg::CfgOptions;\n-use ra_db::{CrateId, FileId, ProcMacroId};\n-use ra_syntax::ast;\n use rustc_hash::FxHashMap;\n+use syntax::ast;\n use test_utils::mark;\n \n use crate::{\n@@ -1208,8 +1208,8 @@ fn is_macro_rules(path: &ModPath) -> bool {\n #[cfg(test)]\n mod tests {\n     use crate::{db::DefDatabase, test_db::TestDB};\n-    use ra_arena::Arena;\n-    use ra_db::{fixture::WithFixture, SourceDatabase};\n+    use arena::Arena;\n+    use base_db::{fixture::WithFixture, SourceDatabase};\n \n     use super::*;\n ", "previous_filename": "crates/ra_hir_def/src/nameres/collector.rs"}, {"sha": "e8389b4846768af9af88c1e519839249deacbd91", "filename": "crates/hir_def/src/nameres/mod_resolution.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,7 @@\n //! This module resolves `mod foo;` declaration to file.\n+use base_db::FileId;\n use hir_expand::name::Name;\n-use ra_db::FileId;\n-use ra_syntax::SmolStr;\n+use syntax::SmolStr;\n \n use crate::{db::DefDatabase, HirFileId};\n ", "previous_filename": "crates/ra_hir_def/src/nameres/mod_resolution.rs"}, {"sha": "88e10574efd54842815002d3835cc160b2c21610", "filename": "crates/hir_def/src/nameres/path_resolution.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -12,8 +12,8 @@\n \n use std::iter::successors;\n \n+use base_db::Edition;\n use hir_expand::name::Name;\n-use ra_db::Edition;\n use test_utils::mark;\n \n use crate::{", "previous_filename": "crates/ra_hir_def/src/nameres/path_resolution.rs"}, {"sha": "8aaf7a158ba42fa4141f334b9ef7ef6d3ad7a450", "filename": "crates/hir_def/src/nameres/tests.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -6,8 +6,8 @@ mod primitives;\n \n use std::sync::Arc;\n \n-use expect::{expect, Expect};\n-use ra_db::{fixture::WithFixture, SourceDatabase};\n+use base_db::{fixture::WithFixture, SourceDatabase};\n+use expect_test::{expect, Expect};\n use test_utils::mark;\n \n use crate::{db::DefDatabase, nameres::*, test_db::TestDB};", "previous_filename": "crates/ra_hir_def/src/nameres/tests.rs"}, {"sha": "2ae836e3c2892085080b9d53758e430933425fb7", "filename": "crates/hir_def/src/nameres/tests/globs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fglobs.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_def/src/nameres/tests/globs.rs"}, {"sha": "cfbc62cc43ccd589f877b9bd4aad0e1f51430fe8", "filename": "crates/hir_def/src/nameres/tests/incremental.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use std::sync::Arc;\n \n-use ra_db::SourceDatabaseExt;\n+use base_db::SourceDatabaseExt;\n \n use super::*;\n ", "previous_filename": "crates/ra_hir_def/src/nameres/tests/incremental.rs"}, {"sha": "e0fb8bdef46d74cd29ced45d0b54ff6b15190656", "filename": "crates/hir_def/src/nameres/tests/macros.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_def/src/nameres/tests/macros.rs"}, {"sha": "1f619787e1d5d47ebb80dfdac83bdcf47222e978", "filename": "crates/hir_def/src/nameres/tests/mod_resolution.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -698,7 +698,7 @@ fn unresolved_module_diagnostics() {\n                             ),\n                         ),\n                     ),\n-                    value: FileAstId::<ra_syntax::ast::generated::nodes::Module>(1),\n+                    value: FileAstId::<syntax::ast::generated::nodes::Module>(1),\n                 },\n                 candidate: \"bar.rs\",\n             },", "previous_filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs"}, {"sha": "215e8952d90299e3c977ef96a51d6e8b96143ec7", "filename": "crates/hir_def/src/nameres/tests/primitives.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Ftests%2Fprimitives.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_def/src/nameres/tests/primitives.rs"}, {"sha": "99395667defcde5c9e23fc5d2ffa5ee48cd3f62f", "filename": "crates/hir_def/src/path.rs", "status": "renamed", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -8,12 +8,12 @@ use std::{\n };\n \n use crate::body::LowerCtx;\n+use base_db::CrateId;\n use hir_expand::{\n     hygiene::Hygiene,\n     name::{AsName, Name},\n };\n-use ra_db::CrateId;\n-use ra_syntax::ast;\n+use syntax::ast;\n \n use crate::{\n     type_ref::{TypeBound, TypeRef},\n@@ -153,12 +153,6 @@ pub enum GenericArg {\n }\n \n impl Path {\n-    /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    #[deprecated = \"Doesn't handle hygiene, don't add new calls, remove old ones\"]\n-    pub fn from_ast(path: ast::Path) -> Option<Path> {\n-        lower::lower_path(path, &Hygiene::new_unhygienic())\n-    }\n-\n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n     /// It correctly handles `$crate` based path from macro call.\n     pub fn from_src(path: ast::Path, hygiene: &Hygiene) -> Option<Path> {\n@@ -258,7 +252,7 @@ impl<'a> PathSegments<'a> {\n }\n \n impl GenericArgs {\n-    pub(crate) fn from_ast(lower_ctx: &LowerCtx, node: ast::TypeArgList) -> Option<GenericArgs> {\n+    pub(crate) fn from_ast(lower_ctx: &LowerCtx, node: ast::GenericArgList) -> Option<GenericArgs> {\n         lower::lower_generic_args(lower_ctx, node)\n     }\n ", "previous_filename": "crates/ra_hir_def/src/path.rs"}, {"sha": "07b9723ce01b6d2230054fa709217166f5aeaa2f", "filename": "crates/hir_def/src/path/lower.rs", "status": "renamed", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -9,7 +9,7 @@ use hir_expand::{\n     hygiene::Hygiene,\n     name::{name, AsName},\n };\n-use ra_syntax::ast::{self, AstNode, TypeBoundsOwner};\n+use syntax::ast::{self, AstNode, TypeBoundsOwner};\n \n use super::AssociatedTypeBinding;\n use crate::{\n@@ -41,7 +41,7 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n                 match hygiene.name_ref_to_name(name_ref) {\n                     Either::Left(name) => {\n                         let args = segment\n-                            .type_arg_list()\n+                            .generic_arg_list()\n                             .and_then(|it| lower_generic_args(&ctx, it))\n                             .or_else(|| {\n                                 lower_generic_args_from_fn_path(\n@@ -148,33 +148,37 @@ pub(super) fn lower_path(mut path: ast::Path, hygiene: &Hygiene) -> Option<Path>\n \n pub(super) fn lower_generic_args(\n     lower_ctx: &LowerCtx,\n-    node: ast::TypeArgList,\n+    node: ast::GenericArgList,\n ) -> Option<GenericArgs> {\n     let mut args = Vec::new();\n-    for type_arg in node.type_args() {\n-        let type_ref = TypeRef::from_ast_opt(lower_ctx, type_arg.type_ref());\n-        args.push(GenericArg::Type(type_ref));\n-    }\n-    // lifetimes ignored for now\n     let mut bindings = Vec::new();\n-    for assoc_type_arg in node.assoc_type_args() {\n-        let assoc_type_arg: ast::AssocTypeArg = assoc_type_arg;\n-        if let Some(name_ref) = assoc_type_arg.name_ref() {\n-            let name = name_ref.as_name();\n-            let type_ref = assoc_type_arg.type_ref().map(|it| TypeRef::from_ast(lower_ctx, it));\n-            let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n-                l.bounds().map(|it| TypeBound::from_ast(lower_ctx, it)).collect()\n-            } else {\n-                Vec::new()\n-            };\n-            bindings.push(AssociatedTypeBinding { name, type_ref, bounds });\n+    for generic_arg in node.generic_args() {\n+        match generic_arg {\n+            ast::GenericArg::TypeArg(type_arg) => {\n+                let type_ref = TypeRef::from_ast_opt(lower_ctx, type_arg.ty());\n+                args.push(GenericArg::Type(type_ref));\n+            }\n+            ast::GenericArg::AssocTypeArg(assoc_type_arg) => {\n+                if let Some(name_ref) = assoc_type_arg.name_ref() {\n+                    let name = name_ref.as_name();\n+                    let type_ref = assoc_type_arg.ty().map(|it| TypeRef::from_ast(lower_ctx, it));\n+                    let bounds = if let Some(l) = assoc_type_arg.type_bound_list() {\n+                        l.bounds().map(|it| TypeBound::from_ast(lower_ctx, it)).collect()\n+                    } else {\n+                        Vec::new()\n+                    };\n+                    bindings.push(AssociatedTypeBinding { name, type_ref, bounds });\n+                }\n+            }\n+            // Lifetimes and constants are ignored for now.\n+            ast::GenericArg::LifetimeArg(_) | ast::GenericArg::ConstArg(_) => (),\n         }\n     }\n+\n     if args.is_empty() && bindings.is_empty() {\n-        None\n-    } else {\n-        Some(GenericArgs { args, has_self_type: false, bindings })\n+        return None;\n     }\n+    Some(GenericArgs { args, has_self_type: false, bindings })\n }\n \n /// Collect `GenericArgs` from the parts of a fn-like path, i.e. `Fn(X, Y)", "previous_filename": "crates/ra_hir_def/src/path/lower.rs"}, {"sha": "53cecb05fb2a335b85e6071e63af888e84135b9f", "filename": "crates/hir_def/src/path/lower/lower_use.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath%2Flower%2Flower_use.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,7 +5,7 @@ use std::iter;\n \n use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName};\n-use ra_syntax::ast::{self, NameOwner};\n+use syntax::ast::{self, NameOwner};\n use test_utils::mark;\n \n use crate::path::{ImportAlias, ModPath, PathKind};", "previous_filename": "crates/ra_hir_def/src/path/lower/lower_use.rs"}, {"sha": "74665c58851c909417bbd2efe9a24b180b1a39dc", "filename": "crates/hir_def/src/per_ns.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fper_ns.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_def/src/per_ns.rs"}, {"sha": "f8cc5e075ed8dc62df74eaa832f23220a26b9366", "filename": "crates/hir_def/src/resolver.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fresolver.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,11 +1,11 @@\n //! Name resolution fa\u00e7ade.\n use std::sync::Arc;\n \n+use base_db::CrateId;\n use hir_expand::{\n     name::{name, Name},\n     MacroDefId,\n };\n-use ra_db::CrateId;\n use rustc_hash::FxHashSet;\n \n use crate::{", "previous_filename": "crates/ra_hir_def/src/resolver.rs"}, {"sha": "7a79b0314993d22a7d37b1a82f9c391beb29c07a", "filename": "crates/hir_def/src/src.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fsrc.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,7 @@\n //! Utilities for mapping between hir IDs and the surface syntax.\n \n+use arena::map::ArenaMap;\n use hir_expand::InFile;\n-use ra_arena::map::ArenaMap;\n \n use crate::{db::DefDatabase, item_tree::ItemTreeNode, AssocItemLoc, ItemLoc};\n ", "previous_filename": "crates/ra_hir_def/src/src.rs"}, {"sha": "42a762936dd461e32fd4b26957f208ddb95b3117", "filename": "crates/hir_def/src/test_db.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftest_db.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,15 +5,15 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n+use base_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, Upcast};\n use hir_expand::db::AstDatabase;\n-use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, Upcast};\n use rustc_hash::FxHashSet;\n \n use crate::db::DefDatabase;\n \n #[salsa::database(\n-    ra_db::SourceDatabaseExtStorage,\n-    ra_db::SourceDatabaseStorage,\n+    base_db::SourceDatabaseExtStorage,\n+    base_db::SourceDatabaseStorage,\n     hir_expand::db::AstDatabaseStorage,\n     crate::db::InternDatabaseStorage,\n     crate::db::DefDatabaseStorage", "previous_filename": "crates/ra_hir_def/src/test_db.rs"}, {"sha": "fd64e701888396bad624cc9f39aff8334305d706", "filename": "crates/hir_def/src/trace.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftrace.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -9,7 +9,7 @@\n //! absolute offsets. The `Trace` structure (inspired, at least in name, by\n //! Kotlin's `BindingTrace`) allows use the same code to compute both\n //! projections.\n-use ra_arena::{map::ArenaMap, Arena, Idx, RawId};\n+use arena::{map::ArenaMap, Arena, Idx, RawId};\n \n pub(crate) struct Trace<T, V> {\n     arena: Option<Arena<T>>,", "previous_filename": "crates/ra_hir_def/src/trace.rs"}, {"sha": "1a78c1444c4326bb44fe3185e8a9499dc60b1fc9", "filename": "crates/hir_def/src/type_ref.rs", "status": "renamed", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,6 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n-\n-use ra_syntax::ast::{self};\n+use syntax::ast::{self};\n \n use crate::{body::LowerCtx, path::Path};\n \n@@ -80,39 +79,39 @@ pub enum TypeBound {\n \n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n-    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::TypeRef) -> Self {\n+    pub(crate) fn from_ast(ctx: &LowerCtx, node: ast::Type) -> Self {\n         match node {\n-            ast::TypeRef::ParenType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n-            ast::TypeRef::TupleType(inner) => {\n+            ast::Type::ParenType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n+            ast::Type::TupleType(inner) => {\n                 TypeRef::Tuple(inner.fields().map(|it| TypeRef::from_ast(ctx, it)).collect())\n             }\n-            ast::TypeRef::NeverType(..) => TypeRef::Never,\n-            ast::TypeRef::PathType(inner) => {\n+            ast::Type::NeverType(..) => TypeRef::Never,\n+            ast::Type::PathType(inner) => {\n                 // FIXME: Use `Path::from_src`\n                 inner\n                     .path()\n                     .and_then(|it| ctx.lower_path(it))\n                     .map(TypeRef::Path)\n                     .unwrap_or(TypeRef::Error)\n             }\n-            ast::TypeRef::PointerType(inner) => {\n+            ast::Type::PtrType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(&ctx, inner.ty());\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n                 TypeRef::RawPtr(Box::new(inner_ty), mutability)\n             }\n-            ast::TypeRef::ArrayType(inner) => {\n+            ast::Type::ArrayType(inner) => {\n                 TypeRef::Array(Box::new(TypeRef::from_ast_opt(&ctx, inner.ty())))\n             }\n-            ast::TypeRef::SliceType(inner) => {\n+            ast::Type::SliceType(inner) => {\n                 TypeRef::Slice(Box::new(TypeRef::from_ast_opt(&ctx, inner.ty())))\n             }\n-            ast::TypeRef::ReferenceType(inner) => {\n+            ast::Type::RefType(inner) => {\n                 let inner_ty = TypeRef::from_ast_opt(&ctx, inner.ty());\n                 let mutability = Mutability::from_mutable(inner.mut_token().is_some());\n                 TypeRef::Reference(Box::new(inner_ty), mutability)\n             }\n-            ast::TypeRef::PlaceholderType(_inner) => TypeRef::Placeholder,\n-            ast::TypeRef::FnPointerType(inner) => {\n+            ast::Type::InferType(_inner) => TypeRef::Placeholder,\n+            ast::Type::FnPtrType(inner) => {\n                 let ret_ty = inner\n                     .ret_type()\n                     .and_then(|rt| rt.ty())\n@@ -132,17 +131,17 @@ impl TypeRef {\n                 TypeRef::Fn(params, is_varargs)\n             }\n             // for types are close enough for our purposes to the inner type for now...\n-            ast::TypeRef::ForType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n-            ast::TypeRef::ImplTraitType(inner) => {\n+            ast::Type::ForType(inner) => TypeRef::from_ast_opt(&ctx, inner.ty()),\n+            ast::Type::ImplTraitType(inner) => {\n                 TypeRef::ImplTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n-            ast::TypeRef::DynTraitType(inner) => {\n+            ast::Type::DynTraitType(inner) => {\n                 TypeRef::DynTrait(type_bounds_from_ast(ctx, inner.type_bound_list()))\n             }\n         }\n     }\n \n-    pub(crate) fn from_ast_opt(ctx: &LowerCtx, node: Option<ast::TypeRef>) -> Self {\n+    pub(crate) fn from_ast_opt(ctx: &LowerCtx, node: Option<ast::Type>) -> Self {\n         if let Some(node) = node {\n             TypeRef::from_ast(ctx, node)\n         } else {", "previous_filename": "crates/ra_hir_def/src/type_ref.rs"}, {"sha": "e6e0853a30a3ae5c44e3e7f73103817dd18e8861", "filename": "crates/hir_def/src/visibility.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fvisibility.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,7 @@\n //! Defines hir-level representation of visibility (e.g. `pub` and `pub(crate)`).\n \n use hir_expand::{hygiene::Hygiene, InFile};\n-use ra_syntax::ast;\n+use syntax::ast;\n \n use crate::{\n     db::DefDatabase,", "previous_filename": "crates/ra_hir_def/src/visibility.rs"}, {"sha": "1c46992915e588c0309a6318fd319ad9c3778c9a", "filename": "crates/hir_expand/Cargo.toml", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -0,0 +1,23 @@\n+[package]\n+name = \"hir_expand\"\n+version = \"0.0.0\"\n+license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+log = \"0.4.8\"\n+either = \"1.5.3\"\n+rustc-hash = \"1.0.0\"\n+\n+arena = { path = \"../arena\" }\n+base_db = { path = \"../base_db\" }\n+syntax = { path = \"../syntax\" }\n+parser = { path = \"../parser\" }\n+profile = { path = \"../profile\" }\n+tt = { path = \"../tt\" }\n+mbe = { path = \"../mbe\" }\n+test_utils = { path = \"../test_utils\"}"}, {"sha": "f63629b305302202353c2ccbc35909b95763c0a0", "filename": "crates/hir_expand/src/ast_id_map.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fast_id_map.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -12,8 +12,8 @@ use std::{\n     marker::PhantomData,\n };\n \n-use ra_arena::{Arena, Idx};\n-use ra_syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr};\n+use arena::{Arena, Idx};\n+use syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr};\n \n /// `AstId` points to an AST node in a specific file.\n pub struct FileAstId<N: AstNode> {", "previous_filename": "crates/ra_hir_expand/src/ast_id_map.rs"}, {"sha": "988a60d56ade855110c8dff4e3f9d45a5a691241", "filename": "crates/hir_expand/src/builtin_derive.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_derive.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,8 +2,8 @@\n \n use log::debug;\n \n-use ra_parser::FragmentKind;\n-use ra_syntax::{\n+use parser::FragmentKind;\n+use syntax::{\n     ast::{self, AstNode, GenericParamsOwner, ModuleItemOwner, NameOwner},\n     match_ast,\n };\n@@ -253,8 +253,8 @@ fn partial_ord_expand(\n \n #[cfg(test)]\n mod tests {\n+    use base_db::{fixture::WithFixture, CrateId, SourceDatabase};\n     use name::{known, Name};\n-    use ra_db::{fixture::WithFixture, CrateId, SourceDatabase};\n \n     use crate::{test_db::TestDB, AstId, MacroCallId, MacroCallKind, MacroCallLoc};\n ", "previous_filename": "crates/ra_hir_expand/src/builtin_derive.rs"}, {"sha": "86918b626998e1233acfad0c431e911bb188156b", "filename": "crates/hir_expand/src/builtin_macro.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_macro.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,11 +4,11 @@ use crate::{\n     MacroDefId, MacroDefKind, TextSize,\n };\n \n+use base_db::FileId;\n use either::Either;\n use mbe::parse_to_token_tree;\n-use ra_db::FileId;\n-use ra_parser::FragmentKind;\n-use ra_syntax::ast::{self, AstToken, HasStringValue};\n+use parser::FragmentKind;\n+use syntax::ast::{self, AstToken, HasStringValue};\n \n macro_rules! register_builtin {\n     ( LAZY: $(($name:ident, $kind: ident) => $expand:ident),* , EAGER: $(($e_name:ident, $e_kind: ident) => $e_expand:ident),*  ) => {\n@@ -426,9 +426,9 @@ mod tests {\n         name::AsName, test_db::TestDB, AstNode, EagerCallLoc, MacroCallId, MacroCallKind,\n         MacroCallLoc,\n     };\n-    use ra_db::{fixture::WithFixture, SourceDatabase};\n-    use ra_syntax::ast::NameOwner;\n+    use base_db::{fixture::WithFixture, SourceDatabase};\n     use std::sync::Arc;\n+    use syntax::ast::NameOwner;\n \n     fn expand_builtin_macro(ra_fixture: &str) -> String {\n         let (db, file_id) = TestDB::with_single_file(&ra_fixture);", "previous_filename": "crates/ra_hir_expand/src/builtin_macro.rs"}, {"sha": "dcc038bcd8d6ce8b44403d31d2e3d913b2a1857b", "filename": "crates/hir_expand/src/db.rs", "status": "renamed", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,11 +2,10 @@\n \n use std::sync::Arc;\n \n+use base_db::{salsa, SourceDatabase};\n use mbe::{ExpandResult, MacroRules};\n-use ra_db::{salsa, SourceDatabase};\n-use ra_parser::FragmentKind;\n-use ra_prof::profile;\n-use ra_syntax::{algo::diff, AstNode, GreenNode, Parse, SyntaxKind::*, SyntaxNode};\n+use parser::FragmentKind;\n+use syntax::{algo::diff, AstNode, GreenNode, Parse, SyntaxKind::*, SyntaxNode};\n \n use crate::{\n     ast_id_map::AstIdMap, BuiltinDeriveExpander, BuiltinFnLikeExpander, EagerCallLoc, EagerMacroId,\n@@ -93,9 +92,9 @@ pub trait AstDatabase: SourceDatabase {\n pub fn expand_hypothetical(\n     db: &dyn AstDatabase,\n     actual_macro_call: MacroCallId,\n-    hypothetical_args: &ra_syntax::ast::TokenTree,\n-    token_to_map: ra_syntax::SyntaxToken,\n-) -> Option<(SyntaxNode, ra_syntax::SyntaxToken)> {\n+    hypothetical_args: &syntax::ast::TokenTree,\n+    token_to_map: syntax::SyntaxToken,\n+) -> Option<(SyntaxNode, syntax::SyntaxToken)> {\n     let macro_file = MacroFile { macro_call_id: actual_macro_call };\n     let (tt, tmap_1) = mbe::syntax_node_to_token_tree(hypothetical_args.syntax()).unwrap();\n     let range =\n@@ -106,7 +105,7 @@ pub fn expand_hypothetical(\n         parse_macro_with_arg(db, macro_file, Some(std::sync::Arc::new((tt, tmap_1))))?;\n     let token_id = macro_def.0.map_id_down(token_id);\n     let range = tmap_2.range_by_token(token_id)?.by_kind(token_to_map.kind())?;\n-    let token = ra_syntax::algo::find_covering_element(&node.syntax_node(), range).into_token()?;\n+    let token = syntax::algo::find_covering_element(&node.syntax_node(), range).into_token()?;\n     Some((node.syntax_node(), token))\n }\n \n@@ -278,7 +277,7 @@ pub fn parse_macro_with_arg(\n     macro_file: MacroFile,\n     arg: Option<Arc<(tt::Subtree, mbe::TokenMap)>>,\n ) -> Option<(Parse<SyntaxNode>, Arc<mbe::TokenMap>)> {\n-    let _p = profile(\"parse_macro_query\");\n+    let _p = profile::span(\"parse_macro_query\");\n \n     let macro_call_id = macro_file.macro_call_id;\n     let (tt, err) = if let Some(arg) = arg {\n@@ -379,7 +378,7 @@ fn to_fragment_kind(db: &dyn AstDatabase, id: MacroCallId) -> FragmentKind {\n \n         FOR_EXPR => FragmentKind::Expr,\n         PATH_EXPR => FragmentKind::Expr,\n-        LAMBDA_EXPR => FragmentKind::Expr,\n+        CLOSURE_EXPR => FragmentKind::Expr,\n         CONDITION => FragmentKind::Expr,\n         BREAK_EXPR => FragmentKind::Expr,\n         RETURN_EXPR => FragmentKind::Expr,", "previous_filename": "crates/ra_hir_expand/src/db.rs"}, {"sha": "78ccc212c84c4214feb2a8747371b14b25389e48", "filename": "crates/hir_expand/src/diagnostics.rs", "status": "renamed", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdiagnostics.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -16,35 +16,30 @@\n \n use std::{any::Any, fmt};\n \n-use ra_syntax::{SyntaxNode, SyntaxNodePtr};\n+use syntax::SyntaxNodePtr;\n \n-use crate::{db::AstDatabase, InFile};\n+use crate::InFile;\n+\n+#[derive(Copy, Clone, PartialEq)]\n+pub struct DiagnosticCode(pub &'static str);\n+\n+impl DiagnosticCode {\n+    pub fn as_str(&self) -> &str {\n+        self.0\n+    }\n+}\n \n pub trait Diagnostic: Any + Send + Sync + fmt::Debug + 'static {\n+    fn code(&self) -> DiagnosticCode;\n     fn message(&self) -> String;\n-    fn source(&self) -> InFile<SyntaxNodePtr>;\n+    /// Used in highlighting and related purposes\n+    fn display_source(&self) -> InFile<SyntaxNodePtr>;\n     fn as_any(&self) -> &(dyn Any + Send + 'static);\n     fn is_experimental(&self) -> bool {\n         false\n     }\n }\n \n-pub trait AstDiagnostic {\n-    type AST;\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST;\n-}\n-\n-impl dyn Diagnostic {\n-    pub fn syntax_node(&self, db: &impl AstDatabase) -> SyntaxNode {\n-        let node = db.parse_or_expand(self.source().file_id).unwrap();\n-        self.source().value.to_node(&node)\n-    }\n-\n-    pub fn downcast_ref<D: Diagnostic>(&self) -> Option<&D> {\n-        self.as_any().downcast_ref()\n-    }\n-}\n-\n pub struct DiagnosticSink<'a> {\n     callbacks: Vec<Box<dyn FnMut(&dyn Diagnostic) -> Result<(), ()> + 'a>>,\n     filters: Vec<Box<dyn FnMut(&dyn Diagnostic) -> bool + 'a>>,\n@@ -89,7 +84,7 @@ impl<'a> DiagnosticSinkBuilder<'a> {\n     }\n \n     pub fn on<D: Diagnostic, F: FnMut(&D) + 'a>(mut self, mut cb: F) -> Self {\n-        let cb = move |diag: &dyn Diagnostic| match diag.downcast_ref::<D>() {\n+        let cb = move |diag: &dyn Diagnostic| match diag.as_any().downcast_ref::<D>() {\n             Some(d) => {\n                 cb(d);\n                 Ok(())", "previous_filename": "crates/ra_hir_expand/src/diagnostics.rs"}, {"sha": "10c45646f0d94228ff710d8775dd6033d8381d2c", "filename": "crates/hir_expand/src/eager.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Feager.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -25,10 +25,10 @@ use crate::{\n     EagerCallLoc, EagerMacroId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n \n-use ra_db::CrateId;\n-use ra_parser::FragmentKind;\n-use ra_syntax::{algo::SyntaxRewriter, SyntaxNode};\n+use base_db::CrateId;\n+use parser::FragmentKind;\n use std::sync::Arc;\n+use syntax::{algo::SyntaxRewriter, SyntaxNode};\n \n pub fn expand_eager_macro(\n     db: &dyn AstDatabase,", "previous_filename": "crates/ra_hir_expand/src/eager.rs"}, {"sha": "845e9cbc19a6fc7168cea7a92f8cbc229dacecc6", "filename": "crates/hir_expand/src/hygiene.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fhygiene.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,9 +2,9 @@\n //!\n //! Specifically, `ast` + `Hygiene` allows you to create a `Name`. Note that, at\n //! this moment, this is horribly incomplete and handles only `$crate`.\n+use base_db::CrateId;\n use either::Either;\n-use ra_db::CrateId;\n-use ra_syntax::ast;\n+use syntax::ast;\n \n use crate::{\n     db::AstDatabase,\n@@ -17,7 +17,7 @@ pub struct Hygiene {\n     // This is what `$crate` expands to\n     def_crate: Option<CrateId>,\n \n-    // Indiciate this is a local inner macro\n+    // Indicate this is a local inner macro\n     local_inner: bool,\n }\n ", "previous_filename": "crates/ra_hir_expand/src/hygiene.rs"}, {"sha": "2be15e84132d91ecf716fa2e6bd89ddbcd86e00d", "filename": "crates/hir_expand/src/lib.rs", "status": "renamed", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-//! `ra_hir_expand` deals with macro expansion.\n+//! `hir_expand` deals with macro expansion.\n //!\n //! Specifically, it implements a concept of `MacroFile` -- a file whose syntax\n //! tree originates not from the text of some `FileId`, but from some macro\n@@ -18,8 +18,8 @@ pub mod eager;\n use std::hash::Hash;\n use std::sync::Arc;\n \n-use ra_db::{impl_intern_key, salsa, CrateId, FileId};\n-use ra_syntax::{\n+use base_db::{impl_intern_key, salsa, CrateId, FileId};\n+use syntax::{\n     algo,\n     ast::{self, AstNode},\n     SyntaxNode, SyntaxToken, TextSize,\n@@ -44,7 +44,8 @@ mod test_db;\n /// containing the call plus the offset of the macro call in the file. Note that\n /// this is a recursive definition! However, the size_of of `HirFileId` is\n /// finite (because everything bottoms out at the real `FileId`) and small\n-/// (`MacroCallId` uses the location interner).\n+/// (`MacroCallId` uses the location interning. You can check details here:\n+/// https://en.wikipedia.org/wiki/String_interning).\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct HirFileId(HirFileIdRepr);\n \n@@ -316,7 +317,7 @@ pub struct ExpansionInfo {\n }\n \n pub use mbe::Origin;\n-use ra_parser::FragmentKind;\n+use parser::FragmentKind;\n \n impl ExpansionInfo {\n     pub fn call_node(&self) -> Option<InFile<SyntaxNode>> {", "previous_filename": "crates/ra_hir_expand/src/lib.rs"}, {"sha": "49841c7a124fcd655507ffe73492416675d5c7c5", "filename": "crates/hir_expand/src/name.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt;\n \n-use ra_syntax::{ast, SmolStr};\n+use syntax::{ast, SmolStr};\n \n /// `Name` is a wrapper around string, which is used in hir for both references\n /// and declarations. In theory, names should also carry hygiene info, but we are\n@@ -37,8 +37,8 @@ impl Name {\n         Name(Repr::TupleField(idx))\n     }\n \n-    pub fn new_lifetime(lt: &ra_syntax::SyntaxToken) -> Name {\n-        assert!(lt.kind() == ra_syntax::SyntaxKind::LIFETIME);\n+    pub fn new_lifetime(lt: &syntax::SyntaxToken) -> Name {\n+        assert!(lt.kind() == syntax::SyntaxKind::LIFETIME);\n         Name(Repr::Text(lt.text().clone()))\n     }\n \n@@ -115,7 +115,7 @@ impl AsName for ast::FieldKind {\n     }\n }\n \n-impl AsName for ra_db::Dependency {\n+impl AsName for base_db::Dependency {\n     fn as_name(&self) -> Name {\n         Name::new_text(SmolStr::new(&*self.name))\n     }", "previous_filename": "crates/ra_hir_expand/src/name.rs"}, {"sha": "80255ea32740cec7db4534fd2dca7391d9a76535", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,7 @@\n //! Proc Macro Expander stub\n \n use crate::{db::AstDatabase, LazyMacroId};\n-use ra_db::{CrateId, ProcMacroId};\n+use base_db::{CrateId, ProcMacroId};\n use tt::buffer::{Cursor, TokenBuffer};\n \n #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]\n@@ -101,7 +101,7 @@ fn remove_derive_attrs(tt: &tt::Subtree) -> Option<tt::Subtree> {\n }\n \n #[cfg(test)]\n-mod test {\n+mod tests {\n     use super::*;\n     use test_utils::assert_eq_text;\n ", "previous_filename": "crates/ra_hir_expand/src/proc_macro.rs"}, {"sha": "219bc20978e5c66c79c156bf3591c248beacc2ae", "filename": "crates/hir_expand/src/quote.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fquote.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_expand/src/quote.rs"}, {"sha": "86a5d867e6808f5d1090e3c068d8e4bcbc4e277a", "filename": "crates/hir_expand/src/test_db.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_expand%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Ftest_db.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,12 +5,12 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n-use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate};\n+use base_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate};\n use rustc_hash::FxHashSet;\n \n #[salsa::database(\n-    ra_db::SourceDatabaseExtStorage,\n-    ra_db::SourceDatabaseStorage,\n+    base_db::SourceDatabaseExtStorage,\n+    base_db::SourceDatabaseStorage,\n     crate::db::AstDatabaseStorage\n )]\n #[derive(Default)]", "previous_filename": "crates/ra_hir_expand/src/test_db.rs"}, {"sha": "06da0d0ec8d23c783a1bc465db7e1b911325342d", "filename": "crates/hir_ty/Cargo.toml", "status": "renamed", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n [package]\n-edition = \"2018\"\n-name = \"ra_hir_ty\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n+name = \"hir_ty\"\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false\n@@ -15,26 +15,22 @@ smallvec = \"1.2.0\"\n ena = \"0.14.0\"\n log = \"0.4.8\"\n rustc-hash = \"1.1.0\"\n+scoped-tls = \"1\"\n+chalk-solve = { version = \"0.23.0\" }\n+chalk-ir = { version = \"0.23.0\" }\n+chalk-recursive = { version = \"0.23.0\" }\n \n stdx = { path = \"../stdx\" }\n-\n-hir_def = { path = \"../ra_hir_def\", package = \"ra_hir_def\" }\n-hir_expand = { path = \"../ra_hir_expand\", package = \"ra_hir_expand\" }\n-ra_arena = { path = \"../ra_arena\" }\n-ra_db = { path = \"../ra_db\" }\n-ra_prof = { path = \"../ra_prof\" }\n-ra_syntax = { path = \"../ra_syntax\" }\n+hir_def = { path = \"../hir_def\" }\n+hir_expand = { path = \"../hir_expand\" }\n+arena = { path = \"../arena\" }\n+base_db = { path = \"../base_db\" }\n+profile = { path = \"../profile\" }\n+syntax = { path = \"../syntax\" }\n test_utils = { path = \"../test_utils\" }\n \n-scoped-tls = \"1\"\n-\n-chalk-solve = { version = \"0.19.0\" }\n-chalk-ir = { version = \"0.19.0\" }\n-chalk-recursive = { version = \"0.19.0\" }\n-\n [dev-dependencies]\n-expect = { path = \"../expect\" }\n-\n+expect-test = \"0.1\"\n tracing = \"0.1\"\n tracing-subscriber = { version = \"0.2\", default-features = false, features = [\"env-filter\", \"registry\"] }\n tracing-tree = { version = \"0.1.4\" }", "previous_filename": "crates/ra_hir_ty/Cargo.toml"}, {"sha": "ece68183e749fe57893bba854eb36103fcc9c330", "filename": "crates/hir_ty/src/autoderef.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,10 +5,10 @@\n \n use std::iter::successors;\n \n+use base_db::CrateId;\n use hir_def::lang_item::LangItemTarget;\n use hir_expand::name::name;\n use log::{info, warn};\n-use ra_db::CrateId;\n \n use crate::{\n     db::HirDatabase,", "previous_filename": "crates/ra_hir_ty/src/autoderef.rs"}, {"sha": "25cf9eb7f1279099a2e7de51ad08e8b7e5a7add0", "filename": "crates/hir_ty/src/db.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,13 +2,12 @@\n \n use std::sync::Arc;\n \n+use arena::map::ArenaMap;\n+use base_db::{impl_intern_key, salsa, CrateId, Upcast};\n use hir_def::{\n     db::DefDatabase, expr::ExprId, DefWithBodyId, FunctionId, GenericDefId, ImplId, LocalFieldId,\n     TypeParamId, VariantId,\n };\n-use ra_arena::map::ArenaMap;\n-use ra_db::{impl_intern_key, salsa, CrateId, Upcast};\n-use ra_prof::profile;\n \n use crate::{\n     method_resolution::{InherentImpls, TraitImpls},\n@@ -123,7 +122,7 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n }\n \n fn infer_wait(db: &impl HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n-    let _p = profile(\"infer:wait\").detail(|| match def {\n+    let _p = profile::span(\"infer:wait\").detail(|| match def {\n         DefWithBodyId::FunctionId(it) => db.function_data(it).name.to_string(),\n         DefWithBodyId::StaticId(it) => {\n             db.static_data(it).name.clone().unwrap_or_else(Name::missing).to_string()", "previous_filename": "crates/ra_hir_ty/src/db.rs"}, {"sha": "9ba005fabd4e45dcd7741cc3d5f4492aeb8c2033", "filename": "crates/hir_ty/src/diagnostics.rs", "status": "renamed", "additions": 74, "deletions": 86, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -6,18 +6,17 @@ mod unsafe_check;\n use std::any::Any;\n \n use hir_def::DefWithBodyId;\n-use hir_expand::diagnostics::{AstDiagnostic, Diagnostic, DiagnosticSink};\n-use hir_expand::{db::AstDatabase, name::Name, HirFileId, InFile};\n-use ra_prof::profile;\n-use ra_syntax::{ast, AstNode, AstPtr, SyntaxNodePtr};\n+use hir_expand::diagnostics::{Diagnostic, DiagnosticCode, DiagnosticSink};\n+use hir_expand::{name::Name, HirFileId, InFile};\n use stdx::format_to;\n+use syntax::{ast, AstPtr, SyntaxNodePtr};\n \n use crate::db::HirDatabase;\n \n pub use crate::diagnostics::expr::{record_literal_missing_fields, record_pattern_missing_fields};\n \n pub fn validate_body(db: &dyn HirDatabase, owner: DefWithBodyId, sink: &mut DiagnosticSink<'_>) {\n-    let _p = profile(\"validate_body\");\n+    let _p = profile::span(\"validate_body\");\n     let infer = db.infer(owner);\n     infer.add_diagnostics(db, owner, sink);\n     let mut validator = expr::ExprValidator::new(owner, infer.clone(), sink);\n@@ -33,11 +32,15 @@ pub struct NoSuchField {\n }\n \n impl Diagnostic for NoSuchField {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"no-such-field\")\n+    }\n+\n     fn message(&self) -> String {\n         \"no such field\".to_string()\n     }\n \n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile::new(self.file, self.field.clone().into())\n     }\n \n@@ -46,66 +49,70 @@ impl Diagnostic for NoSuchField {\n     }\n }\n \n-impl AstDiagnostic for NoSuchField {\n-    type AST = ast::RecordExprField;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::RecordExprField::cast(node).unwrap()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MissingFields {\n     pub file: HirFileId,\n-    pub field_list: AstPtr<ast::RecordExprFieldList>,\n+    pub field_list_parent: AstPtr<ast::RecordExpr>,\n+    pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n     pub missed_fields: Vec<Name>,\n }\n \n impl Diagnostic for MissingFields {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"missing-structure-fields\")\n+    }\n     fn message(&self) -> String {\n         let mut buf = String::from(\"Missing structure fields:\\n\");\n         for field in &self.missed_fields {\n             format_to!(buf, \"- {}\\n\", field);\n         }\n         buf\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.field_list.clone().into() }\n+\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile {\n+            file_id: self.file,\n+            value: self\n+                .field_list_parent_path\n+                .clone()\n+                .map(SyntaxNodePtr::from)\n+                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n+        }\n     }\n+\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n \n-impl AstDiagnostic for MissingFields {\n-    type AST = ast::RecordExprFieldList;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::RecordExprFieldList::cast(node).unwrap()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MissingPatFields {\n     pub file: HirFileId,\n-    pub field_list: AstPtr<ast::RecordFieldPatList>,\n+    pub field_list_parent: AstPtr<ast::RecordPat>,\n+    pub field_list_parent_path: Option<AstPtr<ast::Path>>,\n     pub missed_fields: Vec<Name>,\n }\n \n impl Diagnostic for MissingPatFields {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"missing-pat-fields\")\n+    }\n     fn message(&self) -> String {\n         let mut buf = String::from(\"Missing structure fields:\\n\");\n         for field in &self.missed_fields {\n             format_to!(buf, \"- {}\\n\", field);\n         }\n         buf\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n-        InFile { file_id: self.file, value: self.field_list.clone().into() }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile {\n+            file_id: self.file,\n+            value: self\n+                .field_list_parent_path\n+                .clone()\n+                .map(SyntaxNodePtr::from)\n+                .unwrap_or_else(|| self.field_list_parent.clone().into()),\n+        }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n@@ -120,10 +127,13 @@ pub struct MissingMatchArms {\n }\n \n impl Diagnostic for MissingMatchArms {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"missing-match-arm\")\n+    }\n     fn message(&self) -> String {\n         String::from(\"Missing match arm\")\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.match_expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n@@ -138,83 +148,62 @@ pub struct MissingOkInTailExpr {\n }\n \n impl Diagnostic for MissingOkInTailExpr {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"missing-ok-in-tail-expr\")\n+    }\n     fn message(&self) -> String {\n         \"wrap return expression in Ok\".to_string()\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n \n-impl AstDiagnostic for MissingOkInTailExpr {\n-    type AST = ast::Expr;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.file).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::Expr::cast(node).unwrap()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct BreakOutsideOfLoop {\n     pub file: HirFileId,\n     pub expr: AstPtr<ast::Expr>,\n }\n \n impl Diagnostic for BreakOutsideOfLoop {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"break-outside-of-loop\")\n+    }\n     fn message(&self) -> String {\n         \"break outside of loop\".to_string()\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n \n-impl AstDiagnostic for BreakOutsideOfLoop {\n-    type AST = ast::Expr;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.file).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::Expr::cast(node).unwrap()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MissingUnsafe {\n     pub file: HirFileId,\n     pub expr: AstPtr<ast::Expr>,\n }\n \n impl Diagnostic for MissingUnsafe {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"missing-unsafe\")\n+    }\n     fn message(&self) -> String {\n         format!(\"This operation is unsafe and requires an unsafe function or block\")\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n         self\n     }\n }\n \n-impl AstDiagnostic for MissingUnsafe {\n-    type AST = ast::Expr;\n-\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::Expr::cast(node).unwrap()\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MismatchedArgCount {\n     pub file: HirFileId,\n@@ -224,11 +213,14 @@ pub struct MismatchedArgCount {\n }\n \n impl Diagnostic for MismatchedArgCount {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"mismatched-arg-count\")\n+    }\n     fn message(&self) -> String {\n         let s = if self.expected == 1 { \"\" } else { \"s\" };\n         format!(\"Expected {} argument{}, found {}\", self.expected, s, self.found)\n     }\n-    fn source(&self) -> InFile<SyntaxNodePtr> {\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n         InFile { file_id: self.file, value: self.call_expr.clone().into() }\n     }\n     fn as_any(&self) -> &(dyn Any + Send + 'static) {\n@@ -239,22 +231,16 @@ impl Diagnostic for MismatchedArgCount {\n     }\n }\n \n-impl AstDiagnostic for MismatchedArgCount {\n-    type AST = ast::CallExpr;\n-    fn ast(&self, db: &dyn AstDatabase) -> Self::AST {\n-        let root = db.parse_or_expand(self.source().file_id).unwrap();\n-        let node = self.source().value.to_node(&root);\n-        ast::CallExpr::cast(node).unwrap()\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n+    use base_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n     use hir_def::{db::DefDatabase, AssocItemId, ModuleDefId};\n-    use hir_expand::diagnostics::{Diagnostic, DiagnosticSinkBuilder};\n-    use ra_db::{fixture::WithFixture, FileId, SourceDatabase, SourceDatabaseExt};\n-    use ra_syntax::{TextRange, TextSize};\n+    use hir_expand::{\n+        db::AstDatabase,\n+        diagnostics::{Diagnostic, DiagnosticSinkBuilder},\n+    };\n     use rustc_hash::FxHashMap;\n+    use syntax::{TextRange, TextSize};\n \n     use crate::{diagnostics::validate_body, test_db::TestDB};\n \n@@ -296,9 +282,11 @@ mod tests {\n \n         let mut actual: FxHashMap<FileId, Vec<(TextRange, String)>> = FxHashMap::default();\n         db.diagnostics(|d| {\n-            // FXIME: macros...\n-            let file_id = d.source().file_id.original_file(&db);\n-            let range = d.syntax_node(&db).text_range();\n+            let src = d.display_source();\n+            let root = db.parse_or_expand(src.file_id).unwrap();\n+            // FIXME: macros...\n+            let file_id = src.file_id.original_file(&db);\n+            let range = src.value.to_node(&root).text_range();\n             let message = d.message().to_owned();\n             actual.entry(file_id).or_default().push((range, message));\n         });\n@@ -326,8 +314,8 @@ struct S { foo: i32, bar: () }\n impl S {\n     fn new() -> S {\n         S {\n-        //^... Missing structure fields:\n-        //|    - bar\n+      //^ Missing structure fields:\n+      //|    - bar\n             foo: 92,\n             baz: 62,\n           //^^^^^^^ no such field\n@@ -448,8 +436,8 @@ impl Foo {\n struct S { foo: i32, bar: () }\n fn baz(s: S) {\n     let S { foo: _ } = s;\n-        //^^^^^^^^^^ Missing structure fields:\n-        //         | - bar\n+      //^ Missing structure fields:\n+      //| - bar\n }\n \"#,\n         );", "previous_filename": "crates/ra_hir_ty/src/diagnostics.rs"}, {"sha": "278a4b94726aca5bcd31aaf860a3b99a7d94019f", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "renamed", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,8 +4,8 @@ use std::sync::Arc;\n \n use hir_def::{path::path, resolver::HasResolver, AdtId, DefWithBodyId};\n use hir_expand::diagnostics::DiagnosticSink;\n-use ra_syntax::{ast, AstPtr};\n use rustc_hash::FxHashSet;\n+use syntax::{ast, AstPtr};\n \n use crate::{\n     db::HirDatabase,\n@@ -100,16 +100,17 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         if let Ok(source_ptr) = source_map.expr_syntax(id) {\n             let root = source_ptr.file_syntax(db.upcast());\n-            if let ast::Expr::RecordExpr(record_lit) = &source_ptr.value.to_node(&root) {\n-                if let Some(field_list) = record_lit.record_expr_field_list() {\n+            if let ast::Expr::RecordExpr(record_expr) = &source_ptr.value.to_node(&root) {\n+                if let Some(_) = record_expr.record_expr_field_list() {\n                     let variant_data = variant_data(db.upcast(), variant_def);\n                     let missed_fields = missed_fields\n                         .into_iter()\n                         .map(|idx| variant_data.fields()[idx].name.clone())\n                         .collect();\n                     self.sink.push(MissingFields {\n                         file: source_ptr.file_id,\n-                        field_list: AstPtr::new(&field_list),\n+                        field_list_parent: AstPtr::new(&record_expr),\n+                        field_list_parent_path: record_expr.path().map(|path| AstPtr::new(&path)),\n                         missed_fields,\n                     })\n                 }\n@@ -131,15 +132,18 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             if let Some(expr) = source_ptr.value.as_ref().left() {\n                 let root = source_ptr.file_syntax(db.upcast());\n                 if let ast::Pat::RecordPat(record_pat) = expr.to_node(&root) {\n-                    if let Some(field_list) = record_pat.record_field_pat_list() {\n+                    if let Some(_) = record_pat.record_pat_field_list() {\n                         let variant_data = variant_data(db.upcast(), variant_def);\n                         let missed_fields = missed_fields\n                             .into_iter()\n                             .map(|idx| variant_data.fields()[idx].name.clone())\n                             .collect();\n                         self.sink.push(MissingPatFields {\n                             file: source_ptr.file_id,\n-                            field_list: AstPtr::new(&field_list),\n+                            field_list_parent: AstPtr::new(&record_pat),\n+                            field_list_parent_path: record_pat\n+                                .path()\n+                                .map(|path| AstPtr::new(&path)),\n                             missed_fields,\n                         })\n                     }\n@@ -219,10 +223,10 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             db.body_with_source_map(self.owner.into());\n \n         let match_expr_ty = match infer.type_of_expr.get(match_expr) {\n-            Some(ty) => ty,\n             // If we can't resolve the type of the match expression\n             // we cannot perform exhaustiveness checks.\n-            None => return,\n+            None | Some(Ty::Unknown) => return,\n+            Some(ty) => ty,\n         };\n \n         let cx = MatchCheckCtx { match_expr, body, infer: infer.clone(), db };", "previous_filename": "crates/ra_hir_ty/src/diagnostics/expr.rs"}, {"sha": "5bd03f2ac00d1c6046ded5f1960a0c8773c3d4b0", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "renamed", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -218,13 +218,13 @@\n //!   ```\n use std::sync::Arc;\n \n+use arena::Idx;\n use hir_def::{\n     adt::VariantData,\n     body::Body,\n     expr::{Expr, Literal, Pat, PatId},\n     AdtId, EnumVariantId, VariantId,\n };\n-use ra_arena::Idx;\n use smallvec::{smallvec, SmallVec};\n \n use crate::{db::HirDatabase, ApplicationTy, InferenceResult, Ty, TypeCtor};\n@@ -1161,15 +1161,15 @@ fn main() {\n         //^ Missing match arm\n     match a {\n         Either::A { } => (),\n-                //^^^ Missing structure fields:\n-                //  | - foo\n+      //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n         Either::B => (),\n     }\n     match a {\n         //^ Missing match arm\n         Either::A { } => (),\n-    }           //^^^ Missing structure fields:\n-                //  | - foo\n+    } //^^^^^^^^^ Missing structure fields:\n+      //        | - foo\n \n     match a {\n         Either::A { foo: true } => (),\n@@ -1335,6 +1335,23 @@ fn panic(a: Category, b: Category) {\n         );\n     }\n \n+    #[test]\n+    fn unknown_type() {\n+        check_diagnostics(\n+            r#\"\n+enum Option<T> { Some(T), None }\n+\n+fn main() {\n+    // `Never` is deliberately not defined so that it's an uninferred type.\n+    match Option::<Never>::None {\n+        None => (),\n+        Some(never) => match never {},\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n     mod false_negatives {\n         //! The implementation of match checking here is a work in progress. As we roll this out, we\n         //! prefer false negatives to false positives (ideally there would be no false positives). This", "previous_filename": "crates/ra_hir_ty/src/diagnostics/match_check.rs"}, {"sha": "61ffbf5d1519111c71ed52f6637252dbcc26f342", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "renamed", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -6,6 +6,7 @@ use std::sync::Arc;\n use hir_def::{\n     body::Body,\n     expr::{Expr, ExprId, UnaryOp},\n+    resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n     DefWithBodyId,\n };\n use hir_expand::diagnostics::DiagnosticSink;\n@@ -70,7 +71,7 @@ pub fn unsafe_expressions(\n ) -> Vec<UnsafeExpr> {\n     let mut unsafe_exprs = vec![];\n     let body = db.body(def);\n-    walk_unsafe(&mut unsafe_exprs, db, infer, &body, body.body_expr, false);\n+    walk_unsafe(&mut unsafe_exprs, db, infer, def, &body, body.body_expr, false);\n \n     unsafe_exprs\n }\n@@ -79,6 +80,7 @@ fn walk_unsafe(\n     unsafe_exprs: &mut Vec<UnsafeExpr>,\n     db: &dyn HirDatabase,\n     infer: &InferenceResult,\n+    def: DefWithBodyId,\n     body: &Body,\n     current: ExprId,\n     inside_unsafe_block: bool,\n@@ -97,6 +99,15 @@ fn walk_unsafe(\n                 }\n             }\n         }\n+        Expr::Path(path) => {\n+            let resolver = resolver_for_expr(db.upcast(), def, current);\n+            let value_or_partial = resolver.resolve_path_in_value_ns(db.upcast(), path.mod_path());\n+            if let Some(ResolveValueResult::ValueNs(ValueNs::StaticId(id))) = value_or_partial {\n+                if db.static_data(id).mutable {\n+                    unsafe_exprs.push(UnsafeExpr { expr: current, inside_unsafe_block });\n+                }\n+            }\n+        }\n         Expr::MethodCall { .. } => {\n             if infer\n                 .method_resolution(current)\n@@ -112,13 +123,13 @@ fn walk_unsafe(\n             }\n         }\n         Expr::Unsafe { body: child } => {\n-            return walk_unsafe(unsafe_exprs, db, infer, body, *child, true);\n+            return walk_unsafe(unsafe_exprs, db, infer, def, body, *child, true);\n         }\n         _ => {}\n     }\n \n     expr.walk_child_exprs(|child| {\n-        walk_unsafe(unsafe_exprs, db, infer, body, child, inside_unsafe_block);\n+        walk_unsafe(unsafe_exprs, db, infer, def, body, child, inside_unsafe_block);\n     });\n }\n \n@@ -167,6 +178,27 @@ fn main() {\n         HasUnsafe.unsafe_fn();\n     }\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn missing_unsafe_diagnostic_with_static_mut() {\n+        check_diagnostics(\n+            r#\"\n+struct Ty {\n+    a: u8,\n+}\n+\n+static mut static_mut: Ty = Ty { a: 0 };\n+\n+fn main() {\n+    let x = static_mut.a;\n+          //^^^^^^^^^^ This operation is unsafe and requires an unsafe function or block\n+    unsafe {\n+        let x = static_mut.a;\n+    }\n+}\n \"#,\n         );\n     }", "previous_filename": "crates/ra_hir_ty/src/diagnostics/unsafe_check.rs"}, {"sha": "64b68014d8a07f530cd67c947f41d043cf312366", "filename": "crates/hir_ty/src/display.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -511,6 +511,7 @@ fn write_bounds_like_dyn_trait(\n             GenericPredicate::Implemented(trait_ref) => {\n                 if angle_open {\n                     write!(f, \">\")?;\n+                    angle_open = false;\n                 }\n                 if !first {\n                     write!(f, \" + \")?;", "previous_filename": "crates/ra_hir_ty/src/display.rs"}, {"sha": "03b00b101c2314788f795ad6f7ae4edd3b64d40a", "filename": "crates/hir_ty/src/infer.rs", "status": "renamed", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -18,6 +18,7 @@ use std::mem;\n use std::ops::Index;\n use std::sync::Arc;\n \n+use arena::map::ArenaMap;\n use hir_def::{\n     body::Body,\n     data::{ConstData, FunctionData, StaticData},\n@@ -30,11 +31,9 @@ use hir_def::{\n     TypeAliasId, VariantId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name::name};\n-use ra_arena::map::ArenaMap;\n-use ra_prof::profile;\n-use ra_syntax::SmolStr;\n use rustc_hash::FxHashMap;\n use stdx::impl_from;\n+use syntax::SmolStr;\n \n use super::{\n     primitive::{FloatTy, IntTy},\n@@ -64,7 +63,7 @@ mod coerce;\n \n /// The entry point of type inference.\n pub(crate) fn infer_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n-    let _p = profile(\"infer_query\");\n+    let _p = profile::span(\"infer_query\");\n     let resolver = def.resolver(db.upcast());\n     let mut ctx = InferenceContext::new(db, def, resolver);\n \n@@ -440,6 +439,12 @@ impl<'a> InferenceContext<'a> {\n                 let ty = self.insert_type_vars(ty.subst(&substs));\n                 forbid_unresolved_segments((ty, Some(strukt.into())), unresolved)\n             }\n+            TypeNs::AdtId(AdtId::UnionId(u)) => {\n+                let substs = Ty::substs_from_path(&ctx, path, u.into(), true);\n+                let ty = self.db.ty(u.into());\n+                let ty = self.insert_type_vars(ty.subst(&substs));\n+                forbid_unresolved_segments((ty, Some(u.into())), unresolved)\n+            }\n             TypeNs::EnumVariantId(var) => {\n                 let substs = Ty::substs_from_path(&ctx, path, var.into(), true);\n                 let ty = self.db.ty(var.parent.into());\n@@ -490,10 +495,7 @@ impl<'a> InferenceContext<'a> {\n                 // FIXME potentially resolve assoc type\n                 (Ty::Unknown, None)\n             }\n-            TypeNs::AdtId(AdtId::EnumId(_))\n-            | TypeNs::AdtId(AdtId::UnionId(_))\n-            | TypeNs::BuiltinType(_)\n-            | TypeNs::TraitId(_) => {\n+            TypeNs::AdtId(AdtId::EnumId(_)) | TypeNs::BuiltinType(_) | TypeNs::TraitId(_) => {\n                 // FIXME diagnostic\n                 (Ty::Unknown, None)\n             }", "previous_filename": "crates/ra_hir_ty/src/infer.rs"}, {"sha": "32c7c57cd61a3be0561d59436b391eb6fda0ec77", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_ty/src/infer/coerce.rs"}, {"sha": "a2f849d02130b4f1a9923f824d7c568618b71f38", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -11,7 +11,7 @@ use hir_def::{\n     AdtId, AssocContainerId, FieldId, Lookup,\n };\n use hir_expand::name::{name, Name};\n-use ra_syntax::ast::RangeOp;\n+use syntax::ast::RangeOp;\n \n use crate::{\n     autoderef, method_resolution, op,", "previous_filename": "crates/ra_hir_ty/src/infer/expr.rs"}, {"sha": "4dd4f9802d6ecf93bf48027fe64baccf9820080b", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_ty/src/infer/pat.rs"}, {"sha": "80d7ed10ec3c6a9972d99a62bafe83be038ac623", "filename": "crates/hir_ty/src/infer/path.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_ty/src/infer/path.rs"}, {"sha": "2e895d911683c7f18b2cdace38d9b3a19a998cfb", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_ty/src/infer/unify.rs"}, {"sha": "1e748476ac1946a6afefce3b91056136424889f3", "filename": "crates/hir_ty/src/lib.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -26,14 +26,14 @@ mod test_db;\n \n use std::{iter, mem, ops::Deref, sync::Arc};\n \n+use base_db::{salsa, CrateId};\n use hir_def::{\n     expr::ExprId,\n     type_ref::{Mutability, Rawness},\n     AdtId, AssocContainerId, DefWithBodyId, GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n     TypeParamId,\n };\n use itertools::Itertools;\n-use ra_db::{salsa, CrateId};\n \n use crate::{\n     db::HirDatabase,", "previous_filename": "crates/ra_hir_ty/src/lib.rs"}, {"sha": "cd574e983f90ad09bb314e4c52d3f72807bc2562", "filename": "crates/hir_ty/src/lower.rs", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -7,6 +7,8 @@\n //! This usually involves resolving names, collecting generic arguments etc.\n use std::{iter, sync::Arc};\n \n+use arena::map::ArenaMap;\n+use base_db::CrateId;\n use hir_def::{\n     adt::StructKind,\n     builtin_type::BuiltinType,\n@@ -19,8 +21,6 @@ use hir_def::{\n     UnionId, VariantId,\n };\n use hir_expand::name::Name;\n-use ra_arena::map::ArenaMap;\n-use ra_db::CrateId;\n use smallvec::SmallVec;\n use stdx::impl_from;\n use test_utils::mark;\n@@ -518,6 +518,7 @@ impl Ty {\n         let (segment, generic_def) = match resolved {\n             ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n             ValueTyDefId::StructId(it) => (last, Some(it.into())),\n+            ValueTyDefId::UnionId(it) => (last, Some(it.into())),\n             ValueTyDefId::ConstId(it) => (last, Some(it.into())),\n             ValueTyDefId::StaticId(_) => (last, None),\n             ValueTyDefId::EnumVariantId(var) => {\n@@ -1148,11 +1149,12 @@ impl_from!(BuiltinType, AdtId(StructId, EnumId, UnionId), TypeAliasId for TyDefI\n pub enum ValueTyDefId {\n     FunctionId(FunctionId),\n     StructId(StructId),\n+    UnionId(UnionId),\n     EnumVariantId(EnumVariantId),\n     ConstId(ConstId),\n     StaticId(StaticId),\n }\n-impl_from!(FunctionId, StructId, EnumVariantId, ConstId, StaticId for ValueTyDefId);\n+impl_from!(FunctionId, StructId, UnionId, EnumVariantId, ConstId, StaticId for ValueTyDefId);\n \n /// Build the declared type of an item. This depends on the namespace; e.g. for\n /// `struct Foo(usize)`, we have two types: The type of the struct itself, and\n@@ -1179,6 +1181,7 @@ pub(crate) fn value_ty_query(db: &dyn HirDatabase, def: ValueTyDefId) -> Binders\n     match def {\n         ValueTyDefId::FunctionId(it) => type_for_fn(db, it),\n         ValueTyDefId::StructId(it) => type_for_struct_constructor(db, it),\n+        ValueTyDefId::UnionId(it) => type_for_adt(db, it.into()),\n         ValueTyDefId::EnumVariantId(it) => type_for_enum_variant_constructor(db, it),\n         ValueTyDefId::ConstId(it) => type_for_const(db, it),\n         ValueTyDefId::StaticId(it) => type_for_static(db, it),", "previous_filename": "crates/ra_hir_ty/src/lower.rs"}, {"sha": "ec59145c700a85990045ce4f7c6926947276ac58", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,15 +5,14 @@\n use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n+use base_db::CrateId;\n use hir_def::{\n     builtin_type::{IntBitness, Signedness},\n     lang_item::LangItemTarget,\n     type_ref::Mutability,\n     AssocContainerId, AssocItemId, FunctionId, HasModule, ImplId, Lookup, TraitId,\n };\n use hir_expand::name::Name;\n-use ra_db::CrateId;\n-use ra_prof::profile;\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use super::Substs;\n@@ -109,7 +108,7 @@ pub struct TraitImpls {\n \n impl TraitImpls {\n     pub(crate) fn trait_impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n-        let _p = profile(\"trait_impls_in_crate_query\");\n+        let _p = profile::span(\"trait_impls_in_crate_query\");\n         let mut impls = Self { map: FxHashMap::default() };\n \n         let crate_def_map = db.crate_def_map(krate);\n@@ -135,7 +134,7 @@ impl TraitImpls {\n     }\n \n     pub(crate) fn trait_impls_in_deps_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n-        let _p = profile(\"trait_impls_in_deps_query\");\n+        let _p = profile::span(\"trait_impls_in_deps_query\");\n         let crate_graph = db.crate_graph();\n         let mut res = Self { map: FxHashMap::default() };\n ", "previous_filename": "crates/ra_hir_ty/src/method_resolution.rs"}, {"sha": "0870874fce6cd0544a9e93794ba8e81e5dfd9365", "filename": "crates/hir_ty/src/op.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fop.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_ty/src/op.rs"}, {"sha": "37966b709848cc38c4bd08940f115fa25d48bcd2", "filename": "crates/hir_ty/src/primitive.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fprimitive.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_ty/src/primitive.rs"}, {"sha": "15b8435e9213427e492212e7c753b94da8808027", "filename": "crates/hir_ty/src/test_db.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftest_db.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,16 +5,16 @@ use std::{\n     sync::{Arc, Mutex},\n };\n \n+use base_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast};\n use hir_def::{db::DefDatabase, ModuleId};\n use hir_expand::db::AstDatabase;\n-use ra_db::{salsa, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase, Upcast};\n-use ra_syntax::TextRange;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use syntax::TextRange;\n use test_utils::extract_annotations;\n \n #[salsa::database(\n-    ra_db::SourceDatabaseExtStorage,\n-    ra_db::SourceDatabaseStorage,\n+    base_db::SourceDatabaseExtStorage,\n+    base_db::SourceDatabaseStorage,\n     hir_expand::db::AstDatabaseStorage,\n     hir_def::db::InternDatabaseStorage,\n     hir_def::db::DefDatabaseStorage,", "previous_filename": "crates/ra_hir_ty/src/test_db.rs"}, {"sha": "0445efc9e042a81f098bb29aae1c66ad74a5057a", "filename": "crates/hir_ty/src/tests.rs", "status": "renamed", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -8,9 +8,10 @@ mod method_resolution;\n mod macros;\n mod display_source_code;\n \n-use std::sync::Arc;\n+use std::{env, sync::Arc};\n \n-use expect::Expect;\n+use base_db::{fixture::WithFixture, FileRange, SourceDatabase, SourceDatabaseExt};\n+use expect_test::Expect;\n use hir_def::{\n     body::{BodySourceMap, SyntheticSyntax},\n     child_by_source::ChildBySource,\n@@ -21,33 +22,37 @@ use hir_def::{\n     AssocItemId, DefWithBodyId, LocalModuleId, Lookup, ModuleDefId,\n };\n use hir_expand::{db::AstDatabase, InFile};\n-use ra_db::{fixture::WithFixture, FileRange, SourceDatabase, SourceDatabaseExt};\n-use ra_syntax::{\n+use stdx::{format_to, RacyFlag};\n+use syntax::{\n     algo,\n     ast::{self, AstNode},\n     SyntaxNode,\n };\n-use stdx::format_to;\n+use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Registry};\n+use tracing_tree::HierarchicalLayer;\n \n use crate::{\n     db::HirDatabase, display::HirDisplay, infer::TypeMismatch, test_db::TestDB, InferenceResult, Ty,\n };\n \n // These tests compare the inference results for all expressions in a file\n // against snapshots of the expected results using expect. Use\n-// `env UPDATE_EXPECT=1 cargo test -p ra_hir_ty` to update the snapshots.\n+// `env UPDATE_EXPECT=1 cargo test -p hir_ty` to update the snapshots.\n+\n+fn setup_tracing() -> Option<tracing::subscriber::DefaultGuard> {\n+    static ENABLE: RacyFlag = RacyFlag::new();\n+    if !ENABLE.get(|| env::var(\"CHALK_DEBUG\").is_ok()) {\n+        return None;\n+    }\n \n-fn setup_tracing() -> tracing::subscriber::DefaultGuard {\n-    use tracing_subscriber::{layer::SubscriberExt, EnvFilter, Registry};\n-    use tracing_tree::HierarchicalLayer;\n     let filter = EnvFilter::from_env(\"CHALK_DEBUG\");\n     let layer = HierarchicalLayer::default()\n         .with_indent_lines(true)\n         .with_ansi(false)\n         .with_indent_amount(2)\n         .with_writer(std::io::stderr);\n     let subscriber = Registry::default().with(filter).with(layer);\n-    tracing::subscriber::set_default(subscriber)\n+    Some(tracing::subscriber::set_default(subscriber))\n }\n \n fn check_types(ra_fixture: &str) {", "previous_filename": "crates/ra_hir_ty/src/tests.rs"}, {"sha": "7bc6c79f3ff85c1e3eeab1349c6e83306ba6a4b3", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use expect::expect;\n+use expect_test::expect;\n use test_utils::mark;\n \n use super::{check_infer, check_infer_with_mismatches};", "previous_filename": "crates/ra_hir_ty/src/tests/coercion.rs"}, {"sha": "b502135d8e203af545ddfce284dff315d7c4fcb2", "filename": "crates/hir_ty/src/tests/display_source_code.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fdisplay_source_code.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_ty/src/tests/display_source_code.rs"}, {"sha": "597a195d0248a503257a054960c1c41f141c262b", "filename": "crates/hir_ty/src/tests/macros.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmacros.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use std::fs;\n \n-use expect::expect;\n+use expect_test::expect;\n use test_utils::project_dir;\n \n use super::{check_infer, check_types};\n@@ -543,7 +543,7 @@ fn bar() -> u32 {0}\n #[test]\n #[ignore]\n fn include_accidentally_quadratic() {\n-    let file = project_dir().join(\"crates/ra_syntax/test_data/accidentally_quadratic\");\n+    let file = project_dir().join(\"crates/syntax/test_data/accidentally_quadratic\");\n     let big_file = fs::read_to_string(file).unwrap();\n     let big_file = vec![big_file; 10].join(\"\\n\");\n ", "previous_filename": "crates/ra_hir_ty/src/tests/macros.rs"}, {"sha": "23b2601e643b5d19de1849d61404a56fbe1248da", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use expect::expect;\n+use expect_test::expect;\n \n use super::{check_infer, check_types};\n ", "previous_filename": "crates/ra_hir_ty/src/tests/method_resolution.rs"}, {"sha": "335c474df767e81487ad1496261fcb826a7542c3", "filename": "crates/hir_ty/src/tests/never_type.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fnever_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fnever_type.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use expect::expect;\n+use expect_test::expect;\n \n use super::{check_infer_with_mismatches, check_types};\n ", "previous_filename": "crates/ra_hir_ty/src/tests/never_type.rs"}, {"sha": "aeb191c79a77f826987652677dce6d6784bf3e9d", "filename": "crates/hir_ty/src/tests/patterns.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fpatterns.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use expect::expect;\n+use expect_test::expect;\n use test_utils::mark;\n \n use super::{check_infer, check_infer_with_mismatches};", "previous_filename": "crates/ra_hir_ty/src/tests/patterns.rs"}, {"sha": "94d86b0d1f232a292616d933697ddecacbedccc9", "filename": "crates/hir_ty/src/tests/regression.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fregression.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use expect::expect;\n+use expect_test::expect;\n use test_utils::mark;\n \n use super::{check_infer, check_types};", "previous_filename": "crates/ra_hir_ty/src/tests/regression.rs"}, {"sha": "48db23a341609cbd1bed29ea4f4c35459e871138", "filename": "crates/hir_ty/src/tests/simple.rs", "status": "renamed", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fsimple.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use expect::expect;\n+use expect_test::expect;\n \n use super::{check_infer, check_types};\n \n@@ -334,16 +334,44 @@ fn infer_union() {\n             bar: f32,\n         }\n \n+        fn test() {\n+            let u = MyUnion { foo: 0 };\n+            unsafe { baz(u); }\n+            let u = MyUnion { bar: 0.0 };\n+            unsafe { baz(u); }\n+        }\n+\n         unsafe fn baz(u: MyUnion) {\n             let inner = u.foo;\n+            let inner = u.bar;\n         }\n         \"#,\n         expect![[r#\"\n-            61..62 'u': MyUnion\n-            73..99 '{     ...foo; }': ()\n-            83..88 'inner': u32\n-            91..92 'u': MyUnion\n-            91..96 'u.foo': u32\n+            57..172 '{     ...); } }': ()\n+            67..68 'u': MyUnion\n+            71..89 'MyUnio...o: 0 }': MyUnion\n+            86..87 '0': u32\n+            95..113 'unsafe...(u); }': ()\n+            102..113 '{ baz(u); }': ()\n+            104..107 'baz': fn baz(MyUnion)\n+            104..110 'baz(u)': ()\n+            108..109 'u': MyUnion\n+            122..123 'u': MyUnion\n+            126..146 'MyUnio... 0.0 }': MyUnion\n+            141..144 '0.0': f32\n+            152..170 'unsafe...(u); }': ()\n+            159..170 '{ baz(u); }': ()\n+            161..164 'baz': fn baz(MyUnion)\n+            161..167 'baz(u)': ()\n+            165..166 'u': MyUnion\n+            188..189 'u': MyUnion\n+            200..249 '{     ...bar; }': ()\n+            210..215 'inner': u32\n+            218..219 'u': MyUnion\n+            218..223 'u.foo': u32\n+            233..238 'inner': f32\n+            241..242 'u': MyUnion\n+            241..246 'u.bar': f32\n         \"#]],\n     );\n }\n@@ -1748,8 +1776,8 @@ fn main() {\n     );\n }\n \n-// This test is actually testing the shadowing behavior within ra_hir_def. It\n-// lives here because the testing infrastructure in ra_hir_def isn't currently\n+// This test is actually testing the shadowing behavior within hir_def. It\n+// lives here because the testing infrastructure in hir_def isn't currently\n // capable of asserting the necessary conditions.\n #[test]\n fn should_be_shadowing_imports() {", "previous_filename": "crates/ra_hir_ty/src/tests/simple.rs"}, {"sha": "1f1056962b7c8f99adabd59a34516edb3a3f61d5", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use expect::expect;\n+use expect_test::expect;\n use test_utils::mark;\n \n use super::{check_infer, check_infer_with_mismatches, check_types};", "previous_filename": "crates/ra_hir_ty/src/tests/traits.rs"}, {"sha": "14cd3a2b446745baa2d6dc87b0a547ea725da678", "filename": "crates/hir_ty/src/traits.rs", "status": "renamed", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,11 +1,10 @@\n //! Trait solving using Chalk.\n use std::sync::Arc;\n \n+use base_db::CrateId;\n use chalk_ir::cast::Cast;\n-use chalk_solve::Solver;\n+use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n use hir_def::{lang_item::LangItemTarget, TraitId};\n-use ra_db::CrateId;\n-use ra_prof::profile;\n \n use crate::{db::HirDatabase, DebruijnIndex, Substs};\n \n@@ -125,7 +124,7 @@ pub(crate) fn trait_solve_query(\n     krate: CrateId,\n     goal: Canonical<InEnvironment<Obligation>>,\n ) -> Option<Solution> {\n-    let _p = profile(\"trait_solve_query\").detail(|| match &goal.value.value {\n+    let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.value {\n         Obligation::Trait(it) => db.trait_data(it.trait_).name.to_string(),\n         Obligation::Projection(_) => \"projection\".to_string(),\n     });\n@@ -167,23 +166,36 @@ fn solve(\n         }\n         remaining > 0\n     };\n+\n     let mut solve = || {\n-        let solution = solver.solve_limited(&context, goal, should_continue);\n-        log::debug!(\"solve({:?}) => {:?}\", goal, solution);\n-        solution\n+        if is_chalk_print() {\n+            let logging_db = LoggingRustIrDatabase::new(context);\n+            let solution = solver.solve_limited(&logging_db, goal, &should_continue);\n+            log::debug!(\"chalk program:\\n{}\", logging_db);\n+            solution\n+        } else {\n+            solver.solve_limited(&context, goal, &should_continue)\n+        }\n     };\n+\n     // don't set the TLS for Chalk unless Chalk debugging is active, to make\n     // extra sure we only use it for debugging\n     let solution =\n         if is_chalk_debug() { chalk::tls::set_current_program(db, solve) } else { solve() };\n \n+    log::debug!(\"solve({:?}) => {:?}\", goal, solution);\n+\n     solution\n }\n \n fn is_chalk_debug() -> bool {\n     std::env::var(\"CHALK_DEBUG\").is_ok()\n }\n \n+fn is_chalk_print() -> bool {\n+    std::env::var(\"CHALK_PRINT\").is_ok()\n+}\n+\n fn solution_from_chalk(\n     db: &dyn HirDatabase,\n     solution: chalk_solve::Solution<Interner>,", "previous_filename": "crates/ra_hir_ty/src/traits.rs"}, {"sha": "17c83b6a46e45ec14e2f74aa33a518e4ac20c161", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "renamed", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -6,11 +6,11 @@ use log::debug;\n use chalk_ir::{fold::shift::Shift, CanonicalVarKinds, GenericArg, TypeName};\n use chalk_solve::rust_ir::{self, OpaqueTyDatumBound, WellKnownTrait};\n \n+use base_db::{salsa::InternKey, CrateId};\n use hir_def::{\n     lang_item::{lang_attr, LangItemTarget},\n     AssocContainerId, AssocItemId, HasModule, Lookup, TypeAliasId,\n };\n-use ra_db::{salsa::InternKey, CrateId};\n \n use super::ChalkContext;\n use crate::{\n@@ -240,20 +240,23 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         Substs::empty().to_chalk(self.db)\n     }\n \n-    fn trait_name(&self, _trait_id: chalk_ir::TraitId<Interner>) -> String {\n-        unimplemented!()\n+    fn trait_name(&self, trait_id: chalk_ir::TraitId<Interner>) -> String {\n+        let id = from_chalk(self.db, trait_id);\n+        self.db.trait_data(id).name.to_string()\n     }\n-    fn adt_name(&self, _struct_id: chalk_ir::AdtId<Interner>) -> String {\n-        unimplemented!()\n+    // FIXME: lookup names\n+    fn adt_name(&self, struct_id: chalk_ir::AdtId<Interner>) -> String {\n+        let datum = self.db.struct_datum(self.krate, struct_id);\n+        format!(\"{:?}\", datum.name(&Interner))\n     }\n-    fn assoc_type_name(&self, _assoc_ty_id: chalk_ir::AssocTypeId<Interner>) -> String {\n-        unimplemented!()\n+    fn assoc_type_name(&self, assoc_ty_id: chalk_ir::AssocTypeId<Interner>) -> String {\n+        format!(\"Assoc_{}\", assoc_ty_id.0)\n     }\n-    fn opaque_type_name(&self, _opaque_ty_id: chalk_ir::OpaqueTyId<Interner>) -> String {\n-        unimplemented!()\n+    fn opaque_type_name(&self, opaque_ty_id: chalk_ir::OpaqueTyId<Interner>) -> String {\n+        format!(\"Opaque_{}\", opaque_ty_id.0)\n     }\n-    fn fn_def_name(&self, _fn_def_id: chalk_ir::FnDefId<Interner>) -> String {\n-        unimplemented!()\n+    fn fn_def_name(&self, fn_def_id: chalk_ir::FnDefId<Interner>) -> String {\n+        format!(\"fn_{}\", fn_def_id.0)\n     }\n }\n \n@@ -410,7 +413,7 @@ pub(crate) fn impl_datum_query(\n     krate: CrateId,\n     impl_id: ImplId,\n ) -> Arc<ImplDatum> {\n-    let _p = ra_prof::profile(\"impl_datum\");\n+    let _p = profile::span(\"impl_datum\");\n     debug!(\"impl_datum {:?}\", impl_id);\n     let impl_: hir_def::ImplId = from_chalk(db, impl_id);\n     impl_def_datum(db, krate, impl_id, impl_)", "previous_filename": "crates/ra_hir_ty/src/traits/chalk.rs"}, {"sha": "fc0f9c20198c751efac1a88967011fe60cfa9446", "filename": "crates/hir_ty/src/traits/chalk/interner.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Finterner.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,9 +2,9 @@\n //! representation of the various objects Chalk deals with (types, goals etc.).\n \n use super::tls;\n+use base_db::salsa::InternId;\n use chalk_ir::{GenericArg, Goal, GoalData};\n use hir_def::TypeAliasId;\n-use ra_db::salsa::InternId;\n use std::{fmt, sync::Arc};\n \n #[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]", "previous_filename": "crates/ra_hir_ty/src/traits/chalk/interner.rs"}, {"sha": "fe62f3fa7cd955e2c19a41f45923c5a363c4296f", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -9,8 +9,8 @@ use chalk_ir::{\n };\n use chalk_solve::rust_ir;\n \n+use base_db::salsa::InternKey;\n use hir_def::{type_ref::Mutability, AssocContainerId, GenericDefId, Lookup, TypeAliasId};\n-use ra_db::salsa::InternKey;\n \n use crate::{\n     db::HirDatabase,", "previous_filename": "crates/ra_hir_ty/src/traits/chalk/mapping.rs"}, {"sha": "db915625c2b3e1ebb5670672682f72b671eeea36", "filename": "crates/hir_ty/src/traits/chalk/tls.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Ftls.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_ty/src/traits/chalk/tls.rs"}, {"sha": "e3e2442680e8ec7946c19501c70e480fe40c482b", "filename": "crates/hir_ty/src/utils.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_hir_ty/src/utils.rs"}, {"sha": "9ecf43e5a96f86fae0c95a82c0562357a83e1d91", "filename": "crates/ide/Cargo.toml", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -0,0 +1,37 @@\n+[package]\n+name = \"ide\"\n+version = \"0.0.0\"\n+license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+either = \"1.5.3\"\n+indexmap = \"1.3.2\"\n+itertools = \"0.9.0\"\n+log = \"0.4.8\"\n+rustc-hash = \"1.1.0\"\n+oorandom = \"11.1.2\"\n+pulldown-cmark-to-cmark = \"5.0.0\"\n+pulldown-cmark = {version = \"0.7.2\", default-features = false}\n+\n+stdx = { path = \"../stdx\" }\n+syntax = { path = \"../syntax\" }\n+text_edit = { path = \"../text_edit\" }\n+base_db = { path = \"../base_db\" }\n+ide_db = { path = \"../ide_db\" }\n+cfg = { path = \"../cfg\" }\n+profile = { path = \"../profile\" }\n+test_utils = { path = \"../test_utils\" }\n+assists = { path = \"../assists\" }\n+ssr = { path = \"../ssr\" }\n+\n+# ide should depend only on the top-level `hir` package. if you need\n+# something from some `hir_xxx` subpackage, reexport the API via `hir`.\n+hir = { path = \"../hir\" }\n+\n+[dev-dependencies]\n+expect-test = \"0.1\""}, {"sha": "58e26b94ca7c4b45afb3dd24de3f367db8cacd34", "filename": "crates/ide/src/call_hierarchy.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,8 +3,8 @@\n use indexmap::IndexMap;\n \n use hir::Semantics;\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{ast, match_ast, AstNode, TextRange};\n+use ide_db::RootDatabase;\n+use syntax::{ast, match_ast, AstNode, TextRange};\n \n use crate::{\n     call_info::FnCallNode, display::ToNav, goto_definition, references, FilePosition,\n@@ -137,7 +137,7 @@ impl CallLocations {\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::FilePosition;\n+    use base_db::FilePosition;\n \n     use crate::mock_analysis::analysis_and_position;\n ", "previous_filename": "crates/ra_ide/src/call_hierarchy.rs"}, {"sha": "7e83a2381974c9ab3b29230007607f8cb8c5270e", "filename": "crates/ide/src/call_info.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_info.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,12 +1,12 @@\n //! FIXME: write short doc here\n use either::Either;\n use hir::{Docs, HirDisplay, Semantics, Type};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n+use ide_db::RootDatabase;\n+use stdx::format_to;\n+use syntax::{\n     ast::{self, ArgListOwner},\n     match_ast, AstNode, SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n-use stdx::format_to;\n use test_utils::mark;\n \n use crate::FilePosition;\n@@ -229,7 +229,7 @@ impl FnCallNode {\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n     use test_utils::mark;\n \n     use crate::mock_analysis::analysis_and_position;", "previous_filename": "crates/ra_ide/src/call_info.rs"}, {"sha": "25e580d809841b2bf91257132322cbafb117d292", "filename": "crates/ide/src/completion.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,6 +3,7 @@ mod completion_item;\n mod completion_context;\n mod presentation;\n mod patterns;\n+mod generated_features;\n #[cfg(test)]\n mod test_utils;\n \n@@ -19,7 +20,7 @@ mod complete_postfix;\n mod complete_macro_in_item_position;\n mod complete_trait_impl;\n \n-use ra_ide_db::RootDatabase;\n+use ide_db::RootDatabase;\n \n use crate::{\n     completion::{", "previous_filename": "crates/ra_ide/src/completion.rs"}, {"sha": "0abfaebcbc669f4b887d9f33560c8a6f3d2567f9", "filename": "crates/ide/src/completion/complete_attribute.rs", "status": "renamed", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_attribute.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,12 +3,13 @@\n //! This module uses a bit of static metadata to provide completions\n //! for built-in attributes.\n \n-use ra_syntax::{ast, AstNode, SyntaxKind};\n use rustc_hash::FxHashSet;\n+use syntax::{ast, AstNode, SyntaxKind};\n \n use crate::completion::{\n     completion_context::CompletionContext,\n     completion_item::{CompletionItem, CompletionItemKind, CompletionKind, Completions},\n+    generated_features::FEATURES,\n };\n \n pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n@@ -17,12 +18,15 @@ pub(super) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext)\n         (Some(path), Some(token_tree)) if path.to_string() == \"derive\" => {\n             complete_derive(acc, ctx, token_tree)\n         }\n+        (Some(path), Some(token_tree)) if path.to_string() == \"feature\" => {\n+            complete_lint(acc, ctx, token_tree, FEATURES)\n+        }\n         (Some(path), Some(token_tree))\n             if [\"allow\", \"warn\", \"deny\", \"forbid\"]\n                 .iter()\n                 .any(|lint_level| lint_level == &path.to_string()) =>\n         {\n-            complete_lint(acc, ctx, token_tree)\n+            complete_lint(acc, ctx, token_tree, DEFAULT_LINT_COMPLETIONS)\n         }\n         (_, Some(_token_tree)) => {}\n         _ => complete_attribute_start(acc, ctx, attribute),\n@@ -162,9 +166,14 @@ fn complete_derive(acc: &mut Completions, ctx: &CompletionContext, derive_input:\n     }\n }\n \n-fn complete_lint(acc: &mut Completions, ctx: &CompletionContext, derive_input: ast::TokenTree) {\n+fn complete_lint(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    derive_input: ast::TokenTree,\n+    lints_completions: &[LintCompletion],\n+) {\n     if let Ok(existing_lints) = parse_comma_sep_input(derive_input) {\n-        for lint_completion in DEFAULT_LINT_COMPLETIONS\n+        for lint_completion in lints_completions\n             .into_iter()\n             .filter(|completion| !existing_lints.contains(completion.label))\n         {\n@@ -248,9 +257,9 @@ const DEFAULT_DERIVE_COMPLETIONS: &[DeriveCompletion] = &[\n     DeriveCompletion { label: \"Ord\", dependencies: &[\"PartialOrd\", \"Eq\", \"PartialEq\"] },\n ];\n \n-struct LintCompletion {\n-    label: &'static str,\n-    description: &'static str,\n+pub(super) struct LintCompletion {\n+    pub(super) label: &'static str,\n+    pub(super) description: &'static str,\n }\n \n #[rustfmt::skip]\n@@ -374,7 +383,7 @@ const DEFAULT_LINT_COMPLETIONS: &[LintCompletion] = &[\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::completion::{test_utils::completion_list, CompletionKind};\n ", "previous_filename": "crates/ra_ide/src/completion/complete_attribute.rs"}, {"sha": "0b9f1798acafb6624dde9eee4348dc02edafe090", "filename": "crates/ide/src/completion/complete_dot.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -48,7 +48,7 @@ fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &T\n         let mut seen_methods = FxHashSet::default();\n         let traits_in_scope = ctx.scope.traits_in_scope();\n         receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n-            if func.has_self_param(ctx.db)\n+            if func.self_param(ctx.db).is_some()\n                 && ctx.scope.module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n                 && seen_methods.insert(func.name(ctx.db))\n             {\n@@ -61,7 +61,7 @@ fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &T\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n     use test_utils::mark;\n \n     use crate::completion::{test_utils::completion_list, CompletionKind};", "previous_filename": "crates/ra_ide/src/completion/complete_dot.rs"}, {"sha": "9efe254618eee4e168bd85f392f51fba2d629a86", "filename": "crates/ide/src/completion/complete_fn_param.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_fn_param.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,10 +1,10 @@\n //! See `complete_fn_param`.\n \n-use ra_syntax::{\n+use rustc_hash::FxHashMap;\n+use syntax::{\n     ast::{self, ModuleItemOwner},\n     match_ast, AstNode,\n };\n-use rustc_hash::FxHashMap;\n \n use crate::completion::{CompletionContext, CompletionItem, CompletionKind, Completions};\n \n@@ -66,7 +66,7 @@ pub(super) fn complete_fn_param(acc: &mut Completions, ctx: &CompletionContext)\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::completion::{test_utils::completion_list, CompletionKind};\n ", "previous_filename": "crates/ra_ide/src/completion/complete_fn_param.rs"}, {"sha": "95e4ff1ac6aa01cac94f1d3432286fd2fda894b2", "filename": "crates/ide/src/completion/complete_keyword.rs", "status": "renamed", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::{ast, SyntaxKind};\n+use syntax::{ast, SyntaxKind};\n use test_utils::mark;\n \n use crate::completion::{\n@@ -10,30 +10,21 @@ use crate::completion::{\n pub(super) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n     // complete keyword \"crate\" in use stmt\n     let source_range = ctx.source_range();\n-    match (ctx.use_item_syntax.as_ref(), ctx.path_prefix.as_ref()) {\n-        (Some(_), None) => {\n+\n+    if ctx.use_item_syntax.is_some() {\n+        if ctx.path_qual.is_none() {\n             CompletionItem::new(CompletionKind::Keyword, source_range, \"crate::\")\n                 .kind(CompletionItemKind::Keyword)\n                 .insert_text(\"crate::\")\n                 .add_to(acc);\n-            CompletionItem::new(CompletionKind::Keyword, source_range, \"self\")\n-                .kind(CompletionItemKind::Keyword)\n-                .add_to(acc);\n-            CompletionItem::new(CompletionKind::Keyword, source_range, \"super::\")\n-                .kind(CompletionItemKind::Keyword)\n-                .insert_text(\"super::\")\n-                .add_to(acc);\n-        }\n-        (Some(_), Some(_)) => {\n-            CompletionItem::new(CompletionKind::Keyword, source_range, \"self\")\n-                .kind(CompletionItemKind::Keyword)\n-                .add_to(acc);\n-            CompletionItem::new(CompletionKind::Keyword, source_range, \"super::\")\n-                .kind(CompletionItemKind::Keyword)\n-                .insert_text(\"super::\")\n-                .add_to(acc);\n         }\n-        _ => {}\n+        CompletionItem::new(CompletionKind::Keyword, source_range, \"self\")\n+            .kind(CompletionItemKind::Keyword)\n+            .add_to(acc);\n+        CompletionItem::new(CompletionKind::Keyword, source_range, \"super::\")\n+            .kind(CompletionItemKind::Keyword)\n+            .insert_text(\"super::\")\n+            .add_to(acc);\n     }\n \n     // Suggest .await syntax for types that implement Future trait\n@@ -183,7 +174,7 @@ fn complete_return(\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::completion::{\n         test_utils::{check_edit, completion_list},", "previous_filename": "crates/ra_ide/src/completion/complete_keyword.rs"}, {"sha": "fc8625d8e0a027a787c54c3e578bef6810035bfc", "filename": "crates/ide/src/completion/complete_macro_in_item_position.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_macro_in_item_position.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -15,7 +15,7 @@ pub(super) fn complete_macro_in_item_position(acc: &mut Completions, ctx: &Compl\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::completion::{test_utils::completion_list, CompletionKind};\n ", "previous_filename": "crates/ra_ide/src/completion/complete_macro_in_item_position.rs"}, {"sha": "5a13574d45b0ab180a555751cc4602eb665b836d", "filename": "crates/ide/src/completion/complete_pattern.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_pattern.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -33,7 +33,7 @@ pub(super) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::completion::{test_utils::completion_list, CompletionKind};\n ", "previous_filename": "crates/ra_ide/src/completion/complete_pattern.rs"}, {"sha": "84c4e129d27145535715fddf6f460bdcb08a2e83", "filename": "crates/ide/src/completion/complete_postfix.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,10 +1,10 @@\n //! FIXME: write short doc here\n-use ra_assists::utils::TryEnum;\n-use ra_syntax::{\n+use assists::utils::TryEnum;\n+use syntax::{\n     ast::{self, AstNode},\n     TextRange, TextSize,\n };\n-use ra_text_edit::TextEdit;\n+use text_edit::TextEdit;\n \n use crate::{\n     completion::{\n@@ -238,7 +238,7 @@ fn postfix_snippet(\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::completion::{\n         test_utils::{check_edit, completion_list},", "previous_filename": "crates/ra_ide/src/completion/complete_postfix.rs"}, {"sha": "accb09f7e8c874cbc646a0ddde2a5ccc51f33c60", "filename": "crates/ide/src/completion/complete_qualified_path.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,14 +1,14 @@\n //! Completion of paths, i.e. `some::prefix::<|>`.\n \n use hir::{Adt, HasVisibility, PathResolution, ScopeDef};\n-use ra_syntax::AstNode;\n use rustc_hash::FxHashSet;\n+use syntax::AstNode;\n use test_utils::mark;\n \n use crate::completion::{CompletionContext, Completions};\n \n pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionContext) {\n-    let path = match &ctx.path_prefix {\n+    let path = match &ctx.path_qual {\n         Some(path) => path.clone(),\n         None => return,\n     };\n@@ -19,7 +19,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n     let context_module = ctx.scope.module();\n \n-    let resolution = match ctx.scope.resolve_hir_path_qualifier(&path) {\n+    let resolution = match ctx.sema.resolve_path(&path) {\n         Some(res) => res,\n         None => return,\n     };\n@@ -146,7 +146,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n     use test_utils::mark;\n \n     use crate::completion::{", "previous_filename": "crates/ra_ide/src/completion/complete_qualified_path.rs"}, {"sha": "ceb8d16c10017d10ed3f96e9b40bf2d130457c77", "filename": "crates/ide/src/completion/complete_record.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_record.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_record.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -18,7 +18,7 @@ pub(super) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::completion::{test_utils::completion_list, CompletionKind};\n ", "previous_filename": "crates/ra_ide/src/completion/complete_record.rs"}, {"sha": "c3b03b199e7902e54939c9a6375e25971f78b4ff", "filename": "crates/ide/src/completion/complete_snippet.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_snippet.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -36,7 +36,7 @@ pub(super) fn complete_item_snippet(acc: &mut Completions, ctx: &CompletionConte\n     snippet(\n         ctx,\n         cap,\n-        \"Test module\",\n+        \"tmod (Test module)\",\n         \"\\\n #[cfg(test)]\n mod tests {\n@@ -54,7 +54,7 @@ mod tests {\n     snippet(\n         ctx,\n         cap,\n-        \"Test function\",\n+        \"tfn (Test function)\",\n         \"\\\n #[test]\n fn ${1:feature}() {\n@@ -70,7 +70,7 @@ fn ${1:feature}() {\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::completion::{test_utils::completion_list, CompletionKind};\n \n@@ -106,10 +106,10 @@ mod tests {\n }\n \"#,\n             expect![[r#\"\n-                sn Test function\n-                sn Test module\n                 sn macro_rules\n                 sn pub(crate)\n+                sn tfn (Test function)\n+                sn tmod (Test module)\n             \"#]],\n         )\n     }", "previous_filename": "crates/ra_ide/src/completion/complete_snippet.rs"}, {"sha": "1a2b1e8a57e8b6c287d9df9d141a7424c73ed34a", "filename": "crates/ide/src/completion/complete_trait_impl.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_trait_impl.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -31,13 +31,13 @@\n //! }\n //! ```\n \n+use assists::utils::get_missing_assoc_items;\n use hir::{self, Docs, HasSource};\n-use ra_assists::utils::get_missing_assoc_items;\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, edit, Impl},\n     AstNode, SyntaxKind, SyntaxNode, TextRange, T,\n };\n-use ra_text_edit::TextEdit;\n+use text_edit::TextEdit;\n \n use crate::{\n     completion::{\n@@ -126,17 +126,17 @@ fn add_function_impl(\n ) {\n     let fn_name = func.name(ctx.db).to_string();\n \n-    let label = if !func.params(ctx.db).is_empty() {\n-        format!(\"fn {}(..)\", fn_name)\n-    } else {\n+    let label = if func.params(ctx.db).is_empty() {\n         format!(\"fn {}()\", fn_name)\n+    } else {\n+        format!(\"fn {}(..)\", fn_name)\n     };\n \n     let builder = CompletionItem::new(CompletionKind::Magic, ctx.source_range(), label)\n         .lookup_by(fn_name)\n         .set_documentation(func.docs(ctx.db));\n \n-    let completion_kind = if func.has_self_param(ctx.db) {\n+    let completion_kind = if func.self_param(ctx.db).is_some() {\n         CompletionItemKind::Method\n     } else {\n         CompletionItemKind::Function\n@@ -225,7 +225,7 @@ fn make_const_compl_syntax(const_: &ast::Const) -> String {\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::completion::{\n         test_utils::{check_edit, completion_list},", "previous_filename": "crates/ra_ide/src/completion/complete_trait_impl.rs"}, {"sha": "1f1b682a78c98a7ccba16447d0571441eeda82e7", "filename": "crates/ide/src/completion/complete_unqualified_path.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcomplete_unqualified_path.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,7 @@\n //! Completion of names from the current scope, e.g. locals and imported items.\n \n use hir::{Adt, ModuleDef, ScopeDef, Type};\n-use ra_syntax::AstNode;\n+use syntax::AstNode;\n use test_utils::mark;\n \n use crate::completion::{CompletionContext, Completions};\n@@ -64,7 +64,7 @@ fn complete_enum_variants(acc: &mut Completions, ctx: &CompletionContext, ty: &T\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n     use test_utils::mark;\n \n     use crate::completion::{", "previous_filename": "crates/ra_ide/src/completion/complete_unqualified_path.rs"}, {"sha": "71b49ace8bfb0e38a746ff34866d9f3a3cfb46dc", "filename": "crates/ide/src/completion/completion_config.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_config.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_config.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_config.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_ide/src/completion/completion_config.rs"}, {"sha": "5adac7ebcc1e86f6c0ffa10acdf84b86ac2fa120", "filename": "crates/ide/src/completion/completion_context.rs", "status": "renamed", "additions": 79, "deletions": 58, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,23 +1,29 @@\n //! FIXME: write short doc here\n \n+use base_db::SourceDatabase;\n use hir::{Semantics, SemanticsScope, Type};\n-use ra_db::SourceDatabase;\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n+use ide_db::RootDatabase;\n+use syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n     ast, match_ast, AstNode, NodeOrToken,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextSize,\n };\n-use ra_text_edit::Indel;\n+use test_utils::mark;\n+use text_edit::Indel;\n \n-use super::patterns::{\n-    has_bind_pat_parent, has_block_expr_parent, has_impl_as_prev_sibling, has_impl_parent,\n-    has_item_list_or_source_file_parent, has_ref_parent, has_trait_as_prev_sibling,\n-    has_trait_parent, if_is_prev, is_in_loop_body, is_match_arm, unsafe_is_prev,\n+use crate::{\n+    call_info::ActiveParameter,\n+    completion::{\n+        patterns::{\n+            has_bind_pat_parent, has_block_expr_parent, has_impl_as_prev_sibling, has_impl_parent,\n+            has_item_list_or_source_file_parent, has_ref_parent, has_trait_as_prev_sibling,\n+            has_trait_parent, if_is_prev, is_in_loop_body, is_match_arm, unsafe_is_prev,\n+        },\n+        CompletionConfig,\n+    },\n+    FilePosition,\n };\n-use crate::{call_info::ActiveParameter, completion::CompletionConfig, FilePosition};\n-use test_utils::mark;\n \n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n@@ -27,7 +33,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) scope: SemanticsScope<'a>,\n     pub(super) db: &'a RootDatabase,\n     pub(super) config: &'a CompletionConfig,\n-    pub(super) offset: TextSize,\n+    pub(super) position: FilePosition,\n     /// The token before the cursor, in the original file.\n     pub(super) original_token: SyntaxToken,\n     /// The token before the cursor, in the macro-expanded file.\n@@ -50,7 +56,7 @@ pub(crate) struct CompletionContext<'a> {\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n     /// If not a trivial path, the prefix (qualifier).\n-    pub(super) path_prefix: Option<hir::Path>,\n+    pub(super) path_qual: Option<ast::Path>,\n     pub(super) after_if: bool,\n     /// `true` if we are a statement or a last expr in the block.\n     pub(super) can_be_stmt: bool,\n@@ -117,7 +123,7 @@ impl<'a> CompletionContext<'a> {\n             config,\n             original_token,\n             token,\n-            offset: position.offset,\n+            position,\n             krate,\n             expected_type: None,\n             name_ref_syntax: None,\n@@ -131,7 +137,7 @@ impl<'a> CompletionContext<'a> {\n             is_param: false,\n             is_pat_binding_or_const: false,\n             is_trivial_path: false,\n-            path_prefix: None,\n+            path_qual: None,\n             after_if: false,\n             can_be_stmt: false,\n             is_expr: false,\n@@ -179,7 +185,7 @@ impl<'a> CompletionContext<'a> {\n             };\n             if let (Some(actual_expansion), Some(hypothetical_expansion)) = (\n                 ctx.sema.expand(&actual_macro_call),\n-                ctx.sema.expand_hypothetical(\n+                ctx.sema.speculative_expand(\n                     &actual_macro_call,\n                     &hypothetical_args,\n                     fake_ident_token,\n@@ -209,7 +215,7 @@ impl<'a> CompletionContext<'a> {\n             mark::hit!(completes_if_prefix_is_keyword);\n             self.original_token.text_range()\n         } else {\n-            TextRange::empty(self.offset)\n+            TextRange::empty(self.position.offset)\n         }\n     }\n \n@@ -265,7 +271,7 @@ impl<'a> CompletionContext<'a> {\n                 return;\n             }\n             // FIXME: remove this (V) duplication and make the check more precise\n-            if name_ref.syntax().ancestors().find_map(ast::RecordFieldPatList::cast).is_some() {\n+            if name_ref.syntax().ancestors().find_map(ast::RecordPatFieldList::cast).is_some() {\n                 self.record_pat_syntax =\n                     self.sema.find_node_at_offset_with_macros(&original_file, offset);\n             }\n@@ -275,15 +281,15 @@ impl<'a> CompletionContext<'a> {\n         // Otherwise, see if this is a declaration. We can use heuristics to\n         // suggest declaration names, see `CompletionKind::Magic`.\n         if let Some(name) = find_node_at_offset::<ast::Name>(&file_with_fake_ident, offset) {\n-            if let Some(bind_pat) = name.syntax().ancestors().find_map(ast::BindPat::cast) {\n+            if let Some(bind_pat) = name.syntax().ancestors().find_map(ast::IdentPat::cast) {\n                 self.is_pat_binding_or_const = true;\n                 if bind_pat.at_token().is_some()\n                     || bind_pat.ref_token().is_some()\n                     || bind_pat.mut_token().is_some()\n                 {\n                     self.is_pat_binding_or_const = false;\n                 }\n-                if bind_pat.syntax().parent().and_then(ast::RecordFieldPatList::cast).is_some() {\n+                if bind_pat.syntax().parent().and_then(ast::RecordPatFieldList::cast).is_some() {\n                     self.is_pat_binding_or_const = false;\n                 }\n                 if let Some(let_stmt) = bind_pat.syntax().ancestors().find_map(ast::LetStmt::cast) {\n@@ -300,7 +306,7 @@ impl<'a> CompletionContext<'a> {\n                 return;\n             }\n             // FIXME: remove this (^) duplication and make the check more precise\n-            if name.syntax().ancestors().find_map(ast::RecordFieldPatList::cast).is_some() {\n+            if name.syntax().ancestors().find_map(ast::RecordPatFieldList::cast).is_some() {\n                 self.record_pat_syntax =\n                     self.sema.find_node_at_offset_with_macros(&original_file, offset);\n             }\n@@ -377,50 +383,56 @@ impl<'a> CompletionContext<'a> {\n                 path.syntax().parent().and_then(ast::TupleStructPat::cast).is_some();\n \n             self.is_path_type = path.syntax().parent().and_then(ast::PathType::cast).is_some();\n-            self.has_type_args = segment.type_arg_list().is_some();\n+            self.has_type_args = segment.generic_arg_list().is_some();\n+\n+            if let Some(path) = path_or_use_tree_qualifier(&path) {\n+                self.path_qual = path\n+                    .segment()\n+                    .and_then(|it| {\n+                        find_node_with_range::<ast::PathSegment>(\n+                            original_file,\n+                            it.syntax().text_range(),\n+                        )\n+                    })\n+                    .map(|it| it.parent_path());\n+                return;\n+            }\n \n-            #[allow(deprecated)]\n-            if let Some(path) = hir::Path::from_ast(path.clone()) {\n-                if let Some(path_prefix) = path.qualifier() {\n-                    self.path_prefix = Some(path_prefix);\n+            if let Some(segment) = path.segment() {\n+                if segment.coloncolon_token().is_some() {\n                     return;\n                 }\n             }\n \n-            if path.qualifier().is_none() {\n-                self.is_trivial_path = true;\n-\n-                // Find either enclosing expr statement (thing with `;`) or a\n-                // block. If block, check that we are the last expr.\n-                self.can_be_stmt = name_ref\n-                    .syntax()\n-                    .ancestors()\n-                    .find_map(|node| {\n-                        if let Some(stmt) = ast::ExprStmt::cast(node.clone()) {\n-                            return Some(\n-                                stmt.syntax().text_range() == name_ref.syntax().text_range(),\n-                            );\n-                        }\n-                        if let Some(block) = ast::BlockExpr::cast(node) {\n-                            return Some(\n-                                block.expr().map(|e| e.syntax().text_range())\n-                                    == Some(name_ref.syntax().text_range()),\n-                            );\n-                        }\n-                        None\n-                    })\n-                    .unwrap_or(false);\n-                self.is_expr = path.syntax().parent().and_then(ast::PathExpr::cast).is_some();\n+            self.is_trivial_path = true;\n+\n+            // Find either enclosing expr statement (thing with `;`) or a\n+            // block. If block, check that we are the last expr.\n+            self.can_be_stmt = name_ref\n+                .syntax()\n+                .ancestors()\n+                .find_map(|node| {\n+                    if let Some(stmt) = ast::ExprStmt::cast(node.clone()) {\n+                        return Some(stmt.syntax().text_range() == name_ref.syntax().text_range());\n+                    }\n+                    if let Some(block) = ast::BlockExpr::cast(node) {\n+                        return Some(\n+                            block.expr().map(|e| e.syntax().text_range())\n+                                == Some(name_ref.syntax().text_range()),\n+                        );\n+                    }\n+                    None\n+                })\n+                .unwrap_or(false);\n+            self.is_expr = path.syntax().parent().and_then(ast::PathExpr::cast).is_some();\n \n-                if let Some(off) = name_ref.syntax().text_range().start().checked_sub(2.into()) {\n-                    if let Some(if_expr) =\n-                        self.sema.find_node_at_offset_with_macros::<ast::IfExpr>(original_file, off)\n+            if let Some(off) = name_ref.syntax().text_range().start().checked_sub(2.into()) {\n+                if let Some(if_expr) =\n+                    self.sema.find_node_at_offset_with_macros::<ast::IfExpr>(original_file, off)\n+                {\n+                    if if_expr.syntax().text_range().end() < name_ref.syntax().text_range().start()\n                     {\n-                        if if_expr.syntax().text_range().end()\n-                            < name_ref.syntax().text_range().start()\n-                        {\n-                            self.after_if = true;\n-                        }\n+                        self.after_if = true;\n                     }\n                 }\n             }\n@@ -445,7 +457,7 @@ impl<'a> CompletionContext<'a> {\n         if let Some(method_call_expr) = ast::MethodCallExpr::cast(parent) {\n             // As above\n             self.dot_receiver = method_call_expr\n-                .expr()\n+                .receiver()\n                 .map(|e| e.syntax().text_range())\n                 .and_then(|r| find_node_with_range(original_file, r));\n             self.is_call = true;\n@@ -463,3 +475,12 @@ fn is_node<N: AstNode>(node: &SyntaxNode) -> bool {\n         Some(n) => n.syntax().text_range() == node.text_range(),\n     }\n }\n+\n+fn path_or_use_tree_qualifier(path: &ast::Path) -> Option<ast::Path> {\n+    if let Some(qual) = path.qualifier() {\n+        return Some(qual);\n+    }\n+    let use_tree_list = path.syntax().ancestors().find_map(ast::UseTreeList::cast)?;\n+    let use_tree = use_tree_list.syntax().parent().and_then(ast::UseTree::cast)?;\n+    use_tree.path()\n+}", "previous_filename": "crates/ra_ide/src/completion/completion_context.rs"}, {"sha": "9377cdc577eaec057636c8c84d38d475e8f065f6", "filename": "crates/ide/src/completion/completion_item.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,8 +3,8 @@\n use std::fmt;\n \n use hir::Documentation;\n-use ra_syntax::TextRange;\n-use ra_text_edit::TextEdit;\n+use syntax::TextRange;\n+use text_edit::TextEdit;\n \n use crate::completion::completion_config::SnippetCap;\n ", "previous_filename": "crates/ra_ide/src/completion/completion_item.rs"}, {"sha": "24754a8cf575e5df58d47d31d996ed814d491d5f", "filename": "crates/ide/src/completion/generated_features.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fgenerated_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fgenerated_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fgenerated_features.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0"}, {"sha": "ffc97c076a272988958ab6b242c9a53c1ec13231", "filename": "crates/ide/src/completion/patterns.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fpatterns.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n //! Patterns telling us certain facts about current syntax element, they are used in completion context\n \n-use ra_syntax::{\n+use syntax::{\n     algo::non_trivia_sibling,\n     ast::{self, LoopBodyOwner},\n     match_ast, AstNode, Direction, NodeOrToken, SyntaxElement,\n@@ -44,7 +44,7 @@ fn test_has_block_expr_parent() {\n }\n \n pub(crate) fn has_bind_pat_parent(element: SyntaxElement) -> bool {\n-    element.ancestors().find(|it| it.kind() == BIND_PAT).is_some()\n+    element.ancestors().find(|it| it.kind() == IDENT_PAT).is_some()\n }\n #[test]\n fn test_has_bind_pat_parent() {\n@@ -134,7 +134,7 @@ pub(crate) fn is_in_loop_body(element: SyntaxElement) -> bool {\n         NodeOrToken::Token(token) => token.parent(),\n     };\n     for node in leaf.ancestors() {\n-        if node.kind() == FN || node.kind() == LAMBDA_EXPR {\n+        if node.kind() == FN || node.kind() == CLOSURE_EXPR {\n             break;\n         }\n         let loop_body = match_ast! {", "previous_filename": "crates/ra_ide/src/completion/patterns.rs"}, {"sha": "3371aed2dfa33fba541b8b8e32a320aa5c65bdcc", "filename": "crates/ide/src/completion/presentation.rs", "status": "renamed", "additions": 18, "deletions": 21, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,8 +2,8 @@\n //! It also handles scoring (sorting) completions.\n \n use hir::{Docs, HasAttrs, HasSource, HirDisplay, ModPath, ScopeDef, StructKind, Type};\n-use ra_syntax::ast::NameOwner;\n-use stdx::SepBy;\n+use itertools::Itertools;\n+use syntax::ast::NameOwner;\n use test_utils::mark;\n \n use crate::{\n@@ -191,14 +191,12 @@ impl Completions {\n         func: hir::Function,\n         local_name: Option<String>,\n     ) {\n-        let has_self_param = func.has_self_param(ctx.db);\n-\n         let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n         let ast_node = func.source(ctx.db).value;\n \n         let mut builder =\n             CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n-                .kind(if has_self_param {\n+                .kind(if func.self_param(ctx.db).is_some() {\n                     CompletionItemKind::Method\n                 } else {\n                     CompletionItemKind::Function\n@@ -289,16 +287,16 @@ impl Completions {\n             .map(|field| (field.name(ctx.db), field.signature_ty(ctx.db)));\n         let variant_kind = variant.kind(ctx.db);\n         let detail = match variant_kind {\n-            StructKind::Tuple | StructKind::Unit => detail_types\n-                .map(|(_, t)| t.display(ctx.db).to_string())\n-                .sep_by(\", \")\n-                .surround_with(\"(\", \")\")\n-                .to_string(),\n-            StructKind::Record => detail_types\n-                .map(|(n, t)| format!(\"{}: {}\", n, t.display(ctx.db).to_string()))\n-                .sep_by(\", \")\n-                .surround_with(\"{ \", \" }\")\n-                .to_string(),\n+            StructKind::Tuple | StructKind::Unit => format!(\n+                \"({})\",\n+                detail_types.map(|(_, t)| t.display(ctx.db).to_string()).format(\", \")\n+            ),\n+            StructKind::Record => format!(\n+                \"{{ {} }}\",\n+                detail_types\n+                    .map(|(n, t)| format!(\"{}: {}\", n, t.display(ctx.db).to_string()))\n+                    .format(\", \")\n+            ),\n         };\n         let mut res = CompletionItem::new(\n             CompletionKind::Reference,\n@@ -412,11 +410,10 @@ impl Builder {\n             self = self.trigger_call_info();\n             let snippet = match (ctx.config.add_call_argument_snippets, params) {\n                 (true, Params::Named(params)) => {\n-                    let function_params_snippet = params\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(index, param_name)| format!(\"${{{}:{}}}\", index + 1, param_name))\n-                        .sep_by(\", \");\n+                    let function_params_snippet =\n+                        params.iter().enumerate().format_with(\", \", |(index, param_name), f| {\n+                            f(&format_args!(\"${{{}:{}}}\", index + 1, param_name))\n+                        });\n                     format!(\"{}({})$0\", name, function_params_snippet)\n                 }\n                 _ => {\n@@ -467,7 +464,7 @@ fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static s\n mod tests {\n     use std::cmp::Reverse;\n \n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n     use test_utils::mark;\n \n     use crate::{", "previous_filename": "crates/ra_ide/src/completion/presentation.rs"}, {"sha": "1452d7e9e54b5cde41216ec3fd558907a8c1f8f1", "filename": "crates/ide/src/completion/test_utils.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcompletion%2Ftest_utils.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,8 +2,8 @@\n \n use hir::Semantics;\n use itertools::Itertools;\n-use ra_syntax::{AstNode, NodeOrToken, SyntaxElement};\n use stdx::{format_to, trim_indent};\n+use syntax::{AstNode, NodeOrToken, SyntaxElement};\n use test_utils::assert_eq_text;\n \n use crate::{", "previous_filename": "crates/ra_ide/src/completion/test_utils.rs"}, {"sha": "b2b972b02cb8176b532229b40a7d921d0d573a14", "filename": "crates/ide/src/diagnostics.rs", "status": "renamed", "additions": 116, "deletions": 167, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,43 +4,74 @@\n //! macro-expanded files, but we need to present them to the users in terms of\n //! original files. So we need to map the ranges.\n \n+mod fixes;\n+\n use std::cell::RefCell;\n \n-use hir::{\n-    diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSinkBuilder},\n-    HasSource, HirDisplay, Semantics, VariantDef,\n-};\n+use base_db::SourceDatabase;\n+use hir::{diagnostics::DiagnosticSinkBuilder, Semantics};\n+use ide_db::RootDatabase;\n use itertools::Itertools;\n-use ra_db::SourceDatabase;\n-use ra_ide_db::RootDatabase;\n-use ra_prof::profile;\n-use ra_syntax::{\n-    algo,\n-    ast::{self, edit::IndentLevel, make, AstNode},\n+use rustc_hash::FxHashSet;\n+use syntax::{\n+    ast::{self, AstNode},\n     SyntaxNode, TextRange, T,\n };\n-use ra_text_edit::{TextEdit, TextEditBuilder};\n+use text_edit::TextEdit;\n+\n+use crate::{FileId, Label, SourceChange, SourceFileEdit};\n+\n+use self::fixes::DiagnosticWithFix;\n+\n+#[derive(Debug)]\n+pub struct Diagnostic {\n+    // pub name: Option<String>,\n+    pub message: String,\n+    pub range: TextRange,\n+    pub severity: Severity,\n+    pub fix: Option<Fix>,\n+}\n+\n+#[derive(Debug)]\n+pub struct Fix {\n+    pub label: Label,\n+    pub source_change: SourceChange,\n+    /// Allows to trigger the fix only when the caret is in the range given\n+    pub fix_trigger_range: TextRange,\n+}\n \n-use crate::{Diagnostic, FileId, FileSystemEdit, Fix, SourceFileEdit};\n+impl Fix {\n+    fn new(label: &str, source_change: SourceChange, fix_trigger_range: TextRange) -> Self {\n+        let label = Label::new(label);\n+        Self { label, source_change, fix_trigger_range }\n+    }\n+}\n \n #[derive(Debug, Copy, Clone)]\n pub enum Severity {\n     Error,\n     WeakWarning,\n }\n \n+#[derive(Default, Debug, Clone)]\n+pub struct DiagnosticsConfig {\n+    pub disable_experimental: bool,\n+    pub disabled: FxHashSet<String>,\n+}\n+\n pub(crate) fn diagnostics(\n     db: &RootDatabase,\n+    config: &DiagnosticsConfig,\n     file_id: FileId,\n-    enable_experimental: bool,\n ) -> Vec<Diagnostic> {\n-    let _p = profile(\"diagnostics\");\n+    let _p = profile::span(\"diagnostics\");\n     let sema = Semantics::new(db);\n     let parse = db.parse(file_id);\n     let mut res = Vec::new();\n \n     // [#34344] Only take first 128 errors to prevent slowing down editor/ide, the number 128 is chosen arbitrarily.\n     res.extend(parse.errors().iter().take(128).map(|err| Diagnostic {\n+        // name: None,\n         range: err.range(),\n         message: format!(\"Syntax Error: {}\", err),\n         severity: Severity::Error,\n@@ -52,81 +83,31 @@ pub(crate) fn diagnostics(\n         check_struct_shorthand_initialization(&mut res, file_id, &node);\n     }\n     let res = RefCell::new(res);\n-    let mut sink = DiagnosticSinkBuilder::new()\n+    let sink_builder = DiagnosticSinkBuilder::new()\n         .on::<hir::diagnostics::UnresolvedModule, _>(|d| {\n-            let original_file = d.source().file_id.original_file(db);\n-            let fix = Fix::new(\n-                \"Create module\",\n-                FileSystemEdit::CreateFile { anchor: original_file, dst: d.candidate.clone() }\n-                    .into(),\n-            );\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix: Some(fix),\n-            })\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         .on::<hir::diagnostics::MissingFields, _>(|d| {\n-            // Note that although we could add a diagnostics to\n-            // fill the missing tuple field, e.g :\n-            // `struct A(usize);`\n-            // `let a = A { 0: () }`\n-            // but it is uncommon usage and it should not be encouraged.\n-            let fix = if d.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n-                None\n-            } else {\n-                let mut field_list = d.ast(db);\n-                for f in d.missed_fields.iter() {\n-                    let field =\n-                        make::record_field(make::name_ref(&f.to_string()), Some(make::expr_unit()));\n-                    field_list = field_list.append_field(&field);\n-                }\n-\n-                let edit = {\n-                    let mut builder = TextEditBuilder::default();\n-                    algo::diff(&d.ast(db).syntax(), &field_list.syntax())\n-                        .into_text_edit(&mut builder);\n-                    builder.finish()\n-                };\n-                Some(Fix::new(\"Fill struct fields\", SourceFileEdit { file_id, edit }.into()))\n-            };\n-\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix,\n-            })\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         .on::<hir::diagnostics::MissingOkInTailExpr, _>(|d| {\n-            let node = d.ast(db);\n-            let replacement = format!(\"Ok({})\", node.syntax());\n-            let edit = TextEdit::replace(node.syntax().text_range(), replacement);\n-            let source_change = SourceFileEdit { file_id, edit }.into();\n-            let fix = Fix::new(\"Wrap with ok\", source_change);\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix: Some(fix),\n-            })\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         .on::<hir::diagnostics::NoSuchField, _>(|d| {\n-            res.borrow_mut().push(Diagnostic {\n-                range: sema.diagnostics_range(d).range,\n-                message: d.message(),\n-                severity: Severity::Error,\n-                fix: missing_struct_field_fix(&sema, file_id, d),\n-            })\n+            res.borrow_mut().push(diagnostic_with_fix(d, &sema));\n         })\n         // Only collect experimental diagnostics when they're enabled.\n-        .filter(|diag| !diag.is_experimental() || enable_experimental)\n+        .filter(|diag| !(diag.is_experimental() && config.disable_experimental))\n+        .filter(|diag| !config.disabled.contains(diag.code().as_str()));\n+\n+    // Finalize the `DiagnosticSink` building process.\n+    let mut sink = sink_builder\n         // Diagnostics not handled above get no fix and default treatment.\n         .build(|d| {\n             res.borrow_mut().push(Diagnostic {\n+                // name: Some(d.name().into()),\n                 message: d.message(),\n-                range: sema.diagnostics_range(d).range,\n+                range: sema.diagnostics_display_range(d).range,\n                 severity: Severity::Error,\n                 fix: None,\n             })\n@@ -139,77 +120,13 @@ pub(crate) fn diagnostics(\n     res.into_inner()\n }\n \n-fn missing_struct_field_fix(\n-    sema: &Semantics<RootDatabase>,\n-    usage_file_id: FileId,\n-    d: &hir::diagnostics::NoSuchField,\n-) -> Option<Fix> {\n-    let record_expr = sema.ast(d);\n-\n-    let record_lit = ast::RecordExpr::cast(record_expr.syntax().parent()?.parent()?)?;\n-    let def_id = sema.resolve_variant(record_lit)?;\n-    let module;\n-    let def_file_id;\n-    let record_fields = match VariantDef::from(def_id) {\n-        VariantDef::Struct(s) => {\n-            module = s.module(sema.db);\n-            let source = s.source(sema.db);\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-        VariantDef::Union(u) => {\n-            module = u.module(sema.db);\n-            let source = u.source(sema.db);\n-            def_file_id = source.file_id;\n-            source.value.record_field_list()?\n-        }\n-        VariantDef::EnumVariant(e) => {\n-            module = e.module(sema.db);\n-            let source = e.source(sema.db);\n-            def_file_id = source.file_id;\n-            let fields = source.value.field_list()?;\n-            record_field_list(fields)?\n-        }\n-    };\n-    let def_file_id = def_file_id.original_file(sema.db);\n-\n-    let new_field_type = sema.type_of_expr(&record_expr.expr()?)?;\n-    if new_field_type.is_unknown() {\n-        return None;\n-    }\n-    let new_field = make::record_field_def(\n-        record_expr.field_name()?,\n-        make::type_ref(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n-    );\n-\n-    let last_field = record_fields.fields().last()?;\n-    let last_field_syntax = last_field.syntax();\n-    let indent = IndentLevel::from_node(last_field_syntax);\n-\n-    let mut new_field = new_field.to_string();\n-    if usage_file_id != def_file_id {\n-        new_field = format!(\"pub(crate) {}\", new_field);\n-    }\n-    new_field = format!(\"\\n{}{}\", indent, new_field);\n-\n-    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n-    if needs_comma {\n-        new_field = format!(\",{}\", new_field);\n-    }\n-\n-    let source_change = SourceFileEdit {\n-        file_id: def_file_id,\n-        edit: TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n-    };\n-    let fix = Fix::new(\"Create field\", source_change.into());\n-    return Some(fix);\n-\n-    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n-        match field_def_list {\n-            ast::FieldList::RecordFieldList(it) => Some(it),\n-            ast::FieldList::TupleFieldList(_) => None,\n-        }\n+fn diagnostic_with_fix<D: DiagnosticWithFix>(d: &D, sema: &Semantics<RootDatabase>) -> Diagnostic {\n+    Diagnostic {\n+        // name: Some(d.name().into()),\n+        range: sema.diagnostics_display_range(d).range,\n+        message: d.message(),\n+        severity: Severity::Error,\n+        fix: d.fix(&sema),\n     }\n }\n \n@@ -220,24 +137,26 @@ fn check_unnecessary_braces_in_use_statement(\n ) -> Option<()> {\n     let use_tree_list = ast::UseTreeList::cast(node.clone())?;\n     if let Some((single_use_tree,)) = use_tree_list.use_trees().collect_tuple() {\n-        let range = use_tree_list.syntax().text_range();\n+        let use_range = use_tree_list.syntax().text_range();\n         let edit =\n             text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(&single_use_tree)\n                 .unwrap_or_else(|| {\n                     let to_replace = single_use_tree.syntax().text().to_string();\n-                    let mut edit_builder = TextEditBuilder::default();\n-                    edit_builder.delete(range);\n-                    edit_builder.insert(range.start(), to_replace);\n+                    let mut edit_builder = TextEdit::builder();\n+                    edit_builder.delete(use_range);\n+                    edit_builder.insert(use_range.start(), to_replace);\n                     edit_builder.finish()\n                 });\n \n         acc.push(Diagnostic {\n-            range,\n+            // name: None,\n+            range: use_range,\n             message: \"Unnecessary braces in use statement\".to_string(),\n             severity: Severity::WeakWarning,\n             fix: Some(Fix::new(\n                 \"Remove unnecessary braces\",\n                 SourceFileEdit { file_id, edit }.into(),\n+                use_range,\n             )),\n         });\n     }\n@@ -252,8 +171,7 @@ fn text_edit_for_remove_unnecessary_braces_with_self_in_use_statement(\n     if single_use_tree.path()?.segment()?.syntax().first_child_or_token()?.kind() == T![self] {\n         let start = use_tree_list_node.prev_sibling_or_token()?.text_range().start();\n         let end = use_tree_list_node.text_range().end();\n-        let range = TextRange::new(start, end);\n-        return Some(TextEdit::delete(range));\n+        return Some(TextEdit::delete(TextRange::new(start, end)));\n     }\n     None\n }\n@@ -271,18 +189,21 @@ fn check_struct_shorthand_initialization(\n             let field_expr = expr.syntax().text().to_string();\n             let field_name_is_tup_index = name_ref.as_tuple_field().is_some();\n             if field_name == field_expr && !field_name_is_tup_index {\n-                let mut edit_builder = TextEditBuilder::default();\n+                let mut edit_builder = TextEdit::builder();\n                 edit_builder.delete(record_field.syntax().text_range());\n                 edit_builder.insert(record_field.syntax().text_range().start(), field_name);\n                 let edit = edit_builder.finish();\n \n+                let field_range = record_field.syntax().text_range();\n                 acc.push(Diagnostic {\n-                    range: record_field.syntax().text_range(),\n+                    // name: None,\n+                    range: field_range,\n                     message: \"Shorthand struct initialization\".to_string(),\n                     severity: Severity::WeakWarning,\n                     fix: Some(Fix::new(\n                         \"Use struct shorthand initialization\",\n                         SourceFileEdit { file_id, edit }.into(),\n+                        field_range,\n                     )),\n                 });\n             }\n@@ -293,22 +214,29 @@ fn check_struct_shorthand_initialization(\n \n #[cfg(test)]\n mod tests {\n+    use expect_test::{expect, Expect};\n     use stdx::trim_indent;\n     use test_utils::assert_eq_text;\n \n-    use crate::mock_analysis::{analysis_and_position, single_file, MockAnalysis};\n-    use expect::{expect, Expect};\n+    use crate::{\n+        mock_analysis::{analysis_and_position, single_file, MockAnalysis},\n+        DiagnosticsConfig,\n+    };\n \n     /// Takes a multi-file input fixture with annotated cursor positions,\n     /// and checks that:\n     ///  * a diagnostic is produced\n-    ///  * this diagnostic touches the input cursor position\n+    ///  * this diagnostic fix trigger range touches the input cursor position\n     ///  * that the contents of the file containing the cursor match `after` after the diagnostic fix is applied\n     fn check_fix(ra_fixture_before: &str, ra_fixture_after: &str) {\n         let after = trim_indent(ra_fixture_after);\n \n         let (analysis, file_position) = analysis_and_position(ra_fixture_before);\n-        let diagnostic = analysis.diagnostics(file_position.file_id, true).unwrap().pop().unwrap();\n+        let diagnostic = analysis\n+            .diagnostics(&DiagnosticsConfig::default(), file_position.file_id)\n+            .unwrap()\n+            .pop()\n+            .unwrap();\n         let mut fix = diagnostic.fix.unwrap();\n         let edit = fix.source_change.source_file_edits.pop().unwrap().edit;\n         let target_file_contents = analysis.file_text(file_position.file_id).unwrap();\n@@ -320,10 +248,10 @@ mod tests {\n \n         assert_eq_text!(&after, &actual);\n         assert!(\n-            diagnostic.range.start() <= file_position.offset\n-                && diagnostic.range.end() >= file_position.offset,\n-            \"diagnostic range {:?} does not touch cursor position {:?}\",\n-            diagnostic.range,\n+            fix.fix_trigger_range.start() <= file_position.offset\n+                && fix.fix_trigger_range.end() >= file_position.offset,\n+            \"diagnostic fix range {:?} does not touch cursor position {:?}\",\n+            fix.fix_trigger_range,\n             file_position.offset\n         );\n     }\n@@ -334,7 +262,11 @@ mod tests {\n         let ra_fixture_after = &trim_indent(ra_fixture_after);\n         let (analysis, file_pos) = analysis_and_position(ra_fixture_before);\n         let current_file_id = file_pos.file_id;\n-        let diagnostic = analysis.diagnostics(current_file_id, true).unwrap().pop().unwrap();\n+        let diagnostic = analysis\n+            .diagnostics(&DiagnosticsConfig::default(), current_file_id)\n+            .unwrap()\n+            .pop()\n+            .unwrap();\n         let mut fix = diagnostic.fix.unwrap();\n         let edit = fix.source_change.source_file_edits.pop().unwrap();\n         let changed_file_id = edit.file_id;\n@@ -355,14 +287,16 @@ mod tests {\n         let analysis = mock.analysis();\n         let diagnostics = files\n             .into_iter()\n-            .flat_map(|file_id| analysis.diagnostics(file_id, true).unwrap())\n+            .flat_map(|file_id| {\n+                analysis.diagnostics(&DiagnosticsConfig::default(), file_id).unwrap()\n+            })\n             .collect::<Vec<_>>();\n         assert_eq!(diagnostics.len(), 0, \"unexpected diagnostics:\\n{:#?}\", diagnostics);\n     }\n \n     fn check_expect(ra_fixture: &str, expect: Expect) {\n         let (analysis, file_id) = single_file(ra_fixture);\n-        let diagnostics = analysis.diagnostics(file_id, true).unwrap();\n+        let diagnostics = analysis.diagnostics(&DiagnosticsConfig::default(), file_id).unwrap();\n         expect.assert_debug_eq(&diagnostics)\n     }\n \n@@ -640,6 +574,7 @@ fn test_fn() {\n                                     ],\n                                     is_snippet: false,\n                                 },\n+                                fix_trigger_range: 0..8,\n                             },\n                         ),\n                     },\n@@ -794,4 +729,18 @@ struct Foo {\n             \",\n         )\n     }\n+\n+    #[test]\n+    fn test_disabled_diagnostics() {\n+        let mut config = DiagnosticsConfig::default();\n+        config.disabled.insert(\"unresolved-module\".into());\n+\n+        let (analysis, file_id) = single_file(r#\"mod foo;\"#);\n+\n+        let diagnostics = analysis.diagnostics(&config, file_id).unwrap();\n+        assert!(diagnostics.is_empty());\n+\n+        let diagnostics = analysis.diagnostics(&DiagnosticsConfig::default(), file_id).unwrap();\n+        assert!(!diagnostics.is_empty());\n+    }\n }", "previous_filename": "crates/ra_ide/src/diagnostics.rs"}, {"sha": "68ae1c23981cafab09872037b9f35dc1619fe26b", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -0,0 +1,175 @@\n+//! Provides a way to attach fixes to the diagnostics.\n+//! The same module also has all curret custom fixes for the diagnostics implemented.\n+use base_db::FileId;\n+use hir::{\n+    db::AstDatabase,\n+    diagnostics::{Diagnostic, MissingFields, MissingOkInTailExpr, NoSuchField, UnresolvedModule},\n+    HasSource, HirDisplay, Semantics, VariantDef,\n+};\n+use ide_db::{\n+    source_change::{FileSystemEdit, SourceFileEdit},\n+    RootDatabase,\n+};\n+use syntax::{\n+    algo,\n+    ast::{self, edit::IndentLevel, make},\n+    AstNode,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::diagnostics::Fix;\n+\n+/// A [Diagnostic] that potentially has a fix available.\n+///\n+/// [Diagnostic]: hir::diagnostics::Diagnostic\n+pub trait DiagnosticWithFix: Diagnostic {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix>;\n+}\n+\n+impl DiagnosticWithFix for UnresolvedModule {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let unresolved_module = self.decl.to_node(&root);\n+        Some(Fix::new(\n+            \"Create module\",\n+            FileSystemEdit::CreateFile {\n+                anchor: self.file.original_file(sema.db),\n+                dst: self.candidate.clone(),\n+            }\n+            .into(),\n+            unresolved_module.syntax().text_range(),\n+        ))\n+    }\n+}\n+\n+impl DiagnosticWithFix for NoSuchField {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        missing_record_expr_field_fix(\n+            &sema,\n+            self.file.original_file(sema.db),\n+            &self.field.to_node(&root),\n+        )\n+    }\n+}\n+\n+impl DiagnosticWithFix for MissingFields {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        // Note that although we could add a diagnostics to\n+        // fill the missing tuple field, e.g :\n+        // `struct A(usize);`\n+        // `let a = A { 0: () }`\n+        // but it is uncommon usage and it should not be encouraged.\n+        if self.missed_fields.iter().any(|it| it.as_tuple_index().is_some()) {\n+            return None;\n+        }\n+\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let old_field_list = self.field_list_parent.to_node(&root).record_expr_field_list()?;\n+        let mut new_field_list = old_field_list.clone();\n+        for f in self.missed_fields.iter() {\n+            let field =\n+                make::record_expr_field(make::name_ref(&f.to_string()), Some(make::expr_unit()));\n+            new_field_list = new_field_list.append_field(&field);\n+        }\n+\n+        let edit = {\n+            let mut builder = TextEdit::builder();\n+            algo::diff(&old_field_list.syntax(), &new_field_list.syntax())\n+                .into_text_edit(&mut builder);\n+            builder.finish()\n+        };\n+        Some(Fix::new(\n+            \"Fill struct fields\",\n+            SourceFileEdit { file_id: self.file.original_file(sema.db), edit }.into(),\n+            sema.original_range(&old_field_list.syntax()).range,\n+        ))\n+    }\n+}\n+\n+impl DiagnosticWithFix for MissingOkInTailExpr {\n+    fn fix(&self, sema: &Semantics<RootDatabase>) -> Option<Fix> {\n+        let root = sema.db.parse_or_expand(self.file)?;\n+        let tail_expr = self.expr.to_node(&root);\n+        let tail_expr_range = tail_expr.syntax().text_range();\n+        let edit = TextEdit::replace(tail_expr_range, format!(\"Ok({})\", tail_expr.syntax()));\n+        let source_change =\n+            SourceFileEdit { file_id: self.file.original_file(sema.db), edit }.into();\n+        Some(Fix::new(\"Wrap with ok\", source_change, tail_expr_range))\n+    }\n+}\n+\n+fn missing_record_expr_field_fix(\n+    sema: &Semantics<RootDatabase>,\n+    usage_file_id: FileId,\n+    record_expr_field: &ast::RecordExprField,\n+) -> Option<Fix> {\n+    let record_lit = ast::RecordExpr::cast(record_expr_field.syntax().parent()?.parent()?)?;\n+    let def_id = sema.resolve_variant(record_lit)?;\n+    let module;\n+    let def_file_id;\n+    let record_fields = match VariantDef::from(def_id) {\n+        VariantDef::Struct(s) => {\n+            module = s.module(sema.db);\n+            let source = s.source(sema.db);\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+        VariantDef::Union(u) => {\n+            module = u.module(sema.db);\n+            let source = u.source(sema.db);\n+            def_file_id = source.file_id;\n+            source.value.record_field_list()?\n+        }\n+        VariantDef::EnumVariant(e) => {\n+            module = e.module(sema.db);\n+            let source = e.source(sema.db);\n+            def_file_id = source.file_id;\n+            let fields = source.value.field_list()?;\n+            record_field_list(fields)?\n+        }\n+    };\n+    let def_file_id = def_file_id.original_file(sema.db);\n+\n+    let new_field_type = sema.type_of_expr(&record_expr_field.expr()?)?;\n+    if new_field_type.is_unknown() {\n+        return None;\n+    }\n+    let new_field = make::record_field(\n+        record_expr_field.field_name()?,\n+        make::ty(&new_field_type.display_source_code(sema.db, module.into()).ok()?),\n+    );\n+\n+    let last_field = record_fields.fields().last()?;\n+    let last_field_syntax = last_field.syntax();\n+    let indent = IndentLevel::from_node(last_field_syntax);\n+\n+    let mut new_field = new_field.to_string();\n+    if usage_file_id != def_file_id {\n+        new_field = format!(\"pub(crate) {}\", new_field);\n+    }\n+    new_field = format!(\"\\n{}{}\", indent, new_field);\n+\n+    let needs_comma = !last_field_syntax.to_string().ends_with(',');\n+    if needs_comma {\n+        new_field = format!(\",{}\", new_field);\n+    }\n+\n+    let source_change = SourceFileEdit {\n+        file_id: def_file_id,\n+        edit: TextEdit::insert(last_field_syntax.text_range().end(), new_field),\n+    };\n+    return Some(Fix::new(\n+        \"Create field\",\n+        source_change.into(),\n+        record_expr_field.syntax().text_range(),\n+    ));\n+\n+    fn record_field_list(field_def_list: ast::FieldList) -> Option<ast::RecordFieldList> {\n+        match field_def_list {\n+            ast::FieldList::RecordFieldList(it) => Some(it),\n+            ast::FieldList::TupleFieldList(_) => None,\n+        }\n+    }\n+}"}, {"sha": "41b5bdc490c086859f74f607a07793b82319a36c", "filename": "crates/ide/src/display.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,7 +4,7 @@\n mod navigation_target;\n mod short_label;\n \n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode, AttrsOwner, GenericParamsOwner, NameOwner},\n     SyntaxKind::{ATTR, COMMENT},\n };", "previous_filename": "crates/ra_ide/src/display.rs"}, {"sha": "1ee80c2dd4e92f724eaf8303f9610332c8632789", "filename": "crates/ide/src/display/navigation_target.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,13 +1,13 @@\n //! FIXME: write short doc here\n \n+use base_db::{FileId, SourceDatabase};\n use either::Either;\n use hir::{original_range, AssocItem, FieldSource, HasSource, InFile, ModuleSource};\n-use ra_db::{FileId, SourceDatabase};\n-use ra_ide_db::{defs::Definition, RootDatabase};\n-use ra_syntax::{\n+use ide_db::{defs::Definition, RootDatabase};\n+use syntax::{\n     ast::{self, DocCommentsOwner, NameOwner},\n     match_ast, AstNode, SmolStr,\n-    SyntaxKind::{self, BIND_PAT, TYPE_PARAM},\n+    SyntaxKind::{self, IDENT_PAT, TYPE_PARAM},\n     TextRange,\n };\n \n@@ -253,7 +253,7 @@ impl ToNav for hir::ImplDef {\n         let focus_range = if derive_attr.is_some() {\n             None\n         } else {\n-            src.value.target_type().map(|ty| original_range(db, src.with_value(ty.syntax())).range)\n+            src.value.self_ty().map(|ty| original_range(db, src.with_value(ty.syntax())).range)\n         };\n \n         NavigationTarget::from_syntax(\n@@ -339,7 +339,7 @@ impl ToNav for hir::Local {\n         NavigationTarget {\n             file_id: full_range.file_id,\n             name,\n-            kind: BIND_PAT,\n+            kind: IDENT_PAT,\n             full_range: full_range.range,\n             focus_range: None,\n             container_name: None,\n@@ -421,7 +421,7 @@ pub(crate) fn description_from_symbol(db: &RootDatabase, symbol: &FileSymbol) ->\n \n #[cfg(test)]\n mod tests {\n-    use expect::expect;\n+    use expect_test::expect;\n \n     use crate::{mock_analysis::single_file, Query};\n ", "previous_filename": "crates/ra_ide/src/display/navigation_target.rs"}, {"sha": "ea49d9f970787ba9686d8169a08e7e0b94883dd6", "filename": "crates/ide/src/display/short_label.rs", "status": "renamed", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fdisplay%2Fshort_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fdisplay%2Fshort_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay%2Fshort_label.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n-use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n use stdx::format_to;\n+use syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n \n pub(crate) trait ShortLabel {\n     fn short_label(&self) -> Option<String>;\n@@ -47,6 +47,12 @@ impl ShortLabel for ast::Module {\n     }\n }\n \n+impl ShortLabel for ast::SourceFile {\n+    fn short_label(&self) -> Option<String> {\n+        None\n+    }\n+}\n+\n impl ShortLabel for ast::TypeAlias {\n     fn short_label(&self) -> Option<String> {\n         short_label_from_node(self, \"type \")\n@@ -55,7 +61,11 @@ impl ShortLabel for ast::TypeAlias {\n \n impl ShortLabel for ast::Const {\n     fn short_label(&self) -> Option<String> {\n-        short_label_from_ty(self, self.ty(), \"const \")\n+        let mut new_buf = short_label_from_ty(self, self.ty(), \"const \")?;\n+        if let Some(expr) = self.body() {\n+            format_to!(new_buf, \" = {}\", expr.syntax());\n+        }\n+        Some(new_buf)\n     }\n }\n \n@@ -77,7 +87,7 @@ impl ShortLabel for ast::Variant {\n     }\n }\n \n-fn short_label_from_ty<T>(node: &T, ty: Option<ast::TypeRef>, prefix: &str) -> Option<String>\n+fn short_label_from_ty<T>(node: &T, ty: Option<ast::Type>, prefix: &str) -> Option<String>\n where\n     T: NameOwner + VisibilityOwner,\n {", "previous_filename": "crates/ra_ide/src/display/short_label.rs"}, {"sha": "8a285bcf7a9698b0b4172d17efb345a6198d245d", "filename": "crates/ide/src/expand_macro.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use hir::Semantics;\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n+use ide_db::RootDatabase;\n+use syntax::{\n     algo::{find_node_at_offset, SyntaxRewriter},\n     ast, AstNode, NodeOrToken, SyntaxKind,\n     SyntaxKind::*,\n@@ -120,7 +120,7 @@ fn insert_whitespaces(syn: SyntaxNode) -> String {\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::mock_analysis::analysis_and_position;\n ", "previous_filename": "crates/ra_ide/src/expand_macro.rs"}, {"sha": "34563a0267f6acd64edce4b35aa6d4315b75e9e8", "filename": "crates/ide/src/extend_selection.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fextend_selection.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,8 +1,8 @@\n use std::iter::successors;\n \n use hir::Semantics;\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n+use ide_db::RootDatabase;\n+use syntax::{\n     algo::{self, find_covering_element, skip_trivia_token},\n     ast::{self, AstNode, AstToken},\n     Direction, NodeOrToken,\n@@ -37,15 +37,15 @@ fn try_extend_selection(\n \n     let string_kinds = [COMMENT, STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n     let list_kinds = [\n-        RECORD_FIELD_PAT_LIST,\n+        RECORD_PAT_FIELD_LIST,\n         MATCH_ARM_LIST,\n         RECORD_FIELD_LIST,\n         TUPLE_FIELD_LIST,\n         RECORD_EXPR_FIELD_LIST,\n         VARIANT_LIST,\n         USE_TREE_LIST,\n         GENERIC_PARAM_LIST,\n-        TYPE_ARG_LIST,\n+        GENERIC_ARG_LIST,\n         TYPE_BOUND_LIST,\n         PARAM_LIST,\n         ARG_LIST,", "previous_filename": "crates/ra_ide/src/extend_selection.rs"}, {"sha": "6168fb837ccaee180eee7c62e31d4b4a7df62135", "filename": "crates/ide/src/file_structure.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Ffile_structure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Ffile_structure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffile_structure.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AttrsOwner, GenericParamsOwner, NameOwner},\n     match_ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange, WalkEvent,\n };\n@@ -57,7 +57,7 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n \n     fn decl_with_type_ref<N: NameOwner + AttrsOwner>(\n         node: &N,\n-        type_ref: Option<ast::TypeRef>,\n+        type_ref: Option<ast::Type>,\n     ) -> Option<StructureNode> {\n         let detail = type_ref.map(|type_ref| {\n             let mut detail = String::new();\n@@ -130,8 +130,8 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n             ast::Const(it) => decl_with_type_ref(&it, it.ty()),\n             ast::Static(it) => decl_with_type_ref(&it, it.ty()),\n             ast::Impl(it) => {\n-                let target_type = it.target_type()?;\n-                let target_trait = it.target_trait();\n+                let target_type = it.self_ty()?;\n+                let target_trait = it.trait_();\n                 let label = match target_trait {\n                     None => format!(\"impl {}\", target_type.syntax().text()),\n                     Some(t) => {\n@@ -164,7 +164,7 @@ fn structure_node(node: &SyntaxNode) -> Option<StructureNode> {\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use super::*;\n ", "previous_filename": "crates/ra_ide/src/file_structure.rs"}, {"sha": "7523aec55732bdde0eddd88f2314928e3339cd23", "filename": "crates/ide/src/folding_ranges.rs", "status": "renamed", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffolding_ranges.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_hash::FxHashSet;\n \n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode, AstToken, VisibilityOwner},\n     Direction, NodeOrToken, SourceFile,\n     SyntaxKind::{self, *},\n@@ -85,8 +85,9 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n         COMMENT => Some(FoldKind::Comment),\n         USE => Some(FoldKind::Imports),\n         ARG_LIST | PARAM_LIST => Some(FoldKind::ArgList),\n-        RECORD_FIELD_LIST\n-        | RECORD_FIELD_PAT_LIST\n+        ASSOC_ITEM_LIST\n+        | RECORD_FIELD_LIST\n+        | RECORD_PAT_FIELD_LIST\n         | RECORD_EXPR_FIELD_LIST\n         | ITEM_LIST\n         | EXTERN_ITEM_LIST\n@@ -336,6 +337,26 @@ fn main() <fold block>{\n         );\n     }\n \n+    #[test]\n+    fn test_folds_structs() {\n+        check(\n+            r#\"\n+struct Foo <fold block>{\n+}</fold>\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_folds_traits() {\n+        check(\n+            r#\"\n+trait Foo <fold block>{\n+}</fold>\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn test_folds_macros() {\n         check(", "previous_filename": "crates/ra_ide/src/folding_ranges.rs"}, {"sha": "15e9b7fad825e9298ad80dca3a95a5c483fed6d5", "filename": "crates/ide/src/goto_definition.rs", "status": "renamed", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n use hir::Semantics;\n-use ra_ide_db::{\n-    defs::{classify_name, classify_name_ref, NameClass},\n+use ide_db::{\n+    defs::{classify_name, classify_name_ref},\n     symbol_index, RootDatabase,\n };\n-use ra_syntax::{\n+use syntax::{\n     ast::{self},\n     match_ast, AstNode,\n     SyntaxKind::*,\n@@ -40,10 +40,7 @@ pub(crate) fn goto_definition(\n                 reference_definition(&sema, &name_ref).to_vec()\n             },\n             ast::Name(name) => {\n-                let def = match classify_name(&sema, &name)? {\n-                    NameClass::Definition(def) | NameClass::ConstReference(def) => def,\n-                    NameClass::FieldShorthand { local: _, field } => field,\n-                };\n+                let def = classify_name(&sema, &name)?.definition(sema.db);\n                 let nav = def.try_to_nav(sema.db)?;\n                 vec![nav]\n             },\n@@ -86,8 +83,7 @@ pub(crate) fn reference_definition(\n ) -> ReferenceResult {\n     let name_kind = classify_name_ref(sema, name_ref);\n     if let Some(def) = name_kind {\n-        let def = def.definition();\n-\n+        let def = def.definition(sema.db);\n         return match def.try_to_nav(sema.db) {\n             Some(nav) => ReferenceResult::Exact(nav),\n             None => ReferenceResult::Approximate(Vec::new()),\n@@ -104,8 +100,8 @@ pub(crate) fn reference_definition(\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::FileRange;\n-    use ra_syntax::{TextRange, TextSize};\n+    use base_db::FileRange;\n+    use syntax::{TextRange, TextSize};\n \n     use crate::mock_analysis::MockAnalysis;\n \n@@ -133,6 +129,32 @@ mod tests {\n         assert_eq!(expected, FileRange { file_id: nav.file_id, range: nav.focus_or_full_range() });\n     }\n \n+    #[test]\n+    fn goto_def_for_extern_crate() {\n+        check(\n+            r#\"\n+            //- /main.rs\n+            extern crate std<|>;\n+            //- /std/lib.rs\n+            // empty\n+            //^ file\n+            \"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn goto_def_for_renamed_extern_crate() {\n+        check(\n+            r#\"\n+            //- /main.rs\n+            extern crate std as abc<|>;\n+            //- /std/lib.rs\n+            // empty\n+            //^ file\n+            \"#,\n+        )\n+    }\n+\n     #[test]\n     fn goto_def_in_items() {\n         check(", "previous_filename": "crates/ra_ide/src/goto_definition.rs"}, {"sha": "f503f4ec5fe4b0c14689796bb3a818bbcf5bac99", "filename": "crates/ide/src/goto_implementation.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use hir::{Crate, ImplDef, Semantics};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n+use ide_db::RootDatabase;\n+use syntax::{algo::find_node_at_offset, ast, AstNode};\n \n use crate::{display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n \n@@ -74,7 +74,7 @@ fn impls_for_trait(\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::FileRange;\n+    use base_db::FileRange;\n \n     use crate::mock_analysis::MockAnalysis;\n ", "previous_filename": "crates/ra_ide/src/goto_implementation.rs"}, {"sha": "4a151b1506401992d2fb1aa3f6d2a656d7b3cf88", "filename": "crates/ide/src/goto_type_definition.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_type_definition.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,5 @@\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n+use ide_db::RootDatabase;\n+use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n \n use crate::{display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n \n@@ -54,7 +54,7 @@ fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n \n #[cfg(test)]\n mod tests {\n-    use ra_db::FileRange;\n+    use base_db::FileRange;\n \n     use crate::mock_analysis::MockAnalysis;\n ", "previous_filename": "crates/ra_ide/src/goto_type_definition.rs"}, {"sha": "b012e4900f144cdbdb62e79de17c3000733e9fd7", "filename": "crates/ide/src/hover.rs", "status": "renamed", "additions": 114, "deletions": 13, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,15 +1,15 @@\n+use base_db::SourceDatabase;\n use hir::{\n     Adt, AsAssocItem, AssocItemContainer, Documentation, FieldSource, HasSource, HirDisplay,\n     Module, ModuleDef, ModuleSource, Semantics,\n };\n-use itertools::Itertools;\n-use ra_db::SourceDatabase;\n-use ra_ide_db::{\n+use ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n     RootDatabase,\n };\n-use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n+use itertools::Itertools;\n use stdx::format_to;\n+use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n use test_utils::mark;\n \n use crate::{\n@@ -86,8 +86,8 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n     let node = token.parent();\n     let definition = match_ast! {\n         match node {\n-            ast::NameRef(name_ref) => classify_name_ref(&sema, &name_ref).map(|d| d.definition()),\n-            ast::Name(name) => classify_name(&sema, &name).map(|d| d.definition()),\n+            ast::NameRef(name_ref) => classify_name_ref(&sema, &name_ref).map(|d| d.definition(sema.db)),\n+            ast::Name(name) => classify_name(&sema, &name).map(|d| d.definition(sema.db)),\n             _ => None,\n         }\n     };\n@@ -306,7 +306,10 @@ fn hover_for_definition(db: &RootDatabase, def: Definition) -> Option<Markup> {\n                     let docs = Documentation::from_ast(&it).map(Into::into);\n                     hover_markup(docs, it.short_label(), mod_path)\n                 }\n-                _ => None,\n+                ModuleSource::SourceFile(it) => {\n+                    let docs = Documentation::from_ast(&it).map(Into::into);\n+                    hover_markup(docs, it.short_label(), mod_path)\n+                }\n             },\n             ModuleDef::Function(it) => from_def_source(db, it, mod_path),\n             ModuleDef::Adt(Adt::Struct(it)) => from_def_source(db, it, mod_path),\n@@ -351,8 +354,8 @@ fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n-    use ra_db::FileLoader;\n+    use base_db::FileLoader;\n+    use expect_test::{expect, Expect};\n \n     use crate::mock_analysis::analysis_and_position;\n \n@@ -526,6 +529,44 @@ fn main() { }\n         );\n     }\n \n+    #[test]\n+    fn hover_shows_fn_doc() {\n+        check(\n+            r#\"\n+/// # Example\n+/// ```\n+/// # use std::path::Path;\n+/// #\n+/// foo(Path::new(\"hello, world!\"))\n+/// ```\n+pub fn foo<|>(_: &Path) {}\n+\n+fn main() { }\n+\"#,\n+            expect![[r##\"\n+                *foo*\n+\n+                ```rust\n+                test\n+                ```\n+\n+                ```rust\n+                pub fn foo(_: &Path)\n+                ```\n+\n+                ---\n+\n+                # Example\n+\n+                ```\n+                # use std::path::Path;\n+                #\n+                foo(Path::new(\"hello, world!\"))\n+                ```\n+            \"##]],\n+        );\n+    }\n+\n     #[test]\n     fn hover_shows_struct_field_info() {\n         // Hovering over the field when instantiating\n@@ -576,7 +617,7 @@ fn main() {\n     #[test]\n     fn hover_const_static() {\n         check(\n-            r#\"const foo<|>: u32 = 0;\"#,\n+            r#\"const foo<|>: u32 = 123;\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -585,12 +626,12 @@ fn main() {\n                 ```\n \n                 ```rust\n-                const foo: u32\n+                const foo: u32 = 123\n                 ```\n             \"#]],\n         );\n         check(\n-            r#\"static foo<|>: u32 = 0;\"#,\n+            r#\"static foo<|>: u32 = 456;\"#,\n             expect![[r#\"\n                 *foo*\n \n@@ -773,6 +814,26 @@ fn main() {\n         )\n     }\n \n+    #[test]\n+    fn hover_for_param_with_multiple_traits() {\n+        check(\n+            r#\"trait Deref {\n+                type Target: ?Sized;\n+            }\n+            trait DerefMut {\n+                type Target: ?Sized;\n+            }\n+            fn f(_x<|>: impl Deref<Target=u8> + DerefMut<Target=u8>) {}\"#,\n+            expect![[r#\"\n+                *_x*\n+\n+                ```rust\n+                impl Deref<Target = u8> + DerefMut<Target = u8>\n+                ```\n+            \"#]],\n+        )\n+    }\n+\n     #[test]\n     fn test_hover_infer_associated_method_result() {\n         check(\n@@ -848,7 +909,7 @@ fn main() {\n                 ```\n \n                 ```rust\n-                const C: u32\n+                const C: u32 = 1\n                 ```\n             \"#]],\n         )\n@@ -1193,6 +1254,46 @@ fn bar() { fo<|>o(); }\n         );\n     }\n \n+    #[test]\n+    fn test_hover_extern_crate() {\n+        check(\n+            r#\"\n+//- /main.rs\n+extern crate st<|>d;\n+//- /std/lib.rs\n+//! Standard library for this test\n+//!\n+//! Printed?\n+//! abc123\n+            \"#,\n+            expect![[r#\"\n+            *std*\n+            Standard library for this test\n+\n+            Printed?\n+            abc123\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+//- /main.rs\n+extern crate std as ab<|>c;\n+//- /std/lib.rs\n+//! Standard library for this test\n+//!\n+//! Printed?\n+//! abc123\n+            \"#,\n+            expect![[r#\"\n+            *abc*\n+            Standard library for this test\n+\n+            Printed?\n+            abc123\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn test_hover_mod_with_same_name_as_function() {\n         check(", "previous_filename": "crates/ra_ide/src/hover.rs"}, {"sha": "583f39d85ba22e57cbf987ee985586aec68f8ed8", "filename": "crates/ide/src/inlay_hints.rs", "status": "renamed", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,11 +1,10 @@\n use hir::{Adt, Callable, HirDisplay, Semantics, Type};\n-use ra_ide_db::RootDatabase;\n-use ra_prof::profile;\n-use ra_syntax::{\n+use ide_db::RootDatabase;\n+use stdx::to_lower_snake_case;\n+use syntax::{\n     ast::{self, ArgListOwner, AstNode},\n     match_ast, Direction, NodeOrToken, SmolStr, SyntaxKind, TextRange, T,\n };\n-use stdx::to_lower_snake_case;\n \n use crate::FileId;\n use ast::NameOwner;\n@@ -44,7 +43,7 @@ pub struct InlayHint {\n // rust-analyzer shows additional information inline with the source code.\n // Editors usually render this using read-only virtual text snippets interspersed with code.\n //\n-// rust-analyzer shows hits for\n+// rust-analyzer shows hints for\n //\n // * types of local variables\n // * names of function arguments\n@@ -64,7 +63,7 @@ pub(crate) fn inlay_hints(\n     file_id: FileId,\n     config: &InlayHintsConfig,\n ) -> Vec<InlayHint> {\n-    let _p = profile(\"inlay_hints\");\n+    let _p = profile::span(\"inlay_hints\");\n     let sema = Semantics::new(db);\n     let file = sema.parse(file_id);\n \n@@ -78,7 +77,7 @@ pub(crate) fn inlay_hints(\n             match node {\n                 ast::CallExpr(it) => { get_param_name_hints(&mut res, &sema, config, ast::Expr::from(it)); },\n                 ast::MethodCallExpr(it) => { get_param_name_hints(&mut res, &sema, config, ast::Expr::from(it)); },\n-                ast::BindPat(it) => { get_bind_pat_hints(&mut res, &sema, config, it); },\n+                ast::IdentPat(it) => { get_bind_pat_hints(&mut res, &sema, config, it); },\n                 _ => (),\n             }\n         }\n@@ -157,15 +156,15 @@ fn get_param_name_hints(\n         .params(sema.db)\n         .into_iter()\n         .zip(args)\n-        .filter_map(|((param, _ty), arg)| match param? {\n-            Either::Left(self_param) => Some((self_param.to_string(), arg)),\n-            Either::Right(pat) => {\n-                let param_name = match pat {\n-                    ast::Pat::BindPat(it) => it.name()?.to_string(),\n-                    it => it.to_string(),\n-                };\n-                Some((param_name, arg))\n-            }\n+        .filter_map(|((param, _ty), arg)| {\n+            let param_name = match param? {\n+                Either::Left(self_param) => self_param.to_string(),\n+                Either::Right(pat) => match pat {\n+                    ast::Pat::IdentPat(it) => it.name()?.to_string(),\n+                    _ => return None,\n+                },\n+            };\n+            Some((param_name, arg))\n         })\n         .filter(|(param_name, arg)| should_show_param_name_hint(sema, &callable, &param_name, &arg))\n         .map(|(param_name, arg)| InlayHint {\n@@ -182,7 +181,7 @@ fn get_bind_pat_hints(\n     acc: &mut Vec<InlayHint>,\n     sema: &Semantics<RootDatabase>,\n     config: &InlayHintsConfig,\n-    pat: ast::BindPat,\n+    pat: ast::IdentPat,\n ) -> Option<()> {\n     if !config.type_hints {\n         return None;\n@@ -202,7 +201,7 @@ fn get_bind_pat_hints(\n     Some(())\n }\n \n-fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::BindPat, pat_ty: &Type) -> bool {\n+fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &Type) -> bool {\n     if let Some(Adt::Enum(enum_data)) = pat_ty.as_adt() {\n         let pat_text = bind_pat.to_string();\n         enum_data\n@@ -215,7 +214,11 @@ fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::BindPat, pat_ty: &Type\n     }\n }\n \n-fn should_not_display_type_hint(db: &RootDatabase, bind_pat: &ast::BindPat, pat_ty: &Type) -> bool {\n+fn should_not_display_type_hint(\n+    db: &RootDatabase,\n+    bind_pat: &ast::IdentPat,\n+    pat_ty: &Type,\n+) -> bool {\n     if pat_ty.is_unknown() {\n         return true;\n     }\n@@ -333,7 +336,7 @@ fn get_callable(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<Call\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n     use test_utils::extract_annotations;\n \n     use crate::{inlay_hints::InlayHintsConfig, mock_analysis::single_file};\n@@ -704,6 +707,8 @@ fn different_order(param: &Param) {}\n fn different_order_mut(param: &mut Param) {}\n fn has_underscore(_param: bool) {}\n fn enum_matches_param_name(completion_kind: CompletionKind) {}\n+fn param_destructuring_omitted_1((a, b): (u32, u32)) {}\n+fn param_destructuring_omitted_2(TestVarContainer { test_var: _ }: TestVarContainer) {}\n \n fn twiddle(twiddle: bool) {}\n fn doo(_doo: bool) {}\n@@ -743,6 +748,10 @@ fn main() {\n     let b: f64 = 4.0;\n     let _: f64 = a.div_euclid(b);\n     let _: f64 = a.abs_sub(b);\n+\n+    let range: (u32, u32) = (3, 5);\n+    param_destructuring_omitted_1(range);\n+    param_destructuring_omitted_2(container);\n }\"#,\n         );\n     }", "previous_filename": "crates/ra_ide/src/inlay_hints.rs"}, {"sha": "e37702acdf05ac9a82220b46fd8f7693bfc96320", "filename": "crates/ide/src/join_lines.rs", "status": "renamed", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fjoin_lines.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,13 +1,13 @@\n+use assists::utils::extract_trivial_expression;\n use itertools::Itertools;\n-use ra_fmt::{compute_ws, extract_trivial_expression};\n-use ra_syntax::{\n+use syntax::{\n     algo::{find_covering_element, non_trivia_sibling},\n     ast::{self, AstNode, AstToken},\n     Direction, NodeOrToken, SourceFile,\n-    SyntaxKind::{self, WHITESPACE},\n+    SyntaxKind::{self, USE_TREE, WHITESPACE},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n };\n-use ra_text_edit::{TextEdit, TextEditBuilder};\n+use text_edit::{TextEdit, TextEditBuilder};\n \n // Feature: Join Lines\n //\n@@ -23,7 +23,7 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n         let syntax = file.syntax();\n         let text = syntax.text().slice(range.start()..);\n         let pos = match text.find_char('\\n') {\n-            None => return TextEditBuilder::default().finish(),\n+            None => return TextEdit::builder().finish(),\n             Some(pos) => pos,\n         };\n         TextRange::at(range.start() + pos, TextSize::of('\\n'))\n@@ -35,7 +35,7 @@ pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n         NodeOrToken::Node(node) => node,\n         NodeOrToken::Token(token) => token.parent(),\n     };\n-    let mut edit = TextEditBuilder::default();\n+    let mut edit = TextEdit::builder();\n     for token in node.descendants_with_tokens().filter_map(|it| it.into_token()) {\n         let range = match range.intersect(token.text_range()) {\n             Some(range) => range,\n@@ -168,9 +168,32 @@ fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n     matches!((left, right), (T![,], T![')']) | (T![,], T![']']))\n }\n \n+fn compute_ws(left: SyntaxKind, right: SyntaxKind) -> &'static str {\n+    match left {\n+        T!['('] | T!['['] => return \"\",\n+        T!['{'] => {\n+            if let USE_TREE = right {\n+                return \"\";\n+            }\n+        }\n+        _ => (),\n+    }\n+    match right {\n+        T![')'] | T![']'] => return \"\",\n+        T!['}'] => {\n+            if let USE_TREE = left {\n+                return \"\";\n+            }\n+        }\n+        T![.] => return \"\",\n+        _ => (),\n+    }\n+    \" \"\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use ra_syntax::SourceFile;\n+    use syntax::SourceFile;\n     use test_utils::{add_cursor, assert_eq_text, extract_offset, extract_range};\n \n     use super::*;\n@@ -437,11 +460,11 @@ fn foo() {\n         // No space after the '{'\n         check_join_lines(\n             r\"\n-<|>use ra_syntax::{\n+<|>use syntax::{\n     TextSize, TextRange,\n };\",\n             r\"\n-<|>use ra_syntax::{TextSize, TextRange,\n+<|>use syntax::{TextSize, TextRange,\n };\",\n         );\n     }\n@@ -451,11 +474,11 @@ fn foo() {\n         // No space after the '}'\n         check_join_lines(\n             r\"\n-use ra_syntax::{\n+use syntax::{\n <|>    TextSize, TextRange\n };\",\n             r\"\n-use ra_syntax::{\n+use syntax::{\n <|>    TextSize, TextRange};\",\n         );\n     }\n@@ -465,11 +488,11 @@ use ra_syntax::{\n         // No space after the '}'\n         check_join_lines(\n             r\"\n-use ra_syntax::{\n+use syntax::{\n <|>    TextSize, TextRange,\n };\",\n             r\"\n-use ra_syntax::{\n+use syntax::{\n <|>    TextSize, TextRange};\",\n         );\n     }\n@@ -478,14 +501,14 @@ use ra_syntax::{\n     fn test_join_lines_use_tree() {\n         check_join_lines(\n             r\"\n-use ra_syntax::{\n+use syntax::{\n     algo::<|>{\n         find_token_at_offset,\n     },\n     ast,\n };\",\n             r\"\n-use ra_syntax::{\n+use syntax::{\n     algo::<|>find_token_at_offset,\n     ast,\n };\",", "previous_filename": "crates/ra_ide/src/join_lines.rs"}, {"sha": "570790384ee59d2e80afb023b3beb6f0f2d88d19", "filename": "crates/ide/src/lib.rs", "status": "renamed", "additions": 27, "deletions": 46, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n-//! ra_ide crate provides \"ide-centric\" APIs for the rust-analyzer. That is,\n+//! ide crate provides \"ide-centric\" APIs for the rust-analyzer. That is,\n //! it generally operates with files and text ranges, and returns results as\n //! Strings, suitable for displaying to the human.\n //!\n //! What powers this API are the `RootDatabase` struct, which defines a `salsa`\n-//! database, and the `ra_hir` crate, where majority of the analysis happens.\n+//! database, and the `hir` crate, where majority of the analysis happens.\n //! However, IDE specific bits of the analysis (most notably completion) happen\n //! in this crate.\n \n@@ -39,7 +39,6 @@ mod matching_brace;\n mod parent_module;\n mod references;\n mod runnables;\n-mod ssr;\n mod status;\n mod syntax_highlighting;\n mod syntax_tree;\n@@ -48,16 +47,16 @@ mod link_rewrite;\n \n use std::sync::Arc;\n \n-use ra_cfg::CfgOptions;\n-use ra_db::{\n+use base_db::{\n     salsa::{self, ParallelDatabase},\n     CheckCanceled, Env, FileLoader, FileSet, SourceDatabase, VfsPath,\n };\n-use ra_ide_db::{\n+use cfg::CfgOptions;\n+use ide_db::{\n     symbol_index::{self, FileSymbol},\n     LineIndexDatabase,\n };\n-use ra_syntax::{SourceFile, TextRange, TextSize};\n+use syntax::{SourceFile, TextRange, TextSize};\n \n use crate::display::ToNav;\n \n@@ -67,7 +66,7 @@ pub use crate::{\n     completion::{\n         CompletionConfig, CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat,\n     },\n-    diagnostics::Severity,\n+    diagnostics::{Diagnostic, DiagnosticsConfig, Fix, Severity},\n     display::NavigationTarget,\n     expand_macro::ExpandedMacro,\n     file_structure::StructureNode,\n@@ -82,47 +81,26 @@ pub use crate::{\n     },\n };\n \n-pub use hir::{Documentation, Semantics};\n-pub use ra_assists::{Assist, AssistConfig, AssistId, AssistKind, ResolvedAssist};\n-pub use ra_db::{\n+pub use assists::{Assist, AssistConfig, AssistId, AssistKind, ResolvedAssist};\n+pub use base_db::{\n     Canceled, CrateGraph, CrateId, Edition, FileId, FilePosition, FileRange, SourceRoot,\n     SourceRootId,\n };\n-pub use ra_ide_db::{\n+pub use hir::{Documentation, Semantics};\n+pub use ide_db::{\n     change::AnalysisChange,\n+    label::Label,\n     line_index::{LineCol, LineIndex},\n     search::SearchScope,\n     source_change::{FileSystemEdit, SourceChange, SourceFileEdit},\n     symbol_index::Query,\n     RootDatabase,\n };\n-pub use ra_ssr::SsrError;\n-pub use ra_text_edit::{Indel, TextEdit};\n+pub use ssr::SsrError;\n+pub use text_edit::{Indel, TextEdit};\n \n pub type Cancelable<T> = Result<T, Canceled>;\n \n-#[derive(Debug)]\n-pub struct Diagnostic {\n-    pub message: String,\n-    pub range: TextRange,\n-    pub severity: Severity,\n-    pub fix: Option<Fix>,\n-}\n-\n-#[derive(Debug)]\n-pub struct Fix {\n-    pub label: String,\n-    pub source_change: SourceChange,\n-}\n-\n-impl Fix {\n-    pub fn new(label: impl Into<String>, source_change: SourceChange) -> Self {\n-        let label = label.into();\n-        assert!(label.starts_with(char::is_uppercase) && !label.ends_with('.'));\n-        Self { label, source_change }\n-    }\n-}\n-\n /// Info associated with a text range.\n #[derive(Debug)]\n pub struct RangeInfo<T> {\n@@ -171,7 +149,7 @@ impl AnalysisHost {\n         self.db.collect_garbage();\n     }\n     /// NB: this clears the database\n-    pub fn per_query_memory_usage(&mut self) -> Vec<(String, ra_prof::Bytes)> {\n+    pub fn per_query_memory_usage(&mut self) -> Vec<(String, profile::Bytes)> {\n         self.db.per_query_memory_usage()\n     }\n     pub fn request_cancellation(&mut self) {\n@@ -474,7 +452,7 @@ impl Analysis {\n         config: &AssistConfig,\n         frange: FileRange,\n     ) -> Cancelable<Vec<ResolvedAssist>> {\n-        self.with_db(|db| ra_assists::Assist::resolved(db, config, frange))\n+        self.with_db(|db| assists::Assist::resolved(db, config, frange))\n     }\n \n     /// Computes unresolved assists (aka code actions aka intentions) for the given\n@@ -490,10 +468,10 @@ impl Analysis {\n     /// Computes the set of diagnostics for the given file.\n     pub fn diagnostics(\n         &self,\n+        config: &DiagnosticsConfig,\n         file_id: FileId,\n-        enable_experimental: bool,\n     ) -> Cancelable<Vec<Diagnostic>> {\n-        self.with_db(|db| diagnostics::diagnostics(db, file_id, enable_experimental))\n+        self.with_db(|db| diagnostics::diagnostics(db, config, file_id))\n     }\n \n     /// Returns the edit required to rename reference at the position to the new\n@@ -510,20 +488,23 @@ impl Analysis {\n         &self,\n         query: &str,\n         parse_only: bool,\n-        position: FilePosition,\n+        resolve_context: FilePosition,\n         selections: Vec<FileRange>,\n     ) -> Cancelable<Result<SourceChange, SsrError>> {\n         self.with_db(|db| {\n-            let edits = ssr::parse_search_replace(query, parse_only, db, position, selections)?;\n+            let rule: ssr::SsrRule = query.parse()?;\n+            let mut match_finder = ssr::MatchFinder::in_context(db, resolve_context, selections);\n+            match_finder.add_rule(rule)?;\n+            let edits = if parse_only { Vec::new() } else { match_finder.edits() };\n             Ok(SourceChange::from(edits))\n         })\n     }\n \n     /// Performs an operation on that may be Canceled.\n-    fn with_db<F: FnOnce(&RootDatabase) -> T + std::panic::UnwindSafe, T>(\n-        &self,\n-        f: F,\n-    ) -> Cancelable<T> {\n+    fn with_db<F, T>(&self, f: F) -> Cancelable<T>\n+    where\n+        F: FnOnce(&RootDatabase) -> T + std::panic::UnwindSafe,\n+    {\n         self.db.catch_canceled(f)\n     }\n }", "previous_filename": "crates/ra_ide/src/lib.rs"}, {"sha": "a826220e339537b14cb17b7f19d24ff618670d39", "filename": "crates/ide/src/link_rewrite.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Flink_rewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Flink_rewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flink_rewrite.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,7 +4,7 @@ use pulldown_cmark::{CowStr, Event, Options, Parser, Tag};\n use pulldown_cmark_to_cmark::{cmark_with_options, Options as CmarkOptions};\n \n use hir::resolve_doc_link;\n-use ra_ide_db::{defs::Definition, RootDatabase};\n+use ide_db::{defs::Definition, RootDatabase};\n \n /// Rewrite documentation links in markdown to point to an online host (e.g. docs.rs)\n pub fn rewrite_links(db: &RootDatabase, markdown: &str, definition: &Definition) -> String {", "previous_filename": "crates/ra_ide/src/link_rewrite.rs"}, {"sha": "60c193c40aba27b81111fcab406a69584de34f6d", "filename": "crates/ide/src/markup.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fmarkup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fmarkup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmarkup.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_ide/src/markup.rs"}, {"sha": "cb6abb0db948c451c5c39b5389761e6d09dbae88", "filename": "crates/ide/src/matching_brace.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmatching_brace.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,4 +1,4 @@\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode},\n     SourceFile, SyntaxKind, TextSize, T,\n };", "previous_filename": "crates/ra_ide/src/matching_brace.rs"}, {"sha": "235796dbce78af439cf419e3be09e5b0fa0e2abd", "filename": "crates/ide/src/mock_analysis.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmock_analysis.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,8 +1,8 @@\n //! FIXME: write short doc here\n use std::sync::Arc;\n \n-use ra_cfg::CfgOptions;\n-use ra_db::{CrateName, FileSet, SourceRoot, VfsPath};\n+use base_db::{CrateName, FileSet, SourceRoot, VfsPath};\n+use cfg::CfgOptions;\n use test_utils::{\n     extract_annotations, extract_range_or_offset, Fixture, RangeOrOffset, CURSOR_MARKER,\n };", "previous_filename": "crates/ra_ide/src/mock_analysis.rs"}, {"sha": "59ed2967cf2ac4c049e70f1e7b6768d457db1216", "filename": "crates/ide/src/parent_module.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fparent_module.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,7 @@\n+use base_db::{CrateId, FileId, FilePosition};\n use hir::Semantics;\n-use ra_db::{CrateId, FileId, FilePosition};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n+use ide_db::RootDatabase;\n+use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, AstNode},\n };\n@@ -63,8 +63,8 @@ pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n \n #[cfg(test)]\n mod tests {\n-    use ra_cfg::CfgOptions;\n-    use ra_db::Env;\n+    use base_db::Env;\n+    use cfg::CfgOptions;\n     use test_utils::mark;\n \n     use crate::{", "previous_filename": "crates/ra_ide/src/parent_module.rs"}, {"sha": "c5ab5a1d87ba18d94068ec8bceb6514525d998ec", "filename": "crates/ide/src/prime_caches.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fprime_caches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fprime_caches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fprime_caches.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_ide/src/prime_caches.rs"}, {"sha": "722c8f406e3094f5c8eb42a8c36076fc95787b1b", "filename": "crates/ide/src/references.rs", "status": "renamed", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -12,13 +12,12 @@\n mod rename;\n \n use hir::Semantics;\n-use ra_ide_db::{\n+use ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n     search::SearchScope,\n     RootDatabase,\n };\n-use ra_prof::profile;\n-use ra_syntax::{\n+use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n     AstNode, SyntaxKind, SyntaxNode, TextRange, TokenAtOffset,\n@@ -28,7 +27,7 @@ use crate::{display::TryToNav, FilePosition, FileRange, NavigationTarget, RangeI\n \n pub(crate) use self::rename::rename;\n \n-pub use ra_ide_db::search::{Reference, ReferenceAccess, ReferenceKind};\n+pub use ide_db::search::{Reference, ReferenceAccess, ReferenceKind};\n \n #[derive(Debug, Clone)]\n pub struct ReferenceSearchResult {\n@@ -90,7 +89,7 @@ pub(crate) fn find_all_refs(\n     position: FilePosition,\n     search_scope: Option<SearchScope>,\n ) -> Option<RangeInfo<ReferenceSearchResult>> {\n-    let _p = profile(\"find_all_refs\");\n+    let _p = profile::span(\"find_all_refs\");\n     let syntax = sema.parse(position.file_id).syntax().clone();\n \n     let (opt_name, search_kind) = if let Some(name) =\n@@ -107,7 +106,9 @@ pub(crate) fn find_all_refs(\n     let RangeInfo { range, info: def } = find_name(&sema, &syntax, position, opt_name)?;\n \n     let references = def\n-        .find_usages(sema, search_scope)\n+        .usages(sema)\n+        .set_scope(search_scope)\n+        .all()\n         .into_iter()\n         .filter(|r| search_kind == ReferenceKind::Other || search_kind == r.kind)\n         .collect();\n@@ -130,13 +131,13 @@ fn find_name(\n     opt_name: Option<ast::Name>,\n ) -> Option<RangeInfo<Definition>> {\n     if let Some(name) = opt_name {\n-        let def = classify_name(sema, &name)?.definition();\n+        let def = classify_name(sema, &name)?.definition(sema.db);\n         let range = name.syntax().text_range();\n         return Some(RangeInfo::new(range, def));\n     }\n     let name_ref =\n         sema.find_node_at_offset_with_descend::<ast::NameRef>(&syntax, position.offset)?;\n-    let def = classify_name_ref(sema, &name_ref)?.definition();\n+    let def = classify_name_ref(sema, &name_ref)?.definition(sema.db);\n     let range = name_ref.syntax().text_range();\n     Some(RangeInfo::new(range, def))\n }\n@@ -150,7 +151,7 @@ fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Optio\n     let stmt = find_node_at_offset::<ast::LetStmt>(syntax, range.start())?;\n     if stmt.initializer().is_some() {\n         let pat = stmt.pat()?;\n-        if let ast::Pat::BindPat(it) = pat {\n+        if let ast::Pat::IdentPat(it) = pat {\n             if it.mut_token().is_some() {\n                 return Some(ReferenceAccess::Write);\n             }\n@@ -290,7 +291,7 @@ fn main() {\n         );\n         check_result(\n             refs,\n-            \"i BIND_PAT FileId(1) 24..25 Other Write\",\n+            \"i IDENT_PAT FileId(1) 24..25 Other Write\",\n             &[\n                 \"FileId(1) 50..51 Other Write\",\n                 \"FileId(1) 54..55 Other Read\",\n@@ -316,7 +317,7 @@ fn bar() {\n         );\n         check_result(\n             refs,\n-            \"spam BIND_PAT FileId(1) 19..23 Other\",\n+            \"spam IDENT_PAT FileId(1) 19..23 Other\",\n             &[\"FileId(1) 34..38 Other Read\", \"FileId(1) 41..45 Other Read\"],\n         );\n     }\n@@ -330,7 +331,7 @@ fn foo(i : u32) -> u32 {\n }\n \"#,\n         );\n-        check_result(refs, \"i BIND_PAT FileId(1) 7..8 Other\", &[\"FileId(1) 29..30 Other Read\"]);\n+        check_result(refs, \"i IDENT_PAT FileId(1) 7..8 Other\", &[\"FileId(1) 29..30 Other Read\"]);\n     }\n \n     #[test]\n@@ -342,7 +343,7 @@ fn foo(i<|> : u32) -> u32 {\n }\n \"#,\n         );\n-        check_result(refs, \"i BIND_PAT FileId(1) 7..8 Other\", &[\"FileId(1) 29..30 Other Read\"]);\n+        check_result(refs, \"i IDENT_PAT FileId(1) 7..8 Other\", &[\"FileId(1) 29..30 Other Read\"]);\n     }\n \n     #[test]\n@@ -559,7 +560,7 @@ fn foo() {\n         );\n         check_result(\n             refs,\n-            \"i BIND_PAT FileId(1) 23..24 Other Write\",\n+            \"i IDENT_PAT FileId(1) 23..24 Other Write\",\n             &[\"FileId(1) 34..35 Other Write\", \"FileId(1) 38..39 Other Read\"],\n         );\n     }\n@@ -595,7 +596,7 @@ fn foo() {\n }\n \"#,\n         );\n-        check_result(refs, \"i BIND_PAT FileId(1) 19..20 Other\", &[\"FileId(1) 26..27 Other Write\"]);\n+        check_result(refs, \"i IDENT_PAT FileId(1) 19..20 Other\", &[\"FileId(1) 26..27 Other Write\"]);\n     }\n \n     #[test]", "previous_filename": "crates/ra_ide/src/references.rs"}, {"sha": "3016297633be58d2d1f12a5a8b96608fe7220105", "filename": "crates/ide/src/references/rename.rs", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,19 +1,19 @@\n //! FIXME: write short doc here\n \n+use base_db::SourceDatabaseExt;\n use hir::{Module, ModuleDef, ModuleSource, Semantics};\n-use ra_db::SourceDatabaseExt;\n-use ra_ide_db::{\n+use ide_db::{\n     defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n-use ra_syntax::{\n+use std::convert::TryInto;\n+use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, NameOwner},\n     lex_single_valid_syntax_kind, match_ast, AstNode, SyntaxKind, SyntaxNode, SyntaxToken,\n };\n-use ra_text_edit::TextEdit;\n-use std::convert::TryInto;\n use test_utils::mark;\n+use text_edit::TextEdit;\n \n use crate::{\n     references::find_all_refs, FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind,\n@@ -157,7 +157,7 @@ fn rename_to_self(\n     }\n     let first_param = params.params().next()?;\n     let mutable = match first_param.ty() {\n-        Some(ast::TypeRef::ReferenceType(rt)) => rt.mut_token().is_some(),\n+        Some(ast::Type::RefType(rt)) => rt.mut_token().is_some(),\n         _ => return None, // not renaming other types\n     };\n \n@@ -194,7 +194,7 @@ fn text_edit_from_self_param(\n     new_name: &str,\n ) -> Option<TextEdit> {\n     fn target_type_name(impl_def: &ast::Impl) -> Option<String> {\n-        if let Some(ast::TypeRef::PathType(p)) = impl_def.target_type() {\n+        if let Some(ast::Type::PathType(p)) = impl_def.self_ty() {\n             return Some(p.path()?.segment()?.name_ref()?.text().to_string());\n         }\n         None\n@@ -270,18 +270,18 @@ fn rename_reference(\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n-    use ra_text_edit::TextEditBuilder;\n+    use expect_test::{expect, Expect};\n     use stdx::trim_indent;\n     use test_utils::{assert_eq_text, mark};\n+    use text_edit::TextEdit;\n \n     use crate::{mock_analysis::analysis_and_position, FileId};\n \n     fn check(new_name: &str, ra_fixture_before: &str, ra_fixture_after: &str) {\n         let ra_fixture_after = &trim_indent(ra_fixture_after);\n         let (analysis, position) = analysis_and_position(ra_fixture_before);\n         let source_change = analysis.rename(position, new_name).unwrap();\n-        let mut text_edit_builder = TextEditBuilder::default();\n+        let mut text_edit_builder = TextEdit::builder();\n         let mut file_id: Option<FileId> = None;\n         if let Some(change) = source_change {\n             for edit in change.info.source_file_edits {", "previous_filename": "crates/ra_ide/src/references/rename.rs"}, {"sha": "4139f329eb654274124c70554d5a36f11735147d", "filename": "crates/ide/src/runnables.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,10 +1,10 @@\n use std::fmt;\n \n+use cfg::CfgExpr;\n use hir::{AsAssocItem, Attrs, HirFileId, InFile, Semantics};\n+use ide_db::RootDatabase;\n use itertools::Itertools;\n-use ra_cfg::CfgExpr;\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode, AttrsOwner, DocCommentsOwner, ModuleItemOwner, NameOwner},\n     match_ast, SyntaxNode,\n };\n@@ -268,7 +268,7 @@ fn has_test_function_or_multiple_test_submodules(module: &ast::Module) -> bool {\n \n #[cfg(test)]\n mod tests {\n-    use expect::{expect, Expect};\n+    use expect_test::{expect, Expect};\n \n     use crate::mock_analysis::analysis_and_position;\n ", "previous_filename": "crates/ra_ide/src/runnables.rs"}, {"sha": "c2370818180798cc28513e643a1fa2b233055121", "filename": "crates/ide/src/status.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fstatus.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,22 +1,22 @@\n use std::{fmt, iter::FromIterator, sync::Arc};\n \n-use hir::MacroFile;\n-use ra_db::{\n+use base_db::{\n     salsa::debug::{DebugQueryTable, TableEntry},\n     FileTextQuery, SourceRootId,\n };\n-use ra_ide_db::{\n+use hir::MacroFile;\n+use ide_db::{\n     symbol_index::{LibrarySymbolsQuery, SymbolIndex},\n     RootDatabase,\n };\n-use ra_prof::{memory_usage, Bytes};\n-use ra_syntax::{ast, Parse, SyntaxNode};\n+use profile::{memory_usage, Bytes};\n use rustc_hash::FxHashMap;\n+use syntax::{ast, Parse, SyntaxNode};\n \n use crate::FileId;\n \n fn syntax_tree_stats(db: &RootDatabase) -> SyntaxTreeStats {\n-    ra_db::ParseQuery.in_db(db).entries::<SyntaxTreeStats>()\n+    base_db::ParseQuery.in_db(db).entries::<SyntaxTreeStats>()\n }\n fn macro_syntax_tree_stats(db: &RootDatabase) -> SyntaxTreeStats {\n     hir::db::ParseMacroQuery.in_db(db).entries::<SyntaxTreeStats>()", "previous_filename": "crates/ra_ide/src/status.rs"}, {"sha": "25d6f7abd829057d2f61e3679e09d61325b01d08", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "renamed", "additions": 149, "deletions": 45, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,19 +4,18 @@ mod injection;\n #[cfg(test)]\n mod tests;\n \n-use hir::{Name, Semantics};\n-use ra_ide_db::{\n+use hir::{Name, Semantics, VariantDef};\n+use ide_db::{\n     defs::{classify_name, classify_name_ref, Definition, NameClass, NameRefClass},\n     RootDatabase,\n };\n-use ra_prof::profile;\n-use ra_syntax::{\n+use rustc_hash::FxHashMap;\n+use syntax::{\n     ast::{self, HasFormatSpecifier},\n     AstNode, AstToken, Direction, NodeOrToken, SyntaxElement,\n     SyntaxKind::*,\n     TextRange, WalkEvent, T,\n };\n-use rustc_hash::FxHashMap;\n \n use crate::FileId;\n \n@@ -46,7 +45,7 @@ pub(crate) fn highlight(\n     range_to_highlight: Option<TextRange>,\n     syntactic_name_ref_highlighting: bool,\n ) -> Vec<HighlightedRange> {\n-    let _p = profile(\"highlight\");\n+    let _p = profile::span(\"highlight\");\n     let sema = Semantics::new(db);\n \n     // Determine the root based on the given range.\n@@ -483,11 +482,21 @@ fn highlight_element(\n             };\n \n             match name_kind {\n+                Some(NameClass::ExternCrate(_)) => HighlightTag::Module.into(),\n                 Some(NameClass::Definition(def)) => {\n-                    highlight_name(db, def) | HighlightModifier::Definition\n+                    highlight_def(db, def) | HighlightModifier::Definition\n+                }\n+                Some(NameClass::ConstReference(def)) => highlight_def(db, def),\n+                Some(NameClass::FieldShorthand { field, .. }) => {\n+                    let mut h = HighlightTag::Field.into();\n+                    if let Definition::Field(field) = field {\n+                        if let VariantDef::Union(_) = field.parent_def(db) {\n+                            h |= HighlightModifier::Unsafe;\n+                        }\n+                    }\n+\n+                    h\n                 }\n-                Some(NameClass::ConstReference(def)) => highlight_name(db, def),\n-                Some(NameClass::FieldShorthand { .. }) => HighlightTag::Field.into(),\n                 None => highlight_name_by_syntax(name) | HighlightModifier::Definition,\n             }\n         }\n@@ -498,23 +507,41 @@ fn highlight_element(\n         }\n         NAME_REF => {\n             let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n-            match classify_name_ref(sema, &name_ref) {\n-                Some(name_kind) => match name_kind {\n-                    NameRefClass::Definition(def) => {\n-                        if let Definition::Local(local) = &def {\n-                            if let Some(name) = local.name(db) {\n-                                let shadow_count =\n-                                    bindings_shadow_count.entry(name.clone()).or_default();\n-                                binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+            highlight_func_by_name_ref(sema, &name_ref).unwrap_or_else(|| {\n+                match classify_name_ref(sema, &name_ref) {\n+                    Some(name_kind) => match name_kind {\n+                        NameRefClass::ExternCrate(_) => HighlightTag::Module.into(),\n+                        NameRefClass::Definition(def) => {\n+                            if let Definition::Local(local) = &def {\n+                                if let Some(name) = local.name(db) {\n+                                    let shadow_count =\n+                                        bindings_shadow_count.entry(name.clone()).or_default();\n+                                    binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+                                }\n+                            };\n+\n+                            let mut h = highlight_def(db, def);\n+\n+                            if let Some(parent) = name_ref.syntax().parent() {\n+                                if matches!(parent.kind(), FIELD_EXPR | RECORD_PAT_FIELD) {\n+                                    if let Definition::Field(field) = def {\n+                                        if let VariantDef::Union(_) = field.parent_def(db) {\n+                                            h |= HighlightModifier::Unsafe;\n+                                        }\n+                                    }\n+                                }\n                             }\n-                        };\n-                        highlight_name(db, def)\n+\n+                            h\n+                        }\n+                        NameRefClass::FieldShorthand { .. } => HighlightTag::Field.into(),\n+                    },\n+                    None if syntactic_name_ref_highlighting => {\n+                        highlight_name_ref_by_syntax(name_ref, sema)\n                     }\n-                    NameRefClass::FieldShorthand { .. } => HighlightTag::Field.into(),\n-                },\n-                None if syntactic_name_ref_highlighting => highlight_name_ref_by_syntax(name_ref),\n-                None => HighlightTag::UnresolvedReference.into(),\n-            }\n+                    None => HighlightTag::UnresolvedReference.into(),\n+                }\n+            })\n         }\n \n         // Simple token-based highlighting\n@@ -540,13 +567,24 @@ fn highlight_element(\n             }\n         }\n         p if p.is_punct() => match p {\n-            T![::] | T![->] | T![=>] | T![&] | T![..] | T![=] | T![@] => {\n-                HighlightTag::Operator.into()\n+            T![&] => {\n+                let h = HighlightTag::Operator.into();\n+                let is_unsafe = element\n+                    .parent()\n+                    .and_then(ast::RefExpr::cast)\n+                    .map(|ref_expr| sema.is_unsafe_ref_expr(&ref_expr))\n+                    .unwrap_or(false);\n+                if is_unsafe {\n+                    h | HighlightModifier::Unsafe\n+                } else {\n+                    h\n+                }\n             }\n+            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] => HighlightTag::Operator.into(),\n             T![!] if element.parent().and_then(ast::MacroCall::cast).is_some() => {\n                 HighlightTag::Macro.into()\n             }\n-            T![*] if element.parent().and_then(ast::PointerType::cast).is_some() => {\n+            T![*] if element.parent().and_then(ast::PtrType::cast).is_some() => {\n                 HighlightTag::Keyword.into()\n             }\n             T![*] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n@@ -577,7 +615,7 @@ fn highlight_element(\n             _ if element.parent().and_then(ast::RangePat::cast).is_some() => {\n                 HighlightTag::Operator.into()\n             }\n-            _ if element.parent().and_then(ast::DotDotPat::cast).is_some() => {\n+            _ if element.parent().and_then(ast::RestPat::cast).is_some() => {\n                 HighlightTag::Operator.into()\n             }\n             _ if element.parent().and_then(ast::Attr::cast).is_some() => {\n@@ -623,6 +661,18 @@ fn highlight_element(\n                         HighlightTag::SelfKeyword.into()\n                     }\n                 }\n+                T![ref] => element\n+                    .parent()\n+                    .and_then(ast::IdentPat::cast)\n+                    .and_then(|ident_pat| {\n+                        if sema.is_unsafe_ident_pat(&ident_pat) {\n+                            Some(HighlightModifier::Unsafe)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .map(|modifier| h | modifier)\n+                    .unwrap_or(h),\n                 _ => h,\n             }\n         }\n@@ -652,7 +702,42 @@ fn is_child_of_impl(element: &SyntaxElement) -> bool {\n     }\n }\n \n-fn highlight_name(db: &RootDatabase, def: Definition) -> Highlight {\n+fn highlight_func_by_name_ref(\n+    sema: &Semantics<RootDatabase>,\n+    name_ref: &ast::NameRef,\n+) -> Option<Highlight> {\n+    let method_call = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n+    highlight_method_call(sema, &method_call)\n+}\n+\n+fn highlight_method_call(\n+    sema: &Semantics<RootDatabase>,\n+    method_call: &ast::MethodCallExpr,\n+) -> Option<Highlight> {\n+    let func = sema.resolve_method_call(&method_call)?;\n+    let mut h = HighlightTag::Function.into();\n+    if func.is_unsafe(sema.db) || sema.is_unsafe_method_call(&method_call) {\n+        h |= HighlightModifier::Unsafe;\n+    }\n+    if let Some(self_param) = func.self_param(sema.db) {\n+        match self_param.access(sema.db) {\n+            hir::Access::Shared => (),\n+            hir::Access::Exclusive => h |= HighlightModifier::Mutable,\n+            hir::Access::Owned => {\n+                if let Some(receiver_ty) =\n+                    method_call.receiver().and_then(|it| sema.type_of_expr(&it))\n+                {\n+                    if !receiver_ty.is_copy(sema.db) {\n+                        h |= HighlightModifier::Consuming\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    Some(h)\n+}\n+\n+fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n     match def {\n         Definition::Macro(_) => HighlightTag::Macro,\n         Definition::Field(_) => HighlightTag::Field,\n@@ -677,6 +762,7 @@ fn highlight_name(db: &RootDatabase, def: Definition) -> Highlight {\n                 let mut h = Highlight::new(HighlightTag::Static);\n                 if s.is_mut(db) {\n                     h |= HighlightModifier::Mutable;\n+                    h |= HighlightModifier::Unsafe;\n                 }\n                 return h;\n             }\n@@ -717,24 +803,45 @@ fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n         CONST => HighlightTag::Constant,\n         STATIC => HighlightTag::Static,\n         VARIANT => HighlightTag::EnumVariant,\n-        BIND_PAT => HighlightTag::Local,\n+        IDENT_PAT => HighlightTag::Local,\n         _ => default,\n     };\n \n     tag.into()\n }\n \n-fn highlight_name_ref_by_syntax(name: ast::NameRef) -> Highlight {\n+fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabase>) -> Highlight {\n     let default = HighlightTag::UnresolvedReference;\n \n     let parent = match name.syntax().parent() {\n         Some(it) => it,\n         _ => return default.into(),\n     };\n \n-    let tag = match parent.kind() {\n-        METHOD_CALL_EXPR => HighlightTag::Function,\n-        FIELD_EXPR => HighlightTag::Field,\n+    match parent.kind() {\n+        METHOD_CALL_EXPR => {\n+            return ast::MethodCallExpr::cast(parent)\n+                .and_then(|method_call| highlight_method_call(sema, &method_call))\n+                .unwrap_or_else(|| HighlightTag::Function.into());\n+        }\n+        FIELD_EXPR => {\n+            let h = HighlightTag::Field;\n+            let is_union = ast::FieldExpr::cast(parent)\n+                .and_then(|field_expr| {\n+                    let field = sema.resolve_field(&field_expr)?;\n+                    Some(if let VariantDef::Union(_) = field.parent_def(sema.db) {\n+                        true\n+                    } else {\n+                        false\n+                    })\n+                })\n+                .unwrap_or(false);\n+            if is_union {\n+                h | HighlightModifier::Unsafe\n+            } else {\n+                h.into()\n+            }\n+        }\n         PATH_SEGMENT => {\n             let path = match parent.parent().and_then(ast::Path::cast) {\n                 Some(it) => it,\n@@ -758,18 +865,15 @@ fn highlight_name_ref_by_syntax(name: ast::NameRef) -> Highlight {\n             };\n \n             match parent.kind() {\n-                CALL_EXPR => HighlightTag::Function,\n-                _ => {\n-                    if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                        HighlightTag::Struct\n-                    } else {\n-                        HighlightTag::Constant\n-                    }\n+                CALL_EXPR => HighlightTag::Function.into(),\n+                _ => if name.text().chars().next().unwrap_or_default().is_uppercase() {\n+                    HighlightTag::Struct.into()\n+                } else {\n+                    HighlightTag::Constant\n                 }\n+                .into(),\n             }\n         }\n-        _ => default,\n-    };\n-\n-    tag.into()\n+        _ => default.into(),\n+    }\n }", "previous_filename": "crates/ra_ide/src/syntax_highlighting.rs"}, {"sha": "249368ff8142a3670197a40e2e9181cef25072b5", "filename": "crates/ide/src/syntax_highlighting/html.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhtml.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,8 +1,8 @@\n //! Renders a bit of code as HTML.\n \n+use base_db::SourceDatabase;\n use oorandom::Rand32;\n-use ra_db::SourceDatabase;\n-use ra_syntax::{AstNode, TextRange, TextSize};\n+use syntax::{AstNode, TextRange, TextSize};\n \n use crate::{syntax_highlighting::highlight, FileId, RootDatabase};\n ", "previous_filename": "crates/ra_ide/src/syntax_highlighting/html.rs"}, {"sha": "43f4e6feab309290af0ff95039f250de81f3b9fb", "filename": "crates/ide/src/syntax_highlighting/injection.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finjection.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -4,8 +4,8 @@ use std::{collections::BTreeMap, convert::TryFrom};\n \n use ast::{HasQuotes, HasStringValue};\n use hir::Semantics;\n-use ra_syntax::{ast, AstToken, SyntaxNode, SyntaxToken, TextRange, TextSize};\n-use stdx::SepBy;\n+use itertools::Itertools;\n+use syntax::{ast, AstToken, SyntaxNode, SyntaxToken, TextRange, TextSize};\n \n use crate::{\n     call_info::ActiveParameter, Analysis, Highlight, HighlightModifier, HighlightTag,\n@@ -129,8 +129,7 @@ pub(super) fn extract_doc_comments(\n \n             line[pos..].to_owned()\n         })\n-        .sep_by(\"\\n\")\n-        .to_string();\n+        .join(\"\\n\");\n \n     if doctest.is_empty() {\n         return None;", "previous_filename": "crates/ra_ide/src/syntax_highlighting/injection.rs"}, {"sha": "c1b817f06cca77712e4fee98d006f86216aa9c1d", "filename": "crates/ide/src/syntax_highlighting/tags.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftags.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -62,6 +62,7 @@ pub enum HighlightModifier {\n     Documentation,\n     Injected,\n     Mutable,\n+    Consuming,\n     Unsafe,\n }\n \n@@ -119,6 +120,7 @@ impl HighlightModifier {\n         HighlightModifier::Documentation,\n         HighlightModifier::Injected,\n         HighlightModifier::Mutable,\n+        HighlightModifier::Consuming,\n         HighlightModifier::Unsafe,\n     ];\n \n@@ -130,6 +132,7 @@ impl HighlightModifier {\n             HighlightModifier::Documentation => \"documentation\",\n             HighlightModifier::Injected => \"injected\",\n             HighlightModifier::Mutable => \"mutable\",\n+            HighlightModifier::Consuming => \"consuming\",\n             HighlightModifier::Unsafe => \"unsafe\",\n         }\n     }", "previous_filename": "crates/ra_ide/src/syntax_highlighting/tags.rs"}, {"sha": "1c3fea0588b8457a1feeee4574940badd9ae41ee", "filename": "crates/ide/src/syntax_highlighting/tests.rs", "status": "renamed", "additions": 115, "deletions": 11, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftests.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n use std::fs;\n \n-use expect::{expect_file, ExpectFile};\n+use expect_test::{expect_file, ExpectFile};\n use test_utils::project_dir;\n \n use crate::{mock_analysis::single_file, FileRange, TextRange};\n@@ -9,6 +9,15 @@ use crate::{mock_analysis::single_file, FileRange, TextRange};\n fn test_highlighting() {\n     check_highlighting(\n         r#\"\n+use inner::{self as inner_mod};\n+mod inner {}\n+\n+// Needed for function consuming vs normal\n+pub mod marker {\n+    #[lang = \"copy\"]\n+    pub trait Copy {}\n+}\n+\n #[derive(Clone, Debug)]\n struct Foo {\n     pub x: i32,\n@@ -33,6 +42,29 @@ impl Foo {\n     fn qux(&mut self) {\n         self.x = 0;\n     }\n+\n+    fn quop(&self) -> i32 {\n+        self.x\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+struct FooCopy {\n+    x: u32,\n+}\n+\n+impl FooCopy {\n+    fn baz(self) -> u32 {\n+        self.x\n+    }\n+\n+    fn qux(&mut self) {\n+        self.x = 0;\n+    }\n+\n+    fn quop(&self) -> u32 {\n+        self.x\n+    }\n }\n \n static mut STATIC_MUT: i32 = 0;\n@@ -84,6 +116,16 @@ fn main() {\n     let Foo { x: z, y } = Foo { x: z, y };\n \n     y;\n+\n+    let mut foo = Foo { x, y: x };\n+    foo.quop();\n+    foo.qux();\n+    foo.baz();\n+\n+    let mut copy = FooCopy { x };\n+    copy.quop();\n+    copy.qux();\n+    copy.baz();\n }\n \n enum Option<T> {\n@@ -102,7 +144,7 @@ impl<T> Option<T> {\n }\n \"#\n         .trim(),\n-        expect_file![\"crates/ra_ide/test_data/highlighting.html\"],\n+        expect_file![\"crates/ide/test_data/highlighting.html\"],\n         false,\n     );\n }\n@@ -125,14 +167,14 @@ fn bar() {\n }\n \"#\n         .trim(),\n-        expect_file![\"crates/ra_ide/test_data/rainbow_highlighting.html\"],\n+        expect_file![\"crates/ide/test_data/rainbow_highlighting.html\"],\n         true,\n     );\n }\n \n #[test]\n fn accidentally_quadratic() {\n-    let file = project_dir().join(\"crates/ra_syntax/test_data/accidentally_quadratic\");\n+    let file = project_dir().join(\"crates/syntax/test_data/accidentally_quadratic\");\n     let src = fs::read_to_string(file).unwrap();\n \n     let (analysis, file_id) = single_file(&src);\n@@ -178,7 +220,7 @@ fn main() {\n     );\n }\"##\n         .trim(),\n-        expect_file![\"crates/ra_ide/test_data/highlight_injection.html\"],\n+        expect_file![\"crates/ide/test_data/highlight_injection.html\"],\n         false,\n     );\n }\n@@ -261,7 +303,7 @@ fn main() {\n     println!(\"{\u043d\u0438\u0447\u043e\u0441\u0438}\", \u043d\u0438\u0447\u043e\u0441\u0438 = 92);\n }\"#\n         .trim(),\n-        expect_file![\"crates/ra_ide/test_data/highlight_strings.html\"],\n+        expect_file![\"crates/ide/test_data/highlight_strings.html\"],\n         false,\n     );\n }\n@@ -272,24 +314,69 @@ fn test_unsafe_highlighting() {\n         r#\"\n unsafe fn unsafe_fn() {}\n \n+union Union {\n+    a: u32,\n+    b: f32,\n+}\n+\n struct HasUnsafeFn;\n \n impl HasUnsafeFn {\n     unsafe fn unsafe_method(&self) {}\n }\n \n+struct TypeForStaticMut {\n+    a: u8\n+}\n+\n+static mut global_mut: TypeForStaticMut = TypeForStaticMut { a: 0 };\n+\n+#[repr(packed)]\n+struct Packed {\n+    a: u16,\n+}\n+\n+trait DoTheAutoref {\n+    fn calls_autoref(&self);\n+}\n+\n+impl DoTheAutoref for u16 {\n+    fn calls_autoref(&self) {}\n+}\n+\n fn main() {\n-    let x = &5 as *const usize;\n+    let x = &5 as *const _ as *const usize;\n+    let u = Union { b: 0 };\n     unsafe {\n+        // unsafe fn and method calls\n         unsafe_fn();\n+        let b = u.b;\n+        match u {\n+            Union { b: 0 } => (),\n+            Union { a } => (),\n+        }\n         HasUnsafeFn.unsafe_method();\n-        let y = *(x);\n-        let z = -x;\n+\n+        // unsafe deref\n+        let y = *x;\n+\n+        // unsafe access to a static mut\n+        let a = global_mut.a;\n+\n+        // unsafe ref of packed fields\n+        let packed = Packed { a: 0 };\n+        let a = &packed.a;\n+        let ref a = packed.a;\n+        let Packed { ref a } = packed;\n+        let Packed { a: ref _a } = packed;\n+\n+        // unsafe auto ref of packed field\n+        packed.a.calls_autoref();\n     }\n }\n \"#\n         .trim(),\n-        expect_file![\"crates/ra_ide/test_data/highlight_unsafe.html\"],\n+        expect_file![\"crates/ide/test_data/highlight_unsafe.html\"],\n         false,\n     );\n }\n@@ -365,7 +452,24 @@ macro_rules! noop {\n }\n \"#\n         .trim(),\n-        expect_file![\"crates/ra_ide/test_data/highlight_doctest.html\"],\n+        expect_file![\"crates/ide/test_data/highlight_doctest.html\"],\n+        false,\n+    );\n+}\n+\n+#[test]\n+fn test_extern_crate() {\n+    check_highlighting(\n+        r#\"\n+        //- /main.rs\n+        extern crate std;\n+        extern crate alloc as abc;\n+        //- /std/lib.rs\n+        pub struct S;\n+        //- /alloc/lib.rs\n+        pub struct A\n+        \"#,\n+        expect_file![\"crates/ide/test_data/highlight_extern_crate.html\"],\n         false,\n     );\n }", "previous_filename": "crates/ra_ide/src/syntax_highlighting/tests.rs"}, {"sha": "f8004495960c83e3a47dda5fac2bf41642543b3b", "filename": "crates/ide/src/syntax_tree.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_tree.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,6 +1,6 @@\n-use ra_db::{FileId, SourceDatabase};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n+use base_db::{FileId, SourceDatabase};\n+use ide_db::RootDatabase;\n+use syntax::{\n     algo, AstNode, NodeOrToken, SourceFile,\n     SyntaxKind::{RAW_STRING, STRING},\n     SyntaxToken, TextRange, TextSize,", "previous_filename": "crates/ra_ide/src/syntax_tree.rs"}, {"sha": "899ce5f26527058c5e97473c7dfccd63f7fc2467", "filename": "crates/ide/src/typing.rs", "status": "renamed", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ftyping.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -15,18 +15,17 @@\n \n mod on_enter;\n \n-use ra_db::{FilePosition, SourceDatabase};\n-use ra_fmt::leading_indent;\n-use ra_ide_db::{source_change::SourceFileEdit, RootDatabase};\n-use ra_syntax::{\n+use base_db::{FilePosition, SourceDatabase};\n+use ide_db::{source_change::SourceFileEdit, RootDatabase};\n+use syntax::{\n     algo::find_node_at_offset,\n-    ast::{self, AstToken},\n+    ast::{self, edit::IndentLevel, AstToken},\n     AstNode, SourceFile,\n     SyntaxKind::{FIELD_EXPR, METHOD_CALL_EXPR},\n     TextRange, TextSize,\n };\n \n-use ra_text_edit::TextEdit;\n+use text_edit::TextEdit;\n \n use crate::SourceChange;\n \n@@ -104,7 +103,7 @@ fn on_dot_typed(file: &SourceFile, offset: TextSize) -> Option<TextEdit> {\n     if !matches!(parent.kind(), FIELD_EXPR | METHOD_CALL_EXPR) {\n         return None;\n     }\n-    let prev_indent = leading_indent(&parent)?;\n+    let prev_indent = IndentLevel::from_node(&parent);\n     let target_indent = format!(\"    {}\", prev_indent);\n     let target_indent_len = TextSize::of(&target_indent);\n     if current_indent_len == target_indent_len {", "previous_filename": "crates/ra_ide/src/typing.rs"}, {"sha": "f7d46146c50923b044e8f797afb00c3c9108c1d3", "filename": "crates/ide/src/typing/on_enter.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ftyping%2Fon_enter.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,16 +1,16 @@\n //! Handles the `Enter` key press. At the momently, this only continues\n //! comments, but should handle indent some time in the future as well.\n \n-use ra_db::{FilePosition, SourceDatabase};\n-use ra_ide_db::RootDatabase;\n-use ra_syntax::{\n+use base_db::{FilePosition, SourceDatabase};\n+use ide_db::RootDatabase;\n+use syntax::{\n     ast::{self, AstToken},\n     AstNode, SmolStr, SourceFile,\n     SyntaxKind::*,\n     SyntaxToken, TextRange, TextSize, TokenAtOffset,\n };\n-use ra_text_edit::TextEdit;\n use test_utils::mark;\n+use text_edit::TextEdit;\n \n // Feature: On Enter\n //", "previous_filename": "crates/ra_ide/src/typing/on_enter.rs"}, {"sha": "6322d404fba5c6c7cab62278eecce9b22af4b45c", "filename": "crates/ide/test_data/highlight_doctest.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlight_doctest.html", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlight_doctest.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Ftest_data%2Fhighlight_doctest.html?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_ide/test_data/highlight_doctest.html"}, {"sha": "800d894c7693d2a4649dfe9c691219c6833e4d01", "filename": "crates/ide/test_data/highlight_extern_crate.html", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlight_extern_crate.html", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlight_extern_crate.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Ftest_data%2Fhighlight_extern_crate.html?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -0,0 +1,40 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.documentation      { color: #629755; }\n+.injected           { opacity: 0.65 ; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.value_param        { color: #DCDCCC; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+.escape_sequence    { color: #94BFF3; }\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.control            { font-style: italic; }\n+\n+.unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n+</style>\n+<pre><code><span class=\"keyword\">extern</span> <span class=\"keyword\">crate</span> <span class=\"module\">std</span><span class=\"punctuation\">;</span>\n+<span class=\"keyword\">extern</span> <span class=\"keyword\">crate</span> <span class=\"module\">alloc</span> <span class=\"keyword\">as</span> <span class=\"module\">abc</span><span class=\"punctuation\">;</span>\n+</code></pre>\n\\ No newline at end of file"}, {"sha": "18addd00d283c68b13aa8dbd99b5b964c3e1d0c1", "filename": "crates/ide/test_data/highlight_injection.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlight_injection.html", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlight_injection.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Ftest_data%2Fhighlight_injection.html?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_ide/test_data/highlight_injection.html"}, {"sha": "1b681b2c6b53b5e88c49766605429f4c832ff1c7", "filename": "crates/ide/test_data/highlight_strings.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Ftest_data%2Fhighlight_strings.html?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_ide/test_data/highlight_strings.html"}, {"sha": "552fea668923f1f9fd9e9a17973d7575885bb90b", "filename": "crates/ide/test_data/highlight_unsafe.html", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlight_unsafe.html", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlight_unsafe.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Ftest_data%2Fhighlight_unsafe.html?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -0,0 +1,99 @@\n+\n+<style>\n+body                { margin: 0; }\n+pre                 { color: #DCDCCC; background: #3F3F3F; font-size: 22px; padding: 0.4em; }\n+\n+.lifetime           { color: #DFAF8F; font-style: italic; }\n+.comment            { color: #7F9F7F; }\n+.documentation      { color: #629755; }\n+.injected           { opacity: 0.65 ; }\n+.struct, .enum      { color: #7CB8BB; }\n+.enum_variant       { color: #BDE0F3; }\n+.string_literal     { color: #CC9393; }\n+.field              { color: #94BFF3; }\n+.function           { color: #93E0E3; }\n+.function.unsafe    { color: #BC8383; }\n+.operator.unsafe    { color: #BC8383; }\n+.parameter          { color: #94BFF3; }\n+.text               { color: #DCDCCC; }\n+.type               { color: #7CB8BB; }\n+.builtin_type       { color: #8CD0D3; }\n+.type_param         { color: #DFAF8F; }\n+.attribute          { color: #94BFF3; }\n+.numeric_literal    { color: #BFEBBF; }\n+.bool_literal       { color: #BFE6EB; }\n+.macro              { color: #94BFF3; }\n+.module             { color: #AFD8AF; }\n+.value_param        { color: #DCDCCC; }\n+.variable           { color: #DCDCCC; }\n+.format_specifier   { color: #CC696B; }\n+.mutable            { text-decoration: underline; }\n+.escape_sequence    { color: #94BFF3; }\n+.keyword            { color: #F0DFAF; font-weight: bold; }\n+.keyword.unsafe     { color: #BC8383; font-weight: bold; }\n+.control            { font-style: italic; }\n+\n+.unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n+</style>\n+<pre><code><span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function declaration unsafe\">unsafe_fn</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">union</span> <span class=\"union declaration\">Union</span> <span class=\"punctuation\">{</span>\n+    <span class=\"field declaration\">a</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">u32</span><span class=\"punctuation\">,</span>\n+    <span class=\"field declaration\">b</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">f32</span><span class=\"punctuation\">,</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">struct</span> <span class=\"struct declaration\">HasUnsafeFn</span><span class=\"punctuation\">;</span>\n+\n+<span class=\"keyword\">impl</span> <span class=\"struct\">HasUnsafeFn</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword unsafe\">unsafe</span> <span class=\"keyword\">fn</span> <span class=\"function declaration unsafe\">unsafe_method</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">struct</span> <span class=\"struct declaration\">TypeForStaticMut</span> <span class=\"punctuation\">{</span>\n+    <span class=\"field declaration\">a</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">u8</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">static</span> <span class=\"keyword\">mut</span> <span class=\"static declaration mutable unsafe\">global_mut</span><span class=\"punctuation\">:</span> <span class=\"struct\">TypeForStaticMut</span> <span class=\"operator\">=</span> <span class=\"struct\">TypeForStaticMut</span> <span class=\"punctuation\">{</span> <span class=\"field\">a</span><span class=\"punctuation\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n+\n+<span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">repr</span><span class=\"punctuation\">(</span><span class=\"attribute\">packed</span><span class=\"punctuation\">)</span><span class=\"attribute\">]</span>\n+<span class=\"keyword\">struct</span> <span class=\"struct declaration\">Packed</span> <span class=\"punctuation\">{</span>\n+    <span class=\"field declaration\">a</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">u16</span><span class=\"punctuation\">,</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">trait</span> <span class=\"trait declaration\">DoTheAutoref</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">calls_autoref</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">impl</span> <span class=\"trait\">DoTheAutoref</span> <span class=\"keyword\">for</span> <span class=\"builtin_type\">u16</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">calls_autoref</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">fn</span> <span class=\"function declaration\">main</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">x</span> <span class=\"operator\">=</span> <span class=\"operator\">&</span><span class=\"numeric_literal\">5</span> <span class=\"keyword\">as</span> <span class=\"keyword\">*</span><span class=\"keyword\">const</span> <span class=\"punctuation\">_</span> <span class=\"keyword\">as</span> <span class=\"keyword\">*</span><span class=\"keyword\">const</span> <span class=\"builtin_type\">usize</span><span class=\"punctuation\">;</span>\n+    <span class=\"keyword\">let</span> <span class=\"variable declaration\">u</span> <span class=\"operator\">=</span> <span class=\"union\">Union</span> <span class=\"punctuation\">{</span> <span class=\"field\">b</span><span class=\"punctuation\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n+    <span class=\"keyword unsafe\">unsafe</span> <span class=\"punctuation\">{</span>\n+        <span class=\"comment\">// unsafe fn and method calls</span>\n+        <span class=\"function unsafe\">unsafe_fn</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">b</span> <span class=\"operator\">=</span> <span class=\"variable\">u</span><span class=\"punctuation\">.</span><span class=\"field unsafe\">b</span><span class=\"punctuation\">;</span>\n+        <span class=\"keyword control\">match</span> <span class=\"variable\">u</span> <span class=\"punctuation\">{</span>\n+            <span class=\"union\">Union</span> <span class=\"punctuation\">{</span> <span class=\"field unsafe\">b</span><span class=\"punctuation\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"punctuation\">}</span> <span class=\"operator\">=&gt;</span> <span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span>\n+            <span class=\"union\">Union</span> <span class=\"punctuation\">{</span> <span class=\"field unsafe\">a</span> <span class=\"punctuation\">}</span> <span class=\"operator\">=&gt;</span> <span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">,</span>\n+        <span class=\"punctuation\">}</span>\n+        <span class=\"struct\">HasUnsafeFn</span><span class=\"punctuation\">.</span><span class=\"function unsafe\">unsafe_method</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+\n+        <span class=\"comment\">// unsafe deref</span>\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">y</span> <span class=\"operator\">=</span> <span class=\"operator unsafe\">*</span><span class=\"variable\">x</span><span class=\"punctuation\">;</span>\n+\n+        <span class=\"comment\">// unsafe access to a static mut</span>\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"static mutable unsafe\">global_mut</span><span class=\"punctuation\">.</span><span class=\"field\">a</span><span class=\"punctuation\">;</span>\n+\n+        <span class=\"comment\">// unsafe ref of packed fields</span>\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">packed</span> <span class=\"operator\">=</span> <span class=\"struct\">Packed</span> <span class=\"punctuation\">{</span> <span class=\"field\">a</span><span class=\"punctuation\">:</span> <span class=\"numeric_literal\">0</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n+        <span class=\"keyword\">let</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"operator unsafe\">&</span><span class=\"variable\">packed</span><span class=\"punctuation\">.</span><span class=\"field\">a</span><span class=\"punctuation\">;</span>\n+        <span class=\"keyword\">let</span> <span class=\"keyword unsafe\">ref</span> <span class=\"variable declaration\">a</span> <span class=\"operator\">=</span> <span class=\"variable\">packed</span><span class=\"punctuation\">.</span><span class=\"field\">a</span><span class=\"punctuation\">;</span>\n+        <span class=\"keyword\">let</span> <span class=\"struct\">Packed</span> <span class=\"punctuation\">{</span> <span class=\"keyword unsafe\">ref</span> <span class=\"field\">a</span> <span class=\"punctuation\">}</span> <span class=\"operator\">=</span> <span class=\"variable\">packed</span><span class=\"punctuation\">;</span>\n+        <span class=\"keyword\">let</span> <span class=\"struct\">Packed</span> <span class=\"punctuation\">{</span> <span class=\"field\">a</span><span class=\"punctuation\">:</span> <span class=\"keyword unsafe\">ref</span> <span class=\"variable declaration\">_a</span> <span class=\"punctuation\">}</span> <span class=\"operator\">=</span> <span class=\"variable\">packed</span><span class=\"punctuation\">;</span>\n+\n+        <span class=\"comment\">// unsafe auto ref of packed field</span>\n+        <span class=\"variable\">packed</span><span class=\"punctuation\">.</span><span class=\"field\">a</span><span class=\"punctuation\">.</span><span class=\"function unsafe\">calls_autoref</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+    <span class=\"punctuation\">}</span>\n+<span class=\"punctuation\">}</span></code></pre>\n\\ No newline at end of file"}, {"sha": "d0df2e0ec04b8ed21c5870147b16f59d4f2189c2", "filename": "crates/ide/test_data/highlighting.html", "status": "renamed", "additions": 45, "deletions": 3, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Fhighlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Ftest_data%2Fhighlighting.html?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -35,7 +35,16 @@\n \n .unresolved_reference { color: #FC5555; text-decoration: wavy underline; }\n </style>\n-<pre><code><span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">derive</span><span class=\"punctuation\">(</span><span class=\"attribute\">Clone</span><span class=\"punctuation\">,</span><span class=\"attribute\"> Debug</span><span class=\"punctuation\">)</span><span class=\"attribute\">]</span>\n+<pre><code><span class=\"keyword\">use</span> <span class=\"module\">inner</span><span class=\"operator\">::</span><span class=\"punctuation\">{</span><span class=\"self_keyword\">self</span> <span class=\"keyword\">as</span> <span class=\"module declaration\">inner_mod</span><span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n+<span class=\"keyword\">mod</span> <span class=\"module declaration\">inner</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+\n+<span class=\"comment\">// Needed for function consuming vs normal</span>\n+<span class=\"keyword\">pub</span> <span class=\"keyword\">mod</span> <span class=\"module declaration\">marker</span> <span class=\"punctuation\">{</span>\n+    <span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">lang</span><span class=\"attribute\"> </span><span class=\"operator\">=</span><span class=\"attribute\"> </span><span class=\"string_literal\">\"copy\"</span><span class=\"attribute\">]</span>\n+    <span class=\"keyword\">pub</span> <span class=\"keyword\">trait</span> <span class=\"trait declaration\">Copy</span> <span class=\"punctuation\">{</span><span class=\"punctuation\">}</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">derive</span><span class=\"punctuation\">(</span><span class=\"attribute\">Clone</span><span class=\"punctuation\">,</span><span class=\"attribute\"> Debug</span><span class=\"punctuation\">)</span><span class=\"attribute\">]</span>\n <span class=\"keyword\">struct</span> <span class=\"struct declaration\">Foo</span> <span class=\"punctuation\">{</span>\n     <span class=\"keyword\">pub</span> <span class=\"field declaration\">x</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">i32</span><span class=\"punctuation\">,</span>\n     <span class=\"keyword\">pub</span> <span class=\"field declaration\">y</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">i32</span><span class=\"punctuation\">,</span>\n@@ -59,9 +68,32 @@\n     <span class=\"keyword\">fn</span> <span class=\"function declaration\">qux</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n         <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"punctuation\">;</span>\n     <span class=\"punctuation\">}</span>\n+\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">quop</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">i32</span> <span class=\"punctuation\">{</span>\n+        <span class=\"self_keyword\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span>\n+    <span class=\"punctuation\">}</span>\n <span class=\"punctuation\">}</span>\n \n-<span class=\"keyword\">static</span> <span class=\"keyword\">mut</span> <span class=\"static declaration mutable\">STATIC_MUT</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">i32</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"punctuation\">;</span>\n+<span class=\"attribute\">#</span><span class=\"attribute\">[</span><span class=\"function attribute\">derive</span><span class=\"punctuation\">(</span><span class=\"attribute\">Copy</span><span class=\"punctuation\">,</span><span class=\"attribute\"> Clone</span><span class=\"punctuation\">)</span><span class=\"attribute\">]</span>\n+<span class=\"keyword\">struct</span> <span class=\"struct declaration\">FooCopy</span> <span class=\"punctuation\">{</span>\n+    <span class=\"field declaration\">x</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">u32</span><span class=\"punctuation\">,</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">impl</span> <span class=\"struct\">FooCopy</span> <span class=\"punctuation\">{</span>\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">baz</span><span class=\"punctuation\">(</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">u32</span> <span class=\"punctuation\">{</span>\n+        <span class=\"self_keyword\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span>\n+    <span class=\"punctuation\">}</span>\n+\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">qux</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"keyword\">mut</span> <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">)</span> <span class=\"punctuation\">{</span>\n+        <span class=\"self_keyword mutable\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"punctuation\">;</span>\n+    <span class=\"punctuation\">}</span>\n+\n+    <span class=\"keyword\">fn</span> <span class=\"function declaration\">quop</span><span class=\"punctuation\">(</span><span class=\"operator\">&</span><span class=\"self_keyword\">self</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"builtin_type\">u32</span> <span class=\"punctuation\">{</span>\n+        <span class=\"self_keyword\">self</span><span class=\"punctuation\">.</span><span class=\"field\">x</span>\n+    <span class=\"punctuation\">}</span>\n+<span class=\"punctuation\">}</span>\n+\n+<span class=\"keyword\">static</span> <span class=\"keyword\">mut</span> <span class=\"static declaration mutable unsafe\">STATIC_MUT</span><span class=\"punctuation\">:</span> <span class=\"builtin_type\">i32</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">0</span><span class=\"punctuation\">;</span>\n \n <span class=\"keyword\">fn</span> <span class=\"function declaration\">foo</span><span class=\"punctuation\">&lt;</span><span class=\"lifetime declaration\">'a</span><span class=\"punctuation\">,</span> <span class=\"type_param declaration\">T</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span> <span class=\"operator\">-&gt;</span> <span class=\"type_param\">T</span> <span class=\"punctuation\">{</span>\n     <span class=\"function\">foo</span><span class=\"operator\">::</span><span class=\"punctuation\">&lt;</span><span class=\"lifetime\">'a</span><span class=\"punctuation\">,</span> <span class=\"builtin_type\">i32</span><span class=\"punctuation\">&gt;</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span>\n@@ -94,7 +126,7 @@\n     <span class=\"punctuation\">}</span>\n     <span class=\"keyword unsafe\">unsafe</span> <span class=\"punctuation\">{</span>\n         <span class=\"variable mutable\">vec</span><span class=\"punctuation\">.</span><span class=\"unresolved_reference\">set_len</span><span class=\"punctuation\">(</span><span class=\"numeric_literal\">0</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n-        <span class=\"static mutable\">STATIC_MUT</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">1</span><span class=\"punctuation\">;</span>\n+        <span class=\"static mutable unsafe\">STATIC_MUT</span> <span class=\"operator\">=</span> <span class=\"numeric_literal\">1</span><span class=\"punctuation\">;</span>\n     <span class=\"punctuation\">}</span>\n \n     <span class=\"keyword control\">for</span> <span class=\"variable declaration\">e</span> <span class=\"keyword control\">in</span> <span class=\"variable mutable\">vec</span> <span class=\"punctuation\">{</span>\n@@ -110,6 +142,16 @@\n     <span class=\"keyword\">let</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span> <span class=\"field\">x</span><span class=\"punctuation\">:</span> <span class=\"variable declaration\">z</span><span class=\"punctuation\">,</span> <span class=\"field\">y</span> <span class=\"punctuation\">}</span> <span class=\"operator\">=</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span> <span class=\"field\">x</span><span class=\"punctuation\">:</span> <span class=\"variable\">z</span><span class=\"punctuation\">,</span> <span class=\"field\">y</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n \n     <span class=\"variable\">y</span><span class=\"punctuation\">;</span>\n+\n+    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">foo</span> <span class=\"operator\">=</span> <span class=\"struct\">Foo</span> <span class=\"punctuation\">{</span> <span class=\"field\">x</span><span class=\"punctuation\">,</span> <span class=\"field\">y</span><span class=\"punctuation\">:</span> <span class=\"variable mutable\">x</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n+    <span class=\"variable mutable\">foo</span><span class=\"punctuation\">.</span><span class=\"function\">quop</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+    <span class=\"variable mutable\">foo</span><span class=\"punctuation\">.</span><span class=\"function mutable\">qux</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+    <span class=\"variable mutable\">foo</span><span class=\"punctuation\">.</span><span class=\"function consuming\">baz</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+\n+    <span class=\"keyword\">let</span> <span class=\"keyword\">mut</span> <span class=\"variable declaration mutable\">copy</span> <span class=\"operator\">=</span> <span class=\"struct\">FooCopy</span> <span class=\"punctuation\">{</span> <span class=\"field\">x</span> <span class=\"punctuation\">}</span><span class=\"punctuation\">;</span>\n+    <span class=\"variable mutable\">copy</span><span class=\"punctuation\">.</span><span class=\"function\">quop</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+    <span class=\"variable mutable\">copy</span><span class=\"punctuation\">.</span><span class=\"function mutable\">qux</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n+    <span class=\"variable mutable\">copy</span><span class=\"punctuation\">.</span><span class=\"function\">baz</span><span class=\"punctuation\">(</span><span class=\"punctuation\">)</span><span class=\"punctuation\">;</span>\n <span class=\"punctuation\">}</span>\n \n <span class=\"keyword\">enum</span> <span class=\"enum declaration\">Option</span><span class=\"punctuation\">&lt;</span><span class=\"type_param declaration\">T</span><span class=\"punctuation\">&gt;</span> <span class=\"punctuation\">{</span>", "previous_filename": "crates/ra_ide/test_data/highlighting.html"}, {"sha": "401e87a73d3bc12d0e464d1f30b5caff9d03f59c", "filename": "crates/ide/test_data/rainbow_highlighting.html", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Frainbow_highlighting.html", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide%2Ftest_data%2Frainbow_highlighting.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Ftest_data%2Frainbow_highlighting.html?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_ide/test_data/rainbow_highlighting.html"}, {"sha": "692fb64153bba3a2af71388cd7a8aea55e9abcc5", "filename": "crates/ide_db/Cargo.toml", "status": "renamed", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n [package]\n-edition = \"2018\"\n-name = \"ra_ide_db\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n+name = \"ide_db\"\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false\n@@ -20,13 +20,11 @@ once_cell = \"1.3.1\"\n either = \"1.5.3\"\n \n stdx = { path = \"../stdx\" }\n-\n-ra_syntax = { path = \"../ra_syntax\" }\n-ra_text_edit = { path = \"../ra_text_edit\" }\n-ra_db = { path = \"../ra_db\" }\n-ra_prof = { path = \"../ra_prof\" }\n+syntax = { path = \"../syntax\" }\n+text_edit = { path = \"../text_edit\" }\n+base_db = { path = \"../base_db\" }\n+profile = { path = \"../profile\" }\n test_utils = { path = \"../test_utils\" }\n-\n-# ra_ide should depend only on the top-level `hir` package. if you need\n+# ide should depend only on the top-level `hir` package. if you need\n # something from some `hir_xxx` subpackage, reexport the API via `hir`.\n-hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n+hir = { path = \"../hir\" }", "previous_filename": "crates/ra_ide_db/Cargo.toml"}, {"sha": "8b4fd7ab84981f21b5ee7c93fc6cd54e1c401f1e", "filename": "crates/ide_db/src/change.rs", "status": "renamed", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fchange.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,11 +3,11 @@\n \n use std::{fmt, sync::Arc, time};\n \n-use ra_db::{\n+use base_db::{\n     salsa::{Database, Durability, SweepStrategy},\n     CrateGraph, FileId, SourceDatabase, SourceDatabaseExt, SourceRoot, SourceRootId,\n };\n-use ra_prof::{memory_usage, profile, Bytes};\n+use profile::{memory_usage, Bytes};\n use rustc_hash::FxHashSet;\n \n use crate::{symbol_index::SymbolsDatabase, RootDatabase};\n@@ -85,12 +85,12 @@ const GC_COOLDOWN: time::Duration = time::Duration::from_millis(100);\n \n impl RootDatabase {\n     pub fn request_cancellation(&mut self) {\n-        let _p = profile(\"RootDatabase::request_cancellation\");\n+        let _p = profile::span(\"RootDatabase::request_cancellation\");\n         self.salsa_runtime_mut().synthetic_write(Durability::LOW);\n     }\n \n     pub fn apply_change(&mut self, change: AnalysisChange) {\n-        let _p = profile(\"RootDatabase::apply_change\");\n+        let _p = profile::span(\"RootDatabase::apply_change\");\n         self.request_cancellation();\n         log::info!(\"apply_change {:?}\", change);\n         if let Some(roots) = change.roots {\n@@ -141,12 +141,12 @@ impl RootDatabase {\n             return;\n         }\n \n-        let _p = profile(\"RootDatabase::collect_garbage\");\n+        let _p = profile::span(\"RootDatabase::collect_garbage\");\n         self.last_gc = crate::wasm_shims::Instant::now();\n \n         let sweep = SweepStrategy::default().discard_values().sweep_all_revisions();\n \n-        ra_db::ParseQuery.in_db(self).sweep(sweep);\n+        base_db::ParseQuery.in_db(self).sweep(sweep);\n         hir::db::ParseMacroQuery.in_db(self).sweep(sweep);\n \n         // Macros do take significant space, but less then the syntax trees\n@@ -190,12 +190,25 @@ impl RootDatabase {\n                 let q: $q = Default::default();\n                 let name = format!(\"{:?} (deps)\", q);\n                 acc.push((name, before - after));\n+\n+                let before = memory_usage().allocated;\n+                $q.in_db(self).purge();\n+                let after = memory_usage().allocated;\n+                let q: $q = Default::default();\n+                let name = format!(\"{:?} (purge)\", q);\n+                acc.push((name, before - after));\n             )*}\n         }\n         sweep_each_query![\n             // SourceDatabase\n-            ra_db::ParseQuery\n-            ra_db::SourceRootCratesQuery\n+            base_db::ParseQuery\n+            base_db::CrateGraphQuery\n+\n+            // SourceDatabaseExt\n+            base_db::FileTextQuery\n+            base_db::FileSourceRootQuery\n+            base_db::SourceRootQuery\n+            base_db::SourceRootCratesQuery\n \n             // AstDatabase\n             hir::db::AstIdMapQuery\n@@ -242,15 +255,24 @@ impl RootDatabase {\n             hir::db::TraitImplsInCrateQuery\n             hir::db::TraitImplsInDepsQuery\n             hir::db::AssociatedTyDataQuery\n+            hir::db::AssociatedTyDataQuery\n             hir::db::TraitDatumQuery\n             hir::db::StructDatumQuery\n             hir::db::ImplDatumQuery\n+            hir::db::FnDefDatumQuery\n+            hir::db::ReturnTypeImplTraitsQuery\n+            hir::db::InternCallableDefQuery\n+            hir::db::InternTypeParamIdQuery\n+            hir::db::InternImplTraitIdQuery\n+            hir::db::InternClosureQuery\n             hir::db::AssociatedTyValueQuery\n             hir::db::TraitSolveQuery\n-            hir::db::ReturnTypeImplTraitsQuery\n \n             // SymbolsDatabase\n             crate::symbol_index::FileSymbolsQuery\n+            crate::symbol_index::LibrarySymbolsQuery\n+            crate::symbol_index::LocalRootsQuery\n+            crate::symbol_index::LibraryRootsQuery\n \n             // LineIndexDatabase\n             crate::LineIndexQuery", "previous_filename": "crates/ra_ide_db/src/change.rs"}, {"sha": "0d0affc273575eca6758b78ed22ecd8feecce7c9", "filename": "crates/ide_db/src/defs.rs", "status": "renamed", "additions": 63, "deletions": 29, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -6,13 +6,12 @@\n // FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n \n use hir::{\n-    Field, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef, Name, PathResolution,\n-    Semantics, TypeParam, Visibility,\n+    db::HirDatabase, Crate, Field, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef,\n+    Name, PathResolution, Semantics, TypeParam, Visibility,\n };\n-use ra_prof::profile;\n-use ra_syntax::{\n+use syntax::{\n     ast::{self, AstNode},\n-    match_ast,\n+    match_ast, SyntaxNode,\n };\n \n use crate::RootDatabase;\n@@ -80,6 +79,7 @@ impl Definition {\n \n #[derive(Debug)]\n pub enum NameClass {\n+    ExternCrate(Crate),\n     Definition(Definition),\n     /// `None` in `if let None = Some(82) {}`\n     ConstReference(Definition),\n@@ -90,28 +90,30 @@ pub enum NameClass {\n }\n \n impl NameClass {\n-    pub fn into_definition(self) -> Option<Definition> {\n-        match self {\n-            NameClass::Definition(it) => Some(it),\n-            NameClass::ConstReference(_) => None,\n-            NameClass::FieldShorthand { local, field: _ } => Some(Definition::Local(local)),\n-        }\n+    pub fn into_definition(self, db: &dyn HirDatabase) -> Option<Definition> {\n+        Some(match self {\n+            NameClass::ExternCrate(krate) => Definition::ModuleDef(krate.root_module(db).into()),\n+            NameClass::Definition(it) => it,\n+            NameClass::ConstReference(_) => return None,\n+            NameClass::FieldShorthand { local, field: _ } => Definition::Local(local),\n+        })\n     }\n \n-    pub fn definition(self) -> Definition {\n+    pub fn definition(self, db: &dyn HirDatabase) -> Definition {\n         match self {\n+            NameClass::ExternCrate(krate) => Definition::ModuleDef(krate.root_module(db).into()),\n             NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n             NameClass::FieldShorthand { local: _, field } => field,\n         }\n     }\n }\n \n pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option<NameClass> {\n-    let _p = profile(\"classify_name\");\n+    let _p = profile::span(\"classify_name\");\n \n     let parent = name.syntax().parent()?;\n \n-    if let Some(bind_pat) = ast::BindPat::cast(parent.clone()) {\n+    if let Some(bind_pat) = ast::IdentPat::cast(parent.clone()) {\n         if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n             return Some(NameClass::ConstReference(Definition::ModuleDef(def)));\n         }\n@@ -120,18 +122,42 @@ pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option\n     match_ast! {\n         match parent {\n             ast::Rename(it) => {\n-                let use_tree = it.syntax().parent().and_then(ast::UseTree::cast)?;\n-                let path = use_tree.path()?;\n-                let path_segment = path.segment()?;\n-                let name_ref = path_segment.name_ref()?;\n-                let name_ref_class = classify_name_ref(sema, &name_ref)?;\n+                if let Some(use_tree) = it.syntax().parent().and_then(ast::UseTree::cast) {\n+                    let path = use_tree.path()?;\n+                    let path_segment = path.segment()?;\n+                    let name_ref_class = path_segment\n+                        .name_ref()\n+                        // The rename might be from a `self` token, so fallback to the name higher\n+                        // in the use tree.\n+                        .or_else(||{\n+                            if path_segment.self_token().is_none() {\n+                                return None;\n+                            }\n \n-                Some(NameClass::Definition(name_ref_class.definition()))\n+                            let use_tree = use_tree\n+                                .syntax()\n+                                .parent()\n+                                .as_ref()\n+                                // Skip over UseTreeList\n+                                .and_then(SyntaxNode::parent)\n+                                .and_then(ast::UseTree::cast)?;\n+                            let path = use_tree.path()?;\n+                            let path_segment = path.segment()?;\n+                            path_segment.name_ref()\n+                        })\n+                        .and_then(|name_ref| classify_name_ref(sema, &name_ref))?;\n+\n+                    Some(NameClass::Definition(name_ref_class.definition(sema.db)))\n+                } else {\n+                    let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n+                    let resolved = sema.resolve_extern_crate(&extern_crate)?;\n+                    Some(NameClass::ExternCrate(resolved))\n+                }\n             },\n-            ast::BindPat(it) => {\n+            ast::IdentPat(it) => {\n                 let local = sema.to_def(&it)?;\n \n-                if let Some(record_field_pat) = it.syntax().parent().and_then(ast::RecordFieldPat::cast) {\n+                if let Some(record_field_pat) = it.syntax().parent().and_then(ast::RecordPatField::cast) {\n                     if record_field_pat.name_ref().is_none() {\n                         if let Some(field) = sema.resolve_record_field_pat(&record_field_pat) {\n                             let field = Definition::Field(field);\n@@ -201,26 +227,28 @@ pub fn classify_name(sema: &Semantics<RootDatabase>, name: &ast::Name) -> Option\n \n #[derive(Debug)]\n pub enum NameRefClass {\n+    ExternCrate(Crate),\n     Definition(Definition),\n     FieldShorthand { local: Local, field: Definition },\n }\n \n impl NameRefClass {\n-    pub fn definition(self) -> Definition {\n+    pub fn definition(self, db: &dyn HirDatabase) -> Definition {\n         match self {\n+            NameRefClass::ExternCrate(krate) => Definition::ModuleDef(krate.root_module(db).into()),\n             NameRefClass::Definition(def) => def,\n             NameRefClass::FieldShorthand { local, field: _ } => Definition::Local(local),\n         }\n     }\n }\n \n // Note: we don't have unit-tests for this rather important function.\n-// It is primarily exercised via goto definition tests in `ra_ide`.\n+// It is primarily exercised via goto definition tests in `ide`.\n pub fn classify_name_ref(\n     sema: &Semantics<RootDatabase>,\n     name_ref: &ast::NameRef,\n ) -> Option<NameRefClass> {\n-    let _p = profile(\"classify_name_ref\");\n+    let _p = profile::span(\"classify_name_ref\");\n \n     let parent = name_ref.syntax().parent()?;\n \n@@ -247,7 +275,7 @@ pub fn classify_name_ref(\n         }\n     }\n \n-    if let Some(record_field_pat) = ast::RecordFieldPat::cast(parent.clone()) {\n+    if let Some(record_field_pat) = ast::RecordPatField::cast(parent.clone()) {\n         if let Some(field) = sema.resolve_record_field_pat(&record_field_pat) {\n             let field = Definition::Field(field);\n             return Some(NameRefClass::Definition(field));\n@@ -288,9 +316,15 @@ pub fn classify_name_ref(\n         }\n     }\n \n-    let path = name_ref.syntax().ancestors().find_map(ast::Path::cast)?;\n-    let resolved = sema.resolve_path(&path)?;\n-    Some(NameRefClass::Definition(resolved.into()))\n+    if let Some(path) = name_ref.syntax().ancestors().find_map(ast::Path::cast) {\n+        if let Some(resolved) = sema.resolve_path(&path) {\n+            return Some(NameRefClass::Definition(resolved.into()));\n+        }\n+    }\n+\n+    let extern_crate = ast::ExternCrate::cast(parent)?;\n+    let resolved = sema.resolve_extern_crate(&extern_crate)?;\n+    Some(NameRefClass::ExternCrate(resolved))\n }\n \n impl From<PathResolution> for Definition {", "previous_filename": "crates/ra_ide_db/src/defs.rs"}, {"sha": "ed67e3553144ffde65f24e8d3f423293772bc89c", "filename": "crates/ide_db/src/imports_locator.rs", "status": "renamed", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fimports_locator.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,8 @@\n-//! This module contains an import search funcionality that is provided to the ra_assists module.\n-//! Later, this should be moved away to a separate crate that is accessible from the ra_assists module.\n+//! This module contains an import search funcionality that is provided to the assists module.\n+//! Later, this should be moved away to a separate crate that is accessible from the assists module.\n \n use hir::{Crate, MacroDef, ModuleDef, Semantics};\n-use ra_prof::profile;\n-use ra_syntax::{ast, AstNode, SyntaxKind::NAME};\n+use syntax::{ast, AstNode, SyntaxKind::NAME};\n \n use crate::{\n     defs::{classify_name, Definition},\n@@ -18,7 +17,7 @@ pub fn find_imports<'a>(\n     krate: Crate,\n     name_to_import: &str,\n ) -> Vec<Either<ModuleDef, MacroDef>> {\n-    let _p = profile(\"search_for_imports\");\n+    let _p = profile::span(\"search_for_imports\");\n     let db = sema.db;\n \n     // Query dependencies first.\n@@ -51,7 +50,7 @@ fn get_name_definition<'a>(\n     sema: &Semantics<'a, RootDatabase>,\n     import_candidate: &FileSymbol,\n ) -> Option<Definition> {\n-    let _p = profile(\"get_name_definition\");\n+    let _p = profile::span(\"get_name_definition\");\n     let file_id = import_candidate.file_id;\n \n     let candidate_node = import_candidate.ptr.to_node(sema.parse(file_id).syntax());\n@@ -61,5 +60,5 @@ fn get_name_definition<'a>(\n         candidate_node\n     };\n     let name = ast::Name::cast(candidate_name_node)?;\n-    classify_name(sema, &name)?.into_definition()\n+    classify_name(sema, &name)?.into_definition(sema.db)\n }", "previous_filename": "crates/ra_ide_db/src/imports_locator.rs"}, {"sha": "c0e89e72f5827c07e8d22e0112780b7e01296288", "filename": "crates/ide_db/src/label.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Flabel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Flabel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flabel.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -0,0 +1,49 @@\n+//! See `Label`\n+use std::fmt;\n+\n+/// A type to specify UI label, like an entry in the list of assists. Enforces\n+/// proper casing:\n+///\n+///    Frobnicate bar\n+///\n+/// Note the upper-case first letter and the absence of `.` at the end.\n+#[derive(Clone)]\n+pub struct Label(String);\n+\n+impl PartialEq<str> for Label {\n+    fn eq(&self, other: &str) -> bool {\n+        self.0 == other\n+    }\n+}\n+\n+impl PartialEq<&'_ str> for Label {\n+    fn eq(&self, other: &&str) -> bool {\n+        self == *other\n+    }\n+}\n+\n+impl From<Label> for String {\n+    fn from(label: Label) -> String {\n+        label.0\n+    }\n+}\n+\n+impl Label {\n+    pub fn new(label: impl Into<String>) -> Label {\n+        let label = label.into();\n+        assert!(label.starts_with(char::is_uppercase) && !label.ends_with('.'));\n+        Label(label)\n+    }\n+}\n+\n+impl fmt::Display for Label {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+impl fmt::Debug for Label {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(&self.0, f)\n+    }\n+}"}, {"sha": "70ada02f3121ef0b03cf489ea2c35e7eaf659320", "filename": "crates/ide_db/src/lib.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,6 +2,7 @@\n //!\n //! It is mainly a `HirDatabase` for semantic analysis, plus a `SymbolsDatabase`, for fuzzy search.\n \n+pub mod label;\n pub mod line_index;\n pub mod symbol_index;\n pub mod change;\n@@ -13,19 +14,19 @@ mod wasm_shims;\n \n use std::{fmt, sync::Arc};\n \n-use hir::db::{AstDatabase, DefDatabase, HirDatabase};\n-use ra_db::{\n+use base_db::{\n     salsa::{self, Durability},\n     Canceled, CheckCanceled, CrateId, FileId, FileLoader, FileLoaderDelegate, SourceDatabase,\n     Upcast,\n };\n+use hir::db::{AstDatabase, DefDatabase, HirDatabase};\n use rustc_hash::FxHashSet;\n \n use crate::{line_index::LineIndex, symbol_index::SymbolsDatabase};\n \n #[salsa::database(\n-    ra_db::SourceDatabaseStorage,\n-    ra_db::SourceDatabaseExtStorage,\n+    base_db::SourceDatabaseStorage,\n+    base_db::SourceDatabaseExtStorage,\n     LineIndexDatabaseStorage,\n     symbol_index::SymbolsDatabaseStorage,\n     hir::db::InternDatabaseStorage,\n@@ -111,8 +112,8 @@ impl RootDatabase {\n     }\n \n     pub fn update_lru_capacity(&mut self, lru_capacity: Option<usize>) {\n-        let lru_capacity = lru_capacity.unwrap_or(ra_db::DEFAULT_LRU_CAP);\n-        ra_db::ParseQuery.in_db_mut(self).set_lru_capacity(lru_capacity);\n+        let lru_capacity = lru_capacity.unwrap_or(base_db::DEFAULT_LRU_CAP);\n+        base_db::ParseQuery.in_db_mut(self).set_lru_capacity(lru_capacity);\n         hir::db::ParseMacroQuery.in_db_mut(self).set_lru_capacity(lru_capacity);\n         hir::db::MacroExpandQuery.in_db_mut(self).set_lru_capacity(lru_capacity);\n     }\n@@ -129,7 +130,7 @@ impl salsa::ParallelDatabase for RootDatabase {\n }\n \n #[salsa::query_group(LineIndexDatabaseStorage)]\n-pub trait LineIndexDatabase: ra_db::SourceDatabase + CheckCanceled {\n+pub trait LineIndexDatabase: base_db::SourceDatabase + CheckCanceled {\n     fn line_index(&self, file_id: FileId) -> Arc<LineIndex>;\n }\n ", "previous_filename": "crates/ra_ide_db/src/lib.rs"}, {"sha": "a381f7fb8d5e91277cdbe22cfdfdda43f6bf3ca8", "filename": "crates/ide_db/src/line_index.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fline_index.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,9 +2,9 @@\n //! representation.\n use std::iter;\n \n-use ra_syntax::{TextRange, TextSize};\n use rustc_hash::FxHashMap;\n use stdx::partition_point;\n+use syntax::{TextRange, TextSize};\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LineIndex {", "previous_filename": "crates/ra_ide_db/src/line_index.rs"}, {"sha": "edab1d644d686d555b908481ef1f858a75a7b189", "filename": "crates/ide_db/src/search.rs", "status": "renamed", "additions": 73, "deletions": 39, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -6,12 +6,11 @@\n \n use std::{convert::TryInto, mem};\n \n+use base_db::{FileId, FileRange, SourceDatabaseExt};\n use hir::{DefWithBody, HasSource, Module, ModuleSource, Semantics, Visibility};\n use once_cell::unsync::Lazy;\n-use ra_db::{FileId, FileRange, SourceDatabaseExt};\n-use ra_prof::profile;\n-use ra_syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n use rustc_hash::FxHashMap;\n+use syntax::{ast, match_ast, AstNode, TextRange, TextSize};\n \n use crate::{\n     defs::{classify_name_ref, Definition, NameRefClass},\n@@ -107,7 +106,7 @@ impl IntoIterator for SearchScope {\n \n impl Definition {\n     fn search_scope(&self, db: &RootDatabase) -> SearchScope {\n-        let _p = profile(\"search_scope\");\n+        let _p = profile::span(\"search_scope\");\n         let module = match self.module(db) {\n             Some(it) => it,\n             None => return SearchScope::empty(),\n@@ -182,29 +181,63 @@ impl Definition {\n         SearchScope::new(res)\n     }\n \n-    pub fn find_usages(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-        search_scope: Option<SearchScope>,\n-    ) -> Vec<Reference> {\n-        let _p = profile(\"Definition::find_usages\");\n+    pub fn usages<'a>(&'a self, sema: &'a Semantics<RootDatabase>) -> FindUsages<'a> {\n+        FindUsages { def: self, sema, scope: None }\n+    }\n+}\n+\n+pub struct FindUsages<'a> {\n+    def: &'a Definition,\n+    sema: &'a Semantics<'a, RootDatabase>,\n+    scope: Option<SearchScope>,\n+}\n+\n+impl<'a> FindUsages<'a> {\n+    pub fn in_scope(self, scope: SearchScope) -> FindUsages<'a> {\n+        self.set_scope(Some(scope))\n+    }\n+    pub fn set_scope(mut self, scope: Option<SearchScope>) -> FindUsages<'a> {\n+        assert!(self.scope.is_none());\n+        self.scope = scope;\n+        self\n+    }\n+\n+    pub fn at_least_one(self) -> bool {\n+        let mut found = false;\n+        self.search(&mut |_reference| {\n+            found = true;\n+            true\n+        });\n+        found\n+    }\n+\n+    pub fn all(self) -> Vec<Reference> {\n+        let mut res = Vec::new();\n+        self.search(&mut |reference| {\n+            res.push(reference);\n+            false\n+        });\n+        res\n+    }\n+\n+    fn search(self, sink: &mut dyn FnMut(Reference) -> bool) {\n+        let _p = profile::span(\"FindUsages:search\");\n+        let sema = self.sema;\n \n         let search_scope = {\n-            let base = self.search_scope(sema.db);\n-            match search_scope {\n+            let base = self.def.search_scope(sema.db);\n+            match self.scope {\n                 None => base,\n                 Some(scope) => base.intersection(&scope),\n             }\n         };\n \n-        let name = match self.name(sema.db) {\n-            None => return Vec::new(),\n+        let name = match self.def.name(sema.db) {\n             Some(it) => it.to_string(),\n+            None => return,\n         };\n \n         let pat = name.as_str();\n-        let mut refs = vec![];\n-\n         for (file_id, search_range) in search_scope {\n             let text = sema.db.file_text(file_id);\n             let search_range =\n@@ -219,14 +252,13 @@ impl Definition {\n                 }\n \n                 let name_ref: ast::NameRef =\n-                    if let Some(name_ref) = sema.find_node_at_offset_with_descend(&tree, offset) {\n-                        name_ref\n-                    } else {\n-                        continue;\n+                    match sema.find_node_at_offset_with_descend(&tree, offset) {\n+                        Some(it) => it,\n+                        None => continue,\n                     };\n \n                 match classify_name_ref(&sema, &name_ref) {\n-                    Some(NameRefClass::Definition(def)) if &def == self => {\n+                    Some(NameRefClass::Definition(def)) if &def == self.def => {\n                         let kind = if is_record_lit_name_ref(&name_ref)\n                             || is_call_expr_name_ref(&name_ref)\n                         {\n@@ -235,43 +267,45 @@ impl Definition {\n                             ReferenceKind::Other\n                         };\n \n-                        let file_range = sema.original_range(name_ref.syntax());\n-                        refs.push(Reference {\n-                            file_range,\n+                        let reference = Reference {\n+                            file_range: sema.original_range(name_ref.syntax()),\n                             kind,\n                             access: reference_access(&def, &name_ref),\n-                        });\n+                        };\n+                        if sink(reference) {\n+                            return;\n+                        }\n                     }\n                     Some(NameRefClass::FieldShorthand { local, field }) => {\n-                        match self {\n-                            Definition::Field(_) if &field == self => refs.push(Reference {\n-                                file_range: sema.original_range(name_ref.syntax()),\n+                        let reference = match self.def {\n+                            Definition::Field(_) if &field == self.def => Reference {\n+                                file_range: self.sema.original_range(name_ref.syntax()),\n                                 kind: ReferenceKind::FieldShorthandForField,\n                                 access: reference_access(&field, &name_ref),\n-                            }),\n-                            Definition::Local(l) if &local == l => refs.push(Reference {\n-                                file_range: sema.original_range(name_ref.syntax()),\n+                            },\n+                            Definition::Local(l) if &local == l => Reference {\n+                                file_range: self.sema.original_range(name_ref.syntax()),\n                                 kind: ReferenceKind::FieldShorthandForLocal,\n                                 access: reference_access(&Definition::Local(local), &name_ref),\n-                            }),\n-\n-                            _ => {} // not a usage\n+                            },\n+                            _ => continue, // not a usage\n                         };\n+                        if sink(reference) {\n+                            return;\n+                        }\n                     }\n                     _ => {} // not a usage\n                 }\n             }\n         }\n-        refs\n     }\n }\n \n fn reference_access(def: &Definition, name_ref: &ast::NameRef) -> Option<ReferenceAccess> {\n     // Only Locals and Fields have accesses for now.\n-    match def {\n-        Definition::Local(_) | Definition::Field(_) => {}\n-        _ => return None,\n-    };\n+    if !matches!(def, Definition::Local(_) | Definition::Field(_)) {\n+        return None;\n+    }\n \n     let mode = name_ref.syntax().ancestors().find_map(|node| {\n         match_ast! {", "previous_filename": "crates/ra_ide_db/src/search.rs"}, {"sha": "f1590ec66326856c3ea2e9df385701f95e6e4173", "filename": "crates/ide_db/src/source_change.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fsource_change.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fsource_change.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsource_change.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -3,8 +3,8 @@\n //!\n //! It can be viewed as a dual for `AnalysisChange`.\n \n-use ra_db::FileId;\n-use ra_text_edit::TextEdit;\n+use base_db::FileId;\n+use text_edit::TextEdit;\n \n #[derive(Default, Debug, Clone)]\n pub struct SourceChange {", "previous_filename": "crates/ra_ide_db/src/source_change.rs"}, {"sha": "654df898e93d76c22a4384009ac231f8821adff5", "filename": "crates/ide_db/src/symbol_index.rs", "status": "renamed", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -28,21 +28,20 @@ use std::{\n     sync::Arc,\n };\n \n-use fst::{self, Streamer};\n-use hir::db::DefDatabase;\n-use ra_db::{\n+use base_db::{\n     salsa::{self, ParallelDatabase},\n     CrateId, FileId, SourceDatabaseExt, SourceRootId,\n };\n-use ra_prof::profile;\n-use ra_syntax::{\n+use fst::{self, Streamer};\n+use hir::db::DefDatabase;\n+use rayon::prelude::*;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use syntax::{\n     ast::{self, NameOwner},\n     match_ast, AstNode, Parse, SmolStr, SourceFile,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxNodePtr, TextRange, WalkEvent,\n };\n-use rayon::prelude::*;\n-use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::RootDatabase;\n \n@@ -101,7 +100,7 @@ pub trait SymbolsDatabase: hir::db::HirDatabase + SourceDatabaseExt {\n }\n \n fn library_symbols(db: &dyn SymbolsDatabase) -> Arc<FxHashMap<SourceRootId, SymbolIndex>> {\n-    let _p = profile(\"library_symbols\");\n+    let _p = profile::span(\"library_symbols\");\n \n     let roots = db.library_roots();\n     let res = roots\n@@ -162,7 +161,7 @@ impl<DB: ParallelDatabase> Clone for Snap<salsa::Snapshot<DB>> {\n // | VS Code | kbd:[Ctrl+T]\n // |===\n pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n-    let _p = ra_prof::profile(\"world_symbols\").detail(|| query.query.clone());\n+    let _p = profile::span(\"world_symbols\").detail(|| query.query.clone());\n \n     let tmp1;\n     let tmp2;", "previous_filename": "crates/ra_ide_db/src/symbol_index.rs"}, {"sha": "7af9f9d9bb7bdafcd852e474572a1aca06dcadd0", "filename": "crates/ide_db/src/wasm_shims.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fwasm_shims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fide_db%2Fsrc%2Fwasm_shims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fwasm_shims.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_ide_db/src/wasm_shims.rs"}, {"sha": "1aba8b7c48279d619b264a127720c13067b575fd", "filename": "crates/mbe/Cargo.toml", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,20 +1,21 @@\n [package]\n-edition = \"2018\"\n-name = \"ra_mbe\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n+name = \"mbe\"\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false\n \n [dependencies]\n-ra_syntax = { path = \"../ra_syntax\" }\n-ra_parser = { path = \"../ra_parser\" }\n-tt = { path = \"../ra_tt\", package = \"ra_tt\" }\n rustc-hash = \"1.1.0\"\n smallvec = \"1.2.0\"\n log = \"0.4.8\"\n \n+syntax = { path = \"../syntax\" }\n+parser = { path = \"../parser\" }\n+tt = { path = \"../tt\" }\n+\n [dev-dependencies]\n test_utils = { path = \"../test_utils\" }", "previous_filename": "crates/ra_mbe/Cargo.toml"}, {"sha": "f854ca09abe82256e4a4cd43611a623a5c77040f", "filename": "crates/mbe/src/lib.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,5 +1,5 @@\n //! `mbe` (short for Macro By Example) crate contains code for handling\n-//! `macro_rules` macros. It uses `TokenTree` (from `ra_tt` package) as the\n+//! `macro_rules` macros. It uses `TokenTree` (from `tt` package) as the\n //! interface, although it contains some code to bridge `SyntaxNode`s and\n //! `TokenTree`s as well!\n ", "previous_filename": "crates/ra_mbe/src/lib.rs"}, {"sha": "1ad8b9f8a580ad03012bf5c3840363cdaa11c951", "filename": "crates/mbe/src/mbe_expander.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,8 +5,8 @@\n mod matcher;\n mod transcriber;\n \n-use ra_syntax::SmolStr;\n use rustc_hash::FxHashMap;\n+use syntax::SmolStr;\n \n use crate::{ExpandError, ExpandResult};\n \n@@ -123,7 +123,7 @@ enum Fragment {\n \n #[cfg(test)]\n mod tests {\n-    use ra_syntax::{ast, AstNode};\n+    use syntax::{ast, AstNode};\n \n     use super::*;\n     use crate::ast_to_token_tree;", "previous_filename": "crates/ra_mbe/src/mbe_expander.rs"}, {"sha": "b698b98326d0f6e57fac0ae7b34ff77d37b5842c", "filename": "crates/mbe/src/mbe_expander/matcher.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Fmatcher.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -9,8 +9,8 @@ use crate::{\n };\n \n use super::ExpandResult;\n-use ra_parser::{FragmentKind::*, TreeSink};\n-use ra_syntax::{SmolStr, SyntaxKind};\n+use parser::{FragmentKind::*, TreeSink};\n+use syntax::{SmolStr, SyntaxKind};\n use tt::buffer::{Cursor, TokenBuffer};\n \n impl Bindings {\n@@ -276,7 +276,7 @@ impl<'a> TtIter<'a> {\n         Ok(tt::Subtree {\n             delimiter: None,\n             token_trees: vec![\n-                tt::Leaf::Punct(punct.clone()).into(),\n+                tt::Leaf::Punct(*punct).into(),\n                 tt::Leaf::Ident(ident.clone()).into(),\n             ],\n         }\n@@ -285,7 +285,7 @@ impl<'a> TtIter<'a> {\n \n     pub(crate) fn expect_fragment(\n         &mut self,\n-        fragment_kind: ra_parser::FragmentKind,\n+        fragment_kind: parser::FragmentKind,\n     ) -> ExpandResult<Option<tt::TokenTree>> {\n         pub(crate) struct OffsetTokenSink<'a> {\n             pub(crate) cursor: Cursor<'a>,\n@@ -303,7 +303,7 @@ impl<'a> TtIter<'a> {\n             }\n             fn start_node(&mut self, _kind: SyntaxKind) {}\n             fn finish_node(&mut self) {}\n-            fn error(&mut self, _error: ra_parser::ParseError) {\n+            fn error(&mut self, _error: parser::ParseError) {\n                 self.error = true;\n             }\n         }\n@@ -312,7 +312,7 @@ impl<'a> TtIter<'a> {\n         let mut src = SubtreeTokenSource::new(&buffer);\n         let mut sink = OffsetTokenSink { cursor: buffer.begin(), error: false };\n \n-        ra_parser::parse_fragment(&mut src, &mut sink, fragment_kind);\n+        parser::parse_fragment(&mut src, &mut sink, fragment_kind);\n \n         let mut err = None;\n         if !sink.cursor.is_root() || sink.error {", "previous_filename": "crates/ra_mbe/src/mbe_expander/matcher.rs"}, {"sha": "c9525c5bf204cfb9dc96cf1f9de8488f32da9f19", "filename": "crates/mbe/src/mbe_expander/transcriber.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,7 @@\n //! Transcriber takes a template, like `fn $ident() {}`, a set of bindings like\n //! `$ident => foo`, interpolates variables in the template, to get `fn foo() {}`\n \n-use ra_syntax::SmolStr;\n+use syntax::SmolStr;\n \n use super::ExpandResult;\n use crate::{", "previous_filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs"}, {"sha": "6b46a1673c38e17e012f26478e42143c4f37483d", "filename": "crates/mbe/src/parser.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,8 +1,8 @@\n //! Parser recognizes special macro syntax, `$var` and `$(repeat)*`, in token\n //! trees.\n \n-use ra_syntax::SmolStr;\n use smallvec::SmallVec;\n+use syntax::SmolStr;\n \n use crate::{tt_iter::TtIter, ExpandError};\n ", "previous_filename": "crates/ra_mbe/src/parser.rs"}, {"sha": "41461b3150ae17c9d91b7cc161cb29202ae05e94", "filename": "crates/mbe/src/subtree_source.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsubtree_source.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,8 +1,8 @@\n //! FIXME: write short doc here\n \n-use ra_parser::{Token, TokenSource};\n-use ra_syntax::{lex_single_syntax_kind, SmolStr, SyntaxKind, SyntaxKind::*, T};\n+use parser::{Token, TokenSource};\n use std::cell::{Cell, Ref, RefCell};\n+use syntax::{lex_single_syntax_kind, SmolStr, SyntaxKind, SyntaxKind::*, T};\n use tt::buffer::{Cursor, TokenBuffer};\n \n #[derive(Debug, Clone, Eq, PartialEq)]", "previous_filename": "crates/ra_mbe/src/subtree_source.rs"}, {"sha": "a8ad917fb880c534faffe1df3baca75febd8122d", "filename": "crates/mbe/src/syntax_bridge.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fsyntax_bridge.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,13 +1,13 @@\n //! FIXME: write short doc here\n \n-use ra_parser::{FragmentKind, ParseError, TreeSink};\n-use ra_syntax::{\n+use parser::{FragmentKind, ParseError, TreeSink};\n+use rustc_hash::FxHashMap;\n+use syntax::{\n     ast::{self, make::tokens::doc_comment},\n     tokenize, AstToken, Parse, SmolStr, SyntaxKind,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, SyntaxTreeBuilder, TextRange, TextSize, Token as RawToken, T,\n };\n-use rustc_hash::FxHashMap;\n use tt::buffer::{Cursor, TokenBuffer};\n \n use crate::subtree_source::SubtreeTokenSource;\n@@ -81,7 +81,7 @@ pub fn token_tree_to_syntax_node(\n     let buffer = TokenBuffer::new(&tokens);\n     let mut token_source = SubtreeTokenSource::new(&buffer);\n     let mut tree_sink = TtTreeSink::new(buffer.begin());\n-    ra_parser::parse_fragment(&mut token_source, &mut tree_sink, fragment_kind);\n+    parser::parse_fragment(&mut token_source, &mut tree_sink, fragment_kind);\n     if tree_sink.roots.len() != 1 {\n         return Err(ExpandError::ConversionError);\n     }\n@@ -176,7 +176,7 @@ fn doc_comment_text(comment: &ast::Comment) -> SmolStr {\n     text.into()\n }\n \n-fn convert_doc_comment(token: &ra_syntax::SyntaxToken) -> Option<Vec<tt::TokenTree>> {\n+fn convert_doc_comment(token: &syntax::SyntaxToken) -> Option<Vec<tt::TokenTree>> {\n     let comment = ast::Comment::cast(token.clone())?;\n     let doc = comment.kind().doc?;\n \n@@ -715,8 +715,8 @@ impl<'a> TreeSink for TtTreeSink<'a> {\n mod tests {\n     use super::*;\n     use crate::tests::parse_macro;\n-    use ra_parser::TokenSource;\n-    use ra_syntax::{\n+    use parser::TokenSource;\n+    use syntax::{\n         algo::{insert_children, InsertPosition},\n         ast::AstNode,\n     };", "previous_filename": "crates/ra_mbe/src/syntax_bridge.rs"}, {"sha": "0796ceee1a7a7306c2004ceea592fa28ee5a22f4", "filename": "crates/mbe/src/tests.rs", "status": "renamed", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftests.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,17 +1,18 @@\n use std::fmt::Write;\n \n-use ra_parser::FragmentKind;\n-use ra_syntax::{ast, AstNode, NodeOrToken, SyntaxKind::IDENT, SyntaxNode, WalkEvent, T};\n+use ::parser::FragmentKind;\n+use syntax::{ast, AstNode, NodeOrToken, SyntaxKind::IDENT, SyntaxNode, WalkEvent, T};\n use test_utils::assert_eq_text;\n \n use super::*;\n \n mod rule_parsing {\n-    use ra_syntax::{ast, AstNode};\n+    use syntax::{ast, AstNode};\n \n-    use super::*;\n     use crate::ast_to_token_tree;\n \n+    use super::*;\n+\n     #[test]\n     fn test_valid_arms() {\n         fn check(macro_body: &str) {\n@@ -625,7 +626,7 @@ fn test_tt_to_stmts() {\n         r#\"MACRO_STMTS@0..15\n   LET_STMT@0..7\n     LET_KW@0..3 \"let\"\n-    BIND_PAT@3..4\n+    IDENT_PAT@3..4\n       NAME@3..4\n         IDENT@3..4 \"a\"\n     EQ@4..5 \"=\"\n@@ -1116,7 +1117,7 @@ fn test_vec() {\n   L_CURLY@0..1 \"{\"\n   LET_STMT@1..20\n     LET_KW@1..4 \"let\"\n-    BIND_PAT@4..8\n+    IDENT_PAT@4..8\n       MUT_KW@4..7 \"mut\"\n       NAME@7..8\n         IDENT@7..8 \"v\"\n@@ -1697,7 +1698,7 @@ pub(crate) fn parse_to_token_tree_by_syntax(ra_fixture: &str) -> tt::Subtree {\n     parsed\n }\n \n-fn debug_dump_ignore_spaces(node: &ra_syntax::SyntaxNode) -> String {\n+fn debug_dump_ignore_spaces(node: &syntax::SyntaxNode) -> String {\n     let mut level = 0;\n     let mut buf = String::new();\n     macro_rules! indent {\n@@ -1717,7 +1718,7 @@ fn debug_dump_ignore_spaces(node: &ra_syntax::SyntaxNode) -> String {\n                         writeln!(buf, \"{:?}\", node.kind()).unwrap();\n                     }\n                     NodeOrToken::Token(token) => match token.kind() {\n-                        ra_syntax::SyntaxKind::WHITESPACE => {}\n+                        syntax::SyntaxKind::WHITESPACE => {}\n                         _ => {\n                             indent!();\n                             writeln!(buf, \"{:?}\", token.kind()).unwrap();", "previous_filename": "crates/ra_mbe/src/tests.rs"}, {"sha": "46c4207185f603fbb00c13b09d0278e74b53de8f", "filename": "crates/mbe/src/tt_iter.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_mbe/src/tt_iter.rs"}, {"sha": "358be92d1226471332b45eef9eafae0279efbdc7", "filename": "crates/parser/Cargo.toml", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,10 +1,9 @@\n [package]\n-edition = \"2018\"\n-name = \"ra_parser\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n-publish = false\n+name = \"parser\"\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false", "previous_filename": "crates/ra_parser/Cargo.toml"}, {"sha": "a7d06a815cb383b4f89e0967cc868a3cd8e57ae0", "filename": "crates/parser/src/event.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fevent.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_parser/src/event.rs"}, {"sha": "562e92252b2a40d9561270a11d883952eea00189", "filename": "crates/parser/src/grammar.rs", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -20,7 +20,7 @@\n //!\n //! After adding a new inline-test, run `cargo xtask codegen` to\n //! extract it as a standalone text-fixture into\n-//! `crates/ra_syntax/test_data/parser/`, and run `cargo test` once to\n+//! `crates/syntax/test_data/parser/`, and run `cargo test` once to\n //! create the \"gold\" value.\n //!\n //! Coding convention: rules like `where_clause` always produce either a\n@@ -110,7 +110,7 @@ pub(crate) mod fragments {\n     }\n \n     pub(crate) fn item(p: &mut Parser) {\n-        items::item_or_macro(p, true, items::ItemFlavor::Mod)\n+        items::item_or_macro(p, true)\n     }\n \n     pub(crate) fn macro_items(p: &mut Parser) {\n@@ -142,19 +142,19 @@ pub(crate) fn reparser(\n ) -> Option<fn(&mut Parser)> {\n     let res = match node {\n         BLOCK_EXPR => expressions::block_expr,\n-        RECORD_FIELD_LIST => items::record_field_def_list,\n-        RECORD_EXPR_FIELD_LIST => items::record_field_list,\n-        VARIANT_LIST => items::enum_variant_list,\n+        RECORD_FIELD_LIST => items::record_field_list,\n+        RECORD_EXPR_FIELD_LIST => items::record_expr_field_list,\n+        VARIANT_LIST => items::variant_list,\n         MATCH_ARM_LIST => items::match_arm_list,\n         USE_TREE_LIST => items::use_tree_list,\n         EXTERN_ITEM_LIST => items::extern_item_list,\n         TOKEN_TREE if first_child? == T!['{'] => items::token_tree,\n         ASSOC_ITEM_LIST => match parent? {\n-            IMPL => items::impl_item_list,\n-            TRAIT => items::trait_item_list,\n+            IMPL => items::assoc_item_list,\n+            TRAIT => items::assoc_item_list,\n             _ => return None,\n         },\n-        ITEM_LIST => items::mod_item_list,\n+        ITEM_LIST => items::item_list,\n         _ => return None,\n     };\n     Some(res)\n@@ -217,7 +217,7 @@ fn opt_visibility(p: &mut Parser) -> bool {\n     true\n }\n \n-fn opt_alias(p: &mut Parser) {\n+fn opt_rename(p: &mut Parser) {\n     if p.at(T![as]) {\n         let m = p.start();\n         p.bump(T![as]);\n@@ -239,7 +239,7 @@ fn abi(p: &mut Parser) {\n     abi.complete(p, ABI);\n }\n \n-fn opt_fn_ret_type(p: &mut Parser) -> bool {\n+fn opt_ret_type(p: &mut Parser) -> bool {\n     if p.at(T![->]) {\n         let m = p.start();\n         p.bump(T![->]);", "previous_filename": "crates/ra_parser/src/grammar.rs"}, {"sha": "dab0f62c3caaf6fcea791cddeac9e585e1b1bdf7", "filename": "crates/parser/src/grammar/attributes.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fattributes.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,19 +2,19 @@\n \n use super::*;\n \n-pub(super) fn inner_attributes(p: &mut Parser) {\n+pub(super) fn inner_attrs(p: &mut Parser) {\n     while p.at(T![#]) && p.nth(1) == T![!] {\n-        attribute(p, true)\n+        attr(p, true)\n     }\n }\n \n-pub(super) fn outer_attributes(p: &mut Parser) {\n+pub(super) fn outer_attrs(p: &mut Parser) {\n     while p.at(T![#]) {\n-        attribute(p, false)\n+        attr(p, false)\n     }\n }\n \n-fn attribute(p: &mut Parser, inner: bool) {\n+fn attr(p: &mut Parser, inner: bool) {\n     let attr = p.start();\n     assert!(p.at(T![#]));\n     p.bump(T![#]);", "previous_filename": "crates/ra_parser/src/grammar/attributes.rs"}, {"sha": "e72929f8ccdab3d0dec31b97a22e0cd2cb9cc48c", "filename": "crates/parser/src/grammar/expressions.rs", "status": "renamed", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -22,7 +22,7 @@ pub(super) fn expr(p: &mut Parser) -> (Option<CompletedMarker>, BlockLike) {\n pub(super) fn expr_with_attrs(p: &mut Parser) -> bool {\n     let m = p.start();\n     let has_attrs = p.at(T![#]);\n-    attributes::outer_attributes(p);\n+    attributes::outer_attrs(p);\n \n     let (cm, _block_like) = expr(p);\n     let success = cm.is_some();\n@@ -64,7 +64,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n     //     #[D] return ();\n     // }\n     let has_attrs = p.at(T![#]);\n-    attributes::outer_attributes(p);\n+    attributes::outer_attrs(p);\n \n     if p.at(T![let]) {\n         let_stmt(p, m, with_semi);\n@@ -73,7 +73,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n \n     // test block_items\n     // fn a() { fn b() {} }\n-    let m = match items::maybe_item(p, m, items::ItemFlavor::Mod) {\n+    let m = match items::maybe_item(p, m) {\n         Ok(()) => return,\n         Err(m) => m,\n     };\n@@ -175,7 +175,7 @@ pub(super) fn stmt(p: &mut Parser, with_semi: StmtWithSemi) {\n \n pub(super) fn expr_block_contents(p: &mut Parser) {\n     // This is checked by a validator\n-    attributes::inner_attributes(p);\n+    attributes::inner_attrs(p);\n \n     while !p.at(EOF) && !p.at(T!['}']) {\n         // test nocontentexpr\n@@ -489,7 +489,7 @@ fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     let m = lhs.precede(p);\n     p.bump_any();\n     name_ref(p);\n-    type_args::opt_type_arg_list(p, true);\n+    type_args::opt_generic_arg_list(p, true);\n     if p.at(T!['(']) {\n         arg_list(p);\n     }\n@@ -509,7 +509,6 @@ fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     x.1i32;\n //     x.0x01;\n // }\n-#[allow(clippy::if_same_then_else)]\n fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n     assert!(p.at(T![.]));\n     let m = lhs.precede(p);\n@@ -586,7 +585,7 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n     paths::expr_path(p);\n     match p.current() {\n         T!['{'] if !r.forbid_structs => {\n-            record_field_list(p);\n+            record_expr_field_list(p);\n             (m.complete(p, RECORD_EXPR), BlockLike::NotBlock)\n         }\n         T![!] if !p.at(T![!=]) => {\n@@ -604,7 +603,7 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> (CompletedMarker, BlockLike) {\n //     S { x, y: 32, ..Default::default() };\n //     TupleStruct { 0: 1 };\n // }\n-pub(crate) fn record_field_list(p: &mut Parser) {\n+pub(crate) fn record_expr_field_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -614,7 +613,7 @@ pub(crate) fn record_field_list(p: &mut Parser) {\n         // fn main() {\n         //     S { #[cfg(test)] field: 1 }\n         // }\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n \n         match p.current() {\n             IDENT | INT_NUMBER => {", "previous_filename": "crates/ra_parser/src/grammar/expressions.rs"}, {"sha": "ba6dd2fbcc4681944f039a321b5109cad9f0b054", "filename": "crates/parser/src/grammar/expressions/atom.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -75,9 +75,9 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n         T!['('] => tuple_expr(p),\n         T!['['] => array_expr(p),\n         L_DOLLAR => meta_var_expr(p),\n-        T![|] => lambda_expr(p),\n-        T![move] if la == T![|] => lambda_expr(p),\n-        T![async] if la == T![|] || (la == T![move] && p.nth(2) == T![|]) => lambda_expr(p),\n+        T![|] => closure_expr(p),\n+        T![move] if la == T![|] => closure_expr(p),\n+        T![async] if la == T![|] || (la == T![move] && p.nth(2) == T![|]) => closure_expr(p),\n         T![if] => if_expr(p),\n \n         T![loop] => loop_expr(p, None),\n@@ -228,7 +228,7 @@ fn array_expr(p: &mut Parser) -> CompletedMarker {\n //     move || {};\n //     async move || {};\n // }\n-fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n+fn closure_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(\n         p.at(T![|])\n             || (p.at(T![move]) && p.nth(1) == T![|])\n@@ -239,7 +239,7 @@ fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n     p.eat(T![async]);\n     p.eat(T![move]);\n     params::param_list_closure(p);\n-    if opt_fn_ret_type(p) {\n+    if opt_ret_type(p) {\n         // test lambda_ret_block\n         // fn main() { || -> i32 { 92 }(); }\n         block_expr(p);\n@@ -250,7 +250,7 @@ fn lambda_expr(p: &mut Parser) -> CompletedMarker {\n             p.error(\"expected expression\");\n         }\n     }\n-    m.complete(p, LAMBDA_EXPR)\n+    m.complete(p, CLOSURE_EXPR)\n }\n \n // test if_expr\n@@ -265,7 +265,7 @@ fn if_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![if]));\n     let m = p.start();\n     p.bump(T![if]);\n-    cond(p);\n+    condition(p);\n     block_expr(p);\n     if p.at(T![else]) {\n         p.bump(T![else]);\n@@ -314,7 +314,7 @@ fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![while]));\n     let m = m.unwrap_or_else(|| p.start());\n     p.bump(T![while]);\n-    cond(p);\n+    condition(p);\n     block_expr(p);\n     m.complete(p, WHILE_EXPR)\n }\n@@ -342,7 +342,7 @@ fn for_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n //     while let Some(_) | Some(_) = None {}\n //     while let | Some(_) = None {}\n // }\n-fn cond(p: &mut Parser) {\n+fn condition(p: &mut Parser) {\n     let m = p.start();\n     if p.eat(T![let]) {\n         patterns::pattern_top(p);\n@@ -386,7 +386,7 @@ pub(crate) fn match_arm_list(p: &mut Parser) {\n     //         _ => (),\n     //     }\n     // }\n-    attributes::inner_attributes(p);\n+    attributes::inner_attrs(p);\n \n     while !p.at(EOF) && !p.at(T!['}']) {\n         if p.at(T!['{']) {\n@@ -437,7 +437,7 @@ fn match_arm(p: &mut Parser) -> BlockLike {\n     //         _ => (),\n     //     }\n     // }\n-    attributes::outer_attributes(p);\n+    attributes::outer_attrs(p);\n \n     patterns::pattern_top_r(p, TokenSet::EMPTY);\n     if p.at(T![if]) {", "previous_filename": "crates/ra_parser/src/grammar/expressions/atom.rs"}, {"sha": "8fd8f3b8000256d9720b169138bad1322cb1e0d3", "filename": "crates/parser/src/grammar/items.rs", "status": "renamed", "additions": 67, "deletions": 115, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -6,9 +6,9 @@ mod traits;\n mod use_item;\n \n pub(crate) use self::{\n-    adt::{enum_variant_list, record_field_def_list},\n-    expressions::{match_arm_list, record_field_list},\n-    traits::{impl_item_list, trait_item_list},\n+    adt::{record_field_list, variant_list},\n+    expressions::{match_arm_list, record_expr_field_list},\n+    traits::assoc_item_list,\n     use_item::use_tree_list,\n };\n use super::*;\n@@ -20,26 +20,33 @@ use super::*;\n // super::baz! {}\n // struct S;\n pub(super) fn mod_contents(p: &mut Parser, stop_on_r_curly: bool) {\n-    attributes::inner_attributes(p);\n+    attributes::inner_attrs(p);\n     while !(stop_on_r_curly && p.at(T!['}']) || p.at(EOF)) {\n-        item_or_macro(p, stop_on_r_curly, ItemFlavor::Mod)\n+        item_or_macro(p, stop_on_r_curly)\n     }\n }\n \n-pub(super) enum ItemFlavor {\n-    Mod,\n-    Trait,\n-}\n-\n pub(super) const ITEM_RECOVERY_SET: TokenSet = token_set![\n-    FN_KW, STRUCT_KW, ENUM_KW, IMPL_KW, TRAIT_KW, CONST_KW, STATIC_KW, LET_KW, MOD_KW, PUB_KW,\n-    CRATE_KW, USE_KW, MACRO_KW\n+    FN_KW,\n+    STRUCT_KW,\n+    ENUM_KW,\n+    IMPL_KW,\n+    TRAIT_KW,\n+    CONST_KW,\n+    STATIC_KW,\n+    LET_KW,\n+    MOD_KW,\n+    PUB_KW,\n+    CRATE_KW,\n+    USE_KW,\n+    MACRO_KW,\n+    T![;],\n ];\n \n-pub(super) fn item_or_macro(p: &mut Parser, stop_on_r_curly: bool, flavor: ItemFlavor) {\n+pub(super) fn item_or_macro(p: &mut Parser, stop_on_r_curly: bool) {\n     let m = p.start();\n-    attributes::outer_attributes(p);\n-    let m = match maybe_item(p, m, flavor) {\n+    attributes::outer_attrs(p);\n+    let m = match maybe_item(p, m) {\n         Ok(()) => {\n             if p.at(T![;]) {\n                 p.err_and_bump(\n@@ -76,7 +83,7 @@ pub(super) fn item_or_macro(p: &mut Parser, stop_on_r_curly: bool, flavor: ItemF\n     }\n }\n \n-pub(super) fn maybe_item(p: &mut Parser, m: Marker, flavor: ItemFlavor) -> Result<(), Marker> {\n+pub(super) fn maybe_item(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n     // test_err pub_expr\n     // fn foo() { pub 92; }\n     let has_visibility = opt_visibility(p);\n@@ -114,120 +121,65 @@ pub(super) fn maybe_item(p: &mut Parser, m: Marker, flavor: ItemFlavor) -> Resul\n         has_mods = true;\n     }\n \n-    if p.at(IDENT)\n-        && p.at_contextual_kw(\"default\")\n-        && (match p.nth(1) {\n-            T![impl] => true,\n+    // test default_item\n+    // default impl T for Foo {}\n+    if p.at(IDENT) && p.at_contextual_kw(\"default\") {\n+        match p.nth(1) {\n+            T![fn] | T![type] | T![const] | T![impl] => {\n+                p.bump_remap(T![default]);\n+                has_mods = true;\n+            }\n             T![unsafe] => {\n-                // test default_unsafe_impl\n-                // default unsafe impl Foo {}\n-\n-                // test default_unsafe_fn\n-                // impl T for Foo {\n+                // test default_unsafe_item\n+                // default unsafe impl T for Foo {\n                 //     default unsafe fn foo() {}\n                 // }\n-                if p.nth(2) == T![impl] || p.nth(2) == T![fn] {\n+                if matches!(p.nth(2), T![impl] | T![fn]) {\n                     p.bump_remap(T![default]);\n                     p.bump(T![unsafe]);\n                     has_mods = true;\n                 }\n-                false\n             }\n-            T![fn] | T![type] | T![const] => {\n-                if let ItemFlavor::Mod = flavor {\n-                    true\n-                } else {\n-                    false\n-                }\n-            }\n-            _ => false,\n-        })\n-    {\n-        p.bump_remap(T![default]);\n-        has_mods = true;\n+            _ => (),\n+        }\n     }\n+\n+    // test existential_type\n+    // existential type Foo: Fn() -> usize;\n     if p.at(IDENT) && p.at_contextual_kw(\"existential\") && p.nth(1) == T![type] {\n         p.bump_remap(T![existential]);\n         has_mods = true;\n     }\n \n     // items\n     match p.current() {\n-        // test async_fn\n-        // async fn foo() {}\n-\n-        // test extern_fn\n-        // extern fn foo() {}\n-\n-        // test const_fn\n-        // const fn foo() {}\n-\n-        // test const_unsafe_fn\n-        // const unsafe fn foo() {}\n-\n-        // test unsafe_extern_fn\n-        // unsafe extern \"C\" fn foo() {}\n-\n-        // test unsafe_fn\n-        // unsafe fn foo() {}\n-\n-        // test combined_fns\n-        // async unsafe fn foo() {}\n-        // const unsafe fn bar() {}\n-\n-        // test_err wrong_order_fns\n-        // unsafe async fn foo() {}\n-        // unsafe const fn bar() {}\n+        // test fn\n+        // fn foo() {}\n         T![fn] => {\n-            fn_def(p);\n+            fn_(p);\n             m.complete(p, FN);\n         }\n \n-        // test unsafe_trait\n-        // unsafe trait T {}\n-\n-        // test auto_trait\n-        // auto trait T {}\n-\n-        // test unsafe_auto_trait\n-        // unsafe auto trait T {}\n+        // test trait\n+        // trait T {}\n         T![trait] => {\n-            traits::trait_def(p);\n+            traits::trait_(p);\n             m.complete(p, TRAIT);\n         }\n \n-        // test unsafe_impl\n-        // unsafe impl Foo {}\n-\n-        // test default_impl\n-        // default impl Foo {}\n-\n-        // test_err default_fn_type\n-        // trait T {\n-        //     default type T = Bar;\n-        //     default fn foo() {}\n-        // }\n-\n-        // test default_fn_type\n-        // impl T for Foo {\n-        //     default type T = Bar;\n-        //     default fn foo() {}\n-        // }\n         T![const] => {\n-            consts::const_def(p, m);\n+            consts::konst(p, m);\n         }\n \n-        // test unsafe_default_impl\n-        // unsafe default impl Foo {}\n+        // test impl\n+        // impl T for S {}\n         T![impl] => {\n-            traits::impl_def(p);\n+            traits::impl_(p);\n             m.complete(p, IMPL);\n         }\n \n-        // test existential_type\n-        // existential type Foo: Fn() -> usize;\n         T![type] => {\n-            type_def(p, m);\n+            type_alias(p, m);\n         }\n         _ => {\n             if !has_visibility && !has_mods {\n@@ -250,9 +202,9 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n     match p.current() {\n         // test extern_crate\n         // extern crate foo;\n-        T![extern] if la == T![crate] => extern_crate_item(p, m),\n+        T![extern] if la == T![crate] => extern_crate(p, m),\n         T![type] => {\n-            type_def(p, m);\n+            type_alias(p, m);\n         }\n         T![mod] => mod_item(p, m),\n         T![struct] => {\n@@ -265,7 +217,7 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n             //     a: i32,\n             //     b: f32,\n             // }\n-            adt::struct_def(p, m);\n+            adt::strukt(p, m);\n         }\n         // test pub_macro_def\n         // pub macro m($:ident) {}\n@@ -279,12 +231,12 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n             //     a: i32,\n             //     b: f32,\n             // }\n-            adt::union_def(p, m);\n+            adt::union(p, m);\n         }\n-        T![enum] => adt::enum_def(p, m),\n-        T![use] => use_item::use_item(p, m),\n-        T![const] if (la == IDENT || la == T![_] || la == T![mut]) => consts::const_def(p, m),\n-        T![static] => consts::static_def(p, m),\n+        T![enum] => adt::enum_(p, m),\n+        T![use] => use_item::use_(p, m),\n+        T![const] if (la == IDENT || la == T![_] || la == T![mut]) => consts::konst(p, m),\n+        T![static] => consts::static_(p, m),\n         // test extern_block\n         // extern {}\n         T![extern]\n@@ -299,7 +251,7 @@ fn items_without_modifiers(p: &mut Parser, m: Marker) -> Result<(), Marker> {\n     Ok(())\n }\n \n-fn extern_crate_item(p: &mut Parser, m: Marker) {\n+fn extern_crate(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![extern]));\n     p.bump(T![extern]);\n     assert!(p.at(T![crate]));\n@@ -311,7 +263,7 @@ fn extern_crate_item(p: &mut Parser, m: Marker) {\n         name_ref(p);\n     }\n \n-    opt_alias(p);\n+    opt_rename(p);\n     p.expect(T![;]);\n     m.complete(p, EXTERN_CRATE);\n }\n@@ -325,14 +277,14 @@ pub(crate) fn extern_item_list(p: &mut Parser) {\n     m.complete(p, EXTERN_ITEM_LIST);\n }\n \n-fn fn_def(p: &mut Parser) {\n+fn fn_(p: &mut Parser) {\n     assert!(p.at(T![fn]));\n     p.bump(T![fn]);\n \n     name_r(p, ITEM_RECOVERY_SET);\n     // test function_type_params\n     // fn foo<T: Clone + Copy>(){}\n-    type_params::opt_type_param_list(p);\n+    type_params::opt_generic_param_list(p);\n \n     if p.at(T!['(']) {\n         params::param_list_fn_def(p);\n@@ -342,7 +294,7 @@ fn fn_def(p: &mut Parser) {\n     // test function_ret_type\n     // fn foo() {}\n     // fn bar() -> () {}\n-    opt_fn_ret_type(p);\n+    opt_ret_type(p);\n \n     // test function_where_clause\n     // fn foo<T>() where T: Copy {}\n@@ -359,15 +311,15 @@ fn fn_def(p: &mut Parser) {\n \n // test type_item\n // type Foo = Bar;\n-fn type_def(p: &mut Parser, m: Marker) {\n+fn type_alias(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![type]));\n     p.bump(T![type]);\n \n     name(p);\n \n     // test type_item_type_params\n     // type Result<T> = ();\n-    type_params::opt_type_param_list(p);\n+    type_params::opt_generic_param_list(p);\n \n     if p.at(T![:]) {\n         type_params::bounds(p);\n@@ -389,14 +341,14 @@ pub(crate) fn mod_item(p: &mut Parser, m: Marker) {\n \n     name(p);\n     if p.at(T!['{']) {\n-        mod_item_list(p);\n+        item_list(p);\n     } else if !p.eat(T![;]) {\n         p.error(\"expected `;` or `{`\");\n     }\n     m.complete(p, MODULE);\n }\n \n-pub(crate) fn mod_item_list(p: &mut Parser) {\n+pub(crate) fn item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);", "previous_filename": "crates/ra_parser/src/grammar/items.rs"}, {"sha": "67c0c56970716b7e717b586a3dc83191ec5b0937", "filename": "crates/parser/src/grammar/items/adt.rs", "status": "renamed", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fadt.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,29 +2,29 @@\n \n use super::*;\n \n-pub(super) fn struct_def(p: &mut Parser, m: Marker) {\n+pub(super) fn strukt(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![struct]));\n     p.bump(T![struct]);\n     struct_or_union(p, m, T![struct], STRUCT);\n }\n \n-pub(super) fn union_def(p: &mut Parser, m: Marker) {\n+pub(super) fn union(p: &mut Parser, m: Marker) {\n     assert!(p.at_contextual_kw(\"union\"));\n     p.bump_remap(T![union]);\n     struct_or_union(p, m, T![union], UNION);\n }\n \n fn struct_or_union(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n     name_r(p, ITEM_RECOVERY_SET);\n-    type_params::opt_type_param_list(p);\n+    type_params::opt_generic_param_list(p);\n     match p.current() {\n         T![where] => {\n             type_params::opt_where_clause(p);\n             match p.current() {\n                 T![;] => {\n                     p.bump(T![;]);\n                 }\n-                T!['{'] => record_field_def_list(p),\n+                T!['{'] => record_field_list(p),\n                 _ => {\n                     //FIXME: special case `(` error message\n                     p.error(\"expected `;` or `{`\");\n@@ -34,9 +34,9 @@ fn struct_or_union(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n         T![;] if kw == T![struct] => {\n             p.bump(T![;]);\n         }\n-        T!['{'] => record_field_def_list(p),\n+        T!['{'] => record_field_list(p),\n         T!['('] if kw == T![struct] => {\n-            tuple_field_def_list(p);\n+            tuple_field_list(p);\n             // test tuple_struct_where\n             // struct Test<T>(T) where T: Clone;\n             // struct Test<T>(T);\n@@ -53,21 +53,21 @@ fn struct_or_union(p: &mut Parser, m: Marker, kw: SyntaxKind, def: SyntaxKind) {\n     m.complete(p, def);\n }\n \n-pub(super) fn enum_def(p: &mut Parser, m: Marker) {\n+pub(super) fn enum_(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![enum]));\n     p.bump(T![enum]);\n     name_r(p, ITEM_RECOVERY_SET);\n-    type_params::opt_type_param_list(p);\n+    type_params::opt_generic_param_list(p);\n     type_params::opt_where_clause(p);\n     if p.at(T!['{']) {\n-        enum_variant_list(p);\n+        variant_list(p);\n     } else {\n         p.error(\"expected `{`\")\n     }\n     m.complete(p, ENUM);\n }\n \n-pub(crate) fn enum_variant_list(p: &mut Parser) {\n+pub(crate) fn variant_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -77,12 +77,12 @@ pub(crate) fn enum_variant_list(p: &mut Parser) {\n             continue;\n         }\n         let var = p.start();\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n         if p.at(IDENT) {\n             name(p);\n             match p.current() {\n-                T!['{'] => record_field_def_list(p),\n-                T!['('] => tuple_field_def_list(p),\n+                T!['{'] => record_field_list(p),\n+                T!['('] => tuple_field_list(p),\n                 _ => (),\n             }\n \n@@ -104,7 +104,7 @@ pub(crate) fn enum_variant_list(p: &mut Parser) {\n     m.complete(p, VARIANT_LIST);\n }\n \n-pub(crate) fn record_field_def_list(p: &mut Parser) {\n+pub(crate) fn record_field_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -128,7 +128,7 @@ pub(crate) fn record_field_def_list(p: &mut Parser) {\n         //     #[serde(with = \"url_serde\")]\n         //     pub uri: Uri,\n         // }\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n         opt_visibility(p);\n         if p.at(IDENT) {\n             name(p);\n@@ -142,7 +142,7 @@ pub(crate) fn record_field_def_list(p: &mut Parser) {\n     }\n }\n \n-fn tuple_field_def_list(p: &mut Parser) {\n+fn tuple_field_list(p: &mut Parser) {\n     assert!(p.at(T!['(']));\n     let m = p.start();\n     if !p.expect(T!['(']) {\n@@ -159,7 +159,7 @@ fn tuple_field_def_list(p: &mut Parser) {\n         // enum S {\n         //     Uri(#[serde(with = \"url_serde\")] Uri),\n         // }\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n         opt_visibility(p);\n         if !p.at_ts(types::TYPE_FIRST) {\n             p.error(\"expected a type\");", "previous_filename": "crates/ra_parser/src/grammar/items/adt.rs"}, {"sha": "eb7d1f8281dee00d6d2fab4f316663d36e13d597", "filename": "crates/parser/src/grammar/items/consts.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fconsts.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,11 +2,11 @@\n \n use super::*;\n \n-pub(super) fn static_def(p: &mut Parser, m: Marker) {\n+pub(super) fn static_(p: &mut Parser, m: Marker) {\n     const_or_static(p, m, T![static], STATIC)\n }\n \n-pub(super) fn const_def(p: &mut Parser, m: Marker) {\n+pub(super) fn konst(p: &mut Parser, m: Marker) {\n     const_or_static(p, m, T![const], CONST)\n }\n ", "previous_filename": "crates/ra_parser/src/grammar/items/consts.rs"}, {"sha": "8394020dafae3b70d3daa24f637147470237dfa8", "filename": "crates/parser/src/grammar/items/traits.rs", "status": "renamed", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,11 +5,11 @@ use super::*;\n // test trait_item\n // trait T<U>: Hash + Clone where U: Copy {}\n // trait X<U: Debug + Display>: Hash + Clone where U: Copy {}\n-pub(super) fn trait_def(p: &mut Parser) {\n+pub(super) fn trait_(p: &mut Parser) {\n     assert!(p.at(T![trait]));\n     p.bump(T![trait]);\n     name_r(p, ITEM_RECOVERY_SET);\n-    type_params::opt_type_param_list(p);\n+    type_params::opt_generic_param_list(p);\n     // test trait_alias\n     // trait Z<U> = T<U>;\n     // trait Z<U> = T<U> where U: Copy;\n@@ -25,41 +25,19 @@ pub(super) fn trait_def(p: &mut Parser) {\n     }\n     type_params::opt_where_clause(p);\n     if p.at(T!['{']) {\n-        trait_item_list(p);\n+        assoc_item_list(p);\n     } else {\n         p.error(\"expected `{`\");\n     }\n }\n \n-// test trait_item_list\n-// impl F {\n-//     type A: Clone;\n-//     const B: i32;\n-//     fn foo() {}\n-//     fn bar(&self);\n-// }\n-pub(crate) fn trait_item_list(p: &mut Parser) {\n-    assert!(p.at(T!['{']));\n-    let m = p.start();\n-    p.bump(T!['{']);\n-    while !p.at(EOF) && !p.at(T!['}']) {\n-        if p.at(T!['{']) {\n-            error_block(p, \"expected an item\");\n-            continue;\n-        }\n-        item_or_macro(p, true, ItemFlavor::Trait);\n-    }\n-    p.expect(T!['}']);\n-    m.complete(p, ASSOC_ITEM_LIST);\n-}\n-\n // test impl_def\n // impl Foo {}\n-pub(super) fn impl_def(p: &mut Parser) {\n+pub(super) fn impl_(p: &mut Parser) {\n     assert!(p.at(T![impl]));\n     p.bump(T![impl]);\n     if choose_type_params_over_qpath(p) {\n-        type_params::opt_type_param_list(p);\n+        type_params::opt_generic_param_list(p);\n     }\n \n     // FIXME: never type\n@@ -74,7 +52,7 @@ pub(super) fn impl_def(p: &mut Parser) {\n     }\n     type_params::opt_where_clause(p);\n     if p.at(T!['{']) {\n-        impl_item_list(p);\n+        assoc_item_list(p);\n     } else {\n         p.error(\"expected `{`\");\n     }\n@@ -87,7 +65,7 @@ pub(super) fn impl_def(p: &mut Parser) {\n //     fn foo() {}\n //     fn bar(&self) {}\n // }\n-pub(crate) fn impl_item_list(p: &mut Parser) {\n+pub(crate) fn assoc_item_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n@@ -97,14 +75,14 @@ pub(crate) fn impl_item_list(p: &mut Parser) {\n     //      //! This is a doc comment\n     //      #![doc(\"This is also a doc comment\")]\n     // }\n-    attributes::inner_attributes(p);\n+    attributes::inner_attrs(p);\n \n     while !p.at(EOF) && !p.at(T!['}']) {\n         if p.at(T!['{']) {\n             error_block(p, \"expected an item\");\n             continue;\n         }\n-        item_or_macro(p, true, ItemFlavor::Mod);\n+        item_or_macro(p, true);\n     }\n     p.expect(T!['}']);\n     m.complete(p, ASSOC_ITEM_LIST);", "previous_filename": "crates/ra_parser/src/grammar/items/traits.rs"}, {"sha": "20e6a13cf96da0933c2ce7947ec1d160e6c0a4b0", "filename": "crates/parser/src/grammar/items/use_item.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fitems%2Fuse_item.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,7 +2,7 @@\n \n use super::*;\n \n-pub(super) fn use_item(p: &mut Parser, m: Marker) {\n+pub(super) fn use_(p: &mut Parser, m: Marker) {\n     assert!(p.at(T![use]));\n     p.bump(T![use]);\n     use_tree(p, true);\n@@ -80,7 +80,7 @@ fn use_tree(p: &mut Parser, top_level: bool) {\n                     //  running::out::of::synonyms::for_::different::*\n                     // };\n                     // use Trait as _;\n-                    opt_alias(p);\n+                    opt_rename(p);\n                 }\n                 T![:] if p.at(T![::]) => {\n                     p.bump(T![::]);", "previous_filename": "crates/ra_parser/src/grammar/items/use_item.rs"}, {"sha": "a665ffc133c9a97816c15a197b9478d2a551a548", "filename": "crates/parser/src/grammar/params.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fparams.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -47,20 +47,20 @@ fn list_(p: &mut Parser, flavor: Flavor) {\n     if let FnDef = flavor {\n         // test self_param_outer_attr\n         // fn f(#[must_use] self) {}\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n         opt_self_param(p);\n     }\n \n     while !p.at(EOF) && !p.at(ket) {\n         // test param_outer_arg\n         // fn f(#[attr1] pat: Type) {}\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n \n-        if !p.at_ts(VALUE_PARAMETER_FIRST) {\n+        if !p.at_ts(PARAM_FIRST) {\n             p.error(\"expected value parameter\");\n             break;\n         }\n-        let param = value_parameter(p, flavor);\n+        let param = param(p, flavor);\n         if !p.at(ket) {\n             p.expect(T![,]);\n         }\n@@ -73,11 +73,11 @@ fn list_(p: &mut Parser, flavor: Flavor) {\n     m.complete(p, PARAM_LIST);\n }\n \n-const VALUE_PARAMETER_FIRST: TokenSet = patterns::PATTERN_FIRST.union(types::TYPE_FIRST);\n+const PARAM_FIRST: TokenSet = patterns::PATTERN_FIRST.union(types::TYPE_FIRST);\n \n struct Variadic(bool);\n \n-fn value_parameter(p: &mut Parser, flavor: Flavor) -> Variadic {\n+fn param(p: &mut Parser, flavor: Flavor) -> Variadic {\n     let mut res = Variadic(false);\n     let m = p.start();\n     match flavor {", "previous_filename": "crates/ra_parser/src/grammar/params.rs"}, {"sha": "52562afa41c7c0fde56041e974727fc10ee38128", "filename": "crates/parser/src/grammar/paths.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpaths.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -105,11 +105,11 @@ fn opt_path_type_args(p: &mut Parser, mode: Mode) {\n             // type F = Box<Fn(i32) -> ()>;\n             if p.at(T!['(']) {\n                 params::param_list_fn_trait(p);\n-                opt_fn_ret_type(p);\n+                opt_ret_type(p);\n             } else {\n-                type_args::opt_type_arg_list(p, false)\n+                type_args::opt_generic_arg_list(p, false)\n             }\n         }\n-        Mode::Expr => type_args::opt_type_arg_list(p, true),\n+        Mode::Expr => type_args::opt_generic_arg_list(p, true),\n     }\n }", "previous_filename": "crates/ra_parser/src/grammar/paths.rs"}, {"sha": "07b1d6dd53c4c8c8516dab3392d4d19d8553aaef", "filename": "crates/parser/src/grammar/patterns.rs", "status": "renamed", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -79,22 +79,22 @@ const PAT_RECOVERY_SET: TokenSet =\n fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n     let m = match p.nth(0) {\n         T![box] => box_pat(p),\n-        T![ref] | T![mut] => bind_pat(p, true),\n+        T![ref] | T![mut] => ident_pat(p, true),\n         IDENT => match p.nth(1) {\n             // Checks the token after an IDENT to see if a pattern is a path (Struct { .. }) or macro\n             // (T![x]).\n             T!['('] | T!['{'] | T![!] => path_or_macro_pat(p),\n             T![:] if p.nth_at(1, T![::]) => path_or_macro_pat(p),\n-            _ => bind_pat(p, true),\n+            _ => ident_pat(p, true),\n         },\n \n         // test type_path_in_pattern\n         // fn main() { let <_>::Foo = (); }\n         _ if paths::is_path_start(p) => path_or_macro_pat(p),\n         _ if is_literal_pat_start(p) => literal_pat(p),\n \n-        T![.] if p.at(T![..]) => dot_dot_pat(p),\n-        T![_] => placeholder_pat(p),\n+        T![.] if p.at(T![..]) => rest_pat(p),\n+        T![_] => wildcard_pat(p),\n         T![&] => ref_pat(p),\n         T!['('] => tuple_pat(p),\n         T!['['] => slice_pat(p),\n@@ -149,7 +149,7 @@ fn path_or_macro_pat(p: &mut Parser) -> CompletedMarker {\n             TUPLE_STRUCT_PAT\n         }\n         T!['{'] => {\n-            record_field_pat_list(p);\n+            record_pat_field_list(p);\n             RECORD_PAT\n         }\n         // test marco_pat\n@@ -186,13 +186,13 @@ fn tuple_pat_fields(p: &mut Parser) {\n //     let S { h: _, ..} = ();\n //     let S { h: _, } = ();\n // }\n-fn record_field_pat_list(p: &mut Parser) {\n+fn record_pat_field_list(p: &mut Parser) {\n     assert!(p.at(T!['{']));\n     let m = p.start();\n     p.bump(T!['{']);\n     while !p.at(EOF) && !p.at(T!['}']) {\n         match p.current() {\n-            // A trailing `..` is *not* treated as a DOT_DOT_PAT.\n+            // A trailing `..` is *not* treated as a REST_PAT.\n             T![.] if p.at(T![..]) => p.bump(T![..]),\n             T!['{'] => error_block(p, \"expected ident\"),\n \n@@ -214,27 +214,27 @@ fn record_field_pat_list(p: &mut Parser) {\n                         box_pat(p);\n                     }\n                     _ => {\n-                        bind_pat(p, false);\n+                        ident_pat(p, false);\n                     }\n                 }\n-                m.complete(p, RECORD_FIELD_PAT);\n+                m.complete(p, RECORD_PAT_FIELD);\n             }\n         }\n         if !p.at(T!['}']) {\n             p.expect(T![,]);\n         }\n     }\n     p.expect(T!['}']);\n-    m.complete(p, RECORD_FIELD_PAT_LIST);\n+    m.complete(p, RECORD_PAT_FIELD_LIST);\n }\n \n // test placeholder_pat\n // fn main() { let _ = (); }\n-fn placeholder_pat(p: &mut Parser) -> CompletedMarker {\n+fn wildcard_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![_]));\n     let m = p.start();\n     p.bump(T![_]);\n-    m.complete(p, PLACEHOLDER_PAT)\n+    m.complete(p, WILDCARD_PAT)\n }\n \n // test dot_dot_pat\n@@ -263,11 +263,11 @@ fn placeholder_pat(p: &mut Parser) -> CompletedMarker {\n //     let [head, .., mid, tail @ ..] = ();\n //     let [head, .., mid, .., cons] = ();\n // }\n-fn dot_dot_pat(p: &mut Parser) -> CompletedMarker {\n+fn rest_pat(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![..]));\n     let m = p.start();\n     p.bump(T![..]);\n-    m.complete(p, DOT_DOT_PAT)\n+    m.complete(p, REST_PAT)\n }\n \n // test ref_pat\n@@ -353,15 +353,15 @@ fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n //     let e @ _ = ();\n //     let ref mut f @ g @ _ = ();\n // }\n-fn bind_pat(p: &mut Parser, with_at: bool) -> CompletedMarker {\n+fn ident_pat(p: &mut Parser, with_at: bool) -> CompletedMarker {\n     let m = p.start();\n     p.eat(T![ref]);\n     p.eat(T![mut]);\n     name(p);\n     if with_at && p.eat(T![@]) {\n         pattern_single(p);\n     }\n-    m.complete(p, BIND_PAT)\n+    m.complete(p, IDENT_PAT)\n }\n \n // test box_pat", "previous_filename": "crates/ra_parser/src/grammar/patterns.rs"}, {"sha": "f2d34a749955f1f58ff3f5aaf4e407663e5e6dd5", "filename": "crates/parser/src/grammar/type_args.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_args.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,7 +2,7 @@\n \n use super::*;\n \n-pub(super) fn opt_type_arg_list(p: &mut Parser, colon_colon_required: bool) {\n+pub(super) fn opt_generic_arg_list(p: &mut Parser, colon_colon_required: bool) {\n     let m;\n     if p.at(T![::]) && p.nth(2) == T![<] {\n         m = p.start();\n@@ -16,18 +16,18 @@ pub(super) fn opt_type_arg_list(p: &mut Parser, colon_colon_required: bool) {\n     }\n \n     while !p.at(EOF) && !p.at(T![>]) {\n-        type_arg(p);\n+        generic_arg(p);\n         if !p.at(T![>]) && !p.expect(T![,]) {\n             break;\n         }\n     }\n     p.expect(T![>]);\n-    m.complete(p, TYPE_ARG_LIST);\n+    m.complete(p, GENERIC_ARG_LIST);\n }\n \n // test type_arg\n // type A = B<'static, i32, 1, { 2 }, Item=u64>;\n-fn type_arg(p: &mut Parser) {\n+fn generic_arg(p: &mut Parser) {\n     let m = p.start();\n     match p.current() {\n         LIFETIME => {\n@@ -52,7 +52,7 @@ fn type_arg(p: &mut Parser) {\n             m.complete(p, CONST_ARG);\n         }\n         k if k.is_literal() => {\n-            p.bump(k);\n+            expressions::literal(p);\n             m.complete(p, CONST_ARG);\n         }\n         _ => {", "previous_filename": "crates/ra_parser/src/grammar/type_args.rs"}, {"sha": "bc7d8d7244a3b5ed574187461776cddba7b8552b", "filename": "crates/parser/src/grammar/type_params.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftype_params.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -2,14 +2,14 @@\n \n use super::*;\n \n-pub(super) fn opt_type_param_list(p: &mut Parser) {\n+pub(super) fn opt_generic_param_list(p: &mut Parser) {\n     if !p.at(T![<]) {\n         return;\n     }\n-    type_param_list(p);\n+    generic_param_list(p);\n }\n \n-fn type_param_list(p: &mut Parser) {\n+fn generic_param_list(p: &mut Parser) {\n     assert!(p.at(T![<]));\n     let m = p.start();\n     p.bump(T![<]);\n@@ -20,12 +20,12 @@ fn type_param_list(p: &mut Parser) {\n         // test generic_lifetime_type_attribute\n         // fn foo<#[derive(Lifetime)] 'a, #[derive(Type)] T>(_: &'a T) {\n         // }\n-        attributes::outer_attributes(p);\n+        attributes::outer_attrs(p);\n \n         match p.current() {\n             LIFETIME => lifetime_param(p, m),\n             IDENT => type_param(p, m),\n-            CONST_KW => type_const_param(p, m),\n+            CONST_KW => const_param(p, m),\n             _ => {\n                 m.abandon(p);\n                 p.err_and_bump(\"expected type parameter\")\n@@ -65,7 +65,7 @@ fn type_param(p: &mut Parser, m: Marker) {\n \n // test const_param\n // struct S<const N: u32>;\n-fn type_const_param(p: &mut Parser, m: Marker) {\n+fn const_param(p: &mut Parser, m: Marker) {\n     assert!(p.at(CONST_KW));\n     p.bump(T![const]);\n     name(p);", "previous_filename": "crates/ra_parser/src/grammar/type_params.rs"}, {"sha": "c876545f441d9918bec4af35bd845107a44f51af", "filename": "crates/parser/src/grammar/types.rs", "status": "renamed", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Ftypes.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -32,11 +32,11 @@ fn type_with_bounds_cond(p: &mut Parser, allow_bounds: bool) {\n     match p.current() {\n         T!['('] => paren_or_tuple_type(p),\n         T![!] => never_type(p),\n-        T![*] => pointer_type(p),\n+        T![*] => ptr_type(p),\n         T!['['] => array_or_slice_type(p),\n-        T![&] => reference_type(p),\n-        T![_] => placeholder_type(p),\n-        T![fn] | T![unsafe] | T![extern] => fn_pointer_type(p),\n+        T![&] => ref_type(p),\n+        T![_] => infer_type(p),\n+        T![fn] | T![unsafe] | T![extern] => fn_ptr_type(p),\n         T![for] => for_type(p),\n         T![impl] => impl_trait_type(p),\n         T![dyn] => dyn_trait_type(p),\n@@ -96,7 +96,7 @@ fn never_type(p: &mut Parser) {\n     m.complete(p, NEVER_TYPE);\n }\n \n-fn pointer_type(p: &mut Parser) {\n+fn ptr_type(p: &mut Parser) {\n     assert!(p.at(T![*]));\n     let m = p.start();\n     p.bump(T![*]);\n@@ -117,7 +117,7 @@ fn pointer_type(p: &mut Parser) {\n     };\n \n     type_no_bounds(p);\n-    m.complete(p, POINTER_TYPE);\n+    m.complete(p, PTR_TYPE);\n }\n \n fn array_or_slice_type(p: &mut Parser) {\n@@ -156,31 +156,31 @@ fn array_or_slice_type(p: &mut Parser) {\n // type A = &();\n // type B = &'static ();\n // type C = &mut ();\n-fn reference_type(p: &mut Parser) {\n+fn ref_type(p: &mut Parser) {\n     assert!(p.at(T![&]));\n     let m = p.start();\n     p.bump(T![&]);\n     p.eat(LIFETIME);\n     p.eat(T![mut]);\n     type_no_bounds(p);\n-    m.complete(p, REFERENCE_TYPE);\n+    m.complete(p, REF_TYPE);\n }\n \n // test placeholder_type\n // type Placeholder = _;\n-fn placeholder_type(p: &mut Parser) {\n+fn infer_type(p: &mut Parser) {\n     assert!(p.at(T![_]));\n     let m = p.start();\n     p.bump(T![_]);\n-    m.complete(p, PLACEHOLDER_TYPE);\n+    m.complete(p, INFER_TYPE);\n }\n \n // test fn_pointer_type\n // type A = fn();\n // type B = unsafe fn();\n // type C = unsafe extern \"C\" fn();\n // type D = extern \"C\" fn ( u8 , ... ) -> u8;\n-fn fn_pointer_type(p: &mut Parser) {\n+fn fn_ptr_type(p: &mut Parser) {\n     let m = p.start();\n     p.eat(T![unsafe]);\n     if p.at(T![extern]) {\n@@ -200,15 +200,15 @@ fn fn_pointer_type(p: &mut Parser) {\n     }\n     // test fn_pointer_type_with_ret\n     // type F = fn() -> ();\n-    opt_fn_ret_type(p);\n-    m.complete(p, FN_POINTER_TYPE);\n+    opt_ret_type(p);\n+    m.complete(p, FN_PTR_TYPE);\n }\n \n pub(super) fn for_binder(p: &mut Parser) {\n     assert!(p.at(T![for]));\n     p.bump(T![for]);\n     if p.at(T![<]) {\n-        type_params::opt_type_param_list(p);\n+        type_params::opt_generic_param_list(p);\n     } else {\n         p.error(\"expected `<`\");\n     }", "previous_filename": "crates/ra_parser/src/grammar/types.rs"}, {"sha": "41e62116f88c4999da37ed5a5f214b8d711f1ee7", "filename": "crates/parser/src/lib.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -10,7 +10,7 @@\n //!\n //! The actual parsing happens in the `grammar` module.\n //!\n-//! Tests for this crate live in `ra_syntax` crate.\n+//! Tests for this crate live in `syntax` crate.\n \n #[macro_use]\n mod token_set;", "previous_filename": "crates/ra_parser/src/lib.rs"}, {"sha": "d2487acc3b9c4b6d449db01cc1599e384c3c2060", "filename": "crates/parser/src/parser.rs", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fparser.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -269,8 +269,8 @@ impl Marker {\n     pub(crate) fn complete(mut self, p: &mut Parser, kind: SyntaxKind) -> CompletedMarker {\n         self.bomb.defuse();\n         let idx = self.pos as usize;\n-        match p.events[idx] {\n-            Event::Start { kind: ref mut slot, .. } => {\n+        match &mut p.events[idx] {\n+            Event::Start { kind: slot, .. } => {\n                 *slot = kind;\n             }\n             _ => unreachable!(),\n@@ -320,8 +320,8 @@ impl CompletedMarker {\n     pub(crate) fn precede(self, p: &mut Parser) -> Marker {\n         let new_pos = p.start();\n         let idx = self.start_pos as usize;\n-        match p.events[idx] {\n-            Event::Start { ref mut forward_parent, .. } => {\n+        match &mut p.events[idx] {\n+            Event::Start { forward_parent, .. } => {\n                 *forward_parent = Some(new_pos.pos - self.start_pos);\n             }\n             _ => unreachable!(),\n@@ -333,12 +333,12 @@ impl CompletedMarker {\n     pub(crate) fn undo_completion(self, p: &mut Parser) -> Marker {\n         let start_idx = self.start_pos as usize;\n         let finish_idx = self.finish_pos as usize;\n-        match p.events[start_idx] {\n-            Event::Start { ref mut kind, forward_parent: None } => *kind = TOMBSTONE,\n+        match &mut p.events[start_idx] {\n+            Event::Start { kind, forward_parent: None } => *kind = TOMBSTONE,\n             _ => unreachable!(),\n         }\n-        match p.events[finish_idx] {\n-            ref mut slot @ Event::Finish => *slot = Event::tombstone(),\n+        match &mut p.events[finish_idx] {\n+            slot @ Event::Finish => *slot = Event::tombstone(),\n             _ => unreachable!(),\n         }\n         Marker::new(self.start_pos)", "previous_filename": "crates/ra_parser/src/parser.rs"}, {"sha": "63204436c33e453d2b6aebc5cbbf2cdd4f3739ab", "filename": "crates/parser/src/syntax_kind.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fsyntax_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fsyntax_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fsyntax_kind.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_parser/src/syntax_kind.rs"}, {"sha": "192ecd864e93ffda16ce7e8b0e324c5b0bf256e1", "filename": "crates/parser/src/syntax_kind/generated.rs", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -143,26 +143,26 @@ pub enum SyntaxKind {\n     TUPLE_TYPE,\n     NEVER_TYPE,\n     PATH_TYPE,\n-    POINTER_TYPE,\n+    PTR_TYPE,\n     ARRAY_TYPE,\n     SLICE_TYPE,\n-    REFERENCE_TYPE,\n-    PLACEHOLDER_TYPE,\n-    FN_POINTER_TYPE,\n+    REF_TYPE,\n+    INFER_TYPE,\n+    FN_PTR_TYPE,\n     FOR_TYPE,\n     IMPL_TRAIT_TYPE,\n     DYN_TRAIT_TYPE,\n     OR_PAT,\n     PAREN_PAT,\n     REF_PAT,\n     BOX_PAT,\n-    BIND_PAT,\n-    PLACEHOLDER_PAT,\n-    DOT_DOT_PAT,\n+    IDENT_PAT,\n+    WILDCARD_PAT,\n+    REST_PAT,\n     PATH_PAT,\n     RECORD_PAT,\n-    RECORD_FIELD_PAT_LIST,\n-    RECORD_FIELD_PAT,\n+    RECORD_PAT_FIELD_LIST,\n+    RECORD_PAT_FIELD,\n     TUPLE_STRUCT_PAT,\n     TUPLE_PAT,\n     SLICE_PAT,\n@@ -173,7 +173,7 @@ pub enum SyntaxKind {\n     ARRAY_EXPR,\n     PAREN_EXPR,\n     PATH_EXPR,\n-    LAMBDA_EXPR,\n+    CLOSURE_EXPR,\n     IF_EXPR,\n     WHILE_EXPR,\n     CONDITION,\n@@ -235,7 +235,7 @@ pub enum SyntaxKind {\n     LIFETIME_PARAM,\n     TYPE_PARAM,\n     CONST_PARAM,\n-    TYPE_ARG_LIST,\n+    GENERIC_ARG_LIST,\n     LIFETIME_ARG,\n     TYPE_ARG,\n     ASSOC_TYPE_ARG,", "previous_filename": "crates/ra_parser/src/syntax_kind/generated.rs"}, {"sha": "994017acfd4409b2912313a9fb5cda9e3eb45ae6", "filename": "crates/parser/src/token_set.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Ftoken_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fparser%2Fsrc%2Ftoken_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Ftoken_set.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_parser/src/token_set.rs"}, {"sha": "5ac18d63b350acfc0e99587c4fed0fd3b5c323a4", "filename": "crates/paths/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fpaths%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fpaths%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fpaths%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,9 +1,9 @@\n [package]\n name = \"paths\"\n-version = \"0.1.0\"\n+version = \"0.0.0\"\n+license = \"MIT OR Apache-2.0\"\n authors = [\"rust-analyzer developers\"]\n edition = \"2018\"\n-license = \"MIT OR Apache-2.0\"\n \n [lib]\n doctest = false"}, {"sha": "a3a4c1103332e883624fb9d31685f00f16ca7cd9", "filename": "crates/proc_macro_api/Cargo.toml", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_api%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_api%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,18 +1,18 @@\n [package]\n-edition = \"2018\"\n-name = \"ra_proc_macro\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n-publish = false\n+name = \"proc_macro_api\"\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false\n \n [dependencies]\n-ra_tt = { path = \"../ra_tt\" }\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\"\n log = \"0.4.8\"\n crossbeam-channel = \"0.4.0\"\n jod-thread = \"0.1.1\"\n+\n+tt = { path = \"../tt\" }", "previous_filename": "crates/ra_proc_macro/Cargo.toml"}, {"sha": "d5e87cf7d59cbf5c5453c2d4cf0da381714292aa", "filename": "crates/proc_macro_api/src/lib.rs", "status": "renamed", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -9,15 +9,17 @@ mod rpc;\n mod process;\n pub mod msg;\n \n-use process::{ProcMacroProcessSrv, ProcMacroProcessThread};\n-use ra_tt::{SmolStr, Subtree};\n use std::{\n     ffi::OsStr,\n     io,\n     path::{Path, PathBuf},\n     sync::Arc,\n };\n \n+use tt::{SmolStr, Subtree};\n+\n+use crate::process::{ProcMacroProcessSrv, ProcMacroProcessThread};\n+\n pub use rpc::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask, ProcMacroKind};\n \n #[derive(Debug, Clone)]\n@@ -36,12 +38,12 @@ impl PartialEq for ProcMacroProcessExpander {\n     }\n }\n \n-impl ra_tt::TokenExpander for ProcMacroProcessExpander {\n+impl tt::TokenExpander for ProcMacroProcessExpander {\n     fn expand(\n         &self,\n         subtree: &Subtree,\n         _attr: Option<&Subtree>,\n-    ) -> Result<Subtree, ra_tt::ExpansionError> {\n+    ) -> Result<Subtree, tt::ExpansionError> {\n         self.process.custom_derive(&self.dylib_path, subtree, &self.name)\n     }\n }\n@@ -72,10 +74,7 @@ impl ProcMacroClient {\n         ProcMacroClient { kind: ProcMacroClientKind::Dummy }\n     }\n \n-    pub fn by_dylib_path(\n-        &self,\n-        dylib_path: &Path,\n-    ) -> Vec<(SmolStr, Arc<dyn ra_tt::TokenExpander>)> {\n+    pub fn by_dylib_path(&self, dylib_path: &Path) -> Vec<(SmolStr, Arc<dyn tt::TokenExpander>)> {\n         match &self.kind {\n             ProcMacroClientKind::Dummy => vec![],\n             ProcMacroClientKind::Process { process, .. } => {\n@@ -90,19 +89,19 @@ impl ProcMacroClient {\n                 macros\n                     .into_iter()\n                     .filter_map(|(name, kind)| {\n-                        // FIXME: Support custom derive only for now.\n                         match kind {\n-                            ProcMacroKind::CustomDerive => {\n+                            ProcMacroKind::CustomDerive | ProcMacroKind::FuncLike => {\n                                 let name = SmolStr::new(&name);\n-                                let expander: Arc<dyn ra_tt::TokenExpander> =\n+                                let expander: Arc<dyn tt::TokenExpander> =\n                                     Arc::new(ProcMacroProcessExpander {\n                                         process: process.clone(),\n                                         name: name.clone(),\n                                         dylib_path: dylib_path.into(),\n                                     });\n                                 Some((name, expander))\n                             }\n-                            _ => None,\n+                            // FIXME: Attribute macro are currently unsupported.\n+                            ProcMacroKind::Attr => None,\n                         }\n                     })\n                     .collect()", "previous_filename": "crates/ra_proc_macro/src/lib.rs"}, {"sha": "f84ebdbc5744287f103c260f4e9ecac6c91f6294", "filename": "crates/proc_macro_api/src/msg.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Fmsg.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,11 +5,12 @@ use std::{\n     io::{self, BufRead, Write},\n };\n \n+use serde::{de::DeserializeOwned, Deserialize, Serialize};\n+\n use crate::{\n     rpc::{ListMacrosResult, ListMacrosTask},\n     ExpansionResult, ExpansionTask,\n };\n-use serde::{de::DeserializeOwned, Deserialize, Serialize};\n \n #[derive(Debug, Serialize, Deserialize, Clone)]\n pub enum Request {", "previous_filename": "crates/ra_proc_macro/src/msg.rs"}, {"sha": "51ffcaa786d82b3ba0fb6a54eba18d663ac4ab5b", "filename": "crates/proc_macro_api/src/process.rs", "status": "renamed", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Fprocess.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,21 +1,22 @@\n //! Handle process life-time and message passing for proc-macro client\n \n-use crossbeam_channel::{bounded, Receiver, Sender};\n-use ra_tt::Subtree;\n-\n-use crate::msg::{ErrorCode, Message, Request, Response, ResponseError};\n-use crate::rpc::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask, ProcMacroKind};\n-\n-use io::{BufRead, BufReader};\n use std::{\n     convert::{TryFrom, TryInto},\n     ffi::{OsStr, OsString},\n-    io::{self, Write},\n+    io::{self, BufRead, BufReader, Write},\n     path::{Path, PathBuf},\n     process::{Child, Command, Stdio},\n     sync::{Arc, Weak},\n };\n \n+use crossbeam_channel::{bounded, Receiver, Sender};\n+use tt::Subtree;\n+\n+use crate::{\n+    msg::{ErrorCode, Message, Request, Response, ResponseError},\n+    rpc::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask, ProcMacroKind},\n+};\n+\n #[derive(Debug, Default)]\n pub(crate) struct ProcMacroProcessSrv {\n     inner: Option<Weak<Sender<Task>>>,\n@@ -50,7 +51,7 @@ impl ProcMacroProcessSrv {\n     pub fn find_proc_macros(\n         &self,\n         dylib_path: &Path,\n-    ) -> Result<Vec<(String, ProcMacroKind)>, ra_tt::ExpansionError> {\n+    ) -> Result<Vec<(String, ProcMacroKind)>, tt::ExpansionError> {\n         let task = ListMacrosTask { lib: dylib_path.to_path_buf() };\n \n         let result: ListMacrosResult = self.send_task(Request::ListMacro(task))?;\n@@ -62,7 +63,7 @@ impl ProcMacroProcessSrv {\n         dylib_path: &Path,\n         subtree: &Subtree,\n         derive_name: &str,\n-    ) -> Result<Subtree, ra_tt::ExpansionError> {\n+    ) -> Result<Subtree, tt::ExpansionError> {\n         let task = ExpansionTask {\n             macro_body: subtree.clone(),\n             macro_name: derive_name.to_string(),\n@@ -74,38 +75,35 @@ impl ProcMacroProcessSrv {\n         Ok(result.expansion)\n     }\n \n-    pub fn send_task<R>(&self, req: Request) -> Result<R, ra_tt::ExpansionError>\n+    pub fn send_task<R>(&self, req: Request) -> Result<R, tt::ExpansionError>\n     where\n         R: TryFrom<Response, Error = &'static str>,\n     {\n         let sender = match &self.inner {\n-            None => return Err(ra_tt::ExpansionError::Unknown(\"No sender is found.\".to_string())),\n+            None => return Err(tt::ExpansionError::Unknown(\"No sender is found.\".to_string())),\n             Some(it) => it,\n         };\n \n         let (result_tx, result_rx) = bounded(0);\n         let sender = match sender.upgrade() {\n             None => {\n-                return Err(ra_tt::ExpansionError::Unknown(\"Proc macro process is closed.\".into()))\n+                return Err(tt::ExpansionError::Unknown(\"Proc macro process is closed.\".into()))\n             }\n             Some(it) => it,\n         };\n-        sender.send(Task { req: req.into(), result_tx }).unwrap();\n+        sender.send(Task { req, result_tx }).unwrap();\n         let res = result_rx\n             .recv()\n-            .map_err(|_| ra_tt::ExpansionError::Unknown(\"Proc macro thread is closed.\".into()))?;\n+            .map_err(|_| tt::ExpansionError::Unknown(\"Proc macro thread is closed.\".into()))?;\n \n         match res {\n             Some(Response::Error(err)) => {\n-                return Err(ra_tt::ExpansionError::ExpansionError(err.message));\n+                return Err(tt::ExpansionError::ExpansionError(err.message));\n             }\n             Some(res) => Ok(res.try_into().map_err(|err| {\n-                ra_tt::ExpansionError::Unknown(format!(\n-                    \"Fail to get response, reason : {:#?} \",\n-                    err\n-                ))\n+                tt::ExpansionError::Unknown(format!(\"Fail to get response, reason : {:#?} \", err))\n             })?),\n-            None => Err(ra_tt::ExpansionError::Unknown(\"Empty result\".into())),\n+            None => Err(tt::ExpansionError::Unknown(\"Empty result\".into())),\n         }\n     }\n }", "previous_filename": "crates/ra_proc_macro/src/process.rs"}, {"sha": "47624163ee22f5572b3bce7c0bf9005f72b230df", "filename": "crates/proc_macro_api/src/rpc.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_api%2Fsrc%2Frpc.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,17 +1,18 @@\n-//! Data struture serialization related stuff for RPC\n+//! Data structure serialization related stuff for RPC\n //!\n //! Defines all necessary rpc serialization data structures,\n-//! which includes `ra_tt` related data and some task messages.\n-//! Although adding `Serialize` and `Deserialize` traits to `ra_tt` directly seems\n-//! to be much easier, we deliberately duplicate `ra_tt` structs with `#[serde(with = \"XXDef\")]`\n+//! which includes `tt` related data and some task messages.\n+//! Although adding `Serialize` and `Deserialize` traits to `tt` directly seems\n+//! to be much easier, we deliberately duplicate `tt` structs with `#[serde(with = \"XXDef\")]`\n //! for separation of code responsibility.\n \n-use ra_tt::{\n+use std::path::PathBuf;\n+\n+use serde::{Deserialize, Serialize};\n+use tt::{\n     Delimiter, DelimiterKind, Ident, Leaf, Literal, Punct, SmolStr, Spacing, Subtree, TokenId,\n     TokenTree,\n };\n-use serde::{Deserialize, Serialize};\n-use std::path::PathBuf;\n \n #[derive(Clone, Eq, PartialEq, Debug, Serialize, Deserialize)]\n pub struct ListMacrosTask {", "previous_filename": "crates/ra_proc_macro/src/rpc.rs"}, {"sha": "a468b5560982665bd0a95d923b585b7310b977f5", "filename": "crates/proc_macro_srv/Cargo.toml", "status": "renamed", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2FCargo.toml?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,26 +1,29 @@\n [package]\n-edition = \"2018\"\n-name = \"ra_proc_macro_srv\"\n-version = \"0.1.0\"\n-authors = [\"rust-analyzer developers\"]\n-publish = false\n+name = \"proc_macro_srv\"\n+version = \"0.0.0\"\n license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n \n [lib]\n doctest = false\n \n [dependencies]\n-ra_tt = { path = \"../ra_tt\" }\n-ra_mbe = { path = \"../ra_mbe\" }\n-ra_proc_macro = { path = \"../ra_proc_macro\" }\n goblin = \"0.2.1\"\n libloading = \"0.6.0\"\n memmap = \"0.7\"\n+\n+tt = { path = \"../tt\" }\n+mbe = { path = \"../mbe\" }\n+proc_macro_api = { path = \"../proc_macro_api\" }\n test_utils = { path = \"../test_utils\" }\n \n [dev-dependencies]\n cargo_metadata = \"0.11.1\"\n difference = \"2.0.0\"\n-# used as proc macro test target\n+\n+# used as proc macro test targets\n serde_derive = \"1.0.106\"\n-ra_toolchain = { path = \"../ra_toolchain\" }\n+proc_macro_test = { path = \"../proc_macro_test\" }\n+\n+toolchain = { path = \"../toolchain\" }", "previous_filename": "crates/ra_proc_macro_srv/Cargo.toml"}, {"sha": "d428b956753157b327a8e9f08578a6c8abea59fb", "filename": "crates/proc_macro_srv/src/cli.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fcli.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -1,7 +1,7 @@\n //! Driver for proc macro server\n \n use crate::ProcMacroSrv;\n-use ra_proc_macro::msg::{self, Message};\n+use proc_macro_api::msg::{self, Message};\n use std::io;\n \n pub fn run() -> io::Result<()> {", "previous_filename": "crates/ra_proc_macro_srv/src/cli.rs"}, {"sha": "f8f705da8c83a409acf2e22a72fb7632203be786", "filename": "crates/proc_macro_srv/src/dylib.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fdylib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -7,7 +7,7 @@ use std::path::{Path, PathBuf};\n use goblin::{mach::Mach, Object};\n use libloading::Library;\n use memmap::Mmap;\n-use ra_proc_macro::ProcMacroKind;\n+use proc_macro_api::ProcMacroKind;\n use std::io;\n \n const NEW_REGISTRAR_SYMBOL: &str = \"_rustc_proc_macro_decls_\";\n@@ -128,9 +128,9 @@ impl Expander {\n     pub fn expand(\n         &self,\n         macro_name: &str,\n-        macro_body: &ra_tt::Subtree,\n-        attributes: Option<&ra_tt::Subtree>,\n-    ) -> Result<ra_tt::Subtree, bridge::PanicMessage> {\n+        macro_body: &tt::Subtree,\n+        attributes: Option<&tt::Subtree>,\n+    ) -> Result<tt::Subtree, bridge::PanicMessage> {\n         let parsed_body = TokenStream::with_subtree(macro_body.clone());\n \n         let parsed_attributes = attributes", "previous_filename": "crates/ra_proc_macro_srv/src/dylib.rs"}, {"sha": "7e4e4ad505d8e7f8e5bc7d6f3a3721e7f1709957", "filename": "crates/proc_macro_srv/src/lib.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Flib.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "patch": "@@ -5,10 +5,10 @@\n //!\n //! But we adapt it to better fit RA needs:\n //!\n-//! * We use `ra_tt` for proc-macro `TokenStream` server, it is easier to manipulate and interact with\n+//! * We use `tt` for proc-macro `TokenStream` server, it is easier to manipulate and interact with\n //!   RA than `proc-macro2` token stream.\n //! * By **copying** the whole rustc `lib_proc_macro` code, we are able to build this with `stable`\n-//!   rustc rather than `unstable`. (Although in gerenal ABI compatibility is still an issue)\n+//!   rustc rather than `unstable`. (Although in general ABI compatibility is still an issue)\u2026\n \n #[allow(dead_code)]\n #[doc(hidden)]\n@@ -20,7 +20,7 @@ mod rustc_server;\n mod dylib;\n \n use proc_macro::bridge::client::TokenStream;\n-use ra_proc_macro::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n+use proc_macro_api::{ExpansionResult, ExpansionTask, ListMacrosResult, ListMacrosTask};\n use std::{\n     collections::{hash_map::Entry, HashMap},\n     fs,", "previous_filename": "crates/ra_proc_macro_srv/src/lib.rs"}, {"sha": "dae6ff1d16c38f95fd69b95683e0d5afa5166a32", "filename": "crates/proc_macro_srv/src/proc_macro/bridge/buffer.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fbuffer.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/buffer.rs"}, {"sha": "cb4b3bdb0d3eb8f99f2118cde2eb177fd3697e3c", "filename": "crates/proc_macro_srv/src/proc_macro/bridge/client.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclient.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/client.rs"}, {"sha": "273a977158862ba5632c236f21ca8fd4e5086314", "filename": "crates/proc_macro_srv/src/proc_macro/bridge/closure.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fclosure.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/closure.rs"}, {"sha": "a2f77b5aca7fa303b167db3956c974c53b0a7969", "filename": "crates/proc_macro_srv/src/proc_macro/bridge/handle.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fhandle.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/handle.rs"}, {"sha": "aeb05aad44810aed89ef19d1a64a31c3b2340d5b", "filename": "crates/proc_macro_srv/src/proc_macro/bridge/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fmod.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/mod.rs"}, {"sha": "3528d5c99661bde135a0a4a88f06fd221fc38b6e", "filename": "crates/proc_macro_srv/src/proc_macro/bridge/rpc.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Frpc.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/rpc.rs"}, {"sha": "6ef7ea43c856dd62480f89f94b991f73bd123f65", "filename": "crates/proc_macro_srv/src/proc_macro/bridge/scoped_cell.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fproc_macro_srv%2Fsrc%2Fproc_macro%2Fbridge%2Fscoped_cell.rs?ref=7bbca7a1b3f9293d2f5cc5745199bc5f8396f2f0", "previous_filename": "crates/ra_proc_macro_srv/src/proc_macro/bridge/scoped_cell.rs"}]}