{"sha": "6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYjFkZjkyNTExZTdlY2FmZTA1NTRiMDE0MTBmNGU2OGQ3YmM2NmY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-22T06:06:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-24T21:22:34Z"}, "message": "Remove std::io once and for all!", "tree": {"sha": "77e1bd3a3d541add698d44120bc8293c48fadc45", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77e1bd3a3d541add698d44120bc8293c48fadc45"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "html_url": "https://github.com/rust-lang/rust/commit/6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "html_url": "https://github.com/rust-lang/rust/commit/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5"}], "stats": {"total": 1977, "additions": 123, "deletions": 1854}, "files": [{"sha": "f577ed55f9750cef212332ffd9b94bdfbe2d3f02", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "patch": "@@ -97,6 +97,7 @@ pub mod reader {\n     use std::cast::transmute;\n     use std::int;\n     use std::option::{None, Option, Some};\n+    use std::rt::io::extensions::u64_from_be_bytes;\n \n     // ebml reading\n \n@@ -258,17 +259,17 @@ pub mod reader {\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n         assert_eq!(d.end, d.start + 2u);\n-        ::std::io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n+        u64_from_be_bytes(*d.data, d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n         assert_eq!(d.end, d.start + 4u);\n-        ::std::io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n+        u64_from_be_bytes(*d.data, d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n         assert_eq!(d.end, d.start + 8u);\n-        ::std::io::u64_from_be_bytes(*d.data, d.start, 8u)\n+        u64_from_be_bytes(*d.data, d.start, 8u)\n     }\n \n     pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n@@ -610,6 +611,7 @@ pub mod writer {\n     use std::rt::io;\n     use std::rt::io::{Writer, Seek};\n     use std::rt::io::mem::MemWriter;\n+    use std::rt::io::extensions::u64_to_be_bytes;\n \n     // ebml writing\n     pub struct Encoder {\n@@ -693,19 +695,19 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n-            do ::std::io::u64_to_be_bytes(v, 8u) |v| {\n+            do u64_to_be_bytes(v, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n-            do ::std::io::u64_to_be_bytes(v as u64, 4u) |v| {\n+            do u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n-            do ::std::io::u64_to_be_bytes(v as u64, 2u) |v| {\n+            do u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n@@ -715,19 +717,19 @@ pub mod writer {\n         }\n \n         pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n-            do ::std::io::u64_to_be_bytes(v as u64, 8u) |v| {\n+            do u64_to_be_bytes(v as u64, 8u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n-            do ::std::io::u64_to_be_bytes(v as u64, 4u) |v| {\n+            do u64_to_be_bytes(v as u64, 4u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }\n \n         pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n-            do ::std::io::u64_to_be_bytes(v as u64, 2u) |v| {\n+            do u64_to_be_bytes(v as u64, 2u) |v| {\n                 self.wr_tagged_bytes(tag_id, v);\n             }\n         }"}, {"sha": "0020f432114dd882c9197b2aed0f45d607994b86", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "patch": "@@ -14,8 +14,9 @@\n \n \n use std::{vec, str};\n-use std::io::Reader;\n use std::hashmap::HashMap;\n+use std::rt::io;\n+use std::rt::io::extensions::{ReaderByteConversions, ReaderUtil};\n use super::super::TermInfo;\n \n // These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n@@ -160,7 +161,8 @@ pub static stringnames: &'static[&'static str] = &'static[ \"cbt\", \"_\", \"cr\", \"cs\n     \"box1\"];\n \n /// Parse a compiled terminfo entry, using long capability names if `longnames` is true\n-pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n+pub fn parse(mut file: &mut io::Reader,\n+             longnames: bool) -> Result<~TermInfo, ~str> {\n     let bnames;\n     let snames;\n     let nnames;\n@@ -176,17 +178,17 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     }\n \n     // Check magic number\n-    let magic = file.read_le_u16();\n+    let magic = file.read_le_u16_();\n     if (magic != 0x011A) {\n         return Err(format!(\"invalid magic number: expected {:x} but found {:x}\",\n                            0x011A, magic as uint));\n     }\n \n-    let names_bytes          = file.read_le_i16() as int;\n-    let bools_bytes          = file.read_le_i16() as int;\n-    let numbers_count        = file.read_le_i16() as int;\n-    let string_offsets_count = file.read_le_i16() as int;\n-    let string_table_bytes   = file.read_le_i16() as int;\n+    let names_bytes          = file.read_le_i16_() as int;\n+    let bools_bytes          = file.read_le_i16_() as int;\n+    let numbers_count        = file.read_le_i16_() as int;\n+    let string_offsets_count = file.read_le_i16_() as int;\n+    let string_table_bytes   = file.read_le_i16_() as int;\n \n     assert!(names_bytes          > 0);\n \n@@ -224,7 +226,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     let mut bools_map = HashMap::new();\n     if bools_bytes != 0 {\n         for i in range(0, bools_bytes) {\n-            let b = file.read_byte();\n+            let b = file.read_byte().unwrap();\n             if b < 0 {\n                 error!(\"EOF reading bools after {} entries\", i);\n                 return Err(~\"error: expected more bools but hit EOF\");\n@@ -245,7 +247,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     let mut numbers_map = HashMap::new();\n     if numbers_count != 0 {\n         for i in range(0, numbers_count) {\n-            let n = file.read_le_u16();\n+            let n = file.read_le_u16_();\n             if n != 0xFFFF {\n                 debug!(\"{}\\\\#{}\", nnames[i], n);\n                 numbers_map.insert(nnames[i].to_owned(), n);\n@@ -260,7 +262,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n     if string_offsets_count != 0 {\n         let mut string_offsets = vec::with_capacity(10);\n         for _ in range(0, string_offsets_count) {\n-            string_offsets.push(file.read_le_u16());\n+            string_offsets.push(file.read_le_u16_());\n         }\n \n         debug!(\"offsets: {:?}\", string_offsets);"}, {"sha": "8dff53f14a159b54d5336878779517f8ad097743", "filename": "src/libextra/terminfo/searcher.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibextra%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fsearcher.rs?ref=6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "patch": "@@ -13,7 +13,8 @@\n \n use std::{os, str};\n use std::os::getenv;\n-use std::io::{file_reader, Reader};\n+use std::rt::io;\n+use std::rt::io::file::FileInfo;\n \n /// Return path to database entry for `term`\n pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n@@ -73,9 +74,9 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n }\n \n /// Return open file for `term`\n-pub fn open(term: &str) -> Result<@Reader, ~str> {\n+pub fn open(term: &str) -> Result<@mut io::Reader, ~str> {\n     match get_dbpath_for_term(term) {\n-        Some(x) => file_reader(x),\n+        Some(x) => Ok(@mut x.open_reader(io::Open).unwrap() as @mut io::Reader),\n         None => Err(format!(\"could not find terminfo entry for {}\", term))\n     }\n }"}, {"sha": "aca41f5f4cbb9364ebc13c4def1041f57b11b875", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "patch": "@@ -28,6 +28,7 @@ use middle::astencode::vtable_decoder_helpers;\n \n use std::u64;\n use std::rt::io;\n+use std::rt::io::extensions::u64_from_be_bytes;\n use std::option;\n use std::str;\n use std::vec;\n@@ -55,14 +56,14 @@ fn lookup_hash(d: ebml::Doc, eq_fn: &fn(x:&[u8]) -> bool, hash: u64) ->\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n-    let pos = ::std::io::u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n+    let pos = u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n     let tagged_doc = reader::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     do reader::tagged_docs(tagged_doc.doc, belt) |elt| {\n-        let pos = ::std::io::u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n+        let pos = u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n             ret = Some(reader::doc_at(d.data, pos).doc);\n             false\n@@ -77,7 +78,7 @@ pub type GetCrateDataCb<'self> = &'self fn(ast::CrateNum) -> Cmd;\n \n pub fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n-        return ::std::io::u64_from_be_bytes(\n+        return u64_from_be_bytes(\n             bytes.slice(0u, 4u), 0u, 4u) as int\n             == item_id;\n     }\n@@ -1253,7 +1254,7 @@ fn family_names_type(fam: Family) -> bool {\n \n fn read_path(d: ebml::Doc) -> (~str, uint) {\n     do reader::with_doc_data(d) |desc| {\n-        let pos = ::std::io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n+        let pos = u64_from_be_bytes(desc, 0u, 4u) as uint;\n         let pathbytes = desc.slice(4u, desc.len());\n         let path = str::from_utf8(pathbytes);\n "}, {"sha": "2ffe654d3bdbc7f9a79a34cd1d3adf7da0a7443c", "filename": "src/libstd/io.rs", "status": "removed", "additions": 0, "deletions": 1817, "changes": 1817, "blob_url": "https://github.com/rust-lang/rust/blob/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=c4907cfd14f9afa1fc26e2fdddf128f834fe5ce5", "patch": "@@ -1,1817 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-The `io` module contains basic input and output routines.\n-\n-A quick summary:\n-\n-## `Reader` and `Writer` traits\n-\n-These traits define the minimal set of methods that anything that can do\n-input and output should implement.\n-\n-## `ReaderUtil` and `WriterUtil` traits\n-\n-Richer methods that allow you to do more. `Reader` only lets you read a certain\n-number of bytes into a buffer, while `ReaderUtil` allows you to read a whole\n-line, for example.\n-\n-Generally, these richer methods are probably the ones you want to actually\n-use in day-to-day Rust.\n-\n-Furthermore, because there is an implementation of `ReaderUtil` for\n-`<T: Reader>`, when your input or output code implements `Reader`, you get\n-all of these methods for free.\n-\n-## `print` and `println`\n-\n-These very useful functions are defined here. You generally don't need to\n-import them, though, as the prelude already does.\n-\n-## `stdin`, `stdout`, and `stderr`\n-\n-These functions return references to the classic three file descriptors. They\n-implement `Reader` and `Writer`, where appropriate.\n-\n-*/\n-\n-#[allow(missing_doc)];\n-\n-use cast;\n-use cast::transmute;\n-use clone::Clone;\n-use c_str::ToCStr;\n-use container::Container;\n-use int;\n-use iter::Iterator;\n-use libc::consts::os::posix88::*;\n-use libc::{c_int, c_void, size_t};\n-use libc;\n-use num;\n-use ops::Drop;\n-use option::{Some, None};\n-use os;\n-use path::{Path,GenericPath};\n-use ptr;\n-use result::{Result, Ok, Err};\n-use str::{StrSlice, OwnedStr};\n-use str;\n-use uint;\n-use vec::{MutableVector, ImmutableVector, OwnedVector, OwnedCopyableVector, CopyableVector};\n-use vec;\n-\n-#[cfg(stage0)]\n-pub use rt::io::stdio::{print, println};\n-\n-#[allow(non_camel_case_types)] // not sure what to do about this\n-type fd_t = c_int;\n-\n-mod rustrt {\n-    use libc;\n-\n-    #[link_name = \"rustrt\"]\n-    extern {\n-        pub fn rust_get_stdin() -> *libc::FILE;\n-        pub fn rust_get_stdout() -> *libc::FILE;\n-        pub fn rust_get_stderr() -> *libc::FILE;\n-    }\n-}\n-\n-// Reading\n-\n-// FIXME (#2004): This is all buffered. We might need an unbuffered variant\n-// as well\n-/**\n-* The SeekStyle enum describes the relationship between the position\n-* we'd like to seek to from our current position. It's used as an argument\n-* to the `seek` method defined on the `Reader` trait.\n-*\n-* There are three seek styles:\n-*\n-* 1. `SeekSet` means that the new position should become our position.\n-* 2. `SeekCur` means that we should seek from the current position.\n-* 3. `SeekEnd` means that we should seek from the end.\n-*\n-* # Examples\n-*\n-* None right now.\n-*/\n-pub enum SeekStyle { SeekSet, SeekEnd, SeekCur, }\n-\n-\n-/**\n-* The core Reader trait. All readers must implement this trait.\n-*\n-* # Examples\n-*\n-* None right now.\n-*/\n-pub trait Reader {\n-    // FIXME (#2004): Seekable really should be orthogonal.\n-\n-    // FIXME (#2982): This should probably return an error.\n-    /**\n-    * Reads bytes and puts them into `bytes`, advancing the cursor. Returns the\n-    * number of bytes read.\n-    *\n-    * The number of bytes to be read is `len` or the end of the file,\n-    * whichever comes first.\n-    *\n-    * The buffer must be at least `len` bytes long.\n-    *\n-    * `read` is conceptually similar to C's `fread` function.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n-\n-    /**\n-    * Reads a single byte, advancing the cursor.\n-    *\n-    * In the case of an EOF or an error, returns a negative value.\n-    *\n-    * `read_byte` is conceptually similar to C's `getc` function.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_byte(&self) -> int;\n-\n-    /**\n-    * Returns a boolean value: are we currently at EOF?\n-    *\n-    * Note that stream position may be already at the end-of-file point,\n-    * but `eof` returns false until an attempt to read at that position.\n-    *\n-    * `eof` is conceptually similar to C's `feof` function.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn eof(&self) -> bool;\n-\n-    /**\n-    * Seek to a given `position` in the stream.\n-    *\n-    * Takes an optional SeekStyle, which affects how we seek from the\n-    * position. See `SeekStyle` docs for more details.\n-    *\n-    * `seek` is conceptually similar to C's `fseek` function.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn seek(&self, position: int, style: SeekStyle);\n-\n-    /**\n-    * Returns the current position within the stream.\n-    *\n-    * `tell` is conceptually similar to C's `ftell` function.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn tell(&self) -> uint;\n-}\n-\n-impl Reader for @Reader {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        self.read(bytes, len)\n-    }\n-    fn read_byte(&self) -> int {\n-        self.read_byte()\n-    }\n-    fn eof(&self) -> bool {\n-        self.eof()\n-    }\n-    fn seek(&self, position: int, style: SeekStyle) {\n-        self.seek(position, style)\n-    }\n-    fn tell(&self) -> uint {\n-        self.tell()\n-    }\n-}\n-\n-/**\n-* The `ReaderUtil` trait is a home for many of the utility functions\n-* a particular Reader should implement.\n-*\n-* The default `Reader` trait is focused entirely on bytes. `ReaderUtil` is based\n-* on higher-level concepts like 'chars' and 'lines.'\n-*\n-* # Examples:\n-*\n-* None right now.\n-*/\n-pub trait ReaderUtil {\n-\n-    /**\n-    * Reads `len` number of bytes, and gives you a new vector back.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_bytes(&self, len: uint) -> ~[u8];\n-\n-    /**\n-    * Reads up until a specific byte is seen or EOF.\n-    *\n-    * The `include` parameter specifies if the character should be included\n-    * in the returned string.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_until(&self, c: u8, include: bool) -> ~str;\n-\n-    /**\n-    * Reads up until the first '\\n' or EOF.\n-    *\n-    * The '\\n' is not included in the result.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_line(&self) -> ~str;\n-\n-    /**\n-    * Reads `n` chars.\n-    *\n-    * Assumes that those chars are UTF-8 encoded.\n-    *\n-    * The '\\n' is not included in the result.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_chars(&self, n: uint) -> ~[char];\n-\n-    /**\n-    * Reads a single UTF-8 encoded char.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_char(&self) -> char;\n-\n-    /**\n-    * Reads up until the first null byte or EOF.\n-    *\n-    * The null byte is not returned.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_c_str(&self) -> ~str;\n-\n-    /**\n-    * Reads all remaining data in the stream.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_whole_stream(&self) -> ~[u8];\n-\n-    /**\n-    * Iterate over every byte until EOF or the iterator breaks.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn each_byte(&self, it: &fn(int) -> bool) -> bool;\n-\n-    /**\n-    * Iterate over every char until EOF or the iterator breaks.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn each_char(&self, it: &fn(char) -> bool) -> bool;\n-\n-    /**\n-    * Iterate over every line until EOF or the iterator breaks.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn each_line(&self, it: &fn(&str) -> bool) -> bool;\n-\n-    /**\n-    * Reads all of the lines in the stream.\n-    *\n-    * Returns a vector of those lines.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_lines(&self) -> ~[~str];\n-\n-    /**\n-    * Reads `n` little-endian unsigned integer bytes.\n-    *\n-    * `n` must be between 1 and 8, inclusive.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_uint_n(&self, nbytes: uint) -> u64;\n-\n-    /**\n-    * Reads `n` little-endian signed integer bytes.\n-    *\n-    * `n` must be between 1 and 8, inclusive.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_int_n(&self, nbytes: uint) -> i64;\n-\n-    /**\n-    * Reads `n` big-endian unsigned integer bytes.\n-    *\n-    * `n` must be between 1 and 8, inclusive.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_uint_n(&self, nbytes: uint) -> u64;\n-\n-    /**\n-    * Reads `n` big-endian signed integer bytes.\n-    *\n-    * `n` must be between 1 and 8, inclusive.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_int_n(&self, nbytes: uint) -> i64;\n-\n-    /**\n-    * Reads a little-endian unsigned integer.\n-    *\n-    * The number of bytes returned is system-dependant.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_uint(&self) -> uint;\n-\n-    /**\n-    * Reads a little-endian integer.\n-    *\n-    * The number of bytes returned is system-dependant.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_int(&self) -> int;\n-\n-    /**\n-    * Reads a big-endian unsigned integer.\n-    *\n-    * The number of bytes returned is system-dependant.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_uint(&self) -> uint;\n-\n-    /**\n-    * Reads a big-endian integer.\n-    *\n-    * The number of bytes returned is system-dependant.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_int(&self) -> int;\n-\n-    /**\n-    * Reads a big-endian `u64`.\n-    *\n-    * `u64`s are 8 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_u64(&self) -> u64;\n-\n-    /**\n-    * Reads a big-endian `u32`.\n-    *\n-    * `u32`s are 4 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_u32(&self) -> u32;\n-\n-    /**\n-    * Reads a big-endian `u16`.\n-    *\n-    * `u16`s are 2 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_u16(&self) -> u16;\n-\n-    /**\n-    * Reads a big-endian `i64`.\n-    *\n-    * `i64`s are 8 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_i64(&self) -> i64;\n-\n-    /**\n-    * Reads a big-endian `i32`.\n-    *\n-    * `i32`s are 4 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_i32(&self) -> i32;\n-\n-    /**\n-    * Reads a big-endian `i16`.\n-    *\n-    * `i16`s are 2 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_i16(&self) -> i16;\n-\n-    /**\n-    * Reads a big-endian `f64`.\n-    *\n-    * `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_f64(&self) -> f64;\n-\n-    /**\n-    * Reads a big-endian `f32`.\n-    *\n-    * `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_be_f32(&self) -> f32;\n-\n-    /**\n-    * Reads a little-endian `u64`.\n-    *\n-    * `u64`s are 8 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_u64(&self) -> u64;\n-\n-    /**\n-    * Reads a little-endian `u32`.\n-    *\n-    * `u32`s are 4 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_u32(&self) -> u32;\n-\n-    /**\n-    * Reads a little-endian `u16`.\n-    *\n-    * `u16`s are 2 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_u16(&self) -> u16;\n-\n-    /**\n-    * Reads a little-endian `i64`.\n-    *\n-    * `i64`s are 8 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_i64(&self) -> i64;\n-\n-    /**\n-    * Reads a little-endian `i32`.\n-    *\n-    * `i32`s are 4 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_i32(&self) -> i32;\n-\n-    /**\n-    * Reads a little-endian `i16`.\n-    *\n-    * `i16`s are 2 bytes long.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_i16(&self) -> i16;\n-\n-    /**\n-    * Reads a little-endian `f64`.\n-    *\n-    * `f64`s are 8 byte, IEEE754 double-precision floating point numbers.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_f64(&self) -> f64;\n-\n-    /**\n-    * Reads a little-endian `f32`.\n-    *\n-    * `f32`s are 4 byte, IEEE754 single-precision floating point numbers.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_le_f32(&self) -> f32;\n-\n-    /**\n-    * Read a u8.\n-    *\n-    * `u8`s are 1 byte.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_u8(&self) -> u8;\n-\n-    /**\n-    * Read an i8.\n-    *\n-    * `i8`s are 1 byte.\n-    *\n-    * # Examples\n-    *\n-    * None right now.\n-    */\n-    fn read_i8(&self) -> i8;\n-}\n-\n-impl<T:Reader> ReaderUtil for T {\n-\n-    fn read_bytes(&self, len: uint) -> ~[u8] {\n-        let mut bytes = vec::with_capacity(len);\n-        unsafe { vec::raw::set_len(&mut bytes, len); }\n-\n-        let count = self.read(bytes, len);\n-\n-        unsafe { vec::raw::set_len(&mut bytes, count); }\n-        bytes\n-    }\n-\n-    fn read_until(&self, c: u8, include: bool) -> ~str {\n-        let mut bytes = ~[];\n-        loop {\n-            let ch = self.read_byte();\n-            if ch == -1 || ch == c as int {\n-                if include && ch == c as int {\n-                    bytes.push(ch as u8);\n-                }\n-                break;\n-            }\n-            bytes.push(ch as u8);\n-        }\n-        str::from_utf8(bytes)\n-    }\n-\n-    fn read_line(&self) -> ~str {\n-        self.read_until('\\n' as u8, false)\n-    }\n-\n-    fn read_chars(&self, n: uint) -> ~[char] {\n-        // returns the (consumed offset, n_req), appends characters to &chars\n-        fn chars_from_utf8<T:Reader>(bytes: &~[u8], chars: &mut ~[char])\n-            -> (uint, uint) {\n-            let mut i = 0;\n-            let bytes_len = bytes.len();\n-            while i < bytes_len {\n-                let b0 = bytes[i];\n-                let w = str::utf8_char_width(b0);\n-                let end = i + w;\n-                i += 1;\n-                assert!((w > 0));\n-                if w == 1 {\n-                    unsafe {\n-                        chars.push(transmute(b0 as u32));\n-                    }\n-                    continue;\n-                }\n-                // can't satisfy this char with the existing data\n-                if end > bytes_len {\n-                    return (i - 1, end - bytes_len);\n-                }\n-                let mut val = 0;\n-                while i < end {\n-                    let next = bytes[i] as int;\n-                    i += 1;\n-                    assert!((next > -1));\n-                    assert_eq!(next & 192, 128);\n-                    val <<= 6;\n-                    val += (next & 63) as uint;\n-                }\n-                // See str::StrSlice::char_at\n-                val += ((b0 << ((w + 1) as u8)) as uint)\n-                    << (w - 1) * 6 - w - 1u;\n-                unsafe {\n-                    chars.push(transmute(val as u32));\n-                }\n-            }\n-            return (i, 0);\n-        }\n-        let mut bytes = ~[];\n-        let mut chars = ~[];\n-        // might need more bytes, but reading n will never over-read\n-        let mut nbread = n;\n-        while nbread > 0 {\n-            let data = self.read_bytes(nbread);\n-            if data.is_empty() {\n-                // eof - FIXME (#2004): should we do something if\n-                // we're split in a unicode char?\n-                break;\n-            }\n-            bytes.push_all(data);\n-            let (offset, nbreq) = chars_from_utf8::<T>(&bytes, &mut chars);\n-            let ncreq = n - chars.len();\n-            // again we either know we need a certain number of bytes\n-            // to complete a character, or we make sure we don't\n-            // over-read by reading 1-byte per char needed\n-            nbread = if ncreq > nbreq { ncreq } else { nbreq };\n-            if nbread > 0 {\n-                bytes = bytes.slice(offset, bytes.len()).to_owned();\n-            }\n-        }\n-        chars\n-    }\n-\n-    fn read_char(&self) -> char {\n-        let c = self.read_chars(1);\n-        if c.len() == 0 {\n-            return unsafe { transmute(-1u32) }; // FIXME: #8971: unsound\n-        }\n-        assert_eq!(c.len(), 1);\n-        return c[0];\n-    }\n-\n-    fn read_c_str(&self) -> ~str {\n-        self.read_until(0u8, false)\n-    }\n-\n-    fn read_whole_stream(&self) -> ~[u8] {\n-        let mut bytes: ~[u8] = ~[];\n-        while !self.eof() { bytes.push_all(self.read_bytes(2048u)); }\n-        bytes\n-    }\n-\n-    fn each_byte(&self, it: &fn(int) -> bool) -> bool {\n-        loop {\n-            match self.read_byte() {\n-                -1 => break,\n-                ch => if !it(ch) { return false; }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    fn each_char(&self, it: &fn(char) -> bool) -> bool {\n-        // FIXME: #8971: unsound\n-        let eof: char = unsafe { transmute(-1u32) };\n-        loop {\n-            match self.read_char() {\n-                c if c == eof => break,\n-                ch => if !it(ch) { return false; }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    fn each_line(&self, it: &fn(s: &str) -> bool) -> bool {\n-        while !self.eof() {\n-            // include the \\n, so that we can distinguish an entirely empty\n-            // line read after \"...\\n\", and the trailing empty line in\n-            // \"...\\n\\n\".\n-            let mut line = self.read_until('\\n' as u8, true);\n-\n-            // blank line at the end of the reader is ignored\n-            if self.eof() && line.is_empty() { break; }\n-\n-            // trim the \\n, so that each_line is consistent with read_line\n-            let n = line.len();\n-            if line[n-1] == '\\n' as u8 {\n-                unsafe { str::raw::set_len(&mut line, n-1); }\n-            }\n-\n-            if !it(line) { return false; }\n-        }\n-        return true;\n-    }\n-\n-    fn read_lines(&self) -> ~[~str] {\n-        do vec::build(None) |push| {\n-            do self.each_line |line| {\n-                push(line.to_owned());\n-                true\n-            };\n-        }\n-    }\n-\n-    // FIXME int reading methods need to deal with eof - issue #2004\n-\n-    fn read_le_uint_n(&self, nbytes: uint) -> u64 {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0u64;\n-        let mut pos = 0;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            val += (self.read_u8() as u64) << pos;\n-            pos += 8;\n-            i -= 1;\n-        }\n-        val\n-    }\n-\n-    fn read_le_int_n(&self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_le_uint_n(nbytes), nbytes)\n-    }\n-\n-    fn read_be_uint_n(&self, nbytes: uint) -> u64 {\n-        assert!(nbytes > 0 && nbytes <= 8);\n-\n-        let mut val = 0u64;\n-        let mut i = nbytes;\n-        while i > 0 {\n-            i -= 1;\n-            val += (self.read_u8() as u64) << i * 8;\n-        }\n-        val\n-    }\n-\n-    fn read_be_int_n(&self, nbytes: uint) -> i64 {\n-        extend_sign(self.read_be_uint_n(nbytes), nbytes)\n-    }\n-\n-    fn read_le_uint(&self) -> uint {\n-        self.read_le_uint_n(uint::bytes) as uint\n-    }\n-\n-    fn read_le_int(&self) -> int {\n-        self.read_le_int_n(int::bytes) as int\n-    }\n-\n-    fn read_be_uint(&self) -> uint {\n-        self.read_be_uint_n(uint::bytes) as uint\n-    }\n-\n-    fn read_be_int(&self) -> int {\n-        self.read_be_int_n(int::bytes) as int\n-    }\n-\n-    fn read_be_u64(&self) -> u64 {\n-        self.read_be_uint_n(8) as u64\n-    }\n-\n-    fn read_be_u32(&self) -> u32 {\n-        self.read_be_uint_n(4) as u32\n-    }\n-\n-    fn read_be_u16(&self) -> u16 {\n-        self.read_be_uint_n(2) as u16\n-    }\n-\n-    fn read_be_i64(&self) -> i64 {\n-        self.read_be_int_n(8) as i64\n-    }\n-\n-    fn read_be_i32(&self) -> i32 {\n-        self.read_be_int_n(4) as i32\n-    }\n-\n-    fn read_be_i16(&self) -> i16 {\n-        self.read_be_int_n(2) as i16\n-    }\n-\n-    fn read_be_f64(&self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_be_u64())\n-        }\n-    }\n-\n-    fn read_be_f32(&self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_be_u32())\n-        }\n-    }\n-\n-    fn read_le_u64(&self) -> u64 {\n-        self.read_le_uint_n(8) as u64\n-    }\n-\n-    fn read_le_u32(&self) -> u32 {\n-        self.read_le_uint_n(4) as u32\n-    }\n-\n-    fn read_le_u16(&self) -> u16 {\n-        self.read_le_uint_n(2) as u16\n-    }\n-\n-    fn read_le_i64(&self) -> i64 {\n-        self.read_le_int_n(8) as i64\n-    }\n-\n-    fn read_le_i32(&self) -> i32 {\n-        self.read_le_int_n(4) as i32\n-    }\n-\n-    fn read_le_i16(&self) -> i16 {\n-        self.read_le_int_n(2) as i16\n-    }\n-\n-    fn read_le_f64(&self) -> f64 {\n-        unsafe {\n-            cast::transmute::<u64, f64>(self.read_le_u64())\n-        }\n-    }\n-\n-    fn read_le_f32(&self) -> f32 {\n-        unsafe {\n-            cast::transmute::<u32, f32>(self.read_le_u32())\n-        }\n-    }\n-\n-    fn read_u8(&self) -> u8 {\n-        self.read_byte() as u8\n-    }\n-\n-    fn read_i8(&self) -> i8 {\n-        self.read_byte() as i8\n-    }\n-}\n-\n-fn extend_sign(val: u64, nbytes: uint) -> i64 {\n-    let shift = (8 - nbytes) * 8;\n-    (val << shift) as i64 >> shift\n-}\n-\n-// Reader implementations\n-\n-fn convert_whence(whence: SeekStyle) -> i32 {\n-    return match whence {\n-      SeekSet => 0i32,\n-      SeekCur => 1i32,\n-      SeekEnd => 2i32\n-    };\n-}\n-\n-impl Reader for *libc::FILE {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            do bytes.as_mut_buf |buf_p, buf_len| {\n-                assert!(buf_len >= len);\n-\n-                let count = libc::fread(buf_p as *mut c_void, 1u as size_t,\n-                                        len as size_t, *self) as uint;\n-                if count < len {\n-                  match libc::ferror(*self) {\n-                    0 => (),\n-                    _ => {\n-                      error!(\"error reading buffer: {}\", os::last_os_error());\n-                      fail!();\n-                    }\n-                  }\n-                }\n-\n-                count\n-            }\n-        }\n-    }\n-    fn read_byte(&self) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            libc::fgetc(*self) as int\n-        }\n-    }\n-    fn eof(&self) -> bool {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            return libc::feof(*self) != 0 as c_int;\n-        }\n-    }\n-    fn seek(&self, offset: int, whence: SeekStyle) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            assert!(libc::fseek(*self,\n-                                     offset as libc::c_long,\n-                                     convert_whence(whence)) == 0 as c_int);\n-        }\n-    }\n-    fn tell(&self) -> uint {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            return libc::ftell(*self) as uint;\n-        }\n-    }\n-}\n-\n-struct Wrapper<T, C> {\n-    base: T,\n-    cleanup: C,\n-}\n-\n-// A forwarding impl of reader that also holds on to a resource for the\n-// duration of its lifetime.\n-// FIXME there really should be a better way to do this // #2004\n-impl<R:Reader,C> Reader for Wrapper<R, C> {\n-    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n-        self.base.read(bytes, len)\n-    }\n-    fn read_byte(&self) -> int { self.base.read_byte() }\n-    fn eof(&self) -> bool { self.base.eof() }\n-    fn seek(&self, off: int, whence: SeekStyle) {\n-        self.base.seek(off, whence)\n-    }\n-    fn tell(&self) -> uint { self.base.tell() }\n-}\n-\n-pub struct FILERes {\n-    priv f: *libc::FILE,\n-}\n-\n-impl FILERes {\n-    fn new(f: *libc::FILE) -> FILERes {\n-        FILERes { f: f }\n-    }\n-}\n-\n-impl Drop for FILERes {\n-    fn drop(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            libc::fclose(self.f);\n-        }\n-    }\n-}\n-\n-pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let f = do path.with_c_str |pathbuf| {\n-        do \"rb\".with_c_str |modebuf| {\n-            unsafe { libc::fopen(pathbuf, modebuf as *libc::c_char) }\n-        }\n-    };\n-\n-    if f as uint == 0u {\n-        do path.display().with_str |p| {\n-            Err(~\"error opening \" + p)\n-        }\n-    } else {\n-        Ok(@Wrapper { base: f, cleanup: FILERes::new(f) } as @Reader)\n-    }\n-}\n-\n-// Writing\n-pub enum FileFlag { Append, Create, Truncate, NoFlag, }\n-\n-// What type of writer are we?\n-#[deriving(Eq)]\n-pub enum WriterType { Screen, File }\n-\n-// FIXME (#2004): Seekable really should be orthogonal.\n-// FIXME (#2004): eventually u64\n-/// The raw underlying writer trait. All writers must implement this.\n-pub trait Writer {\n-\n-    /// Write all of the given bytes.\n-    fn write(&self, v: &[u8]);\n-\n-    /// Move the current position within the stream. The second parameter\n-    /// determines the position that the first parameter is relative to.\n-    fn seek(&self, int, SeekStyle);\n-\n-    /// Return the current position within the stream.\n-    fn tell(&self) -> uint;\n-\n-    /// Flush the output buffer for this stream (if there is one).\n-    fn flush(&self) -> int;\n-\n-    /// Determine if this Writer is writing to a file or not.\n-    fn get_type(&self) -> WriterType;\n-}\n-\n-impl Writer for @Writer {\n-    fn write(&self, v: &[u8]) { self.write(v) }\n-    fn seek(&self, a: int, b: SeekStyle) { self.seek(a, b) }\n-    fn tell(&self) -> uint { self.tell() }\n-    fn flush(&self) -> int { self.flush() }\n-    fn get_type(&self) -> WriterType { self.get_type() }\n-}\n-\n-impl<W:Writer,C> Writer for Wrapper<W, C> {\n-    fn write(&self, bs: &[u8]) { self.base.write(bs); }\n-    fn seek(&self, off: int, style: SeekStyle) { self.base.seek(off, style); }\n-    fn tell(&self) -> uint { self.base.tell() }\n-    fn flush(&self) -> int { self.base.flush() }\n-    fn get_type(&self) -> WriterType { File }\n-}\n-\n-impl Writer for *libc::FILE {\n-    fn write(&self, v: &[u8]) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            do v.as_imm_buf |vbuf, len| {\n-                let nout = libc::fwrite(vbuf as *c_void,\n-                                        1,\n-                                        len as size_t,\n-                                        *self);\n-                if nout != len as size_t {\n-                    error!(\"error writing buffer: {}\", os::last_os_error());\n-                    fail!();\n-                }\n-            }\n-        }\n-    }\n-    fn seek(&self, offset: int, whence: SeekStyle) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            assert!(libc::fseek(*self,\n-                                     offset as libc::c_long,\n-                                     convert_whence(whence)) == 0 as c_int);\n-        }\n-    }\n-    fn tell(&self) -> uint {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            libc::ftell(*self) as uint\n-        }\n-    }\n-    fn flush(&self) -> int {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            libc::fflush(*self) as int\n-        }\n-    }\n-    fn get_type(&self) -> WriterType {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            let fd = libc::fileno(*self);\n-            if libc::isatty(fd) == 0 { File   }\n-            else                     { Screen }\n-        }\n-    }\n-}\n-\n-impl Writer for fd_t {\n-    fn write(&self, v: &[u8]) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        #[cfg(windows)]\n-        type IoSize = libc::c_uint;\n-        #[cfg(windows)]\n-        type IoRet = c_int;\n-\n-        #[cfg(unix)]\n-        type IoSize = size_t;\n-        #[cfg(unix)]\n-        type IoRet = libc::ssize_t;\n-\n-        unsafe {\n-            let mut count = 0u;\n-            do v.as_imm_buf |vbuf, len| {\n-                while count < len {\n-                    let vb = ptr::offset(vbuf, count as int) as *c_void;\n-                    let nout = libc::write(*self, vb, len as IoSize);\n-                    if nout < 0 as IoRet {\n-                        error!(\"error writing buffer: {}\", os::last_os_error());\n-                        fail!();\n-                    }\n-                    count += nout as uint;\n-                }\n-            }\n-        }\n-    }\n-    fn seek(&self, _offset: int, _whence: SeekStyle) {\n-        error!(\"need 64-bit foreign calls for seek, sorry\");\n-        fail!();\n-    }\n-    fn tell(&self) -> uint {\n-        error!(\"need 64-bit foreign calls for tell, sorry\");\n-        fail!();\n-    }\n-    fn flush(&self) -> int { 0 }\n-    fn get_type(&self) -> WriterType {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            if libc::isatty(*self) == 0 { File } else { Screen }\n-        }\n-    }\n-}\n-\n-pub struct FdRes {\n-    priv fd: fd_t,\n-}\n-\n-impl FdRes {\n-    fn new(fd: fd_t) -> FdRes {\n-        FdRes { fd: fd }\n-    }\n-}\n-\n-impl Drop for FdRes {\n-    fn drop(&mut self) {\n-        #[fixed_stack_segment]; #[inline(never)];\n-\n-        unsafe {\n-            libc::close(self.fd);\n-        }\n-    }\n-}\n-\n-pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n-                   -> Result<@Writer, ~str> {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    #[cfg(windows)]\n-    fn wb() -> c_int {\n-      (O_WRONLY | libc::consts::os::extra::O_BINARY) as c_int\n-    }\n-\n-    #[cfg(unix)]\n-    fn wb() -> c_int { O_WRONLY as c_int }\n-\n-    let mut fflags: c_int = wb();\n-    for f in flags.iter() {\n-        match *f {\n-          Append => fflags |= O_APPEND as c_int,\n-          Create => fflags |= O_CREAT as c_int,\n-          Truncate => fflags |= O_TRUNC as c_int,\n-          NoFlag => ()\n-        }\n-    }\n-    let fd = unsafe {\n-        do path.with_c_str |pathbuf| {\n-            libc::open(pathbuf, fflags, (S_IRUSR | S_IWUSR) as c_int)\n-        }\n-    };\n-    if fd < (0 as c_int) {\n-        Err(format!(\"error opening {}: {}\", path.display(), os::last_os_error()))\n-    } else {\n-        Ok(@Wrapper { base: fd, cleanup: FdRes::new(fd) } as @Writer)\n-    }\n-}\n-\n-pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n-                          f: &fn(v: &[u8]) -> T) -> T {\n-    assert!(size <= 8u);\n-    match size {\n-      1u => f(&[n as u8]),\n-      2u => f(&[n as u8,\n-              (n >> 8) as u8]),\n-      4u => f(&[n as u8,\n-              (n >> 8) as u8,\n-              (n >> 16) as u8,\n-              (n >> 24) as u8]),\n-      8u => f(&[n as u8,\n-              (n >> 8) as u8,\n-              (n >> 16) as u8,\n-              (n >> 24) as u8,\n-              (n >> 32) as u8,\n-              (n >> 40) as u8,\n-              (n >> 48) as u8,\n-              (n >> 56) as u8]),\n-      _ => {\n-\n-        let mut bytes: ~[u8] = ~[];\n-        let mut i = size;\n-        let mut n = n;\n-        while i > 0u {\n-            bytes.push((n & 255_u64) as u8);\n-            n >>= 8_u64;\n-            i -= 1u;\n-        }\n-        f(bytes)\n-      }\n-    }\n-}\n-\n-pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n-                           f: &fn(v: &[u8]) -> T) -> T {\n-    assert!(size <= 8u);\n-    match size {\n-      1u => f(&[n as u8]),\n-      2u => f(&[(n >> 8) as u8,\n-              n as u8]),\n-      4u => f(&[(n >> 24) as u8,\n-              (n >> 16) as u8,\n-              (n >> 8) as u8,\n-              n as u8]),\n-      8u => f(&[(n >> 56) as u8,\n-              (n >> 48) as u8,\n-              (n >> 40) as u8,\n-              (n >> 32) as u8,\n-              (n >> 24) as u8,\n-              (n >> 16) as u8,\n-              (n >> 8) as u8,\n-              n as u8]),\n-      _ => {\n-        let mut bytes: ~[u8] = ~[];\n-        let mut i = size;\n-        while i > 0u {\n-            let shift = ((i - 1u) * 8u) as u64;\n-            bytes.push((n >> shift) as u8);\n-            i -= 1u;\n-        }\n-        f(bytes)\n-      }\n-    }\n-}\n-\n-pub fn u64_from_be_bytes(data: &[u8],\n-                         start: uint,\n-                         size: uint)\n-                      -> u64 {\n-    let mut sz = size;\n-    assert!((sz <= 8u));\n-    let mut val = 0_u64;\n-    let mut pos = start;\n-    while sz > 0u {\n-        sz -= 1u;\n-        val += (data[pos] as u64) << ((sz * 8u) as u64);\n-        pos += 1u;\n-    }\n-    return val;\n-}\n-\n-// FIXME: #3048 combine trait+impl (or just move these to\n-// default methods on writer)\n-/// Generic utility functions defined on writers.\n-pub trait WriterUtil {\n-\n-    /// Write a single utf-8 encoded char.\n-    fn write_char(&self, ch: char);\n-\n-    /// Write every char in the given str, encoded as utf-8.\n-    fn write_str(&self, s: &str);\n-\n-    /// Write the given str, as utf-8, followed by '\\n'.\n-    fn write_line(&self, s: &str);\n-\n-    /// Write the result of passing n through `int::to_str_bytes`.\n-    fn write_int(&self, n: int);\n-\n-    /// Write the result of passing n through `uint::to_str_bytes`.\n-    fn write_uint(&self, n: uint);\n-\n-    /// Write a little-endian uint (number of bytes depends on system).\n-    fn write_le_uint(&self, n: uint);\n-\n-    /// Write a little-endian int (number of bytes depends on system).\n-    fn write_le_int(&self, n: int);\n-\n-    /// Write a big-endian uint (number of bytes depends on system).\n-    fn write_be_uint(&self, n: uint);\n-\n-    /// Write a big-endian int (number of bytes depends on system).\n-    fn write_be_int(&self, n: int);\n-\n-    /// Write a big-endian u64 (8 bytes).\n-    fn write_be_u64(&self, n: u64);\n-\n-    /// Write a big-endian u32 (4 bytes).\n-    fn write_be_u32(&self, n: u32);\n-\n-    /// Write a big-endian u16 (2 bytes).\n-    fn write_be_u16(&self, n: u16);\n-\n-    /// Write a big-endian i64 (8 bytes).\n-    fn write_be_i64(&self, n: i64);\n-\n-    /// Write a big-endian i32 (4 bytes).\n-    fn write_be_i32(&self, n: i32);\n-\n-    /// Write a big-endian i16 (2 bytes).\n-    fn write_be_i16(&self, n: i16);\n-\n-    /// Write a big-endian IEEE754 double-precision floating-point (8 bytes).\n-    fn write_be_f64(&self, f: f64);\n-\n-    /// Write a big-endian IEEE754 single-precision floating-point (4 bytes).\n-    fn write_be_f32(&self, f: f32);\n-\n-    /// Write a little-endian u64 (8 bytes).\n-    fn write_le_u64(&self, n: u64);\n-\n-    /// Write a little-endian u32 (4 bytes).\n-    fn write_le_u32(&self, n: u32);\n-\n-    /// Write a little-endian u16 (2 bytes).\n-    fn write_le_u16(&self, n: u16);\n-\n-    /// Write a little-endian i64 (8 bytes).\n-    fn write_le_i64(&self, n: i64);\n-\n-    /// Write a little-endian i32 (4 bytes).\n-    fn write_le_i32(&self, n: i32);\n-\n-    /// Write a little-endian i16 (2 bytes).\n-    fn write_le_i16(&self, n: i16);\n-\n-    /// Write a little-endian IEEE754 double-precision floating-point\n-    /// (8 bytes).\n-    fn write_le_f64(&self, f: f64);\n-\n-    /// Write a little-endian IEEE754 single-precision floating-point\n-    /// (4 bytes).\n-    fn write_le_f32(&self, f: f32);\n-\n-    /// Write a u8 (1 byte).\n-    fn write_u8(&self, n: u8);\n-\n-    /// Write a i8 (1 byte).\n-    fn write_i8(&self, n: i8);\n-}\n-\n-impl<T:Writer> WriterUtil for T {\n-    fn write_char(&self, ch: char) {\n-        if (ch as uint) < 128u {\n-            self.write(&[ch as u8]);\n-        } else {\n-            self.write_str(str::from_char(ch));\n-        }\n-    }\n-    fn write_str(&self, s: &str) { self.write(s.as_bytes()) }\n-    fn write_line(&self, s: &str) {\n-        self.write_str(s);\n-        self.write_str(&\"\\n\");\n-    }\n-    fn write_int(&self, n: int) {\n-        int::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n-    }\n-    fn write_uint(&self, n: uint) {\n-        uint::to_str_bytes(n, 10u, |bytes| self.write(bytes))\n-    }\n-    fn write_le_uint(&self, n: uint) {\n-        u64_to_le_bytes(n as u64, uint::bytes, |v| self.write(v))\n-    }\n-    fn write_le_int(&self, n: int) {\n-        u64_to_le_bytes(n as u64, int::bytes, |v| self.write(v))\n-    }\n-    fn write_be_uint(&self, n: uint) {\n-        u64_to_be_bytes(n as u64, uint::bytes, |v| self.write(v))\n-    }\n-    fn write_be_int(&self, n: int) {\n-        u64_to_be_bytes(n as u64, int::bytes, |v| self.write(v))\n-    }\n-    fn write_be_u64(&self, n: u64) {\n-        u64_to_be_bytes(n, 8u, |v| self.write(v))\n-    }\n-    fn write_be_u32(&self, n: u32) {\n-        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-    fn write_be_u16(&self, n: u16) {\n-        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-    fn write_be_i64(&self, n: i64) {\n-        u64_to_be_bytes(n as u64, 8u, |v| self.write(v))\n-    }\n-    fn write_be_i32(&self, n: i32) {\n-        u64_to_be_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-    fn write_be_i16(&self, n: i16) {\n-        u64_to_be_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-    fn write_be_f64(&self, f:f64) {\n-        unsafe {\n-            self.write_be_u64(cast::transmute(f))\n-        }\n-    }\n-    fn write_be_f32(&self, f:f32) {\n-        unsafe {\n-            self.write_be_u32(cast::transmute(f))\n-        }\n-    }\n-    fn write_le_u64(&self, n: u64) {\n-        u64_to_le_bytes(n, 8u, |v| self.write(v))\n-    }\n-    fn write_le_u32(&self, n: u32) {\n-        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-    fn write_le_u16(&self, n: u16) {\n-        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-    fn write_le_i64(&self, n: i64) {\n-        u64_to_le_bytes(n as u64, 8u, |v| self.write(v))\n-    }\n-    fn write_le_i32(&self, n: i32) {\n-        u64_to_le_bytes(n as u64, 4u, |v| self.write(v))\n-    }\n-    fn write_le_i16(&self, n: i16) {\n-        u64_to_le_bytes(n as u64, 2u, |v| self.write(v))\n-    }\n-    fn write_le_f64(&self, f:f64) {\n-        unsafe {\n-            self.write_le_u64(cast::transmute(f))\n-        }\n-    }\n-    fn write_le_f32(&self, f:f32) {\n-        unsafe {\n-            self.write_le_u32(cast::transmute(f))\n-        }\n-    }\n-\n-    fn write_u8(&self, n: u8) { self.write([n]) }\n-    fn write_i8(&self, n: i8) { self.write([n as u8]) }\n-\n-}\n-\n-pub fn file_writer(path: &Path, flags: &[FileFlag]) -> Result<@Writer, ~str> {\n-    mk_file_writer(path, flags).and_then(|w| Ok(w))\n-}\n-\n-// FIXME (#2004) it would be great if this could be a const\n-// FIXME (#2004) why are these different from the way stdin() is\n-// implemented?\n-\n-pub struct BytesWriter {\n-    bytes: @mut ~[u8],\n-    pos: @mut uint,\n-}\n-\n-impl BytesWriter {\n-    pub fn new() -> BytesWriter {\n-        BytesWriter {\n-            bytes: @mut ~[],\n-            pos: @mut 0\n-        }\n-    }\n-}\n-\n-impl Writer for BytesWriter {\n-    fn write(&self, v: &[u8]) {\n-        let v_len = v.len();\n-\n-        let bytes = &mut *self.bytes;\n-        let count = num::max(bytes.len(), *self.pos + v_len);\n-        bytes.reserve(count);\n-\n-        unsafe {\n-            vec::raw::set_len(bytes, count);\n-\n-            let view = bytes.mut_slice(*self.pos, count);\n-            vec::bytes::copy_memory(view, v, v_len);\n-        }\n-\n-        *self.pos += v_len;\n-    }\n-\n-    fn seek(&self, offset: int, whence: SeekStyle) {\n-        let pos = *self.pos;\n-        let len = self.bytes.len();\n-        *self.pos = seek_in_buf(offset, pos, len, whence);\n-    }\n-\n-    fn tell(&self) -> uint {\n-        *self.pos\n-    }\n-\n-    fn flush(&self) -> int {\n-        0\n-    }\n-\n-    fn get_type(&self) -> WriterType {\n-        File\n-    }\n-}\n-\n-pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n-    let wr = @BytesWriter::new();\n-    f(wr as @Writer);\n-    let @BytesWriter { bytes, _ } = wr;\n-    (*bytes).clone()\n-}\n-\n-pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n-    str::from_utf8(with_bytes_writer(f))\n-}\n-\n-// Utility functions\n-fn seek_in_buf(offset: int, pos: uint, len: uint, whence: SeekStyle) ->\n-   uint {\n-    let mut bpos = pos as int;\n-    let blen = len as int;\n-    match whence {\n-      SeekSet => bpos = offset,\n-      SeekCur => bpos += offset,\n-      SeekEnd => bpos = blen + offset\n-    }\n-    if bpos < 0 { bpos = 0; } else if bpos > blen { bpos = blen; }\n-    return bpos as uint;\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use i32;\n-    use io::{BytesWriter, SeekCur, SeekEnd, SeekSet};\n-    use io;\n-    use path::Path;\n-    use result::{Ok, Err};\n-    use u64;\n-    use vec;\n-    use cast::transmute;\n-\n-    #[test]\n-    fn test_simple() {\n-        let tmpfile = &Path::new(\"tmp/lib-io-test-simple.tmp\");\n-        debug!(\"{}\", tmpfile.display());\n-        let frood: ~str =\n-            ~\"A hoopy frood who really knows where his towel is.\";\n-        debug!(\"{}\", frood.clone());\n-        {\n-            let out = io::file_writer(tmpfile, [io::Create, io::Truncate]).unwrap();\n-            out.write_str(frood);\n-        }\n-        let inp = io::file_reader(tmpfile).unwrap();\n-        let frood2: ~str = inp.read_c_str();\n-        debug!(\"{}\", frood2.clone());\n-        assert_eq!(frood, frood2);\n-    }\n-\n-    #[test]\n-    fn test_each_byte_each_char_file() {\n-        // Issue #5056 -- shouldn't include trailing EOF.\n-        let path = Path::new(\"tmp/lib-io-test-each-byte-each-char-file.tmp\");\n-\n-        {\n-            // create empty, enough to reproduce a problem\n-            io::file_writer(&path, [io::Create]).unwrap();\n-        }\n-\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            do file.each_byte() |_| {\n-                fail!(\"must be empty\")\n-            };\n-        }\n-\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            do file.each_char() |_| {\n-                fail!(\"must be empty\")\n-            };\n-        }\n-    }\n-\n-    #[test]\n-    fn file_reader_not_exist() {\n-        match io::file_reader(&Path::new(\"not a file\")) {\n-          Err(e) => {\n-            assert_eq!(e, ~\"error opening not a file\");\n-          }\n-          Ok(_) => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_read_buffer_too_small() {\n-        let path = &Path::new(\"tmp/lib-io-test-read-buffer-too-small.tmp\");\n-        // ensure the file exists\n-        io::file_writer(path, [io::Create]).unwrap();\n-\n-        let file = io::file_reader(path).unwrap();\n-        let mut buf = vec::from_elem(5, 0u8);\n-        file.read(buf, 6); // this should fail because buf is too small\n-    }\n-\n-    #[test]\n-    fn test_read_buffer_big_enough() {\n-        let path = &Path::new(\"tmp/lib-io-test-read-buffer-big-enough.tmp\");\n-        // ensure the file exists\n-        io::file_writer(path, [io::Create]).unwrap();\n-\n-        let file = io::file_reader(path).unwrap();\n-        let mut buf = vec::from_elem(5, 0u8);\n-        file.read(buf, 4); // this should succeed because buf is big enough\n-    }\n-\n-    #[test]\n-    fn test_write_empty() {\n-        let file = io::file_writer(&Path::new(\"tmp/lib-io-test-write-empty.tmp\"),\n-                                   [io::Create]).unwrap();\n-        file.write([]);\n-    }\n-\n-    #[test]\n-    fn file_writer_bad_name() {\n-        match io::file_writer(&Path::new(\"?/?\"), []) {\n-          Err(e) => {\n-            assert!(e.starts_with(\"error opening\"));\n-          }\n-          Ok(_) => fail!()\n-        }\n-    }\n-\n-    #[test]\n-    fn bytes_buffer_overwrite() {\n-        let wr = BytesWriter::new();\n-        wr.write([0u8, 1u8, 2u8, 3u8]);\n-        assert!(*wr.bytes == ~[0u8, 1u8, 2u8, 3u8]);\n-        wr.seek(-2, SeekCur);\n-        wr.write([4u8, 5u8, 6u8, 7u8]);\n-        assert!(*wr.bytes == ~[0u8, 1u8, 4u8, 5u8, 6u8, 7u8]);\n-        wr.seek(-2, SeekEnd);\n-        wr.write([8u8]);\n-        wr.seek(1, SeekSet);\n-        wr.write([9u8]);\n-        assert!(*wr.bytes == ~[0u8, 9u8, 4u8, 5u8, 8u8, 7u8]);\n-    }\n-\n-    #[test]\n-    fn test_read_write_le() {\n-        let path = Path::new(\"tmp/lib-io-test-read-write-le.tmp\");\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n-\n-        // write the ints to the file\n-        {\n-            let file = io::file_writer(&path, [io::Create]).unwrap();\n-            for i in uints.iter() {\n-                file.write_le_u64(*i);\n-            }\n-        }\n-\n-        // then read them back and check that they are the same\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            for i in uints.iter() {\n-                assert_eq!(file.read_le_u64(), *i);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_write_be() {\n-        let path = Path::new(\"tmp/lib-io-test-read-write-be.tmp\");\n-        let uints = [0, 1, 2, 42, 10_123, 100_123_456, u64::max_value];\n-\n-        // write the ints to the file\n-        {\n-            let file = io::file_writer(&path, [io::Create]).unwrap();\n-            for i in uints.iter() {\n-                file.write_be_u64(*i);\n-            }\n-        }\n-\n-        // then read them back and check that they are the same\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            for i in uints.iter() {\n-                assert_eq!(file.read_be_u64(), *i);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_be_int_n() {\n-        let path = Path::new(\"tmp/lib-io-test-read-be-int-n.tmp\");\n-        let ints = [i32::min_value, -123456, -42, -5, 0, 1, i32::max_value];\n-\n-        // write the ints to the file\n-        {\n-            let file = io::file_writer(&path, [io::Create]).unwrap();\n-            for i in ints.iter() {\n-                file.write_be_i32(*i);\n-            }\n-        }\n-\n-        // then read them back and check that they are the same\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            for i in ints.iter() {\n-                // this tests that the sign extension is working\n-                // (comparing the values as i32 would not test this)\n-                assert_eq!(file.read_be_int_n(4), *i as i64);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_f32() {\n-        let path = Path::new(\"tmp/lib-io-test-read-f32.tmp\");\n-        //big-endian floating-point 8.1250\n-        let buf = ~[0x41, 0x02, 0x00, 0x00];\n-\n-        {\n-            let file = io::file_writer(&path, [io::Create]).unwrap();\n-            file.write(buf);\n-        }\n-\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            let f = file.read_be_f32();\n-            assert_eq!(f, 8.1250);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_read_write_f32() {\n-        let path = Path::new(\"tmp/lib-io-test-read-write-f32.tmp\");\n-        let f:f32 = 8.1250;\n-\n-        {\n-            let file = io::file_writer(&path, [io::Create]).unwrap();\n-            file.write_be_f32(f);\n-            file.write_le_f32(f);\n-        }\n-\n-        {\n-            let file = io::file_reader(&path).unwrap();\n-            assert_eq!(file.read_be_f32(), 8.1250);\n-            assert_eq!(file.read_le_f32(), 8.1250);\n-        }\n-    }\n-}"}, {"sha": "bb8e6674b464b15d387a69a9d0d5878d8ddd57e3", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "patch": "@@ -53,7 +53,6 @@ pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use default::Default;\n pub use from_str::FromStr;\n pub use hash::Hash;\n-pub use io::{Reader, ReaderUtil, Writer, WriterUtil};\n pub use iter::{FromIterator, Extendable};\n pub use iter::{Iterator, DoubleEndedIterator, RandomAccessIterator, ClonableIterator};\n pub use iter::{OrdIterator, MutableDoubleEndedIterator, ExactSize};"}, {"sha": "4b16f0bc0e1833681ff1f88b4c04726e6ac5fad3", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 82, "deletions": 1, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "patch": "@@ -22,7 +22,6 @@ use rt::io::{io_error, standard_error, EndOfFile, DEFAULT_BUF_SIZE};\n use option::{Option, Some, None};\n use unstable::finally::Finally;\n use cast;\n-use io::{u64_to_le_bytes, u64_to_be_bytes};\n \n pub trait ReaderUtil {\n \n@@ -634,6 +633,88 @@ fn extend_sign(val: u64, nbytes: uint) -> i64 {\n     (val << shift) as i64 >> shift\n }\n \n+pub fn u64_to_le_bytes<T>(n: u64, size: uint,\n+                          f: &fn(v: &[u8]) -> T) -> T {\n+    assert!(size <= 8u);\n+    match size {\n+      1u => f(&[n as u8]),\n+      2u => f(&[n as u8,\n+              (n >> 8) as u8]),\n+      4u => f(&[n as u8,\n+              (n >> 8) as u8,\n+              (n >> 16) as u8,\n+              (n >> 24) as u8]),\n+      8u => f(&[n as u8,\n+              (n >> 8) as u8,\n+              (n >> 16) as u8,\n+              (n >> 24) as u8,\n+              (n >> 32) as u8,\n+              (n >> 40) as u8,\n+              (n >> 48) as u8,\n+              (n >> 56) as u8]),\n+      _ => {\n+\n+        let mut bytes: ~[u8] = ~[];\n+        let mut i = size;\n+        let mut n = n;\n+        while i > 0u {\n+            bytes.push((n & 255_u64) as u8);\n+            n >>= 8_u64;\n+            i -= 1u;\n+        }\n+        f(bytes)\n+      }\n+    }\n+}\n+\n+pub fn u64_to_be_bytes<T>(n: u64, size: uint,\n+                           f: &fn(v: &[u8]) -> T) -> T {\n+    assert!(size <= 8u);\n+    match size {\n+      1u => f(&[n as u8]),\n+      2u => f(&[(n >> 8) as u8,\n+              n as u8]),\n+      4u => f(&[(n >> 24) as u8,\n+              (n >> 16) as u8,\n+              (n >> 8) as u8,\n+              n as u8]),\n+      8u => f(&[(n >> 56) as u8,\n+              (n >> 48) as u8,\n+              (n >> 40) as u8,\n+              (n >> 32) as u8,\n+              (n >> 24) as u8,\n+              (n >> 16) as u8,\n+              (n >> 8) as u8,\n+              n as u8]),\n+      _ => {\n+        let mut bytes: ~[u8] = ~[];\n+        let mut i = size;\n+        while i > 0u {\n+            let shift = ((i - 1u) * 8u) as u64;\n+            bytes.push((n >> shift) as u8);\n+            i -= 1u;\n+        }\n+        f(bytes)\n+      }\n+    }\n+}\n+\n+pub fn u64_from_be_bytes(data: &[u8],\n+                         start: uint,\n+                         size: uint)\n+                      -> u64 {\n+    let mut sz = size;\n+    assert!((sz <= 8u));\n+    let mut val = 0_u64;\n+    let mut pos = start;\n+    while sz > 0u {\n+        sz -= 1u;\n+        val += (data[pos] as u64) << ((sz * 8u) as u64);\n+        pos += 1u;\n+    }\n+    return val;\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::ReaderUtil;"}, {"sha": "12316cb5ead2a2c66ff4d5f45b86b9bef7513bb4", "filename": "src/libstd/std.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "patch": "@@ -148,7 +148,6 @@ pub mod iter;\n pub mod to_str;\n pub mod to_bytes;\n pub mod clone;\n-pub mod io;\n pub mod hash;\n pub mod container;\n pub mod default;"}, {"sha": "8c78e34528bdec63928586c28717ee449a8e5018", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "patch": "@@ -16,8 +16,6 @@ The `ToBytes` and `IterBytes` traits\n \n use cast;\n use container::Container;\n-use io;\n-use io::Writer;\n use iter::Iterator;\n use option::{None, Option, Some};\n use str::{Str, StrSlice};\n@@ -360,7 +358,10 @@ pub trait ToBytes {\n \n impl<A:IterBytes> ToBytes for A {\n     fn to_bytes(&self, lsb0: bool) -> ~[u8] {\n-        do io::with_bytes_writer |wr| {\n+        use rt::io::mem;\n+        use rt::io::Writer;\n+\n+        do mem::with_mem_writer |wr| {\n             do self.iter_bytes(lsb0) |bytes| {\n                 wr.write(bytes);\n                 true"}, {"sha": "dcfef4e1d9c8510838f087b24507c19e07feaf8f", "filename": "src/test/compile-fail/borrowck-auto-mut-ref-to-immut-var.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-auto-mut-ref-to-immut-var.rs?ref=6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "patch": "@@ -10,8 +10,6 @@\n \n // Tests that auto-ref can't create mutable aliases to immutable memory.\n \n-use std::io;\n-\n struct Foo {\n     x: int\n }"}, {"sha": "8cd2d9edbd7c0de6ac18b8d9c77dabd6f8e0e6fa", "filename": "src/test/run-pass/glob-std.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Ftest%2Frun-pass%2Fglob-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bb1df92511e7ecafe0554b01410f4e68d7bc66f/src%2Ftest%2Frun-pass%2Fglob-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglob-std.rs?ref=6bb1df92511e7ecafe0554b01410f4e68d7bc66f", "patch": "@@ -15,14 +15,16 @@ extern mod extra;\n use extra::glob::glob;\n use extra::tempfile::TempDir;\n use std::unstable::finally::Finally;\n-use std::{io, os, unstable};\n+use std::{os, unstable};\n+use std::rt::io;\n+use std::rt::io::file::FileInfo;\n \n pub fn main() {\n     fn mk_file(path: &str, directory: bool) {\n         if directory {\n             os::make_dir(&Path::new(path), 0xFFFF);\n         } else {\n-            io::mk_file_writer(&Path::new(path), [io::Create]);\n+            Path::new(path).open_writer(io::Create);\n         }\n     }\n "}]}