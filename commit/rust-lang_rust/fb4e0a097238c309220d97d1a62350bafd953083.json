{"sha": "fb4e0a097238c309220d97d1a62350bafd953083", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNGUwYTA5NzIzOGMzMDkyMjBkOTdkMWE2MjM1MGJhZmQ5NTMwODM=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-07-25T10:43:48Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-07-30T16:51:39Z"}, "message": "Implement trait upcasting coercion type-checking.", "tree": {"sha": "bce243f13013ceddb82efd2f5ebc0b60445c55a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bce243f13013ceddb82efd2f5ebc0b60445c55a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb4e0a097238c309220d97d1a62350bafd953083", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4e0a097238c309220d97d1a62350bafd953083", "html_url": "https://github.com/rust-lang/rust/commit/fb4e0a097238c309220d97d1a62350bafd953083", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb4e0a097238c309220d97d1a62350bafd953083/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac354cf5ced544e7e7c74f67ea5fd82d5b501aed", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac354cf5ced544e7e7c74f67ea5fd82d5b501aed", "html_url": "https://github.com/rust-lang/rust/commit/ac354cf5ced544e7e7c74f67ea5fd82d5b501aed"}], "stats": {"total": 155, "additions": 130, "deletions": 25}, "files": [{"sha": "c7bf1f2a94319bc128ee6d5ee16f141e9752546d", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e0a097238c309220d97d1a62350bafd953083/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e0a097238c309220d97d1a62350bafd953083/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=fb4e0a097238c309220d97d1a62350bafd953083", "patch": "@@ -693,22 +693,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let may_apply = match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n-                // Upcasts permit two things:\n-                //\n-                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n-                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n-                //\n-                // Note that neither of these changes requires any\n-                // change at runtime. Eventually this will be\n-                // generalized.\n-                //\n-                // We always upcast when we can because of reason\n-                // #2 (region bounds).\n-                data_a.principal_def_id() == data_b.principal_def_id()\n-                    && data_b\n-                        .auto_traits()\n-                        // All of a's auto traits need to be in b's auto traits.\n-                        .all(|b| data_a.auto_traits().any(|a| a == b))\n+                // See `confirm_builtin_unsize_candidate` for more info.\n+                let auto_traits_compatible = data_b\n+                    .auto_traits()\n+                    // All of a's auto traits need to be in b's auto traits.\n+                    .all(|b| data_a.auto_traits().any(|a| a == b));\n+                auto_traits_compatible\n             }\n \n             // `T` -> `Trait`"}, {"sha": "0c2099593a2616c4a026bf5577919cc04f1d1a8c", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 50, "deletions": 4, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e0a097238c309220d97d1a62350bafd953083/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e0a097238c309220d97d1a62350bafd953083/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=fb4e0a097238c309220d97d1a62350bafd953083", "patch": "@@ -703,10 +703,56 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match (source.kind(), target.kind()) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n             (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n-                // See `assemble_candidates_for_unsizing` for more info.\n-                let iter = data_a\n-                    .principal()\n-                    .map(|b| b.map_bound(ty::ExistentialPredicate::Trait))\n+                // Upcast coercions permit several things:\n+                //\n+                // 1. Dropping auto traits, e.g., `Foo + Send` to `Foo`\n+                // 2. Tightening the region bound, e.g., `Foo + 'a` to `Foo + 'b` if `'a: 'b`\n+                // 3. Tightening trait to its super traits, eg. `Foo` to `Bar` if `Foo: Bar`\n+                //\n+                // Note that neither of the first two of these changes requires any\n+                // change at runtime. The third needs to change pointer metadata at runtime.\n+                //\n+                // We always perform upcasting coercions when we can because of reason\n+                // #2 (region bounds).\n+\n+                // We already checked the compatiblity of auto traits within `assemble_candidates_for_unsizing`.\n+\n+                let principal_a = data_a.principal();\n+                let principal_def_id_b = data_b.principal_def_id();\n+\n+                let existential_predicate = if let Some(principal_a) = principal_a {\n+                    let source_trait_ref = principal_a.with_self_ty(tcx, source);\n+                    let target_trait_did = principal_def_id_b.ok_or_else(|| Unimplemented)?;\n+                    let upcast_idx = util::supertraits(tcx, source_trait_ref)\n+                        .position(|upcast_trait_ref| upcast_trait_ref.def_id() == target_trait_did)\n+                        .ok_or_else(|| Unimplemented)?;\n+                    // FIXME(crlf0710): This is less than ideal, for example,\n+                    // if the trait is defined as `trait Foo: Bar<u32> + Bar<i32>`,\n+                    // the coercion from Box<Foo> to Box<dyn Bar<_>> is actually ambiguous.\n+                    // We currently make this coercion fail for now.\n+                    //\n+                    // see #65991 for more information.\n+                    if util::supertraits(tcx, source_trait_ref)\n+                        .skip(upcast_idx + 1)\n+                        .any(|upcast_trait_ref| upcast_trait_ref.def_id() == target_trait_did)\n+                    {\n+                        return Err(Unimplemented);\n+                    }\n+                    let target_trait_ref =\n+                        util::supertraits(tcx, source_trait_ref).nth(upcast_idx).unwrap();\n+                    let existential_predicate = target_trait_ref.map_bound(|trait_ref| {\n+                        ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef::erase_self_ty(\n+                            tcx, trait_ref,\n+                        ))\n+                    });\n+                    Some(existential_predicate)\n+                } else if principal_def_id_b.is_none() {\n+                    None\n+                } else {\n+                    return Err(Unimplemented);\n+                };\n+\n+                let iter = existential_predicate\n                     .into_iter()\n                     .chain(\n                         data_a"}, {"sha": "a83b39a110834d7aafeb3867d9e70115b69f9b17", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e0a097238c309220d97d1a62350bafd953083/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e0a097238c309220d97d1a62350bafd953083/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=fb4e0a097238c309220d97d1a62350bafd953083", "patch": "@@ -576,6 +576,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         )];\n \n         let mut has_unsized_tuple_coercion = false;\n+        let mut has_trait_upcasting_coercion = false;\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n@@ -590,7 +591,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     if traits.contains(&trait_pred.def_id()) =>\n                 {\n                     if unsize_did == trait_pred.def_id() {\n+                        let self_ty = trait_pred.self_ty();\n                         let unsize_ty = trait_pred.trait_ref.substs[1].expect_ty();\n+                        if let (ty::Dynamic(ref data_a, ..), ty::Dynamic(ref data_b, ..)) =\n+                            (self_ty.kind(), unsize_ty.kind())\n+                        {\n+                            if data_a.principal_def_id() != data_b.principal_def_id() {\n+                                debug!(\"coerce_unsized: found trait upcasting coercion\");\n+                                has_trait_upcasting_coercion = true;\n+                            }\n+                        }\n                         if let ty::Tuple(..) = unsize_ty.kind() {\n                             debug!(\"coerce_unsized: found unsized tuple coercion\");\n                             has_unsized_tuple_coercion = true;\n@@ -666,6 +676,16 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             .emit();\n         }\n \n+        if has_trait_upcasting_coercion && !self.tcx().features().trait_upcasting {\n+            feature_err(\n+                &self.tcx.sess.parse_sess,\n+                sym::trait_upcasting,\n+                self.cause.span,\n+                \"trait upcasting coercion is experimental\",\n+            )\n+            .emit();\n+        }\n+\n         Ok(coercion)\n     }\n "}, {"sha": "e4102f1cfa75d1ea48049b16d3a788d5e0b95944", "filename": "src/test/ui/feature-gates/feature-gate-trait_upcasting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.rs?ref=fb4e0a097238c309220d97d1a62350bafd953083", "patch": "@@ -9,5 +9,5 @@ impl Bar for () {}\n fn main() {\n     let bar: &dyn Bar = &();\n     let foo: &dyn Foo = bar;\n-    //~^ ERROR trait upcasting is experimental [E0658]\n+    //~^ ERROR trait upcasting coercion is experimental [E0658]\n }"}, {"sha": "bc13a5d7d7b46b171ccb7db7416a3aa3e9d8b589", "filename": "src/test/ui/feature-gates/feature-gate-trait_upcasting.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-trait_upcasting.stderr?ref=fb4e0a097238c309220d97d1a62350bafd953083", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: trait upcasting is experimental\n+error[E0658]: trait upcasting coercion is experimental\n   --> $DIR/feature-gate-trait_upcasting.rs:11:25\n    |\n LL |     let foo: &dyn Foo = bar;"}, {"sha": "2072f9c47e2a65dd766fbb707d13e5eec0e44578", "filename": "src/test/ui/issues/issue-11515.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Fissues%2Fissue-11515.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Fissues%2Fissue-11515.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11515.rs?ref=fb4e0a097238c309220d97d1a62350bafd953083", "patch": "@@ -1,10 +1,10 @@\n #![feature(box_syntax)]\n \n struct Test {\n-    func: Box<dyn FnMut() + 'static>\n+    func: Box<dyn FnMut() + 'static>,\n }\n \n fn main() {\n     let closure: Box<dyn Fn() + 'static> = Box::new(|| ());\n-    let test = box Test { func: closure }; //~ ERROR trait upcasting is experimental [E0658]\n+    let test = box Test { func: closure }; //~ ERROR trait upcasting coercion is experimental [E0658]\n }"}, {"sha": "a70e7c416bc0f3157df6e54901e8eb25a91f80f5", "filename": "src/test/ui/issues/issue-11515.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Fissues%2Fissue-11515.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Fissues%2Fissue-11515.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11515.stderr?ref=fb4e0a097238c309220d97d1a62350bafd953083", "patch": "@@ -1,4 +1,4 @@\n-error[E0658]: trait upcasting is experimental\n+error[E0658]: trait upcasting coercion is experimental\n   --> $DIR/issue-11515.rs:9:33\n    |\n LL |     let test = box Test { func: closure };"}, {"sha": "277d9eabe4fb2ce7737c333e2da5c1e565854462", "filename": "src/test/ui/traits/trait-upcasting/issue-11515-upcast-fn_mut-fn.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fissue-11515-upcast-fn_mut-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fissue-11515-upcast-fn_mut-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fissue-11515-upcast-fn_mut-fn.rs?ref=fb4e0a097238c309220d97d1a62350bafd953083", "patch": "@@ -0,0 +1,13 @@\n+// run-pass\n+#![feature(box_syntax, trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+struct Test {\n+    func: Box<dyn FnMut() + 'static>,\n+}\n+\n+fn main() {\n+    let closure: Box<dyn Fn() + 'static> = Box::new(|| ());\n+    let mut test = box Test { func: closure };\n+    (test.func)();\n+}"}, {"sha": "6986ad6217240423c3772114e11ddbb9fa3c943a", "filename": "src/test/ui/traits/trait-upcasting/multiple-occurence-ambiguousity.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.rs?ref=fb4e0a097238c309220d97d1a62350bafd953083", "patch": "@@ -0,0 +1,22 @@\n+// check-fail\n+#![feature(trait_upcasting)]\n+#![allow(incomplete_features)]\n+\n+trait Bar<T> {\n+    fn bar(&self, _: T) {}\n+}\n+\n+trait Foo : Bar<i32> + Bar<u32> {\n+    fn foo(&self, _: ()) {}\n+}\n+\n+struct S;\n+\n+impl Bar<i32> for S {}\n+impl Bar<u32> for S {}\n+impl Foo for S {}\n+\n+fn main() {\n+    let s: &dyn Foo = &S;\n+    let t: &dyn Bar<_> = s; //~ ERROR mismatched types\n+}"}, {"sha": "e9670ad7def4db1505c8e49573eef04b748731b9", "filename": "src/test/ui/traits/trait-upcasting/multiple-occurence-ambiguousity.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fb4e0a097238c309220d97d1a62350bafd953083/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-upcasting%2Fmultiple-occurence-ambiguousity.stderr?ref=fb4e0a097238c309220d97d1a62350bafd953083", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/multiple-occurence-ambiguousity.rs:21:26\n+   |\n+LL |     let t: &dyn Bar<_> = s;\n+   |            -----------   ^ expected trait `Bar`, found trait `Foo`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Bar<_>`\n+              found reference `&dyn Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}