{"sha": "3bcea5f97988af0e113128666cfabf335053d1d5", "node_id": "C_kwDOAAsO6NoAKDNiY2VhNWY5Nzk4OGFmMGUxMTMxMjg2NjZjZmFiZjMzNTA1M2QxZDU", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-03-02T22:23:07Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2023-03-02T22:59:33Z"}, "message": "Improve comments in `needs_process_obligation`.\n\nAnd a couple of other places.", "tree": {"sha": "1e642f91f35c87de10c96516ffa010ea599bce79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e642f91f35c87de10c96516ffa010ea599bce79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bcea5f97988af0e113128666cfabf335053d1d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bcea5f97988af0e113128666cfabf335053d1d5", "html_url": "https://github.com/rust-lang/rust/commit/3bcea5f97988af0e113128666cfabf335053d1d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bcea5f97988af0e113128666cfabf335053d1d5/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca1bc7f1f6487991dd6b504d1fddbc982e6b779c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1bc7f1f6487991dd6b504d1fddbc982e6b779c", "html_url": "https://github.com/rust-lang/rust/commit/ca1bc7f1f6487991dd6b504d1fddbc982e6b779c"}], "stats": {"total": 58, "additions": 34, "deletions": 24}, "files": [{"sha": "91abdaadabdbd4453fc38881ab96ebc0d0805394", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3bcea5f97988af0e113128666cfabf335053d1d5/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcea5f97988af0e113128666cfabf335053d1d5/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=3bcea5f97988af0e113128666cfabf335053d1d5", "patch": "@@ -426,6 +426,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             // nodes. Therefore we use a `while` loop.\n             let mut index = 0;\n             while let Some(node) = self.nodes.get_mut(index) {\n+                // This test is extremely hot.\n                 if node.state.get() != NodeState::Pending\n                     || !processor.needs_process_obligation(&node.obligation)\n                 {\n@@ -439,6 +440,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 // out of sync with `nodes`. It's not very common, but it does\n                 // happen, and code in `compress` has to allow for it.\n \n+                // This code is much less hot.\n                 match processor.process_obligation(&mut node.obligation) {\n                     ProcessResult::Unchanged => {\n                         // No change in state."}, {"sha": "944436ab82f91cc79522d1dc5c9acc02e0280f4b", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 32, "deletions": 24, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3bcea5f97988af0e113128666cfabf335053d1d5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bcea5f97988af0e113128666cfabf335053d1d5/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=3bcea5f97988af0e113128666cfabf335053d1d5", "patch": "@@ -212,36 +212,44 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n \n     /// Identifies whether a predicate obligation needs processing.\n     ///\n-    /// This is always inlined, despite its size, because it has a single\n-    /// callsite and it is called *very* frequently.\n+    /// This is always inlined because it has a single callsite and it is\n+    /// called *very* frequently. Be careful modifying this code! Several\n+    /// compile-time benchmarks are very sensitive to even small changes.\n     #[inline(always)]\n     fn needs_process_obligation(&self, pending_obligation: &Self::Obligation) -> bool {\n         // If we were stalled on some unresolved variables, first check whether\n         // any of them have been resolved; if not, don't bother doing more work\n         // yet.\n-        match pending_obligation.stalled_on.len() {\n-            // Match arms are in order of frequency, which matters because this\n-            // code is so hot. 1 and 0 dominate; 2+ is fairly rare.\n-            1 => {\n-                let infer_var = pending_obligation.stalled_on[0];\n-                self.selcx.infcx.ty_or_const_infer_var_changed(infer_var)\n-            }\n-            0 => {\n-                // In this case we haven't changed, but wish to make a change.\n-                true\n-            }\n-            _ => {\n-                // This `for` loop was once a call to `all()`, but this lower-level\n-                // form was a perf win. See #64545 for details.\n-                (|| {\n-                    for &infer_var in &pending_obligation.stalled_on {\n-                        if self.selcx.infcx.ty_or_const_infer_var_changed(infer_var) {\n-                            return true;\n-                        }\n+        let stalled_on = &pending_obligation.stalled_on;\n+        match stalled_on.len() {\n+            // This case is the hottest most of the time, being hit up to 99%\n+            // of the time. `keccak` and `cranelift-codegen-0.82.1` are\n+            // benchmarks that particularly stress this path.\n+            1 => self.selcx.infcx.ty_or_const_infer_var_changed(stalled_on[0]),\n+\n+            // In this case we haven't changed, but wish to make a change. Note\n+            // that this is a special case, and is not equivalent to the `_`\n+            // case below, which would return `false` for an empty `stalled_on`\n+            // vector.\n+            //\n+            // This case is usually hit only 1% of the time or less, though it\n+            // reaches 20% in `wasmparser-0.101.0`.\n+            0 => true,\n+\n+            // This case is usually hit only 1% of the time or less, though it\n+            // reaches 95% in `mime-0.3.16`, 64% in `wast-54.0.0`, and 12% in\n+            // `inflate-0.4.5`.\n+            //\n+            // The obvious way of writing this, with a call to `any()` and no\n+            // closure, is currently slower than this version.\n+            _ => (|| {\n+                for &infer_var in stalled_on {\n+                    if self.selcx.infcx.ty_or_const_infer_var_changed(infer_var) {\n+                        return true;\n                     }\n-                    false\n-                })()\n-            }\n+                }\n+                false\n+            })(),\n         }\n     }\n "}]}