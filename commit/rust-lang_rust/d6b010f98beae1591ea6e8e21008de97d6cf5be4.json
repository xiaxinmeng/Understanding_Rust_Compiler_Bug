{"sha": "d6b010f98beae1591ea6e8e21008de97d6cf5be4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YjAxMGY5OGJlYWUxNTkxZWE2ZThlMjEwMDhkZTk3ZDZjZjViZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-30T08:00:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-30T08:00:27Z"}, "message": "Auto merge of #46226 - arielb1:special-region-obligation, r=nikomatsakis\n\navoid type-live-for-region obligations on dummy nodes\n\nType-live-for-region obligations on DUMMY_NODE_ID cause an ICE, and it\nturns out that in the few cases they are needed, these obligations are not\nneeded anyway because they are verified elsewhere.\n\nFixes #46069.\n\nBeta-nominating because this is a regression for our new beta.\nr? @nikomatsakis", "tree": {"sha": "a315199382419e26b6c66078e7d3f348dffb0adf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a315199382419e26b6c66078e7d3f348dffb0adf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6b010f98beae1591ea6e8e21008de97d6cf5be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b010f98beae1591ea6e8e21008de97d6cf5be4", "html_url": "https://github.com/rust-lang/rust/commit/d6b010f98beae1591ea6e8e21008de97d6cf5be4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6b010f98beae1591ea6e8e21008de97d6cf5be4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "url": "https://api.github.com/repos/rust-lang/rust/commits/909b94b5cceb046a7a3aa7134be1a3e25f75fec4", "html_url": "https://github.com/rust-lang/rust/commit/909b94b5cceb046a7a3aa7134be1a3e25f75fec4"}, {"sha": "ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf", "html_url": "https://github.com/rust-lang/rust/commit/ebd219ab8e7be56020436f9c6d6a44c6d4f4a5cf"}], "stats": {"total": 201, "additions": 148, "deletions": 53}, "files": [{"sha": "3c3aba372fbd0132a9e3d56ba16023ce0b0dde72", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=d6b010f98beae1591ea6e8e21008de97d6cf5be4", "patch": "@@ -88,6 +88,7 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         body_id: ast::NodeId,\n         obligation: RegionObligation<'tcx>,\n     ) {\n+        debug!(\"register_region_obligation({:?}, {:?})\", body_id, obligation);\n         self.region_obligations\n             .borrow_mut()\n             .push((body_id, obligation));\n@@ -180,18 +181,6 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n             TypeOutlives::new(self, region_bound_pairs, implicit_region_bound, param_env);\n         outlives.type_must_outlive(origin, ty, region);\n     }\n-\n-    /// Ignore the region obligations, not bothering to prove\n-    /// them. This function should not really exist; it is used to\n-    /// accommodate some older code for the time being.\n-    pub fn ignore_region_obligations(&self) {\n-        assert!(\n-            !self.in_snapshot.get(),\n-            \"cannot ignore registered region obligations in a snapshot\"\n-        );\n-\n-        self.region_obligations.borrow_mut().clear();\n-    }\n }\n \n #[must_use] // you ought to invoke `into_accrued_obligations` when you are done =)"}, {"sha": "f56c3853de0ab67966ffc2a6eb8a82f6f40e1e64", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=d6b010f98beae1591ea6e8e21008de97d6cf5be4", "patch": "@@ -46,6 +46,19 @@ pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n     predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n+    // Should this fulfillment context register type-lives-for-region\n+    // obligations on its parent infcx? In some cases, region\n+    // obligations are either already known to hold (normalization) or\n+    // hopefully verifed elsewhere (type-impls-bound), and therefore\n+    // should not be checked.\n+    //\n+    // Note that if we are normalizing a type that we already\n+    // know is well-formed, there should be no harm setting this\n+    // to true - all the region variables should be determinable\n+    // using the RFC 447 rules, which don't depend on\n+    // type-lives-for-region constraints, and because the type\n+    // is well-formed, the constraints should hold.\n+    register_region_obligations: bool,\n }\n \n #[derive(Clone, Debug)]\n@@ -59,6 +72,14 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n+            register_region_obligations: true\n+        }\n+    }\n+\n+    pub fn new_ignoring_regions() -> FulfillmentContext<'tcx> {\n+        FulfillmentContext {\n+            predicates: ObligationForest::new(),\n+            register_region_obligations: false\n         }\n     }\n \n@@ -191,7 +212,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select: starting another iteration\");\n \n             // Process pending obligations.\n-            let outcome = self.predicates.process_obligations(&mut FulfillProcessor { selcx });\n+            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n+                selcx,\n+                register_region_obligations: self.register_region_obligations\n+            });\n             debug!(\"select: outcome={:?}\", outcome);\n \n             // FIXME: if we kept the original cache key, we could mark projection\n@@ -220,6 +244,7 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    register_region_obligations: bool\n }\n \n impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n@@ -230,7 +255,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                           obligation: &mut Self::Obligation)\n                           -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n     {\n-        process_predicate(self.selcx, obligation)\n+        process_predicate(self.selcx, obligation, self.register_region_obligations)\n             .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n                 obligation: o,\n                 stalled_on: vec![]\n@@ -269,7 +294,8 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n /// - `Err` if the predicate does not hold\n fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-    pending_obligation: &mut PendingPredicateObligation<'tcx>)\n+    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n+    register_region_obligations: bool)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n               FulfillmentErrorCode<'tcx>>\n {\n@@ -391,26 +417,30 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                         // `for<'a> T: 'a where 'a not in T`, which we can treat as `T: 'static`.\n                         Some(t_a) => {\n                             let r_static = selcx.tcx().types.re_static;\n-                            selcx.infcx().register_region_obligation(\n-                                obligation.cause.body_id,\n-                                RegionObligation {\n-                                    sup_type: t_a,\n-                                    sub_region: r_static,\n-                                    cause: obligation.cause.clone(),\n-                                });\n+                            if register_region_obligations {\n+                                selcx.infcx().register_region_obligation(\n+                                    obligation.cause.body_id,\n+                                    RegionObligation {\n+                                        sup_type: t_a,\n+                                        sub_region: r_static,\n+                                        cause: obligation.cause.clone(),\n+                                    });\n+                            }\n                             Ok(Some(vec![]))\n                         }\n                     }\n                 }\n                 // If there aren't, register the obligation.\n                 Some(ty::OutlivesPredicate(t_a, r_b)) => {\n-                    selcx.infcx().register_region_obligation(\n-                        obligation.cause.body_id,\n-                        RegionObligation {\n-                            sup_type: t_a,\n-                            sub_region: r_b,\n-                            cause: obligation.cause.clone()\n-                        });\n+                    if register_region_obligations {\n+                        selcx.infcx().register_region_obligation(\n+                            obligation.cause.body_id,\n+                            RegionObligation {\n+                                sup_type: t_a,\n+                                sub_region: r_b,\n+                                cause: obligation.cause.clone()\n+                            });\n+                    }\n                     Ok(Some(vec![]))\n                 }\n             }"}, {"sha": "a3a5c26ec186a6613da9bf69e565874d52710ae7", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=d6b010f98beae1591ea6e8e21008de97d6cf5be4", "patch": "@@ -431,7 +431,10 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         // this function's result remains infallible, we must confirm\n         // that guess. While imperfect, I believe this is sound.\n \n-        let mut fulfill_cx = FulfillmentContext::new();\n+        // The handling of regions in this area of the code is terrible,\n+        // see issue #29149. We should be able to improve on this with\n+        // NLL.\n+        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n \n         // We can use a dummy node-id here because we won't pay any mind\n         // to region obligations that arise (there shouldn't really be any\n@@ -511,8 +514,24 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            unnormalized_env.reveal);\n \n     tcx.infer_ctxt().enter(|infcx| {\n-        let predicates = match fully_normalize(\n+        // FIXME. We should really... do something with these region\n+        // obligations. But this call just continues the older\n+        // behavior (i.e., doesn't cause any new bugs), and it would\n+        // take some further refactoring to actually solve them. In\n+        // particular, we would have to handle implied bounds\n+        // properly, and that code is currently largely confined to\n+        // regionck (though I made some efforts to extract it\n+        // out). -nmatsakis\n+        //\n+        // @arielby: In any case, these obligations are checked\n+        // by wfcheck anyway, so I'm not sure we have to check\n+        // them here too, and we will remove this function when\n+        // we move over to lazy normalization *anyway*.\n+        let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+\n+        let predicates = match fully_normalize_with_fulfillcx(\n             &infcx,\n+            fulfill_cx,\n             cause,\n             elaborated_env,\n             // You would really want to pass infcx.param_env.caller_bounds here,\n@@ -537,16 +556,6 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let region_scope_tree = region::ScopeTree::default();\n         let free_regions = FreeRegionMap::new();\n \n-        // FIXME. We should really... do something with these region\n-        // obligations. But this call just continues the older\n-        // behavior (i.e., doesn't cause any new bugs), and it would\n-        // take some further refactoring to actually solve them. In\n-        // particular, we would have to handle implied bounds\n-        // properly, and that code is currently largely confined to\n-        // regionck (though I made some efforts to extract it\n-        // out). -nmatsakis\n-        let _ = infcx.ignore_region_obligations();\n-\n         infcx.resolve_regions_and_report_errors(region_context, &region_scope_tree, &free_regions);\n         let predicates = match infcx.fully_resolve(&predicates) {\n             Ok(predicates) => predicates,\n@@ -583,9 +592,6 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                           -> Result<T, Vec<FulfillmentError<'tcx>>>\n     where T : TypeFoldable<'tcx>\n {\n-    debug!(\"fully_normalize(value={:?})\", value);\n-\n-    let selcx = &mut SelectionContext::new(infcx);\n     // FIXME (@jroesch) ISSUE 26721\n     // I'm not sure if this is a bug or not, needs further investigation.\n     // It appears that by reusing the fulfillment_cx here we incur more\n@@ -599,8 +605,21 @@ pub fn fully_normalize<'a, 'gcx, 'tcx, T>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     //\n     // I think we should probably land this refactor and then come\n     // back to this is a follow-up patch.\n-    let mut fulfill_cx = FulfillmentContext::new();\n+    let fulfillcx = FulfillmentContext::new();\n+    fully_normalize_with_fulfillcx(infcx, fulfillcx, cause, param_env, value)\n+}\n \n+pub fn fully_normalize_with_fulfillcx<'a, 'gcx, 'tcx, T>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    mut fulfill_cx: FulfillmentContext<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    value: &T)\n+    -> Result<T, Vec<FulfillmentError<'tcx>>>\n+    where T : TypeFoldable<'tcx>\n+{\n+    debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n+    let selcx = &mut SelectionContext::new(infcx);\n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, param_env, cause, value);\n     debug!(\"fully_normalize: normalized_value={:?} obligations={:?}\","}, {"sha": "1b5b0d35ba3903c7a7782683cf390c9e145348f5", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d6b010f98beae1591ea6e8e21008de97d6cf5be4", "patch": "@@ -241,7 +241,18 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // (which are packed up in penv)\n \n     infcx.save_and_restore_in_snapshot_flag(|infcx| {\n-        let mut fulfill_cx = FulfillmentContext::new();\n+        // If we came from `translate_substs`, we already know that the\n+        // predicates for our impl hold (after all, we know that a more\n+        // specialized impl holds, so our impl must hold too), and\n+        // we only want to process the projections to determine the\n+        // the types in our substs using RFC 447, so we can safely\n+        // ignore region obligations, which allows us to avoid threading\n+        // a node-id to assign them with.\n+        //\n+        // If we came from specialization graph construction, then\n+        // we already make a mockery out of the region system, so\n+        // why not ignore them a bit earlier?\n+        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n         for oblig in obligations.into_iter() {\n             fulfill_cx.register_predicate_obligation(&infcx, oblig);\n         }"}, {"sha": "e1e2798ecb51c052d61d483b742d4a623ef6f4ae", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=d6b010f98beae1591ea6e8e21008de97d6cf5be4", "patch": "@@ -10,7 +10,7 @@\n \n use traits;\n use traits::project::Normalized;\n-use ty::{Lift, TyCtxt};\n+use ty::{self, Lift, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::fmt;\n@@ -28,9 +28,16 @@ impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n \n impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Obligation(predicate={:?},depth={})\",\n-               self.predicate,\n-               self.recursion_depth)\n+        if ty::tls::with(|tcx| tcx.sess.verbose()) {\n+            write!(f, \"Obligation(predicate={:?},cause={:?},depth={})\",\n+                   self.predicate,\n+                   self.cause,\n+                   self.recursion_depth)\n+        } else {\n+            write!(f, \"Obligation(predicate={:?},depth={})\",\n+                   self.predicate,\n+                   self.recursion_depth)\n+        }\n     }\n }\n "}, {"sha": "479680cc7fe79c40cc55a4ca17b5f9ff89eed54a", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=d6b010f98beae1591ea6e8e21008de97d6cf5be4", "patch": "@@ -152,10 +152,17 @@ impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n             // associated types and parameters). We need to normalize\n             // associated types here and possibly recursively process.\n             for ty in dtorck_types {\n-                // FIXME -- I think that this may disregard some region obligations\n-                // or something. Do we care? -nmatsakis\n                 let cause = ObligationCause::dummy();\n-                match traits::fully_normalize(self.infcx, cause, self.param_env, &ty) {\n+                // We know that our original `dropped_ty` is well-formed,\n+                // so region obligations resulting from this normalization\n+                // should always hold.\n+                //\n+                // Therefore we ignore them instead of trying to match\n+                // them up with a location.\n+                let fulfillcx = traits::FulfillmentContext::new_ignoring_regions();\n+                match traits::fully_normalize_with_fulfillcx(\n+                    self.infcx, fulfillcx, cause, self.param_env, &ty\n+                ) {\n                     Ok(ty) => match ty.sty {\n                         ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n                             self.add_regular_live_constraint(ty, location);"}, {"sha": "70db20e4a6c9244dbc4514ab20c80e443ca80a77", "filename": "src/test/run-pass/issue-46069.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Ftest%2Frun-pass%2Fissue-46069.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b010f98beae1591ea6e8e21008de97d6cf5be4/src%2Ftest%2Frun-pass%2Fissue-46069.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-46069.rs?ref=d6b010f98beae1591ea6e8e21008de97d6cf5be4", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::iter::{Fuse, Cloned};\n+use std::slice::Iter;\n+\n+struct Foo<'a, T: 'a>(&'a T);\n+impl<'a, T: 'a> Copy for Foo<'a, T> {}\n+impl<'a, T: 'a> Clone for Foo<'a, T> {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+fn copy_ex() {\n+    let s = 2;\n+    let k1 = || s;\n+    let upvar = Foo(&k1);\n+    let k = || upvar;\n+    k();\n+}\n+\n+fn main() {\n+    let _f = 0 as *mut <Fuse<Cloned<Iter<u8>>> as Iterator>::Item;\n+\n+    copy_ex();\n+}"}]}