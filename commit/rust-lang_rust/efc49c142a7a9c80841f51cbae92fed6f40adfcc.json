{"sha": "efc49c142a7a9c80841f51cbae92fed6f40adfcc", "node_id": "C_kwDOAAsO6NoAKGVmYzQ5YzE0MmE3YTljODA4NDFmNTFjYmFlOTJmZWQ2ZjQwYWRmY2M", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-15T07:36:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-15T07:36:20Z"}, "message": "Rollup merge of #91479 - scottmcm:slice-as-simd, r=workingjubilee\n\nAdd `[T]::as_simd(_mut)`\n\nSIMD-style optimizations are the most common use for `[T]::align_to(_mut)`, but that's `unsafe`.  So these are *safe* wrappers around it, now that we have the `Simd` type available, to make it easier to use.\n\n```rust\nimpl [T] {\n    pub fn as_simd<const LANES: usize>(&self) -> (&[T], &[Simd<T, LANES>], &[T]);\n    pub fn as_simd_mut<const LANES: usize>(&mut self) -> (&mut [T], &mut [Simd<T, LANES>], &mut [T]);\n}\n```\n\nThey're `cfg`'d out for miri because the `simd` module as a whole is unavailable there.", "tree": {"sha": "2261ea082257388f69f962608f0101cac03c02eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2261ea082257388f69f962608f0101cac03c02eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efc49c142a7a9c80841f51cbae92fed6f40adfcc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhuZr0CRBK7hj4Ov3rIwAA3jwIAHYaZSvQtl4b75oGw/QFe3wI\nj7Vs/vYZ8byj+ifW0oQ7wXSh87rfsvDacf8NkckpEvfI9XfJO5rAHESl6jI241dc\nhNfFiNP2vxArT0r9OdRSfcVbHTfyx8qDm+Gd4KXIZ7U2sO78mPXN96IxvWdIoRIB\nhiROKPSHIXNPCFjYc9k6/E6X224d3F1xf+VuP7oYrZIZy0nO5IH+VmwNNywys+oC\nkPXhPLbQVZrvypDkMusGmSf+nIwPw+RMSiidMrMJg9WwpPUbSPmHsqHOW8foknK/\npSTqeIUrBivlFP4YBx5sGWe0JeYmVPci42CVpt3tO853Ky42YhmjTBHXjgSu7Qk=\n=lG9Y\n-----END PGP SIGNATURE-----\n", "payload": "tree 2261ea082257388f69f962608f0101cac03c02eb\nparent d258e92900739e7798ed4fccfbbb8cb0fe519acd\nparent e4c44c5df707bb0b3de00d24e8b7735ab945362b\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1639553780 +0100\ncommitter GitHub <noreply@github.com> 1639553780 +0100\n\nRollup merge of #91479 - scottmcm:slice-as-simd, r=workingjubilee\n\nAdd `[T]::as_simd(_mut)`\n\nSIMD-style optimizations are the most common use for `[T]::align_to(_mut)`, but that's `unsafe`.  So these are *safe* wrappers around it, now that we have the `Simd` type available, to make it easier to use.\n\n```rust\nimpl [T] {\n    pub fn as_simd<const LANES: usize>(&self) -> (&[T], &[Simd<T, LANES>], &[T]);\n    pub fn as_simd_mut<const LANES: usize>(&mut self) -> (&mut [T], &mut [Simd<T, LANES>], &mut [T]);\n}\n```\n\nThey're `cfg`'d out for miri because the `simd` module as a whole is unavailable there.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efc49c142a7a9c80841f51cbae92fed6f40adfcc", "html_url": "https://github.com/rust-lang/rust/commit/efc49c142a7a9c80841f51cbae92fed6f40adfcc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efc49c142a7a9c80841f51cbae92fed6f40adfcc/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d258e92900739e7798ed4fccfbbb8cb0fe519acd", "url": "https://api.github.com/repos/rust-lang/rust/commits/d258e92900739e7798ed4fccfbbb8cb0fe519acd", "html_url": "https://github.com/rust-lang/rust/commit/d258e92900739e7798ed4fccfbbb8cb0fe519acd"}, {"sha": "e4c44c5df707bb0b3de00d24e8b7735ab945362b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c44c5df707bb0b3de00d24e8b7735ab945362b", "html_url": "https://github.com/rust-lang/rust/commit/e4c44c5df707bb0b3de00d24e8b7735ab945362b"}], "stats": {"total": 119, "additions": 119, "deletions": 0}, "files": [{"sha": "49dce89a494c862eda3347db08ac852ad779c41e", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/efc49c142a7a9c80841f51cbae92fed6f40adfcc/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efc49c142a7a9c80841f51cbae92fed6f40adfcc/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=efc49c142a7a9c80841f51cbae92fed6f40adfcc", "patch": "@@ -16,6 +16,8 @@ use crate::option::Option::{None, Some};\n use crate::ptr;\n use crate::result::Result;\n use crate::result::Result::{Err, Ok};\n+#[cfg(not(miri))] // Miri does not support all SIMD intrinsics\n+use crate::simd::{self, Simd};\n use crate::slice;\n \n #[unstable(\n@@ -3512,6 +3514,123 @@ impl<T> [T] {\n         }\n     }\n \n+    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n+    ///\n+    /// This is a safe wrapper around [`slice::align_to`], so has the same weak\n+    /// postconditions as that method.  You're only assured that\n+    /// `self.len() == prefix.len() + middle.len() * LANES + suffix.len()`.\n+    ///\n+    /// Notably, all of the following are possible:\n+    /// - `prefix.len() >= LANES`.\n+    /// - `middle.is_empty()` despite `self.len() >= 3 * LANES`.\n+    /// - `suffix.len() >= LANES`.\n+    ///\n+    /// That said, this is a safe method, so if you're only writing safe code,\n+    /// then this can at most cause incorrect logic, not unsoundness.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This will panic if the size of the SIMD type is different from\n+    /// `LANES` times that of the scalar.\n+    ///\n+    /// At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n+    /// that from ever happening, as only power-of-two numbers of lanes are\n+    /// supported.  It's possible that, in the future, those restrictions might\n+    /// be lifted in a way that would make it possible to see panics from this\n+    /// method for something like `LANES == 3`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(portable_simd)]\n+    ///\n+    /// let short = &[1, 2, 3];\n+    /// let (prefix, middle, suffix) = short.as_simd::<4>();\n+    /// assert_eq!(middle, []); // Not enough elements for anything in the middle\n+    ///\n+    /// // They might be split in any possible way between prefix and suffix\n+    /// let it = prefix.iter().chain(suffix).copied();\n+    /// assert_eq!(it.collect::<Vec<_>>(), vec![1, 2, 3]);\n+    ///\n+    /// fn basic_simd_sum(x: &[f32]) -> f32 {\n+    ///     use std::ops::Add;\n+    ///     use std::simd::f32x4;\n+    ///     let (prefix, middle, suffix) = x.as_simd();\n+    ///     let sums = f32x4::from_array([\n+    ///         prefix.iter().copied().sum(),\n+    ///         0.0,\n+    ///         0.0,\n+    ///         suffix.iter().copied().sum(),\n+    ///     ]);\n+    ///     let sums = middle.iter().copied().fold(sums, f32x4::add);\n+    ///     sums.horizontal_sum()\n+    /// }\n+    ///\n+    /// let numbers: Vec<f32> = (1..101).map(|x| x as _).collect();\n+    /// assert_eq!(basic_simd_sum(&numbers[1..99]), 4949.0);\n+    /// ```\n+    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+    #[cfg(not(miri))] // Miri does not support all SIMD intrinsics\n+    pub fn as_simd<const LANES: usize>(&self) -> (&[T], &[Simd<T, LANES>], &[T])\n+    where\n+        Simd<T, LANES>: AsRef<[T; LANES]>,\n+        T: simd::SimdElement,\n+        simd::LaneCount<LANES>: simd::SupportedLaneCount,\n+    {\n+        // These are expected to always match, as vector types are laid out like\n+        // arrays per <https://llvm.org/docs/LangRef.html#vector-type>, but we\n+        // might as well double-check since it'll optimize away anyhow.\n+        assert_eq!(mem::size_of::<Simd<T, LANES>>(), mem::size_of::<[T; LANES]>());\n+\n+        // SAFETY: The simd types have the same layout as arrays, just with\n+        // potentially-higher alignment, so the de-facto transmutes are sound.\n+        unsafe { self.align_to() }\n+    }\n+\n+    /// Split a slice into a prefix, a middle of aligned SIMD types, and a suffix.\n+    ///\n+    /// This is a safe wrapper around [`slice::align_to_mut`], so has the same weak\n+    /// postconditions as that method.  You're only assured that\n+    /// `self.len() == prefix.len() + middle.len() * LANES + suffix.len()`.\n+    ///\n+    /// Notably, all of the following are possible:\n+    /// - `prefix.len() >= LANES`.\n+    /// - `middle.is_empty()` despite `self.len() >= 3 * LANES`.\n+    /// - `suffix.len() >= LANES`.\n+    ///\n+    /// That said, this is a safe method, so if you're only writing safe code,\n+    /// then this can at most cause incorrect logic, not unsoundness.\n+    ///\n+    /// This is the mutable version of [`slice::as_simd`]; see that for examples.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This will panic if the size of the SIMD type is different from\n+    /// `LANES` times that of the scalar.\n+    ///\n+    /// At the time of writing, the trait restrictions on `Simd<T, LANES>` keeps\n+    /// that from ever happening, as only power-of-two numbers of lanes are\n+    /// supported.  It's possible that, in the future, those restrictions might\n+    /// be lifted in a way that would make it possible to see panics from this\n+    /// method for something like `LANES == 3`.\n+    #[unstable(feature = \"portable_simd\", issue = \"86656\")]\n+    #[cfg(not(miri))] // Miri does not support all SIMD intrinsics\n+    pub fn as_simd_mut<const LANES: usize>(&mut self) -> (&mut [T], &mut [Simd<T, LANES>], &mut [T])\n+    where\n+        Simd<T, LANES>: AsMut<[T; LANES]>,\n+        T: simd::SimdElement,\n+        simd::LaneCount<LANES>: simd::SupportedLaneCount,\n+    {\n+        // These are expected to always match, as vector types are laid out like\n+        // arrays per <https://llvm.org/docs/LangRef.html#vector-type>, but we\n+        // might as well double-check since it'll optimize away anyhow.\n+        assert_eq!(mem::size_of::<Simd<T, LANES>>(), mem::size_of::<[T; LANES]>());\n+\n+        // SAFETY: The simd types have the same layout as arrays, just with\n+        // potentially-higher alignment, so the de-facto transmutes are sound.\n+        unsafe { self.align_to_mut() }\n+    }\n+\n     /// Checks if the elements of this slice are sorted.\n     ///\n     /// That is, for each element `a` and its following element `b`, `a <= b` must hold. If the"}]}