{"sha": "1c82e60ca78da1f659db0c7dc82fe8c05566224f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjODJlNjBjYTc4ZGExZjY1OWRiMGM3ZGM4MmZlOGMwNTU2NjIyNGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-18T21:02:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-10-18T21:02:17Z"}, "message": "auto merge of #18113 : bkoropoff/rust/issue-16739, r=alexcrichton\n\nWhen translating the unboxing shim, account for the fact that the shim translation has already performed the necessary unboxing of input types and values when forwarding to the shimmed function.  This prevents ICEing or generating incorrect code.\r\n\r\nCloses #16739", "tree": {"sha": "ab17a876389f8f7b0f9d396e0ff3f33311df265a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab17a876389f8f7b0f9d396e0ff3f33311df265a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c82e60ca78da1f659db0c7dc82fe8c05566224f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c82e60ca78da1f659db0c7dc82fe8c05566224f", "html_url": "https://github.com/rust-lang/rust/commit/1c82e60ca78da1f659db0c7dc82fe8c05566224f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c82e60ca78da1f659db0c7dc82fe8c05566224f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce342f522c10eef8799f2b91b7f39947d40f93ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce342f522c10eef8799f2b91b7f39947d40f93ce", "html_url": "https://github.com/rust-lang/rust/commit/ce342f522c10eef8799f2b91b7f39947d40f93ce"}, {"sha": "f4cb9f466383d2c7b9e9c23c9a41e5310fede4a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4cb9f466383d2c7b9e9c23c9a41e5310fede4a6", "html_url": "https://github.com/rust-lang/rust/commit/f4cb9f466383d2c7b9e9c23c9a41e5310fede4a6"}], "stats": {"total": 78, "additions": 72, "deletions": 6}, "files": [{"sha": "3bfd03da2834e4997facf085ffcb05965b6d70a8", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1c82e60ca78da1f659db0c7dc82fe8c05566224f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c82e60ca78da1f659db0c7dc82fe8c05566224f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=1c82e60ca78da1f659db0c7dc82fe8c05566224f", "patch": "@@ -281,8 +281,32 @@ pub fn trans_unboxing_shim(bcx: Block,\n     };\n     let boxed_function_type =\n         ty::mk_bare_fn(tcx, boxed_function_type).subst(tcx, &substs);\n-    let function_type =\n-        ty::mk_bare_fn(tcx, (*fty).clone()).subst(tcx, &substs);\n+    let function_type = match fty.abi {\n+        synabi::RustCall => {\n+            // We're passing through to a RustCall ABI function, but\n+            // because the shim will already perform untupling, we\n+            // need to pretend the shimmed function does not use\n+            // RustCall so the untupled arguments can be passed\n+            // through verbatim.  This is kind of ugly.\n+            let fake_ty = ty::FnSig {\n+                binder_id: fty.sig.binder_id,\n+                inputs: type_of::untuple_arguments_if_necessary(ccx,\n+                                                                fty.sig.inputs.as_slice(),\n+                                                                fty.abi),\n+                output: fty.sig.output,\n+                variadic: false,\n+            };\n+            let fake_ty = ty::BareFnTy {\n+                fn_style: fty.fn_style,\n+                abi: synabi::Rust,\n+                sig: fake_ty,\n+            };\n+            ty::mk_bare_fn(tcx, fake_ty).subst(tcx, &substs)\n+        }\n+        _ => {\n+            ty::mk_bare_fn(tcx, (*fty).clone()).subst(tcx, &substs)\n+        }\n+    };\n \n     let function_name = ty::with_path(tcx, method_id, |path| {\n         link::mangle_internal_name_by_path_and_seq(path, \"unboxing_shim\")"}, {"sha": "989ac63cd5c264984319b2654d95e925f52b44b9", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c82e60ca78da1f659db0c7dc82fe8c05566224f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c82e60ca78da1f659db0c7dc82fe8c05566224f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=1c82e60ca78da1f659db0c7dc82fe8c05566224f", "patch": "@@ -58,10 +58,10 @@ pub fn type_of_explicit_arg(ccx: &CrateContext, arg_ty: ty::t) -> Type {\n /// Yields the types of the \"real\" arguments for this function. For most\n /// functions, these are simply the types of the arguments. For functions with\n /// the `RustCall` ABI, however, this untuples the arguments of the function.\n-fn untuple_arguments_if_necessary(ccx: &CrateContext,\n-                                  inputs: &[ty::t],\n-                                  abi: abi::Abi)\n-                                  -> Vec<ty::t> {\n+pub fn untuple_arguments_if_necessary(ccx: &CrateContext,\n+                                      inputs: &[ty::t],\n+                                      abi: abi::Abi)\n+                                      -> Vec<ty::t> {\n     if abi != abi::RustCall {\n         return inputs.iter().map(|x| (*x).clone()).collect()\n     }"}, {"sha": "80a7ae72e180f32654a7bf3b13edba52a74517b4", "filename": "src/test/run-pass/issue-16739.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1c82e60ca78da1f659db0c7dc82fe8c05566224f/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c82e60ca78da1f659db0c7dc82fe8c05566224f/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16739.rs?ref=1c82e60ca78da1f659db0c7dc82fe8c05566224f", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+// Test that unboxing shim for calling rust-call ABI methods through a\n+// trait box works and does not cause an ICE\n+\n+struct Foo { foo: uint }\n+\n+impl FnOnce<(), uint> for Foo {\n+    #[rust_call_abi_hack]\n+    fn call_once(self, _: ()) -> uint { self.foo }\n+}\n+\n+impl FnOnce<(uint,), uint> for Foo {\n+    #[rust_call_abi_hack]\n+    fn call_once(self, (x,): (uint,)) -> uint { self.foo + x }\n+}\n+\n+impl FnOnce<(uint, uint), uint> for Foo {\n+    #[rust_call_abi_hack]\n+    fn call_once(self, (x, y): (uint, uint)) -> uint { self.foo + x + y }\n+}\n+\n+fn main() {\n+    let f = box Foo { foo: 42 } as Box<FnOnce<(), uint>>;\n+    assert_eq!(f.call_once(()), 42);\n+\n+    let f = box Foo { foo: 40 } as Box<FnOnce<(uint,), uint>>;\n+    assert_eq!(f.call_once((2,)), 42);\n+\n+    let f = box Foo { foo: 40 } as Box<FnOnce<(uint, uint), uint>>;\n+    assert_eq!(f.call_once((1, 1)), 42);\n+}"}]}