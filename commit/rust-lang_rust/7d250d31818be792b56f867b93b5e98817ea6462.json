{"sha": "7d250d31818be792b56f867b93b5e98817ea6462", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkMjUwZDMxODE4YmU3OTJiNTZmODY3YjkzYjVlOTg4MTdlYTY0NjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-19T19:03:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-19T19:03:49Z"}, "message": "auto merge of #5824 : bleibig/rust/debuginfo, r=brson\n\nThis adds debugging symbol generation for boxes, bare functions, vectors, and strings, along with a tests for boxes and vectors.\r\n\r\nNote that gdb will see them as their actual compiled representation with the refcount, tydesc, etc. fields, so if `b` refers to box, `b->boxed` will refer to its value. Also, since you seem to use the [C struct hack](http://c-faq.com/struct/structhack.html) for dynamic vectors, you won't be able to print out the whole vector at once, only one element at a time by indexing specific elements.", "tree": {"sha": "4596cdfbd5450b85835d7fb9b1272f0019f03e9a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4596cdfbd5450b85835d7fb9b1272f0019f03e9a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d250d31818be792b56f867b93b5e98817ea6462", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d250d31818be792b56f867b93b5e98817ea6462", "html_url": "https://github.com/rust-lang/rust/commit/7d250d31818be792b56f867b93b5e98817ea6462", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d250d31818be792b56f867b93b5e98817ea6462/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10e6869a54b3d9e703ca6bc29f49f522ee25d865", "url": "https://api.github.com/repos/rust-lang/rust/commits/10e6869a54b3d9e703ca6bc29f49f522ee25d865", "html_url": "https://github.com/rust-lang/rust/commit/10e6869a54b3d9e703ca6bc29f49f522ee25d865"}, {"sha": "d2718e6324270831b36e14638d8522b702a3534a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2718e6324270831b36e14638d8522b702a3534a", "html_url": "https://github.com/rust-lang/rust/commit/d2718e6324270831b36e14638d8522b702a3534a"}], "stats": {"total": 267, "additions": 232, "deletions": 35}, "files": [{"sha": "a6e86a2612266caa868761f4b201797f51d047f0", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7d250d31818be792b56f867b93b5e98817ea6462/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d250d31818be792b56f867b93b5e98817ea6462/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=7d250d31818be792b56f867b93b5e98817ea6462", "patch": "@@ -129,6 +129,13 @@ impl get_insn_ctxt for fn_ctxt {\n     }\n }\n \n+fn fcx_has_nonzero_span(fcx: fn_ctxt) -> bool {\n+    match fcx.span {\n+        None => true,\n+        Some(span) => *span.lo != 0 || *span.hi != 0\n+    }\n+}\n+\n pub fn log_fn_time(ccx: @CrateContext, +name: ~str, start: time::Timespec,\n                    end: time::Timespec) {\n     let elapsed = 1000 * ((end.sec - start.sec) as int) +\n@@ -1150,7 +1157,8 @@ pub fn trans_stmt(cx: block, s: ast::stmt) -> block {\n                 ast::decl_local(ref locals) => {\n                     for locals.each |local| {\n                         bcx = init_local(bcx, *local);\n-                        if cx.sess().opts.extra_debuginfo {\n+                        if cx.sess().opts.extra_debuginfo\n+                            && fcx_has_nonzero_span(bcx.fcx) {\n                             debuginfo::create_local_var(bcx, *local);\n                         }\n                     }\n@@ -1730,7 +1738,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n \n         fcx.llargs.insert(arg_id, local_mem(llarg));\n \n-        if fcx.ccx.sess.opts.extra_debuginfo {\n+        if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n             debuginfo::create_arg(bcx, args[arg_n], args[arg_n].ty.span);\n         }\n     }\n@@ -1853,7 +1861,8 @@ pub fn trans_fn(ccx: @CrateContext,\n     trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n                   param_substs, id, impl_id,\n                   |fcx| {\n-                      if ccx.sess.opts.extra_debuginfo {\n+                      if ccx.sess.opts.extra_debuginfo\n+                          && fcx_has_nonzero_span(fcx) {\n                           debuginfo::create_function(fcx);\n                       }\n                   },"}, {"sha": "4f6057bc125087236286e1ab1bbd80eaab4c1973", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 156, "deletions": 32, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/7d250d31818be792b56f867b93b5e98817ea6462/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d250d31818be792b56f867b93b5e98817ea6462/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=7d250d31818be792b56f867b93b5e98817ea6462", "patch": "@@ -414,7 +414,8 @@ fn create_pointer_type(cx: @CrateContext, t: ty::t, span: span,\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     //let cu_node = create_compile_unit(cx, fname);\n-    let llnode = create_derived_type(tg, file_node.node, ~\"\", 0, size * 8,\n+    let name = ty_to_str(cx.tcx, t);\n+    let llnode = create_derived_type(tg, file_node.node, name, 0, size * 8,\n                                      align * 8, 0, pointee.node);\n     let mdval = @Metadata {\n         node: llnode,\n@@ -536,33 +537,48 @@ fn create_tuple(cx: @CrateContext, t: ty::t, elements: &[ty::t], span: span)\n     return mdval;\n }\n \n-fn create_boxed_type(cx: @CrateContext, outer: ty::t, _inner: ty::t,\n+// returns (void* type as a ValueRef, size in bytes, align in bytes)\n+fn voidptr() -> (ValueRef, int, int) {\n+    let null = ptr::null();\n+    let size = sys::size_of::<ValueRef>() as int;\n+    let align = sys::min_align_of::<ValueRef>() as int;\n+    let vp = create_derived_type(PointerTypeTag, null, ~\"\", 0,\n+                                 size, align, 0, null);\n+    return (vp, size, align);\n+}\n+\n+fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n                      span: span, boxed: @Metadata<TyDescMetadata>)\n     -> @Metadata<TyDescMetadata> {\n     //let tg = StructureTypeTag;\n     /*let cache = cx.llmetadata;\n     match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, {|md| ty::hash_ty(outer) == ty::hash_ty(md.data.hash)}) {\n+        cache, tg, {|md| ty::hash_ty(contents) == ty::hash_ty(md.data.hash)}) {\n       option::Some(md) { return md; }\n       option::None {}\n     }*/\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     //let cu_node = create_compile_unit_metadata(cx, fname);\n-    let uint_t = ty::mk_uint(cx.tcx);\n-    let refcount_type = create_basic_type(cx, uint_t, span);\n-    let scx = create_structure(file_node,\n-                               @/*bad*/ copy ty_to_str(cx.tcx, outer), 0);\n+    let int_t = ty::mk_int(cx.tcx);\n+    let refcount_type = create_basic_type(cx, int_t, span);\n+    let name = ty_to_str(cx.tcx, contents);\n+    let scx = create_structure(file_node, @fmt!(\"box<%s>\", name), 0);\n     add_member(scx, ~\"refcnt\", 0, sys::size_of::<uint>() as int,\n                sys::min_align_of::<uint>() as int, refcount_type.node);\n-    add_member(scx, ~\"boxed\", 0, 8, //XXX member_size_and_align(??)\n-               8, //XXX just a guess\n-               boxed.node);\n+    // the tydesc and other pointers should be irrelevant to the\n+    // debugger, so treat them as void* types\n+    let (vp, vpsize, vpalign) = voidptr();\n+    add_member(scx, ~\"tydesc\", 0, vpsize, vpalign, vp);\n+    add_member(scx, ~\"prev\", 0, vpsize, vpalign, vp);\n+    add_member(scx, ~\"next\", 0, vpsize, vpalign, vp);\n+    let (size, align) = size_and_align_of(cx, contents);\n+    add_member(scx, ~\"boxed\", 0, size, align, boxed.node);\n     let llnode = finish_structure(scx);\n     let mdval = @Metadata {\n         node: llnode,\n         data: TyDescMetadata {\n-            hash: ty::type_id(outer)\n+            hash: ty::type_id(contents)\n         }\n     };\n     //update_cache(cache, tg, tydesc_metadata(mdval));\n@@ -600,33 +616,117 @@ fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n     return llmdnode(lldata);\n }\n \n-fn create_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n-              vec_ty_span: codemap::span) -> @Metadata<TyDescMetadata> {\n+fn create_fixed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n+                    len: int, span: span) -> @Metadata<TyDescMetadata> {\n+    let t_md = create_ty(cx, elem_t, span);\n+    let fname = filename_from_span(cx, span);\n+    let file_node = create_file(cx, fname);\n+    let (size, align) = size_and_align_of(cx, elem_t);\n+    let subrange = llmdnode(~[lltag(SubrangeTag), lli64(0), lli64(len - 1)]);\n+    let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n+    let array = create_composite_type(ArrayTypeTag, name, file_node.node, 0,\n+                                      size * len, align, 0, Some(t_md.node),\n+                                      Some(~[subrange]));\n+    @Metadata {\n+        node: array,\n+        data: TyDescMetadata {\n+            hash: ty::type_id(vec_t)\n+        }\n+    }\n+}\n+\n+fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n+                    vec_ty_span: codemap::span)\n+    -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, vec_ty_span);\n     let file_node = create_file(cx, fname);\n     let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n-    let scx = create_structure(file_node,\n+    let vec_scx = create_structure(file_node,\n                                @/*bad*/ copy ty_to_str(cx.tcx, vec_t), 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(cx.tcx), vec_ty_span);\n-    add_member(scx, ~\"fill\", 0, sys::size_of::<libc::size_t>() as int,\n+    add_member(vec_scx, ~\"fill\", 0, sys::size_of::<libc::size_t>() as int,\n                sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n-    add_member(scx, ~\"alloc\", 0, sys::size_of::<libc::size_t>() as int,\n+    add_member(vec_scx, ~\"alloc\", 0, sys::size_of::<libc::size_t>() as int,\n                sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n     let subrange = llmdnode(~[lltag(SubrangeTag), lli64(0), lli64(0)]);\n     let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n-    let data_ptr = create_composite_type(ArrayTypeTag, ~\"\", file_node.node, 0,\n+    let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n+    let data_ptr = create_composite_type(ArrayTypeTag, name, file_node.node, 0,\n                                          arr_size, arr_align, 0,\n                                          Some(elem_ty_md.node),\n                                          Some(~[subrange]));\n-    add_member(scx, ~\"data\", 0, 0, // clang says the size should be 0\n+    add_member(vec_scx, ~\"data\", 0, 0, // clang says the size should be 0\n                sys::min_align_of::<u8>() as int, data_ptr);\n+    let llnode = finish_structure(vec_scx);\n+    let vec_md = @Metadata {\n+        node: llnode,\n+        data: TyDescMetadata {\n+            hash: ty::type_id(vec_t)\n+        }\n+    };\n+\n+    let box_scx = create_structure(file_node, @fmt!(\"box<%s>\", name), 0);\n+    let int_t = ty::mk_int(cx.tcx);\n+    let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n+    add_member(box_scx, ~\"refcnt\", 0, sys::size_of::<uint>() as int,\n+               sys::min_align_of::<uint>() as int, refcount_type.node);\n+    let (vp, vpsize, vpalign) = voidptr();\n+    add_member(box_scx, ~\"tydesc\", 0, vpsize, vpalign, vp);\n+    add_member(box_scx, ~\"prev\", 0, vpsize, vpalign, vp);\n+    add_member(box_scx, ~\"next\", 0, vpsize, vpalign, vp);\n+    let size = 2 * sys::size_of::<int>() as int;\n+    let align = sys::min_align_of::<int>() as int;\n+    add_member(box_scx, ~\"boxed\", 0, size, align, vec_md.node);\n+    let llnode = finish_structure(box_scx);\n+    let mdval = @Metadata {\n+        node: llnode,\n+        data: TyDescMetadata {\n+            hash: ty::type_id(elem_t)\n+        }\n+    };\n+    return mdval;\n+}\n+\n+fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n+    -> @Metadata<TyDescMetadata> {\n+    let fname = filename_from_span(cx, span);\n+    let file_node = create_file(cx, fname);\n+    let elem_ty_md = create_ty(cx, elem_t, span);\n+    let uint_type = create_basic_type(cx, ty::mk_uint(cx.tcx), span);\n+    let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n+    let scx = create_structure(file_node, @ty_to_str(cx.tcx, vec_t), 0);\n+    let (_, ptr_size, ptr_align) = voidptr();\n+    add_member(scx, ~\"vec\", 0, ptr_size, ptr_align, elem_ptr.node);\n+    add_member(scx, ~\"length\", 0, sys::size_of::<uint>() as int,\n+               sys::min_align_of::<uint>() as int, uint_type.node);\n     let llnode = finish_structure(scx);\n-    @Metadata {\n+    let mdval = @Metadata {\n         node: llnode,\n         data: TyDescMetadata {\n             hash: ty::type_id(vec_t)\n         }\n-    }\n+    };\n+    return mdval;\n+}\n+\n+fn create_fn_ty(cx: @CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n+                span: span) -> @Metadata<TyDescMetadata> {\n+    let fname = filename_from_span(cx, span);\n+    let file_node = create_file(cx, fname);\n+    let (vp, _, _) = voidptr();\n+    let output_md = create_ty(cx, output, span);\n+    let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n+    let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span).node };\n+    let members = ~[output_ptr_md.node, vp] + inputs_vals;\n+    let llnode = create_composite_type(SubroutineTag, ~\"\", file_node.node,\n+                                       0, 0, 0, 0, None, Some(members));\n+    let mdval = @Metadata {\n+        node: llnode,\n+        data: TyDescMetadata {\n+            hash: ty::type_id(fn_ty)\n+        }\n+    };\n+    return mdval;\n }\n \n fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n@@ -643,20 +743,42 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n     match sty {\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_)\n         | ty::ty_float(_) => create_basic_type(cx, t, span),\n-        ty::ty_estr(_vstore) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for estr NYI\")\n+        ty::ty_estr(ref vstore) => {\n+            let i8_t = ty::mk_i8(cx.tcx);\n+            match *vstore {\n+                ty::vstore_fixed(len) => {\n+                    create_fixed_vec(cx, t, i8_t, len as int + 1, span)\n+                },\n+                ty::vstore_uniq | ty::vstore_box => {\n+                    let box_md = create_boxed_vec(cx, t, i8_t, span);\n+                    create_pointer_type(cx, t, span, box_md)\n+                }\n+                ty::vstore_slice(_region) => {\n+                    create_vec_slice(cx, t, i8_t, span)\n+                }\n+            }\n         },\n         ty::ty_enum(_did, ref _substs) => {\n             cx.sess.span_bug(span, ~\"debuginfo for enum NYI\")\n         }\n-        ty::ty_box(ref _mt) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for box NYI\")\n+        ty::ty_box(ref mt) | ty::ty_uniq(ref mt) => {\n+            let boxed = create_ty(cx, mt.ty, span);\n+            let box_md = create_boxed_type(cx, mt.ty, span, boxed);\n+            create_pointer_type(cx, t, span, box_md)\n         },\n-        ty::ty_uniq(ref _mt) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for uniq NYI\")\n-        },\n-        ty::ty_evec(ref _mt, ref _vstore) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for evec NYI\")\n+        ty::ty_evec(ref mt, ref vstore) => {\n+            match *vstore {\n+                ty::vstore_fixed(len) => {\n+                    create_fixed_vec(cx, t, mt.ty, len as int, span)\n+                },\n+                ty::vstore_uniq | ty::vstore_box => {\n+                    let box_md = create_boxed_vec(cx, t, mt.ty, span);\n+                    create_pointer_type(cx, t, span, box_md)\n+                },\n+                ty::vstore_slice(_region) => {\n+                    create_vec_slice(cx, t, mt.ty, span)\n+                }\n+            }\n         },\n         ty::ty_ptr(ref mt) => {\n             let pointee = create_ty(cx, mt.ty, span);\n@@ -665,8 +787,10 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n         ty::ty_rptr(ref _region, ref _mt) => {\n             cx.sess.span_bug(span, ~\"debuginfo for rptr NYI\")\n         },\n-        ty::ty_bare_fn(ref _barefnty) => {\n-            cx.sess.span_bug(span, ~\"debuginfo for bare_fn NYI\")\n+        ty::ty_bare_fn(ref barefnty) => {\n+            let inputs = do barefnty.sig.inputs.map |a| { a.ty };\n+            let output = barefnty.sig.output;\n+            create_fn_ty(cx, t, inputs, output, span)\n         },\n         ty::ty_closure(ref _closurety) => {\n             cx.sess.span_bug(span, ~\"debuginfo for closure NYI\")\n@@ -812,7 +936,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n }\n \n pub fn update_source_pos(cx: block, s: span) {\n-    if !cx.sess().opts.debuginfo {\n+    if !cx.sess().opts.debuginfo || (*s.lo == 0 && *s.hi == 0) {\n         return;\n     }\n     let cm = cx.sess().codemap;"}, {"sha": "54aa0c12578b9b86866b067ea813176f4a4e3a9d", "filename": "src/test/debug-info/box.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7d250d31818be792b56f867b93b5e98817ea6462/src%2Ftest%2Fdebug-info%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d250d31818be792b56f867b93b5e98817ea6462/src%2Ftest%2Fdebug-info%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fbox.rs?ref=7d250d31818be792b56f867b93b5e98817ea6462", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-test\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break 29\n+// debugger:run\n+// debugger:print a->boxed\n+// check:$1 = 1\n+// debugger:print b->boxed\n+// check:$2 = {2, 3.5}\n+// debugger:print c->boxed\n+// check:$3 = 4\n+// debugger:print d->boxed\n+// check:$4 = false\n+\n+fn main() {\n+    let a = ~1;\n+    let b = ~(2, 3.5);\n+    let c = @4;\n+    let d = @false;\n+    let _z = 0;\n+}"}, {"sha": "3876f1c46d4873fc5bccb72b2230167678e7f77f", "filename": "src/test/debug-info/vec.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7d250d31818be792b56f867b93b5e98817ea6462/src%2Ftest%2Fdebug-info%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d250d31818be792b56f867b93b5e98817ea6462/src%2Ftest%2Fdebug-info%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvec.rs?ref=7d250d31818be792b56f867b93b5e98817ea6462", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-test\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:set print pretty off\n+// debugger:break 29\n+// debugger:run\n+// debugger:print a\n+// check:$1 = {1, 2, 3}\n+// debugger:print b.vec[0]\n+// check:$2 = 4\n+// debugger:print c->boxed.data[1]\n+// check:$3 = 8\n+// debugger:print d->boxed.data[2]\n+// check:$4 = 12\n+\n+fn main() {\n+    let a = [1, 2, 3];\n+    let b = &[4, 5, 6];\n+    let c = @[7, 8, 9];\n+    let d = ~[10, 11, 12];\n+    let _z = 0;\n+}"}]}