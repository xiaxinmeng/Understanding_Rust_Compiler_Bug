{"sha": "822c10feb7d594f324d0160bef47ed999769a789", "node_id": "C_kwDOAAsO6NoAKDgyMmMxMGZlYjdkNTk0ZjMyNGQwMTYwYmVmNDdlZDk5OTc2OWE3ODk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-20T23:53:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-20T23:53:09Z"}, "message": "Auto merge of #109046 - Zoxc:split-execute-job, r=cjgillot,michaelwoerister\n\nSplit `execute_job` into `execute_job_incr` and `execute_job_non_incr`\n\n`execute_job` was a bit large, so this splits it in 2. Performance was neutral locally, but this may affect bootstrap times.", "tree": {"sha": "4696e45fe58ebacdbe727c69ed895aa7a648a1d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4696e45fe58ebacdbe727c69ed895aa7a648a1d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/822c10feb7d594f324d0160bef47ed999769a789", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/822c10feb7d594f324d0160bef47ed999769a789", "html_url": "https://github.com/rust-lang/rust/commit/822c10feb7d594f324d0160bef47ed999769a789", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/822c10feb7d594f324d0160bef47ed999769a789/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44f5180584404d18058cbbf224c55255db4fdcbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/44f5180584404d18058cbbf224c55255db4fdcbb", "html_url": "https://github.com/rust-lang/rust/commit/44f5180584404d18058cbbf224c55255db4fdcbb"}, {"sha": "c4bcac628cd44e8585a7b45583ae702624d13d63", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4bcac628cd44e8585a7b45583ae702624d13d63", "html_url": "https://github.com/rust-lang/rust/commit/c4bcac628cd44e8585a7b45583ae702624d13d63"}], "stats": {"total": 72, "additions": 42, "deletions": 30}, "files": [{"sha": "3dbcc4d2e8aabc40d90e14dc8297f82157c23aef", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/822c10feb7d594f324d0160bef47ed999769a789/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/822c10feb7d594f324d0160bef47ed999769a789/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=822c10feb7d594f324d0160bef47ed999769a789", "patch": "@@ -969,6 +969,7 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     pub(crate) fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n+        debug_assert!(self.data.is_none());\n         let index = self.virtual_dep_node_index.fetch_add(1, Relaxed);\n         DepNodeIndex::from_u32(index)\n     }"}, {"sha": "ba2f859ff0f8e0f6800bc553444cce2bd61ea17f", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/822c10feb7d594f324d0160bef47ed999769a789/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/822c10feb7d594f324d0160bef47ed999769a789/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=822c10feb7d594f324d0160bef47ed999769a789", "patch": "@@ -379,7 +379,11 @@ where\n \n     match JobOwner::<'_, Q::Key, Qcx::DepKind>::try_start(&qcx, state, state_lock, span, key) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(query, qcx, key.clone(), dep_node, job.id);\n+            let (result, dep_node_index) = match qcx.dep_context().dep_graph().data() {\n+                None => execute_job_non_incr(query, qcx, key, job.id),\n+                Some(data) => execute_job_incr(query, qcx, data, key, dep_node, job.id),\n+            };\n+\n             let cache = query.query_cache(qcx);\n             if query.feedable() {\n                 // We should not compute queries that also got a value via feeding.\n@@ -413,48 +417,55 @@ where\n     }\n }\n \n+// Fast path for when incr. comp. is off.\n #[inline(always)]\n-fn execute_job<Q, Qcx>(\n+fn execute_job_non_incr<Q, Qcx>(\n     query: Q,\n     qcx: Qcx,\n     key: Q::Key,\n-    mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n     job_id: QueryJobId,\n ) -> (Q::Value, DepNodeIndex)\n where\n     Q: QueryConfig<Qcx>,\n     Qcx: QueryContext,\n {\n-    let dep_graph = qcx.dep_context().dep_graph();\n-    let dep_graph_data = match dep_graph.data() {\n-        // Fast path for when incr. comp. is off.\n-        None => {\n-            // Fingerprint the key, just to assert that it doesn't\n-            // have anything we don't consider hashable\n-            if cfg!(debug_assertions) {\n-                let _ = key.to_fingerprint(*qcx.dep_context());\n-            }\n+    debug_assert!(!qcx.dep_context().dep_graph().is_fully_enabled());\n \n-            let prof_timer = qcx.dep_context().profiler().query_provider();\n-            let result =\n-                qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n-            let dep_node_index = dep_graph.next_virtual_depnode_index();\n-            prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n-\n-            // Similarly, fingerprint the result to assert that\n-            // it doesn't have anything not considered hashable.\n-            if cfg!(debug_assertions) && let Some(hash_result) = query.hash_result()\n-            {\n-                qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n-                    hash_result(&mut hcx, &result);\n-                });\n-            }\n+    // Fingerprint the key, just to assert that it doesn't\n+    // have anything we don't consider hashable\n+    if cfg!(debug_assertions) {\n+        let _ = key.to_fingerprint(*qcx.dep_context());\n+    }\n \n-            return (result, dep_node_index);\n-        }\n-        Some(data) => data,\n-    };\n+    let prof_timer = qcx.dep_context().profiler().query_provider();\n+    let result = qcx.start_query(job_id, query.depth_limit(), None, || query.compute(qcx, key));\n+    let dep_node_index = qcx.dep_context().dep_graph().next_virtual_depnode_index();\n+    prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n+\n+    // Similarly, fingerprint the result to assert that\n+    // it doesn't have anything not considered hashable.\n+    if cfg!(debug_assertions) && let Some(hash_result) = query.hash_result() {\n+        qcx.dep_context().with_stable_hashing_context(|mut hcx| {\n+            hash_result(&mut hcx, &result);\n+        });\n+    }\n \n+    (result, dep_node_index)\n+}\n+\n+#[inline(always)]\n+fn execute_job_incr<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    dep_graph_data: &DepGraphData<Qcx::DepKind>,\n+    key: Q::Key,\n+    mut dep_node_opt: Option<DepNode<Qcx::DepKind>>,\n+    job_id: QueryJobId,\n+) -> (Q::Value, DepNodeIndex)\n+where\n+    Q: QueryConfig<Qcx>,\n+    Qcx: QueryContext,\n+{\n     if !query.anon() && !query.eval_always() {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node ="}]}