{"sha": "20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMDgzYzFlMWY2OTE2ZWI3OWUzZDk2N2MxYzlhYjYzMzQyYzcxYWU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-28T02:00:15Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-10-08T22:53:41Z"}, "message": "Move `for` loop desugaring to lowering", "tree": {"sha": "671e474800b5aacf481581cc46e700dcde46f808", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/671e474800b5aacf481581cc46e700dcde46f808"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "html_url": "https://github.com/rust-lang/rust/commit/20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56713a1684c22742a3a4d3d2b19fa09fa6832024", "url": "https://api.github.com/repos/rust-lang/rust/commits/56713a1684c22742a3a4d3d2b19fa09fa6832024", "html_url": "https://github.com/rust-lang/rust/commit/56713a1684c22742a3a4d3d2b19fa09fa6832024"}], "stats": {"total": 634, "additions": 420, "deletions": 214}, "files": [{"sha": "0213070d7860255abad43ec4e98272921876f3c9", "filename": "mk/crates.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -80,13 +80,13 @@ DEPS_rustc_typeck := rustc syntax rustc_front rustc_platform_intrinsics\n DEPS_rustc_borrowck := rustc rustc_front log graphviz syntax\n DEPS_rustc_resolve := rustc rustc_front log syntax\n DEPS_rustc_privacy := rustc rustc_front log syntax\n+DEPS_rustc_front := std syntax log serialize\n DEPS_rustc_lint := rustc log syntax\n-DEPS_rustc := syntax flate arena serialize getopts rbml \\\n+DEPS_rustc := syntax flate arena serialize getopts rbml rustc_front\\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_rustc_platform_intrinsics := rustc rustc_llvm\n DEPS_rustc_back := std syntax rustc_llvm rustc_front flate log libc\n-DEPS_rustc_front := std syntax log serialize\n DEPS_rustc_data_structures := std log serialize\n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts \\\n                 test rustc_lint rustc_front"}, {"sha": "985a517d8d97d99dcabdbec388358e4479d87a02", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -36,6 +36,7 @@ use middle::subst;\n use middle::ty::{self, Ty};\n \n use syntax::{ast, ast_util, codemap};\n+use syntax::ast::NodeIdAssigner;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n "}, {"sha": "830232cf373b8fe02115ac4f07e4efcf27eb7c24", "filename": "src/librustc/middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fcontext.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -219,7 +219,7 @@ pub struct ctxt<'tcx> {\n     /// Common types, pre-interned for your convenience.\n     pub types: CommonTypes<'tcx>,\n \n-    pub sess: Session,\n+    pub sess: &'tcx Session,\n     pub def_map: DefMap,\n \n     pub named_region_map: resolve_lifetime::NamedRegionMap,\n@@ -443,7 +443,7 @@ impl<'tcx> ctxt<'tcx> {\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid\n     /// reference to the context, to allow formatting values that need it.\n-    pub fn create_and_enter<F, R>(s: Session,\n+    pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                  arenas: &'tcx CtxtArenas<'tcx>,\n                                  def_map: DefMap,\n                                  named_region_map: resolve_lifetime::NamedRegionMap,\n@@ -452,7 +452,7 @@ impl<'tcx> ctxt<'tcx> {\n                                  region_maps: RegionMaps,\n                                  lang_items: middle::lang_items::LanguageItems,\n                                  stability: stability::Index<'tcx>,\n-                                 f: F) -> (Session, R)\n+                                 f: F) -> R\n                                  where F: FnOnce(&ctxt<'tcx>) -> R\n     {\n         let interner = RefCell::new(FnvHashMap());\n@@ -556,7 +556,6 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n \n pub mod tls {\n     use middle::ty;\n-    use session::Session;\n \n     use std::fmt;\n     use syntax::codemap;\n@@ -574,17 +573,15 @@ pub mod tls {\n         })\n     }\n \n-    pub fn enter<'tcx, F: FnOnce(&ty::ctxt<'tcx>) -> R, R>(tcx: ty::ctxt<'tcx>, f: F)\n-                                                           -> (Session, R) {\n-        let result = codemap::SPAN_DEBUG.with(|span_dbg| {\n+    pub fn enter<'tcx, F: FnOnce(&ty::ctxt<'tcx>) -> R, R>(tcx: ty::ctxt<'tcx>, f: F) -> R {\n+        codemap::SPAN_DEBUG.with(|span_dbg| {\n             let original_span_debug = span_dbg.get();\n             span_dbg.set(span_debug);\n             let tls_ptr = &tcx as *const _ as *const ThreadLocalTyCx;\n             let result = TLS_TCX.set(unsafe { &*tls_ptr }, || f(&tcx));\n             span_dbg.set(original_span_debug);\n             result\n-        });\n-        (tcx.sess, result)\n+        })\n     }\n \n     pub fn with<F: FnOnce(&ty::ctxt) -> R, R>(f: F) -> R {"}, {"sha": "1eb90580b480dd785aefa2c72d3e275d6c34ca4c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -15,7 +15,7 @@ use middle::dependency_format;\n use session::search_paths::PathKind;\n use util::nodemap::{NodeMap, FnvHashMap};\n \n-use syntax::ast::NodeId;\n+use syntax::ast::{NodeId, NodeIdAssigner};\n use syntax::codemap::Span;\n use syntax::diagnostic::{self, Emitter};\n use syntax::diagnostics;\n@@ -236,9 +236,6 @@ impl Session {\n         }\n         lints.insert(id, vec!((lint_id, sp, msg)));\n     }\n-    pub fn next_node_id(&self) -> ast::NodeId {\n-        self.reserve_node_ids(1)\n-    }\n     pub fn reserve_node_ids(&self, count: ast::NodeId) -> ast::NodeId {\n         let id = self.next_node_id.get();\n \n@@ -317,6 +314,12 @@ impl Session {\n     }\n }\n \n+impl NodeIdAssigner for Session {\n+    fn next_node_id(&self) -> NodeId {\n+        self.reserve_node_ids(1)\n+    }\n+}\n+\n fn split_msg_into_multilines(msg: &str) -> Option<String> {\n     // Conditions for enabling multi-line errors:\n     if !msg.contains(\"mismatched types\") &&"}, {"sha": "6f989811ed253639e0f53d2e754c06ed933bc2b0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -42,7 +42,7 @@ use std::ffi::{OsString, OsStr};\n use std::fs;\n use std::io::{self, Write};\n use std::path::{Path, PathBuf};\n-use syntax::ast;\n+use syntax::ast::{self, NodeIdAssigner};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::diagnostics;\n@@ -71,7 +71,7 @@ pub fn compile_input(sess: Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (sess, result) = {\n+    let result = {\n         let (outputs, expanded_crate, id) = {\n             let krate = phase_1_parse_input(&sess, cfg, input);\n \n@@ -113,7 +113,7 @@ pub fn compile_input(sess: Session,\n         let expanded_crate = assign_node_ids(&sess, expanded_crate);\n         // Lower ast -> hir.\n         let foo = &42;\n-        let lcx = LoweringContext::new(foo);\n+        let lcx = LoweringContext::new(foo, &sess, &expanded_crate);\n         let mut hir_forest = time(sess.time_passes(),\n                                   \"lowering ast -> hir\",\n                                   || hir_map::Forest::new(lower_crate(&lcx, &expanded_crate)));\n@@ -141,7 +141,7 @@ pub fn compile_input(sess: Session,\n             lint::check_ast_crate(&sess, &expanded_crate)\n         });\n \n-        phase_3_run_analysis_passes(sess,\n+        phase_3_run_analysis_passes(&sess,\n                                     ast_map,\n                                     &arenas,\n                                     id,\n@@ -282,7 +282,7 @@ pub struct CompileState<'a, 'ast: 'a, 'tcx: 'a> {\n     pub ast_map: Option<&'a hir_map::Map<'ast>>,\n     pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<&'a ty::ctxt<'tcx>>,\n-    pub lcx: Option<&'a LoweringContext<'tcx>>,\n+    pub lcx: Option<&'a LoweringContext<'a, 'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n@@ -340,7 +340,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                               krate: &'a ast::Crate,\n                               hir_crate: &'a hir::Crate,\n                               crate_name: &'a str,\n-                              lcx: &'a LoweringContext<'tcx>)\n+                              lcx: &'a LoweringContext<'a, 'tcx>)\n                               -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             crate_name: Some(crate_name),\n@@ -359,7 +359,7 @@ impl<'a, 'ast, 'tcx> CompileState<'a, 'ast, 'tcx> {\n                             hir_crate: &'a hir::Crate,\n                             analysis: &'a ty::CrateAnalysis,\n                             tcx: &'a ty::ctxt<'tcx>,\n-                            lcx: &'a LoweringContext<'tcx>)\n+                            lcx: &'a LoweringContext<'a, 'tcx>)\n                             -> CompileState<'a, 'ast, 'tcx> {\n         CompileState {\n             analysis: Some(analysis),\n@@ -659,21 +659,21 @@ pub fn make_map<'ast>(sess: &Session,\n /// Run the resolution, typechecking, region checking and other\n /// miscellaneous analysis passes on the crate. Return various\n /// structures carrying the results of the analysis.\n-pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n+pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                ast_map: front::map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: String,\n                                                make_glob_map: resolve::MakeGlobMap,\n                                                f: F)\n-                                               -> (Session, R)\n+                                               -> R\n                                                where F: for<'a> FnOnce(&'a ty::ctxt<'tcx>,\n                                                                        ty::CrateAnalysis) -> R\n {\n     let time_passes = sess.time_passes();\n     let krate = ast_map.krate();\n \n     time(time_passes, \"external crate/lib resolution\", ||\n-         LocalCrateReader::new(&sess, &ast_map).read_crates(krate));\n+         LocalCrateReader::new(sess, &ast_map).read_crates(krate));\n \n     let lang_items = time(time_passes, \"language item collection\", ||\n                           middle::lang_items::collect_language_items(&sess, &ast_map));\n@@ -687,32 +687,32 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: Session,\n         glob_map,\n     } =\n         time(time_passes, \"resolution\",\n-             || resolve::resolve_crate(&sess, &ast_map, make_glob_map));\n+             || resolve::resolve_crate(sess, &ast_map, make_glob_map));\n \n     // Discard MTWT tables that aren't required past resolution.\n     if !sess.opts.debugging_opts.keep_mtwt_tables {\n         syntax::ext::mtwt::clear_tables();\n     }\n \n     let named_region_map = time(time_passes, \"lifetime resolution\",\n-                                || middle::resolve_lifetime::krate(&sess, krate, &def_map));\n+                                || middle::resolve_lifetime::krate(sess, krate, &def_map));\n \n     time(time_passes, \"looking for entry point\",\n-         || middle::entry::find_entry_point(&sess, &ast_map));\n+         || middle::entry::find_entry_point(sess, &ast_map));\n \n     sess.plugin_registrar_fn.set(\n         time(time_passes, \"looking for plugin registrar\", ||\n             plugin::build::find_plugin_registrar(\n                 sess.diagnostic(), krate)));\n \n     let region_map = time(time_passes, \"region resolution\", ||\n-                          middle::region::resolve_crate(&sess, krate));\n+                          middle::region::resolve_crate(sess, krate));\n \n     time(time_passes, \"loop checking\", ||\n-         middle::check_loop::check_crate(&sess, krate));\n+         middle::check_loop::check_crate(sess, krate));\n \n     time(time_passes, \"static item recursion checking\", ||\n-         middle::check_static_recursion::check_crate(&sess, krate, &def_map, &ast_map));\n+         middle::check_static_recursion::check_crate(sess, krate, &def_map, &ast_map));\n \n     ty::ctxt::create_and_enter(sess,\n                                arenas,"}, {"sha": "09a1d6f685115a5bb6a76a0efe00bddb53825f64", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -131,7 +131,7 @@ pub fn parse_pretty(sess: &Session,\n impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n     fn call_with_pp_support<'tcx, A, B, F>(&self,\n-                                           sess: Session,\n+                                           sess: &'tcx Session,\n                                            ast_map: Option<hir_map::Map<'tcx>>,\n                                            payload: B,\n                                            f: F) -> A where\n@@ -155,7 +155,7 @@ impl PpSourceMode {\n         }\n     }\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n-                                               sess: Session,\n+                                               sess: &'tcx Session,\n                                                ast_map: &hir_map::Map<'tcx>,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: String,\n@@ -185,7 +185,7 @@ impl PpSourceMode {\n                                                     |tcx, _| {\n                     let annotation = TypedAnnotation { tcx: tcx };\n                     f(&annotation, payload, &ast_map.forest.krate)\n-                }).1\n+                })\n             }\n             _ => panic!(\"Should use call_with_pp_support\"),\n         }\n@@ -224,13 +224,13 @@ trait HirPrinterSupport<'ast>: pprust_hir::PpAnn {\n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn;\n }\n \n-struct NoAnn<'ast> {\n-    sess: Session,\n+struct NoAnn<'ast, 'tcx> {\n+    sess: &'tcx Session,\n     ast_map: Option<hir_map::Map<'ast>>\n }\n \n-impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+impl<'ast, 'tcx> PrinterSupport<'ast> for NoAnn<'ast, 'tcx> {\n+    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n@@ -239,8 +239,8 @@ impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n-impl<'ast> HirPrinterSupport<'ast> for NoAnn<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+impl<'ast, 'tcx> HirPrinterSupport<'ast> for NoAnn<'ast, 'tcx> {\n+    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n@@ -249,16 +249,16 @@ impl<'ast> HirPrinterSupport<'ast> for NoAnn<'ast> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn { self }\n }\n \n-impl<'ast> pprust::PpAnn for NoAnn<'ast> {}\n-impl<'ast> pprust_hir::PpAnn for NoAnn<'ast> {}\n+impl<'ast, 'tcx> pprust::PpAnn for NoAnn<'ast, 'tcx> {}\n+impl<'ast, 'tcx> pprust_hir::PpAnn for NoAnn<'ast, 'tcx> {}\n \n-struct IdentifiedAnnotation<'ast> {\n-    sess: Session,\n+struct IdentifiedAnnotation<'ast, 'tcx> {\n+    sess: &'tcx Session,\n     ast_map: Option<hir_map::Map<'ast>>,\n }\n \n-impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+impl<'ast, 'tcx> PrinterSupport<'ast> for IdentifiedAnnotation<'ast, 'tcx> {\n+    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n@@ -267,7 +267,7 @@ impl<'ast> PrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n-impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n+impl<'ast, 'tcx> pprust::PpAnn for IdentifiedAnnotation<'ast, 'tcx> {\n     fn pre(&self,\n            s: &mut pprust::State,\n            node: pprust::AnnNode) -> io::Result<()> {\n@@ -307,8 +307,8 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n     }\n }\n \n-impl<'ast> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+impl<'ast, 'tcx> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast, 'tcx> {\n+    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n@@ -317,7 +317,7 @@ impl<'ast> HirPrinterSupport<'ast> for IdentifiedAnnotation<'ast> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust_hir::PpAnn { self }\n }\n \n-impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n+impl<'ast, 'tcx> pprust_hir::PpAnn for IdentifiedAnnotation<'ast, 'tcx> {\n     fn pre(&self,\n            s: &mut pprust_hir::State,\n            node: pprust_hir::AnnNode) -> io::Result<()> {\n@@ -356,13 +356,13 @@ impl<'ast> pprust_hir::PpAnn for IdentifiedAnnotation<'ast> {\n     }\n }\n \n-struct HygieneAnnotation<'ast> {\n-    sess: Session,\n+struct HygieneAnnotation<'ast, 'tcx> {\n+    sess: &'tcx Session,\n     ast_map: Option<hir_map::Map<'ast>>,\n }\n \n-impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n-    fn sess<'a>(&'a self) -> &'a Session { &self.sess }\n+impl<'ast, 'tcx> PrinterSupport<'ast> for HygieneAnnotation<'ast, 'tcx> {\n+    fn sess<'a>(&'a self) -> &'a Session { self.sess }\n \n     fn ast_map<'a>(&'a self) -> Option<&'a hir_map::Map<'ast>> {\n         self.ast_map.as_ref()\n@@ -371,7 +371,7 @@ impl<'ast> PrinterSupport<'ast> for HygieneAnnotation<'ast> {\n     fn pp_ann<'a>(&'a self) -> &'a pprust::PpAnn { self }\n }\n \n-impl<'ast> pprust::PpAnn for HygieneAnnotation<'ast> {\n+impl<'ast, 'tcx> pprust::PpAnn for HygieneAnnotation<'ast, 'tcx> {\n     fn post(&self,\n             s: &mut pprust::State,\n             node: pprust::AnnNode) -> io::Result<()> {\n@@ -671,7 +671,7 @@ pub fn pretty_print_input(sess: Session,\n     // the ordering of stuff super-finicky.\n     let mut hir_forest;\n     let foo = &42;\n-    let lcx = LoweringContext::new(foo);\n+    let lcx = LoweringContext::new(foo, &sess, &krate);\n     let arenas = ty::CtxtArenas::new();\n     let ast_map = if compute_ast_map {\n         hir_forest = hir_map::Forest::new(lower_crate(&lcx, &krate));\n@@ -697,7 +697,7 @@ pub fn pretty_print_input(sess: Session,\n             // Silently ignores an identified node.\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support(\n-                sess, ast_map, box out, |annotation, out| {\n+                &sess, ast_map, box out, |annotation, out| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust::print_crate(sess.codemap(),\n@@ -714,7 +714,7 @@ pub fn pretty_print_input(sess: Session,\n         (PpmHir(s), None) => {\n             let out: &mut Write = &mut out;\n             s.call_with_pp_support_hir(\n-                sess, &ast_map.unwrap(), &arenas, id, box out, |annotation, out, krate| {\n+                &sess, &ast_map.unwrap(), &arenas, id, box out, |annotation, out, krate| {\n                     debug!(\"pretty printing source code {:?}\", s);\n                     let sess = annotation.sess();\n                     pprust_hir::print_crate(sess.codemap(),\n@@ -730,7 +730,7 @@ pub fn pretty_print_input(sess: Session,\n \n         (PpmHir(s), Some(uii)) => {\n             let out: &mut Write = &mut out;\n-            s.call_with_pp_support_hir(sess,\n+            s.call_with_pp_support_hir(&sess,\n                                        &ast_map.unwrap(),\n                                        &arenas,\n                                        id,\n@@ -778,14 +778,14 @@ pub fn pretty_print_input(sess: Session,\n             match code {\n                 Some(code) => {\n                     let variants = gather_flowgraph_variants(&sess);\n-                    driver::phase_3_run_analysis_passes(sess,\n+                    driver::phase_3_run_analysis_passes(&sess,\n                                                         ast_map,\n                                                         &arenas,\n                                                         id,\n                                                         resolve::MakeGlobMap::No,\n                                                         |tcx, _| {\n                         print_flowgraph(variants, tcx, code, mode, out)\n-                    }).1\n+                    })\n                 }\n                 None => {\n                     let message = format!(\"--pretty=flowgraph needs \\"}, {"sha": "c8f5f89b669109142e1f2f485e214475c727d7fa", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 344, "deletions": 54, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -14,20 +14,38 @@ use hir;\n \n use syntax::ast::*;\n use syntax::ptr::P;\n-use syntax::codemap::{respan, Spanned};\n+use syntax::codemap::{respan, Spanned, Span};\n use syntax::owned_slice::OwnedSlice;\n+use syntax::parse::token::{self, str_to_ident};\n+use syntax::std_inject;\n \n-pub struct LoweringContext<'hir> {\n+pub struct LoweringContext<'a, 'hir> {\n     // TODO\n     foo: &'hir i32,\n+    id_assigner: &'a NodeIdAssigner,\n+    crate_root: Option<&'static str>,\n }\n \n-impl<'hir> LoweringContext<'hir> {\n-    pub fn new(foo: &'hir i32) -> LoweringContext<'hir> {\n+impl<'a, 'hir> LoweringContext<'a, 'hir> {\n+    pub fn new(foo: &'hir i32, id_assigner: &'a NodeIdAssigner, c: &Crate) -> LoweringContext<'a, 'hir> {\n+        let crate_root = if std_inject::no_core(c) {\n+            None\n+        } else if std_inject::no_std(c) {\n+            Some(\"core\")\n+        } else {\n+            Some(\"std\")\n+        };\n+\n         LoweringContext {\n             foo: foo,\n+            id_assigner: id_assigner,\n+            crate_root: crate_root,\n         }\n     }\n+\n+    fn next_id(&self) -> NodeId {\n+        self.id_assigner.next_node_id()\n+    }\n }\n \n pub fn lower_view_path(_lctx: &LoweringContext, view_path: &ViewPath) -> P<hir::ViewPath> {\n@@ -727,105 +745,105 @@ pub fn lower_pat(_lctx: &LoweringContext, p: &Pat) -> P<hir::Pat> {\n     })\n }\n \n-pub fn lower_expr(_lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n+pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n     P(hir::Expr {\n             id: e.id,\n             node: match e.node {\n                 ExprBox(ref e) => {\n-                    hir::ExprBox(lower_expr(_lctx, e))\n+                    hir::ExprBox(lower_expr(lctx, e))\n                 }\n                 ExprVec(ref exprs) => {\n-                    hir::ExprVec(exprs.iter().map(|x| lower_expr(_lctx, x)).collect())\n+                    hir::ExprVec(exprs.iter().map(|x| lower_expr(lctx, x)).collect())\n                 }\n                 ExprRepeat(ref expr, ref count) => {\n-                    hir::ExprRepeat(lower_expr(_lctx, expr), lower_expr(_lctx, count))\n+                    hir::ExprRepeat(lower_expr(lctx, expr), lower_expr(lctx, count))\n                 }\n                 ExprTup(ref elts) => {\n-                    hir::ExprTup(elts.iter().map(|x| lower_expr(_lctx, x)).collect())\n+                    hir::ExprTup(elts.iter().map(|x| lower_expr(lctx, x)).collect())\n                 }\n                 ExprCall(ref f, ref args) => {\n-                    hir::ExprCall(lower_expr(_lctx, f),\n-                             args.iter().map(|x| lower_expr(_lctx, x)).collect())\n+                    hir::ExprCall(lower_expr(lctx, f),\n+                             args.iter().map(|x| lower_expr(lctx, x)).collect())\n                 }\n                 ExprMethodCall(i, ref tps, ref args) => {\n                     hir::ExprMethodCall(\n                         respan(i.span, i.node.name),\n-                        tps.iter().map(|x| lower_ty(_lctx, x)).collect(),\n-                        args.iter().map(|x| lower_expr(_lctx, x)).collect())\n+                        tps.iter().map(|x| lower_ty(lctx, x)).collect(),\n+                        args.iter().map(|x| lower_expr(lctx, x)).collect())\n                 }\n                 ExprBinary(binop, ref lhs, ref rhs) => {\n-                    hir::ExprBinary(lower_binop(_lctx, binop),\n-                            lower_expr(_lctx, lhs),\n-                            lower_expr(_lctx, rhs))\n+                    hir::ExprBinary(lower_binop(lctx, binop),\n+                            lower_expr(lctx, lhs),\n+                            lower_expr(lctx, rhs))\n                 }\n                 ExprUnary(op, ref ohs) => {\n-                    hir::ExprUnary(lower_unop(_lctx, op), lower_expr(_lctx, ohs))\n+                    hir::ExprUnary(lower_unop(lctx, op), lower_expr(lctx, ohs))\n                 }\n                 ExprLit(ref l) => hir::ExprLit(P((**l).clone())),\n                 ExprCast(ref expr, ref ty) => {\n-                    hir::ExprCast(lower_expr(_lctx, expr), lower_ty(_lctx, ty))\n+                    hir::ExprCast(lower_expr(lctx, expr), lower_ty(lctx, ty))\n                 }\n                 ExprAddrOf(m, ref ohs) => {\n-                    hir::ExprAddrOf(lower_mutability(_lctx, m), lower_expr(_lctx, ohs))\n+                    hir::ExprAddrOf(lower_mutability(lctx, m), lower_expr(lctx, ohs))\n                 }\n                 ExprIf(ref cond, ref tr, ref fl) => {\n-                    hir::ExprIf(lower_expr(_lctx, cond),\n-                           lower_block(_lctx, tr),\n-                           fl.as_ref().map(|x| lower_expr(_lctx, x)))\n+                    hir::ExprIf(lower_expr(lctx, cond),\n+                           lower_block(lctx, tr),\n+                           fl.as_ref().map(|x| lower_expr(lctx, x)))\n                 }\n                 ExprWhile(ref cond, ref body, opt_ident) => {\n-                    hir::ExprWhile(lower_expr(_lctx, cond),\n-                              lower_block(_lctx, body),\n+                    hir::ExprWhile(lower_expr(lctx, cond),\n+                              lower_block(lctx, body),\n                               opt_ident)\n                 }\n                 ExprLoop(ref body, opt_ident) => {\n-                    hir::ExprLoop(lower_block(_lctx, body),\n+                    hir::ExprLoop(lower_block(lctx, body),\n                             opt_ident)\n                 }\n                 ExprMatch(ref expr, ref arms, ref source) => {\n-                    hir::ExprMatch(lower_expr(_lctx, expr),\n-                            arms.iter().map(|x| lower_arm(_lctx, x)).collect(),\n-                            lower_match_source(_lctx, source))\n+                    hir::ExprMatch(lower_expr(lctx, expr),\n+                            arms.iter().map(|x| lower_arm(lctx, x)).collect(),\n+                            lower_match_source(lctx, source))\n                 }\n                 ExprClosure(capture_clause, ref decl, ref body) => {\n-                    hir::ExprClosure(lower_capture_clause(_lctx, capture_clause),\n-                                lower_fn_decl(_lctx, decl),\n-                                lower_block(_lctx, body))\n+                    hir::ExprClosure(lower_capture_clause(lctx, capture_clause),\n+                                lower_fn_decl(lctx, decl),\n+                                lower_block(lctx, body))\n                 }\n-                ExprBlock(ref blk) => hir::ExprBlock(lower_block(_lctx, blk)),\n+                ExprBlock(ref blk) => hir::ExprBlock(lower_block(lctx, blk)),\n                 ExprAssign(ref el, ref er) => {\n-                    hir::ExprAssign(lower_expr(_lctx, el), lower_expr(_lctx, er))\n+                    hir::ExprAssign(lower_expr(lctx, el), lower_expr(lctx, er))\n                 }\n                 ExprAssignOp(op, ref el, ref er) => {\n-                    hir::ExprAssignOp(lower_binop(_lctx, op),\n-                                lower_expr(_lctx, el),\n-                                lower_expr(_lctx, er))\n+                    hir::ExprAssignOp(lower_binop(lctx, op),\n+                                lower_expr(lctx, el),\n+                                lower_expr(lctx, er))\n                 }\n                 ExprField(ref el, ident) => {\n-                    hir::ExprField(lower_expr(_lctx, el), respan(ident.span, ident.node.name))\n+                    hir::ExprField(lower_expr(lctx, el), respan(ident.span, ident.node.name))\n                 }\n                 ExprTupField(ref el, ident) => {\n-                    hir::ExprTupField(lower_expr(_lctx, el), ident)\n+                    hir::ExprTupField(lower_expr(lctx, el), ident)\n                 }\n                 ExprIndex(ref el, ref er) => {\n-                    hir::ExprIndex(lower_expr(_lctx, el), lower_expr(_lctx, er))\n+                    hir::ExprIndex(lower_expr(lctx, el), lower_expr(lctx, er))\n                 }\n                 ExprRange(ref e1, ref e2) => {\n-                    hir::ExprRange(e1.as_ref().map(|x| lower_expr(_lctx, x)),\n-                              e2.as_ref().map(|x| lower_expr(_lctx, x)))\n+                    hir::ExprRange(e1.as_ref().map(|x| lower_expr(lctx, x)),\n+                              e2.as_ref().map(|x| lower_expr(lctx, x)))\n                 }\n                 ExprPath(ref qself, ref path) => {\n                     let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n                         hir::QSelf {\n-                            ty: lower_ty(_lctx, ty),\n+                            ty: lower_ty(lctx, ty),\n                             position: position\n                         }\n                     });\n-                    hir::ExprPath(qself, lower_path(_lctx, path))\n+                    hir::ExprPath(qself, lower_path(lctx, path))\n                 }\n                 ExprBreak(opt_ident) => hir::ExprBreak(opt_ident),\n                 ExprAgain(opt_ident) => hir::ExprAgain(opt_ident),\n-                ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(_lctx, x))),\n+                ExprRet(ref e) => hir::ExprRet(e.as_ref().map(|x| lower_expr(lctx, x))),\n                 ExprInlineAsm(InlineAsm {\n                     ref inputs,\n                     ref outputs,\n@@ -838,10 +856,10 @@ pub fn lower_expr(_lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     expn_id,\n                 }) => hir::ExprInlineAsm(hir::InlineAsm {\n                     inputs: inputs.iter().map(|&(ref c, ref input)| {\n-                        (c.clone(), lower_expr(_lctx, input))\n+                        (c.clone(), lower_expr(lctx, input))\n                     }).collect(),\n                     outputs: outputs.iter().map(|&(ref c, ref out, ref is_rw)| {\n-                        (c.clone(), lower_expr(_lctx, out), *is_rw)\n+                        (c.clone(), lower_expr(lctx, out), *is_rw)\n                     }).collect(),\n                     asm: asm.clone(),\n                     asm_str_style: asm_str_style,\n@@ -852,17 +870,124 @@ pub fn lower_expr(_lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                     expn_id: expn_id,\n                 }),\n                 ExprStruct(ref path, ref fields, ref maybe_expr) => {\n-                    hir::ExprStruct(lower_path(_lctx, path),\n-                            fields.iter().map(|x| lower_field(_lctx, x)).collect(),\n-                            maybe_expr.as_ref().map(|x| lower_expr(_lctx, x)))\n+                    hir::ExprStruct(lower_path(lctx, path),\n+                            fields.iter().map(|x| lower_field(lctx, x)).collect(),\n+                            maybe_expr.as_ref().map(|x| lower_expr(lctx, x)))\n                 },\n                 ExprParen(ref ex) => {\n-                    return lower_expr(_lctx, ex);\n+                    return lower_expr(lctx, ex);\n+                }\n+                ExprInPlace(..) => {\n+                    panic!(\"todo\");\n+                }\n+                ExprIfLet(..) => {\n+                    panic!(\"todo\");\n+                }\n+                ExprWhileLet(..) => {\n+                    panic!(\"todo\");\n+                }\n+\n+                // Desugar ExprForLoop\n+                // From: `[opt_ident]: for <pat> in <head> <body>`\n+                ExprForLoop(ref pat, ref head, ref body, ref opt_ident) => {\n+                    // to:\n+                    //\n+                    //   {\n+                    //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n+                    //       mut iter => {\n+                    //         [opt_ident]: loop {\n+                    //           match ::std::iter::Iterator::next(&mut iter) {\n+                    //             ::std::option::Option::Some(<pat>) => <body>,\n+                    //             ::std::option::Option::None => break\n+                    //           }\n+                    //         }\n+                    //       }\n+                    //     };\n+                    //     result\n+                    //   }\n+\n+                    // expand <head>\n+                    let head = lower_expr(lctx, head);\n+\n+                    let iter = token::gensym_ident(\"iter\");\n+\n+                    // `::std::option::Option::Some(<pat>) => <body>`\n+                    let pat_arm = {\n+                        let body_block = lower_block(lctx, body);\n+                        let body_span = body_block.span;\n+                        let body_expr = P(hir::Expr {\n+                            id: lctx.next_id(),\n+                            node: hir::ExprBlock(body_block),\n+                            span: body_span,\n+                        });\n+                        let pat = lower_pat(lctx, pat);\n+                        let some_pat = pat_some(lctx, e.span, pat);\n+\n+                        arm(vec![some_pat], body_expr)\n+                    };\n+\n+                    // `::std::option::Option::None => break`\n+                    let break_arm = {\n+                        let break_expr = expr_break(lctx, e.span);\n+\n+                        arm(vec![pat_none(lctx, e.span)], break_expr)\n+                    };\n+\n+                    // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+                    let match_expr = {\n+                        let next_path = {\n+                            let strs = std_path(lctx, &[\"iter\", \"Iterator\", \"next\"]);\n+\n+                            path_global(e.span, strs)\n+                        };\n+                        let ref_mut_iter = expr_mut_addr_of(lctx, e.span, expr_ident(lctx, e.span, iter));\n+                        let next_expr =\n+                            expr_call(lctx, e.span, expr_path(lctx, next_path), vec![ref_mut_iter]);\n+                        let arms = vec![pat_arm, break_arm];\n+\n+                        expr(lctx,\n+                             e.span,\n+                             hir::ExprMatch(next_expr, arms, hir::MatchSource::ForLoopDesugar))\n+                    };\n+\n+                    // `[opt_ident]: loop { ... }`\n+                    let loop_block = block_expr(lctx, match_expr);\n+                    let loop_expr = expr(lctx, e.span, hir::ExprLoop(loop_block, opt_ident.clone()));\n+\n+                    // `mut iter => { ... }`\n+                    let iter_arm = {\n+                        let iter_pat =\n+                            pat_ident_binding_mode(lctx, e.span, iter, hir::BindByValue(hir::MutMutable));\n+                        arm(vec![iter_pat], loop_expr)\n+                    };\n+\n+                    // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+                    let into_iter_expr = {\n+                        let into_iter_path = {\n+                            let strs = std_path(lctx, &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n+\n+                            path_global(e.span, strs)\n+                        };\n+\n+                        expr_call(lctx, e.span, expr_path(lctx, into_iter_path), vec![head])\n+                    };\n+\n+                    let match_expr = expr_match(lctx, e.span, into_iter_expr, vec![iter_arm]);\n+\n+                    // `{ let result = ...; result }`\n+                    let result_ident = token::gensym_ident(\"result\");\n+                    let result = expr_block(lctx,\n+                                            block_all(lctx,\n+                                                      e.span,\n+                                                      vec![stmt_let(lctx,\n+                                                                    e.span,\n+                                                                    false,\n+                                                                    result_ident,\n+                                                                    match_expr)],\n+                                                      Some(expr_ident(lctx, e.span, result_ident))));\n+                    return result;\n                 }\n-                ExprInPlace(..) |\n-                ExprIfLet(..) |\n-                ExprWhileLet(..) |\n-                ExprForLoop(..) |\n+\n                 ExprMac(_) => panic!(\"Shouldn't exist here\"),\n             },\n             span: e.span,\n@@ -972,3 +1097,168 @@ pub fn lower_trait_bound_modifier(_lctx: &LoweringContext,\n         TraitBoundModifier::Maybe => hir::TraitBoundModifier::Maybe,\n     }\n }\n+\n+// Helper methods for building HIR.\n+\n+fn arm(pats: Vec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+    hir::Arm {\n+        attrs: vec!(),\n+        pats: pats,\n+        guard: None,\n+        body: expr\n+    }\n+}\n+\n+fn expr_break(lctx: &LoweringContext, span: Span) -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprBreak(None))\n+}\n+\n+fn expr_call(lctx: &LoweringContext, span: Span, e: P<hir::Expr>, args: Vec<P<hir::Expr>>) -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprCall(e, args))\n+}\n+\n+fn expr_ident(lctx: &LoweringContext, span: Span, id: Ident) -> P<hir::Expr> {\n+    expr_path(lctx, path_ident(span, id))\n+}\n+\n+fn expr_mut_addr_of(lctx: &LoweringContext, span: Span, e: P<hir::Expr>) -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprAddrOf(hir::MutMutable, e))\n+}\n+\n+fn expr_path(lctx: &LoweringContext, path: hir::Path) -> P<hir::Expr> {\n+    expr(lctx, path.span, hir::ExprPath(None, path))\n+}\n+\n+fn expr_match(lctx: &LoweringContext, span: Span, arg: P<hir::Expr>, arms: Vec<hir::Arm>) -> P<hir::Expr> {\n+    expr(lctx, span, hir::ExprMatch(arg, arms, hir::MatchSource::Normal))\n+}\n+\n+fn expr_block(lctx: &LoweringContext, b: P<hir::Block>) -> P<hir::Expr> {\n+    expr(lctx, b.span, hir::ExprBlock(b))\n+}\n+\n+fn expr(lctx: &LoweringContext, span: Span, node: hir::Expr_) -> P<hir::Expr> {\n+    P(hir::Expr {\n+        id: lctx.next_id(),\n+        node: node,\n+        span: span,\n+    })\n+}\n+\n+fn stmt_let(lctx: &LoweringContext, sp: Span, mutbl: bool, ident: Ident, ex: P<hir::Expr>) -> P<hir::Stmt> {\n+    let pat = if mutbl {\n+        pat_ident_binding_mode(lctx, sp, ident, hir::BindByValue(hir::MutMutable))\n+    } else {\n+        pat_ident(lctx, sp, ident)\n+    };\n+    let local = P(hir::Local {\n+        pat: pat,\n+        ty: None,\n+        init: Some(ex),\n+        id: lctx.next_id(),\n+        span: sp,\n+    });\n+    let decl = respan(sp, hir::DeclLocal(local));\n+    P(respan(sp, hir::StmtDecl(P(decl), lctx.next_id())))\n+}\n+\n+fn block_expr(lctx: &LoweringContext, expr: P<hir::Expr>) -> P<hir::Block> {\n+    block_all(lctx, expr.span, Vec::new(), Some(expr))\n+}\n+\n+fn block_all(lctx: &LoweringContext,\n+             span: Span,\n+             stmts: Vec<P<hir::Stmt>>,\n+             expr: Option<P<hir::Expr>>) -> P<hir::Block> {\n+        P(hir::Block {\n+            stmts: stmts,\n+            expr: expr,\n+            id: lctx.next_id(),\n+            rules: hir::DefaultBlock,\n+            span: span,\n+        })\n+}\n+\n+fn pat_some(lctx: &LoweringContext, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n+    let some = std_path(lctx, &[\"option\", \"Option\", \"Some\"]);\n+    let path = path_global(span, some);\n+    pat_enum(lctx, span, path, vec!(pat))\n+}\n+\n+fn pat_none(lctx: &LoweringContext, span: Span) -> P<hir::Pat> {\n+    let none = std_path(lctx, &[\"option\", \"Option\", \"None\"]);\n+    let path = path_global(span, none);\n+    pat_enum(lctx, span, path, vec![])\n+}\n+\n+fn pat_enum(lctx: &LoweringContext, span: Span, path: hir::Path, subpats: Vec<P<hir::Pat>>) -> P<hir::Pat> {\n+    let pt = hir::PatEnum(path, Some(subpats));\n+    pat(lctx, span, pt)\n+}\n+\n+fn pat_ident(lctx: &LoweringContext, span: Span, ident: Ident) -> P<hir::Pat> {\n+    pat_ident_binding_mode(lctx, span, ident, hir::BindByValue(hir::MutImmutable))\n+}\n+\n+fn pat_ident_binding_mode(lctx: &LoweringContext,\n+                          span: Span,\n+                          ident: Ident,\n+                          bm: hir::BindingMode) -> P<hir::Pat> {\n+    let pat_ident = hir::PatIdent(bm, Spanned{span: span, node: ident}, None);\n+    pat(lctx, span, pat_ident)\n+}\n+\n+fn pat(lctx: &LoweringContext, span: Span, pat: hir::Pat_) -> P<hir::Pat> {\n+    P(hir::Pat { id: lctx.next_id(), node: pat, span: span })\n+}\n+\n+fn path_ident(span: Span, id: Ident) -> hir::Path {\n+    path(span, vec!(id))\n+}\n+\n+fn path(span: Span, strs: Vec<Ident> ) -> hir::Path {\n+    path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n+}\n+\n+fn path_global(span: Span, strs: Vec<Ident> ) -> hir::Path {\n+    path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n+}\n+\n+fn path_all(sp: Span,\n+            global: bool,\n+            mut idents: Vec<Ident> ,\n+            lifetimes: Vec<hir::Lifetime>,\n+            types: Vec<P<hir::Ty>>,\n+            bindings: Vec<P<hir::TypeBinding>> )\n+            -> hir::Path {\n+    let last_identifier = idents.pop().unwrap();\n+    let mut segments: Vec<hir::PathSegment> = idents.into_iter()\n+                                                    .map(|ident| {\n+        hir::PathSegment {\n+            identifier: ident,\n+            parameters: hir::PathParameters::none(),\n+        }\n+    }).collect();\n+    segments.push(hir::PathSegment {\n+        identifier: last_identifier,\n+        parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n+            lifetimes: lifetimes,\n+            types: OwnedSlice::from_vec(types),\n+            bindings: OwnedSlice::from_vec(bindings),\n+        })\n+    });\n+    hir::Path {\n+        span: sp,\n+        global: global,\n+        segments: segments,\n+    }\n+}\n+\n+fn std_path(lctx: &LoweringContext, components: &[&str]) -> Vec<Ident> {\n+    let mut v = Vec::new();\n+    if let Some(s) = lctx.crate_root {\n+        v.push(str_to_ident(s));\n+    }\n+    v.extend(components.iter().map(|s| str_to_ident(s)));\n+    return v\n+}"}, {"sha": "6a6d0b3bdca87c6f4bbac14a4f5bc51e8cb524b4", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -76,7 +76,7 @@ pub struct DumpCsvVisitor<'l, 'tcx: 'l> {\n \n impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     pub fn new(tcx: &'l ty::ctxt<'tcx>,\n-               lcx: &'l LoweringContext<'tcx>,\n+               lcx: &'l LoweringContext<'l, 'tcx>,\n                analysis: &'l ty::CrateAnalysis,\n                output_file: Box<File>)\n                -> DumpCsvVisitor<'l, 'tcx> {"}, {"sha": "5e26322ebda04ae9ce49708559e9ba408e6f680d", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -38,7 +38,7 @@ mod dump_csv;\n \n pub struct SaveContext<'l, 'tcx: 'l> {\n     tcx: &'l ty::ctxt<'tcx>,\n-    lcx: &'l lowering::LoweringContext<'tcx>,\n+    lcx: &'l lowering::LoweringContext<'l, 'tcx>,\n     span_utils: SpanUtils<'l>,\n }\n \n@@ -177,13 +177,15 @@ pub struct MethodCallData {\n \n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(tcx: &'l ty::ctxt<'tcx>, lcx: &'l lowering::LoweringContext<'tcx>) -> SaveContext<'l, 'tcx> {\n+    pub fn new(tcx: &'l ty::ctxt<'tcx>,\n+               lcx: &'l lowering::LoweringContext<'l, 'tcx>)\n+               -> SaveContext<'l, 'tcx> {\n         let span_utils = SpanUtils::new(&tcx.sess);\n         SaveContext::from_span_utils(tcx, lcx, span_utils)\n     }\n \n     pub fn from_span_utils(tcx: &'l ty::ctxt<'tcx>,\n-                           lcx: &'l lowering::LoweringContext<'tcx>,\n+                           lcx: &'l lowering::LoweringContext<'l, 'tcx>,\n                            span_utils: SpanUtils<'l>)\n                            -> SaveContext<'l, 'tcx> {\n         SaveContext {\n@@ -709,7 +711,7 @@ impl<'v> Visitor<'v> for PathCollector {\n }\n \n pub fn process_crate<'l, 'tcx>(tcx: &'l ty::ctxt<'tcx>,\n-                               lcx: &'l lowering::LoweringContext<'tcx>,\n+                               lcx: &'l lowering::LoweringContext<'l, 'tcx>,\n                                krate: &ast::Crate,\n                                analysis: &ty::CrateAnalysis,\n                                odir: Option<&Path>) {"}, {"sha": "5afcdbc8c131d7d2aac332896a23c658bc0217bb", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -38,6 +38,7 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::ast::NodeIdAssigner;\n use util::nodemap::{DefIdMap, FnvHashMap};\n use rustc::front::map as hir_map;\n use rustc::front::map::NodeItem;"}, {"sha": "bf43b87b26727d8430da227b78707e2ddb23ae85", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -375,6 +375,10 @@ pub const CRATE_NODE_ID: NodeId = 0;\n /// small, positive ids.\n pub const DUMMY_NODE_ID: NodeId = !0;\n \n+pub trait NodeIdAssigner {\n+    fn next_node_id(&self) -> NodeId;\n+}\n+\n /// The AST represents all type param bounds as types.\n /// typeck::collect::compute_bounds matches these against\n /// the \"special\" built-in traits (see middle::lang_items) and"}, {"sha": "8cfad6341de0ed51e3263b7148e8279a47b6dc6b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 94, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20083c1e1f6916eb79e3d967c1c9ab63342c71ae/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=20083c1e1f6916eb79e3d967c1c9ab63342c71ae", "patch": "@@ -360,102 +360,10 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n         }\n \n-        // Desugar ExprForLoop\n-        // From: `[opt_ident]: for <pat> in <head> <body>`\n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n-            // to:\n-            //\n-            //   {\n-            //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n-            //       mut iter => {\n-            //         [opt_ident]: loop {\n-            //           match ::std::iter::Iterator::next(&mut iter) {\n-            //             ::std::option::Option::Some(<pat>) => <body>,\n-            //             ::std::option::Option::None => break\n-            //           }\n-            //         }\n-            //       }\n-            //     };\n-            //     result\n-            //   }\n-\n-            push_compiler_expansion(fld, span, CompilerExpansionFormat::ForLoop);\n-\n-            let span = fld.new_span(span);\n-\n-            // expand <head>\n             let head = fld.fold_expr(head);\n-\n-            let iter = token::gensym_ident(\"iter\");\n-\n-            let pat_span = fld.new_span(pat.span);\n-            // `::std::option::Option::Some(<pat>) => <body>`\n-            let pat_arm = {\n-                let body_expr = fld.cx.expr_block(body);\n-                let pat = fld.fold_pat(pat);\n-                let some_pat = fld.cx.pat_some(pat_span, pat);\n-\n-                fld.cx.arm(pat_span, vec![some_pat], body_expr)\n-            };\n-\n-            // `::std::option::Option::None => break`\n-            let break_arm = {\n-                let break_expr = fld.cx.expr_break(span);\n-\n-                fld.cx.arm(span, vec![fld.cx.pat_none(span)], break_expr)\n-            };\n-\n-            // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n-            let match_expr = {\n-                let next_path = {\n-                    let strs = fld.cx.std_path(&[\"iter\", \"Iterator\", \"next\"]);\n-\n-                    fld.cx.path_global(span, strs)\n-                };\n-                let ref_mut_iter = fld.cx.expr_mut_addr_of(span, fld.cx.expr_ident(span, iter));\n-                let next_expr =\n-                    fld.cx.expr_call(span, fld.cx.expr_path(next_path), vec![ref_mut_iter]);\n-                let arms = vec![pat_arm, break_arm];\n-\n-                fld.cx.expr(pat_span,\n-                            ast::ExprMatch(next_expr, arms, ast::MatchSource::ForLoopDesugar))\n-            };\n-\n-            // `[opt_ident]: loop { ... }`\n-            let loop_block = fld.cx.block_expr(match_expr);\n-            let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            let loop_expr = fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident));\n-\n-            // `mut iter => { ... }`\n-            let iter_arm = {\n-                let iter_pat =\n-                    fld.cx.pat_ident_binding_mode(span, iter, ast::BindByValue(ast::MutMutable));\n-                fld.cx.arm(span, vec![iter_pat], loop_expr)\n-            };\n-\n-            // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n-            let into_iter_expr = {\n-                let into_iter_path = {\n-                    let strs = fld.cx.std_path(&[\"iter\", \"IntoIterator\",\n-                                                 \"into_iter\"]);\n-\n-                    fld.cx.path_global(span, strs)\n-                };\n-\n-                fld.cx.expr_call(span, fld.cx.expr_path(into_iter_path), vec![head])\n-            };\n-\n-            let match_expr = fld.cx.expr_match(span, into_iter_expr, vec![iter_arm]);\n-\n-            // `{ let result = ...; result }`\n-            let result_ident = token::gensym_ident(\"result\");\n-            let result = fld.cx.expr_block(\n-                fld.cx.block_all(\n-                    span,\n-                    vec![fld.cx.stmt_let(span, false, result_ident, match_expr)],\n-                    Some(fld.cx.expr_ident(span, result_ident))));\n-            fld.cx.bt_pop();\n-            result\n+            let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n+            fld.cx.expr(span, ast::ExprForLoop(pat, head, body, opt_ident))\n         }\n \n         ast::ExprClosure(capture_clause, fn_decl, block) => {"}]}