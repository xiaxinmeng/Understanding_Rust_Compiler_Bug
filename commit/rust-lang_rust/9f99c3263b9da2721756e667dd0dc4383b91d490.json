{"sha": "9f99c3263b9da2721756e667dd0dc4383b91d490", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmOTljMzI2M2I5ZGEyNzIxNzU2ZTY2N2RkMGRjNDM4M2I5MWQ0OTA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-24T09:13:25Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-25T07:15:17Z"}, "message": "Rewrite exhaustiveness checker\n\nIssue #2111", "tree": {"sha": "d5b69823c71cd05e8a30245bd902a59f376826bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d5b69823c71cd05e8a30245bd902a59f376826bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f99c3263b9da2721756e667dd0dc4383b91d490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f99c3263b9da2721756e667dd0dc4383b91d490", "html_url": "https://github.com/rust-lang/rust/commit/9f99c3263b9da2721756e667dd0dc4383b91d490", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f99c3263b9da2721756e667dd0dc4383b91d490/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9e3f387f49b4817c2b1fc7a152d64f77cba494e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e3f387f49b4817c2b1fc7a152d64f77cba494e", "html_url": "https://github.com/rust-lang/rust/commit/c9e3f387f49b4817c2b1fc7a152d64f77cba494e"}], "stats": {"total": 478, "additions": 257, "deletions": 221}, "files": [{"sha": "f3c7e08ef9f1ba8335d5877717bf941e79b01778", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -102,7 +102,6 @@ fn unop_to_str(op: unop) -> str {\n       deref { ret \"*\"; }\n       not { ret \"!\"; }\n       neg { ret \"-\"; }\n-      addr_of { ret \"&\"; }\n     }\n }\n "}, {"sha": "1ab340c9c0edb0d9a780e39ebf2cd679c9af0e70", "filename": "src/librustsyntax/ext/fmt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Flibrustsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Flibrustsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Ffmt.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -190,7 +190,6 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n           ty_octal { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n           ty_float { ret make_conv_call(cx, arg.span, \"float\", cnv, arg); }\n           ty_poly { ret make_conv_call(cx, arg.span, \"poly\", cnv, arg); }\n-          _ { cx.span_unimpl(sp, unsupported); }\n         }\n     }\n     fn log_conv(c: conv) {"}, {"sha": "07bb87d6a067624874f0fd2bf744cdfd30b0804a", "filename": "src/libstd/net.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -17,7 +17,6 @@ fn format_addr(ip: ip_addr) -> str {\n       ipv4(a, b, c, d) {\n         #fmt[\"%u.%u.%u.%u\", a as uint, b as uint, c as uint, d as uint]\n       }\n-      _ { fail \"Unsupported address type\"; }\n     }\n }\n "}, {"sha": "75c75c3217b7e94be2432616d117b8a62d85ec64", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -25,7 +25,7 @@ fn default_configuration(sess: session, argv0: str, input: str) ->\n       session::os_macos { \"libc.dylib\" }\n       session::os_linux { \"libc.so.6\" }\n       session::os_freebsd { \"libc.so.7\" }\n-      _ { \"libc.so\" }\n+      // _ { \"libc.so\" }\n     };\n \n     let mk = attr::mk_name_value_item_str;"}, {"sha": "802d47bf0c72c0b9c70253cbf0f06a157832f28c", "filename": "src/rustc/middle/check_alt.rs", "status": "modified", "additions": 235, "deletions": 203, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fcheck_alt.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -1,7 +1,7 @@\n-\n import syntax::ast::*;\n import syntax::ast_util::{variant_def_ids, dummy_sp, unguarded_pat};\n-import middle::const_eval::{compare_lit_exprs, lit_expr_eq};\n+import const_eval::{eval_const_expr, const_val, const_int,\n+                    compare_const_vals};\n import syntax::codemap::span;\n import syntax::print::pprust::pat_to_str;\n import pat_util::*;\n@@ -35,28 +35,20 @@ fn check_expr(tcx: ty::ctxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n     }\n }\n \n+// Check for unreachable patterns\n fn check_arms(tcx: ty::ctxt, arms: [arm]) {\n-    let mut i = 0;\n-    /* Check for unreachable patterns */\n+    let mut seen = [];\n     for arms.each {|arm|\n-        for arm.pats.each {|arm_pat|\n-            let mut reachable = true;\n-            let mut j = 0;\n-            while j < i {\n-                if option::is_none(arms[j].guard) {\n-                    for vec::each(arms[j].pats) {|prev_pat|\n-                        if pattern_supersedes(tcx, prev_pat, arm_pat) {\n-                            reachable = false;\n-                        }\n-                    }\n-                }\n-                j += 1;\n-            }\n-            if !reachable {\n-                tcx.sess.span_err(arm_pat.span, \"unreachable pattern\");\n+        for arm.pats.each {|pat|\n+            let v = [pat];\n+            alt is_useful(tcx, seen, v) {\n+              not_useful {\n+                tcx.sess.span_err(pat.span, \"unreachable pattern\");\n+              }\n+              _ {}\n             }\n+            if option::is_none(arm.guard) { seen += [v]; }\n         }\n-        i += 1;\n     }\n }\n \n@@ -68,229 +60,269 @@ fn raw_pat(p: @pat) -> @pat {\n }\n \n fn check_exhaustive(tcx: ty::ctxt, sp: span, pats: [@pat]) {\n-    if pats.len() == 0u {\n-        tcx.sess.span_err(sp, \"non-exhaustive patterns\");\n-        ret;\n-    }\n-    // If there a non-refutable pattern in the set, we're okay.\n-    for pats.each {|pat| if !is_refutable(tcx, pat) { ret; } }\n-\n-    alt ty::get(ty::node_id_to_type(tcx, pats[0].id)).struct {\n-      ty::ty_enum(id, _) {\n-        check_exhaustive_enum(tcx, id, sp, pats);\n-      }\n-      ty::ty_box(_) {\n-        check_exhaustive(tcx, sp, vec::filter_map(pats, {|p|\n-            alt raw_pat(p).node { pat_box(sub) { some(sub) } _ { none } }\n-        }));\n-      }\n-      ty::ty_uniq(_) {\n-        check_exhaustive(tcx, sp, vec::filter_map(pats, {|p|\n-            alt raw_pat(p).node { pat_uniq(sub) { some(sub) } _ { none } }\n-        }));\n-      }\n-      ty::ty_tup(ts) {\n-        let cols = vec::to_mut(vec::from_elem(ts.len(), []));\n-        for pats.each {|p|\n-            alt raw_pat(p).node {\n-              pat_tup(sub) {\n-                vec::iteri(sub) {|i, sp| cols[i] += [sp];}\n-              }\n-              _ {}\n-            }\n-        }\n-        vec::iter(cols) {|col| check_exhaustive(tcx, sp, col); }\n-      }\n-      ty::ty_rec(fs) {\n-        let cols = vec::from_elem(fs.len(), {mut wild: false,\n-                                            mut pats: []});\n-        for pats.each {|p|\n-            alt raw_pat(p).node {\n-              pat_rec(sub, _) {\n-                vec::iteri(fs) {|i, field|\n-                    alt vec::find(sub, {|pf| pf.ident == field.ident }) {\n-                      some(pf) { cols[i].pats += [pf.pat]; }\n-                      none { cols[i].wild = true; }\n-                    }\n-                }\n-              }\n-              _ {}\n+    let ext = alt is_useful(tcx, vec::map(pats, {|p| [p]}), [wild()]) {\n+      not_useful { ret; } // This is good, wildcard pattern isn't reachable\n+      useful_ { none }\n+      useful(ty, ctor) {\n+        alt ty::get(ty).struct {\n+          ty::ty_bool {\n+            alt check ctor {\n+              val(const_int(1i64)) { some(\"true\") }\n+              val(const_int(0i64)) { some(\"false\") }\n             }\n-        }\n-        vec::iter(cols) {|col|\n-            if !col.wild { check_exhaustive(tcx, sp, copy col.pats); }\n-        }\n-      }\n-      ty::ty_bool {\n-        let mut saw_true = false, saw_false = false;\n-        for pats.each {|p|\n-            alt raw_pat(p).node {\n-              pat_lit(@{node: expr_lit(@{node: lit_bool(b), _}), _}) {\n-                if b { saw_true = true; }\n-                else { saw_false = true; }\n-              }\n-              _ {}\n+          }\n+          ty::ty_enum(id, _) {\n+            let vid = alt check ctor { variant(id) { id } };\n+            alt check vec::find(*ty::enum_variants(tcx, id),\n+                                {|v| v.id == vid}) {\n+              some(v) { some(v.name) }\n             }\n+          }\n+          _ { none }\n         }\n-        if !saw_true { tcx.sess.span_err(\n-            sp, \"non-exhaustive bool patterns: true not covered\"); }\n-        if !saw_false { tcx.sess.span_err(\n-            sp, \"non-exhaustive bool patterns: false not covered\"); }\n-      }\n-      ty::ty_nil {\n-        let seen = vec::any(pats, {|p|\n-            alt raw_pat(p).node {\n-              pat_lit(@{node: expr_lit(@{node: lit_nil, _}), _}) { true }\n-              _ { false }\n-            }\n-        });\n-        if !seen { tcx.sess.span_err(sp, \"non-exhaustive patterns\"); }\n-      }\n-      // Literal patterns are always considered non-exhaustive\n-      _ {\n-        tcx.sess.span_err(sp, \"non-exhaustive literal patterns\");\n       }\n-    }\n+    };\n+    let msg = \"non-exhaustive patterns\" + alt ext {\n+      some(s) { \": \" + s + \" not covered\" }\n+      none { \"\" }\n+    };\n+    tcx.sess.span_err(sp, msg);\n+}\n+\n+type matrix = [[@pat]];\n+\n+enum useful { useful(ty::t, ctor), useful_, not_useful }\n+\n+enum ctor {\n+    single,\n+    variant(def_id),\n+    val(const_val),\n+    range(const_val, const_val),\n }\n \n-fn check_exhaustive_enum(tcx: ty::ctxt, enum_id: def_id, sp: span,\n-                         pats: [@pat]) {\n-    let variants = enum_variants(tcx, enum_id);\n-    let columns_by_variant = vec::map(*variants, {|v|\n-        {mut seen: false,\n-         cols: vec::to_mut(vec::from_elem(v.args.len(), []))}\n-    });\n+// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n+//\n+// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n+// vectors `m` is defined as there being a set of inputs that will match `v`\n+// but not any of the sets in `m`.\n+//\n+// This is used both for reachability checking (if a pattern isn't useful in\n+// relation to preceding patterns, it is not reachable) and exhaustiveness\n+// checking (if a wildcard pattern is useful in relation to a matrix, the\n+// matrix isn't exhaustive).\n \n-    for pats.each {|pat|\n-        let pat = raw_pat(pat);\n-        alt tcx.def_map.get(pat.id) {\n-          def_variant(_, id) {\n-            let variant_idx =\n-                option::get(vec::position(*variants, {|v| v.id == id}));\n-            let arg_len = variants[variant_idx].args.len();\n-            columns_by_variant[variant_idx].seen = true;\n-            alt pat.node {\n-              pat_enum(_, some(args)) {\n-                vec::iteri(args) {|i, p|\n-                    columns_by_variant[variant_idx].cols[i] += [p];\n+fn is_useful(tcx: ty::ctxt, m: matrix, v: [@pat]) -> useful {\n+    if m.len() == 0u { ret useful_; }\n+    if m[0].len() == 0u { ret not_useful; }\n+    let real_pat = alt vec::find(m, {|r| r[0].id != 0}) {\n+      some(r) { r[0] } none { v[0] }\n+    };\n+    let left_ty = if real_pat.id == 0 { ty::mk_nil(tcx) }\n+                  else { ty::node_id_to_type(tcx, real_pat.id) };\n+\n+    alt pat_ctor_id(tcx, v[0]) {\n+      none {\n+        if is_complete(tcx, m, left_ty) {\n+            alt ty::get(left_ty).struct {\n+              ty::ty_bool {\n+                alt is_useful_specialized(tcx, m, v, val(const_int(1i64)),\n+                                          0u, left_ty){\n+                  not_useful {\n+                    is_useful_specialized(tcx, m, v, val(const_int(0i64)),\n+                                          0u, left_ty)\n+                  }\n+                  u { u }\n                 }\n               }\n-              pat_enum(_, none) {\n-                  /* (*) pattern -- we fill in n '_' patterns, if the variant\n-                   has n args */\n-                let wild_pat = @{id: tcx.sess.next_node_id(),\n-                                   node: pat_wild, span: pat.span};\n-                uint::range(0u, arg_len) {|i|\n-                    columns_by_variant[variant_idx].cols[i] += [wild_pat]};\n+              ty::ty_enum(eid, _) {\n+                for (*ty::enum_variants(tcx, eid)).each {|va|\n+                    alt is_useful_specialized(tcx, m, v, variant(va.id),\n+                                              va.args.len(), left_ty) {\n+                      not_useful {}\n+                      u { ret u; }\n+                    }\n+                }\n+                not_useful\n+              }\n+              _ {\n+                let arity = ctor_arity(tcx, single, left_ty);\n+                is_useful_specialized(tcx, m, v, single, arity, left_ty)\n               }\n-              _ {}\n             }\n-          }\n-          _ {}\n-        }\n-    }\n-\n-    vec::iteri(columns_by_variant) {|i, cv|\n-        if !cv.seen {\n-            tcx.sess.span_err(sp, \"non-exhaustive patterns: variant `\" +\n-                              variants[i].name + \"` not covered\");\n         } else {\n-            vec::iter(cv.cols) {|col| check_exhaustive(tcx, sp, col); }\n+            is_useful(tcx, vec::filter_map(m, {|r| default(tcx, r)}),\n+                      vec::tail(v))\n         }\n+      }\n+      some(v0_ctor) {\n+        let arity = ctor_arity(tcx, v0_ctor, left_ty);\n+        is_useful_specialized(tcx, m, v, v0_ctor, arity, left_ty)\n+      }\n     }\n }\n \n-fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n-    fn patterns_supersede(tcx: ty::ctxt, as: [@pat], bs: [@pat]) -> bool {\n-        let mut i = 0;\n-        for as.each {|a|\n-            if !pattern_supersedes(tcx, a, bs[i]) { ret false; }\n-            i += 1;\n-        }\n-        ret true;\n+fn is_useful_specialized(tcx: ty::ctxt, m: matrix, v: [@pat], ctor: ctor,\n+                          arity: uint, lty: ty::t) -> useful {\n+    let ms = vec::filter_map(m, {|r| specialize(tcx, r, ctor, arity, lty)});\n+    alt is_useful(tcx, ms, option::get(specialize(tcx, v, ctor, arity, lty))){\n+      useful_ { useful(lty, ctor) }\n+      u { u }\n     }\n-    fn field_patterns_supersede(tcx: ty::ctxt, fas: [field_pat],\n-                                fbs: [field_pat]) -> bool {\n-        let wild = @{id: 0, node: pat_wild, span: dummy_sp()};\n-        for fas.each {|fa|\n-            let mut pb = wild;\n-            for fbs.each {|fb|\n-                if fa.ident == fb.ident { pb = fb.pat; }\n-            }\n-            if !pattern_supersedes(tcx, fa.pat, pb) { ret false; }\n+}\n+\n+fn pat_ctor_id(tcx: ty::ctxt, p: @pat) -> option<ctor> {\n+    let pat = raw_pat(p);\n+    alt pat.node {\n+      pat_wild { none }\n+      pat_ident(_, _) | pat_enum(_, _) {\n+        alt tcx.def_map.find(pat.id) {\n+          some(def_variant(_, id)) { some(variant(id)) }\n+          _ { none }\n         }\n-        ret true;\n+      }\n+      pat_lit(expr) { some(val(eval_const_expr(tcx, expr))) }\n+      pat_range(lo, hi) {\n+        some(range(eval_const_expr(tcx, lo), eval_const_expr(tcx, hi)))\n+      }\n+      pat_box(_) | pat_uniq(_) | pat_rec(_, _) | pat_tup(_) { some(single) }\n     }\n+}\n \n-    alt a.node {\n-      pat_ident(_, some(p)) { pattern_supersedes(tcx, p, b) }\n+fn is_wild(tcx: ty::ctxt, p: @pat) -> bool {\n+    let pat = raw_pat(p);\n+    alt pat.node {\n       pat_wild { true }\n-      pat_ident(_, none) {\n-        let opt_def_a = tcx.def_map.find(a.id);\n-        alt opt_def_a {\n-          some(def_variant(_, _)) { opt_def_a == tcx.def_map.find(b.id) }\n-          // This is a binding\n+      pat_ident(_, _) {\n+        alt tcx.def_map.find(pat.id) {\n+          some(def_variant(_, _)) { false }\n           _ { true }\n         }\n       }\n-      pat_enum(va, suba) {\n-        alt b.node {\n-          pat_enum(vb, some(subb)) {\n-            tcx.def_map.get(a.id) == tcx.def_map.get(b.id) &&\n-                alt suba { none { true }\n-                           some(subaa) {\n-                               patterns_supersede(tcx, subaa, subb)\n-                           }}\n-          }\n-          _ { false }\n-        }\n-      }\n-      pat_rec(suba, _) {\n-        alt b.node {\n-          pat_rec(subb, _) { field_patterns_supersede(tcx, suba, subb) }\n-          _ { false }\n+      _ { false }\n+    }\n+}\n+\n+fn is_complete(tcx: ty::ctxt, m: matrix, left_ty: ty::t) -> bool {\n+    alt ty::get(left_ty).struct {\n+      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_tup(_) | ty::ty_rec(_) {\n+        for m.each {|r|\n+            if !is_wild(tcx, r[0]) { ret true; }\n         }\n+        ret false;\n       }\n-      pat_tup(suba) {\n-        alt b.node {\n-          pat_tup(subb) { patterns_supersede(tcx, suba, subb) }\n-          _ { false }\n+      ty::ty_enum(eid, _) {\n+        let mut found = [];\n+        for m.each {|r|\n+            option::iter(pat_ctor_id(tcx, r[0])) {|id|\n+                if !vec::contains(found, id) { found += [id]; }\n+            }\n         }\n+        found.len() == (*ty::enum_variants(tcx, eid)).len()\n       }\n-      pat_box(suba) {\n-        alt b.node {\n-          pat_box(subb) { pattern_supersedes(tcx, suba, subb) }\n-          _ { pattern_supersedes(tcx, suba, b) }\n+      ty::ty_nil { true }\n+      ty::ty_bool {\n+        let mut true_found = false, false_found = false;\n+        for m.each {|r|\n+            alt check pat_ctor_id(tcx, r[0]) {\n+              none {}\n+              some(val(const_int(1i64))) { true_found = true; }\n+              some(val(const_int(0i64))) { false_found = true; }\n+            }\n         }\n+        true_found && false_found\n       }\n-      pat_uniq(suba) {\n-        alt b.node {\n-          pat_uniq(subb) { pattern_supersedes(tcx, suba, subb) }\n-          _ { pattern_supersedes(tcx, suba, b) }\n+      _ { false }\n+    }\n+}\n+\n+fn ctor_arity(tcx: ty::ctxt, ctor: ctor, ty: ty::t) -> uint {\n+    alt ty::get(ty).struct {\n+      ty::ty_tup(fs) { fs.len() }\n+      ty::ty_rec(fs) { fs.len() }\n+      ty::ty_box(_) | ty::ty_uniq(_) { 1u }\n+      ty::ty_enum(eid, _) {\n+        let id = alt check ctor { variant(id) { id } };\n+        alt check vec::find(*ty::enum_variants(tcx, eid), {|v| v.id == id}) {\n+          some(v) { v.args.len() }\n         }\n       }\n-      pat_lit(la) {\n-        alt b.node {\n-          pat_lit(lb) { lit_expr_eq(tcx, la, lb) }\n-          _ { false }\n+      _ { 0u }\n+    }\n+}\n+\n+fn wild() -> @pat {\n+    @{id: 0, node: pat_wild, span: syntax::ast_util::dummy_sp()}\n+}\n+\n+fn specialize(tcx: ty::ctxt, r: [@pat], ctor_id: ctor, arity: uint,\n+              left_ty: ty::t) -> option<[@pat]> {\n+    let r0 = raw_pat(r[0]);\n+    alt r0.node {\n+      pat_wild { some(vec::from_elem(arity, wild()) + vec::tail(r)) }\n+      pat_ident(_, _) {\n+        alt tcx.def_map.find(r0.id) {\n+          some(def_variant(_, id)) {\n+            if variant(id) == ctor_id { some(vec::tail(r)) }\n+            else { none }\n+          }\n+          _ { some(vec::from_elem(arity, wild()) + vec::tail(r)) }\n         }\n       }\n-      pat_range(begina, enda) {\n-        alt b.node {\n-          pat_lit(lb) {\n-            compare_lit_exprs(tcx, begina, lb) <= 0 &&\n-            compare_lit_exprs(tcx, enda, lb) >= 0\n-          }\n-          pat_range(beginb, endb) {\n-            compare_lit_exprs(tcx, begina, beginb) <= 0 &&\n-            compare_lit_exprs(tcx, enda, endb) >= 0\n+      pat_enum(_, args) {\n+        alt check tcx.def_map.get(r0.id) {\n+          def_variant(_, id) if variant(id) == ctor_id {\n+            let args = alt args {\n+              some(args) { args }\n+              none { vec::from_elem(arity, wild()) }\n+            };\n+            some(args + vec::tail(r))\n           }\n-          _ { false }\n+          def_variant(_, _) { none }\n         }\n       }\n+      pat_rec(flds, _) {\n+        let ty_flds = alt check ty::get(left_ty).struct {\n+          ty::ty_rec(flds) { flds }\n+        };\n+        let args = vec::map(ty_flds, {|ty_f|\n+            alt vec::find(flds, {|f| f.ident == ty_f.ident}) {\n+              some(f) { f.pat } _ { wild() }\n+            }\n+        });\n+        some(args + vec::tail(r))\n+      }\n+      pat_tup(args) { some(args + vec::tail(r)) }\n+      pat_box(a) | pat_uniq(a) { some([a] + vec::tail(r)) }\n+      pat_lit(expr) {\n+        let e_v = eval_const_expr(tcx, expr);\n+        let match = alt check ctor_id {\n+          val(v) { compare_const_vals(e_v, v) == 0 }\n+          range(c_lo, c_hi) { compare_const_vals(c_lo, e_v) >= 0 &&\n+                              compare_const_vals(c_hi, e_v) <= 0 }\n+          single { true }\n+        };\n+        if match { some(vec::tail(r)) } else { none }\n+      }\n+      pat_range(lo, hi) {\n+        let (c_lo, c_hi) = alt check ctor_id {\n+          val(v) { (v, v) }\n+          range(lo, hi) { (lo, hi) }\n+          single { ret some(vec::tail(r)); }\n+        };\n+        let v_lo = eval_const_expr(tcx, lo),\n+            v_hi = eval_const_expr(tcx, hi);\n+        let match = compare_const_vals(c_lo, v_lo) >= 0 &&\n+                    compare_const_vals(c_hi, v_hi) <= 0;\n+        if match { some(vec::tail(r)) } else { none }\n+      }\n     }\n }\n \n+fn default(tcx: ty::ctxt, r: [@pat]) -> option<[@pat]> {\n+    if is_wild(tcx, r[0]) { some(vec::tail(r)) }\n+    else { none }\n+}\n+\n fn check_local(tcx: ty::ctxt, loc: @local, &&s: (), v: visit::vt<()>) {\n     visit::visit_local(loc, s, v);\n     if is_refutable(tcx, loc.node.pat) {"}, {"sha": "77bfedafd93a53f7c510892cf577ffc1603b8968", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -245,7 +245,6 @@ fn check_item_ctypes(cx: ctxt, level: level, it: @ast::item) {\n               ast::native_item_fn(decl, tps) {\n                 check_native_fn(cx, level, decl);\n               }\n-              _ { }\n             }\n         }\n       }"}, {"sha": "1d6d506dbc10b1f21ba9835393aa6060860bdaf4", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -1656,7 +1656,7 @@ fn ns_for_def(d: def) -> namespace {\n       ast::def_variant(_, _) { ns_val }\n       ast::def_fn(_, _) | ast::def_self(_) |\n       ast::def_const(_) | ast::def_arg(_, _) | ast::def_local(_, _) |\n-      ast::def_upvar(_, _, _) |  ast::def_self(_) { ns_val }\n+      ast::def_upvar(_, _, _) { ns_val }\n       ast::def_mod(_) | ast::def_native_mod(_) { ns_module }\n       ast::def_ty(_) | ast::def_binding(_) | ast::def_use(_) |\n       ast::def_ty_param(_, _) | ast::def_prim_ty(_) | ast::def_class(_)"}, {"sha": "63f05806582e5dee79a1fc4add16c6d81246d952", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -3694,7 +3694,6 @@ fn trans_stmt(cx: block, s: ast::stmt) -> block {\n           ast::decl_item(i) { trans_item(cx.fcx.ccx, *i); }\n         }\n       }\n-      _ { cx.sess().unimpl(\"stmt variant\"); }\n     }\n \n     ret bcx;"}, {"sha": "791c1aa6924b83c4472f89f1218ca8418209900a", "filename": "src/rustc/middle/tstate/annotate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fannotate.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -18,7 +18,6 @@ fn collect_ids_stmt(s: @stmt, rs: @mut [node_id]) {\n         log_stmt(*s);\n         *rs += [id];\n       }\n-      _ { }\n     }\n }\n "}, {"sha": "efad557fbe77824270233c3ef1259398552d02d1", "filename": "src/rustc/middle/tstate/states.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fstates.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -709,7 +709,6 @@ fn find_pre_post_state_stmt(fcx: fn_ctxt, pres: prestate, s: @stmt) -> bool {\n \n         ret changed;\n       }\n-      _ { ret false; }\n     }\n }\n "}, {"sha": "b04e787d6607143cb039e2b8c487f7648243a47b", "filename": "src/test/compile-fail/alt-range-fail-dominate.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Falt-range-fail-dominate.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -5,27 +5,27 @@\n //error-pattern: unreachable\n \n fn main() {\n-    alt 5u {\n+    alt check 5u {\n       1u to 10u { }\n       5u to 6u { }\n     };\n \n-    alt 5u {\n+    alt check 5u {\n       3u to 6u { }\n       4u to 6u { }\n     };\n \n-    alt 5u {\n+    alt check 5u {\n       4u to 6u { }\n       4u to 6u { }\n     };\n \n-    alt 'c' {\n+    alt check 'c' {\n       'A' to 'z' {}\n       'a' to 'z' {}\n     };\n \n-    alt 1.0 {\n+    alt check 1.0 {\n       0.01 to 6.5 {}\n       0.02 {}\n     };"}, {"sha": "83012972ccaf4e84fabc002dcb23551241a8b098", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -3,13 +3,23 @@ enum t { a, b, }\n fn main() {\n     let x = a;\n     alt x { b { } } //! ERROR non-exhaustive patterns\n-    alt true { //! ERROR non-exhaustive bool patterns\n+    alt true { //! ERROR non-exhaustive patterns\n       true {}\n     }\n     alt @some(10) { //! ERROR non-exhaustive patterns\n       @none {}\n     }\n-    alt (2, 3, 4) { //! ERROR non-exhaustive literal patterns\n+    alt (2, 3, 4) { //! ERROR non-exhaustive patterns\n       (_, _, 4) {}\n     }\n+    alt (a, a) { //! ERROR non-exhaustive patterns\n+      (a, b) {}\n+      (b, a) {}\n+    }\n+    // This is exhaustive, though the algorithm got it wrong at one point\n+    alt (a, b) {\n+      (a, _) {}\n+      (_, a) {}\n+      (b, b) {}\n+    }\n }"}, {"sha": "a3426e3a9213b03ecba83d9a9a638f7f3802b30d", "filename": "src/test/run-fail/alt-wildcards.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Ftest%2Frun-fail%2Falt-wildcards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Ftest%2Frun-fail%2Falt-wildcards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Falt-wildcards.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -1,6 +1,6 @@\n // error-pattern:squirrelcupcake\n fn cmp() -> int {\n-    alt(option::some('a'), option::none::<char>) {\n+    alt check (option::some('a'), option::none::<char>) {\n         (option::some(_), _) { fail \"squirrelcupcake\"; }\n         (_, option::some(_)) { fail; }\n     }"}, {"sha": "f3ebc1f8a4f5e6728d069e5f2ed541900f06d20b", "filename": "src/test/run-pass/nested-exhaustive-alt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Ftest%2Frun-pass%2Fnested-exhaustive-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Ftest%2Frun-pass%2Fnested-exhaustive-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-exhaustive-alt.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -2,5 +2,7 @@ fn main() {\n     alt @{foo: true, bar: some(10), baz: 20} {\n       @{foo: true, bar: some(_), _} {}\n       @{foo: false, bar: none, _} {}\n+      @{foo: true, bar: none, _} {}\n+      @{foo: false, bar: some(_), _} {}\n     }\n }"}, {"sha": "c33b167128a6dead8b24774f57d596f23c91a000", "filename": "src/test/run-pass/tag-variant-disr-val.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f99c3263b9da2721756e667dd0dc4383b91d490/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag-variant-disr-val.rs?ref=9f99c3263b9da2721756e667dd0dc4383b91d490", "patch": "@@ -38,7 +38,6 @@ fn get_color_alt(color: color) -> str {\n       imaginary {\"imaginary\"}\n       purple {\"purple\"}\n       orange {\"orange\"}\n-      _ {\"unknown\"}\n     }\n }\n "}]}