{"sha": "4bf0685cca167e684340152809be20a16ad65a76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZjA2ODVjY2ExNjdlNjg0MzQwMTUyODA5YmUyMGExNmFkNjVhNzY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-10-19T20:01:36Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-11-11T22:06:54Z"}, "message": "Evaluate borrow and struct expressions in `into`\n\nThis fixes some ordering problems around assignment expressions.", "tree": {"sha": "a4ed0cd9d962d0bb7d693a05b298d4adc54227be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4ed0cd9d962d0bb7d693a05b298d4adc54227be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4bf0685cca167e684340152809be20a16ad65a76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4bf0685cca167e684340152809be20a16ad65a76", "html_url": "https://github.com/rust-lang/rust/commit/4bf0685cca167e684340152809be20a16ad65a76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4bf0685cca167e684340152809be20a16ad65a76/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "732081829263fd02b6995ff815d4c001cce460cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/732081829263fd02b6995ff815d4c001cce460cf", "html_url": "https://github.com/rust-lang/rust/commit/732081829263fd02b6995ff815d4c001cce460cf"}], "stats": {"total": 280, "additions": 184, "deletions": 96}, "files": [{"sha": "f9b77a4b5dd2adcc52320aa57841ed895d013084", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 10, "deletions": 85, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4bf0685cca167e684340152809be20a16ad65a76/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf0685cca167e684340152809be20a16ad65a76/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=4bf0685cca167e684340152809be20a16ad65a76", "patch": "@@ -1,6 +1,5 @@\n //! See docs in `build/expr/mod.rs`.\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_index::vec::Idx;\n \n use crate::build::expr::category::{Category, RvalueFunc};\n@@ -9,11 +8,16 @@ use crate::hair::*;\n use rustc::middle::region;\n use rustc::mir::interpret::PanicInfo;\n use rustc::mir::*;\n-use rustc::ty::{self, CanonicalUserTypeAnnotation, Ty, UpvarSubsts};\n+use rustc::ty::{self, Ty, UpvarSubsts};\n use syntax_pos::Span;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n-    /// See comment on `as_local_operand`\n+    /// Returns an rvalue suitable for use until the end of the current\n+    /// scope expression.\n+    ///\n+    /// The operand returned from this function will *not be valid* after\n+    /// an ExprKind::Scope is passed, so please do *not* return it from\n+    /// functions to avoid bad miscompiles.\n     pub fn as_local_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n     where\n         M: Mirror<'tcx, Output = Expr<'tcx>>,\n@@ -23,7 +27,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(\n+    fn as_rvalue<M>(\n         &mut self,\n         block: BasicBlock,\n         scope: Option<region::Scope>,\n@@ -66,16 +70,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let value_operand = unpack!(block = this.as_operand(block, scope, value));\n                 block.and(Rvalue::Repeat(value_operand, count))\n             }\n-            ExprKind::Borrow {\n-                borrow_kind,\n-                arg,\n-            } => {\n-                let arg_place = match borrow_kind {\n-                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, arg)),\n-                    _ => unpack!(block = this.as_place(block, arg)),\n-                };\n-                block.and(Rvalue::Ref(this.hir.tcx().lifetimes.re_erased, borrow_kind, arg_place))\n-            }\n             ExprKind::Binary { op, lhs, rhs } => {\n                 let lhs = unpack!(block = this.as_operand(block, scope, lhs));\n                 let rhs = unpack!(block = this.as_operand(block, scope, rhs));\n@@ -256,77 +250,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 };\n                 block.and(Rvalue::Aggregate(result, operands))\n             }\n-            ExprKind::Adt {\n-                adt_def,\n-                variant_index,\n-                substs,\n-                user_ty,\n-                fields,\n-                base,\n-            } => {\n-                // see (*) above\n-                let is_union = adt_def.is_union();\n-                let active_field_index = if is_union {\n-                    Some(fields[0].name.index())\n-                } else {\n-                    None\n-                };\n-\n-                // first process the set of fields that were provided\n-                // (evaluating them in order given by user)\n-                let fields_map: FxHashMap<_, _> = fields\n-                    .into_iter()\n-                    .map(|f| {\n-                        (\n-                            f.name,\n-                            unpack!(block = this.as_operand(block, scope, f.expr)),\n-                        )\n-                    }).collect();\n-\n-                let field_names = this.hir.all_fields(adt_def, variant_index);\n-\n-                let fields = if let Some(FruInfo { base, field_types }) = base {\n-                    let base = unpack!(block = this.as_place(block, base));\n-\n-                    // MIR does not natively support FRU, so for each\n-                    // base-supplied field, generate an operand that\n-                    // reads it from the base.\n-                    field_names\n-                        .into_iter()\n-                        .zip(field_types.into_iter())\n-                        .map(|(n, ty)| match fields_map.get(&n) {\n-                            Some(v) => v.clone(),\n-                            None => this.consume_by_copy_or_move(this.hir.tcx().mk_place_field(\n-                                base.clone(),\n-                                n,\n-                                ty,\n-                            )),\n-                        })\n-                        .collect()\n-                } else {\n-                    field_names\n-                        .iter()\n-                        .filter_map(|n| fields_map.get(n).cloned())\n-                        .collect()\n-                };\n-\n-                let inferred_ty = expr.ty;\n-                let user_ty = user_ty.map(|ty| {\n-                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n-                        span: source_info.span,\n-                        user_ty: ty,\n-                        inferred_ty,\n-                    })\n-                });\n-                let adt = box AggregateKind::Adt(\n-                    adt_def,\n-                    variant_index,\n-                    substs,\n-                    user_ty,\n-                    active_field_index,\n-                );\n-                block.and(Rvalue::Aggregate(adt, fields))\n-            }\n             ExprKind::Assign { .. } | ExprKind::AssignOp { .. } => {\n                 block = unpack!(this.stmt_expr(block, expr, None));\n                 block.and(this.unit_rvalue())\n@@ -351,6 +274,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }\n+            | ExprKind::Borrow { .. }\n+            | ExprKind::Adt { .. }\n             | ExprKind::Loop { .. }\n             | ExprKind::LogicalOp { .. }\n             | ExprKind::Call { .. }"}, {"sha": "ae5289986e77cc537ccdef36cbca6e615950a892", "filename": "src/librustc_mir/build/expr/category.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bf0685cca167e684340152809be20a16ad65a76/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf0685cca167e684340152809be20a16ad65a76/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fcategory.rs?ref=4bf0685cca167e684340152809be20a16ad65a76", "patch": "@@ -48,19 +48,19 @@ impl Category {\n             | ExprKind::Match { .. }\n             | ExprKind::NeverToAny { .. }\n             | ExprKind::Use { .. }\n+            | ExprKind::Adt { .. }\n+            | ExprKind::Borrow { .. }\n             | ExprKind::Call { .. } => Some(Category::Rvalue(RvalueFunc::Into)),\n \n             ExprKind::Array { .. }\n             | ExprKind::Tuple { .. }\n-            | ExprKind::Adt { .. }\n             | ExprKind::Closure { .. }\n             | ExprKind::Unary { .. }\n             | ExprKind::Binary { .. }\n             | ExprKind::Box { .. }\n             | ExprKind::Cast { .. }\n             | ExprKind::Pointer { .. }\n             | ExprKind::Repeat { .. }\n-            | ExprKind::Borrow { .. }\n             | ExprKind::Assign { .. }\n             | ExprKind::AssignOp { .. }\n             | ExprKind::Yield { .. }"}, {"sha": "404ca3204e6c0038ade679a506ecea8215c1ea78", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 99, "deletions": 3, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/4bf0685cca167e684340152809be20a16ad65a76/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf0685cca167e684340152809be20a16ad65a76/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=4bf0685cca167e684340152809be20a16ad65a76", "patch": "@@ -4,7 +4,9 @@ use crate::build::expr::category::{Category, RvalueFunc};\n use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::hair::*;\n use rustc::mir::*;\n-use rustc::ty;\n+use rustc::ty::{self, CanonicalUserTypeAnnotation};\n+use rustc_data_structures::fx::FxHashMap;\n+use syntax_pos::symbol::sym;\n \n use rustc_target::spec::abi::Abi;\n \n@@ -270,6 +272,102 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             ExprKind::Use { source } => {\n                 this.into(destination, block, source)\n             }\n+            ExprKind::Borrow { arg, borrow_kind } => {\n+                // We don't do this in `as_rvalue` because we use `as_place`\n+                // for borrow expressions, so we cannot create an `RValue` that\n+                // remains valid across user code. `as_rvalue` is usually called\n+                // by this method anyway, so this shouldn't cause too many\n+                // unnecessary temporaries.\n+                let arg_place = match borrow_kind {\n+                    BorrowKind::Shared => unpack!(block = this.as_read_only_place(block, arg)),\n+                    _ => unpack!(block = this.as_place(block, arg)),\n+                };\n+                let borrow = Rvalue::Ref(\n+                    this.hir.tcx().lifetimes.re_erased,\n+                    borrow_kind,\n+                    arg_place,\n+                );\n+                this.cfg.push_assign(block, source_info, destination, borrow);\n+                block.unit()\n+            }\n+            ExprKind::Adt {\n+                adt_def,\n+                variant_index,\n+                substs,\n+                user_ty,\n+                fields,\n+                base,\n+            } => {\n+                // See the notes for `ExprKind::Array` in `as_rvalue` and for\n+                // `ExprKind::Borrow` above.\n+                let is_union = adt_def.is_union();\n+                let active_field_index = if is_union {\n+                    Some(fields[0].name.index())\n+                } else {\n+                    None\n+                };\n+\n+                let scope =  this.local_scope();\n+\n+                // first process the set of fields that were provided\n+                // (evaluating them in order given by user)\n+                let fields_map: FxHashMap<_, _> = fields\n+                    .into_iter()\n+                    .map(|f| {\n+                        (\n+                            f.name,\n+                            unpack!(block = this.as_operand(block, scope, f.expr)),\n+                        )\n+                    }).collect();\n+\n+                let field_names = this.hir.all_fields(adt_def, variant_index);\n+\n+                let fields = if let Some(FruInfo { base, field_types }) = base {\n+                    let base = unpack!(block = this.as_place(block, base));\n+\n+                    // MIR does not natively support FRU, so for each\n+                    // base-supplied field, generate an operand that\n+                    // reads it from the base.\n+                    field_names\n+                        .into_iter()\n+                        .zip(field_types.into_iter())\n+                        .map(|(n, ty)| match fields_map.get(&n) {\n+                            Some(v) => v.clone(),\n+                            None => this.consume_by_copy_or_move(\n+                                this.hir.tcx().mk_place_field(base.clone(), n, ty),\n+                            ),\n+                        }).collect()\n+                } else {\n+                    field_names\n+                        .iter()\n+                        .filter_map(|n| fields_map.get(n).cloned())\n+                        .collect()\n+                };\n+\n+                let inferred_ty = expr.ty;\n+                let user_ty = user_ty.map(|ty| {\n+                    this.canonical_user_type_annotations.push(CanonicalUserTypeAnnotation {\n+                        span: source_info.span,\n+                        user_ty: ty,\n+                        inferred_ty,\n+                    })\n+                });\n+                let adt = box AggregateKind::Adt(\n+                    adt_def,\n+                    variant_index,\n+                    substs,\n+                    user_ty,\n+                    active_field_index,\n+                );\n+                this.cfg.push_assign(\n+                    block,\n+                    source_info,\n+                    destination,\n+                    Rvalue::Aggregate(adt, fields)\n+                );\n+                block.unit()\n+            }\n+\n \n             // These cases don't actually need a destination\n             ExprKind::Assign { .. }\n@@ -324,10 +422,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Cast { .. }\n             | ExprKind::Pointer { .. }\n             | ExprKind::Repeat { .. }\n-            | ExprKind::Borrow { .. }\n             | ExprKind::Array { .. }\n             | ExprKind::Tuple { .. }\n-            | ExprKind::Adt { .. }\n             | ExprKind::Closure { .. }\n             | ExprKind::Literal { .. }\n             | ExprKind::Yield { .. } => {"}, {"sha": "f01afe1466aef7564c2e971c7e592b6044757b81", "filename": "src/test/ui/borrowck/borrowck-init-in-fru.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bf0685cca167e684340152809be20a16ad65a76/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bf0685cca167e684340152809be20a16ad65a76/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-init-in-fru.stderr?ref=4bf0685cca167e684340152809be20a16ad65a76", "patch": "@@ -1,8 +1,8 @@\n error[E0381]: use of possibly-uninitialized variable: `origin`\n-  --> $DIR/borrowck-init-in-fru.rs:9:5\n+  --> $DIR/borrowck-init-in-fru.rs:9:14\n    |\n LL |     origin = Point { x: 10, ..origin };\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ use of possibly-uninitialized `origin.y`\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^ use of possibly-uninitialized `origin.y`\n \n error: aborting due to previous error\n "}, {"sha": "1594421b0b13b01a12757f387a833c3f4e557ab9", "filename": "src/test/ui/mir/mir_assign_eval_order.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4bf0685cca167e684340152809be20a16ad65a76/src%2Ftest%2Fui%2Fmir%2Fmir_assign_eval_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4bf0685cca167e684340152809be20a16ad65a76/src%2Ftest%2Fui%2Fmir%2Fmir_assign_eval_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir_assign_eval_order.rs?ref=4bf0685cca167e684340152809be20a16ad65a76", "patch": "@@ -0,0 +1,67 @@\n+// Test evaluation order of assignment expressions is right to left.\n+\n+// run-pass\n+\n+// We would previously not finish evaluating borrow and FRU expressions before\n+// starting on the LHS\n+\n+struct S(i32);\n+\n+fn evaluate_reborrow_before_assign() {\n+    let mut x = &1;\n+    let y = &mut &2;\n+    let z = &3;\n+    // There's an implicit reborrow of `x` on the right-hand side of the\n+    // assignement. Note that writing an explicit reborrow would not show this\n+    // bug, as now there would be two reborrows on the right-hand side and at\n+    // least one of them would happen before the left-hand side is evaluated.\n+    *{ x = z; &mut *y } = x;\n+    assert_eq!(*x, 3);\n+    assert_eq!(**y, 1);             // y should be assigned the original value of `x`.\n+}\n+\n+fn evaluate_mut_reborrow_before_assign() {\n+    let mut x = &mut 1;\n+    let y = &mut &mut 2;\n+    let z = &mut 3;\n+    *{ x = z; &mut *y } = x;\n+    assert_eq!(*x, 3);\n+    assert_eq!(**y, 1);            // y should be assigned the original value of `x`.\n+}\n+\n+// We should evaluate `x[2]` and borrow the value out *before* evaluating the\n+// LHS and changing its value.\n+fn evaluate_ref_to_temp_before_assign_slice() {\n+    let mut x = &[S(0), S(1), S(2)][..];\n+    let y = &mut &S(7);\n+    *{ x = &[S(3), S(4), S(5)]; &mut *y } = &x[2];\n+    assert_eq!(2, y.0);\n+    assert_eq!(5, x[2].0);\n+}\n+\n+// We should evaluate `x[2]` and copy the value out *before* evaluating the LHS\n+// and changing its value.\n+fn evaluate_fru_to_temp_before_assign_slice() {\n+    let mut x = &[S(0), S(1), S(2)][..];\n+    let y = &mut S(7);\n+    *{ x = &[S(3), S(4), S(5)]; &mut *y } = S { ..x[2] };\n+    assert_eq!(2, y.0);\n+    assert_eq!(5, x[2].0);\n+}\n+\n+// We should evaluate `*x` and copy the value out *before* evaluating the LHS\n+// and dropping `x`.\n+fn evaluate_fru_to_temp_before_assign_box() {\n+    let x = Box::new(S(0));\n+    let y = &mut S(1);\n+    *{ drop(x); &mut *y } = S { ..*x };\n+    assert_eq!(0, y.0);\n+}\n+\n+fn main() {\n+    evaluate_reborrow_before_assign();\n+    evaluate_mut_reborrow_before_assign();\n+    evaluate_ref_to_temp_before_assign_slice();\n+    evaluate_fru_to_temp_before_assign_slice();\n+    evaluate_fru_to_temp_before_assign_box();\n+}"}, {"sha": "cef4aba02403717020e7e7b8e8d8db55196a3640", "filename": "src/test/ui/nll/issue-52534-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bf0685cca167e684340152809be20a16ad65a76/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bf0685cca167e684340152809be20a16ad65a76/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52534-2.stderr?ref=4bf0685cca167e684340152809be20a16ad65a76", "patch": "@@ -1,8 +1,8 @@\n error[E0597]: `x` does not live long enough\n-  --> $DIR/issue-52534-2.rs:6:9\n+  --> $DIR/issue-52534-2.rs:6:13\n    |\n LL |         y = &x\n-   |         ^^^^^^ borrowed value does not live long enough\n+   |             ^^ borrowed value does not live long enough\n LL |\n LL |     }\n    |     - `x` dropped here while still borrowed"}, {"sha": "0939584380af9c8ece730f97336edc5f502ae178", "filename": "src/test/ui/span/issue-36537.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4bf0685cca167e684340152809be20a16ad65a76/src%2Ftest%2Fui%2Fspan%2Fissue-36537.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4bf0685cca167e684340152809be20a16ad65a76/src%2Ftest%2Fui%2Fspan%2Fissue-36537.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-36537.stderr?ref=4bf0685cca167e684340152809be20a16ad65a76", "patch": "@@ -1,8 +1,8 @@\n error[E0597]: `a` does not live long enough\n-  --> $DIR/issue-36537.rs:5:9\n+  --> $DIR/issue-36537.rs:5:13\n    |\n LL |         p = &a;\n-   |         ^^^^^^ borrowed value does not live long enough\n+   |             ^^ borrowed value does not live long enough\n ...\n LL |     }\n    |     - `a` dropped here while still borrowed"}]}