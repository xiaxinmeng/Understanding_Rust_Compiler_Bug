{"sha": "9aac5fc0f3754bf8a7ec63119895530616ac7ccc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhYWM1ZmMwZjM3NTRiZjhhN2VjNjMxMTk4OTU1MzA2MTZhYzdjY2M=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-24T17:27:59Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-04-26T14:45:02Z"}, "message": "refactor away trans::symbol_map", "tree": {"sha": "46f7ee99b489686ee02c390c3586904ea344d959", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/46f7ee99b489686ee02c390c3586904ea344d959"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9aac5fc0f3754bf8a7ec63119895530616ac7ccc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9aac5fc0f3754bf8a7ec63119895530616ac7ccc", "html_url": "https://github.com/rust-lang/rust/commit/9aac5fc0f3754bf8a7ec63119895530616ac7ccc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9aac5fc0f3754bf8a7ec63119895530616ac7ccc/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a517343566956fb038b061f31558f088944977c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a517343566956fb038b061f31558f088944977c3", "html_url": "https://github.com/rust-lang/rust/commit/a517343566956fb038b061f31558f088944977c3"}], "stats": {"total": 238, "additions": 70, "deletions": 168}, "files": [{"sha": "ddd86c4679934d79493a9d20e2755e6d0fd1b164", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9aac5fc0f3754bf8a7ec63119895530616ac7ccc/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aac5fc0f3754bf8a7ec63119895530616ac7ccc/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=9aac5fc0f3754bf8a7ec63119895530616ac7ccc", "patch": "@@ -10,13 +10,11 @@\n \n use context::SharedCrateContext;\n use monomorphize::Instance;\n-use symbol_map::SymbolMap;\n use util::nodemap::FxHashMap;\n use rustc::hir::def_id::{DefId, CrateNum, LOCAL_CRATE};\n use rustc::session::config;\n use rustc::ty::TyCtxt;\n use syntax::attr;\n-use trans_item::TransItem;\n \n /// The SymbolExportLevel of a symbols specifies from which kinds of crates\n /// the symbol will be exported. `C` symbols will be exported from any\n@@ -35,24 +33,21 @@ pub struct ExportedSymbols {\n }\n \n impl ExportedSymbols {\n-\n     pub fn empty() -> ExportedSymbols {\n         ExportedSymbols {\n             exports: FxHashMap(),\n         }\n     }\n \n-    pub fn compute_from<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n-                                  symbol_map: &SymbolMap<'tcx>)\n-                                  -> ExportedSymbols {\n+    pub fn compute<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>) -> ExportedSymbols {\n         let mut local_crate: Vec<_> = scx\n             .exported_symbols()\n             .iter()\n             .map(|&node_id| {\n                 scx.tcx().hir.local_def_id(node_id)\n             })\n             .map(|def_id| {\n-                let name = symbol_for_def_id(scx.tcx(), def_id, symbol_map);\n+                let name = scx.tcx().symbol_name(Instance::mono(scx.tcx(), def_id));\n                 let export_level = export_level(scx, def_id);\n                 debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n                 (str::to_owned(&name), export_level)\n@@ -212,20 +207,3 @@ pub fn is_below_threshold(level: SymbolExportLevel,\n         level == SymbolExportLevel::C\n     }\n }\n-\n-fn symbol_for_def_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                               def_id: DefId,\n-                               symbol_map: &SymbolMap<'tcx>)\n-                               -> String {\n-    // Just try to look things up in the symbol map. If nothing's there, we\n-    // recompute.\n-    if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let Some(sym) = symbol_map.get(TransItem::Static(node_id)) {\n-            return sym.to_owned();\n-        }\n-    }\n-\n-    let instance = Instance::mono(tcx, def_id);\n-\n-    str::to_owned(&tcx.symbol_name(instance))\n-}"}, {"sha": "56ff5ebb069ea4a5f044a912fda677f656d726c1", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 54, "deletions": 11, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9aac5fc0f3754bf8a7ec63119895530616ac7ccc/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aac5fc0f3754bf8a7ec63119895530616ac7ccc/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=9aac5fc0f3754bf8a7ec63119895530616ac7ccc", "patch": "@@ -65,7 +65,6 @@ use meth;\n use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n-use symbol_map::SymbolMap;\n use symbol_names_test;\n use trans_item::{TransItem, DefPathBasedNames};\n use type_::Type;\n@@ -803,7 +802,6 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n                                  scx: &SharedCrateContext<'a, 'tcx>,\n                                  translation_items: &FxHashSet<TransItem<'tcx>>,\n                                  llvm_modules: &[ModuleLlvm],\n-                                 symbol_map: &SymbolMap<'tcx>,\n                                  exported_symbols: &ExportedSymbols) {\n     let export_threshold =\n         symbol_export::crates_export_threshold(&sess.crate_types.borrow());\n@@ -855,7 +853,7 @@ fn internalize_symbols<'a, 'tcx>(sess: &Session,\n             let mut linkage_fixed_explicitly = FxHashSet();\n \n             for trans_item in translation_items {\n-                let symbol_name = symbol_map.get_or_compute(scx, *trans_item);\n+                let symbol_name = str::to_owned(&trans_item.symbol_name(tcx));\n                 if trans_item.explicit_linkage(tcx).is_some() {\n                     linkage_fixed_explicitly.insert(symbol_name.clone());\n                 }\n@@ -1109,7 +1107,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Run the translation item collector and partition the collected items into\n     // codegen units.\n-    let (translation_items, codegen_units, symbol_map) =\n+    let (translation_items, codegen_units) =\n         collect_and_partition_translation_items(&shared_ccx);\n \n     let mut all_stats = Stats::default();\n@@ -1269,8 +1267,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let sess = shared_ccx.sess();\n \n-    let exported_symbols = ExportedSymbols::compute_from(&shared_ccx,\n-                                                         &symbol_map);\n+    let exported_symbols = ExportedSymbols::compute(&shared_ccx);\n \n     // Get the list of llvm modules we created. We'll do a few wacky\n     // transforms on them now.\n@@ -1290,7 +1287,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             &shared_ccx,\n                             &translation_items,\n                             &llvm_modules,\n-                            &symbol_map,\n                             &exported_symbols);\n     });\n \n@@ -1516,10 +1512,57 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n+#[inline(never)] // give this a place in the profiler\n+fn assert_symbols_are_distinct<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trans_items: I)\n+    where I: Iterator<Item=&'a TransItem<'tcx>>\n+{\n+    let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n+        (trans_item, trans_item.symbol_name(tcx))\n+    }).collect();\n+\n+    (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n+        sym1.cmp(sym2)\n+    });\n+\n+    for pair in (&symbols[..]).windows(2) {\n+        let sym1 = &pair[0].1;\n+        let sym2 = &pair[1].1;\n+\n+        if *sym1 == *sym2 {\n+            let trans_item1 = pair[0].0;\n+            let trans_item2 = pair[1].0;\n+\n+            let span1 = trans_item1.local_span(tcx);\n+            let span2 = trans_item2.local_span(tcx);\n+\n+            // Deterministically select one of the spans for error reporting\n+            let span = match (span1, span2) {\n+                (Some(span1), Some(span2)) => {\n+                    Some(if span1.lo.0 > span2.lo.0 {\n+                        span1\n+                    } else {\n+                        span2\n+                    })\n+                }\n+                (Some(span), None) |\n+                (None, Some(span)) => Some(span),\n+                _ => None\n+            };\n+\n+            let error_message = format!(\"symbol `{}` is already defined\", sym1);\n+\n+            if let Some(span) = span {\n+                tcx.sess.span_fatal(span, &error_message)\n+            } else {\n+                tcx.sess.fatal(&error_message)\n+            }\n+        }\n+    }\n+}\n+\n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n                                                      -> (FxHashSet<TransItem<'tcx>>,\n-                                                         Vec<CodegenUnit<'tcx>>,\n-                                                         SymbolMap<'tcx>) {\n+                                                         Vec<CodegenUnit<'tcx>>) {\n     let time_passes = scx.sess().time_passes();\n \n     let collection_mode = match scx.sess().opts.debugging_opts.print_trans_items {\n@@ -1547,7 +1590,7 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n             collector::collect_crate_translation_items(&scx, collection_mode)\n     });\n \n-    let symbol_map = SymbolMap::build(scx, items.iter().cloned());\n+    assert_symbols_are_distinct(scx.tcx(), items.iter());\n \n     let strategy = if scx.sess().opts.debugging_opts.incremental.is_some() {\n         PartitioningStrategy::PerModule\n@@ -1620,5 +1663,5 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         }\n     }\n \n-    (translation_items, codegen_units, symbol_map)\n+    (translation_items, codegen_units)\n }"}, {"sha": "7bc54e22265f959507b4d16bc90ab4952f2f7b28", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9aac5fc0f3754bf8a7ec63119895530616ac7ccc/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aac5fc0f3754bf8a7ec63119895530616ac7ccc/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=9aac5fc0f3754bf8a7ec63119895530616ac7ccc", "patch": "@@ -125,7 +125,6 @@ mod meth;\n mod mir;\n mod monomorphize;\n mod partitioning;\n-mod symbol_map;\n mod symbol_names_test;\n mod trans_item;\n mod tvec;"}, {"sha": "85a8d501753f237cfcb363158eac5ea6df213893", "filename": "src/librustc_trans/symbol_map.rs", "status": "removed", "additions": 0, "deletions": 131, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fsymbol_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a517343566956fb038b061f31558f088944977c3/src%2Flibrustc_trans%2Fsymbol_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_map.rs?ref=a517343566956fb038b061f31558f088944977c3", "patch": "@@ -1,131 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use context::SharedCrateContext;\n-use monomorphize::Instance;\n-use rustc::ty::TyCtxt;\n-use std::borrow::Cow;\n-use syntax::codemap::Span;\n-use trans_item::TransItem;\n-use util::nodemap::FxHashMap;\n-\n-// In the SymbolMap we collect the symbol names of all translation items of\n-// the current crate. This map exists as a performance optimization. Symbol\n-// names of translation items are deterministic and fully defined by the item.\n-// Thus they could also always be recomputed if needed.\n-\n-pub struct SymbolMap<'tcx> {\n-    index: FxHashMap<TransItem<'tcx>, (usize, usize)>,\n-    arena: String,\n-}\n-\n-impl<'tcx> SymbolMap<'tcx> {\n-\n-    pub fn build<'a, I>(scx: &SharedCrateContext<'a, 'tcx>,\n-                        trans_items: I)\n-                        -> SymbolMap<'tcx>\n-        where I: Iterator<Item=TransItem<'tcx>>\n-    {\n-        // Check for duplicate symbol names\n-        let tcx = scx.tcx();\n-        let mut symbols: Vec<_> = trans_items.map(|trans_item| {\n-            (trans_item, trans_item.symbol_name(tcx))\n-        }).collect();\n-\n-        (&mut symbols[..]).sort_by(|&(_, ref sym1), &(_, ref sym2)|{\n-            sym1.cmp(sym2)\n-        });\n-\n-        for pair in (&symbols[..]).windows(2) {\n-            let sym1 = &pair[0].1;\n-            let sym2 = &pair[1].1;\n-\n-            if *sym1 == *sym2 {\n-                let trans_item1 = pair[0].0;\n-                let trans_item2 = pair[1].0;\n-\n-                let span1 = get_span(scx.tcx(), trans_item1);\n-                let span2 = get_span(scx.tcx(), trans_item2);\n-\n-                // Deterministically select one of the spans for error reporting\n-                let span = match (span1, span2) {\n-                    (Some(span1), Some(span2)) => {\n-                        Some(if span1.lo.0 > span2.lo.0 {\n-                            span1\n-                        } else {\n-                            span2\n-                        })\n-                    }\n-                    (Some(span), None) |\n-                    (None, Some(span)) => Some(span),\n-                    _ => None\n-                };\n-\n-                let error_message = format!(\"symbol `{}` is already defined\", sym1);\n-\n-                if let Some(span) = span {\n-                    scx.sess().span_fatal(span, &error_message)\n-                } else {\n-                    scx.sess().fatal(&error_message)\n-                }\n-            }\n-        }\n-\n-        let mut symbol_map = SymbolMap {\n-            index: FxHashMap(),\n-            arena: String::with_capacity(1024),\n-        };\n-\n-        for (trans_item, symbol) in symbols {\n-            let start_index = symbol_map.arena.len();\n-            symbol_map.arena.push_str(&symbol[..]);\n-            let end_index = symbol_map.arena.len();\n-            let prev_entry = symbol_map.index.insert(trans_item,\n-                                                     (start_index, end_index));\n-            if prev_entry.is_some() {\n-                bug!(\"TransItem encountered twice?\")\n-            }\n-        }\n-\n-        fn get_span<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              trans_item: TransItem<'tcx>) -> Option<Span> {\n-            match trans_item {\n-                TransItem::Fn(Instance { def, .. }) => {\n-                    tcx.hir.as_local_node_id(def.def_id())\n-                }\n-                TransItem::Static(node_id) |\n-                TransItem::GlobalAsm(node_id) => {\n-                    Some(node_id)\n-                }\n-            }.map(|node_id| {\n-                tcx.hir.span(node_id)\n-            })\n-        }\n-\n-        symbol_map\n-    }\n-\n-    pub fn get(&self, trans_item: TransItem<'tcx>) -> Option<&str> {\n-        self.index.get(&trans_item).map(|&(start_index, end_index)| {\n-            &self.arena[start_index .. end_index]\n-        })\n-    }\n-\n-    pub fn get_or_compute<'map, 'scx>(&'map self,\n-                                      scx: &SharedCrateContext<'scx, 'tcx>,\n-                                      trans_item: TransItem<'tcx>)\n-                                      -> Cow<'map, str> {\n-        if let Some(sym) = self.get(trans_item) {\n-            Cow::from(sym)\n-        } else {\n-            Cow::from(str::to_owned(&trans_item.symbol_name(scx.tcx())))\n-        }\n-    }\n-}"}, {"sha": "392ee71d52b44c751d44523928293f9549aa53fb", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9aac5fc0f3754bf8a7ec63119895530616ac7ccc/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aac5fc0f3754bf8a7ec63119895530616ac7ccc/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=9aac5fc0f3754bf8a7ec63119895530616ac7ccc", "patch": "@@ -28,9 +28,10 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::Substs;\n-use syntax_pos::symbol::Symbol;\n use syntax::ast::{self, NodeId};\n use syntax::attr;\n+use syntax_pos::Span;\n+use syntax_pos::symbol::Symbol;\n use type_of;\n use std::fmt::Write;\n use std::iter;\n@@ -200,6 +201,18 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         }\n     }\n \n+    pub fn local_span(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<Span> {\n+        match *self {\n+            TransItem::Fn(Instance { def, .. }) => {\n+                tcx.hir.as_local_node_id(def.def_id())\n+            }\n+            TransItem::Static(node_id) |\n+            TransItem::GlobalAsm(node_id) => {\n+                Some(node_id)\n+            }\n+        }.map(|node_id| tcx.hir.span(node_id))\n+    }\n+\n     pub fn instantiation_mode(&self,\n                               tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                               -> InstantiationMode {"}]}