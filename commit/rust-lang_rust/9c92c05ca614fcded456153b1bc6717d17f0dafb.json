{"sha": "9c92c05ca614fcded456153b1bc6717d17f0dafb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljOTJjMDVjYTYxNGZjZGVkNDU2MTUzYjFiYzY3MTdkMTdmMGRhZmI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-06-08T18:41:35Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-06-08T18:41:35Z"}, "message": "Merge #1386\n\n1386: Remove one of the two different algorithms for name resolution of macros :D r=edwin0cheng a=matklad\n\nr? @edwin0cheng \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4cdbfe1ae67d0eae6ba85b19cf40126898f43ac5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cdbfe1ae67d0eae6ba85b19cf40126898f43ac5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c92c05ca614fcded456153b1bc6717d17f0dafb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c92c05ca614fcded456153b1bc6717d17f0dafb", "html_url": "https://github.com/rust-lang/rust/commit/9c92c05ca614fcded456153b1bc6717d17f0dafb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c92c05ca614fcded456153b1bc6717d17f0dafb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "bb55111c209a9d3a6249cab35308a506b7f22d53", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb55111c209a9d3a6249cab35308a506b7f22d53", "html_url": "https://github.com/rust-lang/rust/commit/bb55111c209a9d3a6249cab35308a506b7f22d53"}, {"sha": "caefa6982bc57195687de11137997f1d62d791fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/caefa6982bc57195687de11137997f1d62d791fe", "html_url": "https://github.com/rust-lang/rust/commit/caefa6982bc57195687de11137997f1d62d791fe"}], "stats": {"total": 185, "additions": 97, "deletions": 88}, "files": [{"sha": "012f374ec8428cad87ac3545a0116e90fb5e8c6f", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=9c92c05ca614fcded456153b1bc6717d17f0dafb", "patch": "@@ -827,25 +827,25 @@ where\n             ast::ExprKind::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::ExprKind::MacroCall(e) => {\n-                // very hacky.FIXME change to use the macro resolution\n-                let path = e.path().and_then(Path::from_ast);\n-\n                 let ast_id = self\n                     .db\n                     .ast_id_map(self.current_file_id)\n                     .ast_id(e)\n                     .with_file_id(self.current_file_id);\n \n-                if let Some(def) = self.resolver.resolve_macro_call(self.db, path) {\n-                    let call_id = MacroCallLoc { def, ast_id }.id(self.db);\n-                    let file_id = call_id.as_file(MacroFileKind::Expr);\n-                    if let Some(node) = self.db.parse_or_expand(file_id) {\n-                        if let Some(expr) = ast::Expr::cast(&*node) {\n-                            log::debug!(\"macro expansion {}\", expr.syntax().debug_dump());\n-                            let old_file_id = std::mem::replace(&mut self.current_file_id, file_id);\n-                            let id = self.collect_expr(&expr);\n-                            self.current_file_id = old_file_id;\n-                            return id;\n+                if let Some(path) = e.path().and_then(Path::from_ast) {\n+                    if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n+                        let call_id = MacroCallLoc { def: def.id, ast_id }.id(self.db);\n+                        let file_id = call_id.as_file(MacroFileKind::Expr);\n+                        if let Some(node) = self.db.parse_or_expand(file_id) {\n+                            if let Some(expr) = ast::Expr::cast(&*node) {\n+                                log::debug!(\"macro expansion {}\", expr.syntax().debug_dump());\n+                                let old_file_id =\n+                                    std::mem::replace(&mut self.current_file_id, file_id);\n+                                let id = self.collect_expr(&expr);\n+                                self.current_file_id = old_file_id;\n+                                return id;\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "b5938fa032e419c0878c1044cec8979a2850f588", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=9c92c05ca614fcded456153b1bc6717d17f0dafb", "patch": "@@ -92,7 +92,6 @@ pub struct CrateDefMap {\n     extern_prelude: FxHashMap<Name, ModuleDef>,\n     root: CrateModuleId,\n     modules: Arena<CrateModuleId, ModuleData>,\n-    public_macros: FxHashMap<Name, MacroDefId>,\n \n     /// Some macros are not well-behavior, which leads to infinite loop\n     /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n@@ -106,7 +105,6 @@ pub struct CrateDefMap {\n     /// However, do we want to put it as a global variable?\n     poison_macros: FxHashSet<MacroDefId>,\n \n-    local_macros: FxHashMap<Name, MacroDefId>,\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n@@ -249,9 +247,7 @@ impl CrateDefMap {\n                 prelude: None,\n                 root,\n                 modules,\n-                public_macros: FxHashMap::default(),\n                 poison_macros: FxHashSet::default(),\n-                local_macros: FxHashMap::default(),\n                 diagnostics: Vec::new(),\n             }\n         };\n@@ -313,7 +309,7 @@ impl CrateDefMap {\n         (res.resolved_def.left().unwrap_or_else(PerNs::none), res.segment_index)\n     }\n \n-    fn resolve_path_with_macro(\n+    pub(crate) fn resolve_path_with_macro(\n         &self,\n         db: &impl DefDatabase,\n         original_module: CrateModuleId,\n@@ -323,27 +319,6 @@ impl CrateDefMap {\n         (res.resolved_def, res.segment_index)\n     }\n \n-    // FIXME: This seems to do the same work as `resolve_path_with_macro`, but\n-    // using a completely different code path. Seems bad, huh?\n-    pub(crate) fn find_macro(\n-        &self,\n-        db: &impl DefDatabase,\n-        original_module: CrateModuleId,\n-        path: &Path,\n-    ) -> Option<MacroDefId> {\n-        let name = path.expand_macro_expr()?;\n-        // search local first\n-        // FIXME: Remove public_macros check when we have a correct local_macors implementation\n-        let local =\n-            self.public_macros.get(&name).or_else(|| self.local_macros.get(&name)).map(|it| *it);\n-        if local.is_some() {\n-            return local;\n-        }\n-\n-        let res = self.resolve_path_fp_with_macro(db, ResolveMode::Other, original_module, path);\n-        res.resolved_def.right().map(|m| m.id)\n-    }\n-\n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n     // the result.\n     fn resolve_path_fp_with_macro(\n@@ -511,7 +486,7 @@ impl CrateDefMap {\n         let from_scope = self[module]\n             .scope\n             .get_item_or_macro(name)\n-            .unwrap_or_else(|| Either::Left(PerNs::none()));;\n+            .unwrap_or_else(|| Either::Left(PerNs::none()));\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n         let from_prelude = self.resolve_in_prelude(db, name);"}, {"sha": "99110d58d2bda8018e5425f0864ea83140955b5b", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=9c92c05ca614fcded456153b1bc6717d17f0dafb", "patch": "@@ -138,15 +138,35 @@ where\n         }\n     }\n \n-    fn define_macro(&mut self, name: Name, macro_id: MacroDefId, export: bool) {\n+    fn define_macro(\n+        &mut self,\n+        module_id: CrateModuleId,\n+        name: Name,\n+        macro_id: MacroDefId,\n+        export: bool,\n+    ) {\n+        // macro-by-example in Rust have completely weird name resolution logic,\n+        // unlike anything else in the language. We'd don't fully implement yet,\n+        // just give a somewhat precise approximation.\n+        //\n+        // Specifically, we store a set of visible macros in each module, just\n+        // like how we do with usual items. This is wrong, however, because\n+        // macros can be shadowed and their scopes are mostly unrelated to\n+        // modules. To paper over the second problem, we also maintain\n+        // `global_macro_scope` which works when we construct `CrateDefMap`, but\n+        // is completely ignored in expressions.\n+        //\n+        // What we should do is that, in CrateDefMap, we should maintain a\n+        // separate tower of macro scopes, with ids. Then, for each item in the\n+        // module, we need to store it's macro scope.\n+        let def = Either::Right(MacroDef { id: macro_id });\n+\n+        // In Rust, `#[macro_export]` macros are unconditionally visible at the\n+        // crate root, even if the parent modules is **not** visible.\n         if export {\n-            self.def_map.public_macros.insert(name.clone(), macro_id);\n-\n-            let def = Either::Right(MacroDef { id: macro_id });\n-            self.update(self.def_map.root, None, &[(name.clone(), def)]);\n-        } else {\n-            self.def_map.local_macros.insert(name.clone(), macro_id);\n+            self.update(self.def_map.root, None, &[(name.clone(), def.clone())]);\n         }\n+        self.update(module_id, None, &[(name.clone(), def)]);\n         self.global_macro_scope.insert(name, macro_id);\n     }\n \n@@ -589,7 +609,7 @@ where\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n                 let macro_id = MacroDefId(mac.ast_id.with_file_id(self.file_id));\n-                self.def_collector.define_macro(name.clone(), macro_id, mac.export)\n+                self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export)\n             }\n             return;\n         }\n@@ -694,9 +714,7 @@ mod tests {\n                 prelude: None,\n                 root,\n                 modules,\n-                public_macros: FxHashMap::default(),\n                 poison_macros: FxHashSet::default(),\n-                local_macros: FxHashMap::default(),\n                 diagnostics: Vec::new(),\n             }\n         };"}, {"sha": "4e04740eb997acdf7bbc58bfdf2827180b613655", "filename": "crates/ra_hir/src/nameres/tests/macros.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=9c92c05ca614fcded456153b1bc6717d17f0dafb", "patch": "@@ -21,6 +21,7 @@ fn macro_rules_are_globally_visible() {\n    \u22eecrate\n    \u22eeFoo: t v\n    \u22eenested: t\n+   \u22eestructs: m\n    \u22ee\n    \u22eecrate::nested\n    \u22eeBar: t v\n@@ -46,6 +47,7 @@ fn macro_rules_can_define_modules() {\n     );\n     assert_snapshot_matches!(map, @r###\"\n    \u22eecrate\n+   \u22eem: m\n    \u22een1: t\n    \u22ee\n    \u22eecrate::n1\n@@ -127,8 +129,11 @@ fn unexpanded_macro_should_expand_by_fixedpoint_loop() {\n             \"foo\": (\"/lib.rs\", []),\n         },\n     );\n-    assert_snapshot_matches!(map, @r###\"crate\n-Foo: t v\n-bar: m\n-foo: m\"###);\n+    assert_snapshot_matches!(map, @r###\"\n+   \u22eecrate\n+   \u22eeFoo: t v\n+   \u22eebar: m\n+   \u22eebaz: m\n+   \u22eefoo: m\n+    \"###);\n }"}, {"sha": "1b987c1b663138c9d9f7cf614a750b97119385b3", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=9c92c05ca614fcded456153b1bc6717d17f0dafb", "patch": "@@ -2,11 +2,11 @@\n use std::sync::Arc;\n \n use rustc_hash::{FxHashMap, FxHashSet};\n+use either::Either;\n \n use crate::{\n-    ModuleDef, Trait,\n+    ModuleDef, Trait, MacroDef,\n     code_model::Crate,\n-    MacroDefId,\n     db::HirDatabase,\n     name::{Name, KnownName},\n     nameres::{PerNs, CrateDefMap, CrateModuleId},\n@@ -130,13 +130,16 @@ impl Resolver {\n         resolution\n     }\n \n-    pub(crate) fn resolve_macro_call(\n+    pub(crate) fn resolve_path_as_macro(\n         &self,\n         db: &impl HirDatabase,\n-        path: Option<Path>,\n-    ) -> Option<MacroDefId> {\n-        let m = self.module()?;\n-        m.0.find_macro(db, m.1, &path?)\n+        path: &Path,\n+    ) -> Option<MacroDef> {\n+        let (item_map, module) = self.module()?;\n+        match item_map.resolve_path_with_macro(db, module, path) {\n+            (Either::Right(macro_def), None) => Some(macro_def),\n+            _ => None,\n+        }\n     }\n \n     /// Returns the resolved path segments\n@@ -165,7 +168,11 @@ impl Resolver {\n \n     /// Returns the fully resolved path if we were able to resolve it.\n     /// otherwise returns `PerNs::none`\n-    pub(crate) fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<Resolution> {\n+    pub(crate) fn resolve_path_without_assoc_items(\n+        &self,\n+        db: &impl HirDatabase,\n+        path: &Path,\n+    ) -> PerNs<Resolution> {\n         // into_fully_resolved() returns the fully resolved path or PerNs::none() otherwise\n         self.resolve_path_segments(db, path).into_fully_resolved()\n     }"}, {"sha": "876ebe0e34c8f913170d7f4881d1b2c3f8c25f67", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=9c92c05ca614fcded456153b1bc6717d17f0dafb", "patch": "@@ -267,17 +267,16 @@ impl SourceAnalyzer {\n         db: &impl HirDatabase,\n         macro_call: &ast::MacroCall,\n     ) -> Option<MacroDef> {\n-        let id =\n-            self.resolver.resolve_macro_call(db, macro_call.path().and_then(Path::from_ast))?;\n-        Some(MacroDef { id })\n+        let path = macro_call.path().and_then(Path::from_ast)?;\n+        self.resolver.resolve_path_as_macro(db, &path)\n     }\n \n     pub fn resolve_hir_path(\n         &self,\n         db: &impl HirDatabase,\n         path: &crate::Path,\n     ) -> PerNs<crate::Resolution> {\n-        self.resolver.resolve_path(db, path)\n+        self.resolver.resolve_path_without_assoc_items(db, path)\n     }\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &ast::Path) -> Option<PathResolution> {\n@@ -294,7 +293,7 @@ impl SourceAnalyzer {\n             }\n         }\n         let hir_path = crate::Path::from_ast(path)?;\n-        let res = self.resolver.resolve_path(db, &hir_path);\n+        let res = self.resolver.resolve_path_without_assoc_items(db, &hir_path);\n         let res = res.clone().take_types().or_else(|| res.take_values())?;\n         let res = match res {\n             crate::Resolution::Def(it) => PathResolution::Def(it),"}, {"sha": "6aa727ea10453e00e9350a6011cc573c9bb205be", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=9c92c05ca614fcded456153b1bc6717d17f0dafb", "patch": "@@ -610,23 +610,26 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             None => return (Ty::Unknown, None),\n         };\n         let resolver = &self.resolver;\n-        let typable: Option<TypableDef> = match resolver.resolve_path(self.db, &path).take_types() {\n-            Some(Resolution::Def(def)) => def.into(),\n-            Some(Resolution::LocalBinding(..)) => {\n-                // this cannot happen\n-                log::error!(\"path resolved to local binding in type ns\");\n-                return (Ty::Unknown, None);\n-            }\n-            Some(Resolution::GenericParam(..)) => {\n-                // generic params can't be used in struct literals\n-                return (Ty::Unknown, None);\n-            }\n-            Some(Resolution::SelfType(..)) => {\n-                // FIXME this is allowed in an impl for a struct, handle this\n-                return (Ty::Unknown, None);\n-            }\n-            None => return (Ty::Unknown, None),\n-        };\n+        let typable: Option<TypableDef> =\n+            // FIXME: this should resolve assoc items as well, see this example:\n+            // https://play.rust-lang.org/?gist=087992e9e22495446c01c0d4e2d69521\n+            match resolver.resolve_path_without_assoc_items(self.db, &path).take_types() {\n+                Some(Resolution::Def(def)) => def.into(),\n+                Some(Resolution::LocalBinding(..)) => {\n+                    // this cannot happen\n+                    log::error!(\"path resolved to local binding in type ns\");\n+                    return (Ty::Unknown, None);\n+                }\n+                Some(Resolution::GenericParam(..)) => {\n+                    // generic params can't be used in struct literals\n+                    return (Ty::Unknown, None);\n+                }\n+                Some(Resolution::SelfType(..)) => {\n+                    // FIXME this is allowed in an impl for a struct, handle this\n+                    return (Ty::Unknown, None);\n+                }\n+                None => return (Ty::Unknown, None),\n+            };\n         let def = match typable {\n             None => return (Ty::Unknown, None),\n             Some(it) => it,"}, {"sha": "26c213a416878eff356accd1cd7f9bdaeedc7c52", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=9c92c05ca614fcded456153b1bc6717d17f0dafb", "patch": "@@ -65,7 +65,7 @@ impl Ty {\n \n     pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Self {\n         // Resolve the path (in type namespace)\n-        let resolution = resolver.resolve_path(db, path).take_types();\n+        let resolution = resolver.resolve_path_without_assoc_items(db, path).take_types();\n \n         let def = match resolution {\n             Some(Resolution::Def(def)) => def,\n@@ -216,7 +216,7 @@ impl TraitRef {\n         path: &Path,\n         explicit_self_ty: Option<Ty>,\n     ) -> Option<Self> {\n-        let resolved = match resolver.resolve_path(db, &path).take_types()? {\n+        let resolved = match resolver.resolve_path_without_assoc_items(db, &path).take_types()? {\n             Resolution::Def(ModuleDef::Trait(tr)) => tr,\n             _ => return None,\n         };"}, {"sha": "54b2a8c162949b66e528f798df434b2ded2ae175", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c92c05ca614fcded456153b1bc6717d17f0dafb/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=9c92c05ca614fcded456153b1bc6717d17f0dafb", "patch": "@@ -2481,8 +2481,10 @@ fn main() {\n }\n \"#),\n         @r###\"\n-[156; 182) '{     ...,2); }': ()\n-[166; 167) 'x': Foo\"###\n+   \u22ee\n+   \u22ee[156; 182) '{     ...,2); }': ()\n+   \u22ee[166; 167) 'x': Foo\n+    \"###\n     );\n }\n "}]}