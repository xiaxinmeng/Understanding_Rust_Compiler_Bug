{"sha": "8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYTdiYTdkNGMxYWM5YjllNTg5NjlkYzE1NThiMjllOWIwMmE0OGE=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-02-10T00:37:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-10T00:37:15Z"}, "message": "Merge pull request #61 from rust-lang/feature/masks\n\nAdd bitmasks and simplify mask API", "tree": {"sha": "1b1a58a6a4bf97724a4d8817ff23121f43752199", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b1a58a6a4bf97724a4d8817ff23121f43752199"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgIyq7CRBK7hj4Ov3rIwAAdHIIABC/0IJpjo7SFiDFwtY807r+\nUyJs8PVnLaxZ6kttzOX6jp3e9t9a59sOX5xyclnPimC3PBPJcQ/aIyNEKXa4g5cN\nZIt2e5OKlKxMQDPz2G920Ht0JeSTeobAtoKp94oBXsdSPXnoi+mTCn48gt5PRBU3\n2FNgBwhP5jNMKtWJtXrJS518EE6/ZGaizgKnGi97Oa8OgUv98OKWSmbjUc4C37I5\nq5R6zWY9mpcs6iFKB3KSVjDsuGxJF8ldVjFfDGtRBKS2SIjnZ08ddn+WyIzCOq0B\nyE/7/tAxn7rmeVRpWDmXhtRunLr7itMG3hb3RZI3lfOhuM5JOn1beE84ch7mbrU=\n=sihX\n-----END PGP SIGNATURE-----\n", "payload": "tree 1b1a58a6a4bf97724a4d8817ff23121f43752199\nparent 1b0c23194829da3a75e641ff0424986cbeb5ff9e\nparent 26061b4e84f833a100b4cd0978940997ecd72be3\nauthor Caleb Zulawski <caleb.zulawski@gmail.com> 1612917435 -0500\ncommitter GitHub <noreply@github.com> 1612917435 -0500\n\nMerge pull request #61 from rust-lang/feature/masks\n\nAdd bitmasks and simplify mask API"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a", "html_url": "https://github.com/rust-lang/rust/commit/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b0c23194829da3a75e641ff0424986cbeb5ff9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b0c23194829da3a75e641ff0424986cbeb5ff9e", "html_url": "https://github.com/rust-lang/rust/commit/1b0c23194829da3a75e641ff0424986cbeb5ff9e"}, {"sha": "26061b4e84f833a100b4cd0978940997ecd72be3", "url": "https://api.github.com/repos/rust-lang/rust/commits/26061b4e84f833a100b4cd0978940997ecd72be3", "html_url": "https://github.com/rust-lang/rust/commit/26061b4e84f833a100b4cd0978940997ecd72be3"}], "stats": {"total": 1074, "additions": 733, "deletions": 341}, "files": [{"sha": "de9cb566022e2916d15e49654d0f752c60af4895", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a", "patch": "@@ -1,12 +1,6 @@\n #![no_std]\n #![allow(incomplete_features)]\n-#![feature(\n-    repr_simd,\n-    platform_intrinsics,\n-    link_llvm_intrinsics,\n-    simd_ffi,\n-    const_generics\n-)]\n+#![feature(repr_simd, platform_intrinsics, simd_ffi, const_generics)]\n #![warn(missing_docs)]\n //! Portable SIMD module.\n "}, {"sha": "51ed8037043da993dc554891ab46edd2fba8dfe4", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a", "patch": "@@ -0,0 +1,220 @@\n+/// Implemented for bitmask sizes that are supported by the implementation.\n+pub trait LanesAtMost64 {}\n+impl LanesAtMost64 for BitMask<1> {}\n+impl LanesAtMost64 for BitMask<2> {}\n+impl LanesAtMost64 for BitMask<4> {}\n+impl LanesAtMost64 for BitMask<8> {}\n+impl LanesAtMost64 for BitMask<16> {}\n+impl LanesAtMost64 for BitMask<32> {}\n+impl LanesAtMost64 for BitMask<64> {}\n+\n+/// A mask where each lane is represented by a single bit.\n+#[derive(Copy, Clone, Debug)]\n+#[repr(transparent)]\n+pub struct BitMask<const LANES: usize>(u64)\n+where\n+    BitMask<LANES>: LanesAtMost64;\n+\n+impl<const LANES: usize> BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    /// Construct a mask by setting all lanes to the given value.\n+    pub fn splat(value: bool) -> Self {\n+        if value {\n+            Self(u64::MAX)\n+        } else {\n+            Self(u64::MIN)\n+        }\n+    }\n+\n+    /// Tests the value of the specified lane.\n+    ///\n+    /// # Panics\n+    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+    #[inline]\n+    pub fn test(&self, lane: usize) -> bool {\n+        assert!(lane < LANES, \"lane index out of range\");\n+        (self.0 >> lane) & 0x1 > 0\n+    }\n+\n+    /// Sets the value of the specified lane.\n+    ///\n+    /// # Panics\n+    /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+    #[inline]\n+    pub fn set(&mut self, lane: usize, value: bool) {\n+        assert!(lane < LANES, \"lane index out of range\");\n+        self.0 ^= ((value ^ self.test(lane)) as u64) << lane\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitAnd for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(self, rhs: Self) -> Self {\n+        Self(self.0 & rhs.0)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitAnd<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitand(self, rhs: bool) -> Self {\n+        self & Self::splat(rhs)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitAnd<BitMask<LANES>> for bool\n+where\n+    BitMask<LANES>: LanesAtMost64,\n+{\n+    type Output = BitMask<LANES>;\n+    #[inline]\n+    fn bitand(self, rhs: BitMask<LANES>) -> BitMask<LANES> {\n+        BitMask::<LANES>::splat(self) & rhs\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitOr for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(self, rhs: Self) -> Self {\n+        Self(self.0 | rhs.0)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitOr<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitor(self, rhs: bool) -> Self {\n+        self | Self::splat(rhs)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitOr<BitMask<LANES>> for bool\n+where\n+    BitMask<LANES>: LanesAtMost64,\n+{\n+    type Output = BitMask<LANES>;\n+    #[inline]\n+    fn bitor(self, rhs: BitMask<LANES>) -> BitMask<LANES> {\n+        BitMask::<LANES>::splat(self) | rhs\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitXor for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(self, rhs: Self) -> Self::Output {\n+        Self(self.0 ^ rhs.0)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitXor<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = Self;\n+    #[inline]\n+    fn bitxor(self, rhs: bool) -> Self::Output {\n+        self ^ Self::splat(rhs)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitXor<BitMask<LANES>> for bool\n+where\n+    BitMask<LANES>: LanesAtMost64,\n+{\n+    type Output = BitMask<LANES>;\n+    #[inline]\n+    fn bitxor(self, rhs: BitMask<LANES>) -> Self::Output {\n+        BitMask::<LANES>::splat(self) ^ rhs\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::Not for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    type Output = BitMask<LANES>;\n+    #[inline]\n+    fn not(self) -> Self::Output {\n+        Self(!self.0)\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitAndAssign for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitand_assign(&mut self, rhs: Self) {\n+        self.0 &= rhs.0;\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitAndAssign<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitand_assign(&mut self, rhs: bool) {\n+        *self &= Self::splat(rhs);\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitOrAssign for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        self.0 |= rhs.0;\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitOrAssign<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitor_assign(&mut self, rhs: bool) {\n+        *self |= Self::splat(rhs);\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitXorAssign for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitxor_assign(&mut self, rhs: Self) {\n+        self.0 ^= rhs.0;\n+    }\n+}\n+\n+impl<const LANES: usize> core::ops::BitXorAssign<bool> for BitMask<LANES>\n+where\n+    Self: LanesAtMost64,\n+{\n+    #[inline]\n+    fn bitxor_assign(&mut self, rhs: bool) {\n+        *self ^= Self::splat(rhs);\n+    }\n+}"}, {"sha": "d7c4af47727caa92b0c5faed174b5105687e3536", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a", "patch": "@@ -0,0 +1,301 @@\n+//! Masks that take up full SIMD vector registers.\n+\n+/// The error type returned when converting an integer to a mask fails.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub struct TryFromMaskError(());\n+\n+impl core::fmt::Display for TryFromMaskError {\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(\n+            f,\n+            \"mask vector must have all bits set or unset in each lane\"\n+        )\n+    }\n+}\n+\n+macro_rules! define_mask {\n+    { $(#[$attr:meta])* struct $name:ident<const $lanes:ident: usize>($type:ty); } => {\n+        $(#[$attr])*\n+        #[derive(Copy, Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n+        #[repr(transparent)]\n+        pub struct $name<const $lanes: usize>($type);\n+\n+        impl<const $lanes: usize> $name<$lanes> {\n+            /// Construct a mask by setting all lanes to the given value.\n+            pub fn splat(value: bool) -> Self {\n+                Self(<$type>::splat(\n+                    if value {\n+                        -1\n+                    } else {\n+                        0\n+                    }\n+                ))\n+            }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn test(&self, lane: usize) -> bool {\n+                assert!(lane < LANES, \"lane index out of range\");\n+                self.0[lane] == -1\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn set(&mut self, lane: usize, value: bool) {\n+                assert!(lane < LANES, \"lane index out of range\");\n+                self.0[lane] = if value {\n+                    -1\n+                } else {\n+                    0\n+                }\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<bool> for $name<$lanes> {\n+            fn from(value: bool) -> Self {\n+                Self::splat(value)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::TryFrom<$type> for $name<$lanes> {\n+            type Error = TryFromMaskError;\n+            fn try_from(value: $type) -> Result<Self, Self::Error> {\n+                if value.as_slice().iter().all(|x| *x == 0 || *x == -1) {\n+                    Ok(Self(value))\n+                } else {\n+                    Err(TryFromMaskError(()))\n+                }\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for $type {\n+            fn from(value: $name<$lanes>) -> Self {\n+                value.0\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<crate::BitMask<$lanes>> for $name<$lanes>\n+        where\n+            crate::BitMask<$lanes>: crate::LanesAtMost64,\n+        {\n+            fn from(value: crate::BitMask<$lanes>) -> Self {\n+                // TODO use an intrinsic to do this efficiently (with LLVM's sext instruction)\n+                let mut mask = Self::splat(false);\n+                for lane in 0..LANES {\n+                    mask.set(lane, value.test(lane));\n+                }\n+                mask\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for crate::BitMask<$lanes>\n+        where\n+            crate::BitMask<$lanes>: crate::LanesAtMost64,\n+        {\n+            fn from(value: $name<$lanes>) -> Self {\n+                // TODO use an intrinsic to do this efficiently (with LLVM's trunc instruction)\n+                let mut mask = Self::splat(false);\n+                for lane in 0..LANES {\n+                    mask.set(lane, value.test(lane));\n+                }\n+                mask\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                f.debug_list()\n+                    .entries((0..LANES).map(|lane| self.test(lane)))\n+                    .finish()\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Binary for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Binary::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Octal for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Octal::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::LowerHex for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::LowerHex::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::UpperHex for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::UpperHex::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAnd for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitand(self, rhs: Self) -> Self {\n+                Self(self.0 & rhs.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitand(self, rhs: bool) -> Self {\n+                self & Self::splat(rhs)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn bitand(self, rhs: $name<LANES>) -> $name<LANES> {\n+                $name::<LANES>::splat(self) & rhs\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOr for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitor(self, rhs: Self) -> Self {\n+                Self(self.0 | rhs.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitor(self, rhs: bool) -> Self {\n+                self | Self::splat(rhs)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn bitor(self, rhs: $name<LANES>) -> $name<LANES> {\n+                $name::<LANES>::splat(self) | rhs\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXor for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitxor(self, rhs: Self) -> Self::Output {\n+                Self(self.0 ^ rhs.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES> {\n+            type Output = Self;\n+            #[inline]\n+            fn bitxor(self, rhs: bool) -> Self::Output {\n+                self ^ Self::splat(rhs)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn bitxor(self, rhs: $name<LANES>) -> Self::Output {\n+                $name::<LANES>::splat(self) ^ rhs\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::Not for $name<LANES> {\n+            type Output = $name<LANES>;\n+            #[inline]\n+            fn not(self) -> Self::Output {\n+                Self(!self.0)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES> {\n+            #[inline]\n+            fn bitand_assign(&mut self, rhs: Self) {\n+                self.0 &= rhs.0;\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES> {\n+            #[inline]\n+            fn bitand_assign(&mut self, rhs: bool) {\n+                *self &= Self::splat(rhs);\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES> {\n+            #[inline]\n+            fn bitor_assign(&mut self, rhs: Self) {\n+                self.0 |= rhs.0;\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES> {\n+            #[inline]\n+            fn bitor_assign(&mut self, rhs: bool) {\n+                *self |= Self::splat(rhs);\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES> {\n+            #[inline]\n+            fn bitxor_assign(&mut self, rhs: Self) {\n+                self.0 ^= rhs.0;\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES> {\n+            #[inline]\n+            fn bitxor_assign(&mut self, rhs: bool) {\n+                *self ^= Self::splat(rhs);\n+            }\n+        }\n+    }\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI8](crate::SimdI8), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMask8<const LANES: usize>(crate::SimdI8<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI16](crate::SimdI16), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMask16<const LANES: usize>(crate::SimdI16<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI32](crate::SimdI32), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMask32<const LANES: usize>(crate::SimdI32<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI64](crate::SimdI64), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMask64<const LANES: usize>(crate::SimdI64<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI128](crate::SimdI128), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMask128<const LANES: usize>(crate::SimdI64<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdIsize](crate::SimdIsize), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdMaskSize<const LANES: usize>(crate::SimdI64<LANES>);\n+}"}, {"sha": "eac5178512e52f894075ffed57011319e4599088", "filename": "crates/core_simd/src/masks/full_masks/mod.rs", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/1b0c23194829da3a75e641ff0424986cbeb5ff9e/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1b0c23194829da3a75e641ff0424986cbeb5ff9e/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs?ref=1b0c23194829da3a75e641ff0424986cbeb5ff9e", "patch": "@@ -1,205 +0,0 @@\n-//! Masks that take up full SIMD vector registers.\n-\n-/// The error type returned when converting an integer to a mask fails.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromMaskError(());\n-\n-impl core::fmt::Display for TryFromMaskError {\n-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        write!(f, \"mask vector must have all bits set or unset in each lane\")\n-    }\n-}\n-\n-macro_rules! define_mask {\n-    { $(#[$attr:meta])* struct $name:ident<const $lanes:ident: usize>($type:ty); } => {\n-        $(#[$attr])*\n-        #[derive(Copy, Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n-        #[repr(transparent)]\n-        pub struct $name<const $lanes: usize>($type);\n-\n-        delegate_ops_to_inner! { $name }\n-\n-        impl<const $lanes: usize> $name<$lanes> {\n-            /// Construct a mask by setting all lanes to the given value.\n-            pub fn splat(value: bool) -> Self {\n-                Self(<$type>::splat(\n-                    if value {\n-                        -1\n-                    } else {\n-                        0\n-                    }\n-                ))\n-            }\n-\n-            /// Tests the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn test(&self, lane: usize) -> bool {\n-                self.0[lane] == -1\n-            }\n-\n-            /// Sets the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn set(&mut self, lane: usize, value: bool) {\n-                self.0[lane] = if value {\n-                    -1\n-                } else {\n-                    0\n-                }\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::convert::From<bool> for $name<$lanes> {\n-            fn from(value: bool) -> Self {\n-                Self::splat(value)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::convert::TryFrom<$type> for $name<$lanes> {\n-            type Error = TryFromMaskError;\n-            fn try_from(value: $type) -> Result<Self, Self::Error> {\n-                if value.as_slice().iter().all(|x| *x == 0 || *x == -1) {\n-                    Ok(Self(value))\n-                } else {\n-                    Err(TryFromMaskError(()))\n-                }\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for $type {\n-            fn from(value: $name<$lanes>) -> Self {\n-                value.0\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                f.debug_list()\n-                    .entries((0..LANES).map(|lane| self.test(lane)))\n-                    .finish()\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::Binary for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Binary::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::Octal for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Octal::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::LowerHex for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::LowerHex::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::UpperHex for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::UpperHex::fmt(&self.0, f)\n-            }\n-        }\n-    }\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdI8](crate::SimdI8), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdI8Mask<const LANES: usize>(crate::SimdI8<LANES>);\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdI16](crate::SimdI16), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdI16Mask<const LANES: usize>(crate::SimdI16<LANES>);\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdI32](crate::SimdI32), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdI32Mask<const LANES: usize>(crate::SimdI32<LANES>);\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdI64](crate::SimdI64), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdI64Mask<const LANES: usize>(crate::SimdI64<LANES>);\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdI128](crate::SimdI128), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdI128Mask<const LANES: usize>(crate::SimdI64<LANES>);\n-}\n-\n-define_mask! {\n-    /// A mask equivalent to [SimdIsize](crate::SimdIsize), where all bits in the lane must be either set\n-    /// or unset.\n-    struct SimdIsizeMask<const LANES: usize>(crate::SimdI64<LANES>);\n-}\n-\n-macro_rules! implement_mask_ext {\n-    { $($vector:ident => $mask:ident,)* } => {\n-        $(\n-            impl<const LANES: usize> crate::masks::MaskExt<$mask<LANES>> for crate::$vector<LANES> {\n-                #[inline]\n-                fn lanes_eq(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_eq(self, other) }\n-                }\n-\n-                #[inline]\n-                fn lanes_ne(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_ne(self, other) }\n-                }\n-\n-                #[inline]\n-                fn lanes_lt(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_lt(self, other) }\n-                }\n-\n-                #[inline]\n-                fn lanes_gt(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_gt(self, other) }\n-                }\n-\n-                #[inline]\n-                fn lanes_le(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_le(self, other) }\n-                }\n-\n-                #[inline]\n-                fn lanes_ge(&self, other: &Self) -> $mask<LANES> {\n-                    unsafe { crate::intrinsics::simd_ge(self, other) }\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-implement_mask_ext! {\n-    SimdI8 => SimdI8Mask,\n-    SimdI16 => SimdI16Mask,\n-    SimdI32 => SimdI32Mask,\n-    SimdI64 => SimdI64Mask,\n-    SimdI128 => SimdI128Mask,\n-    SimdIsize => SimdIsizeMask,\n-\n-    SimdU8 => SimdI8Mask,\n-    SimdU16 => SimdI16Mask,\n-    SimdU32 => SimdI32Mask,\n-    SimdU64 => SimdI64Mask,\n-    SimdU128 => SimdI128Mask,\n-    SimdUsize => SimdIsizeMask,\n-\n-    SimdF32 => SimdI32Mask,\n-    SimdF64 => SimdI64Mask,\n-}"}, {"sha": "e51052f53f2f573b42380fafa814c39428c39353", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 141, "deletions": 129, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a", "patch": "@@ -1,310 +1,322 @@\n //! Types and traits associated with masking lanes of vectors.\n #![allow(non_camel_case_types)]\n \n-/// Implements bitwise ops on mask types by delegating the operators to the inner type.\n-macro_rules! delegate_ops_to_inner {\n-    { $name:ident } => {\n-        impl<const LANES: usize> core::ops::BitAnd for $name<LANES> {\n+mod full_masks;\n+pub use full_masks::*;\n+\n+mod bitmask;\n+pub use bitmask::*;\n+\n+macro_rules! define_opaque_mask {\n+    {\n+        $(#[$attr:meta])*\n+        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n+    } => {\n+        $(#[$attr])*\n+        #[allow(non_camel_case_types)]\n+        pub struct $name<const $lanes: usize>($inner_ty) where BitMask<LANES>: LanesAtMost64;\n+\n+        impl<const $lanes: usize> $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            /// Construct a mask by setting all lanes to the given value.\n+            pub fn splat(value: bool) -> Self {\n+                Self(<$inner_ty>::splat(value))\n+            }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn test(&self, lane: usize) -> bool {\n+                self.0.test(lane)\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn set(&mut self, lane: usize, value: bool) {\n+                self.0.set(lane, value);\n+            }\n+        }\n+\n+        impl<const $lanes: usize> From<BitMask<$lanes>> for $name<$lanes>\n+        where\n+            BitMask<$lanes>: LanesAtMost64,\n+        {\n+            fn from(value: BitMask<$lanes>) -> Self {\n+                Self(value.into())\n+            }\n+        }\n+\n+        impl<const $lanes: usize> From<$name<$lanes>> for crate::BitMask<$lanes>\n+        where\n+            BitMask<$lanes>: LanesAtMost64,\n+        {\n+            fn from(value: $name<$lanes>) -> Self {\n+                value.0.into()\n+            }\n+        }\n+\n+        impl<const $lanes: usize> From<$inner_ty> for $name<$lanes>\n+        where\n+            BitMask<$lanes>: LanesAtMost64,\n+        {\n+            fn from(value: $inner_ty) -> Self {\n+                Self(value)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> From<$name<$lanes>> for $inner_ty\n+        where\n+            BitMask<$lanes>: LanesAtMost64,\n+        {\n+            fn from(value: $name<$lanes>) -> Self {\n+                value.0\n+            }\n+        }\n+\n+        impl<const $lanes: usize> Copy for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {}\n+\n+        impl<const $lanes: usize> Clone for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            #[inline]\n+            fn clone(&self) -> Self {\n+                *self\n+            }\n+        }\n+\n+        impl<const $lanes: usize> Default for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            #[inline]\n+            fn default() -> Self {\n+                Self::splat(false)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> PartialEq for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            #[inline]\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n+        }\n+\n+        impl<const $lanes: usize> PartialOrd for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            #[inline]\n+            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+                self.0.partial_cmp(&other.0)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> where BitMask<$lanes>: LanesAtMost64 {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Debug::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const LANES: usize> core::ops::BitAnd for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitand(self, rhs: Self) -> Self {\n                 Self(self.0 & rhs.0)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitand(self, rhs: bool) -> Self {\n                 self & Self::splat(rhs)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool {\n+        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool where BitMask<LANES>: LanesAtMost64 {\n             type Output = $name<LANES>;\n             #[inline]\n             fn bitand(self, rhs: $name<LANES>) -> $name<LANES> {\n                 $name::<LANES>::splat(self) & rhs\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOr for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitOr for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitor(self, rhs: Self) -> Self {\n                 Self(self.0 | rhs.0)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitor(self, rhs: bool) -> Self {\n                 self | Self::splat(rhs)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool {\n+        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool where BitMask<LANES>: LanesAtMost64 {\n             type Output = $name<LANES>;\n             #[inline]\n             fn bitor(self, rhs: $name<LANES>) -> $name<LANES> {\n                 $name::<LANES>::splat(self) | rhs\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitXor for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitxor(self, rhs: Self) -> Self::Output {\n                 Self(self.0 ^ rhs.0)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = Self;\n             #[inline]\n             fn bitxor(self, rhs: bool) -> Self::Output {\n                 self ^ Self::splat(rhs)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool {\n+        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool where BitMask<LANES>: LanesAtMost64 {\n             type Output = $name<LANES>;\n             #[inline]\n             fn bitxor(self, rhs: $name<LANES>) -> Self::Output {\n                 $name::<LANES>::splat(self) ^ rhs\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::Not for $name<LANES> {\n+        impl<const LANES: usize> core::ops::Not for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             type Output = $name<LANES>;\n             #[inline]\n             fn not(self) -> Self::Output {\n                 Self(!self.0)\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n                 self.0 &= rhs.0;\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n                 *self &= Self::splat(rhs);\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n                 self.0 |= rhs.0;\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n                 *self |= Self::splat(rhs);\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n                 self.0 ^= rhs.0;\n             }\n         }\n \n-        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES> {\n+        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES> where BitMask<LANES>: LanesAtMost64 {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n                 *self ^= Self::splat(rhs);\n             }\n         }\n-    }\n-}\n-\n-pub mod full_masks;\n-\n-macro_rules! define_opaque_mask {\n-    {\n-        $(#[$attr:meta])*\n-        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n-    } => {\n-        $(#[$attr])*\n-        #[allow(non_camel_case_types)]\n-        pub struct $name<const $lanes: usize>($inner_ty);\n-\n-        delegate_ops_to_inner! { $name }\n-\n-        impl<const $lanes: usize> $name<$lanes> {\n-            /// Construct a mask by setting all lanes to the given value.\n-            pub fn splat(value: bool) -> Self {\n-                Self(<$inner_ty>::splat(value))\n-            }\n-\n-            /// Tests the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn test(&self, lane: usize) -> bool {\n-                self.0.test(lane)\n-            }\n-\n-            /// Sets the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn set(&mut self, lane: usize, value: bool) {\n-                self.0.set(lane, value);\n-            }\n-        }\n-\n-        impl<const $lanes: usize> Copy for $name<$lanes> {}\n-\n-        impl<const $lanes: usize> Clone for $name<$lanes> {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                *self\n-            }\n-        }\n-\n-        impl<const $lanes: usize> Default for $name<$lanes> {\n-            #[inline]\n-            fn default() -> Self {\n-                Self::splat(false)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> PartialEq for $name<$lanes> {\n-            #[inline]\n-            fn eq(&self, other: &Self) -> bool {\n-                self.0 == other.0\n-            }\n-        }\n-\n-        impl<const $lanes: usize> PartialOrd for $name<$lanes> {\n-            #[inline]\n-            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-                self.0.partial_cmp(&other.0)\n-            }\n-        }\n-\n-        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Debug::fmt(&self.0, f)\n-            }\n-        }\n     };\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 8-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask8<const LANES: usize>(full_masks::SimdI8Mask<LANES>);\n+    struct Mask8<const LANES: usize>(SimdMask8<LANES>);\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 16-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask16<const LANES: usize>(full_masks::SimdI16Mask<LANES>);\n+    struct Mask16<const LANES: usize>(SimdMask16<LANES>);\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 32-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask32<const LANES: usize>(full_masks::SimdI32Mask<LANES>);\n+    struct Mask32<const LANES: usize>(SimdMask32<LANES>);\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 64-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask64<const LANES: usize>(full_masks::SimdI64Mask<LANES>);\n+    struct Mask64<const LANES: usize>(SimdMask64<LANES>);\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 128-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct Mask128<const LANES: usize>(full_masks::SimdI128Mask<LANES>);\n+    struct Mask128<const LANES: usize>(SimdMask128<LANES>);\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` pointer-width elements.\n     ///\n     /// The layout of this type is unspecified.\n-    struct MaskSize<const LANES: usize>(full_masks::SimdIsizeMask<LANES>);\n-}\n-\n-/// Mask-related operations using a particular mask layout.\n-pub trait MaskExt<Mask> {\n-    /// Test if each lane is equal to the corresponding lane in `other`.\n-    fn lanes_eq(&self, other: &Self) -> Mask;\n-\n-    /// Test if each lane is not equal to the corresponding lane in `other`.\n-    fn lanes_ne(&self, other: &Self) -> Mask;\n-\n-    /// Test if each lane is less than the corresponding lane in `other`.\n-    fn lanes_lt(&self, other: &Self) -> Mask;\n-\n-    /// Test if each lane is greater than the corresponding lane in `other`.\n-    fn lanes_gt(&self, other: &Self) -> Mask;\n-\n-    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n-    fn lanes_le(&self, other: &Self) -> Mask;\n-\n-    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n-    fn lanes_ge(&self, other: &Self) -> Mask;\n+    struct MaskSize<const LANES: usize>(SimdMaskSize<LANES>);\n }\n \n macro_rules! implement_mask_ops {\n     { $($vector:ident => $mask:ident,)* } => {\n         $(\n-            impl<const LANES: usize> crate::$vector<LANES> {\n+            impl<const LANES: usize> crate::$vector<LANES> where BitMask<LANES>: LanesAtMost64 {\n                 /// Test if each lane is equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_eq(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_eq(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_eq(self, other)) }\n                 }\n \n                 /// Test if each lane is not equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_ne(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_ne(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_ne(self, other)) }\n                 }\n \n                 /// Test if each lane is less than the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_lt(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_lt(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_lt(self, other)) }\n                 }\n \n                 /// Test if each lane is greater than the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_gt(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_gt(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_gt(self, other)) }\n                 }\n \n                 /// Test if each lane is less than or equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_le(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_le(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_le(self, other)) }\n                 }\n \n                 /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n                 #[inline]\n                 pub fn lanes_ge(&self, other: &Self) -> $mask<LANES> {\n-                    $mask(MaskExt::lanes_ge(self, other))\n+                    unsafe { $mask(crate::intrinsics::simd_ge(self, other)) }\n                 }\n             }\n         )*"}, {"sha": "03a835b9c66f798839eef050d493200a212fbf3b", "filename": "crates/core_simd/tests/masks.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=8aa7ba7d4c1ac9b9e58969dc1558b29e9b02a48a", "patch": "@@ -0,0 +1,70 @@\n+use core::convert::TryFrom;\n+use core_simd::{BitMask, Mask8, SimdI8, SimdMask8};\n+\n+#[cfg(target_arch = \"wasm32\")]\n+use wasm_bindgen_test::*;\n+\n+#[cfg(target_arch = \"wasm32\")]\n+wasm_bindgen_test_configure!(run_in_browser);\n+\n+#[test]\n+#[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+fn mask_format_round_trip() {\n+    let ints = SimdI8::from_array([-1, 0, 0, -1]);\n+\n+    let simd_mask = SimdMask8::try_from(ints).unwrap();\n+\n+    let bitmask = BitMask::from(simd_mask);\n+\n+    let opaque_mask = Mask8::from(bitmask);\n+\n+    let simd_mask_returned = SimdMask8::from(opaque_mask);\n+\n+    let ints_returned = SimdI8::from(simd_mask_returned);\n+\n+    assert_eq!(ints_returned, ints);\n+}\n+\n+macro_rules! test_mask_api {\n+    { $name:ident } => {\n+        #[allow(non_snake_case)]\n+        mod $name {\n+            #[cfg(target_arch = \"wasm32\")]\n+            use wasm_bindgen_test::*;\n+\n+            #[test]\n+            #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n+            fn set_and_test() {\n+                let values = [true, false, false, true, false, false, true, false];\n+                let mut mask = core_simd::$name::<8>::splat(false);\n+                for (lane, value) in values.iter().copied().enumerate() {\n+                    mask.set(lane, value);\n+                }\n+                for (lane, value) in values.iter().copied().enumerate() {\n+                    assert_eq!(mask.test(lane), value);\n+                }\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn set_invalid_lane() {\n+                let mut mask = core_simd::$name::<8>::splat(false);\n+                mask.set(8, true);\n+                let _ = mask;\n+            }\n+\n+            #[test]\n+            #[should_panic]\n+            fn test_invalid_lane() {\n+                let mask = core_simd::$name::<8>::splat(false);\n+                let _ = mask.test(8);\n+            }\n+        }\n+    }\n+}\n+\n+mod mask_api {\n+    test_mask_api! { Mask8 }\n+    test_mask_api! { SimdMask8 }\n+    test_mask_api! { BitMask }\n+}"}]}