{"sha": "f191f924214aa1dcd342ada1d99775ccbb01ddd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxOTFmOTI0MjE0YWExZGNkMzQyYWRhMWQ5OTc3NWNjYmIwMWRkZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-24T13:50:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-24T13:50:40Z"}, "message": "Auto merge of #24758 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #24523, #24698, #24699, #24700, #24706, #24717, #24718, #24721, #24727\n- Failed merges:", "tree": {"sha": "aaba16e5f6fd64f9107b81b0c978914313f63b93", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaba16e5f6fd64f9107b81b0c978914313f63b93"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f191f924214aa1dcd342ada1d99775ccbb01ddd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f191f924214aa1dcd342ada1d99775ccbb01ddd7", "html_url": "https://github.com/rust-lang/rust/commit/f191f924214aa1dcd342ada1d99775ccbb01ddd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f191f924214aa1dcd342ada1d99775ccbb01ddd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d439b41777103b8b349635e68e9ccd3648aabc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d439b41777103b8b349635e68e9ccd3648aabc2", "html_url": "https://github.com/rust-lang/rust/commit/9d439b41777103b8b349635e68e9ccd3648aabc2"}, {"sha": "1447ee4c2031cfc0950b1bf0f658055e7a86e0c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1447ee4c2031cfc0950b1bf0f658055e7a86e0c2", "html_url": "https://github.com/rust-lang/rust/commit/1447ee4c2031cfc0950b1bf0f658055e7a86e0c2"}], "stats": {"total": 101, "additions": 71, "deletions": 30}, "files": [{"sha": "1cedbf299c327949f370b08dc2bda99e5467591b", "filename": "src/doc/reference.md", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=f191f924214aa1dcd342ada1d99775ccbb01ddd7", "patch": "@@ -271,7 +271,7 @@ cases mentioned in [Number literals](#number-literals) below.\n ##### Suffixes\n | Integer | Floating-point |\n |---------|----------------|\n-| `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `is` (`isize`), `us` (`usize`) | `f32`, `f64` |\n+| `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `isize`, `usize` | `f32`, `f64` |\n \n #### Character and string literals\n \n@@ -738,15 +738,26 @@ Rust syntax is restricted in two ways:\n \n # Crates and source files\n \n-Rust is a *compiled* language. Its semantics obey a *phase distinction* between\n-compile-time and run-time. Those semantic rules that have a *static\n+Although Rust, like any other language, can be implemented by an interpreter as\n+well as a compiler, the only existing implementation is a compiler &mdash;\n+from now on referred to as *the* Rust compiler &mdash; and the language has\n+always been designed to be compiled. For these reasons, this section assumes a\n+compiler.\n+\n+Rust's semantics obey a *phase distinction* between compile-time and\n+run-time.[^phase-distinction] Those semantic rules that have a *static\n interpretation* govern the success or failure of compilation. Those semantics\n that have a *dynamic interpretation* govern the behavior of the program at\n run-time.\n \n+[^phase-distinction]: This distinction would also exist in an interpreter.\n+    Static checks like syntactic analysis, type checking, and lints should\n+    happen before the program is executed regardless of when it is executed.\n+\n The compilation model centers on artifacts called _crates_. Each compilation\n processes a single crate in source form, and if successful, produces a single\n-crate in binary form: either an executable or a library.[^cratesourcefile]\n+crate in binary form: either an executable or some sort of\n+library.[^cratesourcefile]\n \n [^cratesourcefile]: A crate is somewhat analogous to an *assembly* in the\n     ECMA-335 CLI model, a *library* in the SML/NJ Compilation Manager, a *unit*\n@@ -767,21 +778,25 @@ extension `.rs`.\n A Rust source file describes a module, the name and location of which &mdash;\n in the module tree of the current crate &mdash; are defined from outside the\n source file: either by an explicit `mod_item` in a referencing source file, or\n-by the name of the crate itself.\n+by the name of the crate itself. Every source file is a module, but not every\n+module needs its own source file: [module definitions](#modules) can be nested\n+within one file.\n \n Each source file contains a sequence of zero or more `item` definitions, and\n-may optionally begin with any number of `attributes` that apply to the\n-containing module. Attributes on the anonymous crate module define important\n-metadata that influences the behavior of the compiler.\n+may optionally begin with any number of [attributes](#Items and attributes)\n+that apply to the containing module, most of which influence the behavior of\n+the compiler. The anonymous crate module can have additional attributes that\n+apply to the crate as a whole.\n \n ```no_run\n-// Crate name\n+// Specify the crate name.\n #![crate_name = \"projx\"]\n \n-// Specify the output type\n+// Specify the type of output artifact.\n #![crate_type = \"lib\"]\n \n-// Turn on a warning\n+// Turn on a warning.\n+// This can be done in any module, not just the anonymous crate module.\n #![warn(non_camel_case_types)]\n ```\n "}, {"sha": "7ce74e86fef63450f2cd002d2aecec07a7dcd7eb", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=f191f924214aa1dcd342ada1d99775ccbb01ddd7", "patch": "@@ -7,7 +7,6 @@\n * [Learn Rust](learn-rust.md)\n * [Effective Rust](effective-rust.md)\n     * [The Stack and the Heap](the-stack-and-the-heap.md)\n-    * [Debug and Display](debug-and-display.md)\n     * [Testing](testing.md)\n     * [Conditional Compilation](conditional-compilation.md)\n     * [Documentation](documentation.md)"}, {"sha": "918f4c440ac32d5901d65a8d9710d08c4403f062", "filename": "src/doc/trpl/debug-and-display.md", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d439b41777103b8b349635e68e9ccd3648aabc2/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md", "raw_url": "https://github.com/rust-lang/rust/raw/9d439b41777103b8b349635e68e9ccd3648aabc2/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdebug-and-display.md?ref=9d439b41777103b8b349635e68e9ccd3648aabc2", "patch": "@@ -1,3 +0,0 @@\n-% Debug and Display\n-\n-Coming soon!"}, {"sha": "ec84ef7986a43b8b8c327954174c566ee6a90548", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=f191f924214aa1dcd342ada1d99775ccbb01ddd7", "patch": "@@ -80,7 +80,7 @@ impl<T> Clone for Slice<T> {\n /// `TraitObject` is guaranteed to match layouts, but it is not the\n /// type of trait objects (e.g. the fields are not directly accessible\n /// on a `&SomeTrait`) nor does it control that layout (changing the\n-/// definition will not change the layout of a `&SometTrait`). It is\n+/// definition will not change the layout of a `&SomeTrait`). It is\n /// only designed to be used by unsafe code that needs to manipulate\n /// the low-level details.\n ///"}, {"sha": "182405a640dbcfb2d506607c6c6194f355c5c06e", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=f191f924214aa1dcd342ada1d99775ccbb01ddd7", "patch": "@@ -75,11 +75,13 @@ the following is invalid as it requires the entire Option<String> to be moved\n into a variable called `op_string` while simultaneously requiring the inner\n String to be moved into a variable called `s`.\n \n+```\n let x = Some(\"s\".to_string());\n match x {\n     op_string @ Some(s) => ...\n     None => ...\n }\n+```\n \n See also Error 303.\n \"##,\n@@ -90,10 +92,12 @@ name is bound by move in a pattern, it should also be moved to wherever it is\n referenced in the pattern guard code. Doing so however would prevent the name\n from being available in the body of the match arm. Consider the following:\n \n+```\n match Some(\"hi\".to_string()) {\n     Some(s) if s.len() == 0 => // use s.\n     ...\n }\n+```\n \n The variable `s` has type String, and its use in the guard is as a variable of\n type String. The guard code effectively executes in a separate scope to the body\n@@ -102,11 +106,13 @@ become unavailable in the body of the arm. Although this example seems\n innocuous, the problem is most clear when considering functions that take their\n argument by value.\n \n+```\n match Some(\"hi\".to_string()) {\n     Some(s) if { drop(s); false } => (),\n     Some(s) => // use s.\n     ...\n }\n+```\n \n The value would be dropped in the guard then become unavailable not only in the\n body of that arm but also in all subsequent arms! The solution is to bind by\n@@ -219,8 +225,10 @@ them yourself.\n You can build a free-standing crate by adding `#![no_std]` to the crate\n attributes:\n \n+```\n #![feature(no_std)]\n #![no_std]\n+```\n \n See also https://doc.rust-lang.org/book/no-stdlib.html\n \"##,\n@@ -236,11 +244,13 @@ mutex can be declared `static` as well.\n \n If you want to match against a `static`, consider using a guard instead:\n \n+```\n static FORTY_TWO: i32 = 42;\n match Some(42) {\n     Some(x) if x == FORTY_TWO => ...\n     ...\n }\n+```\n \"##,\n \n E0161: r##\"\n@@ -256,6 +266,7 @@ An if-let pattern attempts to match the pattern, and enters the body if the\n match was succesful. If the match is irrefutable (when it cannot fail to match),\n use a regular `let`-binding instead. For instance:\n \n+```\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n \n@@ -268,13 +279,15 @@ if let Irrefutable(x) = irr {\n // Try this instead:\n let Irrefutable(x) = irr;\n foo(x);\n+```\n \"##,\n \n E0165: r##\"\n A while-let pattern attempts to match the pattern, and enters the body if the\n match was succesful. If the match is irrefutable (when it cannot fail to match),\n use a regular `let`-binding inside a `loop` instead. For instance:\n \n+```\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n \n@@ -288,22 +301,27 @@ loop {\n     let Irrefutable(x) = irr;\n     ...\n }\n+```\n \"##,\n \n E0170: r##\"\n Enum variants are qualified by default. For example, given this type:\n \n+```\n enum Method {\n     GET,\n     POST\n }\n+```\n \n you would match it using:\n \n+```\n match m {\n     Method::GET => ...\n     Method::POST => ...\n }\n+```\n \n If you don't qualify the names, the code will bind new variables named \"GET\" and\n \"POST\" instead. This behavior is likely not what you want, so rustc warns when\n@@ -312,8 +330,10 @@ that happens.\n Qualified names are good practice, and most code works well with them. But if\n you prefer them unqualified, you can import the variants into scope:\n \n+```\n use Method::*;\n enum Method { GET, POST }\n+```\n \"##,\n \n E0267: r##\"\n@@ -333,7 +353,9 @@ E0296: r##\"\n This error indicates that the given recursion limit could not be parsed. Ensure\n that the value provided is a positive integer between quotes, like so:\n \n+```\n #![recursion_limit=\"1000\"]\n+```\n \"##,\n \n E0297: r##\"\n@@ -342,6 +364,7 @@ that a name will be extracted in all cases. Instead of pattern matching the\n loop variable, consider using a `match` or `if let` inside the loop body. For\n instance:\n \n+```\n // This fails because `None` is not covered.\n for Some(x) in xs {\n     ...\n@@ -361,6 +384,7 @@ for item in xs {\n         ...\n     }\n }\n+```\n \"##,\n \n E0301: r##\"\n@@ -370,11 +394,13 @@ on which the match depends in such a way, that the match would not be\n exhaustive. For instance, the following would not match any arm if mutable\n borrows were allowed:\n \n+```\n match Some(()) {\n     None => { },\n     option if option.take().is_none() => { /* impossible, option is `Some` */ },\n     Some(_) => { } // When the previous match failed, the option became `None`.\n }\n+```\n \"##,\n \n E0302: r##\"\n@@ -384,21 +410,24 @@ on which the match depends in such a way, that the match would not be\n exhaustive. For instance, the following would not match any arm if assignments\n were allowed:\n \n+```\n match Some(()) {\n     None => { },\n     option if { option = None; false } { },\n     Some(_) => { } // When the previous match failed, the option became `None`.\n }\n+```\n \"##,\n \n E0303: r##\"\n In certain cases it is possible for sub-bindings to violate memory safety.\n Updates to the borrow checker in a future version of Rust may remove this\n restriction, but for now patterns must be rewritten without sub-bindings.\n \n-// Before.\n-match Some(\"hi\".to_string()) {\n-    ref op_string_ref @ Some(ref s) => ...\n+```\n+// Code like this...\n+match Some(5) {\n+    ref op_num @ Some(num) => ...\n     None => ...\n }\n \n@@ -410,6 +439,7 @@ match Some(\"hi\".to_string()) {\n     }\n     None => ...\n }\n+```\n \n The `op_string_ref` binding has type &Option<&String> in both cases.\n "}, {"sha": "56cea50a502399cae7e4279f07eff6d2852b3c3f", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=f191f924214aa1dcd342ada1d99775ccbb01ddd7", "patch": "@@ -828,6 +828,9 @@\n     $(document).on(\"click\", \".collapse-toggle\", function() {\n         var toggle = $(this);\n         var relatedDoc = toggle.parent().next();\n+        if (relatedDoc.is(\".stability\")) {\n+            relatedDoc = relatedDoc.next();\n+        }\n         if (relatedDoc.is(\".docblock\")) {\n             if (relatedDoc.is(\":visible\")) {\n                 relatedDoc.slideUp({duration:'fast', easing:'linear'});\n@@ -848,9 +851,10 @@\n             .html(\"[<span class='inner'>-</span>]\");\n \n         $(\".method\").each(function() {\n-           if ($(this).next().is(\".docblock\")) {\n-               $(this).children().first().after(toggle.clone());\n-           }\n+            if ($(this).next().is(\".docblock\") ||\n+                ($(this).next().is(\".stability\") && $(this).next().next().is(\".docblock\"))) {\n+                    $(this).children().first().after(toggle.clone());\n+            }\n         });\n \n         var mainToggle ="}, {"sha": "d0f990eaf782a5d0c25c17e74ba62e8fd7296334", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=f191f924214aa1dcd342ada1d99775ccbb01ddd7", "patch": "@@ -40,14 +40,6 @@ impl Drop for DynamicLibrary {\n }\n \n impl DynamicLibrary {\n-    // FIXME (#12938): Until DST lands, we cannot decompose &str into\n-    // & and str, so we cannot usefully take ToCStr arguments by\n-    // reference (without forcing an additional & around &str). So we\n-    // are instead temporarily adding an instance for &Path, so that\n-    // we can take ToCStr as owned. When DST lands, the &Path instance\n-    // should be removed, and arguments bound by ToCStr should be\n-    // passed by reference. (Here: in the `open` method.)\n-\n     /// Lazily open a dynamic library. When passed None it gives a\n     /// handle to the calling process\n     pub fn open(filename: Option<&Path>) -> Result<DynamicLibrary, String> {"}, {"sha": "42fad701533b2b04ad1a228016738c8958c3e629", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f191f924214aa1dcd342ada1d99775ccbb01ddd7/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=f191f924214aa1dcd342ada1d99775ccbb01ddd7", "patch": "@@ -95,6 +95,8 @@ impl Write for StderrRaw {\n ///\n /// This handle implements the `Read` trait, but beware that concurrent reads\n /// of `Stdin` must be executed with care.\n+///\n+/// Created by the function `io::stdin()`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stdin {\n     inner: Arc<Mutex<BufReader<StdinRaw>>>,\n@@ -206,6 +208,8 @@ const OUT_MAX: usize = ::usize::MAX;\n /// Each handle shares a global buffer of data to be written to the standard\n /// output stream. Access is also synchronized via a lock and explicit control\n /// over locking is available via the `lock` method.\n+///\n+/// Created by the function `io::stdout()`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of"}]}