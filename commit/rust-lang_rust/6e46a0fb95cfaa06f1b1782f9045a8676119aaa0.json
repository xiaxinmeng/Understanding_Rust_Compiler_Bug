{"sha": "6e46a0fb95cfaa06f1b1782f9045a8676119aaa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNDZhMGZiOTVjZmFhMDZmMWIxNzgyZjkwNDVhODY3NjExOWFhYTA=", "commit": {"author": {"name": "jethrogb", "email": "github@jbeekman.nl", "date": "2015-12-13T19:40:27Z"}, "committer": {"name": "jethrogb", "email": "github@jbeekman.nl", "date": "2015-12-13T19:40:27Z"}, "message": "Make BinaryHeap Dijkstra example return Option", "tree": {"sha": "86e6e1f183b2405134c518e8b7ff3519bccca33a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86e6e1f183b2405134c518e8b7ff3519bccca33a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e46a0fb95cfaa06f1b1782f9045a8676119aaa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e46a0fb95cfaa06f1b1782f9045a8676119aaa0", "html_url": "https://github.com/rust-lang/rust/commit/6e46a0fb95cfaa06f1b1782f9045a8676119aaa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e46a0fb95cfaa06f1b1782f9045a8676119aaa0/comments", "author": {"login": "jethrogb", "id": 1132307, "node_id": "MDQ6VXNlcjExMzIzMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1132307?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jethrogb", "html_url": "https://github.com/jethrogb", "followers_url": "https://api.github.com/users/jethrogb/followers", "following_url": "https://api.github.com/users/jethrogb/following{/other_user}", "gists_url": "https://api.github.com/users/jethrogb/gists{/gist_id}", "starred_url": "https://api.github.com/users/jethrogb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jethrogb/subscriptions", "organizations_url": "https://api.github.com/users/jethrogb/orgs", "repos_url": "https://api.github.com/users/jethrogb/repos", "events_url": "https://api.github.com/users/jethrogb/events{/privacy}", "received_events_url": "https://api.github.com/users/jethrogb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jethrogb", "id": 1132307, "node_id": "MDQ6VXNlcjExMzIzMDc=", "avatar_url": "https://avatars.githubusercontent.com/u/1132307?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jethrogb", "html_url": "https://github.com/jethrogb", "followers_url": "https://api.github.com/users/jethrogb/followers", "following_url": "https://api.github.com/users/jethrogb/following{/other_user}", "gists_url": "https://api.github.com/users/jethrogb/gists{/gist_id}", "starred_url": "https://api.github.com/users/jethrogb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jethrogb/subscriptions", "organizations_url": "https://api.github.com/users/jethrogb/orgs", "repos_url": "https://api.github.com/users/jethrogb/repos", "events_url": "https://api.github.com/users/jethrogb/events{/privacy}", "received_events_url": "https://api.github.com/users/jethrogb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69adc883aa6d0660ba1a235a2cee56c5cffd38e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/69adc883aa6d0660ba1a235a2cee56c5cffd38e0", "html_url": "https://github.com/rust-lang/rust/commit/69adc883aa6d0660ba1a235a2cee56c5cffd38e0"}], "stats": {"total": 16, "additions": 8, "deletions": 8}, "files": [{"sha": "effd4ebb316725f1c42fea3f01741b2336a266e5", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e46a0fb95cfaa06f1b1782f9045a8676119aaa0/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e46a0fb95cfaa06f1b1782f9045a8676119aaa0/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=6e46a0fb95cfaa06f1b1782f9045a8676119aaa0", "patch": "@@ -66,7 +66,7 @@\n //! // to each node. This implementation isn't memory-efficient as it may leave duplicate\n //! // nodes in the queue. It also uses `usize::MAX` as a sentinel value,\n //! // for a simpler implementation.\n-//! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: usize, goal: usize) -> usize {\n+//! fn shortest_path(adj_list: &Vec<Vec<Edge>>, start: usize, goal: usize) -> Option<usize> {\n //!     // dist[node] = current shortest distance from `start` to `node`\n //!     let mut dist: Vec<_> = (0..adj_list.len()).map(|_| usize::MAX).collect();\n //!\n@@ -79,7 +79,7 @@\n //!     // Examine the frontier with lower cost nodes first (min-heap)\n //!     while let Some(State { cost, position }) = heap.pop() {\n //!         // Alternatively we could have continued to find all shortest paths\n-//!         if position == goal { return cost; }\n+//!         if position == goal { return Some(cost); }\n //!\n //!         // Important as we may have already found a better way\n //!         if cost > dist[position] { continue; }\n@@ -99,7 +99,7 @@\n //!     }\n //!\n //!     // Goal not reachable\n-//!     usize::MAX\n+//!     None\n //! }\n //!\n //! fn main() {\n@@ -140,11 +140,11 @@\n //!         // Node 4\n //!         vec![]];\n //!\n-//!     assert_eq!(shortest_path(&graph, 0, 1), 1);\n-//!     assert_eq!(shortest_path(&graph, 0, 3), 3);\n-//!     assert_eq!(shortest_path(&graph, 3, 0), 7);\n-//!     assert_eq!(shortest_path(&graph, 0, 4), 5);\n-//!     assert_eq!(shortest_path(&graph, 4, 0), usize::MAX);\n+//!     assert_eq!(shortest_path(&graph, 0, 1), Some(1));\n+//!     assert_eq!(shortest_path(&graph, 0, 3), Some(3));\n+//!     assert_eq!(shortest_path(&graph, 3, 0), Some(7));\n+//!     assert_eq!(shortest_path(&graph, 0, 4), Some(5));\n+//!     assert_eq!(shortest_path(&graph, 4, 0), None);\n //! }\n //! ```\n "}]}