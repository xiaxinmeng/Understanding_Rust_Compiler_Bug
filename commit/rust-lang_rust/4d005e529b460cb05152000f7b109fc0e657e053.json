{"sha": "4d005e529b460cb05152000f7b109fc0e657e053", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkMDA1ZTUyOWI0NjBjYjA1MTUyMDAwZjdiMTA5ZmMwZTY1N2UwNTM=", "commit": {"author": {"name": "Daiki Ihara", "email": "sasurau4@gmail.com", "date": "2021-06-25T13:14:42Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-01T09:11:57Z"}, "message": "Fix extract_function with macro arg", "tree": {"sha": "36045247c86905a6c8396c32767b3bc1a6be03c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36045247c86905a6c8396c32767b3bc1a6be03c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d005e529b460cb05152000f7b109fc0e657e053", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d005e529b460cb05152000f7b109fc0e657e053", "html_url": "https://github.com/rust-lang/rust/commit/4d005e529b460cb05152000f7b109fc0e657e053", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d005e529b460cb05152000f7b109fc0e657e053/comments", "author": {"login": "sasurau4", "id": 13580199, "node_id": "MDQ6VXNlcjEzNTgwMTk5", "avatar_url": "https://avatars.githubusercontent.com/u/13580199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sasurau4", "html_url": "https://github.com/sasurau4", "followers_url": "https://api.github.com/users/sasurau4/followers", "following_url": "https://api.github.com/users/sasurau4/following{/other_user}", "gists_url": "https://api.github.com/users/sasurau4/gists{/gist_id}", "starred_url": "https://api.github.com/users/sasurau4/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sasurau4/subscriptions", "organizations_url": "https://api.github.com/users/sasurau4/orgs", "repos_url": "https://api.github.com/users/sasurau4/repos", "events_url": "https://api.github.com/users/sasurau4/events{/privacy}", "received_events_url": "https://api.github.com/users/sasurau4/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "535f0726f18187574d47de1a4b78d0d54bc00de8", "url": "https://api.github.com/repos/rust-lang/rust/commits/535f0726f18187574d47de1a4b78d0d54bc00de8", "html_url": "https://github.com/rust-lang/rust/commit/535f0726f18187574d47de1a4b78d0d54bc00de8"}], "stats": {"total": 97, "additions": 69, "deletions": 28}, "files": [{"sha": "192403b15d77598f97fe8cfe617a3188af317fe1", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 64, "deletions": 28, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4d005e529b460cb05152000f7b109fc0e657e053/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d005e529b460cb05152000f7b109fc0e657e053/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=4d005e529b460cb05152000f7b109fc0e657e053", "patch": "@@ -2,7 +2,7 @@ use std::{hash::BuildHasherDefault, iter};\n \n use ast::make;\n use either::Either;\n-use hir::{HirDisplay, Local, Semantics, TypeInfo};\n+use hir::{HirDisplay, InFile, Local, Semantics, TypeInfo};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n     search::{FileReference, ReferenceAccess, SearchScope},\n@@ -17,7 +17,7 @@ use syntax::{\n         edit::{AstNodeEdit, IndentLevel},\n         AstNode,\n     },\n-    match_ast, ted,\n+    match_ast, ted, SyntaxElement,\n     SyntaxKind::{self, COMMENT},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, WalkEvent, T,\n };\n@@ -582,38 +582,45 @@ impl FunctionBody {\n         &self,\n         sema: &Semantics<RootDatabase>,\n     ) -> (FxIndexSet<Local>, Option<ast::SelfParam>) {\n-        // FIXME: currently usages inside macros are not found\n         let mut self_param = None;\n         let mut res = FxIndexSet::default();\n-        self.walk_expr(&mut |expr| {\n-            let name_ref = match expr {\n-                ast::Expr::PathExpr(path_expr) => {\n-                    path_expr.path().and_then(|it| it.as_single_name_ref())\n-                }\n-                _ => return,\n-            };\n-            if let Some(name_ref) = name_ref {\n-                if let Some(\n-                    NameRefClass::Definition(Definition::Local(local_ref))\n-                    | NameRefClass::FieldShorthand { local_ref, field_ref: _ },\n-                ) = NameRefClass::classify(sema, &name_ref)\n-                {\n-                    if local_ref.is_self(sema.db) {\n-                        match local_ref.source(sema.db).value {\n-                            Either::Right(it) => {\n-                                self_param.replace(it);\n-                            }\n-                            Either::Left(_) => {\n-                                stdx::never!(\n-                                    \"Local::is_self returned true, but source is IdentPat\"\n-                                );\n-                            }\n-                        }\n-                    } else {\n+        let mut cb = |name_ref: Option<_>| {\n+            let local_ref =\n+                match name_ref.and_then(|name_ref| NameRefClass::classify(sema, &name_ref)) {\n+                    Some(\n+                        NameRefClass::Definition(Definition::Local(local_ref))\n+                        | NameRefClass::FieldShorthand { local_ref, field_ref: _ },\n+                    ) => local_ref,\n+                    _ => return,\n+                };\n+            let InFile { file_id, value } = local_ref.source(sema.db);\n+            // locals defined inside macros are not relevant to us\n+            if !file_id.is_macro() {\n+                match value {\n+                    Either::Right(it) => {\n+                        self_param.replace(it);\n+                    }\n+                    Either::Left(_) => {\n                         res.insert(local_ref);\n                     }\n                 }\n             }\n+        };\n+        self.walk_expr(&mut |expr| match expr {\n+            ast::Expr::PathExpr(path_expr) => {\n+                cb(path_expr.path().and_then(|it| it.as_single_name_ref()))\n+            }\n+            ast::Expr::MacroCall(call) => {\n+                if let Some(tt) = call.token_tree() {\n+                    tt.syntax()\n+                        .children_with_tokens()\n+                        .flat_map(SyntaxElement::into_token)\n+                        .filter(|it| it.kind() == SyntaxKind::IDENT)\n+                        .flat_map(|t| sema.descend_into_macros_many(t))\n+                        .for_each(|t| cb(t.parent().and_then(ast::NameRef::cast)));\n+                }\n+            }\n+            _ => (),\n         });\n         (res, self_param)\n     }\n@@ -4155,6 +4162,35 @@ fn foo() {\n fn $0fun_name(y: &mut Foo) {\n     y.foo();\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn extract_with_macro_arg() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+macro_rules! m {\n+    ($val:expr) => { $val };\n+}\n+fn main() {\n+    let bar = \"bar\";\n+    $0m!(bar);$0\n+}\n+\"#,\n+            r#\"\n+macro_rules! m {\n+    ($val:expr) => { $val };\n+}\n+fn main() {\n+    let bar = \"bar\";\n+    fun_name(bar);\n+}\n+\n+fn $0fun_name(bar: &str) {\n+    m!(bar);\n+}\n \"#,\n         );\n     }"}, {"sha": "1c40de1e60064c0810eb8d20f4d864609a6f9446", "filename": "crates/syntax/src/ast/expr_ext.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4d005e529b460cb05152000f7b109fc0e657e053/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d005e529b460cb05152000f7b109fc0e657e053/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fexpr_ext.rs?ref=4d005e529b460cb05152000f7b109fc0e657e053", "patch": "@@ -77,6 +77,11 @@ impl ast::Expr {\n                 }\n                 // Don't skip subtree since we want to process the expression child next\n                 Some(ast::Stmt::ExprStmt(_)) => (),\n+                // This might be an expression\n+                Some(ast::Stmt::Item(ast::Item::MacroCall(mcall))) => {\n+                    cb(WalkEvent::Enter(ast::Expr::MacroCall(mcall)));\n+                    preorder.skip_subtree();\n+                }\n                 // skip inner items which might have their own expressions\n                 Some(ast::Stmt::Item(_)) => preorder.skip_subtree(),\n                 None => {"}]}