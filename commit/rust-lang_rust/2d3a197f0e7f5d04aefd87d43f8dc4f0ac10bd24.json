{"sha": "2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkM2ExOTdmMGU3ZjVkMDRhZWZkODdkNDNmOGRjNGYwYWMxMGJkMjQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-24T15:12:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-25T12:45:52Z"}, "message": "comment various region-related things better", "tree": {"sha": "72c09b4d30a8ab60af343de77bedc823749598c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72c09b4d30a8ab60af343de77bedc823749598c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24", "html_url": "https://github.com/rust-lang/rust/commit/2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7022ede9b338fcd7429977c4cd0d01ca76aecb5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7022ede9b338fcd7429977c4cd0d01ca76aecb5f", "html_url": "https://github.com/rust-lang/rust/commit/7022ede9b338fcd7429977c4cd0d01ca76aecb5f"}], "stats": {"total": 208, "additions": 60, "deletions": 148}, "files": [{"sha": "ca00aeaa0f4ab58a1fa14397ba43c96c53953db4", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 16, "deletions": 136, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24", "patch": "@@ -1,134 +1,9 @@\n-/*\n+/*!\n \n-Region resolution. This pass runs before typechecking and resolves region\n-names to the appropriate block.\n-\n-This seems to be as good a place as any to explain in detail how\n-region naming, representation, and type check works.\n-\n-### Naming and so forth\n-\n-We really want regions to be very lightweight to use. Therefore,\n-unlike other named things, the scopes for regions are not explicitly\n-declared: instead, they are implicitly defined.  Functions declare new\n-scopes: if the function is not a bare function, then as always it\n-inherits the names in scope from the outer scope.  Within a function\n-declaration, new names implicitly declare new region variables.  Outside\n-of function declarations, new names are illegal.  To make this more\n-concrete, here is an example:\n-\n-    fn foo(s: &a.S, t: &b.T) {\n-        let s1: &a.S = s; // a refers to the same a as in the decl\n-        let t1: &c.T = t; // illegal: cannot introduce new name here\n-    }\n-\n-The code in this file is what actually handles resolving these names.\n-It creates a couple of maps that map from the AST node representing a\n-region ptr type to the resolved form of its region parameter.  If new\n-names are introduced where they shouldn't be, then an error is\n-reported.\n-\n-If regions are not given an explicit name, then the behavior depends\n-a bit on the context.  Within a function declaration, all unnamed regions\n-are mapped to a single, anonymous parameter.  That is, a function like:\n-\n-    fn foo(s: &S) -> &S { s }\n-\n-is equivalent to a declaration like:\n-\n-    fn foo(s: &a.S) -> &a.S { s }\n-\n-Within a function body or other non-binding context, an unnamed region\n-reference is mapped to a fresh region variable whose value can be\n-inferred as normal.\n-\n-The resolved form of regions is `ty::region`.  Before I can explain\n-why this type is setup the way it is, I have to digress a little bit\n-into some ill-explained type theory.\n-\n-### Universal Quantification\n-\n-Regions are more complex than type parameters because, unlike type\n-parameters, they can be universally quantified within a type.  To put\n-it another way, you cannot (at least at the time of this writing) have\n-a variable `x` of type `fn<T>(T) -> T`.  You can have an *item* of\n-type `fn<T>(T) -> T`, but whenever it is referenced within a method,\n-that type parameter `T` is replaced with a concrete type *variable*\n-`$T`.  To make this more concrete, imagine this code:\n-\n-    fn identity<T>(x: T) -> T { x }\n-    let f = identity; // f has type fn($T) -> $T\n-    f(3u); // $T is bound to uint\n-    f(3);  // Type error\n-\n-You can see here that a type error will result because the type of `f`\n-(as opposed to the type of `identity`) is not universally quantified\n-over `$T`.  That's fancy math speak for saying that the type variable\n-`$T` refers to a specific type that may not yet be known, unlike the\n-type parameter `T` which refers to some type which will never be\n-known.\n-\n-Anyway, regions work differently.  If you have an item of type\n-`fn(&a.T) -> &a.T` and you reference it, its type remains the same:\n-only when the function *is called* is `&a` instantiated with a\n-concrete region variable.  This means you could call it twice and give\n-different values for `&a` each time.\n-\n-This more general form is possible for regions because they do not\n-impact code generation.  We do not need to monomorphize functions\n-differently just because they contain region pointers.  In fact, we\n-don't really do *anything* differently.\n-\n-### Representing regions; or, why do I care about all that?\n-\n-The point of this discussion is that the representation of regions\n-must distinguish between a *bound* reference to a region and a *free*\n-reference.  A bound reference is one which will be replaced with a\n-fresh type variable when the function is called, like the type\n-parameter `T` in `identity`.  They can only appear within function\n-types.  A free reference is a region that may not yet be concretely\n-known, like the variable `$T`.\n-\n-To see why we must distinguish them carefully, consider this program:\n-\n-    fn item1(s: &a.S) {\n-        let choose = fn@(s1: &a.S) -> &a.S {\n-            if some_cond { s } else { s1 }\n-        };\n-    }\n-\n-Here, the variable `s1: &a.S` that appears within the `fn@` is a free\n-reference to `a`.  That is, when you call `choose()`, you don't\n-replace `&a` with a fresh region variable, but rather you expect `s1`\n-to be in the same region as the parameter `s`.\n-\n-But in this program, this is not the case at all:\n-\n-    fn item2() {\n-        let identity = fn@(s1: &a.S) -> &a.S { s1 };\n-    }\n-\n-To distinguish between these two cases, `ty::region` contains two\n-variants: `re_bound` and `re_free`.  In `item1()`, the outer reference\n-to `&a` would be `re_bound(rid_param(\"a\", 0u))`, and the inner reference\n-would be `re_free(rid_param(\"a\", 0u))`.  In `item2()`, the inner reference\n-would be `re_bound(rid_param(\"a\", 0u))`.\n-\n-#### Implications for typeck\n-\n-In typeck, whenever we call a function, we must go over and replace\n-all references to `re_bound()` regions within its parameters with\n-fresh type variables (we do not, however, replace bound regions within\n-nested function types, as those nested functions have not yet been\n-called).\n-\n-Also, when we typecheck the *body* of an item, we must replace all\n-`re_bound` references with `re_free` references.  This means that the\n-region in the type of the argument `s` in `item1()` *within `item1()`*\n-is not `re_bound(re_param(\"a\", 0u))` but rather `re_free(re_param(\"a\",\n-0u))`.  This is because, for any particular *invocation of `item1()`*,\n-`&a` will be bound to some specific region, and hence it is no longer\n-bound.\n+This file actually contains two passes related to regions.  The first\n+pass builds up the `region_map`, which describes the parent links in\n+the region hierarchy.  The second pass infers which types must be\n+region parameterized.\n \n */\n \n@@ -153,10 +28,10 @@ type binding = {node_id: ast::node_id,\n                 name: ~str,\n                 br: ty::bound_region};\n \n-// Mapping from a block/expr/binding to the innermost scope that\n-// bounds its lifetime.  For a block/expression, this is the lifetime\n-// in which it will be evaluated.  For a binding, this is the lifetime\n-// in which is in scope.\n+/// Mapping from a block/expr/binding to the innermost scope that\n+/// bounds its lifetime.  For a block/expression, this is the lifetime\n+/// in which it will be evaluated.  For a binding, this is the lifetime\n+/// in which is in scope.\n type region_map = hashmap<ast::node_id, ast::node_id>;\n \n type ctxt = {\n@@ -198,8 +73,8 @@ type ctxt = {\n     parent: parent\n };\n \n-// Returns true if `subscope` is equal to or is lexically nested inside\n-// `superscope` and false otherwise.\n+/// Returns true if `subscope` is equal to or is lexically nested inside\n+/// `superscope` and false otherwise.\n fn scope_contains(region_map: region_map, superscope: ast::node_id,\n                   subscope: ast::node_id) -> bool {\n     let mut subscope = subscope;\n@@ -212,6 +87,9 @@ fn scope_contains(region_map: region_map, superscope: ast::node_id,\n     ret true;\n }\n \n+/// Finds the nearest common ancestor (if any) of two scopes.  That\n+/// is, finds the smallest scope which is greater than or equal to\n+/// both `scope_a` and `scope_b`.\n fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n                            scope_b: ast::node_id) -> option<ast::node_id> {\n \n@@ -262,6 +140,7 @@ fn nearest_common_ancestor(region_map: region_map, scope_a: ast::node_id,\n     }\n }\n \n+/// Extracts that current parent from cx, failing if there is none.\n fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n     alt cx.parent {\n       none {\n@@ -273,6 +152,7 @@ fn parent_id(cx: ctxt, span: span) -> ast::node_id {\n     }\n }\n \n+/// Records the current parent (if any) as the parent of `child_id`.\n fn record_parent(cx: ctxt, child_id: ast::node_id) {\n     alt cx.parent {\n       none { /* no-op */ }"}, {"sha": "af4974347367a71b566d39dd806790a7c6ea63d4", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 44, "deletions": 12, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=2d3a197f0e7f5d04aefd87d43f8dc4f0ac10bd24", "patch": "@@ -307,6 +307,13 @@ enum closure_kind {\n     ck_uniq,\n }\n \n+/// Innards of a function type:\n+///\n+/// - `purity` is the function's effect (pure, impure, unsafe).\n+/// - `proto` is the protocol (fn@, fn~, etc).\n+/// - `inputs` is the list of arguments and their modes.\n+/// - `output` is the return type.\n+/// - `ret_style`indicates whether the function returns a value or fails.\n type fn_ty = {purity: ast::purity,\n               proto: ast::proto,\n               inputs: ~[arg],\n@@ -315,13 +322,32 @@ type fn_ty = {purity: ast::purity,\n \n type param_ty = {idx: uint, def_id: def_id};\n \n-// See discussion at head of region.rs\n+/// Representation of regions:\n enum region {\n+    /// Bound regions are found (primarily) in function types.  They indicate\n+    /// region parameters that have yet to be replaced with actual regions\n+    /// (analogous to type parameters, except that due to the monomorphic\n+    /// nature of our type system, bound type parameters are always replaced\n+    /// with fresh type variables whenever an item is referenced, so type\n+    /// parameters only appear \"free\" in types.  Regions in contrast can\n+    /// appear free or bound.).  When a function is called, all bound regions\n+    /// tied to that function's node-id are replaced with fresh region\n+    /// variables whose value is then inferred.\n     re_bound(bound_region),\n+\n+    /// When checking a function body, the types of all arguments and so forth\n+    /// that refer to bound region parameters are modified to refer to free\n+    /// region parameters.\n     re_free(node_id, bound_region),\n+\n+    /// A concrete region naming some expression within the current function.\n     re_scope(node_id),\n+\n+    /// Static data that has an \"infinite\" lifetime.\n+    re_static,\n+\n+    /// A region variable.  Should not exist after typeck.\n     re_var(region_vid),\n-    re_static // effectively `top` in the region lattice\n }\n \n enum bound_region {\n@@ -332,16 +358,22 @@ enum bound_region {\n \n type opt_region = option<region>;\n \n-// The type substs represents the kinds of things that can be substituted into\n-// a type.  There may be at most one region parameter (self_r), along with\n-// some number of type parameters (tps).\n-//\n-// The region parameter is present on nominative types (enums, resources,\n-// classes) that are declared as having a region parameter.  If the type is\n-// declared as `enum foo&`, then self_r should always be non-none.  If the\n-// type is declared as `enum foo`, then self_r will always be none.  In the\n-// latter case, typeck::ast_ty_to_ty() will reject any references to `&T` or\n-// `&self.T` within the type and report an error.\n+/// The type substs represents the kinds of things that can be substituted to\n+/// convert a polytype into a monotype.  Note however that substituting bound\n+/// regions other than `self` is done through a different mechanism.\n+///\n+/// `tps` represents the type parameters in scope.  They are indexed according\n+/// to the order in which they were declared.\n+///\n+/// `self_r` indicates the region parameter `self` that is present on nominal\n+/// types (enums, classes) declared as having a region parameter.  `self_r`\n+/// should always be none for types that are not region-parameterized and\n+/// some(_) for types that are.  The only bound region parameter that should\n+/// appear within a region-parameterized type is `self`.\n+///\n+/// `self_ty` is the type to which `self` should be remapped, if any.  The\n+/// `self` type is rather funny in that it can only appear on interfaces and\n+/// is always substituted away to the implementing type for an interface.\n type substs = {\n     self_r: opt_region,\n     self_ty: option<ty::t>,"}]}