{"sha": "619fd96868b2cc83b7f205ff11ff897aebb5ef93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxOWZkOTY4NjhiMmNjODNiN2YyMDVmZjExZmY4OTdhZWJiNWVmOTM=", "commit": {"author": {"name": "Dominik Stolz", "email": "d.stolz@tum.de", "date": "2021-02-06T13:15:49Z"}, "committer": {"name": "Dominik Stolz", "email": "d.stolz@tum.de", "date": "2021-07-21T08:49:11Z"}, "message": "Add PidFd type and seal traits\n\nImprove docs\n\nSplit do_fork into two\n\nMake do_fork unsafe\n\nAdd target attribute to create_pidfd field in Command\n\nAdd method to get create_pidfd value", "tree": {"sha": "56ad0f7f11c5e34f85fec0cf659b29981943c4d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56ad0f7f11c5e34f85fec0cf659b29981943c4d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/619fd96868b2cc83b7f205ff11ff897aebb5ef93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/619fd96868b2cc83b7f205ff11ff897aebb5ef93", "html_url": "https://github.com/rust-lang/rust/commit/619fd96868b2cc83b7f205ff11ff897aebb5ef93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/619fd96868b2cc83b7f205ff11ff897aebb5ef93/comments", "author": {"login": "voidc", "id": 5302792, "node_id": "MDQ6VXNlcjUzMDI3OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5302792?v=4", "gravatar_id": "", "url": "https://api.github.com/users/voidc", "html_url": "https://github.com/voidc", "followers_url": "https://api.github.com/users/voidc/followers", "following_url": "https://api.github.com/users/voidc/following{/other_user}", "gists_url": "https://api.github.com/users/voidc/gists{/gist_id}", "starred_url": "https://api.github.com/users/voidc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/voidc/subscriptions", "organizations_url": "https://api.github.com/users/voidc/orgs", "repos_url": "https://api.github.com/users/voidc/repos", "events_url": "https://api.github.com/users/voidc/events{/privacy}", "received_events_url": "https://api.github.com/users/voidc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "voidc", "id": 5302792, "node_id": "MDQ6VXNlcjUzMDI3OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/5302792?v=4", "gravatar_id": "", "url": "https://api.github.com/users/voidc", "html_url": "https://github.com/voidc", "followers_url": "https://api.github.com/users/voidc/followers", "following_url": "https://api.github.com/users/voidc/following{/other_user}", "gists_url": "https://api.github.com/users/voidc/gists{/gist_id}", "starred_url": "https://api.github.com/users/voidc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/voidc/subscriptions", "organizations_url": "https://api.github.com/users/voidc/orgs", "repos_url": "https://api.github.com/users/voidc/repos", "events_url": "https://api.github.com/users/voidc/events{/privacy}", "received_events_url": "https://api.github.com/users/voidc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef03de2e6a4c28543941a228e0c42bcf2dc61df6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef03de2e6a4c28543941a228e0c42bcf2dc61df6", "html_url": "https://github.com/rust-lang/rust/commit/ef03de2e6a4c28543941a228e0c42bcf2dc61df6"}], "stats": {"total": 395, "additions": 282, "deletions": 113}, "files": [{"sha": "435c0227c7ecada5b9445ea17176b07441e64a16", "filename": "library/std/src/os/linux/process.rs", "status": "modified", "additions": 124, "deletions": 22, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/619fd96868b2cc83b7f205ff11ff897aebb5ef93/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619fd96868b2cc83b7f205ff11ff897aebb5ef93/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Flinux%2Fprocess.rs?ref=619fd96868b2cc83b7f205ff11ff897aebb5ef93", "patch": "@@ -2,40 +2,142 @@\n \n #![unstable(feature = \"linux_pidfd\", issue = \"none\")]\n \n-use crate::process;\n-use crate::sys_common::AsInnerMut;\n use crate::io::Result;\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::process;\n+use crate::sys::fd::FileDesc;\n+use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n \n-/// Os-specific extensions to [`process::Child`]\n+/// This type represents a file descriptor that refers to a process.\n+///\n+/// A `PidFd` can be obtained by setting the corresponding option on [`Command`]\n+/// with [`create_pidfd`]. Subsequently, the created pidfd can be retrieved\n+/// from the [`Child`] by calling [`pidfd`] or [`take_pidfd`].\n+///\n+/// Example:\n+/// ```no_run\n+/// #![feature(linux_pidfd)]\n+/// use std::os::linux::process::{CommandExt, ChildExt};\n+/// use std::process::Command;\n+///\n+/// let mut child = Command::new(\"echo\")\n+///     .create_pidfd(true)\n+///     .spawn()\n+///     .expect(\"Failed to spawn child\");\n ///\n-/// [`process::Child`]: crate::process::Child\n-pub trait ChildExt {\n-    /// Obtains the pidfd created for this child process, if available.\n+/// let pidfd = child\n+///     .take_pidfd()\n+///     .expect(\"Failed to retrieve pidfd\");\n+///\n+/// // The file descriptor will be closed when `pidfd` is dropped.\n+/// ```\n+/// Refer to the man page of `pidfd_open(2)` for further details.\n+///\n+/// [`Command`]: process::Command\n+/// [`create_pidfd`]: CommandExt::create_pidfd\n+/// [`Child`]: process::Child\n+/// [`pidfd`]: fn@ChildExt::pidfd\n+/// [`take_pidfd`]: ChildExt::take_pidfd\n+#[derive(Debug)]\n+pub struct PidFd {\n+    inner: FileDesc,\n+}\n+\n+impl AsInner<FileDesc> for PidFd {\n+    fn as_inner(&self) -> &FileDesc {\n+        &self.inner\n+    }\n+}\n+\n+impl FromInner<FileDesc> for PidFd {\n+    fn from_inner(inner: FileDesc) -> PidFd {\n+        PidFd { inner }\n+    }\n+}\n+\n+impl IntoInner<FileDesc> for PidFd {\n+    fn into_inner(self) -> FileDesc {\n+        self.inner\n+    }\n+}\n+\n+impl AsRawFd for PidFd {\n+    fn as_raw_fd(&self) -> RawFd {\n+        self.as_inner().raw()\n+    }\n+}\n+\n+impl FromRawFd for PidFd {\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self {\n+        Self::from_inner(FileDesc::new(fd))\n+    }\n+}\n+\n+impl IntoRawFd for PidFd {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_raw()\n+    }\n+}\n+\n+mod private_child_ext {\n+    pub trait Sealed {}\n+    impl Sealed for crate::process::Child {}\n+}\n+\n+/// Os-specific extensions for [`Child`]\n+///\n+/// [`Child`]: process::Child\n+pub trait ChildExt: private_child_ext::Sealed {\n+    /// Obtains a reference to the [`PidFd`] created for this [`Child`], if available.\n+    ///\n+    /// A pidfd will only be available if its creation was requested with\n+    /// [`create_pidfd`] when the corresponding [`Command`] was created.\n     ///\n-    /// A pidfd will only ever be available if `create_pidfd(true)` was called\n-    /// when the corresponding `Command` was created.\n+    /// Even if requested, a pidfd may not be available due to an older\n+    /// version of Linux being in use, or if some other error occurred.\n+    ///\n+    /// [`Command`]: process::Command\n+    /// [`create_pidfd`]: CommandExt::create_pidfd\n+    /// [`Child`]: process::Child\n+    fn pidfd(&self) -> Result<&PidFd>;\n+\n+    /// Takes ownership of the [`PidFd`] created for this [`Child`], if available.\n     ///\n-    /// Even if `create_pidfd(true)` is called, a pidfd may not be available\n-    /// due to an older version of Linux being in use, or if\n-    /// some other error occured.\n+    /// A pidfd will only be available if its creation was requested with\n+    /// [`create_pidfd`] when the corresponding [`Command`] was created.\n     ///\n-    /// See `man pidfd_open` for more details about pidfds.\n-    fn pidfd(&self) -> Result<i32>;\n+    /// Even if requested, a pidfd may not be available due to an older\n+    /// version of Linux being in use, or if some other error occurred.\n+    ///\n+    /// [`Command`]: process::Command\n+    /// [`create_pidfd`]: CommandExt::create_pidfd\n+    /// [`Child`]: process::Child\n+    fn take_pidfd(&mut self) -> Result<PidFd>;\n+}\n+\n+mod private_command_ext {\n+    pub trait Sealed {}\n+    impl Sealed for crate::process::Command {}\n }\n \n-/// Os-specific extensions to [`process::Command`]\n+/// Os-specific extensions for [`Command`]\n ///\n-/// [`process::Command`]: crate::process::Command\n-pub trait CommandExt {\n-    /// Sets whether or this `Command` will attempt to create a pidfd\n-    /// for the child. If this method is never called, a pidfd will\n-    /// not be crated.\n+/// [`Command`]: process::Command\n+pub trait CommandExt: private_command_ext::Sealed {\n+    /// Sets whether a [`PidFd`](struct@PidFd) should be created for the [`Child`]\n+    /// spawned by this [`Command`].\n+    /// By default, no pidfd will be created.\n     ///\n-    /// The pidfd can be retrieved from the child via [`ChildExt::pidfd`]\n+    /// The pidfd can be retrieved from the child with [`pidfd`] or [`take_pidfd`].\n     ///\n     /// A pidfd will only be created if it is possible to do so\n-    /// in a guaranteed race-free manner (e.g. if the `clone3` system call is\n-    /// supported). Otherwise, [`ChildExit::pidfd`] will return an error.\n+    /// in a guaranteed race-free manner (e.g. if the `clone3` system call\n+    /// is supported). Otherwise, [`pidfd`] will return an error.\n+    ///\n+    /// [`Command`]: process::Command\n+    /// [`Child`]: process::Child\n+    /// [`pidfd`]: fn@ChildExt::pidfd\n+    /// [`take_pidfd`]: ChildExt::take_pidfd\n     fn create_pidfd(&mut self, val: bool) -> &mut process::Command;\n }\n "}, {"sha": "80cae5a3d79803d8305717f13e36d472a2353117", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 39, "deletions": 4, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/619fd96868b2cc83b7f205ff11ff897aebb5ef93/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619fd96868b2cc83b7f205ff11ff897aebb5ef93/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=619fd96868b2cc83b7f205ff11ff897aebb5ef93", "patch": "@@ -79,7 +79,8 @@ pub struct Command {\n     stdin: Option<Stdio>,\n     stdout: Option<Stdio>,\n     stderr: Option<Stdio>,\n-    pub(crate) make_pidfd: bool,\n+    #[cfg(target_os = \"linux\")]\n+    create_pidfd: bool,\n }\n \n // Create a new type for argv, so that we can make it `Send` and `Sync`\n@@ -125,6 +126,7 @@ pub enum Stdio {\n }\n \n impl Command {\n+    #[cfg(not(target_os = \"linux\"))]\n     pub fn new(program: &OsStr) -> Command {\n         let mut saw_nul = false;\n         let program = os2c(program, &mut saw_nul);\n@@ -142,7 +144,28 @@ impl Command {\n             stdin: None,\n             stdout: None,\n             stderr: None,\n-            make_pidfd: false,\n+        }\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    pub fn new(program: &OsStr) -> Command {\n+        let mut saw_nul = false;\n+        let program = os2c(program, &mut saw_nul);\n+        Command {\n+            argv: Argv(vec![program.as_ptr(), ptr::null()]),\n+            args: vec![program.clone()],\n+            program,\n+            env: Default::default(),\n+            cwd: None,\n+            uid: None,\n+            gid: None,\n+            saw_nul,\n+            closures: Vec::new(),\n+            groups: None,\n+            stdin: None,\n+            stdout: None,\n+            stderr: None,\n+            create_pidfd: false,\n         }\n     }\n \n@@ -178,9 +201,21 @@ impl Command {\n     pub fn groups(&mut self, groups: &[gid_t]) {\n         self.groups = Some(Box::from(groups));\n     }\n-    \n+\n+    #[cfg(target_os = \"linux\")]\n     pub fn create_pidfd(&mut self, val: bool) {\n-        self.make_pidfd = val;\n+        self.create_pidfd = val;\n+    }\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    #[allow(dead_code)]\n+    pub fn get_create_pidfd(&self) -> bool {\n+        false\n+    }\n+\n+    #[cfg(target_os = \"linux\")]\n+    pub fn get_create_pidfd(&self) -> bool {\n+        self.create_pidfd\n     }\n \n     pub fn saw_nul(&self) -> bool {"}, {"sha": "f7112a73efac3dbbab426cbbbe6a25419718b8f3", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 116, "deletions": 84, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/619fd96868b2cc83b7f205ff11ff897aebb5ef93/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619fd96868b2cc83b7f205ff11ff897aebb5ef93/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=619fd96868b2cc83b7f205ff11ff897aebb5ef93", "patch": "@@ -8,7 +8,9 @@ use crate::ptr;\n use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n-use crate::sync::atomic::{AtomicBool, Ordering};\n+\n+#[cfg(target_os = \"linux\")]\n+use crate::os::linux::process::PidFd;\n \n #[cfg(target_os = \"linux\")]\n use crate::sys::weak::syscall;\n@@ -66,7 +68,7 @@ impl Command {\n         // in its own process. Thus the parent drops the lock guard while the child\n         // forgets it to avoid unlocking it on a new thread, which would be invalid.\n         let env_lock = sys::os::env_read_lock();\n-        let (pid, pidfd) = self.do_fork()?;\n+        let (pid, pidfd) = unsafe { self.do_fork()? };\n \n         if pid == 0 {\n             crate::panic::always_abort();\n@@ -95,7 +97,7 @@ impl Command {\n         drop(env_lock);\n         drop(output);\n \n-        let mut p = Process { pid, status: None, pidfd };\n+        let mut p = Process::new(pid, pidfd);\n         let mut bytes = [0; 8];\n \n         // loop to handle EINTR\n@@ -127,84 +129,91 @@ impl Command {\n         }\n     }\n \n-    // Attempts to fork the process. If successful, returns\n-    // Ok((0, -1)) in the child, and Ok((child_pid, child_pidfd)) in the parent.\n-    fn do_fork(&mut self) -> Result<(libc::c_long, libc::pid_t), io::Error> {\n-        // If we fail to create a pidfd for any reason, this will\n-        // stay as -1, which indicates an error\n-        let mut pidfd: libc::pid_t = -1;\n-\n-        // On Linux, attempt to use the `clone3` syscall, which\n-        // supports more argument (in particular, the ability to create a pidfd).\n-        // If this fails, we will fall through this block to a call to `fork()`\n-        cfg_if::cfg_if! {\n-            if #[cfg(target_os = \"linux\")] {\n-                static HAS_CLONE3: AtomicBool = AtomicBool::new(true);\n-\n-                const CLONE_PIDFD: u64 = 0x00001000;\n-\n-                #[repr(C)]\n-                struct clone_args {\n-                    flags: u64,\n-                    pidfd: u64,\n-                    child_tid: u64,\n-                    parent_tid: u64,\n-                    exit_signal: u64,\n-                    stack: u64,\n-                    stack_size: u64,\n-                    tls: u64,\n-                    set_tid: u64,\n-                    set_tid_size: u64,\n-                    cgroup: u64,\n-                }\n+    // Attempts to fork the process. If successful, returns Ok((0, -1))\n+    // in the child, and Ok((child_pid, -1)) in the parent.\n+    #[cfg(not(target_os = \"linux\"))]\n+    unsafe fn do_fork(&mut self) -> Result<(pid_t, pid_t), io::Error> {\n+        cvt(libc::fork()).map(|res| (res, -1))\n+    }\n \n-                syscall! {\n-                    fn clone3(cl_args: *mut clone_args, len: libc::size_t) -> libc::c_long\n-                }\n+    // Attempts to fork the process. If successful, returns Ok((0, -1))\n+    // in the child, and Ok((child_pid, child_pidfd)) in the parent.\n+    #[cfg(target_os = \"linux\")]\n+    unsafe fn do_fork(&mut self) -> Result<(pid_t, pid_t), io::Error> {\n+        use crate::sync::atomic::{AtomicBool, Ordering};\n+\n+        static HAS_CLONE3: AtomicBool = AtomicBool::new(true);\n+        const CLONE_PIDFD: u64 = 0x00001000;\n+\n+        #[repr(C)]\n+        struct clone_args {\n+            flags: u64,\n+            pidfd: u64,\n+            child_tid: u64,\n+            parent_tid: u64,\n+            exit_signal: u64,\n+            stack: u64,\n+            stack_size: u64,\n+            tls: u64,\n+            set_tid: u64,\n+            set_tid_size: u64,\n+            cgroup: u64,\n+        }\n \n-                if HAS_CLONE3.load(Ordering::Relaxed) {\n-                    let mut flags = 0;\n-                    if self.make_pidfd {\n-                        flags |= CLONE_PIDFD;\n-                    }\n+        syscall! {\n+            fn clone3(cl_args: *mut clone_args, len: libc::size_t) -> libc::c_long\n+        }\n \n-                    let mut args = clone_args {\n-                        flags,\n-                        pidfd: &mut pidfd as *mut libc::pid_t as u64,\n-                        child_tid: 0,\n-                        parent_tid: 0,\n-                        exit_signal: libc::SIGCHLD as u64,\n-                        stack: 0,\n-                        stack_size: 0,\n-                        tls: 0,\n-                        set_tid: 0,\n-                        set_tid_size: 0,\n-                        cgroup: 0\n-                    };\n-\n-                    let args_ptr = &mut args as *mut clone_args;\n-                    let args_size = crate::mem::size_of::<clone_args>();\n-\n-                    let res = cvt(unsafe { clone3(args_ptr, args_size) });\n-                    match res {\n-                        Ok(n) => return Ok((n, pidfd)),\n-                        Err(e) => match e.raw_os_error() {\n-                            // Multiple threads can race to execute this store,\n-                            // but that's fine - that just means that multiple threads\n-                            // will have tried and failed to execute the same syscall,\n-                            // with no other side effects.\n-                            Some(libc::ENOSYS) => HAS_CLONE3.store(false, Ordering::Relaxed),\n-                            _ => return Err(e)\n-                        }\n-                    }\n-                }\n+        // If we fail to create a pidfd for any reason, this will\n+        // stay as -1, which indicates an error.\n+        let mut pidfd: pid_t = -1;\n+\n+        // Attempt to use the `clone3` syscall, which supports more arguments\n+        // (in particular, the ability to create a pidfd). If this fails,\n+        // we will fall through this block to a call to `fork()`\n+        if HAS_CLONE3.load(Ordering::Relaxed) {\n+            let mut flags = 0;\n+            if self.get_create_pidfd() {\n+                flags |= CLONE_PIDFD;\n+            }\n+\n+            let mut args = clone_args {\n+                flags,\n+                pidfd: &mut pidfd as *mut pid_t as u64,\n+                child_tid: 0,\n+                parent_tid: 0,\n+                exit_signal: libc::SIGCHLD as u64,\n+                stack: 0,\n+                stack_size: 0,\n+                tls: 0,\n+                set_tid: 0,\n+                set_tid_size: 0,\n+                cgroup: 0,\n+            };\n+\n+            let args_ptr = &mut args as *mut clone_args;\n+            let args_size = crate::mem::size_of::<clone_args>();\n+\n+            let res = cvt(clone3(args_ptr, args_size));\n+            match res {\n+                Ok(n) => return Ok((n as pid_t, pidfd)),\n+                Err(e) => match e.raw_os_error() {\n+                    // Multiple threads can race to execute this store,\n+                    // but that's fine - that just means that multiple threads\n+                    // will have tried and failed to execute the same syscall,\n+                    // with no other side effects.\n+                    Some(libc::ENOSYS) => HAS_CLONE3.store(false, Ordering::Relaxed),\n+                    // Fallback to fork if `EPERM` is returned. (e.g. blocked by seccomp)\n+                    Some(libc::EPERM) => {}\n+                    _ => return Err(e),\n+                },\n             }\n         }\n-        // If we get here, we are either not on Linux,\n-        // or we are on Linux and the 'clone3' syscall does not exist\n-        cvt(unsafe { libc::fork() }.into()).map(|res| (res, pidfd))\n-    }\n \n+        // If we get here, the 'clone3' syscall does not exist\n+        // or we do not have permission to call it\n+        cvt(libc::fork()).map(|res| (res, pidfd))\n+    }\n \n     pub fn exec(&mut self, default: Stdio) -> io::Error {\n         let envp = self.capture_env();\n@@ -360,6 +369,8 @@ impl Command {\n     #[cfg(not(any(\n         target_os = \"macos\",\n         target_os = \"freebsd\",\n+        all(target_os = \"linux\", target_env = \"gnu\"),\n+        all(target_os = \"linux\", target_env = \"musl\"),\n     )))]\n     fn posix_spawn(\n         &mut self,\n@@ -374,6 +385,8 @@ impl Command {\n     #[cfg(any(\n         target_os = \"macos\",\n         target_os = \"freebsd\",\n+        all(target_os = \"linux\", target_env = \"gnu\"),\n+        all(target_os = \"linux\", target_env = \"musl\"),\n     ))]\n     fn posix_spawn(\n         &mut self,\n@@ -388,6 +401,7 @@ impl Command {\n             || (self.env_saw_path() && !self.program_is_path())\n             || !self.get_closures().is_empty()\n             || self.get_groups().is_some()\n+            || self.get_create_pidfd()\n         {\n             return Ok(None);\n         }\n@@ -432,7 +446,7 @@ impl Command {\n             None => None,\n         };\n \n-        let mut p = Process { pid: 0, status: None };\n+        let mut p = Process::new(0, -1);\n \n         struct PosixSpawnFileActions<'a>(&'a mut MaybeUninit<libc::posix_spawn_file_actions_t>);\n \n@@ -522,14 +536,26 @@ pub struct Process {\n     pid: pid_t,\n     status: Option<ExitStatus>,\n     // On Linux, stores the pidfd created for this child.\n-    // This is -1 if the user did not request pidfd creation,\n+    // This is None if the user did not request pidfd creation,\n     // or if the pidfd could not be created for some reason\n     // (e.g. the `clone3` syscall was not available).\n     #[cfg(target_os = \"linux\")]\n-    pidfd: libc::c_int,\n+    pidfd: Option<PidFd>,\n }\n \n impl Process {\n+    #[cfg(target_os = \"linux\")]\n+    fn new(pid: pid_t, pidfd: pid_t) -> Self {\n+        use crate::sys_common::FromInner;\n+        let pidfd = (pidfd >= 0).then(|| PidFd::from_inner(sys::fd::FileDesc::new(pidfd)));\n+        Process { pid, status: None, pidfd }\n+    }\n+\n+    #[cfg(not(target_os = \"linux\"))]\n+    fn new(pid: pid_t, _pidfd: pid_t) -> Self {\n+        Process { pid, status: None }\n+    }\n+\n     pub fn id(&self) -> u32 {\n         self.pid as u32\n     }\n@@ -669,12 +695,18 @@ impl ExitStatusError {\n #[cfg(target_os = \"linux\")]\n #[unstable(feature = \"linux_pidfd\", issue = \"none\")]\n impl crate::os::linux::process::ChildExt for crate::process::Child {\n-    fn pidfd(&self) -> crate::io::Result<i32> {\n-        if self.handle.pidfd > 0 {\n-            Ok(self.handle.pidfd)\n-        } else {\n-            Err(crate::io::Error::from(crate::io::ErrorKind::Other))\n-        }\n+    fn pidfd(&self) -> io::Result<&PidFd> {\n+        self.handle\n+            .pidfd\n+            .as_ref()\n+            .ok_or_else(|| Error::new(ErrorKind::Other, \"No pidfd was created.\"))\n+    }\n+\n+    fn take_pidfd(&mut self) -> io::Result<PidFd> {\n+        self.handle\n+            .pidfd\n+            .take()\n+            .ok_or_else(|| Error::new(ErrorKind::Other, \"No pidfd was created.\"))\n     }\n }\n "}, {"sha": "db728be09dfbcce5b1d85acc11908388b6f5670a", "filename": "src/test/ui/command/command-create-pidfd.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/619fd96868b2cc83b7f205ff11ff897aebb5ef93/src%2Ftest%2Fui%2Fcommand%2Fcommand-create-pidfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/619fd96868b2cc83b7f205ff11ff897aebb5ef93/src%2Ftest%2Fui%2Fcommand%2Fcommand-create-pidfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcommand%2Fcommand-create-pidfd.rs?ref=619fd96868b2cc83b7f205ff11ff897aebb5ef93", "patch": "@@ -1,13 +1,13 @@\n // run-pass\n-// linux-only - pidfds are a linux-specific concept\n+// only-linux - pidfds are a linux-specific concept\n \n #![feature(linux_pidfd)]\n use std::os::linux::process::{CommandExt, ChildExt};\n use std::process::Command;\n \n fn main() {\n-    // We don't assert the precise value, since the standard libarary\n-    // may be opened other file descriptors before our code ran.\n+    // We don't assert the precise value, since the standard library\n+    // might have opened other file descriptors before our code runs.\n     let _ = Command::new(\"echo\")\n         .create_pidfd(true)\n         .spawn()"}]}