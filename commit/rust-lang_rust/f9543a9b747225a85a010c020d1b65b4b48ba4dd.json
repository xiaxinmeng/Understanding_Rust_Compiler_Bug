{"sha": "f9543a9b747225a85a010c020d1b65b4b48ba4dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NTQzYTliNzQ3MjI1YTg1YTAxMGMwMjBkMWI2NWI0YjQ4YmE0ZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-15T03:17:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-15T03:17:35Z"}, "message": "Auto merge of #31555 - nrc:err-recover, r=pnkfelix\n\nRecover from missing brackets in the parser", "tree": {"sha": "47e880dd6189c596f8126b5ca6a028246bc1d249", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47e880dd6189c596f8126b5ca6a028246bc1d249"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9543a9b747225a85a010c020d1b65b4b48ba4dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9543a9b747225a85a010c020d1b65b4b48ba4dd", "html_url": "https://github.com/rust-lang/rust/commit/f9543a9b747225a85a010c020d1b65b4b48ba4dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9543a9b747225a85a010c020d1b65b4b48ba4dd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2808df961bf218dc1844a61efc1906ffdf2808a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2808df961bf218dc1844a61efc1906ffdf2808a8", "html_url": "https://github.com/rust-lang/rust/commit/2808df961bf218dc1844a61efc1906ffdf2808a8"}, {"sha": "73a8513b88f28344c37d3b3296f93cbc8f30cefa", "url": "https://api.github.com/repos/rust-lang/rust/commits/73a8513b88f28344c37d3b3296f93cbc8f30cefa", "html_url": "https://github.com/rust-lang/rust/commit/73a8513b88f28344c37d3b3296f93cbc8f30cefa"}], "stats": {"total": 455, "additions": 330, "deletions": 125}, "files": [{"sha": "59e79200568a05f46144b5875a545028c96b5e52", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 269, "deletions": 107, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -105,6 +105,12 @@ pub enum ParsePub {\n     No,\n }\n \n+#[derive(Clone, Copy, PartialEq)]\n+pub enum SemiColonMode {\n+    Break,\n+    Ignore,\n+}\n+\n /// Possibly accept an `token::Interpolated` expression (a pre-parsed expression\n /// dropped into the token stream, which happens while parsing the result of\n /// macro expansion). Placement of these is not as complex as I feared it would\n@@ -598,7 +604,7 @@ impl<'a> Parser<'a> {\n \n     /// Check if the next token is `tok`, and return `true` if so.\n     ///\n-    /// This method is will automatically add `tok` to `expected_tokens` if `tok` is not\n+    /// This method will automatically add `tok` to `expected_tokens` if `tok` is not\n     /// encountered.\n     pub fn check(&mut self, tok: &token::Token) -> bool {\n         let is_present = self.token == *tok;\n@@ -840,6 +846,15 @@ impl<'a> Parser<'a> {\n         return Ok((v, returned));\n     }\n \n+    /// Eat and discard tokens until one of `kets` is encountered. Respects token trees,\n+    /// passes through any errors encountered. Used for error recovery.\n+    pub fn eat_to_tokens(&mut self, kets: &[&token::Token]) {\n+        self.parse_seq_to_before_tokens(kets,\n+                                        seq_sep_none(),\n+                                        |p| p.parse_token_tree(),\n+                                        |mut e| e.cancel());\n+    }\n+\n     /// Parse a sequence, including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n@@ -850,7 +865,7 @@ impl<'a> Parser<'a> {\n                                   -> PResult<'a, Vec<T>> where\n         F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n-        let val = try!(self.parse_seq_to_before_end(ket, sep, f));\n+        let val = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         Ok(val)\n     }\n@@ -861,24 +876,53 @@ impl<'a> Parser<'a> {\n     pub fn parse_seq_to_before_end<T, F>(&mut self,\n                                          ket: &token::Token,\n                                          sep: SeqSep,\n-                                         mut f: F)\n-                                         -> PResult<'a, Vec<T>> where\n-        F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+                                         f: F)\n+                                         -> Vec<T>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+    {\n+        self.parse_seq_to_before_tokens(&[ket], sep, f, |mut e| e.emit())\n+    }\n+\n+    // `fe` is an error handler.\n+    fn parse_seq_to_before_tokens<T, F, Fe>(&mut self,\n+                                            kets: &[&token::Token],\n+                                            sep: SeqSep,\n+                                            mut f: F,\n+                                            mut fe: Fe)\n+                                            -> Vec<T>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n+              Fe: FnMut(DiagnosticBuilder)\n     {\n         let mut first: bool = true;\n         let mut v = vec!();\n-        while self.token != *ket {\n+        while !kets.contains(&&self.token) {\n             match sep.sep {\n-              Some(ref t) => {\n-                if first { first = false; }\n-                else { try!(self.expect(t)); }\n-              }\n-              _ => ()\n+                Some(ref t) => {\n+                    if first {\n+                        first = false;\n+                    } else {\n+                        if let Err(e) = self.expect(t) {\n+                            fe(e);\n+                            break;\n+                        }\n+                    }\n+                }\n+                _ => ()\n+            }\n+            if sep.trailing_sep_allowed && kets.iter().any(|k| self.check(k)) {\n+                break;\n+            }\n+\n+            match f(self) {\n+                Ok(t) => v.push(t),\n+                Err(e) => {\n+                    fe(e);\n+                    break;\n+                }\n             }\n-            if sep.trailing_sep_allowed && self.check(ket) { break; }\n-            v.push(try!(f(self)));\n         }\n-        return Ok(v);\n+\n+        v\n     }\n \n     /// Parse a sequence, including the closing delimiter. The function\n@@ -893,7 +937,7 @@ impl<'a> Parser<'a> {\n         F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n         try!(self.expect(bra));\n-        let result = try!(self.parse_seq_to_before_end(ket, sep, f));\n+        let result = self.parse_seq_to_before_end(ket, sep, f);\n         self.bump();\n         Ok(result)\n     }\n@@ -929,7 +973,7 @@ impl<'a> Parser<'a> {\n     {\n         let lo = self.span.lo;\n         try!(self.expect(bra));\n-        let result = try!(self.parse_seq_to_before_end(ket, sep, f));\n+        let result = self.parse_seq_to_before_end(ket, sep, f);\n         let hi = self.span.hi;\n         self.bump();\n         Ok(spanned(lo, hi, result))\n@@ -1216,7 +1260,25 @@ impl<'a> Parser<'a> {\n                 };\n                 (ident, TraitItemKind::Const(ty, default))\n             } else {\n-                let (constness, unsafety, abi) = try!(p.parse_fn_front_matter());\n+                let (constness, unsafety, abi) = match p.parse_fn_front_matter() {\n+                    Ok(cua) => cua,\n+                    Err(e) => {\n+                        loop {\n+                            p.bump();\n+                            if p.token == token::Semi {\n+                                p.bump();\n+                                break;\n+                            }\n+\n+                            if p.token == token::OpenDelim(token::DelimToken::Brace) {\n+                                try!(p.parse_token_tree());\n+                                break;\n+                            }\n+                        }\n+\n+                        return Err(e);\n+                    }\n+                };\n \n                 let ident = try!(p.parse_ident());\n                 let mut generics = try!(p.parse_generics());\n@@ -2289,14 +2351,37 @@ impl<'a> Parser<'a> {\n \n                             while self.token != token::CloseDelim(token::Brace) {\n                                 if self.eat(&token::DotDot) {\n-                                    base = Some(try!(self.parse_expr()));\n+                                    match self.parse_expr() {\n+                                        Ok(e) => {\n+                                            base = Some(e);\n+                                        }\n+                                        Err(mut e) => {\n+                                            e.emit();\n+                                            self.recover_stmt();\n+                                        }\n+                                    }\n                                     break;\n                                 }\n \n-                                fields.push(try!(self.parse_field()));\n-                                try!(self.commit_expr(&fields.last().unwrap().expr,\n-                                                 &[token::Comma],\n-                                                 &[token::CloseDelim(token::Brace)]));\n+                                match self.parse_field() {\n+                                    Ok(f) => fields.push(f),\n+                                    Err(mut e) => {\n+                                        e.emit();\n+                                        self.recover_stmt();\n+                                        break;\n+                                    }\n+                                }\n+\n+                                match self.commit_expr(&fields.last().unwrap().expr,\n+                                                       &[token::Comma],\n+                                                       &[token::CloseDelim(token::Brace)]) {\n+                                    Ok(()) => {}\n+                                    Err(mut e) => {\n+                                        e.emit();\n+                                        self.recover_stmt();\n+                                        break;\n+                                    }\n+                                }\n                             }\n \n                             hi = self.span.hi;\n@@ -2641,45 +2726,16 @@ impl<'a> Parser<'a> {\n         // yet.\n         maybe_whole!(deref self, NtTT);\n \n-        // this is the fall-through for the 'match' below.\n-        // invariants: the current token is not a left-delimiter,\n-        // not an EOF, and not the desired right-delimiter (if\n-        // it were, parse_seq_to_before_end would have prevented\n-        // reaching this point.\n-        fn parse_non_delim_tt_tok<'b>(p: &mut Parser<'b>) -> PResult<'b,  TokenTree> {\n-            maybe_whole!(deref p, NtTT);\n-            match p.token {\n-                token::CloseDelim(_) => {\n-                    let token_str = p.this_token_to_string();\n-                    let mut err = p.fatal(\n-                        &format!(\"incorrect close delimiter: `{}`\", token_str));\n-                    // This is a conservative error: only report the last unclosed delimiter. The\n-                    // previous unclosed delimiters could actually be closed! The parser just hasn't\n-                    // gotten to them yet.\n-                    if let Some(&sp) = p.open_braces.last() {\n-                        err.span_note(sp, \"unclosed delimiter\");\n-                    };\n-                    Err(err)\n-                },\n-                /* we ought to allow different depths of unquotation */\n-                token::Dollar | token::SubstNt(..) if p.quote_depth > 0 => {\n-                    p.parse_unquoted()\n-                }\n-                _ => {\n-                    Ok(TokenTree::Token(p.span, p.bump_and_get()))\n-                }\n-            }\n-        }\n-\n         match self.token {\n             token::Eof => {\n-                let open_braces = self.open_braces.clone();\n                 let mut err: DiagnosticBuilder<'a> =\n-                    self.fatal(\"this file contains an un-closed delimiter\");\n-                for sp in &open_braces {\n+                    self.diagnostic().struct_span_err(self.span,\n+                                                      \"this file contains an un-closed delimiter\");\n+                for sp in &self.open_braces {\n                     err.span_help(*sp, \"did you mean to close this delimiter?\");\n                 }\n-                return Err(err);\n+\n+                Err(err)\n             },\n             token::OpenDelim(delim) => {\n                 // The span for beginning of the delimited section\n@@ -2691,11 +2747,9 @@ impl<'a> Parser<'a> {\n                 self.bump();\n \n                 // Parse the token trees within the delimiters\n-                let tts = try!(self.parse_seq_to_before_end(\n-                    &token::CloseDelim(delim),\n-                    seq_sep_none(),\n-                    |p| p.parse_token_tree()\n-                ));\n+                let tts = self.parse_seq_to_before_end(&token::CloseDelim(delim),\n+                                                       seq_sep_none(),\n+                                                       |p| p.parse_token_tree());\n \n                 // Parse the close delimiter.\n                 let close_span = self.span;\n@@ -2712,7 +2766,35 @@ impl<'a> Parser<'a> {\n                     close_span: close_span,\n                 })))\n             },\n-            _ => parse_non_delim_tt_tok(self),\n+            _ => {\n+                // invariants: the current token is not a left-delimiter,\n+                // not an EOF, and not the desired right-delimiter (if\n+                // it were, parse_seq_to_before_end would have prevented\n+                // reaching this point.\n+                maybe_whole!(deref self, NtTT);\n+                match self.token {\n+                    token::CloseDelim(_) => {\n+                        let token_str = self.this_token_to_string();\n+                        let mut err = self.diagnostic().struct_span_err(self.span,\n+                            &format!(\"incorrect close delimiter: `{}`\", token_str));\n+                        // This is a conservative error: only report the last unclosed delimiter.\n+                        // The previous unclosed delimiters could actually be closed! The parser\n+                        // just hasn't gotten to them yet.\n+                        if let Some(&sp) = self.open_braces.last() {\n+                            err.span_note(sp, \"unclosed delimiter\");\n+                        };\n+\n+                        Err(err)\n+                    },\n+                    /* we ought to allow different depths of unquotation */\n+                    token::Dollar | token::SubstNt(..) if self.quote_depth > 0 => {\n+                        self.parse_unquoted()\n+                    }\n+                    _ => {\n+                        Ok(TokenTree::Token(self.span, self.bump_and_get()))\n+                    }\n+                }\n+            }\n         }\n     }\n \n@@ -3149,8 +3231,8 @@ impl<'a> Parser<'a> {\n     fn parse_match_expr(&mut self, attrs: ThinAttributes) -> PResult<'a, P<Expr>> {\n         let match_span = self.last_span;\n         let lo = self.last_span.lo;\n-        let discriminant = try!(self.parse_expr_res(\n-            Restrictions::RESTRICTION_NO_STRUCT_LITERAL, None));\n+        let discriminant = try!(self.parse_expr_res(Restrictions::RESTRICTION_NO_STRUCT_LITERAL,\n+                                                    None));\n         if let Err(mut e) = self.commit_expr_expecting(&discriminant,\n                                                        token::OpenDelim(token::Brace)) {\n             if self.token == token::Token::Semi {\n@@ -3162,7 +3244,19 @@ impl<'a> Parser<'a> {\n             try!(self.parse_inner_attributes()).into_thin_attrs());\n         let mut arms: Vec<Arm> = Vec::new();\n         while self.token != token::CloseDelim(token::Brace) {\n-            arms.push(try!(self.parse_arm()));\n+            match self.parse_arm() {\n+                Ok(arm) => arms.push(arm),\n+                Err(mut e) => {\n+                    // Recover by skipping to the end of the block.\n+                    e.emit();\n+                    self.recover_stmt();\n+                    let hi = self.span.hi;\n+                    if self.token == token::CloseDelim(token::Brace) {\n+                        self.bump();\n+                    }\n+                    return Ok(self.mk_expr(lo, hi, ExprKind::Match(discriminant, arms), attrs));\n+                }\n+            }\n         }\n         let hi = self.span.hi;\n         self.bump();\n@@ -3520,7 +3614,11 @@ impl<'a> Parser<'a> {\n                         }\n                         // Parse struct pattern\n                         self.bump();\n-                        let (fields, etc) = try!(self.parse_pat_fields());\n+                        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n+                            e.emit();\n+                            self.recover_stmt();\n+                            (vec![], false)\n+                        });\n                         self.bump();\n                         pat = PatKind::Struct(path, fields, etc);\n                       }\n@@ -3674,10 +3772,72 @@ impl<'a> Parser<'a> {\n \n     /// Parse a statement. may include decl.\n     pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n-        Ok(try!(self.parse_stmt_()))\n+        Ok(self.parse_stmt_())\n+    }\n+\n+    // Eat tokens until we can be relatively sure we reached the end of the\n+    // statement. This is something of a best-effort heuristic.\n+    //\n+    // We terminate when we find an unmatched `}` (without consuming it).\n+    fn recover_stmt(&mut self) {\n+        self.recover_stmt_(SemiColonMode::Ignore)\n+    }\n+    // If `break_on_semi` is `Break`, then we will stop consuming tokens after\n+    // finding (and consuming) a `;` outside of `{}` or `[]` (note that this is\n+    // approximate - it can mean we break too early due to macros, but that\n+    // shoud only lead to sub-optimal recovery, not inaccurate parsing).\n+    fn recover_stmt_(&mut self, break_on_semi: SemiColonMode) {\n+        let mut brace_depth = 0;\n+        let mut bracket_depth = 0;\n+        loop {\n+            match self.token {\n+                token::OpenDelim(token::DelimToken::Brace) => {\n+                    brace_depth += 1;\n+                    self.bump();\n+                }\n+                token::OpenDelim(token::DelimToken::Bracket) => {\n+                    bracket_depth += 1;\n+                    self.bump();\n+                }\n+                token::CloseDelim(token::DelimToken::Brace) => {\n+                    if brace_depth == 0 {\n+                        return;\n+                    }\n+                    brace_depth -= 1;\n+                    self.bump();\n+                }\n+                token::CloseDelim(token::DelimToken::Bracket) => {\n+                    bracket_depth -= 1;\n+                    if bracket_depth < 0 {\n+                        bracket_depth = 0;\n+                    }\n+                    self.bump();\n+                }\n+                token::Eof => return,\n+                token::Semi => {\n+                    self.bump();\n+                    if break_on_semi == SemiColonMode::Break &&\n+                       brace_depth == 0 &&\n+                       bracket_depth == 0 {\n+                        return;\n+                    }\n+                }\n+                _ => {\n+                    self.bump()\n+                }\n+            }\n+        }\n+    }\n+\n+    fn parse_stmt_(&mut self) -> Option<Stmt> {\n+        self.parse_stmt_without_recovery().unwrap_or_else(|mut e| {\n+            e.emit();\n+            self.recover_stmt_(SemiColonMode::Break);\n+            None\n+        })\n     }\n \n-    fn parse_stmt_(&mut self) -> PResult<'a, Option<Stmt>> {\n+    fn parse_stmt_without_recovery(&mut self) -> PResult<'a, Option<Stmt>> {\n         maybe_whole!(Some deref self, NtStmt);\n \n         let attrs = try!(self.parse_outer_attributes());\n@@ -3833,7 +3993,7 @@ impl<'a> Parser<'a> {\n         let lo = self.span.lo;\n         try!(self.expect(&token::OpenDelim(token::Brace)));\n         Ok((try!(self.parse_inner_attributes()),\n-         try!(self.parse_block_tail(lo, BlockCheckMode::Default))))\n+            try!(self.parse_block_tail(lo, BlockCheckMode::Default))))\n     }\n \n     /// Parse the rest of a block expression or function body\n@@ -3843,7 +4003,7 @@ impl<'a> Parser<'a> {\n         let mut expr = None;\n \n         while !self.eat(&token::CloseDelim(token::Brace)) {\n-            let Spanned {node, span} = if let Some(s) = try!(self.parse_stmt_()) {\n+            let Spanned {node, span} = if let Some(s) = self.parse_stmt_() {\n                 s\n             } else {\n                 // Found only `;` or `}`.\n@@ -3928,17 +4088,21 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    fn handle_expression_like_statement(\n-            &mut self,\n-            e: P<Expr>,\n-            span: Span,\n-            stmts: &mut Vec<Stmt>,\n-            last_block_expr: &mut Option<P<Expr>>) -> PResult<'a, ()> {\n+    fn handle_expression_like_statement(&mut self,\n+                                        e: P<Expr>,\n+                                        span: Span,\n+                                        stmts: &mut Vec<Stmt>,\n+                                        last_block_expr: &mut Option<P<Expr>>)\n+                                        -> PResult<'a, ()> {\n         // expression without semicolon\n         if classify::expr_requires_semi_to_be_stmt(&e) {\n             // Just check for errors and recover; do not eat semicolon yet.\n-            try!(self.commit_stmt(&[],\n-                             &[token::Semi, token::CloseDelim(token::Brace)]));\n+            if let Err(mut e) =\n+                self.commit_stmt(&[], &[token::Semi, token::CloseDelim(token::Brace)])\n+            {\n+                e.emit();\n+                self.recover_stmt();\n+            }\n         }\n \n         match self.token {\n@@ -4171,8 +4335,8 @@ impl<'a> Parser<'a> {\n     fn forbid_lifetime(&mut self) -> PResult<'a, ()> {\n         if self.token.is_lifetime() {\n             let span = self.span;\n-            return Err(self.span_fatal(span, \"lifetime parameters must be declared \\\n-                                        prior to type parameters\"))\n+            return Err(self.diagnostic().struct_span_err(span, \"lifetime parameters must be \\\n+                                                                declared prior to type parameters\"))\n         }\n         Ok(())\n     }\n@@ -4300,7 +4464,8 @@ impl<'a> Parser<'a> {\n     fn parse_fn_args(&mut self, named_args: bool, allow_variadic: bool)\n                      -> PResult<'a, (Vec<Arg> , bool)> {\n         let sp = self.span;\n-        let mut args: Vec<Option<Arg>> =\n+        let mut variadic = false;\n+        let args: Vec<Option<Arg>> =\n             try!(self.parse_unspanned_seq(\n                 &token::OpenDelim(token::Paren),\n                 &token::CloseDelim(token::Paren),\n@@ -4311,38 +4476,36 @@ impl<'a> Parser<'a> {\n                         if allow_variadic {\n                             if p.token != token::CloseDelim(token::Paren) {\n                                 let span = p.span;\n-                                return Err(p.span_fatal(span,\n-                                    \"`...` must be last in argument list for variadic function\"))\n+                                p.span_err(span,\n+                                    \"`...` must be last in argument list for variadic function\");\n                             }\n                         } else {\n                             let span = p.span;\n-                            return Err(p.span_fatal(span,\n-                                         \"only foreign functions are allowed to be variadic\"))\n+                            p.span_err(span,\n+                                       \"only foreign functions are allowed to be variadic\");\n                         }\n+                        variadic = true;\n                         Ok(None)\n                     } else {\n-                        Ok(Some(try!(p.parse_arg_general(named_args))))\n+                        match p.parse_arg_general(named_args) {\n+                            Ok(arg) => Ok(Some(arg)),\n+                            Err(mut e) => {\n+                                e.emit();\n+                                p.eat_to_tokens(&[&token::Comma, &token::CloseDelim(token::Paren)]);\n+                                Ok(None)\n+                            }\n+                        }\n                     }\n                 }\n             ));\n \n-        let variadic = match args.pop() {\n-            Some(None) => true,\n-            Some(x) => {\n-                // Need to put back that last arg\n-                args.push(x);\n-                false\n-            }\n-            None => false\n-        };\n+        let args: Vec<_> = args.into_iter().filter_map(|x| x).collect();\n \n         if variadic && args.is_empty() {\n             self.span_err(sp,\n                           \"variadic function must be declared with at least one named argument\");\n         }\n \n-        let args = args.into_iter().map(|x| x.unwrap()).collect();\n-\n         Ok((args, variadic))\n     }\n \n@@ -4519,11 +4682,11 @@ impl<'a> Parser<'a> {\n                 token::Comma => {\n                     self.bump();\n                     let sep = seq_sep_trailing_allowed(token::Comma);\n-                    let mut fn_inputs = try!(self.parse_seq_to_before_end(\n+                    let mut fn_inputs = self.parse_seq_to_before_end(\n                         &token::CloseDelim(token::Paren),\n                         sep,\n                         parse_arg_fn\n-                    ));\n+                    );\n                     fn_inputs.insert(0, Arg::new_self(explicit_self_sp, mutbl_self, $self_id));\n                     fn_inputs\n                 }\n@@ -4542,8 +4705,7 @@ impl<'a> Parser<'a> {\n         let fn_inputs = match explicit_self {\n             SelfKind::Static =>  {\n                 let sep = seq_sep_trailing_allowed(token::Comma);\n-                try!(self.parse_seq_to_before_end(&token::CloseDelim(token::Paren),\n-                                                  sep, parse_arg_fn))\n+                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n             }\n             SelfKind::Value(id) => parse_remaining_arguments!(id),\n             SelfKind::Region(_,_,id) => parse_remaining_arguments!(id),\n@@ -4574,11 +4736,11 @@ impl<'a> Parser<'a> {\n             } else {\n                 try!(self.expect(&token::BinOp(token::Or)));\n                 try!(self.parse_obsolete_closure_kind());\n-                let args = try!(self.parse_seq_to_before_end(\n+                let args = self.parse_seq_to_before_end(\n                     &token::BinOp(token::Or),\n                     seq_sep_trailing_allowed(token::Comma),\n                     |p| p.parse_fn_block_arg()\n-                ));\n+                );\n                 self.bump();\n                 args\n             }\n@@ -4740,8 +4902,8 @@ impl<'a> Parser<'a> {\n             // eat a matched-delimiter token tree:\n             let delim = try!(self.expect_open_delim());\n             let tts = try!(self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                            seq_sep_none(),\n-                                            |p| p.parse_token_tree()));\n+                                                 seq_sep_none(),\n+                                                 |p| p.parse_token_tree()));\n             let m_ = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n             let m: ast::Mac = codemap::Spanned { node: m_,\n                                                 span: mk_sp(lo,\n@@ -5800,8 +5962,8 @@ impl<'a> Parser<'a> {\n             // eat a matched-delimiter token tree:\n             let delim = try!(self.expect_open_delim());\n             let tts = try!(self.parse_seq_to_end(&token::CloseDelim(delim),\n-                                            seq_sep_none(),\n-                                            |p| p.parse_token_tree()));\n+                                                 seq_sep_none(),\n+                                                 |p| p.parse_token_tree()));\n             // single-variant-enum... :\n             let m = Mac_ { path: pth, tts: tts, ctxt: EMPTY_CTXT };\n             let m: ast::Mac = codemap::Spanned { node: m,"}, {"sha": "67f619b4de4f433f79f771dd6fe431cf24c2f584", "filename": "src/test/compile-fail/issue-30715.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fcompile-fail%2Fissue-30715.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fcompile-fail%2Fissue-30715.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30715.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -25,7 +25,7 @@ macro_rules! parallel {\n fn main() {\n     parallel! {\n         for i in 0..n {\n-            x += i; //~ ERROR no rules expected the token `+=`\n-        }\n+            x += i; //~ ERROR expected `:`, found `+=`\n+        } //~ ERROR unexpected end of macro invocation\n     }\n }"}, {"sha": "364a7e9cf6d75cb025ea9fc3f4691739ff95d2b2", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -18,7 +18,7 @@ macro_rules! ignored_item {\n \n macro_rules! ignored_expr {\n     () => ( 1,  //~ ERROR unexpected token: `,`\n-            2 ) //~ ERROR macro expansion ignores token `2`\n+            2 )\n }\n \n macro_rules! ignored_pat {\n@@ -28,7 +28,7 @@ macro_rules! ignored_pat {\n ignored_item!(); //~ NOTE caused by the macro expansion here\n \n fn main() {\n-    ignored_expr!(); //~ NOTE caused by the macro expansion here\n+    ignored_expr!();\n     match 1 {\n         ignored_pat!() => (), //~ NOTE caused by the macro expansion here\n         _ => (),"}, {"sha": "674418dcca6adf7b4103b3c17a3e048061891a74", "filename": "src/test/compile-fail/parser-recovery-1.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fcompile-fail%2Fparser-recovery-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fcompile-fail%2Fparser-recovery-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fparser-recovery-1.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can recover from missing braces in the parser.\n+\n+trait Foo {\n+    fn bar() {\n+        let x = foo(); //~ ERROR unresolved name `foo`\n+\n+}\n+\n+fn main() {\n+    let x = y.;  //~ ERROR unexpected token\n+                 //~^ ERROR unresolved name `y`\n+} //~ ERROR this file contains an un-closed delimiter"}, {"sha": "f1eb696f6ff84563391fdf1033ae55eb0d5e46ed", "filename": "src/test/compile-fail/parser-recovery-2.rs", "status": "renamed", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fcompile-fail%2Fparser-recovery-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fcompile-fail%2Fparser-recovery-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fparser-recovery-2.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z parse-only\n+// Test that we can recover from mismatched braces in the parser.\n \n-extern {\n-    fn printf(...); //~ ERROR: variadic function must be declared with at least one named argument\n-    fn printf(..., foo: isize); //~ ERROR: `...` must be last in argument list for variadic function\n+trait Foo {\n+    fn bar() {\n+        let x = foo(); //~ ERROR unresolved name `foo`\n+    ) //~ ERROR incorrect close delimiter: `)`\n }\n \n-fn main() {}\n+fn main() {\n+    let x = y.;  //~ ERROR unexpected token\n+                 //~^ ERROR unresolved name `y`\n+}", "previous_filename": "src/test/parse-fail/variadic-ffi-1.rs"}, {"sha": "ff434d87e1fb2c141955f5f363ad7d4837a56974", "filename": "src/test/parse-fail/brace-after-qualified-path-in-match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbrace-after-qualified-path-in-match.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z parse-only\n+\n fn foo() {\n     match x {\n         <T as Trait>::Type{key: value} => (),"}, {"sha": "41a3b06e6556e9bd1d8ba065256f345de9b1cf90", "filename": "src/test/parse-fail/issue-10636-2.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fissue-10636-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fissue-10636-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-10636-2.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -8,8 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME(31528) we emit a bunch of silly errors here due to continuing past the\n+// first one. This would be easy-ish to address by better recovery in tokenisation.\n+\n // compile-flags: -Z parse-only\n \n-pub fn trace_option(option: Option<isize>) {\n+pub fn trace_option(option: Option<isize>) { //~ HELP did you mean to close this delimiter?\n     option.map(|some| 42; //~ NOTE: unclosed delimiter\n+                          //~^ ERROR: expected one of\n } //~ ERROR: incorrect close delimiter\n+//~^ ERROR: expected one of\n+//~ ERROR: this file contains an un-closed delimiter"}, {"sha": "7c30b5f26296ba0ef0583de657fc0b95742f08f4", "filename": "src/test/parse-fail/issue-14303-path.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-14303-path.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -12,3 +12,4 @@\n \n fn bar<'a, T>(x: mymodule::X<'a, T, 'b, 'c>) {}\n //~^ ERROR lifetime parameters must be declared prior to type parameters\n+//~^^ ERROR unexpected token"}, {"sha": "2e799a72c81af7b6b1a3bba5c65a8149cb7b48e6", "filename": "src/test/parse-fail/issue-2354.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fissue-2354.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fissue-2354.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-2354.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -12,8 +12,8 @@\n \n fn foo() { //~ HELP did you mean to close this delimiter?\n   match Some(x) {\n-      Some(y) { panic!(); }\n-      None    { panic!(); }\n+      Some(y) => { panic!(); }\n+      None => { panic!(); }\n }\n \n fn bar() {"}, {"sha": "b99d0493ff7333b2f402829193a766a3ecc1f382", "filename": "src/test/parse-fail/match-refactor-to-expr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fmatch-refactor-to-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fmatch-refactor-to-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fmatch-refactor-to-expr.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z parse-only\n+\n fn main() {\n     let foo =\n         match //~ NOTE did you mean to remove this `match` keyword?"}, {"sha": "d3aa4b72b78a55190c1fdadb9e6d982c217a7709", "filename": "src/test/parse-fail/paren-after-qualified-path-in-match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fparen-after-qualified-path-in-match.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z parse-only\n+\n fn foo() {\n     match x {\n         <T as Trait>::Type(2) => (),"}, {"sha": "a163b38b49270ac25f18c67d055074e39689c038", "filename": "src/test/parse-fail/pat-lt-bracket-4.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-4.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// compile-flags: -Z parse-only\n+\n enum BtNode {\n     Node(u32,Box<BtNode>,Box<BtNode>),\n     Leaf(u32),"}, {"sha": "bc27aedb627ee5fe7c784b6b7c920df0bb88e0f5", "filename": "src/test/parse-fail/pat-lt-bracket-6.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-6.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -10,4 +10,5 @@\n \n fn main() {\n     let Test(&desc[..]) = x; //~ error: expected one of `,` or `@`, found `[`\n+    //~^ ERROR expected one of `:`, `;`, or `=`, found `..`\n }"}, {"sha": "3e9478da44de596853501b9c5a90cceec4c5efe9", "filename": "src/test/parse-fail/pat-lt-bracket-7.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fpat-lt-bracket-7.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -9,5 +9,6 @@\n // except according to those terms.\n \n fn main() {\n-    for thing(x[]) {} //~ error: expected one of `,` or `@`, found `[`\n+    for thing(x[]) in foo {} //~ error: expected one of `,` or `@`, found `[`\n+    //~^ ERROR: expected `in`, found `]`\n }"}, {"sha": "e57298f72804af423ba7a55a3c6e5e9d91529934", "filename": "src/test/parse-fail/struct-literal-in-for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-for.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -23,7 +23,7 @@ impl Foo {\n fn main() {\n     for x in Foo {\n         x: 3    //~ ERROR expected type, found `3`\n-    }.hi() {\n+    }.hi() { //~ ERROR expected one of `.`, `;`, `}`, or an operator, found `{`\n         println!(\"yo\");\n     }\n }"}, {"sha": "6bf41b7a450aff70a1c6492c4ce331b7c82e3b5d", "filename": "src/test/parse-fail/struct-literal-in-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-if.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -23,7 +23,7 @@ impl Foo {\n fn main() {\n     if Foo {\n         x: 3    //~ ERROR expected type, found `3`\n-    }.hi() {\n+    }.hi() { //~ ERROR expected one of `.`, `;`, `}`, or an operator, found `{`\n         println!(\"yo\");\n     }\n }"}, {"sha": "679f4542824fbd0ff4155e7429add1bd28daac80", "filename": "src/test/parse-fail/struct-literal-in-match-discriminant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-match-discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-match-discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-match-discriminant.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -20,6 +20,6 @@ fn main() {\n     } {\n         Foo {\n             x: x\n-        } => {}\n+        } => {} //~ ERROR expected one of `.`, `;`, `}`, or an operator, found `=>`\n     }\n }"}, {"sha": "b388aac2c54875400a3ea4b0e35c770ec43c2fd5", "filename": "src/test/parse-fail/struct-literal-in-while.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9543a9b747225a85a010c020d1b65b4b48ba4dd/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fstruct-literal-in-while.rs?ref=f9543a9b747225a85a010c020d1b65b4b48ba4dd", "patch": "@@ -23,7 +23,7 @@ impl Foo {\n fn main() {\n     while Foo {\n         x: 3    //~ ERROR expected type, found `3`\n-    }.hi() {\n+    }.hi() { //~ ERROR expected one of `.`, `;`, `}`, or an operator, found `{`\n         println!(\"yo\");\n     }\n }"}]}