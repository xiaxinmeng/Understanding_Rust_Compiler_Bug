{"sha": "5033213fc973e209c84b1c0309933574230254cc", "node_id": "C_kwDOAAsO6NoAKDUwMzMyMTNmYzk3M2UyMDljODRiMWMwMzA5OTMzNTc0MjMwMjU0Y2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-03T10:59:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-03T10:59:21Z"}, "message": "Auto merge of #13885 - Veykril:bin-op-adjust, r=Veykril\n\nSkip lifetime elision on fn pointers and fn trait types\n\nThese currently don't work correctly, so it's better to not render them at all there", "tree": {"sha": "c0b0f678e40b0f00216f12708a3741810b769461", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0b0f678e40b0f00216f12708a3741810b769461"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5033213fc973e209c84b1c0309933574230254cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5033213fc973e209c84b1c0309933574230254cc", "html_url": "https://github.com/rust-lang/rust/commit/5033213fc973e209c84b1c0309933574230254cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5033213fc973e209c84b1c0309933574230254cc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "50801b7d6a5c18d24ae47e5a8963431899da20cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/50801b7d6a5c18d24ae47e5a8963431899da20cd", "html_url": "https://github.com/rust-lang/rust/commit/50801b7d6a5c18d24ae47e5a8963431899da20cd"}, {"sha": "b996a54cd845ae315a7b089437b43bf1b79a5e65", "url": "https://api.github.com/repos/rust-lang/rust/commits/b996a54cd845ae315a7b089437b43bf1b79a5e65", "html_url": "https://github.com/rust-lang/rust/commit/b996a54cd845ae315a7b089437b43bf1b79a5e65"}], "stats": {"total": 165, "additions": 100, "deletions": 65}, "files": [{"sha": "a015f67024fd05531fb0c9fc2b37028439e1345d", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5033213fc973e209c84b1c0309933574230254cc/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033213fc973e209c84b1c0309933574230254cc/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=5033213fc973e209c84b1c0309933574230254cc", "patch": "@@ -334,6 +334,7 @@ impl<'a> InferenceContext<'a> {\n                 let (param_tys, ret_ty) = match res {\n                     Some(res) => {\n                         let adjustments = auto_deref_adjust_steps(&derefs);\n+                        // FIXME: Handle call adjustments for Fn/FnMut\n                         self.write_expr_adj(*callee, adjustments);\n                         res\n                     }"}, {"sha": "0057f439f1af45d9de5d8851b9c448de485f5031", "filename": "crates/ide-assists/src/handlers/add_explicit_type.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5033213fc973e209c84b1c0309933574230254cc/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033213fc973e209c84b1c0309933574230254cc/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_explicit_type.rs?ref=5033213fc973e209c84b1c0309933574230254cc", "patch": "@@ -47,7 +47,10 @@ pub(crate) fn add_explicit_type(acc: &mut Assists, ctx: &AssistContext<'_>) -> O\n     // Don't enable the assist if there is a type ascription without any placeholders\n     if let Some(ty) = &ascribed_ty {\n         let mut contains_infer_ty = false;\n-        walk_ty(ty, &mut |ty| contains_infer_ty |= matches!(ty, ast::Type::InferType(_)));\n+        walk_ty(ty, &mut |ty| {\n+            contains_infer_ty |= matches!(ty, ast::Type::InferType(_));\n+            false\n+        });\n         if !contains_infer_ty {\n             cov_mark::hit!(add_explicit_type_not_applicable_if_ty_already_specified);\n             return None;"}, {"sha": "0505f5784f81495058fe04584a18a31bd823b786", "filename": "crates/ide-assists/src/handlers/extract_type_alias.rs", "status": "modified", "additions": 62, "deletions": 58, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/5033213fc973e209c84b1c0309933574230254cc/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033213fc973e209c84b1c0309933574230254cc/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_type_alias.rs?ref=5033213fc973e209c84b1c0309933574230254cc", "patch": "@@ -108,76 +108,80 @@ fn collect_used_generics<'gp>(\n     }\n \n     let mut generics = Vec::new();\n-    walk_ty(ty, &mut |ty| match ty {\n-        ast::Type::PathType(ty) => {\n-            if let Some(path) = ty.path() {\n-                if let Some(name_ref) = path.as_single_name_ref() {\n-                    if let Some(param) = known_generics.iter().find(|gp| {\n-                        match gp {\n-                            ast::GenericParam::ConstParam(cp) => cp.name(),\n-                            ast::GenericParam::TypeParam(tp) => tp.name(),\n-                            _ => None,\n+    walk_ty(ty, &mut |ty| {\n+        match ty {\n+            ast::Type::PathType(ty) => {\n+                if let Some(path) = ty.path() {\n+                    if let Some(name_ref) = path.as_single_name_ref() {\n+                        if let Some(param) = known_generics.iter().find(|gp| {\n+                            match gp {\n+                                ast::GenericParam::ConstParam(cp) => cp.name(),\n+                                ast::GenericParam::TypeParam(tp) => tp.name(),\n+                                _ => None,\n+                            }\n+                            .map_or(false, |n| n.text() == name_ref.text())\n+                        }) {\n+                            generics.push(param);\n                         }\n-                        .map_or(false, |n| n.text() == name_ref.text())\n-                    }) {\n-                        generics.push(param);\n                     }\n+                    generics.extend(\n+                        path.segments()\n+                            .filter_map(|seg| seg.generic_arg_list())\n+                            .flat_map(|it| it.generic_args())\n+                            .filter_map(|it| match it {\n+                                ast::GenericArg::LifetimeArg(lt) => {\n+                                    let lt = lt.lifetime()?;\n+                                    known_generics.iter().find(find_lifetime(&lt.text()))\n+                                }\n+                                _ => None,\n+                            }),\n+                    );\n                 }\n-                generics.extend(\n-                    path.segments()\n-                        .filter_map(|seg| seg.generic_arg_list())\n-                        .flat_map(|it| it.generic_args())\n-                        .filter_map(|it| match it {\n-                            ast::GenericArg::LifetimeArg(lt) => {\n-                                let lt = lt.lifetime()?;\n-                                known_generics.iter().find(find_lifetime(&lt.text()))\n-                            }\n-                            _ => None,\n-                        }),\n-                );\n             }\n-        }\n-        ast::Type::ImplTraitType(impl_ty) => {\n-            if let Some(it) = impl_ty.type_bound_list() {\n-                generics.extend(\n-                    it.bounds()\n-                        .filter_map(|it| it.lifetime())\n-                        .filter_map(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n-                );\n+            ast::Type::ImplTraitType(impl_ty) => {\n+                if let Some(it) = impl_ty.type_bound_list() {\n+                    generics.extend(\n+                        it.bounds()\n+                            .filter_map(|it| it.lifetime())\n+                            .filter_map(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n+                    );\n+                }\n             }\n-        }\n-        ast::Type::DynTraitType(dyn_ty) => {\n-            if let Some(it) = dyn_ty.type_bound_list() {\n-                generics.extend(\n-                    it.bounds()\n-                        .filter_map(|it| it.lifetime())\n-                        .filter_map(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n-                );\n+            ast::Type::DynTraitType(dyn_ty) => {\n+                if let Some(it) = dyn_ty.type_bound_list() {\n+                    generics.extend(\n+                        it.bounds()\n+                            .filter_map(|it| it.lifetime())\n+                            .filter_map(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n+                    );\n+                }\n             }\n-        }\n-        ast::Type::RefType(ref_) => generics.extend(\n-            ref_.lifetime().and_then(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n-        ),\n-        ast::Type::ArrayType(ar) => {\n-            if let Some(expr) = ar.expr() {\n-                if let ast::Expr::PathExpr(p) = expr {\n-                    if let Some(path) = p.path() {\n-                        if let Some(name_ref) = path.as_single_name_ref() {\n-                            if let Some(param) = known_generics.iter().find(|gp| {\n-                                if let ast::GenericParam::ConstParam(cp) = gp {\n-                                    cp.name().map_or(false, |n| n.text() == name_ref.text())\n-                                } else {\n-                                    false\n+            ast::Type::RefType(ref_) => generics.extend(\n+                ref_.lifetime()\n+                    .and_then(|lt| known_generics.iter().find(find_lifetime(&lt.text()))),\n+            ),\n+            ast::Type::ArrayType(ar) => {\n+                if let Some(expr) = ar.expr() {\n+                    if let ast::Expr::PathExpr(p) = expr {\n+                        if let Some(path) = p.path() {\n+                            if let Some(name_ref) = path.as_single_name_ref() {\n+                                if let Some(param) = known_generics.iter().find(|gp| {\n+                                    if let ast::GenericParam::ConstParam(cp) = gp {\n+                                        cp.name().map_or(false, |n| n.text() == name_ref.text())\n+                                    } else {\n+                                        false\n+                                    }\n+                                }) {\n+                                    generics.push(param);\n                                 }\n-                            }) {\n-                                generics.push(param);\n                             }\n                         }\n                     }\n                 }\n             }\n-        }\n-        _ => (),\n+            _ => (),\n+        };\n+        false\n     });\n     // stable resort to lifetime, type, const\n     generics.sort_by_key(|gp| match gp {"}, {"sha": "aa03478599d67296bf261e0b4125ef078084eb37", "filename": "crates/ide-db/src/syntax_helpers/node_ext.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5033213fc973e209c84b1c0309933574230254cc/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033213fc973e209c84b1c0309933574230254cc/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsyntax_helpers%2Fnode_ext.rs?ref=5033213fc973e209c84b1c0309933574230254cc", "patch": "@@ -173,7 +173,8 @@ pub fn walk_pat(pat: &ast::Pat, cb: &mut dyn FnMut(ast::Pat)) {\n }\n \n /// Preorder walk all the type's sub types.\n-pub fn walk_ty(ty: &ast::Type, cb: &mut dyn FnMut(ast::Type)) {\n+// FIXME: Make the control flow more proper\n+pub fn walk_ty(ty: &ast::Type, cb: &mut dyn FnMut(ast::Type) -> bool) {\n     let mut preorder = ty.syntax().preorder();\n     while let Some(event) = preorder.next() {\n         let node = match event {\n@@ -184,10 +185,12 @@ pub fn walk_ty(ty: &ast::Type, cb: &mut dyn FnMut(ast::Type)) {\n         match ast::Type::cast(node) {\n             Some(ty @ ast::Type::MacroType(_)) => {\n                 preorder.skip_subtree();\n-                cb(ty)\n+                cb(ty);\n             }\n             Some(ty) => {\n-                cb(ty);\n+                if cb(ty) {\n+                    preorder.skip_subtree();\n+                }\n             }\n             // skip const args\n             None if ast::ConstArg::can_cast(kind) => {"}, {"sha": "2aa5e3dc734fc6901704bb0b6529e0d9f81c11eb", "filename": "crates/ide/src/inlay_hints/fn_lifetime_fn.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5033213fc973e209c84b1c0309933574230254cc/crates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5033213fc973e209c84b1c0309933574230254cc/crates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Ffn_lifetime_fn.rs?ref=5033213fc973e209c84b1c0309933574230254cc", "patch": "@@ -59,9 +59,14 @@ pub(super) fn hints(\n                         r.amp_token(),\n                         lifetime,\n                         is_elided,\n-                    ))\n+                    ));\n+                    false\n                 }\n-                _ => (),\n+                ast::Type::FnPtrType(_) => true,\n+                ast::Type::PathType(t) => {\n+                    t.path().and_then(|it| it.segment()).and_then(|it| it.param_list()).is_some()\n+                }\n+                _ => false,\n             })\n         });\n         acc\n@@ -146,8 +151,13 @@ pub(super) fn hints(\n                         is_trivial = false;\n                         acc.push(mk_lt_hint(amp, output_lt.to_string()));\n                     }\n+                    false\n+                }\n+                ast::Type::FnPtrType(_) => true,\n+                ast::Type::PathType(t) => {\n+                    t.path().and_then(|it| it.segment()).and_then(|it| it.param_list()).is_some()\n                 }\n-                _ => (),\n+                _ => false,\n             })\n         }\n     }\n@@ -295,6 +305,20 @@ impl () {\n     // ^^^<'0, '1>\n         // ^'0       ^'1     ^'0\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn hints_lifetimes_skip_fn_likes() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                lifetime_elision_hints: LifetimeElisionHints::Always,\n+                ..TEST_CONFIG\n+            },\n+            r#\"\n+fn fn_ptr(a: fn(&()) -> &()) {}\n+fn fn_trait<>(a: impl Fn(&()) -> &()) {}\n \"#,\n         );\n     }"}]}