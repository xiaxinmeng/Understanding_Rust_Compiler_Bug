{"sha": "05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1Y2NjZGM5YjMyMWU2NTY1YjNlNjJlOGI1MmFlYzUzZDEwNmVmMmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-28T10:45:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-28T10:45:28Z"}, "message": "Auto merge of #88019 - inquisitivecrystal:macro-def, r=cjgillot\n\nTreat macros as HIR items\n\nMacros have historically been treated differently from other items at the HIR level. This PR makes them just like normal items. There are a few special cases left over, which I've attempted to lay out below. By normalizing the treatment of macro items, this PR simplifies a fair bit of code and fixes some bugs at the same time. For more information, see #87406.\n\nr? `@cjgillot`\n\n## Backwards incompatibility\n\nThis is backwards incompatible in one small way. Due to a mistake, it was previously possible to apply stability attributes to an exported macro, even without enabling the `staged_api` feature. This never should have worked. After this PR, it will error, as it should. We could make it a warning instead, but that would require a special case for a feature that shouldn't ever have worked and is likely used by no or very few crates, so I'm not thrilled about the idea.\n\n## Notes for reviewers\n### Commit seperation\n\nI'd recommend reviewing this PR commit by commit. The commit chunking wasn't perfect, but it's better than looking at the combined diff, which is quite overwhelming. The compiler and standard library build after each commit, although tests do not necessarily pass and tools do not necessarily build till the end of the series.\n\n### Special cases\nThere are a few special cases that remain after this change. Here are the notable ones I remember:\n\n1. Visibility works a bit differently for `macro_rules!` macros than other items, since they aren't generally marked with `pub` but instead with `#[macro_export]`.\n2. Since `#[macro_export]` macros always have paths at the top level of the crate, some additional handling needs to be done on the reexport to top level.\n### Performance impact\n\nI don't know for sure, but theses changes may slightly hurt performance. They create more work for the compiler in a few places. For instance, some operations that were previously run only for exported macros are now run for all macros. A perf run is probably advisable. For all I know we'll see performance improvements instead. :)\n\n## Issues resolved\n\nThis resolves #87406 (the tracking issue for this change). It also fixes several bugs:\n\nFixes #59306.\nFixes #73754.\nFixes #87257.", "tree": {"sha": "d6d123da95741a6b5bad6f4e6288805fa500f174", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d6d123da95741a6b5bad6f4e6288805fa500f174"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "html_url": "https://github.com/rust-lang/rust/commit/05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2031fd6e46fbe4da271bb23d55c211b2e16dd91f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2031fd6e46fbe4da271bb23d55c211b2e16dd91f", "html_url": "https://github.com/rust-lang/rust/commit/2031fd6e46fbe4da271bb23d55c211b2e16dd91f"}, {"sha": "b5a41418f84b4d54b9137fe9c83c50f015161063", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a41418f84b4d54b9137fe9c83c50f015161063", "html_url": "https://github.com/rust-lang/rust/commit/b5a41418f84b4d54b9137fe9c83c50f015161063"}], "stats": {"total": 734, "additions": 338, "deletions": 396}, "files": [{"sha": "af23324cbefdb1531c9e1d9c74561b177a702a2b", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -4146,6 +4146,7 @@ dependencies = [\n name = \"rustc_privacy\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\",\n  \"rustc_errors\","}, {"sha": "cc87078d54b3f5fcfc5955d93d56373cdb8c5084", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -170,7 +170,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_item_id_use_tree(use_tree, i.id, &mut vec);\n                 vec\n             }\n-            ItemKind::MacroDef(..) => SmallVec::new(),\n             ItemKind::Fn(..) | ItemKind::Impl(box ImplKind { of_trait: None, .. }) => {\n                 smallvec![i.id]\n             }\n@@ -212,28 +211,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item<'hir>> {\n         let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis, None);\n-\n-        if let ItemKind::MacroDef(MacroDef { ref body, macro_rules }) = i.kind {\n-            if !macro_rules || self.sess.contains_name(&i.attrs, sym::macro_export) {\n-                let hir_id = self.lower_node_id(i.id);\n-                self.lower_attrs(hir_id, &i.attrs);\n-                let body = P(self.lower_mac_args(body));\n-                self.insert_macro_def(hir::MacroDef {\n-                    ident,\n-                    vis,\n-                    def_id: hir_id.expect_owner(),\n-                    span: i.span,\n-                    ast: MacroDef { body, macro_rules },\n-                });\n-            } else {\n-                for a in i.attrs.iter() {\n-                    let a = self.lower_attr(a);\n-                    self.non_exported_macro_attrs.push(a);\n-                }\n-            }\n-            return None;\n-        }\n-\n         let hir_id = self.lower_node_id(i.id);\n         let attrs = self.lower_attrs(hir_id, &i.attrs);\n         let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, &mut vis, &i.kind);\n@@ -465,7 +442,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self.lower_generics(generics, ImplTraitContext::disallowed()),\n                 self.lower_param_bounds(bounds, ImplTraitContext::disallowed()),\n             ),\n-            ItemKind::MacroDef(..) | ItemKind::MacCall(..) => {\n+            ItemKind::MacroDef(MacroDef { ref body, macro_rules }) => {\n+                let body = P(self.lower_mac_args(body));\n+\n+                hir::ItemKind::Macro(ast::MacroDef { body, macro_rules })\n+            }\n+            ItemKind::MacCall(..) => {\n                 panic!(\"`TyMac` should have been expanded by now\")\n             }\n         }"}, {"sha": "bd2c9f41a5378ef7d511269b1ef9891f0d673484", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -103,7 +103,6 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// The items being lowered are collected here.\n     owners: IndexVec<LocalDefId, Option<hir::OwnerNode<'hir>>>,\n     bodies: BTreeMap<hir::BodyId, hir::Body<'hir>>,\n-    non_exported_macro_attrs: Vec<ast::Attribute>,\n \n     trait_impls: BTreeMap<DefId, Vec<LocalDefId>>,\n \n@@ -330,7 +329,6 @@ pub fn lower_crate<'a, 'hir>(\n         trait_impls: BTreeMap::new(),\n         modules: BTreeMap::new(),\n         attrs: BTreeMap::default(),\n-        non_exported_macro_attrs: Vec::new(),\n         catch_scopes: Vec::new(),\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n@@ -551,7 +549,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         let krate = hir::Crate {\n-            non_exported_macro_attrs: self.arena.alloc_from_iter(self.non_exported_macro_attrs),\n             owners: self.owners,\n             bodies: self.bodies,\n             body_ids,\n@@ -600,13 +597,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         id\n     }\n \n-    fn insert_macro_def(&mut self, item: hir::MacroDef<'hir>) {\n-        let def_id = item.def_id;\n-        let item = self.arena.alloc(item);\n-        self.owners.ensure_contains_elem(def_id, || None);\n-        self.owners[def_id] = Some(hir::OwnerNode::MacroDef(item));\n-    }\n-\n     fn allocate_hir_id_counter(&mut self, owner: NodeId) -> hir::HirId {\n         // Set up the counter if needed.\n         self.item_local_id_counters.entry(owner).or_insert(0);"}, {"sha": "f729973ddc62e1ccdab4f51531a644f2214da04b", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -578,6 +578,33 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n         }\n     }\n \n+    fn print_mac_def(\n+        &mut self,\n+        macro_def: &ast::MacroDef,\n+        ident: &Ident,\n+        sp: &Span,\n+        print_visibility: impl FnOnce(&mut Self),\n+    ) {\n+        let (kw, has_bang) = if macro_def.macro_rules {\n+            (\"macro_rules\", true)\n+        } else {\n+            print_visibility(self);\n+            (\"macro\", false)\n+        };\n+        self.print_mac_common(\n+            Some(MacHeader::Keyword(kw)),\n+            has_bang,\n+            Some(*ident),\n+            macro_def.body.delim(),\n+            &macro_def.body.inner_tokens(),\n+            true,\n+            *sp,\n+        );\n+        if macro_def.body.need_semicolon() {\n+            self.word(\";\");\n+        }\n+    }\n+\n     fn print_path(&mut self, path: &ast::Path, colons_before_params: bool, depth: usize) {\n         self.maybe_print_comment(path.span.lo());\n \n@@ -1305,24 +1332,9 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ItemKind::MacroDef(ref macro_def) => {\n-                let (kw, has_bang) = if macro_def.macro_rules {\n-                    (\"macro_rules\", true)\n-                } else {\n-                    self.print_visibility(&item.vis);\n-                    (\"macro\", false)\n-                };\n-                self.print_mac_common(\n-                    Some(MacHeader::Keyword(kw)),\n-                    has_bang,\n-                    Some(item.ident),\n-                    macro_def.body.delim(),\n-                    &macro_def.body.inner_tokens(),\n-                    true,\n-                    item.span,\n-                );\n-                if macro_def.body.need_semicolon() {\n-                    self.word(\";\");\n-                }\n+                self.print_mac_def(macro_def, &item.ident, &item.span, |state| {\n+                    state.print_visibility(&item.vis)\n+                });\n             }\n         }\n         self.ann.post(self, AnnNode::Item(item))"}, {"sha": "0801a1bde2264b545fce729dbc1f2d68af61a982", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -35,7 +35,6 @@ macro_rules! arena_types {\n             [few] inline_asm: rustc_hir::InlineAsm<$tcx>,\n             [few] llvm_inline_asm: rustc_hir::LlvmInlineAsm<$tcx>,\n             [] local: rustc_hir::Local<$tcx>,\n-            [few] macro_def: rustc_hir::MacroDef<$tcx>,\n             [few] mod_: rustc_hir::Mod<$tcx>,\n             [] param: rustc_hir::Param<$tcx>,\n             [] pat: rustc_hir::Pat<$tcx>,"}, {"sha": "a9bd83a67c9dcff2c73efbaa95ee70f1c1294195", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 9, "deletions": 57, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -670,9 +670,6 @@ pub struct ModuleItems {\n /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/hir.html\n #[derive(Debug)]\n pub struct Crate<'hir> {\n-    // Attributes from non-exported macros, kept only for collecting the library feature list.\n-    pub non_exported_macro_attrs: &'hir [Attribute],\n-\n     pub owners: IndexVec<LocalDefId, Option<OwnerNode<'hir>>>,\n     pub bodies: BTreeMap<BodyId, Body<'hir>>,\n     pub trait_impls: BTreeMap<DefId, Vec<LocalDefId>>,\n@@ -743,7 +740,7 @@ impl Crate<'_> {\n                 OwnerNode::ForeignItem(item) => visitor.visit_foreign_item(item),\n                 OwnerNode::ImplItem(item) => visitor.visit_impl_item(item),\n                 OwnerNode::TraitItem(item) => visitor.visit_trait_item(item),\n-                OwnerNode::MacroDef(_) | OwnerNode::Crate(_) => {}\n+                OwnerNode::Crate(_) => {}\n             }\n         }\n     }\n@@ -758,7 +755,7 @@ impl Crate<'_> {\n             Some(OwnerNode::ForeignItem(item)) => visitor.visit_foreign_item(item),\n             Some(OwnerNode::ImplItem(item)) => visitor.visit_impl_item(item),\n             Some(OwnerNode::TraitItem(item)) => visitor.visit_trait_item(item),\n-            Some(OwnerNode::MacroDef(_)) | Some(OwnerNode::Crate(_)) | None => {}\n+            Some(OwnerNode::Crate(_)) | None => {}\n         })\n     }\n \n@@ -768,32 +765,6 @@ impl Crate<'_> {\n             _ => None,\n         })\n     }\n-\n-    pub fn exported_macros<'hir>(&'hir self) -> impl Iterator<Item = &'hir MacroDef<'hir>> + 'hir {\n-        self.owners.iter().filter_map(|owner| match owner {\n-            Some(OwnerNode::MacroDef(macro_def)) => Some(*macro_def),\n-            _ => None,\n-        })\n-    }\n-}\n-\n-/// A macro definition, in this crate or imported from another.\n-///\n-/// Not parsed directly, but created on macro import or `macro_rules!` expansion.\n-#[derive(Debug)]\n-pub struct MacroDef<'hir> {\n-    pub ident: Ident,\n-    pub vis: Visibility<'hir>,\n-    pub def_id: LocalDefId,\n-    pub span: Span,\n-    pub ast: ast::MacroDef,\n-}\n-\n-impl MacroDef<'_> {\n-    #[inline]\n-    pub fn hir_id(&self) -> HirId {\n-        HirId::make_owner(self.def_id)\n-    }\n }\n \n /// A block of statements `{ .. }`, which may have a label (in this case the\n@@ -2602,7 +2573,7 @@ pub struct PolyTraitRef<'hir> {\n \n pub type Visibility<'hir> = Spanned<VisibilityKind<'hir>>;\n \n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum VisibilityKind<'hir> {\n     Public,\n     Crate(CrateSugar),\n@@ -2791,6 +2762,8 @@ pub enum ItemKind<'hir> {\n     Const(&'hir Ty<'hir>, BodyId),\n     /// A function declaration.\n     Fn(FnSig<'hir>, Generics<'hir>, BodyId),\n+    /// A MBE macro definition (`macro_rules!` or `macro`).\n+    Macro(ast::MacroDef),\n     /// A module.\n     Mod(Mod<'hir>),\n     /// An external module, e.g. `extern { .. }`.\n@@ -2856,6 +2829,7 @@ impl ItemKind<'_> {\n             ItemKind::Static(..) => \"static item\",\n             ItemKind::Const(..) => \"constant item\",\n             ItemKind::Fn(..) => \"function\",\n+            ItemKind::Macro(..) => \"macro\",\n             ItemKind::Mod(..) => \"module\",\n             ItemKind::ForeignMod { .. } => \"extern block\",\n             ItemKind::GlobalAsm(..) => \"global asm item\",\n@@ -2996,7 +2970,6 @@ pub enum OwnerNode<'hir> {\n     ForeignItem(&'hir ForeignItem<'hir>),\n     TraitItem(&'hir TraitItem<'hir>),\n     ImplItem(&'hir ImplItem<'hir>),\n-    MacroDef(&'hir MacroDef<'hir>),\n     Crate(&'hir Mod<'hir>),\n }\n \n@@ -3006,8 +2979,7 @@ impl<'hir> OwnerNode<'hir> {\n             OwnerNode::Item(Item { ident, .. })\n             | OwnerNode::ForeignItem(ForeignItem { ident, .. })\n             | OwnerNode::ImplItem(ImplItem { ident, .. })\n-            | OwnerNode::TraitItem(TraitItem { ident, .. })\n-            | OwnerNode::MacroDef(MacroDef { ident, .. }) => Some(*ident),\n+            | OwnerNode::TraitItem(TraitItem { ident, .. }) => Some(*ident),\n             OwnerNode::Crate(..) => None,\n         }\n     }\n@@ -3018,7 +2990,6 @@ impl<'hir> OwnerNode<'hir> {\n             | OwnerNode::ForeignItem(ForeignItem { span, .. })\n             | OwnerNode::ImplItem(ImplItem { span, .. })\n             | OwnerNode::TraitItem(TraitItem { span, .. })\n-            | OwnerNode::MacroDef(MacroDef { span, .. })\n             | OwnerNode::Crate(Mod { inner: span, .. }) => *span,\n         }\n     }\n@@ -3062,8 +3033,7 @@ impl<'hir> OwnerNode<'hir> {\n             OwnerNode::Item(Item { def_id, .. })\n             | OwnerNode::TraitItem(TraitItem { def_id, .. })\n             | OwnerNode::ImplItem(ImplItem { def_id, .. })\n-            | OwnerNode::ForeignItem(ForeignItem { def_id, .. })\n-            | OwnerNode::MacroDef(MacroDef { def_id, .. }) => *def_id,\n+            | OwnerNode::ForeignItem(ForeignItem { def_id, .. }) => *def_id,\n             OwnerNode::Crate(..) => crate::CRATE_HIR_ID.owner,\n         }\n     }\n@@ -3095,13 +3065,6 @@ impl<'hir> OwnerNode<'hir> {\n             _ => panic!(),\n         }\n     }\n-\n-    pub fn expect_macro_def(self) -> &'hir MacroDef<'hir> {\n-        match self {\n-            OwnerNode::MacroDef(n) => n,\n-            _ => panic!(),\n-        }\n-    }\n }\n \n impl<'hir> Into<OwnerNode<'hir>> for &'hir Item<'hir> {\n@@ -3128,20 +3091,13 @@ impl<'hir> Into<OwnerNode<'hir>> for &'hir TraitItem<'hir> {\n     }\n }\n \n-impl<'hir> Into<OwnerNode<'hir>> for &'hir MacroDef<'hir> {\n-    fn into(self) -> OwnerNode<'hir> {\n-        OwnerNode::MacroDef(self)\n-    }\n-}\n-\n impl<'hir> Into<Node<'hir>> for OwnerNode<'hir> {\n     fn into(self) -> Node<'hir> {\n         match self {\n             OwnerNode::Item(n) => Node::Item(n),\n             OwnerNode::ForeignItem(n) => Node::ForeignItem(n),\n             OwnerNode::ImplItem(n) => Node::ImplItem(n),\n             OwnerNode::TraitItem(n) => Node::TraitItem(n),\n-            OwnerNode::MacroDef(n) => Node::MacroDef(n),\n             OwnerNode::Crate(n) => Node::Crate(n),\n         }\n     }\n@@ -3167,7 +3123,6 @@ pub enum Node<'hir> {\n     Arm(&'hir Arm<'hir>),\n     Block(&'hir Block<'hir>),\n     Local(&'hir Local<'hir>),\n-    MacroDef(&'hir MacroDef<'hir>),\n \n     /// `Ctor` refers to the constructor of an enum variant or struct. Only tuple or unit variants\n     /// with synthesized constructors.\n@@ -3204,7 +3159,6 @@ impl<'hir> Node<'hir> {\n             | Node::ForeignItem(ForeignItem { ident, .. })\n             | Node::Field(FieldDef { ident, .. })\n             | Node::Variant(Variant { ident, .. })\n-            | Node::MacroDef(MacroDef { ident, .. })\n             | Node::Item(Item { ident, .. })\n             | Node::PathSegment(PathSegment { ident, .. }) => Some(*ident),\n             Node::Lifetime(lt) => Some(lt.name.ident()),\n@@ -3265,8 +3219,7 @@ impl<'hir> Node<'hir> {\n             Node::Item(Item { def_id, .. })\n             | Node::TraitItem(TraitItem { def_id, .. })\n             | Node::ImplItem(ImplItem { def_id, .. })\n-            | Node::ForeignItem(ForeignItem { def_id, .. })\n-            | Node::MacroDef(MacroDef { def_id, .. }) => Some(HirId::make_owner(*def_id)),\n+            | Node::ForeignItem(ForeignItem { def_id, .. }) => Some(HirId::make_owner(*def_id)),\n             Node::Field(FieldDef { hir_id, .. })\n             | Node::AnonConst(AnonConst { hir_id, .. })\n             | Node::Expr(Expr { hir_id, .. })\n@@ -3326,7 +3279,6 @@ impl<'hir> Node<'hir> {\n             Node::ForeignItem(i) => Some(OwnerNode::ForeignItem(i)),\n             Node::TraitItem(i) => Some(OwnerNode::TraitItem(i)),\n             Node::ImplItem(i) => Some(OwnerNode::ImplItem(i)),\n-            Node::MacroDef(i) => Some(OwnerNode::MacroDef(i)),\n             Node::Crate(i) => Some(OwnerNode::Crate(i)),\n             _ => None,\n         }"}, {"sha": "f4fbfd2692ca58866fa87f1bb223a8cdb8bac8f2", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -466,9 +466,6 @@ pub trait Visitor<'v>: Sized {\n         walk_assoc_type_binding(self, type_binding)\n     }\n     fn visit_attribute(&mut self, _id: HirId, _attr: &'v Attribute) {}\n-    fn visit_macro_def(&mut self, macro_def: &'v MacroDef<'v>) {\n-        walk_macro_def(self, macro_def)\n-    }\n     fn visit_vis(&mut self, vis: &'v Visibility<'v>) {\n         walk_vis(self, vis)\n     }\n@@ -484,19 +481,13 @@ pub trait Visitor<'v>: Sized {\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate<'v>) {\n     let top_mod = krate.module();\n     visitor.visit_mod(top_mod, top_mod.inner, CRATE_HIR_ID);\n-    walk_list!(visitor, visit_macro_def, krate.exported_macros());\n     for (&id, attrs) in krate.attrs.iter() {\n         for a in *attrs {\n             visitor.visit_attribute(id, a)\n         }\n     }\n }\n \n-pub fn walk_macro_def<'v, V: Visitor<'v>>(visitor: &mut V, macro_def: &'v MacroDef<'v>) {\n-    visitor.visit_id(macro_def.hir_id());\n-    visitor.visit_ident(macro_def.ident);\n-}\n-\n pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod<'v>, mod_hir_id: HirId) {\n     visitor.visit_id(mod_hir_id);\n     for &item_id in module.item_ids {\n@@ -586,6 +577,9 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item<'v>) {\n             item.span,\n             item.hir_id(),\n         ),\n+        ItemKind::Macro(_) => {\n+            visitor.visit_id(item.hir_id());\n+        }\n         ItemKind::Mod(ref module) => {\n             // `visit_mod()` takes care of visiting the `Item`'s `HirId`.\n             visitor.visit_mod(module, item.span, item.hir_id())"}, {"sha": "422a1064874c5c879d1f5de4f18b6b51671a5f5c", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -1,8 +1,8 @@\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n \n use crate::hir::{\n-    BodyId, Expr, ForeignItem, ForeignItemId, ImplItem, ImplItemId, Item, ItemId, MacroDef, Mod,\n-    TraitItem, TraitItemId, Ty, VisibilityKind,\n+    BodyId, Expr, ForeignItem, ForeignItemId, ImplItem, ImplItemId, Item, ItemId, Mod, TraitItem,\n+    TraitItemId, Ty, VisibilityKind,\n };\n use crate::hir_id::{HirId, ItemLocalId};\n use rustc_span::def_id::DefPathHash;\n@@ -190,16 +190,3 @@ impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for Item<'_> {\n         });\n     }\n }\n-\n-impl<HirCtx: crate::HashStableContext> HashStable<HirCtx> for MacroDef<'_> {\n-    fn hash_stable(&self, hcx: &mut HirCtx, hasher: &mut StableHasher) {\n-        let MacroDef { ident, def_id: _, ref ast, ref vis, span } = *self;\n-\n-        hcx.hash_hir_item_like(|hcx| {\n-            ident.name.hash_stable(hcx, hasher);\n-            ast.hash_stable(hcx, hasher);\n-            vis.hash_stable(hcx, hasher);\n-            span.hash_stable(hcx, hasher);\n-        });\n-    }\n-}"}, {"sha": "29c948fe31845745a81074eabe2a0192fd01347b", "filename": "compiler/rustc_hir/src/target.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Ftarget.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -111,6 +111,7 @@ impl Target {\n             ItemKind::Static(..) => Target::Static,\n             ItemKind::Const(..) => Target::Const,\n             ItemKind::Fn(..) => Target::Fn,\n+            ItemKind::Macro(..) => Target::MacroDef,\n             ItemKind::Mod(..) => Target::Mod,\n             ItemKind::ForeignMod { .. } => Target::ForeignMod,\n             ItemKind::GlobalAsm(..) => Target::GlobalAsm,"}, {"sha": "42e51f4bb48c74e76de9980647dd249290e57ec2", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -120,7 +120,6 @@ impl<'a> State<'a> {\n             // printing.\n             Node::Ctor(..) => panic!(\"cannot print isolated Ctor\"),\n             Node::Local(a) => self.print_local_decl(&a),\n-            Node::MacroDef(_) => panic!(\"cannot print MacroDef\"),\n             Node::Crate(..) => panic!(\"cannot print Crate\"),\n         }\n     }\n@@ -642,6 +641,11 @@ impl<'a> State<'a> {\n                 self.end(); // need to close a box\n                 self.ann.nested(self, Nested::Body(body));\n             }\n+            hir::ItemKind::Macro(ref macro_def) => {\n+                self.print_mac_def(macro_def, &item.ident, &item.span, |state| {\n+                    state.print_visibility(&item.vis)\n+                });\n+            }\n             hir::ItemKind::Mod(ref _mod) => {\n                 self.head(visibility_qualified(&item.vis, \"mod\"));\n                 self.print_ident(item.ident);"}, {"sha": "a5b4fa15921b859ba5bff01303b5f4b3c5dd18b3", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -585,24 +585,6 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n     fn check_crate(&mut self, cx: &LateContext<'_>, krate: &hir::Crate<'_>) {\n         self.check_missing_docs_attrs(cx, CRATE_DEF_ID, krate.module().inner, \"the\", \"crate\");\n-\n-        for macro_def in krate.exported_macros() {\n-            // Non exported macros should be skipped, since `missing_docs` only\n-            // applies to externally visible items.\n-            if !cx.access_levels.is_exported(macro_def.def_id) {\n-                continue;\n-            }\n-\n-            let attrs = cx.tcx.hir().attrs(macro_def.hir_id());\n-            let has_doc = attrs.iter().any(has_doc);\n-            if !has_doc {\n-                cx.struct_span_lint(\n-                    MISSING_DOCS,\n-                    cx.tcx.sess.source_map().guess_head_span(macro_def.span),\n-                    |lint| lint.build(\"missing documentation for macro\").emit(),\n-                );\n-            }\n-        }\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n@@ -636,6 +618,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n             hir::ItemKind::TyAlias(..)\n             | hir::ItemKind::Fn(..)\n+            | hir::ItemKind::Macro(..)\n             | hir::ItemKind::Mod(..)\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)"}, {"sha": "30400da86b4b0b042e93496fda12993057e650ba", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -453,10 +453,6 @@ fn late_lint_pass_crate<'tcx, T: LateLintPass<'tcx>>(tcx: TyCtxt<'tcx>, pass: T)\n         lint_callback!(cx, check_crate, krate);\n \n         hir_visit::walk_crate(cx, krate);\n-        for attr in krate.non_exported_macro_attrs {\n-            // This HIR ID is a lie, since the macro ID isn't available.\n-            cx.visit_attribute(hir::CRATE_HIR_ID, attr);\n-        }\n \n         lint_callback!(cx, check_crate_post, krate);\n     })"}, {"sha": "90bf34ee863b874226f5b300943f939d6e433337", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -37,9 +37,6 @@ fn lint_levels(tcx: TyCtxt<'_>, (): ()) -> LintLevelMap {\n \n     let push = builder.levels.push(tcx.hir().attrs(hir::CRATE_HIR_ID), &store, true);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n-    for macro_def in krate.exported_macros() {\n-        builder.levels.register_id(macro_def.hir_id());\n-    }\n     intravisit::walk_crate(&mut builder, krate);\n     builder.levels.pop(push);\n "}, {"sha": "dd44e0cb1fa90872c1f64cad00ddb3d52bd75eb3", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -1100,7 +1100,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                     let vis = self.get_visibility(child_index);\n                     let def_id = self.local_def_id(child_index);\n                     let res = Res::Def(kind, def_id);\n-                    callback(Export { res, ident, vis, span });\n+\n+                    // FIXME: Macros are currently encoded twice, once as items and once as\n+                    // reexports. We ignore the items here and only use the reexports.\n+                    if !matches!(kind, DefKind::Macro(..)) {\n+                        callback(Export { res, ident, vis, span });\n+                    }\n+\n                     // For non-re-export structs and variants add their constructors to children.\n                     // Re-export lists automatically contain constructors when necessary.\n                     match kind {"}, {"sha": "2cd4fe3b7062160bd061755e8259e255f822f7ef", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -448,9 +448,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n \n         krate.visit_all_item_likes(&mut self.as_deep_visitor());\n-        for macro_def in krate.exported_macros() {\n-            self.visit_macro_def(macro_def);\n-        }\n     }\n \n     fn encode_def_path_table(&mut self) {\n@@ -1385,6 +1382,9 @@ impl EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Fn(self.lazy(data))\n             }\n+            hir::ItemKind::Macro(ref macro_def) => {\n+                EntryKind::MacroDef(self.lazy(macro_def.clone()))\n+            }\n             hir::ItemKind::Mod(ref m) => {\n                 return self.encode_info_for_mod(item.def_id, m);\n             }\n@@ -1539,13 +1539,6 @@ impl EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    /// Serialize the text of exported macros\n-    fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n-        let def_id = macro_def.def_id.to_def_id();\n-        record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n-        self.encode_ident_span(def_id, macro_def.ident);\n-    }\n-\n     fn encode_info_for_generic_param(&mut self, def_id: DefId, kind: EntryKind, encode_type: bool) {\n         record!(self.tables.kind[def_id] <- kind);\n         if encode_type {\n@@ -1915,9 +1908,6 @@ impl Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n         intravisit::walk_generics(self, generics);\n         self.encode_info_for_generics(generics);\n     }\n-    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef<'tcx>) {\n-        self.encode_info_for_macro_def(macro_def);\n-    }\n }\n \n impl EncodeContext<'a, 'tcx> {\n@@ -1972,6 +1962,7 @@ impl EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Static(..)\n             | hir::ItemKind::Const(..)\n             | hir::ItemKind::Fn(..)\n+            | hir::ItemKind::Macro(..)\n             | hir::ItemKind::Mod(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..)"}, {"sha": "1351b4950f143cb9714bd4cc95fbe2ca7ba208ee", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -394,20 +394,6 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         }\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &'hir MacroDef<'hir>) {\n-        // Exported macros are visited directly from the crate root,\n-        // so they do not have `parent_node` set.\n-        // Find the correct enclosing module from their DefKey.\n-        let def_key = self.definitions.def_key(macro_def.def_id);\n-        let parent = def_key.parent.map_or(hir::CRATE_HIR_ID, |local_def_index| {\n-            self.definitions.local_def_id_to_hir_id(LocalDefId { local_def_index })\n-        });\n-        self.insert_owner(macro_def.def_id, OwnerNode::MacroDef(macro_def));\n-        self.with_parent(parent, |this| {\n-            this.insert_nested(macro_def.def_id);\n-        });\n-    }\n-\n     fn visit_variant(&mut self, v: &'hir Variant<'hir>, g: &'hir Generics<'hir>, item_id: HirId) {\n         self.insert(v.span, v.id, Node::Variant(v));\n         self.with_parent(v.id, |this| {"}, {"sha": "62d0374fb52e1a135a50e124c8810a1964da6bb0", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -10,7 +10,6 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_hir::intravisit;\n-use rustc_hir::intravisit::Visitor;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::*;\n use rustc_index::vec::Idx;\n@@ -218,6 +217,7 @@ impl<'hir> Map<'hir> {\n                 ItemKind::Static(..) => DefKind::Static,\n                 ItemKind::Const(..) => DefKind::Const,\n                 ItemKind::Fn(..) => DefKind::Fn,\n+                ItemKind::Macro(..) => DefKind::Macro(MacroKind::Bang),\n                 ItemKind::Mod(..) => DefKind::Mod,\n                 ItemKind::OpaqueTy(..) => DefKind::OpaqueTy,\n                 ItemKind::TyAlias(..) => DefKind::TyAlias,\n@@ -266,7 +266,6 @@ impl<'hir> Map<'hir> {\n                 ExprKind::Closure(.., Some(_)) => DefKind::Generator,\n                 _ => bug!(\"def_kind: unsupported node: {}\", self.node_to_string(hir_id)),\n             },\n-            Node::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n             Node::GenericParam(param) => match param.kind {\n                 GenericParamKind::Lifetime { .. } => DefKind::LifetimeParam,\n                 GenericParamKind::Type { .. } => DefKind::TyParam,\n@@ -543,15 +542,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn visit_exported_macros_in_krate<V>(&self, visitor: &mut V)\n-    where\n-        V: Visitor<'hir>,\n-    {\n-        for macro_def in self.krate().exported_macros() {\n-            visitor.visit_macro_def(macro_def);\n-        }\n-    }\n-\n     /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n     /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n     pub fn parent_iter(&self, current_id: HirId) -> ParentHirIterator<'_, 'hir> {\n@@ -645,8 +635,6 @@ impl<'hir> Map<'hir> {\n     /// in a module, trait, or impl.\n     pub fn get_parent_item(&self, hir_id: HirId) -> HirId {\n         if let Some((hir_id, _node)) = self.parent_owner_iter(hir_id).next() {\n-            // A MacroDef does not have children.\n-            debug_assert!(!matches!(_node, OwnerNode::MacroDef(_)));\n             hir_id\n         } else {\n             CRATE_HIR_ID\n@@ -774,13 +762,6 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn expect_macro_def(&self, id: HirId) -> &'hir MacroDef<'hir> {\n-        match self.tcx.hir_owner(id.expect_owner()) {\n-            Some(Owner { node: OwnerNode::MacroDef(macro_def) }) => macro_def,\n-            _ => bug!(\"expected macro def, found {}\", self.node_to_string(id)),\n-        }\n-    }\n-\n     pub fn expect_expr(&self, id: HirId) -> &'hir Expr<'hir> {\n         match self.find(id) {\n             Some(Node::Expr(expr)) => expr,\n@@ -800,7 +781,6 @@ impl<'hir> Map<'hir> {\n             Node::GenericParam(param) => param.name.ident().name,\n             Node::Binding(&Pat { kind: PatKind::Binding(_, _, l, _), .. }) => l.name,\n             Node::Ctor(..) => self.name(self.get_parent_item(id)),\n-            Node::MacroDef(md) => md.ident.name,\n             _ => return None,\n         })\n     }\n@@ -867,7 +847,6 @@ impl<'hir> Map<'hir> {\n             Node::Infer(i) => i.span,\n             Node::Visibility(v) => bug!(\"unexpected Visibility {:?}\", v),\n             Node::Local(local) => local.span,\n-            Node::MacroDef(macro_def) => macro_def.span,\n             Node::Crate(item) => item.inner,\n         };\n         Some(span)\n@@ -1013,7 +992,6 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n     tcx.sess.opts.dep_tracking_hash(true).hash_stable(&mut hcx, &mut stable_hasher);\n     tcx.sess.local_stable_crate_id().hash_stable(&mut hcx, &mut stable_hasher);\n-    tcx.untracked_crate.non_exported_macro_attrs.hash_stable(&mut hcx, &mut stable_hasher);\n \n     let crate_hash: Fingerprint = stable_hasher.finish();\n     Svh::new(crate_hash.to_smaller_hash())\n@@ -1062,6 +1040,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n                 ItemKind::Static(..) => \"static\",\n                 ItemKind::Const(..) => \"const\",\n                 ItemKind::Fn(..) => \"fn\",\n+                ItemKind::Macro(..) => \"macro\",\n                 ItemKind::Mod(..) => \"mod\",\n                 ItemKind::ForeignMod { .. } => \"foreign mod\",\n                 ItemKind::GlobalAsm(..) => \"global asm\",\n@@ -1118,7 +1097,6 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n         Some(Node::Lifetime(_)) => node_str(\"lifetime\"),\n         Some(Node::GenericParam(ref param)) => format!(\"generic_param {:?}{}\", param, id_str),\n         Some(Node::Visibility(ref vis)) => format!(\"visibility {:?}{}\", vis, id_str),\n-        Some(Node::MacroDef(_)) => format!(\"macro {}{}\", path_str(), id_str),\n         Some(Node::Crate(..)) => String::from(\"root_crate\"),\n         None => format!(\"unknown node{}\", id_str),\n     }"}, {"sha": "4cb362238c1c5106b6aa5029ec7d88188d9b00d3", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -1149,6 +1149,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n         match item.kind {\n             hir::ItemKind::ExternCrate(..)\n             | hir::ItemKind::Use(..)\n+            | hir::ItemKind::Macro(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::TyAlias(..)\n             | hir::ItemKind::Trait(..)"}, {"sha": "d3dac35d2c9e5a326a8de3272ffeeb180fac824c", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -1723,6 +1723,16 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n+        // Historically we've run more checks on non-exported than exported macros,\n+        // so this lets us continue to run them while maintaining backwards compatibility.\n+        // In the long run, the checks should be harmonized.\n+        if let ItemKind::Macro(ref macro_def) = item.kind {\n+            let def_id = item.def_id.to_def_id();\n+            if macro_def.macro_rules && !self.tcx.has_attr(def_id, sym::macro_export) {\n+                check_non_exported_macro_for_invalid_attrs(self.tcx, item);\n+            }\n+        }\n+\n         let target = Target::from_item(item);\n         self.check_attributes(item.hir_id(), &item.span, target, Some(ItemLike::Item(item)));\n         intravisit::walk_item(self, item)\n@@ -1795,11 +1805,6 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         intravisit::walk_variant(self, variant, generics, item_id)\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &'tcx hir::MacroDef<'tcx>) {\n-        self.check_attributes(macro_def.hir_id(), &macro_def.span, Target::MacroDef, None);\n-        intravisit::walk_macro_def(self, macro_def);\n-    }\n-\n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         self.check_attributes(param.hir_id, &param.span, Target::Param, None);\n \n@@ -1848,7 +1853,9 @@ fn check_invalid_crate_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n     }\n }\n \n-fn check_invalid_macro_level_attr(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n+fn check_non_exported_macro_for_invalid_attrs(tcx: TyCtxt<'_>, item: &Item<'_>) {\n+    let attrs = tcx.hir().attrs(item.hir_id());\n+\n     for attr in attrs {\n         if attr.has_name(sym::inline) {\n             struct_span_err!(\n@@ -1869,8 +1876,6 @@ fn check_mod_attrs(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     if module_def_id.is_top_level_module() {\n         check_attr_visitor.check_attributes(CRATE_HIR_ID, &DUMMY_SP, Target::Mod, None);\n         check_invalid_crate_level_attr(tcx, tcx.hir().krate_attrs());\n-        tcx.hir().visit_exported_macros_in_krate(check_attr_visitor);\n-        check_invalid_macro_level_attr(tcx, tcx.hir().krate().non_exported_macro_attrs);\n     }\n }\n "}, {"sha": "3f12a744be0e819cc69ad20f2813ce0fbfd18d21", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -107,10 +107,6 @@ fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> FxHashMap<Symbol\n     // Collect diagnostic items in this crate.\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n \n-    for m in tcx.hir().krate().exported_macros() {\n-        collector.observe_item(m.def_id);\n-    }\n-\n     collector.items\n }\n "}, {"sha": "b8ce973185c8d73011338ae1e4abe9d5f1b6dbbf", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -244,11 +244,6 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n     fn visit_attribute(&mut self, _: hir::HirId, attr: &'v ast::Attribute) {\n         self.record(\"Attribute\", Id::Attr(attr.id), attr);\n     }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'v hir::MacroDef<'v>) {\n-        self.record(\"MacroDef\", Id::Node(macro_def.hir_id()), macro_def);\n-        hir_visit::walk_macro_def(self, macro_def)\n-    }\n }\n \n impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {"}, {"sha": "7d15ca1e8f798a2299f5e9201d8abe6a7814798e", "filename": "compiler/rustc_passes/src/lib_features.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib_features.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -127,9 +127,7 @@ impl Visitor<'tcx> for LibFeatureCollector<'tcx> {\n fn get_lib_features(tcx: TyCtxt<'_>, (): ()) -> LibFeatures {\n     let mut collector = LibFeatureCollector::new(tcx);\n     let krate = tcx.hir().krate();\n-    for attr in krate.non_exported_macro_attrs {\n-        collector.visit_attribute(rustc_hir::CRATE_HIR_ID, attr);\n-    }\n+\n     intravisit::walk_crate(&mut collector, krate);\n     collector.lib_features\n }"}, {"sha": "23f43233b79ca5906d9628acacc25c46faea16ce", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -263,6 +263,7 @@ impl<'tcx> ReachableContext<'tcx> {\n                     | hir::ItemKind::Use(..)\n                     | hir::ItemKind::OpaqueTy(..)\n                     | hir::ItemKind::TyAlias(..)\n+                    | hir::ItemKind::Macro(..)\n                     | hir::ItemKind::Mod(..)\n                     | hir::ItemKind::ForeignMod { .. }\n                     | hir::ItemKind::Impl { .. }\n@@ -309,8 +310,7 @@ impl<'tcx> ReachableContext<'tcx> {\n             | Node::Ctor(..)\n             | Node::Field(_)\n             | Node::Ty(_)\n-            | Node::Crate(_)\n-            | Node::MacroDef(_) => {}\n+            | Node::Crate(_) => {}\n             _ => {\n                 bug!(\n                     \"found unexpected node kind in worklist: {} ({:?})\","}, {"sha": "a88393cea828593f0ac8696284af222226a4d808", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -538,19 +538,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         );\n     }\n \n-    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        self.annotate(\n-            md.def_id,\n-            md.span,\n-            None,\n-            AnnotationKind::Required,\n-            InheritDeprecation::Yes,\n-            InheritConstStability::No,\n-            InheritStability::No,\n-            |_| {},\n-        );\n-    }\n-\n     fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n         let kind = match &p.kind {\n             // Allow stability attributes on default generic arguments.\n@@ -662,11 +649,6 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n         self.check_missing_stability(i.def_id, i.span);\n         intravisit::walk_foreign_item(self, i);\n     }\n-\n-    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        self.check_missing_stability(md.def_id, md.span);\n-    }\n-\n     // Note that we don't need to `check_missing_stability` for default generic parameters,\n     // as we assume that any default generic parameters without attributes are automatically\n     // stable (assuming they have not inherited instability from their parent)."}, {"sha": "6ac2915c3452688b40b1d98ac57f040b10a8f486", "filename": "compiler/rustc_privacy/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_privacy%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_privacy%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2FCargo.toml?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -5,6 +5,7 @@ edition = \"2018\"\n \n [dependencies]\n rustc_middle = { path = \"../rustc_middle\" }\n+rustc_ast = { path = \"../rustc_ast\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_errors = { path = \"../rustc_errors\" }\n rustc_hir = { path = \"../rustc_hir\" }"}, {"sha": "079a9ed878a7f387b1465f4859302c7d14701a6d", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 67, "deletions": 47, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -6,6 +6,7 @@\n #![feature(associated_type_defaults)]\n #![recursion_limit = \"256\"]\n \n+use rustc_ast::MacroDef;\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n@@ -26,7 +27,7 @@ use rustc_middle::ty::subst::{InternalSubsts, Subst};\n use rustc_middle::ty::{self, Const, GenericParamDefKind, TraitRef, Ty, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use rustc_trait_selection::traits::const_evaluatable::{self, AbstractConst};\n \n@@ -462,6 +463,43 @@ impl EmbargoVisitor<'tcx> {\n         }\n     }\n \n+    // We have to make sure that the items that macros might reference\n+    // are reachable, since they might be exported transitively.\n+    fn update_reachability_from_macro(&mut self, local_def_id: LocalDefId, md: &MacroDef) {\n+        // Non-opaque macros cannot make other items more accessible than they already are.\n+\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+        let attrs = self.tcx.hir().attrs(hir_id);\n+        if attr::find_transparency(&attrs, md.macro_rules).0 != Transparency::Opaque {\n+            return;\n+        }\n+\n+        let item_def_id = local_def_id.to_def_id();\n+        let macro_module_def_id =\n+            ty::DefIdTree::parent(self.tcx, item_def_id).unwrap().expect_local();\n+        if self.tcx.hir().opt_def_kind(macro_module_def_id) != Some(DefKind::Mod) {\n+            // The macro's parent doesn't correspond to a `mod`, return early (#63164, #65252).\n+            return;\n+        }\n+\n+        if self.get(local_def_id).is_none() {\n+            return;\n+        }\n+\n+        // Since we are starting from an externally visible module,\n+        // all the parents in the loop below are also guaranteed to be modules.\n+        let mut module_def_id = macro_module_def_id;\n+        loop {\n+            let changed_reachability =\n+                self.update_macro_reachable(module_def_id, macro_module_def_id);\n+            if changed_reachability || module_def_id == CRATE_DEF_ID {\n+                break;\n+            }\n+            module_def_id =\n+                ty::DefIdTree::parent(self.tcx, module_def_id.to_def_id()).unwrap().expect_local();\n+        }\n+    }\n+\n     /// Updates the item as being reachable through a macro defined in the given\n     /// module. Returns `true` if the level has changed.\n     fn update_macro_reachable(\n@@ -511,16 +549,26 @@ impl EmbargoVisitor<'tcx> {\n         }\n         match def_kind {\n             // No type privacy, so can be directly marked as reachable.\n-            DefKind::Const\n-            | DefKind::Macro(_)\n-            | DefKind::Static\n-            | DefKind::TraitAlias\n-            | DefKind::TyAlias => {\n+            DefKind::Const | DefKind::Static | DefKind::TraitAlias | DefKind::TyAlias => {\n                 if vis.is_accessible_from(module.to_def_id(), self.tcx) {\n                     self.update(def_id, level);\n                 }\n             }\n \n+            // Hygine isn't really implemented for `macro_rules!` macros at the\n+            // moment. Accordingly, marking them as reachable is unwise. `macro` macros\n+            // have normal  hygine, so we can treat them like other items without type\n+            // privacy and mark them reachable.\n+            DefKind::Macro(_) => {\n+                let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+                let item = self.tcx.hir().expect_item(hir_id);\n+                if let hir::ItemKind::Macro(MacroDef { macro_rules: false, .. }) = item.kind {\n+                    if vis.is_accessible_from(module.to_def_id(), self.tcx) {\n+                        self.update(def_id, level);\n+                    }\n+                }\n+            }\n+\n             // We can't use a module name as the final segment of a path, except\n             // in use statements. Since re-export checking doesn't consider\n             // hygiene these don't need to be marked reachable. The contents of\n@@ -644,6 +692,12 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             hir::ItemKind::Impl { .. } => {\n                 Option::<AccessLevel>::of_impl(item.def_id, self.tcx, &self.access_levels)\n             }\n+            // Only exported `macro_rules!` items are public, but they always are.\n+            hir::ItemKind::Macro(MacroDef { macro_rules: true, .. }) => {\n+                let def_id = item.def_id.to_def_id();\n+                let is_macro_export = self.tcx.has_attr(def_id, sym::macro_export);\n+                if is_macro_export { Some(AccessLevel::Public) } else { None }\n+            }\n             // Foreign modules inherit level from parents.\n             hir::ItemKind::ForeignMod { .. } => self.prev_level,\n             // Other `pub` items inherit levels from parents.\n@@ -652,6 +706,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             | hir::ItemKind::ExternCrate(..)\n             | hir::ItemKind::GlobalAsm(..)\n             | hir::ItemKind::Fn(..)\n+            | hir::ItemKind::Macro(..)\n             | hir::ItemKind::Mod(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Struct(..)\n@@ -708,13 +763,17 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     }\n                 }\n             }\n+            hir::ItemKind::Macro(ref macro_def) => {\n+                self.update_reachability_from_macro(item.def_id, macro_def);\n+            }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n                     if foreign_item.vis.node.is_pub() {\n                         self.update(foreign_item.id.def_id, item_level);\n                     }\n                 }\n             }\n+\n             hir::ItemKind::OpaqueTy(..)\n             | hir::ItemKind::Use(..)\n             | hir::ItemKind::Static(..)\n@@ -730,7 +789,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         // Mark all items in interfaces of reachable items as reachable.\n         match item.kind {\n             // The interface is empty.\n-            hir::ItemKind::ExternCrate(..) => {}\n+            hir::ItemKind::Macro(..) | hir::ItemKind::ExternCrate(..) => {}\n             // All nested items are checked by `visit_item`.\n             hir::ItemKind::Mod(..) => {}\n             // Re-exports are handled in `visit_mod`. However, in order to avoid looping over\n@@ -885,45 +944,6 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n \n         intravisit::walk_mod(self, m, id);\n     }\n-\n-    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        // Non-opaque macros cannot make other items more accessible than they already are.\n-        let attrs = self.tcx.hir().attrs(md.hir_id());\n-        if attr::find_transparency(&attrs, md.ast.macro_rules).0 != Transparency::Opaque {\n-            // `#[macro_export]`-ed `macro_rules!` are `Public` since they\n-            // ignore their containing path to always appear at the crate root.\n-            if md.ast.macro_rules {\n-                self.update(md.def_id, Some(AccessLevel::Public));\n-            }\n-            return;\n-        }\n-\n-        let macro_module_def_id =\n-            ty::DefIdTree::parent(self.tcx, md.def_id.to_def_id()).unwrap().expect_local();\n-        if self.tcx.hir().opt_def_kind(macro_module_def_id) != Some(DefKind::Mod) {\n-            // The macro's parent doesn't correspond to a `mod`, return early (#63164, #65252).\n-            return;\n-        }\n-\n-        let level = if md.vis.node.is_pub() { self.get(macro_module_def_id) } else { None };\n-        let new_level = self.update(md.def_id, level);\n-        if new_level.is_none() {\n-            return;\n-        }\n-\n-        // Since we are starting from an externally visible module,\n-        // all the parents in the loop below are also guaranteed to be modules.\n-        let mut module_def_id = macro_module_def_id;\n-        loop {\n-            let changed_reachability =\n-                self.update_macro_reachable(module_def_id, macro_module_def_id);\n-            if changed_reachability || module_def_id == CRATE_DEF_ID {\n-                break;\n-            }\n-            module_def_id =\n-                ty::DefIdTree::parent(self.tcx, module_def_id.to_def_id()).unwrap().expect_local();\n-        }\n-    }\n }\n \n impl ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n@@ -1981,7 +2001,7 @@ impl<'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'tcx> {\n             // Checked in resolve.\n             hir::ItemKind::Use(..) => {}\n             // No subitems.\n-            hir::ItemKind::GlobalAsm(..) => {}\n+            hir::ItemKind::Macro(..) | hir::ItemKind::GlobalAsm(..) => {}\n             // Subitems of these items have inherited publicity.\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Static(..)"}, {"sha": "bc2c46ec0aa7c2754cbd71d0967a0d5a3c2fe273", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -740,6 +740,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n             hir::ItemKind::ExternCrate(_)\n             | hir::ItemKind::Use(..)\n+            | hir::ItemKind::Macro(..)\n             | hir::ItemKind::Mod(..)\n             | hir::ItemKind::ForeignMod { .. }\n             | hir::ItemKind::GlobalAsm(..) => {"}, {"sha": "7864b47ab0a7f429decd27730ceaeffef2f3da2d", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -416,6 +416,14 @@ impl<'hir> Sig for hir::Item<'hir> {\n \n                 Ok(sig)\n             }\n+            hir::ItemKind::Macro(_) => {\n+                let mut text = \"macro\".to_owned();\n+                let name = self.ident.to_string();\n+                text.push_str(&name);\n+                text.push_str(&\"! {}\");\n+\n+                Ok(text_sig(text))\n+            }\n             hir::ItemKind::Mod(ref _mod) => {\n                 let mut text = \"mod \".to_owned();\n                 let name = self.ident.to_string();"}, {"sha": "145a0c5413bb81d3e65038f966a1bde5a9ee2b1a", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -746,6 +746,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n         // These don't define types.\n         hir::ItemKind::ExternCrate(_)\n         | hir::ItemKind::Use(..)\n+        | hir::ItemKind::Macro(_)\n         | hir::ItemKind::Mod(_)\n         | hir::ItemKind::GlobalAsm(_) => {}\n         hir::ItemKind::ForeignMod { items, .. } => {"}, {"sha": "41277b22da0e034281487848d107834f1f71e621", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -427,6 +427,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 }\n                 ItemKind::Trait(..)\n                 | ItemKind::TraitAlias(..)\n+                | ItemKind::Macro(..)\n                 | ItemKind::Mod(..)\n                 | ItemKind::ForeignMod { .. }\n                 | ItemKind::GlobalAsm(..)"}, {"sha": "640acffb114d945de22d1324f2bce214fec84637", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -91,7 +91,6 @@ impl Clean<Item> for doctree::Module<'_> {\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n-        items.extend(self.macros.iter().map(|x| x.clean(cx)));\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -1861,6 +1860,10 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 ItemKind::Fn(ref sig, ref generics, body_id) => {\n                     clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n                 }\n+                ItemKind::Macro(ref macro_def) => MacroItem(Macro {\n+                    source: display_macro_source(cx, name, &macro_def, def_id, &item.vis),\n+                    imported_from: None,\n+                }),\n                 ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n                     let items = item_ids\n                         .iter()\n@@ -2138,24 +2141,6 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n     }\n }\n \n-impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n-        let (item, renamed) = self;\n-        let name = renamed.unwrap_or(item.ident.name);\n-        let def_id = item.def_id.to_def_id();\n-\n-        Item::from_hir_id_and_parts(\n-            item.hir_id(),\n-            Some(name),\n-            MacroItem(Macro {\n-                source: display_macro_source(cx, name, &item.ast, def_id, &item.vis),\n-                imported_from: None,\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> TypeBinding {\n         TypeBinding { name: self.ident.name, kind: self.kind.clean(cx) }"}, {"sha": "bf14a17c0769355f33f36dbad24dcede2b495ea0", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -1171,10 +1171,21 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n     }\n \n     fn visit_item(&mut self, item: &'hir hir::Item<'_>) {\n-        let name = if let hir::ItemKind::Impl(impl_) = &item.kind {\n-            rustc_hir_pretty::id_to_string(&self.map, impl_.self_ty.hir_id)\n-        } else {\n-            item.ident.to_string()\n+        let name = match &item.kind {\n+            hir::ItemKind::Macro(ref macro_def) => {\n+                // FIXME(#88038): Non exported macros have historically not been tested,\n+                // but we really ought to start testing them.\n+                let def_id = item.def_id.to_def_id();\n+                if macro_def.macro_rules && !self.tcx.has_attr(def_id, sym::macro_export) {\n+                    intravisit::walk_item(self, item);\n+                    return;\n+                }\n+                item.ident.to_string()\n+            }\n+            hir::ItemKind::Impl(impl_) => {\n+                rustc_hir_pretty::id_to_string(&self.map, impl_.self_ty.hir_id)\n+            }\n+            _ => item.ident.to_string(),\n         };\n \n         self.visit_testable(name, item.hir_id(), item.span, |this| {\n@@ -1216,15 +1227,6 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n             intravisit::walk_field_def(this, f);\n         });\n     }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'hir hir::MacroDef<'_>) {\n-        self.visit_testable(\n-            macro_def.ident.to_string(),\n-            macro_def.hir_id(),\n-            macro_def.span,\n-            |_| (),\n-        );\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "8f1e8f277c5fe8795a7a7d8ca98471cf3e8df29c", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -5,6 +5,7 @@ use rustc_span::{self, Span, Symbol};\n \n use rustc_hir as hir;\n \n+#[derive(Debug)]\n crate struct Module<'hir> {\n     crate name: Symbol,\n     crate where_inner: Span,\n@@ -13,20 +14,11 @@ crate struct Module<'hir> {\n     // (item, renamed)\n     crate items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>)>,\n     crate foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n-    crate macros: Vec<(&'hir hir::MacroDef<'hir>, Option<Symbol>)>,\n }\n \n impl Module<'hir> {\n     crate fn new(name: Symbol, id: hir::HirId, where_inner: Span) -> Module<'hir> {\n-        Module {\n-            name,\n-            id,\n-            where_inner,\n-            mods: Vec::new(),\n-            items: Vec::new(),\n-            foreigns: Vec::new(),\n-            macros: Vec::new(),\n-        }\n+        Module { name, id, where_inner, mods: Vec::new(), items: Vec::new(), foreigns: Vec::new() }\n     }\n \n     crate fn where_outer(&self, tcx: TyCtxt<'_>) -> Span {"}, {"sha": "897b9140fc8bcc6dfdc6aef07198cd5abd59908d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 42, "deletions": 49, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::Node;\n use rustc_middle::middle::privacy::AccessLevel;\n use rustc_middle::ty::TyCtxt;\n use rustc_span;\n-use rustc_span::def_id::LOCAL_CRATE;\n+use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n@@ -79,49 +79,23 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             &krate.module(),\n             self.cx.tcx.crate_name(LOCAL_CRATE),\n         );\n-        // Attach the crate's exported macros to the top-level module.\n-        // In the case of macros 2.0 (`pub macro`), and for built-in `derive`s or attributes as\n-        // well (_e.g._, `Copy`), these are wrongly bundled in there too, so we need to fix that by\n-        // moving them back to their correct locations.\n-        'exported_macros: for def in krate.exported_macros() {\n-            // The `def` of a macro in `exported_macros` should correspond to either:\n-            //  - a `#[macro_export] macro_rules!` macro,\n-            //  - a built-in `derive` (or attribute) macro such as the ones in `::core`,\n-            //  - a `pub macro`.\n-            // Only the last two need to be fixed, thus:\n-            if def.ast.macro_rules {\n-                top_level_module.macros.push((def, None));\n-                continue 'exported_macros;\n-            }\n-            let tcx = self.cx.tcx;\n-            // Note: this is not the same as `.parent_module()`. Indeed, the latter looks\n-            // for the closest module _ancestor_, which is not necessarily a direct parent\n-            // (since a direct parent isn't necessarily a module, c.f. #77828).\n-            let macro_parent_def_id = {\n-                use rustc_middle::ty::DefIdTree;\n-                tcx.parent(def.def_id.to_def_id()).unwrap()\n-            };\n-            let macro_parent_path = tcx.def_path(macro_parent_def_id);\n-            // HACK: rustdoc has no way to lookup `doctree::Module`s by their HirId. Instead,\n-            // lookup the module by its name, by looking at each path segment one at a time.\n-            let mut cur_mod = &mut top_level_module;\n-            for path_segment in macro_parent_path.data {\n-                // Path segments may refer to a module (in which case they belong to the type\n-                // namespace), which is _necessary_ for the macro to be accessible outside it\n-                // (no \"associated macros\" as of yet). Else we bail with an outer `continue`.\n-                let path_segment_ty_ns = match path_segment.data {\n-                    rustc_hir::definitions::DefPathData::TypeNs(symbol) => symbol,\n-                    _ => continue 'exported_macros,\n-                };\n-                // Descend into the child module that matches this path segment (if any).\n-                match cur_mod.mods.iter_mut().find(|child| child.name == path_segment_ty_ns) {\n-                    Some(child_mod) => cur_mod = &mut *child_mod,\n-                    None => continue 'exported_macros,\n+\n+        // `#[macro_export] macro_rules!` items are reexported at the top level of the\n+        // crate, regardless of where they're defined. We want to document the\n+        // top level rexport of the macro, not its original definition, since\n+        // the rexport defines the path that a user will actually see. Accordingly,\n+        // we add the rexport as an item here, and then skip over the original\n+        // definition in `visit_item()` below.\n+        for export in self.cx.tcx.module_exports(CRATE_DEF_ID).unwrap_or(&[]) {\n+            if let Res::Def(DefKind::Macro(_), def_id) = export.res {\n+                if let Some(local_def_id) = def_id.as_local() {\n+                    if self.cx.tcx.has_attr(def_id, sym::macro_export) {\n+                        let hir_id = self.cx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+                        let item = self.cx.tcx.hir().expect_item(hir_id);\n+                        top_level_module.items.push((item, None));\n+                    }\n                 }\n             }\n-            let cur_mod_def_id = tcx.hir().local_def_id(cur_mod.id).to_def_id();\n-            assert_eq!(cur_mod_def_id, macro_parent_def_id);\n-            cur_mod.macros.push((def, None));\n         }\n         self.cx.cache.exact_paths = self.exact_paths;\n         top_level_module\n@@ -238,10 +212,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 self.inlining = prev;\n                 true\n             }\n-            Node::MacroDef(def) if !glob => {\n-                om.macros.push((def, renamed));\n-                true\n-            }\n             _ => false,\n         };\n         self.view_item_stack.remove(&res_hir_id);\n@@ -257,7 +227,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n \n-        if item.vis.node.is_pub() {\n+        let def_id = item.def_id.to_def_id();\n+        let is_pub = item.vis.node.is_pub() || self.cx.tcx.has_attr(def_id, sym::macro_export);\n+\n+        if is_pub {\n             self.store_path(item.def_id.to_def_id());\n         }\n \n@@ -269,7 +242,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n             }\n             // If we're inlining, skip private items.\n-            _ if self.inlining && !item.vis.node.is_pub() => {}\n+            _ if self.inlining && !is_pub => {}\n             hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::Use(_, hir::UseKind::ListStem) => {}\n             hir::ItemKind::Use(ref path, kind) => {\n@@ -285,7 +258,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 // If there was a private module in the current path then don't bother inlining\n                 // anything as it will probably be stripped anyway.\n-                if item.vis.node.is_pub() && self.inside_public_path {\n+                if is_pub && self.inside_public_path {\n                     let please_inline = attrs.iter().any(|item| match item.meta_item_list() {\n                         Some(ref list) if item.has_name(sym::doc) => {\n                             list.iter().any(|i| i.has_name(sym::inline))\n@@ -307,6 +280,26 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 om.items.push((item, renamed))\n             }\n+            hir::ItemKind::Macro(ref macro_def) => {\n+                // `#[macro_export] macro_rules!` items are handled seperately in `visit()`,\n+                // above, since they need to be documented at the module top level. Accordingly,\n+                // we only want to handle macros if one of three conditions holds:\n+                //\n+                // 1. This macro was defined by `macro`, and thus isn't covered by the case\n+                //    above.\n+                // 2. This macro isn't marked with `#[macro_export]`, and thus isn't covered\n+                //    by the case above.\n+                // 3. We're inlining, since a reexport where inlining has been requested\n+                //    should be inlined even if it is also documented at the top level.\n+\n+                let def_id = item.def_id.to_def_id();\n+                let is_macro_2_0 = !macro_def.macro_rules;\n+                let nonexported = !self.cx.tcx.has_attr(def_id, sym::macro_export);\n+\n+                if is_macro_2_0 || nonexported || self.inlining {\n+                    om.items.push((item, renamed));\n+                }\n+            }\n             hir::ItemKind::Mod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(&item.vis, item.hir_id(), m, name));\n             }"}, {"sha": "0867b08183e2de20eaa7af23ce9f43ce2c6e8b53", "filename": "src/test/rustdoc-ui/deny-missing-docs-macro.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-macro.stderr?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -1,4 +1,4 @@\n-error: missing documentation for macro\n+error: missing documentation for a macro\n   --> $DIR/deny-missing-docs-macro.rs:6:1\n    |\n LL | macro_rules! foo {"}, {"sha": "460785ed979de3d6b24d40b1a7a360bbbd35155f", "filename": "src/test/rustdoc/macro-document-private-duplicate.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Frustdoc%2Fmacro-document-private-duplicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Frustdoc%2Fmacro-document-private-duplicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-document-private-duplicate.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -0,0 +1,23 @@\n+// FIXME: If two macros in the same module have the same name\n+// (yes, that's a thing), rustdoc lists both of them on the index page,\n+// but only documents the first one on the page for the macro.\n+// Fortunately, this can only happen in document private items mode,\n+// but it still isn't ideal beahvior.\n+//\n+// See https://github.com/rust-lang/rust/pull/88019#discussion_r693920453\n+//\n+// compile-flags: --document-private-items\n+\n+// @has macro_document_private_duplicate/index.html 'Doc 1.'\n+// @has macro_document_private_duplicate/macro.a_macro.html 'Doc 1.'\n+/// Doc 1.\n+macro_rules! a_macro {\n+    () => ()\n+}\n+\n+// @has macro_document_private_duplicate/index.html 'Doc 2.'\n+// @!has macro_document_private_duplicate/macro.a_macro.html 'Doc 2.'\n+/// Doc 2.\n+macro_rules! a_macro {\n+    () => ()\n+}"}, {"sha": "d2496913ffcf2a4574b0dd4d77c54e4961b45845", "filename": "src/test/rustdoc/macro-document-private.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Frustdoc%2Fmacro-document-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Frustdoc%2Fmacro-document-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-document-private.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -0,0 +1,19 @@\n+// Checks that private macros are documented when `--document-private-items`\n+// is present.\n+//\n+// This is a regression test for issue #73754.\n+//\n+// compile-flags: --document-private-items\n+\n+#![feature(decl_macro)]\n+\n+\n+// @has macro_document_private/macro.some_macro.html\n+macro some_macro {\n+    (a: tt) => {}\n+}\n+\n+// @has macro_document_private/macro.another_macro.html\n+macro_rules! another_macro {\n+    (a: tt) => {}\n+}"}, {"sha": "b2d9336cffc815ef234fa8350c245232e6064ad8", "filename": "src/test/rustdoc/macro-indirect-use.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Frustdoc%2Fmacro-indirect-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Frustdoc%2Fmacro-indirect-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fmacro-indirect-use.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -0,0 +1,16 @@\n+// Checks that it is possible to make a macro public through a `pub use` of its\n+// parent module.\n+//\n+// This is a regression test for issue #87257.\n+\n+#![feature(decl_macro)]\n+\n+mod outer {\n+    pub mod inner {\n+        pub macro some_macro() {}\n+    }\n+}\n+\n+// @has macro_indirect_use/inner/index.html\n+// @has macro_indirect_use/inner/macro.some_macro.html\n+pub use outer::inner;"}, {"sha": "79f7d1206df202bd0248b618fa9e635bdac3c68d", "filename": "src/test/ui/lint/lint-level-macro-def-mod.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Fui%2Flint%2Flint-level-macro-def-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Fui%2Flint%2Flint-level-macro-def-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-level-macro-def-mod.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -0,0 +1,17 @@\n+// This checks that exported macros lint as part of their module of origin, not\n+// the root module.\n+//\n+// check-pass\n+\n+//! Top level documentation\n+#![deny(missing_docs)]\n+\n+#[allow(missing_docs)]\n+mod module {\n+    #[macro_export]\n+    macro_rules! hello {\n+        () => ()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "720f4b453abf55d54cf2e1d92babda2f4213732c", "filename": "src/test/ui/lint/lint-level-macro-def.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Fui%2Flint%2Flint-level-macro-def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Fui%2Flint%2Flint-level-macro-def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-level-macro-def.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -0,0 +1,17 @@\n+// Checks that you can set a lint level specficially for a macro definition.\n+//\n+// This is a regression test for issue #59306.\n+//\n+// check-pass\n+\n+\n+#[deny(missing_docs)]\n+mod module {\n+    #[allow(missing_docs)]\n+    #[macro_export]\n+    macro_rules! hello {\n+        () => ()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0d4332ed08b26955b0eb119561c344e709ee2a3c", "filename": "src/test/ui/lint/missing-doc-private-macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Fui%2Flint%2Fmissing-doc-private-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Fui%2Flint%2Fmissing-doc-private-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmissing-doc-private-macro.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -29,13 +29,13 @@ mod submodule {\n \n     #[macro_export]\n     macro_rules! exported_to_top_level {\n-        //~^ ERROR missing documentation for macro\n+        //~^ ERROR missing documentation for a macro\n         () => ()\n     }\n }\n \n pub macro top_level_pub_macro {\n-    //~^ ERROR missing documentation for macro\n+    //~^ ERROR missing documentation for a macro\n     () => ()\n }\n "}, {"sha": "979b007d0ecd69c1c08f89c5d45f9feefbb49124", "filename": "src/test/ui/lint/missing-doc-private-macro.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Fui%2Flint%2Fmissing-doc-private-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Fui%2Flint%2Fmissing-doc-private-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fmissing-doc-private-macro.stderr?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -1,4 +1,4 @@\n-error: missing documentation for macro\n+error: missing documentation for a macro\n   --> $DIR/missing-doc-private-macro.rs:31:5\n    |\n LL |     macro_rules! exported_to_top_level {\n@@ -10,7 +10,7 @@ note: the lint level is defined here\n LL | #![deny(missing_docs)]\n    |         ^^^^^^^^^^^^\n \n-error: missing documentation for macro\n+error: missing documentation for a macro\n   --> $DIR/missing-doc-private-macro.rs:37:1\n    |\n LL | pub macro top_level_pub_macro {"}, {"sha": "2d02b95288df45e7fc0b8121de4ce838de3e2f41", "filename": "src/test/ui/macros/macro-stability-rpass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-stability-rpass.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -1,7 +1,8 @@\n // run-pass\n // aux-build:unstable-macros.rs\n \n-#![feature(unstable_macros, local_unstable)]\n+#![unstable(feature = \"one_two_three_testing\", issue = \"none\")]\n+#![feature(staged_api, unstable_macros, local_unstable)]\n \n #[macro_use] extern crate unstable_macros;\n "}, {"sha": "940eee7a78897131d0ced058361e5dd3a87454e3", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -122,6 +122,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             },\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Macro(..)\n             | hir::ItemKind::Mod(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Struct(..)"}, {"sha": "667cdd8302528caec005ef878d7a8f2087d50e70", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -118,6 +118,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             },\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Macro(..)\n             | hir::ItemKind::Mod(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Struct(..)"}, {"sha": "e97983a2e1451d373e77609e8f13f456f7dbbfde", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05cccdc9b321e6565b3e62e8b52aec53d106ef2f/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=05cccdc9b321e6565b3e62e8b52aec53d106ef2f", "patch": "@@ -381,6 +381,13 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n             let item_ty = cx.tcx.type_of(did);\n             println!(\"function of type {:#?}\", item_ty);\n         },\n+        hir::ItemKind::Macro(ref macro_def) => {\n+            if macro_def.macro_rules {\n+                println!(\"macro introduced by `macro_rules!`\");\n+            } else {\n+                println!(\"macro introduced by `macro`\");\n+            }\n+        },\n         hir::ItemKind::Mod(..) => println!(\"module\"),\n         hir::ItemKind::ForeignMod { abi, .. } => println!(\"foreign module with abi: {}\", abi),\n         hir::ItemKind::GlobalAsm(asm) => println!(\"global asm: {:?}\", asm),"}]}