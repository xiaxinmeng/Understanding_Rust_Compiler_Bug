{"sha": "d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZmE3MmFiZTJjYzZmNjg1MmEzZmFlYWY0ZDFhYzdjNWMzNzFkOTE=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-20T10:28:32Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-06-20T11:27:54Z"}, "message": "Fix hygiene regression", "tree": {"sha": "17de6cfe88258ed1a6298a5e8007a70c4601db18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17de6cfe88258ed1a6298a5e8007a70c4601db18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91", "html_url": "https://github.com/rust-lang/rust/commit/d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1ae194fa665265cbabdfdd1d1d43fc8bb47362a", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ae194fa665265cbabdfdd1d1d43fc8bb47362a", "html_url": "https://github.com/rust-lang/rust/commit/b1ae194fa665265cbabdfdd1d1d43fc8bb47362a"}], "stats": {"total": 195, "additions": 44, "deletions": 151}, "files": [{"sha": "c1624259a7f55bef26162b5ef9eac3c42a32b1ad", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91", "patch": "@@ -681,7 +681,7 @@ pub struct IdentRenamer<'a> {\n \n impl<'a> Folder for IdentRenamer<'a> {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n-        Ident::new(id.name, mtwt::apply_renames(self.renames, id.ctxt))\n+        mtwt::apply_renames(self.renames, id)\n     }\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n         fold::noop_fold_mac(mac, self)\n@@ -705,8 +705,7 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n \n         pat.map(|ast::Pat {id, node, span}| match node {\n             PatKind::Ident(binding_mode, Spanned{span: sp, node: ident}, sub) => {\n-                let new_ident = Ident::new(ident.name,\n-                                           mtwt::apply_renames(self.renames, ident.ctxt));\n+                let new_ident = mtwt::apply_renames(self.renames, ident);\n                 let new_node =\n                     PatKind::Ident(binding_mode,\n                                   Spanned{span: sp, node: new_ident},"}, {"sha": "70d93f9936e3a907e9be5988df189ee4155dac86", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 42, "deletions": 148, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=d7fa72abe2cc6f6852a3faeaf4d1ac7c5c371d91", "patch": "@@ -25,34 +25,22 @@ use std::collections::HashMap;\n /// The SCTable contains a table of SyntaxContext_'s. It\n /// represents a flattened tree structure, to avoid having\n /// managed pointers everywhere (that caused an ICE).\n-/// the mark_memo and rename_memo fields are side-tables\n+/// the `marks` and `renames` fields are side-tables\n /// that ensure that adding the same mark to the same context\n-/// gives you back the same context as before. This shouldn't\n-/// change the semantics--everything here is immutable--but\n-/// it should cut down on memory use *a lot*; applying a mark\n-/// to a tree containing 50 identifiers would otherwise generate\n-/// 50 new contexts\n+/// gives you back the same context as before. This should cut\n+/// down on memory use *a lot*; applying a mark to a tree containing\n+/// 50 identifiers would otherwise generate 50 new contexts.\n pub struct SCTable {\n     table: RefCell<Vec<SyntaxContext_>>,\n-    mark_memo: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n-    // The pair (Name,SyntaxContext) is actually one Ident, but it needs to be hashed and\n-    // compared as pair (name, ctxt) and not as an Ident\n-    rename_memo: RefCell<HashMap<(SyntaxContext,(Name,SyntaxContext),Name),SyntaxContext>>,\n+    marks: RefCell<HashMap<(SyntaxContext,Mrk),SyntaxContext>>,\n+    renames: RefCell<HashMap<Name,SyntaxContext>>,\n }\n \n #[derive(PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy, Clone)]\n pub enum SyntaxContext_ {\n     EmptyCtxt,\n     Mark (Mrk,SyntaxContext),\n-    /// flattening the name and syntaxcontext into the rename...\n-    /// HIDDEN INVARIANTS:\n-    /// 1) the first name in a Rename node\n-    /// can only be a programmer-supplied name.\n-    /// 2) Every Rename node with a given Name in the\n-    /// \"to\" slot must have the same name and context\n-    /// in the \"from\" slot. In essence, they're all\n-    /// pointers to a single \"rename\" event node.\n-    Rename (Ident,Name,SyntaxContext),\n+    Rename (Name),\n     /// actually, IllegalCtxt may not be necessary.\n     IllegalCtxt\n }\n@@ -67,37 +55,39 @@ pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n \n /// Extend a syntax context with a given mark and sctable (explicit memoization)\n fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n-    let key = (ctxt, m);\n-    *table.mark_memo.borrow_mut().entry(key).or_insert_with(|| {\n-        SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt)))\n-    })\n+    let ctxts = &mut *table.table.borrow_mut();\n+    match ctxts[ctxt.0 as usize] {\n+        // Applying the same mark twice is a no-op.\n+        Mark(outer_mark, prev_ctxt) if outer_mark == m => return prev_ctxt,\n+        _ => *table.marks.borrow_mut().entry((ctxt, m)).or_insert_with(|| {\n+            SyntaxContext(idx_push(ctxts, Mark(m, ctxt)))\n+        }),\n+    }\n }\n \n /// Extend a syntax context with a given rename\n-pub fn apply_rename(id: Ident, to:Name,\n-                  ctxt: SyntaxContext) -> SyntaxContext {\n-    with_sctable(|table| apply_rename_internal(id, to, ctxt, table))\n+pub fn apply_rename(from: Ident, to: Name, ident: Ident) -> Ident {\n+    with_sctable(|table| apply_rename_internal(from, to, ident, table))\n }\n \n /// Extend a syntax context with a given rename and sctable (explicit memoization)\n-fn apply_rename_internal(id: Ident,\n-                       to: Name,\n-                       ctxt: SyntaxContext,\n-                       table: &SCTable) -> SyntaxContext {\n-    let key = (ctxt, (id.name, id.ctxt), to);\n-\n-    *table.rename_memo.borrow_mut().entry(key).or_insert_with(|| {\n-            SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt)))\n-    })\n+fn apply_rename_internal(from: Ident, to: Name, ident: Ident, table: &SCTable) -> Ident {\n+    if (ident.name, ident.ctxt) != (from.name, from.ctxt) {\n+        return ident;\n+    }\n+    let ctxt = *table.renames.borrow_mut().entry(to).or_insert_with(|| {\n+        SyntaxContext(idx_push(&mut *table.table.borrow_mut(), Rename(to)))\n+    });\n+    Ident { ctxt: ctxt, ..ident }\n }\n \n /// Apply a list of renamings to a context\n // if these rename lists get long, it would make sense\n // to consider memoizing this fold. This may come up\n // when we add hygiene to item names.\n-pub fn apply_renames(renames: &RenameList, ctxt: SyntaxContext) -> SyntaxContext {\n-    renames.iter().fold(ctxt, |ctxt, &(from, to)| {\n-        apply_rename(from, to, ctxt)\n+pub fn apply_renames(renames: &RenameList, ident: Ident) -> Ident {\n+    renames.iter().fold(ident, |ident, &(from, to)| {\n+        apply_rename(from, to, ident)\n     })\n }\n \n@@ -114,8 +104,8 @@ pub fn with_sctable<T, F>(op: F) -> T where\n fn new_sctable_internal() -> SCTable {\n     SCTable {\n         table: RefCell::new(vec!(EmptyCtxt, IllegalCtxt)),\n-        mark_memo: RefCell::new(HashMap::new()),\n-        rename_memo: RefCell::new(HashMap::new()),\n+        marks: RefCell::new(HashMap::new()),\n+        renames: RefCell::new(HashMap::new()),\n     }\n }\n \n@@ -131,20 +121,18 @@ pub fn display_sctable(table: &SCTable) {\n pub fn clear_tables() {\n     with_sctable(|table| {\n         *table.table.borrow_mut() = Vec::new();\n-        *table.mark_memo.borrow_mut() = HashMap::new();\n-        *table.rename_memo.borrow_mut() = HashMap::new();\n+        *table.marks.borrow_mut() = HashMap::new();\n+        *table.renames.borrow_mut() = HashMap::new();\n     });\n-    with_resolve_table_mut(|table| *table = HashMap::new());\n }\n \n /// Reset the tables to their initial state\n pub fn reset_tables() {\n     with_sctable(|table| {\n         *table.table.borrow_mut() = vec!(EmptyCtxt, IllegalCtxt);\n-        *table.mark_memo.borrow_mut() = HashMap::new();\n-        *table.rename_memo.borrow_mut() = HashMap::new();\n+        *table.marks.borrow_mut() = HashMap::new();\n+        *table.renames.borrow_mut() = HashMap::new();\n     });\n-    with_resolve_table_mut(|table| *table = HashMap::new());\n }\n \n /// Add a value to the end of a vec, return its index\n@@ -156,103 +144,19 @@ fn idx_push<T>(vec: &mut Vec<T>, val: T) -> u32 {\n /// Resolve a syntax object to a name, per MTWT.\n pub fn resolve(id: Ident) -> Name {\n     with_sctable(|sctable| {\n-        with_resolve_table_mut(|resolve_table| {\n-            resolve_internal(id, sctable, resolve_table)\n-        })\n+        resolve_internal(id, sctable)\n     })\n }\n \n-type ResolveTable = HashMap<(Name,SyntaxContext),Name>;\n-\n-// okay, I admit, putting this in TLS is not so nice:\n-// fetch the SCTable from TLS, create one if it doesn't yet exist.\n-fn with_resolve_table_mut<T, F>(op: F) -> T where\n-    F: FnOnce(&mut ResolveTable) -> T,\n-{\n-    thread_local!(static RESOLVE_TABLE_KEY: RefCell<ResolveTable> = {\n-        RefCell::new(HashMap::new())\n-    });\n-\n-    RESOLVE_TABLE_KEY.with(move |slot| op(&mut *slot.borrow_mut()))\n-}\n-\n /// Resolve a syntax object to a name, per MTWT.\n /// adding memoization to resolve 500+ seconds in resolve for librustc (!)\n-fn resolve_internal(id: Ident,\n-                    table: &SCTable,\n-                    resolve_table: &mut ResolveTable) -> Name {\n-    let key = (id.name, id.ctxt);\n-\n-    match resolve_table.get(&key) {\n-        Some(&name) => return name,\n-        None => {}\n-    }\n-\n-    let resolved = {\n-        let result = (*table.table.borrow())[id.ctxt.0 as usize];\n-        match result {\n-            EmptyCtxt => id.name,\n-            // ignore marks here:\n-            Mark(_,subctxt) =>\n-                resolve_internal(Ident::new(id.name, subctxt),\n-                                 table, resolve_table),\n-            // do the rename if necessary:\n-            Rename(Ident{name, ctxt}, toname, subctxt) => {\n-                let resolvedfrom =\n-                    resolve_internal(Ident::new(name, ctxt),\n-                                     table, resolve_table);\n-                let resolvedthis =\n-                    resolve_internal(Ident::new(id.name, subctxt),\n-                                     table, resolve_table);\n-                if (resolvedthis == resolvedfrom)\n-                    && (marksof_internal(ctxt, resolvedthis, table)\n-                        == marksof_internal(subctxt, resolvedthis, table)) {\n-                    toname\n-                } else {\n-                    resolvedthis\n-                }\n-            }\n-            IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n-        }\n-    };\n-    resolve_table.insert(key, resolved);\n-    resolved\n-}\n-\n-/// Compute the marks associated with a syntax context.\n-pub fn marksof(ctxt: SyntaxContext, stopname: Name) -> Vec<Mrk> {\n-    with_sctable(|table| marksof_internal(ctxt, stopname, table))\n-}\n-\n-// the internal function for computing marks\n-// it's not clear to me whether it's better to use a [] mutable\n-// vector or a cons-list for this.\n-fn marksof_internal(ctxt: SyntaxContext,\n-                    stopname: Name,\n-                    table: &SCTable) -> Vec<Mrk> {\n-    let mut result = Vec::new();\n-    let mut loopvar = ctxt;\n-    loop {\n-        let table_entry = (*table.table.borrow())[loopvar.0 as usize];\n-        match table_entry {\n-            EmptyCtxt => {\n-                return result;\n-            },\n-            Mark(mark, tl) => {\n-                xor_push(&mut result, mark);\n-                loopvar = tl;\n-            },\n-            Rename(_,name,tl) => {\n-                // see MTWT for details on the purpose of the stopname.\n-                // short version: it prevents duplication of effort.\n-                if name == stopname {\n-                    return result;\n-                } else {\n-                    loopvar = tl;\n-                }\n-            }\n-            IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n-        }\n+fn resolve_internal(id: Ident, table: &SCTable) -> Name {\n+    match table.table.borrow()[id.ctxt.0 as usize] {\n+        EmptyCtxt => id.name,\n+        // ignore marks here:\n+        Mark(_, subctxt) => resolve_internal(Ident::new(id.name, subctxt), table),\n+        Rename(name) => name,\n+        IllegalCtxt => panic!(\"expected resolvable context, got IllegalCtxt\")\n     }\n }\n \n@@ -267,16 +171,6 @@ pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     })\n }\n \n-/// Push a name... unless it matches the one on top, in which\n-/// case pop and discard (so two of the same marks cancel)\n-fn xor_push(marks: &mut Vec<Mrk>, mark: Mrk) {\n-    if (!marks.is_empty()) && (*marks.last().unwrap() == mark) {\n-        marks.pop().unwrap();\n-    } else {\n-        marks.push(mark);\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use self::TestSC::*;"}]}