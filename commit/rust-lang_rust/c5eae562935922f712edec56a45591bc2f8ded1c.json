{"sha": "c5eae562935922f712edec56a45591bc2f8ded1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1ZWFlNTYyOTM1OTIyZjcxMmVkZWM1NmE0NTU5MWJjMmY4ZGVkMWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-11T18:50:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-11T18:50:53Z"}, "message": "Auto merge of #75490 - LukasKalbertodt:add-basic-array-methods, r=dtolnay\n\nAdd `[T; N]::each_ref` and `[T; N]::each_mut`\n\nThis PR adds the methods `each_ref` and `each_mut` to `[T; N]`. The ability to add methods to arrays was added in #75212. These two methods are particularly useful with `map` which was also added in that PR. Tracking issue: #76118\n\n```rust\nimpl<T, const N: usize> [T; N] {\n    pub fn each_ref(&self) -> [&T; N];\n    pub fn each_mut(&mut self) -> [&mut T; N];\n}\n```", "tree": {"sha": "35af8ef473d32f7e42de1dfe9cf423f7b97f9b35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35af8ef473d32f7e42de1dfe9cf423f7b97f9b35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5eae562935922f712edec56a45591bc2f8ded1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5eae562935922f712edec56a45591bc2f8ded1c", "html_url": "https://github.com/rust-lang/rust/commit/c5eae562935922f712edec56a45591bc2f8ded1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5eae562935922f712edec56a45591bc2f8ded1c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6526e5c772f2da07db745c94ca6bb0a591a39ba4", "url": "https://api.github.com/repos/rust-lang/rust/commits/6526e5c772f2da07db745c94ca6bb0a591a39ba4", "html_url": "https://github.com/rust-lang/rust/commit/6526e5c772f2da07db745c94ca6bb0a591a39ba4"}, {"sha": "4038042eb0f9e8088974f1d9342103ed1b5de31f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4038042eb0f9e8088974f1d9342103ed1b5de31f", "html_url": "https://github.com/rust-lang/rust/commit/4038042eb0f9e8088974f1d9342103ed1b5de31f"}], "stats": {"total": 75, "additions": 72, "deletions": 3}, "files": [{"sha": "85b1a47f4a9ff5b3f64ca4ae4d3d076245eb523b", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 72, "deletions": 3, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c5eae562935922f712edec56a45591bc2f8ded1c/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5eae562935922f712edec56a45591bc2f8ded1c/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=c5eae562935922f712edec56a45591bc2f8ded1c", "patch": "@@ -12,6 +12,7 @@ use crate::convert::{Infallible, TryFrom};\n use crate::fmt;\n use crate::hash::{self, Hash};\n use crate::marker::Unsize;\n+use crate::mem::MaybeUninit;\n use crate::ops::{Index, IndexMut};\n use crate::slice::{Iter, IterMut};\n \n@@ -429,7 +430,6 @@ impl<T, const N: usize> [T; N] {\n     where\n         F: FnMut(T) -> U,\n     {\n-        use crate::mem::MaybeUninit;\n         struct Guard<T, const N: usize> {\n             dst: *mut T,\n             initialized: usize,\n@@ -481,8 +481,6 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_zip\", issue = \"80094\")]\n     pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n-        use crate::mem::MaybeUninit;\n-\n         let mut dst = MaybeUninit::uninit_array::<N>();\n         for (i, (lhs, rhs)) in IntoIter::new(self).zip(IntoIter::new(rhs)).enumerate() {\n             dst[i].write((lhs, rhs));\n@@ -506,4 +504,75 @@ impl<T, const N: usize> [T; N] {\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         self\n     }\n+\n+    /// Borrows each element and returns an array of references with the same\n+    /// size as `self`.\n+    ///\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(array_methods)]\n+    ///\n+    /// let floats = [3.1, 2.7, -1.0];\n+    /// let float_refs: [&f64; 3] = floats.each_ref();\n+    /// assert_eq!(float_refs, [&3.1, &2.7, &-1.0]);\n+    /// ```\n+    ///\n+    /// This method is particularly useful if combined with other methods, like\n+    /// [`map`](#method.map). This way, you can can avoid moving the original\n+    /// array if its elements are not `Copy`.\n+    ///\n+    /// ```\n+    /// #![feature(array_methods, array_map)]\n+    ///\n+    /// let strings = [\"Ferris\".to_string(), \"\u2665\".to_string(), \"Rust\".to_string()];\n+    /// let is_ascii = strings.each_ref().map(|s| s.is_ascii());\n+    /// assert_eq!(is_ascii, [true, false, true]);\n+    ///\n+    /// // We can still access the original array: it has not been moved.\n+    /// assert_eq!(strings.len(), 3);\n+    /// ```\n+    #[unstable(feature = \"array_methods\", issue = \"76118\")]\n+    pub fn each_ref(&self) -> [&T; N] {\n+        // Unlike in `map`, we don't need a guard here, as dropping a reference\n+        // is a noop.\n+        let mut out = MaybeUninit::uninit_array::<N>();\n+        for (src, dst) in self.iter().zip(&mut out) {\n+            dst.write(src);\n+        }\n+\n+        // SAFETY: All elements of `dst` are properly initialized and\n+        // `MaybeUninit<T>` has the same layout as `T`, so this cast is valid.\n+        unsafe { (&mut out as *mut _ as *mut [&T; N]).read() }\n+    }\n+\n+    /// Borrows each element mutably and returns an array of mutable references\n+    /// with the same size as `self`.\n+    ///\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(array_methods)]\n+    ///\n+    /// let mut floats = [3.1, 2.7, -1.0];\n+    /// let float_refs: [&mut f64; 3] = floats.each_mut();\n+    /// *float_refs[0] = 0.0;\n+    /// assert_eq!(float_refs, [&mut 0.0, &mut 2.7, &mut -1.0]);\n+    /// assert_eq!(floats, [0.0, 2.7, -1.0]);\n+    /// ```\n+    #[unstable(feature = \"array_methods\", issue = \"76118\")]\n+    pub fn each_mut(&mut self) -> [&mut T; N] {\n+        // Unlike in `map`, we don't need a guard here, as dropping a reference\n+        // is a noop.\n+        let mut out = MaybeUninit::uninit_array::<N>();\n+        for (src, dst) in self.iter_mut().zip(&mut out) {\n+            dst.write(src);\n+        }\n+\n+        // SAFETY: All elements of `dst` are properly initialized and\n+        // `MaybeUninit<T>` has the same layout as `T`, so this cast is valid.\n+        unsafe { (&mut out as *mut _ as *mut [&mut T; N]).read() }\n+    }\n }"}]}