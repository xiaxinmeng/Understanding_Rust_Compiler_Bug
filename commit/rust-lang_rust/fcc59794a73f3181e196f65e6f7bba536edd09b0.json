{"sha": "fcc59794a73f3181e196f65e6f7bba536edd09b0", "node_id": "C_kwDOAAsO6NoAKGZjYzU5Nzk0YTczZjMxODFlMTk2ZjY1ZTZmN2JiYTUzNmVkZDA5YjA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-18T07:16:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-18T07:16:29Z"}, "message": "Rollup merge of #91928 - fee1-dead:constification1, r=oli-obk\n\nConstify (most) `Option` methods\n\nr? ``@oli-obk``", "tree": {"sha": "22f16d9263ecedadf0f446e1d175e071f64fc561", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22f16d9263ecedadf0f446e1d175e071f64fc561"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcc59794a73f3181e196f65e6f7bba536edd09b0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhvYrNCRBK7hj4Ov3rIwAAVr8IAHjbNXf9kETnkiFzKD/sSX/T\nC6BwVKjYRydntzH9YDFLeTYF+HoiczVkFy06z4MlTZGtReMYDQ1IUSCR8IjD9KLe\n9m0Nso13JjJNsT+Kw0EWc0kyfF3HaeLW7Wzm0joL7tbugtUtfm8jr197UifrffhZ\nfWaXPcyIHA/mmO6AmYgKpnrARY1UtGFmwYoTS8qe9PErzPc6ad6RTrvPNkSyyuRA\nYRUarwKMt19ctNQ/LmA6LO97rcLPlyW501Ywt6Lp9JcTr0Sy19K4NUVbLO4/wzh0\njuGMMxdZiXW2bsLclvX6hNz3+5U4+3XYDI0Le6681Ra1XTB7Ram+Tems3TSp/G8=\n=qyse\n-----END PGP SIGNATURE-----\n", "payload": "tree 22f16d9263ecedadf0f446e1d175e071f64fc561\nparent 64ce698f7476116892973a38e5c7a0bcecfe472e\nparent f141bedd90233dad9906034562062f89158fecef\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1639811789 +0100\ncommitter GitHub <noreply@github.com> 1639811789 +0100\n\nRollup merge of #91928 - fee1-dead:constification1, r=oli-obk\n\nConstify (most) `Option` methods\n\nr? ``@oli-obk``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcc59794a73f3181e196f65e6f7bba536edd09b0", "html_url": "https://github.com/rust-lang/rust/commit/fcc59794a73f3181e196f65e6f7bba536edd09b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcc59794a73f3181e196f65e6f7bba536edd09b0/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64ce698f7476116892973a38e5c7a0bcecfe472e", "url": "https://api.github.com/repos/rust-lang/rust/commits/64ce698f7476116892973a38e5c7a0bcecfe472e", "html_url": "https://github.com/rust-lang/rust/commit/64ce698f7476116892973a38e5c7a0bcecfe472e"}, {"sha": "f141bedd90233dad9906034562062f89158fecef", "url": "https://api.github.com/repos/rust-lang/rust/commits/f141bedd90233dad9906034562062f89158fecef", "html_url": "https://github.com/rust-lang/rust/commit/f141bedd90233dad9906034562062f89158fecef"}], "stats": {"total": 388, "additions": 311, "deletions": 77}, "files": [{"sha": "e2de9f12aaa71527080243cb1d994f79e1d07274", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -771,11 +771,24 @@ rustc_queries! {\n         desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n         cache_on_disk_if { true }\n         load_cached(tcx, id) {\n-            let typeck_results: Option<ty::TypeckResults<'tcx>> = tcx\n-                .on_disk_cache().as_ref()\n-                .and_then(|c| c.try_load_query_result(*tcx, id));\n+            #[cfg(bootstrap)]\n+            {\n+                match match tcx.on_disk_cache().as_ref() {\n+                    Some(c) => c.try_load_query_result(*tcx, id),\n+                    None => None,\n+                } {\n+                    Some(x) => Some(&*tcx.arena.alloc(x)),\n+                    None => None,\n+                }\n+            }\n+            #[cfg(not(bootstrap))]\n+            {\n+                let typeck_results: Option<ty::TypeckResults<'tcx>> = tcx\n+                    .on_disk_cache().as_ref()\n+                    .and_then(|c| c.try_load_query_result(*tcx, id));\n \n-            typeck_results.map(|x| &*tcx.arena.alloc(x))\n+                typeck_results.map(|x| &*tcx.arena.alloc(x))\n+            }\n         }\n     }\n "}, {"sha": "67f77f14a6e6bcb0382e7b5f68f347795226e8a9", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -123,6 +123,7 @@\n #![feature(const_num_from_num)]\n #![feature(const_ops)]\n #![feature(const_option)]\n+#![feature(const_option_ext)]\n #![feature(const_pin)]\n #![feature(const_replace)]\n #![feature(const_ptr_is_null)]"}, {"sha": "8969c6f617130225d1185b667cd8b3883249fea3", "filename": "library/core/src/option.rs", "status": "modified", "additions": 191, "deletions": 51, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -589,12 +589,13 @@ impl<T> Option<T> {\n     #[must_use]\n     #[inline]\n     #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n-    pub fn contains<U>(&self, x: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn contains<U>(&self, x: &U) -> bool\n     where\n-        U: PartialEq<T>,\n+        U: ~const PartialEq<T>,\n     {\n         match self {\n-            Some(y) => x == y,\n+            Some(y) => x.eq(y),\n             None => false,\n         }\n     }\n@@ -660,10 +661,14 @@ impl<T> Option<T> {\n     #[inline]\n     #[must_use]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n-        // SAFETY: `x` is guaranteed to be pinned because it comes from `self`\n-        // which is pinned.\n-        unsafe { Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x)) }\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n+        match Pin::get_ref(self).as_ref() {\n+            // SAFETY: `x` is guaranteed to be pinned because it comes from `self`\n+            // which is pinned.\n+            Some(x) => unsafe { Some(Pin::new_unchecked(x)) },\n+            None => None,\n+        }\n     }\n \n     /// Converts from <code>[Pin]<[&mut] Option\\<T>></code> to <code>Option<[Pin]<[&mut] T>></code>.\n@@ -672,10 +677,16 @@ impl<T> Option<T> {\n     #[inline]\n     #[must_use]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n         // SAFETY: `get_unchecked_mut` is never used to move the `Option` inside `self`.\n         // `x` is guaranteed to be pinned because it comes from `self` which is pinned.\n-        unsafe { Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x)) }\n+        unsafe {\n+            match Pin::get_unchecked_mut(self).as_mut() {\n+                Some(x) => Some(Pin::new_unchecked(x)),\n+                None => None,\n+            }\n+        }\n     }\n \n     /////////////////////////////////////////////////////////////////////////\n@@ -764,7 +775,11 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or(self, default: T) -> T {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn unwrap_or(self, default: T) -> T\n+    where\n+        T: ~const Drop,\n+    {\n         match self {\n             Some(x) => x,\n             None => default,\n@@ -782,7 +797,12 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn unwrap_or_else<F>(self, f: F) -> T\n+    where\n+        F: ~const FnOnce() -> T,\n+        F: ~const Drop,\n+    {\n         match self {\n             Some(x) => x,\n             None => f(),\n@@ -812,7 +832,8 @@ impl<T> Option<T> {\n     #[inline]\n     #[track_caller]\n     #[stable(feature = \"option_result_unwrap_unchecked\", since = \"1.58.0\")]\n-    pub unsafe fn unwrap_unchecked(self) -> T {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const unsafe fn unwrap_unchecked(self) -> T {\n         debug_assert!(self.is_some());\n         match self {\n             Some(val) => val,\n@@ -842,7 +863,12 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn map<U, F>(self, f: F) -> Option<U>\n+    where\n+        F: ~const FnOnce(T) -> U,\n+        F: ~const Drop,\n+    {\n         match self {\n             Some(x) => Some(f(x)),\n             None => None,\n@@ -866,7 +892,12 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"result_option_inspect\", issue = \"91345\")]\n-    pub fn inspect<F: FnOnce(&T)>(self, f: F) -> Self {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn inspect<F>(self, f: F) -> Self\n+    where\n+        F: ~const FnOnce(&T),\n+        F: ~const Drop,\n+    {\n         if let Some(ref x) = self {\n             f(x);\n         }\n@@ -894,7 +925,13 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn map_or<U, F>(self, default: U, f: F) -> U\n+    where\n+        F: ~const FnOnce(T) -> U,\n+        F: ~const Drop,\n+        U: ~const Drop,\n+    {\n         match self {\n             Some(t) => f(t),\n             None => default,\n@@ -917,7 +954,14 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn map_or_else<U, D: FnOnce() -> U, F: FnOnce(T) -> U>(self, default: D, f: F) -> U {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn map_or_else<U, D, F>(self, default: D, f: F) -> U\n+    where\n+        D: ~const FnOnce() -> U,\n+        D: ~const Drop,\n+        F: ~const FnOnce(T) -> U,\n+        F: ~const Drop,\n+    {\n         match self {\n             Some(t) => f(t),\n             None => default(),\n@@ -947,7 +991,11 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn ok_or<E>(self, err: E) -> Result<T, E>\n+    where\n+        E: ~const Drop,\n+    {\n         match self {\n             Some(v) => Ok(v),\n             None => Err(err),\n@@ -972,7 +1020,12 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn ok_or_else<E, F>(self, err: F) -> Result<T, E>\n+    where\n+        F: ~const FnOnce() -> E,\n+        F: ~const Drop,\n+    {\n         match self {\n             Some(v) => Ok(v),\n             None => Err(err()),\n@@ -1049,7 +1102,12 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn and<U>(self, optb: Option<U>) -> Option<U> {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn and<U>(self, optb: Option<U>) -> Option<U>\n+    where\n+        T: ~const Drop,\n+        U: ~const Drop,\n+    {\n         match self {\n             Some(_) => optb,\n             None => None,\n@@ -1074,7 +1132,12 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn and_then<U, F>(self, f: F) -> Option<U>\n+    where\n+        F: ~const FnOnce(T) -> Option<U>,\n+        F: ~const Drop,\n+    {\n         match self {\n             Some(x) => f(x),\n             None => None,\n@@ -1107,7 +1170,13 @@ impl<T> Option<T> {\n     /// [`Some(t)`]: Some\n     #[inline]\n     #[stable(feature = \"option_filter\", since = \"1.27.0\")]\n-    pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn filter<P>(self, predicate: P) -> Self\n+    where\n+        T: ~const Drop,\n+        P: ~const FnOnce(&T) -> bool,\n+        P: ~const Drop,\n+    {\n         if let Some(x) = self {\n             if predicate(&x) {\n                 return Some(x);\n@@ -1145,9 +1214,13 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or(self, optb: Option<T>) -> Option<T> {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn or(self, optb: Option<T>) -> Option<T>\n+    where\n+        T: ~const Drop,\n+    {\n         match self {\n-            Some(_) => self,\n+            Some(x) => Some(x),\n             None => optb,\n         }\n     }\n@@ -1167,9 +1240,14 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn or_else<F>(self, f: F) -> Option<T>\n+    where\n+        F: ~const FnOnce() -> Option<T>,\n+        F: ~const Drop,\n+    {\n         match self {\n-            Some(_) => self,\n+            Some(x) => Some(x),\n             None => f(),\n         }\n     }\n@@ -1197,7 +1275,11 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_xor\", since = \"1.37.0\")]\n-    pub fn xor(self, optb: Option<T>) -> Option<T> {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn xor(self, optb: Option<T>) -> Option<T>\n+    where\n+        T: ~const Drop,\n+    {\n         match (self, optb) {\n             (Some(a), None) => Some(a),\n             (None, Some(b)) => Some(b),\n@@ -1231,7 +1313,11 @@ impl<T> Option<T> {\n     #[must_use = \"if you intended to set a value, consider assignment instead\"]\n     #[inline]\n     #[stable(feature = \"option_insert\", since = \"1.53.0\")]\n-    pub fn insert(&mut self, value: T) -> &mut T {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn insert(&mut self, value: T) -> &mut T\n+    where\n+        T: ~const Drop,\n+    {\n         *self = Some(value);\n \n         // SAFETY: the code above just filled the option\n@@ -1260,8 +1346,18 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n-    pub fn get_or_insert(&mut self, value: T) -> &mut T {\n-        self.get_or_insert_with(|| value)\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn get_or_insert(&mut self, value: T) -> &mut T\n+    where\n+        T: ~const Drop,\n+    {\n+        if let None = *self {\n+            *self = Some(value);\n+        }\n+\n+        // SAFETY: a `None` variant for `self` would have been replaced by a `Some`\n+        // variant in the code above.\n+        unsafe { self.as_mut().unwrap_unchecked() }\n     }\n \n     /// Inserts the default value into the option if it is [`None`], then\n@@ -1285,11 +1381,17 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[unstable(feature = \"option_get_or_insert_default\", issue = \"82901\")]\n-    pub fn get_or_insert_default(&mut self) -> &mut T\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn get_or_insert_default(&mut self) -> &mut T\n     where\n-        T: Default,\n+        T: ~const Default,\n     {\n-        self.get_or_insert_with(Default::default)\n+        #[rustc_allow_const_fn_unstable(const_fn_trait_bound)]\n+        const fn default<T: ~const Default>() -> T {\n+            T::default()\n+        }\n+\n+        self.get_or_insert_with(default)\n     }\n \n     /// Inserts a value computed from `f` into the option if it is [`None`],\n@@ -1311,17 +1413,21 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n-    pub fn get_or_insert_with<F: FnOnce() -> T>(&mut self, f: F) -> &mut T {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn get_or_insert_with<F>(&mut self, f: F) -> &mut T\n+    where\n+        F: ~const FnOnce() -> T,\n+        F: ~const Drop,\n+    {\n         if let None = *self {\n-            *self = Some(f());\n+            // the compiler isn't smart enough to know that we are not dropping a `T`\n+            // here and wants us to ensure `T` can be dropped at compile time.\n+            mem::forget(mem::replace(self, Some(f())))\n         }\n \n-        match self {\n-            Some(v) => v,\n-            // SAFETY: a `None` variant for `self` would have been replaced by a `Some`\n-            // variant in the code above.\n-            None => unsafe { hint::unreachable_unchecked() },\n-        }\n+        // SAFETY: a `None` variant for `self` would have been replaced by a `Some`\n+        // variant in the code above.\n+        unsafe { self.as_mut().unwrap_unchecked() }\n     }\n \n     /////////////////////////////////////////////////////////////////////////\n@@ -1391,7 +1497,12 @@ impl<T> Option<T> {\n     /// assert_eq!(x.zip(z), None);\n     /// ```\n     #[stable(feature = \"option_zip_option\", since = \"1.46.0\")]\n-    pub fn zip<U>(self, other: Option<U>) -> Option<(T, U)> {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn zip<U>(self, other: Option<U>) -> Option<(T, U)>\n+    where\n+        T: ~const Drop,\n+        U: ~const Drop,\n+    {\n         match (self, other) {\n             (Some(a), Some(b)) => Some((a, b)),\n             _ => None,\n@@ -1427,11 +1538,18 @@ impl<T> Option<T> {\n     /// assert_eq!(x.zip_with(None, Point::new), None);\n     /// ```\n     #[unstable(feature = \"option_zip\", issue = \"70086\")]\n-    pub fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R>\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn zip_with<U, F, R>(self, other: Option<U>, f: F) -> Option<R>\n     where\n-        F: FnOnce(T, U) -> R,\n+        F: ~const FnOnce(T, U) -> R,\n+        F: ~const Drop,\n+        T: ~const Drop,\n+        U: ~const Drop,\n     {\n-        Some(f(self?, other?))\n+        match (self, other) {\n+            (Some(a), Some(b)) => Some(f(a, b)),\n+            _ => None,\n+        }\n     }\n }\n \n@@ -1503,8 +1621,12 @@ impl<T: Copy> Option<&mut T> {\n     /// ```\n     #[must_use = \"`self` will be dropped if the result is not used\"]\n     #[stable(feature = \"copied\", since = \"1.35.0\")]\n-    pub fn copied(self) -> Option<T> {\n-        self.map(|&mut t| t)\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn copied(self) -> Option<T> {\n+        match self {\n+            Some(&mut t) => Some(t),\n+            None => None,\n+        }\n     }\n }\n \n@@ -1591,7 +1713,11 @@ impl<T: Default> Option<T> {\n     /// [`FromStr`]: crate::str::FromStr\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn unwrap_or_default(self) -> T {\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn unwrap_or_default(self) -> T\n+    where\n+        T: ~const Default,\n+    {\n         match self {\n             Some(x) => x,\n             None => Default::default(),\n@@ -1615,8 +1741,15 @@ impl<T: Deref> Option<T> {\n     /// assert_eq!(x.as_deref(), None);\n     /// ```\n     #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n-    pub fn as_deref(&self) -> Option<&T::Target> {\n-        self.as_ref().map(|t| t.deref())\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn as_deref(&self) -> Option<&T::Target>\n+    where\n+        T: ~const Deref,\n+    {\n+        match self.as_ref() {\n+            Some(t) => Some(t.deref()),\n+            None => None,\n+        }\n     }\n }\n \n@@ -1636,8 +1769,15 @@ impl<T: DerefMut> Option<T> {\n     /// }), Some(\"HEY\".to_owned().as_mut_str()));\n     /// ```\n     #[stable(feature = \"option_deref\", since = \"1.40.0\")]\n-    pub fn as_deref_mut(&mut self) -> Option<&mut T::Target> {\n-        self.as_mut().map(|t| t.deref_mut())\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn as_deref_mut(&mut self) -> Option<&mut T::Target>\n+    where\n+        T: ~const DerefMut,\n+    {\n+        match self.as_mut() {\n+            Some(t) => Some(t.deref_mut()),\n+            None => None,\n+        }\n     }\n }\n "}, {"sha": "21562acf3d766cad63cc648c08f0f907ad34e4c7", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -70,8 +70,10 @@\n #![feature(portable_simd)]\n #![feature(ptr_metadata)]\n #![feature(once_cell)]\n+#![feature(option_result_contains)]\n #![feature(unsized_tuple_coercion)]\n #![feature(const_option)]\n+#![feature(const_option_ext)]\n #![feature(const_result)]\n #![feature(integer_atomics)]\n #![feature(int_roundings)]"}, {"sha": "da692461261fcc6cf44941729e87abe33cceb628", "filename": "library/core/tests/option.rs", "status": "modified", "additions": 88, "deletions": 10, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/library%2Fcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/library%2Fcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Foption.rs?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -86,17 +86,49 @@ fn test_and() {\n     let x: Option<isize> = None;\n     assert_eq!(x.and(Some(2)), None);\n     assert_eq!(x.and(None::<isize>), None);\n+\n+    const FOO: Option<isize> = Some(1);\n+    const A: Option<isize> = FOO.and(Some(2));\n+    const B: Option<isize> = FOO.and(None);\n+    assert_eq!(A, Some(2));\n+    assert_eq!(B, None);\n+\n+    const BAR: Option<isize> = None;\n+    const C: Option<isize> = BAR.and(Some(2));\n+    const D: Option<isize> = BAR.and(None);\n+    assert_eq!(C, None);\n+    assert_eq!(D, None);\n }\n \n #[test]\n fn test_and_then() {\n+    const fn plus_one(x: isize) -> Option<isize> {\n+        Some(x + 1)\n+    }\n+\n+    const fn none(_: isize) -> Option<isize> {\n+        None\n+    }\n+\n     let x: Option<isize> = Some(1);\n-    assert_eq!(x.and_then(|x| Some(x + 1)), Some(2));\n-    assert_eq!(x.and_then(|_| None::<isize>), None);\n+    assert_eq!(x.and_then(plus_one), Some(2));\n+    assert_eq!(x.and_then(none), None);\n \n     let x: Option<isize> = None;\n-    assert_eq!(x.and_then(|x| Some(x + 1)), None);\n-    assert_eq!(x.and_then(|_| None::<isize>), None);\n+    assert_eq!(x.and_then(plus_one), None);\n+    assert_eq!(x.and_then(none), None);\n+\n+    const FOO: Option<isize> = Some(1);\n+    const A: Option<isize> = FOO.and_then(plus_one);\n+    const B: Option<isize> = FOO.and_then(none);\n+    assert_eq!(A, Some(2));\n+    assert_eq!(B, None);\n+\n+    const BAR: Option<isize> = None;\n+    const C: Option<isize> = BAR.and_then(plus_one);\n+    const D: Option<isize> = BAR.and_then(none);\n+    assert_eq!(C, None);\n+    assert_eq!(D, None);\n }\n \n #[test]\n@@ -108,17 +140,49 @@ fn test_or() {\n     let x: Option<isize> = None;\n     assert_eq!(x.or(Some(2)), Some(2));\n     assert_eq!(x.or(None), None);\n+\n+    const FOO: Option<isize> = Some(1);\n+    const A: Option<isize> = FOO.or(Some(2));\n+    const B: Option<isize> = FOO.or(None);\n+    assert_eq!(A, Some(1));\n+    assert_eq!(B, Some(1));\n+\n+    const BAR: Option<isize> = None;\n+    const C: Option<isize> = BAR.or(Some(2));\n+    const D: Option<isize> = BAR.or(None);\n+    assert_eq!(C, Some(2));\n+    assert_eq!(D, None);\n }\n \n #[test]\n fn test_or_else() {\n+    const fn two() -> Option<isize> {\n+        Some(2)\n+    }\n+\n+    const fn none() -> Option<isize> {\n+        None\n+    }\n+\n     let x: Option<isize> = Some(1);\n-    assert_eq!(x.or_else(|| Some(2)), Some(1));\n-    assert_eq!(x.or_else(|| None), Some(1));\n+    assert_eq!(x.or_else(two), Some(1));\n+    assert_eq!(x.or_else(none), Some(1));\n \n     let x: Option<isize> = None;\n-    assert_eq!(x.or_else(|| Some(2)), Some(2));\n-    assert_eq!(x.or_else(|| None), None);\n+    assert_eq!(x.or_else(two), Some(2));\n+    assert_eq!(x.or_else(none), None);\n+\n+    const FOO: Option<isize> = Some(1);\n+    const A: Option<isize> = FOO.or_else(two);\n+    const B: Option<isize> = FOO.or_else(none);\n+    assert_eq!(A, Some(1));\n+    assert_eq!(B, Some(1));\n+\n+    const BAR: Option<isize> = None;\n+    const C: Option<isize> = BAR.or_else(two);\n+    const D: Option<isize> = BAR.or_else(none);\n+    assert_eq!(C, Some(2));\n+    assert_eq!(D, None);\n }\n \n #[test]\n@@ -149,15 +213,29 @@ fn test_unwrap_or() {\n \n     let x: Option<isize> = None;\n     assert_eq!(x.unwrap_or(2), 2);\n+\n+    const A: isize = Some(1).unwrap_or(2);\n+    const B: isize = None.unwrap_or(2);\n+    assert_eq!(A, 1);\n+    assert_eq!(B, 2);\n }\n \n #[test]\n fn test_unwrap_or_else() {\n+    const fn two() -> isize {\n+        2\n+    }\n+\n     let x: Option<isize> = Some(1);\n-    assert_eq!(x.unwrap_or_else(|| 2), 1);\n+    assert_eq!(x.unwrap_or_else(two), 1);\n \n     let x: Option<isize> = None;\n-    assert_eq!(x.unwrap_or_else(|| 2), 2);\n+    assert_eq!(x.unwrap_or_else(two), 2);\n+\n+    const A: isize = Some(1).unwrap_or_else(two);\n+    const B: isize = None.unwrap_or_else(two);\n+    assert_eq!(A, 1);\n+    assert_eq!(B, 2);\n }\n \n #[test]"}, {"sha": "7ffe3c1ef954ab6378d2c072698f6189be11a194", "filename": "src/test/ui/closures/closure-expected.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fclosure-expected.stderr?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -11,8 +11,8 @@ LL |     let y = x.or_else(4);\n note: required by a bound in `Option::<T>::or_else`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL |     pub fn or_else<F: FnOnce() -> Option<T>>(self, f: F) -> Option<T> {\n-   |                       ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::or_else`\n+LL |         F: ~const FnOnce() -> Option<T>,\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::or_else`\n \n error: aborting due to previous error\n "}, {"sha": "883348eb98c708a100de973996c79043f4ca19d9", "filename": "src/test/ui/closures/coerce-unsafe-to-closure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fclosures%2Fcoerce-unsafe-to-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fclosures%2Fcoerce-unsafe-to-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fcoerce-unsafe-to-closure.stderr?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -10,8 +10,8 @@ LL |     let x: Option<&[u8]> = Some(\"foo\").map(std::mem::transmute);\n note: required by a bound in `Option::<T>::map`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL |     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n-   |                      ^^^^^^^^^^^^^^ required by this bound in `Option::<T>::map`\n+LL |         F: ~const FnOnce(T) -> U,\n+   |            ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::map`\n \n error: aborting due to previous error\n "}, {"sha": "9db9cfc7ff0244c8bc81bc09da01b2cc6cc86c22", "filename": "src/test/ui/expr/malformed_closure/ruby_style_closure.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr%2Fmalformed_closure%2Fruby_style_closure.stderr?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -23,8 +23,8 @@ LL | |     });\n note: required by a bound in `Option::<T>::and_then`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL |     pub fn and_then<U, F: FnOnce(T) -> Option<U>>(self, f: F) -> Option<U> {\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::and_then`\n+LL |         F: ~const FnOnce(T) -> Option<U>,\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::and_then`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d596b4a69f34a89c1c352dab236708feb6da91a4", "filename": "src/test/ui/issues/issue-47706-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fissues%2Fissue-47706-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fissues%2Fissue-47706-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47706-trait.stderr?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -11,8 +11,8 @@ LL |         None::<()>.map(Self::f);\n note: required by a bound in `Option::<T>::map`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL |     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n-   |                      ^^^^^^^^^^^^^^ required by this bound in `Option::<T>::map`\n+LL |         F: ~const FnOnce(T) -> U,\n+   |            ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::map`\n \n error: aborting due to previous error\n "}, {"sha": "0b4f84a330a548f3b2b371ca18f8d5f46c49e0b2", "filename": "src/test/ui/issues/issue-47706.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fissues%2Fissue-47706.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fissues%2Fissue-47706.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-47706.stderr?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -12,8 +12,8 @@ LL |         self.foo.map(Foo::new)\n note: required by a bound in `Option::<T>::map`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL |     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n-   |                      ^^^^^^^^^^^^^^ required by this bound in `Option::<T>::map`\n+LL |         F: ~const FnOnce(T) -> U,\n+   |            ^^^^^^^^^^^^^^^^^^^^^ required by this bound in `Option::<T>::map`\n \n error[E0593]: function is expected to take 0 arguments, but it takes 1 argument\n   --> $DIR/issue-47706.rs:27:9"}, {"sha": "3c9d0f72abe0c0f643e2c8c63555dd2de8873ce8", "filename": "src/test/ui/suggestions/as-ref-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fsuggestions%2Fas-ref-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fcc59794a73f3181e196f65e6f7bba536edd09b0/src%2Ftest%2Fui%2Fsuggestions%2Fas-ref-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fas-ref-2.stderr?ref=fcc59794a73f3181e196f65e6f7bba536edd09b0", "patch": "@@ -11,8 +11,8 @@ LL |     let _y = foo;\n note: this function takes ownership of the receiver `self`, which moves `foo`\n   --> $SRC_DIR/core/src/option.rs:LL:COL\n    |\n-LL |     pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {\n-   |                                      ^^^^\n+LL |     pub const fn map<U, F>(self, f: F) -> Option<U>\n+   |                            ^^^^\n help: consider calling `.as_ref()` to borrow the type's contents\n    |\n LL |     let _x: Option<Struct> = foo.as_ref().map(|s| bar(&s));"}]}