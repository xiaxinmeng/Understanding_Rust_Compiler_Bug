{"sha": "41e0363055ade59584cff667c79f64937e6ef3f9", "node_id": "C_kwDOAAsO6NoAKDQxZTAzNjMwNTVhZGU1OTU4NGNmZjY2N2M3OWY2NDkzN2U2ZWYzZjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-25T06:14:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-25T06:14:42Z"}, "message": "Auto merge of #104602 - petrochenkov:effvisperf5, r=oli-obk\n\nprivacy: Fix more (potential) issues with effective visibilities\n\nContinuation of https://github.com/rust-lang/rust/pull/103965.\nSee individual commits for more detailed description of the changes.\n\nThe shortcuts removed in https://github.com/rust-lang/rust/pull/104602/commits/4eb63f618e601efee657d24cd4e8833fb03fac4c and https://github.com/rust-lang/rust/pull/104602/commits/c7c7d1672739e38c8d39ae861b284486aefd5b48 could actually be correct (or correct after some tweaks), but they used global reasoning like \"we can skip this update because if the code compiles then some other update should do the same thing eventually\".\nI have some expertise in this area, but I still have doubt whether such global reasoning was correct or not, especially in presence of all possible exotic cases with imports.\nAfter this PR all table changes should be \"locally correct\" after every update, even if it may be overcautious.\nIf similar optimizations are introduced again they will need detailed comments explaining why it's legal to do what they do and providing proofs.\n\nFixes https://github.com/rust-lang/rust/issues/104249.\nFixes https://github.com/rust-lang/rust/issues/104539.", "tree": {"sha": "cb7ee93fc9ada627bd4a1e0dd753e3b15006ff3e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb7ee93fc9ada627bd4a1e0dd753e3b15006ff3e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41e0363055ade59584cff667c79f64937e6ef3f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41e0363055ade59584cff667c79f64937e6ef3f9", "html_url": "https://github.com/rust-lang/rust/commit/41e0363055ade59584cff667c79f64937e6ef3f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41e0363055ade59584cff667c79f64937e6ef3f9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af63e3b39f3990418ad8e0a1b1fa8a722a7c50b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/af63e3b39f3990418ad8e0a1b1fa8a722a7c50b0", "html_url": "https://github.com/rust-lang/rust/commit/af63e3b39f3990418ad8e0a1b1fa8a722a7c50b0"}, {"sha": "47cd844468a45ea3dde60b2d19c282639e2e44fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/47cd844468a45ea3dde60b2d19c282639e2e44fc", "html_url": "https://github.com/rust-lang/rust/commit/47cd844468a45ea3dde60b2d19c282639e2e44fc"}], "stats": {"total": 279, "additions": 178, "deletions": 101}, "files": [{"sha": "fc08d58cc40687765dbf33fa580b95a17dcbe1fc", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 57, "deletions": 50, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/41e0363055ade59584cff667c79f64937e6ef3f9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e0363055ade59584cff667c79f64937e6ef3f9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=41e0363055ade59584cff667c79f64937e6ef3f9", "patch": "@@ -4,7 +4,6 @@\n use crate::ty::{DefIdTree, TyCtxt, Visibility};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def::DefKind;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_span::def_id::LocalDefId;\n@@ -142,13 +141,13 @@ impl EffectiveVisibilities {\n     pub fn set_public_at_level(\n         &mut self,\n         id: LocalDefId,\n-        default_vis: impl FnOnce() -> Visibility,\n+        lazy_private_vis: impl FnOnce() -> Visibility,\n         level: Level,\n     ) {\n         let mut effective_vis = self\n             .effective_vis(id)\n             .copied()\n-            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis()));\n+            .unwrap_or_else(|| EffectiveVisibility::from_vis(lazy_private_vis()));\n         for l in Level::all_levels() {\n             if l <= level {\n                 *effective_vis.at_level_mut(l) = Visibility::Public;\n@@ -185,7 +184,6 @@ impl EffectiveVisibilities {\n                 );\n             }\n             let nominal_vis = tcx.visibility(def_id);\n-            let def_kind = tcx.opt_def_kind(def_id);\n             // FIXME: `rustc_privacy` is not yet updated for the new logic and can set\n             // effective visibilities that are larger than the nominal one.\n             if !nominal_vis.is_at_least(ev.reachable_through_impl_trait, tcx) && early {\n@@ -197,15 +195,15 @@ impl EffectiveVisibilities {\n                     nominal_vis\n                 );\n             }\n-            // Fully private items are never put into the table, this is important for performance.\n-            // FIXME: Fully private `mod` items are currently put into the table.\n-            if ev.reachable_through_impl_trait == private_vis && def_kind != Some(DefKind::Mod) {\n-                span_bug!(span, \"fully private item in the table {:?}: {:?}\", def_id, ev.direct);\n-            }\n         }\n     }\n }\n \n+pub trait IntoDefIdTree {\n+    type Tree: DefIdTree;\n+    fn tree(self) -> Self::Tree;\n+}\n+\n impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n     pub fn iter(&self) -> impl Iterator<Item = (&Id, &EffectiveVisibility)> {\n         self.map.iter()\n@@ -215,56 +213,65 @@ impl<Id: Eq + Hash> EffectiveVisibilities<Id> {\n         self.map.get(&id)\n     }\n \n-    // `parent_id` is not necessarily a parent in source code tree,\n-    // it is the node from which the maximum effective visibility is inherited.\n-    pub fn update(\n+    // FIXME: Share code with `fn update`.\n+    pub fn effective_vis_or_private(\n+        &mut self,\n+        id: Id,\n+        lazy_private_vis: impl FnOnce() -> Visibility,\n+    ) -> &EffectiveVisibility {\n+        self.map.entry(id).or_insert_with(|| EffectiveVisibility::from_vis(lazy_private_vis()))\n+    }\n+\n+    pub fn update<T: IntoDefIdTree>(\n         &mut self,\n         id: Id,\n         nominal_vis: Visibility,\n-        default_vis: Visibility,\n-        inherited_eff_vis: Option<EffectiveVisibility>,\n+        lazy_private_vis: impl FnOnce(T) -> (Visibility, T),\n+        inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n-        tree: impl DefIdTree,\n+        mut into_tree: T,\n     ) -> bool {\n         let mut changed = false;\n-        let mut current_effective_vis = self\n-            .map\n-            .get(&id)\n-            .copied()\n-            .unwrap_or_else(|| EffectiveVisibility::from_vis(default_vis));\n-        if let Some(inherited_effective_vis) = inherited_eff_vis {\n-            let mut inherited_effective_vis_at_prev_level =\n-                *inherited_effective_vis.at_level(level);\n-            let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n-            for l in Level::all_levels() {\n-                if level >= l {\n-                    let inherited_effective_vis_at_level = *inherited_effective_vis.at_level(l);\n-                    let current_effective_vis_at_level = current_effective_vis.at_level_mut(l);\n-                    // effective visibility for id shouldn't be recalculated if\n-                    // inherited from parent_id effective visibility isn't changed at next level\n-                    if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n-                        && level != l)\n-                    {\n-                        calculated_effective_vis =\n-                            if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n-                                inherited_effective_vis_at_level\n-                            } else {\n-                                nominal_vis\n-                            };\n-                    }\n-                    // effective visibility can't be decreased at next update call for the\n-                    // same id\n-                    if *current_effective_vis_at_level != calculated_effective_vis\n-                        && calculated_effective_vis\n-                            .is_at_least(*current_effective_vis_at_level, tree)\n-                    {\n-                        changed = true;\n-                        *current_effective_vis_at_level = calculated_effective_vis;\n-                    }\n-                    inherited_effective_vis_at_prev_level = inherited_effective_vis_at_level;\n+        let mut current_effective_vis = match self.map.get(&id).copied() {\n+            Some(eff_vis) => eff_vis,\n+            None => {\n+                let private_vis;\n+                (private_vis, into_tree) = lazy_private_vis(into_tree);\n+                EffectiveVisibility::from_vis(private_vis)\n+            }\n+        };\n+        let tree = into_tree.tree();\n+\n+        let mut inherited_effective_vis_at_prev_level = *inherited_effective_vis.at_level(level);\n+        let mut calculated_effective_vis = inherited_effective_vis_at_prev_level;\n+        for l in Level::all_levels() {\n+            if level >= l {\n+                let inherited_effective_vis_at_level = *inherited_effective_vis.at_level(l);\n+                let current_effective_vis_at_level = current_effective_vis.at_level_mut(l);\n+                // effective visibility for id shouldn't be recalculated if\n+                // inherited from parent_id effective visibility isn't changed at next level\n+                if !(inherited_effective_vis_at_prev_level == inherited_effective_vis_at_level\n+                    && level != l)\n+                {\n+                    calculated_effective_vis =\n+                        if nominal_vis.is_at_least(inherited_effective_vis_at_level, tree) {\n+                            inherited_effective_vis_at_level\n+                        } else {\n+                            nominal_vis\n+                        };\n                 }\n+                // effective visibility can't be decreased at next update call for the\n+                // same id\n+                if *current_effective_vis_at_level != calculated_effective_vis\n+                    && calculated_effective_vis.is_at_least(*current_effective_vis_at_level, tree)\n+                {\n+                    changed = true;\n+                    *current_effective_vis_at_level = calculated_effective_vis;\n+                }\n+                inherited_effective_vis_at_prev_level = inherited_effective_vis_at_level;\n             }\n         }\n+\n         self.map.insert(id, current_effective_vis);\n         changed\n     }"}, {"sha": "3aa8d52db038173b57eab84b0da899cefa0a9120", "filename": "compiler/rustc_resolve/src/effective_visibilities.rs", "status": "modified", "additions": 71, "deletions": 45, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/41e0363055ade59584cff667c79f64937e6ef3f9/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e0363055ade59584cff667c79f64937e6ef3f9/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Feffective_visibilities.rs?ref=41e0363055ade59584cff667c79f64937e6ef3f9", "patch": "@@ -7,8 +7,10 @@ use rustc_ast::EnumDef;\n use rustc_data_structures::intern::Interned;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n-use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility, Level};\n-use rustc_middle::ty::Visibility;\n+use rustc_middle::middle::privacy::{EffectiveVisibilities, EffectiveVisibility};\n+use rustc_middle::middle::privacy::{IntoDefIdTree, Level};\n+use rustc_middle::ty::{DefIdTree, Visibility};\n+use std::mem;\n \n type ImportId<'a> = Interned<'a, NameBinding<'a>>;\n \n@@ -29,31 +31,71 @@ impl ParentId<'_> {\n \n pub struct EffectiveVisibilitiesVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n+    def_effective_visibilities: EffectiveVisibilities,\n     /// While walking import chains we need to track effective visibilities per-binding, and def id\n     /// keys in `Resolver::effective_visibilities` are not enough for that, because multiple\n     /// bindings can correspond to a single def id in imports. So we keep a separate table.\n     import_effective_visibilities: EffectiveVisibilities<ImportId<'a>>,\n+    // It's possible to recalculate this at any point, but it's relatively expensive.\n+    current_private_vis: Visibility,\n     changed: bool,\n }\n \n+impl Resolver<'_> {\n+    fn nearest_normal_mod(&mut self, def_id: LocalDefId) -> LocalDefId {\n+        self.get_nearest_non_block_module(def_id.to_def_id()).nearest_parent_mod().expect_local()\n+    }\n+\n+    fn private_vis_import(&mut self, binding: ImportId<'_>) -> Visibility {\n+        let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n+        Visibility::Restricted(\n+            import\n+                .id()\n+                .map(|id| self.nearest_normal_mod(self.local_def_id(id)))\n+                .unwrap_or(CRATE_DEF_ID),\n+        )\n+    }\n+\n+    fn private_vis_def(&mut self, def_id: LocalDefId) -> Visibility {\n+        // For mod items `nearest_normal_mod` returns its argument, but we actually need its parent.\n+        let normal_mod_id = self.nearest_normal_mod(def_id);\n+        if normal_mod_id == def_id {\n+            self.opt_local_parent(def_id).map_or(Visibility::Public, Visibility::Restricted)\n+        } else {\n+            Visibility::Restricted(normal_mod_id)\n+        }\n+    }\n+}\n+\n+impl<'a, 'b> IntoDefIdTree for &'b mut Resolver<'a> {\n+    type Tree = &'b Resolver<'a>;\n+    fn tree(self) -> Self::Tree {\n+        self\n+    }\n+}\n+\n impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n     /// Fills the `Resolver::effective_visibilities` table with public & exported items\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n     pub fn compute_effective_visibilities<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n         let mut visitor = EffectiveVisibilitiesVisitor {\n             r,\n+            def_effective_visibilities: Default::default(),\n             import_effective_visibilities: Default::default(),\n+            current_private_vis: Visibility::Public,\n             changed: false,\n         };\n \n         visitor.update(CRATE_DEF_ID, CRATE_DEF_ID);\n+        visitor.current_private_vis = Visibility::Restricted(CRATE_DEF_ID);\n         visitor.set_bindings_effective_visibilities(CRATE_DEF_ID);\n \n         while visitor.changed {\n             visitor.changed = false;\n             visit::walk_crate(&mut visitor, krate);\n         }\n+        visitor.r.effective_visibilities = visitor.def_effective_visibilities;\n \n         // Update visibilities for import def ids. These are not used during the\n         // `EffectiveVisibilitiesVisitor` pass, because we have more detailed binding-based\n@@ -90,10 +132,6 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n         info!(\"resolve::effective_visibilities: {:#?}\", r.effective_visibilities);\n     }\n \n-    fn nearest_normal_mod(&mut self, def_id: LocalDefId) -> LocalDefId {\n-        self.r.get_nearest_non_block_module(def_id.to_def_id()).nearest_parent_mod().expect_local()\n-    }\n-\n     /// Update effective visibilities of bindings in the given module,\n     /// including their whole reexport chains.\n     fn set_bindings_effective_visibilities(&mut self, module_id: LocalDefId) {\n@@ -122,62 +160,47 @@ impl<'r, 'a> EffectiveVisibilitiesVisitor<'r, 'a> {\n         }\n     }\n \n-    fn effective_vis(&self, parent_id: ParentId<'a>) -> Option<EffectiveVisibility> {\n-        match parent_id {\n-            ParentId::Def(def_id) => self.r.effective_visibilities.effective_vis(def_id),\n-            ParentId::Import(binding) => self.import_effective_visibilities.effective_vis(binding),\n-        }\n-        .copied()\n+    fn cheap_private_vis(&self, parent_id: ParentId<'_>) -> Option<Visibility> {\n+        matches!(parent_id, ParentId::Def(_)).then_some(self.current_private_vis)\n     }\n \n-    /// The update is guaranteed to not change the table and we can skip it.\n-    fn is_noop_update(\n-        &self,\n-        parent_id: ParentId<'a>,\n-        nominal_vis: Visibility,\n-        default_vis: Visibility,\n-    ) -> bool {\n-        nominal_vis == default_vis\n-            || match parent_id {\n-                ParentId::Def(def_id) => self.r.visibilities[&def_id],\n-                ParentId::Import(binding) => binding.vis.expect_local(),\n-            } == default_vis\n+    fn effective_vis_or_private(&mut self, parent_id: ParentId<'a>) -> EffectiveVisibility {\n+        // Private nodes are only added to the table for caching, they could be added or removed at\n+        // any moment without consequences, so we don't set `changed` to true when adding them.\n+        *match parent_id {\n+            ParentId::Def(def_id) => self\n+                .def_effective_visibilities\n+                .effective_vis_or_private(def_id, || self.r.private_vis_def(def_id)),\n+            ParentId::Import(binding) => self\n+                .import_effective_visibilities\n+                .effective_vis_or_private(binding, || self.r.private_vis_import(binding)),\n+        }\n     }\n \n     fn update_import(&mut self, binding: ImportId<'a>, parent_id: ParentId<'a>) {\n-        let NameBindingKind::Import { import, .. } = binding.kind else { unreachable!() };\n         let nominal_vis = binding.vis.expect_local();\n-        let default_vis = Visibility::Restricted(\n-            import\n-                .id()\n-                .map(|id| self.nearest_normal_mod(self.r.local_def_id(id)))\n-                .unwrap_or(CRATE_DEF_ID),\n-        );\n-        if self.is_noop_update(parent_id, nominal_vis, default_vis) {\n-            return;\n-        }\n+        let private_vis = self.cheap_private_vis(parent_id);\n+        let inherited_eff_vis = self.effective_vis_or_private(parent_id);\n         self.changed |= self.import_effective_visibilities.update(\n             binding,\n             nominal_vis,\n-            default_vis,\n-            self.effective_vis(parent_id),\n+            |r| (private_vis.unwrap_or_else(|| r.private_vis_import(binding)), r),\n+            inherited_eff_vis,\n             parent_id.level(),\n-            ResolverTree(&self.r.definitions, &self.r.crate_loader),\n+            &mut *self.r,\n         );\n     }\n \n     fn update_def(&mut self, def_id: LocalDefId, nominal_vis: Visibility, parent_id: ParentId<'a>) {\n-        let default_vis = Visibility::Restricted(self.nearest_normal_mod(def_id));\n-        if self.is_noop_update(parent_id, nominal_vis, default_vis) {\n-            return;\n-        }\n-        self.changed |= self.r.effective_visibilities.update(\n+        let private_vis = self.cheap_private_vis(parent_id);\n+        let inherited_eff_vis = self.effective_vis_or_private(parent_id);\n+        self.changed |= self.def_effective_visibilities.update(\n             def_id,\n             nominal_vis,\n-            if def_id == CRATE_DEF_ID { Visibility::Public } else { default_vis },\n-            self.effective_vis(parent_id),\n+            |r| (private_vis.unwrap_or_else(|| r.private_vis_def(def_id)), r),\n+            inherited_eff_vis,\n             parent_id.level(),\n-            ResolverTree(&self.r.definitions, &self.r.crate_loader),\n+            &mut *self.r,\n         );\n     }\n \n@@ -201,8 +224,11 @@ impl<'r, 'ast> Visitor<'ast> for EffectiveVisibilitiesVisitor<'ast, 'r> {\n             ),\n \n             ast::ItemKind::Mod(..) => {\n+                let prev_private_vis =\n+                    mem::replace(&mut self.current_private_vis, Visibility::Restricted(def_id));\n                 self.set_bindings_effective_visibilities(def_id);\n                 visit::walk_item(self, item);\n+                self.current_private_vis = prev_private_vis;\n             }\n \n             ast::ItemKind::Enum(EnumDef { ref variants }, _) => {"}, {"sha": "8d0602fa79f02ea06414251afd8437e2f184ac2b", "filename": "src/test/ui/privacy/effective_visibilities.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41e0363055ade59584cff667c79f64937e6ef3f9/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e0363055ade59584cff667c79f64937e6ef3f9/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.rs?ref=41e0363055ade59584cff667c79f64937e6ef3f9", "patch": "@@ -17,13 +17,13 @@ mod outer { //~ ERROR Direct: pub(crate), Reexported: pub(crate), Reachable: pub\n         }\n \n         #[rustc_effective_visibility]\n-        struct PrivStruct; //~ ERROR not in the table\n-                           //~| ERROR not in the table\n+        struct PrivStruct; //~ ERROR Direct: pub(self), Reexported: pub(self), Reachable: pub(self), ReachableThroughImplTrait: pub(self)\n+                           //~| ERROR Direct: pub(self), Reexported: pub(self), Reachable: pub(self), ReachableThroughImplTrait: pub(self)\n \n         #[rustc_effective_visibility]\n         pub union PubUnion { //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n             #[rustc_effective_visibility]\n-            a: u8, //~ ERROR not in the table\n+            a: u8, //~ ERROR Direct: pub(self), Reexported: pub(self), Reachable: pub(self), ReachableThroughImplTrait: pub(self)\n             #[rustc_effective_visibility]\n             pub b: u8, //~ ERROR Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImplTrait: pub\n         }"}, {"sha": "6a99afe64fee3f67cd2f410f58929e957a3f435f", "filename": "src/test/ui/privacy/effective_visibilities.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41e0363055ade59584cff667c79f64937e6ef3f9/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41e0363055ade59584cff667c79f64937e6ef3f9/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities.stderr?ref=41e0363055ade59584cff667c79f64937e6ef3f9", "patch": "@@ -22,13 +22,13 @@ error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImpl\n LL |         pub trait PubTrait {\n    |         ^^^^^^^^^^^^^^^^^^\n \n-error: not in the table\n+error: Direct: pub(self), Reexported: pub(self), Reachable: pub(self), ReachableThroughImplTrait: pub(self)\n   --> $DIR/effective_visibilities.rs:20:9\n    |\n LL |         struct PrivStruct;\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: not in the table\n+error: Direct: pub(self), Reexported: pub(self), Reachable: pub(self), ReachableThroughImplTrait: pub(self)\n   --> $DIR/effective_visibilities.rs:20:9\n    |\n LL |         struct PrivStruct;\n@@ -40,7 +40,7 @@ error: Direct: pub(crate), Reexported: pub, Reachable: pub, ReachableThroughImpl\n LL |         pub union PubUnion {\n    |         ^^^^^^^^^^^^^^^^^^\n \n-error: not in the table\n+error: Direct: pub(self), Reexported: pub(self), Reachable: pub(self), ReachableThroughImplTrait: pub(self)\n   --> $DIR/effective_visibilities.rs:26:13\n    |\n LL |             a: u8,"}, {"sha": "af5a2bed6ab24bef151797620a69b587817d29ca", "filename": "src/test/ui/privacy/effective_visibilities_invariants.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41e0363055ade59584cff667c79f64937e6ef3f9/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_invariants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41e0363055ade59584cff667c79f64937e6ef3f9/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_invariants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_invariants.rs?ref=41e0363055ade59584cff667c79f64937e6ef3f9", "patch": "@@ -0,0 +1,12 @@\n+// Invariant checking doesn't ICE in some cases with errors (issue #104249).\n+\n+#![feature(staged_api)] //~ ERROR module has missing stability attribute\n+\n+pub mod m {} //~ ERROR module has missing stability attribute\n+\n+pub mod m { //~ ERROR the name `m` is defined multiple times\n+    mod inner {}\n+    type Inner = u8;\n+}\n+\n+fn main() {}"}, {"sha": "fd205f4058ae0514c660236cb8ac1164cc4ee99a", "filename": "src/test/ui/privacy/effective_visibilities_invariants.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/41e0363055ade59584cff667c79f64937e6ef3f9/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_invariants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/41e0363055ade59584cff667c79f64937e6ef3f9/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_invariants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Feffective_visibilities_invariants.stderr?ref=41e0363055ade59584cff667c79f64937e6ef3f9", "patch": "@@ -0,0 +1,32 @@\n+error[E0428]: the name `m` is defined multiple times\n+  --> $DIR/effective_visibilities_invariants.rs:7:1\n+   |\n+LL | pub mod m {}\n+   | --------- previous definition of the module `m` here\n+LL |\n+LL | pub mod m {\n+   | ^^^^^^^^^ `m` redefined here\n+   |\n+   = note: `m` must be defined only once in the type namespace of this module\n+\n+error: module has missing stability attribute\n+  --> $DIR/effective_visibilities_invariants.rs:3:1\n+   |\n+LL | / #![feature(staged_api)]\n+LL | |\n+LL | | pub mod m {}\n+LL | |\n+...  |\n+LL | |\n+LL | | fn main() {}\n+   | |____________^\n+\n+error: module has missing stability attribute\n+  --> $DIR/effective_visibilities_invariants.rs:5:1\n+   |\n+LL | pub mod m {}\n+   | ^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0428`."}]}