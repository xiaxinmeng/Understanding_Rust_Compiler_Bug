{"sha": "bcbb4107a1a966ea8ad48d370f553dffde780392", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYmI0MTA3YTFhOTY2ZWE4YWQ0OGQzNzBmNTUzZGZmZGU3ODAzOTI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-01T21:49:29Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-09-20T17:08:01Z"}, "message": "rustc_metadata: side-step ty{en,de}code for everything but Ty.", "tree": {"sha": "3b0ba2891de86946e0fbe26b0840800dfe5ad860", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b0ba2891de86946e0fbe26b0840800dfe5ad860"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcbb4107a1a966ea8ad48d370f553dffde780392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcbb4107a1a966ea8ad48d370f553dffde780392", "html_url": "https://github.com/rust-lang/rust/commit/bcbb4107a1a966ea8ad48d370f553dffde780392", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcbb4107a1a966ea8ad48d370f553dffde780392/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0863012fb9b709aee34190d902f0fce5d34eef9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0863012fb9b709aee34190d902f0fce5d34eef9e", "html_url": "https://github.com/rust-lang/rust/commit/0863012fb9b709aee34190d902f0fce5d34eef9e"}], "stats": {"total": 479, "additions": 99, "deletions": 380}, "files": [{"sha": "d4dd8298db3e2e5f8285d5a89e0192784cbc587c", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=bcbb4107a1a966ea8ad48d370f553dffde780392", "patch": "@@ -668,7 +668,7 @@ pub enum IntVarValue {\n /// from `T:'a` annotations appearing in the type definition.  If\n /// this is `None`, then the default is inherited from the\n /// surrounding context. See RFC #599 for details.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n pub enum ObjectLifetimeDefault<'tcx> {\n     /// Require an explicit annotation. Occurs when multiple\n     /// `T:'a` constraints are found.\n@@ -681,7 +681,7 @@ pub enum ObjectLifetimeDefault<'tcx> {\n     Specific(&'tcx Region),\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct TypeParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n@@ -691,7 +691,7 @@ pub struct TypeParameterDef<'tcx> {\n     pub object_lifetime_default: ObjectLifetimeDefault<'tcx>,\n }\n \n-#[derive(Clone)]\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct RegionParameterDef<'tcx> {\n     pub name: Name,\n     pub def_id: DefId,\n@@ -719,7 +719,7 @@ impl<'tcx> RegionParameterDef<'tcx> {\n \n /// Information about the formal type/lifetime parameters associated\n /// with an item or method. Analogous to hir::Generics.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct Generics<'tcx> {\n     pub parent: Option<DefId>,\n     pub parent_regions: u32,\n@@ -786,7 +786,7 @@ impl<'a, 'gcx, 'tcx> GenericPredicates<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n@@ -910,7 +910,7 @@ impl<'a, 'gcx, 'tcx> Predicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>\n }\n@@ -967,11 +967,11 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct EquatePredicate<'tcx>(pub Ty<'tcx>, pub Ty<'tcx>); // `0 == 1`\n pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n \n-#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n pub type PolyRegionOutlivesPredicate<'tcx> = PolyOutlivesPredicate<&'tcx ty::Region,\n@@ -990,7 +990,7 @@ pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, &'tcx\n /// equality between arbitrary types. Processing an instance of Form\n /// #2 eventually yields one of these `ProjectionPredicate`\n /// instances to normalize the LHS.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ProjectionPredicate<'tcx> {\n     pub projection_ty: ProjectionTy<'tcx>,\n     pub ty: Ty<'tcx>,"}, {"sha": "0f2ff8a689fa32e887c8f6043277e167fee1ac6f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=bcbb4107a1a966ea8ad48d370f553dffde780392", "patch": "@@ -290,7 +290,7 @@ pub struct TraitObject<'tcx> {\n /// Note that a `TraitRef` introduces a level of region binding, to\n /// account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n /// U>` or higher-ranked object types.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct TraitRef<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n@@ -366,7 +366,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound regions, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g. `liberate_late_bound_regions`).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Binder<T>(pub T);\n \n impl<T> Binder<T> {\n@@ -414,7 +414,7 @@ impl fmt::Debug for TypeFlags {\n \n /// Represents the projection of an associated type. In explicit UFCS\n /// form this would be written `<T as Trait<..>>::N`.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ProjectionTy<'tcx> {\n     /// The trait reference `T as Trait<..>`.\n     pub trait_ref: ty::TraitRef<'tcx>,\n@@ -430,7 +430,7 @@ pub struct BareFnTy<'tcx> {\n     pub sig: PolyFnSig<'tcx>,\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct ClosureTy<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub abi: abi::Abi,\n@@ -443,7 +443,7 @@ pub struct ClosureTy<'tcx> {\n /// - `inputs` is the list of arguments and their modes.\n /// - `output` is the return type.\n /// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n-#[derive(Clone, PartialEq, Eq, Hash)]\n+#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct FnSig<'tcx> {\n     pub inputs: Vec<Ty<'tcx>>,\n     pub output: Ty<'tcx>,"}, {"sha": "6911d2174260db022fdf256a407e0ecd2412fcbb", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=bcbb4107a1a966ea8ad48d370f553dffde780392", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n-use serialize;\n+use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n \n use core::nonzero::NonZero;\n@@ -128,8 +128,40 @@ impl<'tcx> TypeFoldable<'tcx> for Kind<'tcx> {\n     }\n }\n \n+impl<'tcx> Encodable for Kind<'tcx> {\n+    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n+        e.emit_enum(\"Kind\", |e| {\n+            if let Some(ty) = self.as_type() {\n+                e.emit_enum_variant(\"Ty\", TYPE_TAG, 1, |e| {\n+                    e.emit_enum_variant_arg(0, |e| ty.encode(e))\n+                })\n+            } else if let Some(r) = self.as_region() {\n+                e.emit_enum_variant(\"Region\", REGION_TAG, 1, |e| {\n+                    e.emit_enum_variant_arg(0, |e| r.encode(e))\n+                })\n+            } else {\n+                bug!()\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx> Decodable for Kind<'tcx> {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Kind<'tcx>, D::Error> {\n+        d.read_enum(\"Kind\", |d| {\n+            d.read_enum_variant(&[\"Ty\", \"Region\"], |d, tag| {\n+                match tag {\n+                    TYPE_TAG => Ty::decode(d).map(Kind::from),\n+                    REGION_TAG => <&ty::Region>::decode(d).map(Kind::from),\n+                    _ => Err(d.error(\"invalid Kind tag\"))\n+                }\n+            })\n+        })\n+    }\n+}\n+\n /// A substitution mapping type/region parameters to new values.\n-#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+#[derive(Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct Substs<'tcx> {\n     params: Vec<Kind<'tcx>>\n }\n@@ -297,7 +329,6 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedEncodable for &'tcx Substs<'tcx> {}\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Substs<'tcx> {}\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "d3c04874a08eff1ac1ea41efea16f1a56765d19e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 33, "deletions": 32, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=bcbb4107a1a966ea8ad48d370f553dffde780392", "patch": "@@ -94,16 +94,6 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     pub fn cdata(&self) -> &'a cstore::CrateMetadata {\n         self.cdata.expect(\"missing CrateMetadata in DecodeContext\")\n     }\n-\n-    fn read_ty_encoded<F, R>(&mut self, op: F) -> R\n-        where F: for<'x> FnOnce(&mut TyDecoder<'x,'tcx>) -> R\n-    {\n-        let pos = self.opaque.position();\n-        let doc = rbml::Doc::at(self.opaque.data, pos);\n-        self.opaque.advance(doc.end - pos);\n-        op(&mut TyDecoder::with_doc(self.tcx(), self.cdata().cnum, doc,\n-                                    &mut |d| translate_def_id(self.cdata(), d)))\n-    }\n }\n \n macro_rules! decoder_methods {\n@@ -243,13 +233,19 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Ty<'tcx>, Self::Error> {\n-        Ok(self.read_ty_encoded(|d| d.parse_ty()))\n+        let pos = self.opaque.position();\n+        let doc = rbml::Doc::at(self.opaque.data, pos);\n+        self.opaque.advance(doc.end - pos);\n+        Ok(TyDecoder::with_doc(self.tcx(), self.cdata().cnum, doc,\n+                               &mut |d| translate_def_id(self.cdata(), d))\n+            .parse_ty())\n     }\n }\n \n impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n-        Ok(self.read_ty_encoded(|d| d.parse_substs()))\n+        let substs = Substs::decode(self)?;\n+        Ok(self.tcx().mk_substs(substs))\n     }\n }\n \n@@ -469,26 +465,25 @@ fn variant_disr_val(d: rbml::Doc) -> u64 {\n }\n \n fn doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd) -> Ty<'tcx> {\n-    let tp = reader::get_doc(doc, tag_items_data_item_type);\n-    TyDecoder::with_doc(tcx, cdata.cnum, tp,\n-                        &mut |did| translate_def_id(cdata, did))\n-        .parse_ty()\n+    maybe_doc_type(doc, tcx, cdata).expect(\"missing tag_items_data_item_type\")\n }\n \n fn maybe_doc_type<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n                             -> Option<Ty<'tcx>> {\n     reader::maybe_get_doc(doc, tag_items_data_item_type).map(|tp| {\n-        TyDecoder::with_doc(tcx, cdata.cnum, tp,\n-                            &mut |did| translate_def_id(cdata, did))\n-            .parse_ty()\n+        let mut dcx = tp.decoder();\n+        dcx.tcx = Some(tcx);\n+        dcx.cdata = Some(cdata);\n+        Decodable::decode(&mut dcx).unwrap()\n     })\n }\n \n fn doc_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n                            -> ty::TraitRef<'tcx> {\n-    TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                        &mut |did| translate_def_id(cdata, did))\n-        .parse_trait_ref()\n+    let mut dcx = doc.decoder();\n+    dcx.tcx = Some(tcx);\n+    dcx.cdata = Some(cdata);\n+    Decodable::decode(&mut dcx).unwrap()\n }\n \n fn item_trait_ref<'a, 'tcx>(doc: rbml::Doc, tcx: TyCtxt<'a, 'tcx, 'tcx>, cdata: Cmd)\n@@ -1628,10 +1623,10 @@ fn doc_generics<'a, 'tcx>(base_doc: rbml::Doc,\n                           cdata: Cmd)\n                           -> &'tcx ty::Generics<'tcx>\n {\n-    let doc = reader::get_doc(base_doc, tag_item_generics);\n-    TyDecoder::with_doc(tcx, cdata.cnum, doc,\n-                        &mut |did| translate_def_id(cdata, did))\n-        .parse_generics()\n+    let mut dcx = reader::get_doc(base_doc, tag_item_generics).decoder();\n+    dcx.tcx = Some(tcx);\n+    dcx.cdata = Some(cdata);\n+    tcx.alloc_generics(Decodable::decode(&mut dcx).unwrap())\n }\n \n fn doc_predicate<'a, 'tcx>(cdata: Cmd,\n@@ -1641,10 +1636,14 @@ fn doc_predicate<'a, 'tcx>(cdata: Cmd,\n {\n     let predicate_pos = cdata.xref_index.lookup(\n         cdata.data(), reader::doc_as_u32(doc)).unwrap() as usize;\n-    TyDecoder::new(\n-        cdata.data(), cdata.cnum, predicate_pos, tcx,\n-        &mut |did| translate_def_id(cdata, did)\n-    ).parse_predicate()\n+    let mut dcx = rbml::Doc {\n+        data: cdata.data(),\n+        start: predicate_pos,\n+        end: cdata.data().len(),\n+    }.decoder();\n+    dcx.tcx = Some(tcx);\n+    dcx.cdata = Some(cdata);\n+    Decodable::decode(&mut dcx).unwrap()\n }\n \n fn doc_predicates<'a, 'tcx>(base_doc: rbml::Doc,\n@@ -1694,8 +1693,10 @@ pub fn closure_ty<'a, 'tcx>(cdata: Cmd, closure_id: DefIndex, tcx: TyCtxt<'a, 't\n                             -> ty::ClosureTy<'tcx> {\n     let closure_doc = cdata.lookup_item(closure_id);\n     let closure_ty_doc = reader::get_doc(closure_doc, tag_items_closure_ty);\n-    TyDecoder::with_doc(tcx, cdata.cnum, closure_ty_doc, &mut |did| translate_def_id(cdata, did))\n-        .parse_closure_ty()\n+    let mut dcx = closure_ty_doc.decoder();\n+    dcx.tcx = Some(tcx);\n+    dcx.cdata = Some(cdata);\n+    Decodable::decode(&mut dcx).unwrap()\n }\n \n pub fn def_key(cdata: Cmd, id: DefIndex) -> hir_map::DefKey {"}, {"sha": "dcc3d13631ebae1429e305124f81266052c787a6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 34, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=bcbb4107a1a966ea8ad48d370f553dffde780392", "patch": "@@ -28,7 +28,6 @@ use middle::dependency_format::Linkage;\n use rustc::dep_graph::DepNode;\n use rustc::traits::specialization_graph;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::subst::Substs;\n \n use rustc::hir::svh::Svh;\n use rustc::mir::mir_map::MirMap;\n@@ -126,17 +125,6 @@ impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedEncoder<&'tcx Substs<'tcx>> for EncodeContext<'a, 'tcx> {\n-    fn specialized_encode(&mut self, substs: &&'tcx Substs<'tcx>) -> Result<(), Self::Error> {\n-        let cx = self.ty_str_ctxt();\n-\n-        self.start_tag(tag_opaque)?;\n-        tyencode::enc_substs(&mut self.rbml_w.opaque.cursor, &cx, substs);\n-        self.mark_stable_position();\n-        self.end_tag()\n-    }\n-}\n-\n fn encode_name(ecx: &mut EncodeContext, name: Name) {\n     ecx.wr_tagged_str(tag_paths_data_name, &name.as_str());\n }\n@@ -163,10 +151,8 @@ fn encode_def_id_and_key(ecx: &mut EncodeContext, def_id: DefId) {\n fn encode_trait_ref<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n                               trait_ref: ty::TraitRef<'tcx>,\n                               tag: usize) {\n-    let cx = ecx.ty_str_ctxt();\n     ecx.start_tag(tag);\n-    tyencode::enc_trait_ref(&mut ecx.opaque.cursor, &cx, trait_ref);\n-    ecx.mark_stable_position();\n+    trait_ref.encode(ecx).unwrap();\n     ecx.end_tag();\n }\n \n@@ -211,19 +197,10 @@ fn encode_variant_id(ecx: &mut EncodeContext, vid: DefId) {\n     ecx.wr_tagged_u64(tag_mod_child, id);\n }\n \n-fn write_closure_type<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n-                                closure_type: &ty::ClosureTy<'tcx>) {\n-    let cx = ecx.ty_str_ctxt();\n-    tyencode::enc_closure_ty(&mut ecx.opaque.cursor, &cx, closure_type);\n-    ecx.mark_stable_position();\n-}\n-\n impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n     fn encode_type(&mut self, typ: Ty<'tcx>) {\n-        let cx = self.ty_str_ctxt();\n         self.start_tag(tag_items_data_item_type);\n-        tyencode::enc_ty(&mut self.opaque.cursor, &cx, typ);\n-        self.mark_stable_position();\n+        typ.encode(self.ecx).unwrap();\n         self.end_tag();\n     }\n \n@@ -519,10 +496,8 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n                        generics: &ty::Generics<'tcx>,\n                        predicates: &ty::GenericPredicates<'tcx>)\n     {\n-        let cx = self.ty_str_ctxt();\n         self.start_tag(tag_item_generics);\n-        tyencode::enc_generics(&mut self.opaque.cursor, &cx, generics);\n-        self.mark_stable_position();\n+        generics.encode(self.ecx).unwrap();\n         self.end_tag();\n         self.encode_predicates(predicates, tag_item_predicates);\n     }\n@@ -859,7 +834,6 @@ fn encode_xrefs<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n                           xrefs: FnvHashMap<XRef<'tcx>, u32>)\n {\n     let mut xref_positions = vec![0; xrefs.len()];\n-    let cx = ecx.ty_str_ctxt();\n \n     // Encode XRefs sorted by their ID\n     let mut sorted_xrefs: Vec<_> = xrefs.into_iter().collect();\n@@ -869,9 +843,7 @@ fn encode_xrefs<'a, 'tcx>(ecx: &mut EncodeContext<'a, 'tcx>,\n     for (xref, id) in sorted_xrefs.into_iter() {\n         xref_positions[id as usize] = ecx.mark_stable_position() as u32;\n         match xref {\n-            XRef::Predicate(p) => {\n-                tyencode::enc_predicate(&mut ecx.opaque.cursor, &cx, &p)\n-            }\n+            XRef::Predicate(p) => p.encode(ecx).unwrap()\n         }\n     }\n     ecx.mark_stable_position();\n@@ -1396,8 +1368,7 @@ impl<'a, 'b, 'tcx> ItemContentBuilder<'a, 'b, 'tcx> {\n         encode_name(self, syntax::parse::token::intern(\"<closure>\"));\n \n         self.start_tag(tag_items_closure_ty);\n-        write_closure_type(self,\n-                           &tcx.tables.borrow().closure_tys[&def_id]);\n+        tcx.tables.borrow().closure_tys[&def_id].encode(self.ecx).unwrap();\n         self.end_tag();\n \n         self.start_tag(tag_items_closure_kind);"}, {"sha": "ccc4894fcdda27ae162e1be0ba97830579cf062e", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 6, "deletions": 158, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=bcbb4107a1a966ea8ad48d370f553dffde780392", "patch": "@@ -21,7 +21,7 @@ use rustc::hir;\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex};\n use middle::region;\n use rustc::ty::subst::{Kind, Substs};\n-use rustc::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rbml;\n use rustc_serialize::leb128;\n@@ -109,12 +109,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         value as usize\n     }\n \n-    fn parse_name(&mut self, last: char) -> ast::Name {\n-        fn is_last(b: char, c: char) -> bool { return c == b; }\n-        let bytes = self.scan(|a| is_last(last, a));\n-        token::intern(str::from_utf8(bytes).unwrap())\n-    }\n-\n     fn parse_size(&mut self) -> Option<usize> {\n         assert_eq!(self.next(), '/');\n \n@@ -128,7 +122,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {\n+    fn parse_substs(&mut self) -> &'tcx Substs<'tcx> {\n         let mut params = vec![];\n         assert_eq!(self.next(), '[');\n         while self.peek() != ']' {\n@@ -144,34 +138,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         Substs::new(self.tcx, params)\n     }\n \n-    pub fn parse_generics(&mut self) -> &'tcx ty::Generics<'tcx> {\n-        let parent = self.parse_opt(|this| this.parse_def());\n-        let parent_regions = self.parse_u32();\n-        assert_eq!(self.next(), '|');\n-        let parent_types = self.parse_u32();\n-\n-        let mut regions = vec![];\n-        let mut types = vec![];\n-        assert_eq!(self.next(), '[');\n-        while self.peek() != '|' {\n-            regions.push(self.parse_region_param_def());\n-        }\n-        assert_eq!(self.next(), '|');\n-        while self.peek() != ']' {\n-            types.push(self.parse_type_param_def());\n-        }\n-        assert_eq!(self.next(), ']');\n-\n-        self.tcx.alloc_generics(ty::Generics {\n-            parent: parent,\n-            parent_regions: parent_regions,\n-            parent_types: parent_types,\n-            regions: regions,\n-            types: types,\n-            has_self: self.next() == 'S'\n-        })\n-    }\n-\n     fn parse_bound_region(&mut self) -> ty::BoundRegion {\n         match self.next() {\n             'a' => {\n@@ -207,7 +173,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    pub fn parse_region(&mut self) -> &'tcx ty::Region {\n+    fn parse_region(&mut self) -> &'tcx ty::Region {\n         self.tcx.mk_region(match self.next() {\n             'b' => {\n                 assert_eq!(self.next(), '[');\n@@ -300,16 +266,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         })\n     }\n \n-    fn parse_opt<T, F>(&mut self, f: F) -> Option<T>\n-        where F: FnOnce(&mut TyDecoder<'a, 'tcx>) -> T,\n-    {\n-        match self.next() {\n-            'n' => None,\n-            's' => Some(f(self)),\n-            _ => bug!(\"parse_opt: bad input\")\n-        }\n-    }\n-\n     fn parse_str(&mut self, term: char) -> String {\n         let mut result = String::new();\n         while self.peek() != term {\n@@ -321,14 +277,14 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         result\n     }\n \n-    pub fn parse_trait_ref(&mut self) -> ty::TraitRef<'tcx> {\n+    fn parse_trait_ref(&mut self) -> ty::TraitRef<'tcx> {\n         ty::TraitRef {\n             def_id: self.parse_def(),\n             substs: self.parse_substs()\n         }\n     }\n \n-    pub fn parse_existential_trait_ref(&mut self) -> ty::ExistentialTraitRef<'tcx> {\n+    fn parse_existential_trait_ref(&mut self) -> ty::ExistentialTraitRef<'tcx> {\n         ty::ExistentialTraitRef {\n             def_id: self.parse_def(),\n             substs: self.parse_substs()\n@@ -538,18 +494,7 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         abi::lookup(&abi_str[..]).expect(abi_str)\n     }\n \n-    pub fn parse_closure_ty(&mut self) -> ty::ClosureTy<'tcx> {\n-        let unsafety = parse_unsafety(self.next());\n-        let sig = self.parse_sig();\n-        let abi = self.parse_abi_set();\n-        ty::ClosureTy {\n-            unsafety: unsafety,\n-            sig: sig,\n-            abi: abi,\n-        }\n-    }\n-\n-    pub fn parse_bare_fn_ty(&mut self) -> &'tcx ty::BareFnTy<'tcx> {\n+    fn parse_bare_fn_ty(&mut self) -> &'tcx ty::BareFnTy<'tcx> {\n         let unsafety = parse_unsafety(self.next());\n         let abi = self.parse_abi_set();\n         let sig = self.parse_sig();\n@@ -578,48 +523,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                               variadic: variadic})\n     }\n \n-    pub fn parse_predicate(&mut self) -> ty::Predicate<'tcx> {\n-        match self.next() {\n-            't' => ty::Binder(self.parse_trait_ref()).to_predicate(),\n-            'e' => ty::Binder(ty::EquatePredicate(self.parse_ty(),\n-                                                  self.parse_ty())).to_predicate(),\n-            'r' => ty::Binder(ty::OutlivesPredicate(self.parse_region(),\n-                                                    self.parse_region())).to_predicate(),\n-            'o' => ty::Binder(ty::OutlivesPredicate(self.parse_ty(),\n-                                                    self.parse_region())).to_predicate(),\n-            'p' => ty::Binder(self.parse_projection_predicate()).to_predicate(),\n-            'w' => ty::Predicate::WellFormed(self.parse_ty()),\n-            'O' => {\n-                let def_id = self.parse_def();\n-                assert_eq!(self.next(), '|');\n-                ty::Predicate::ObjectSafe(def_id)\n-            }\n-            'c' => {\n-                let def_id = self.parse_def();\n-                assert_eq!(self.next(), '|');\n-                let kind = match self.next() {\n-                    'f' => ty::ClosureKind::Fn,\n-                    'm' => ty::ClosureKind::FnMut,\n-                    'o' => ty::ClosureKind::FnOnce,\n-                    c => bug!(\"Encountered invalid character in metadata: {}\", c)\n-                };\n-                assert_eq!(self.next(), '|');\n-                ty::Predicate::ClosureKind(def_id, kind)\n-            }\n-            c => bug!(\"Encountered invalid character in metadata: {}\", c)\n-        }\n-    }\n-\n-    fn parse_projection_predicate(&mut self) -> ty::ProjectionPredicate<'tcx> {\n-        ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy {\n-                trait_ref: self.parse_trait_ref(),\n-                item_name: token::intern(&self.parse_str('|')),\n-            },\n-            ty: self.parse_ty(),\n-        }\n-    }\n-\n     fn parse_existential_projection(&mut self) -> ty::ExistentialProjection<'tcx> {\n         ty::ExistentialProjection {\n             trait_ref: self.parse_existential_trait_ref(),\n@@ -628,61 +531,6 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n         }\n     }\n \n-    fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n-        let name = self.parse_name(':');\n-        let def_id = self.parse_def();\n-        let index = self.parse_u32();\n-        assert_eq!(self.next(), '|');\n-        let default_def_id = self.parse_def();\n-        let default = self.parse_opt(|this| this.parse_ty());\n-        let object_lifetime_default = self.parse_object_lifetime_default();\n-\n-        ty::TypeParameterDef {\n-            name: name,\n-            def_id: def_id,\n-            index: index,\n-            default_def_id: default_def_id,\n-            default: default,\n-            object_lifetime_default: object_lifetime_default,\n-        }\n-    }\n-\n-    fn parse_region_param_def(&mut self) -> ty::RegionParameterDef<'tcx> {\n-        let name = self.parse_name(':');\n-        let def_id = self.parse_def();\n-        let index = self.parse_u32();\n-        assert_eq!(self.next(), '|');\n-        let mut bounds = vec![];\n-        loop {\n-            match self.next() {\n-                'R' => bounds.push(self.parse_region()),\n-                '.' => { break; }\n-                c => {\n-                    bug!(\"parse_region_param_def: bad bounds ('{}')\", c)\n-                }\n-            }\n-        }\n-        ty::RegionParameterDef {\n-            name: name,\n-            def_id: def_id,\n-            index: index,\n-            bounds: bounds,\n-        }\n-    }\n-\n-\n-    fn parse_object_lifetime_default(&mut self) -> ty::ObjectLifetimeDefault<'tcx> {\n-        match self.next() {\n-            'a' => ty::ObjectLifetimeDefault::Ambiguous,\n-            'b' => ty::ObjectLifetimeDefault::BaseDefault,\n-            's' => {\n-                let region = self.parse_region();\n-                ty::ObjectLifetimeDefault::Specific(region)\n-            }\n-            _ => bug!(\"parse_object_lifetime_default: bad input\")\n-        }\n-    }\n-\n     fn parse_builtin_bounds(&mut self) -> ty::BuiltinBounds {\n         let mut builtin_bounds = ty::BuiltinBounds::empty();\n         loop {"}, {"sha": "54b4dc933424e7eca4f2274f244849e9e3801823", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 7, "deletions": 139, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcbb4107a1a966ea8ad48d370f553dffde780392/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=bcbb4107a1a966ea8ad48d370f553dffde780392", "patch": "@@ -220,22 +220,8 @@ fn enc_mt<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T, F>(w: &mut Cursor<Vec<u8>>, t: Option<T>, enc_f: F) where\n-    F: FnOnce(&mut Cursor<Vec<u8>>, T),\n-{\n-    match t {\n-        None => {\n-            write!(w, \"n\");\n-        }\n-        Some(v) => {\n-            write!(w, \"s\");\n-            enc_f(w, v);\n-        }\n-    }\n-}\n-\n-pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                            substs: &Substs<'tcx>) {\n+fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n+                        substs: &Substs<'tcx>) {\n     write!(w, \"[\");\n     for &k in substs.params() {\n         if let Some(ty) = k.as_type() {\n@@ -251,32 +237,7 @@ pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n     write!(w, \"]\");\n }\n \n-pub fn enc_generics<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                              generics: &ty::Generics<'tcx>) {\n-    enc_opt(w, generics.parent, |w, def_id| {\n-        write!(w, \"{}|\", (cx.ds)(cx.tcx, def_id));\n-    });\n-    write!(w, \"{}|{}[\",\n-           generics.parent_regions,\n-           generics.parent_types);\n-\n-    for r in &generics.regions {\n-        enc_region_param_def(w, cx, r)\n-    }\n-    write!(w, \"|\");\n-    for t in &generics.types {\n-        enc_type_param_def(w, cx, t);\n-    }\n-    write!(w, \"]\");\n-\n-    if generics.has_self {\n-        write!(w, \"S\");\n-    } else {\n-        write!(w, \"N\");\n-    }\n-}\n-\n-pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: &ty::Region) {\n+fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: &ty::Region) {\n     match *r {\n         ty::ReLateBound(id, br) => {\n             write!(w, \"b[{}|\", id.depth);\n@@ -355,8 +316,8 @@ fn enc_bound_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, br: ty::BoundRegion) {\n     }\n }\n \n-pub fn enc_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                               s: ty::TraitRef<'tcx>) {\n+fn enc_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n+                           s: ty::TraitRef<'tcx>) {\n     write!(w, \"{}|\", (cx.ds)(cx.tcx, s.def_id));\n     enc_substs(w, cx, s.substs);\n }\n@@ -380,20 +341,13 @@ fn enc_abi(w: &mut Cursor<Vec<u8>>, abi: Abi) {\n     write!(w, \"]\");\n }\n \n-pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                                ft: &ty::BareFnTy<'tcx>) {\n+fn enc_bare_fn_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n+                            ft: &ty::BareFnTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n     enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-pub fn enc_closure_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                                ft: &ty::ClosureTy<'tcx>) {\n-    enc_unsafety(w, ft.unsafety);\n-    enc_fn_sig(w, cx, &ft.sig);\n-    enc_abi(w, ft.abi);\n-}\n-\n fn enc_fn_sig<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                         fsig: &ty::PolyFnSig<'tcx>) {\n     write!(w, \"[\");\n@@ -422,92 +376,6 @@ fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBound\n     write!(w, \".\");\n }\n \n-fn enc_type_param_def<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n-                                v: &ty::TypeParameterDef<'tcx>) {\n-    write!(w, \"{}:{}|{}|{}|\",\n-           v.name, (cx.ds)(cx.tcx, v.def_id),\n-           v.index, (cx.ds)(cx.tcx, v.default_def_id));\n-    enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n-    enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n-}\n-\n-fn enc_region_param_def(w: &mut Cursor<Vec<u8>>, cx: &ctxt,\n-                        v: &ty::RegionParameterDef) {\n-    write!(w, \"{}:{}|{}|\",\n-           v.name, (cx.ds)(cx.tcx, v.def_id), v.index);\n-    for &r in &v.bounds {\n-        write!(w, \"R\");\n-        enc_region(w, cx, r);\n-    }\n-    write!(w, \".\");\n-}\n-\n-fn enc_object_lifetime_default<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n-                                         cx: &ctxt<'a, 'tcx>,\n-                                         default: ty::ObjectLifetimeDefault)\n-{\n-    match default {\n-        ty::ObjectLifetimeDefault::Ambiguous => {\n-            write!(w, \"a\");\n-        }\n-        ty::ObjectLifetimeDefault::BaseDefault => {\n-            write!(w, \"b\");\n-        }\n-        ty::ObjectLifetimeDefault::Specific(r) => {\n-            write!(w, \"s\");\n-            enc_region(w, cx, r);\n-        }\n-    }\n-}\n-\n-pub fn enc_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n-                               cx: &ctxt<'a, 'tcx>,\n-                               p: &ty::Predicate<'tcx>)\n-{\n-    match *p {\n-        ty::Predicate::Trait(ref trait_ref) => {\n-            write!(w, \"t\");\n-            enc_trait_ref(w, cx, trait_ref.0.trait_ref);\n-        }\n-        ty::Predicate::Equate(ty::Binder(ty::EquatePredicate(a, b))) => {\n-            write!(w, \"e\");\n-            enc_ty(w, cx, a);\n-            enc_ty(w, cx, b);\n-        }\n-        ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(a, b))) => {\n-            write!(w, \"r\");\n-            enc_region(w, cx, a);\n-            enc_region(w, cx, b);\n-        }\n-        ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(a, b))) => {\n-            write!(w, \"o\");\n-            enc_ty(w, cx, a);\n-            enc_region(w, cx, b);\n-        }\n-        ty::Predicate::Projection(ty::Binder(ref data)) => {\n-            write!(w, \"p\");\n-            enc_trait_ref(w, cx, data.projection_ty.trait_ref);\n-            write!(w, \"{}|\", data.projection_ty.item_name);\n-            enc_ty(w, cx, data.ty);\n-        }\n-        ty::Predicate::WellFormed(data) => {\n-            write!(w, \"w\");\n-            enc_ty(w, cx, data);\n-        }\n-        ty::Predicate::ObjectSafe(trait_def_id) => {\n-            write!(w, \"O{}|\", (cx.ds)(cx.tcx, trait_def_id));\n-        }\n-        ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-            let kind_char = match kind {\n-                ty::ClosureKind::Fn => 'f',\n-                ty::ClosureKind::FnMut => 'm',\n-                ty::ClosureKind::FnOnce => 'o',\n-            };\n-            write!(w, \"c{}|{}|\", (cx.ds)(cx.tcx, closure_def_id), kind_char);\n-        }\n-    }\n-}\n-\n fn enc_existential_projection<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n                                         cx: &ctxt<'a, 'tcx>,\n                                         data: &ty::ExistentialProjection<'tcx>) {"}]}