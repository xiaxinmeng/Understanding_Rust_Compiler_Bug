{"sha": "53616f63b13935df6c761a449bfa940d3146ef47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNjE2ZjYzYjEzOTM1ZGY2Yzc2MWE0NDliZmE5NDBkMzE0NmVmNDc=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-05T07:39:45Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2017-12-05T07:39:45Z"}, "message": "Keep blank lines around comments with range", "tree": {"sha": "86f03f0d20b1f1653b6bf4c9589babeb93567e94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86f03f0d20b1f1653b6bf4c9589babeb93567e94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53616f63b13935df6c761a449bfa940d3146ef47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53616f63b13935df6c761a449bfa940d3146ef47", "html_url": "https://github.com/rust-lang/rust/commit/53616f63b13935df6c761a449bfa940d3146ef47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53616f63b13935df6c761a449bfa940d3146ef47/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "829d94940ebb07a49f5d841d2adc66947678ed5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/829d94940ebb07a49f5d841d2adc66947678ed5c", "html_url": "https://github.com/rust-lang/rust/commit/829d94940ebb07a49f5d841d2adc66947678ed5c"}], "stats": {"total": 92, "additions": 51, "deletions": 41}, "files": [{"sha": "b25f15b48805512c9ef76e64bb4486883deb2434", "filename": "src/missed_spans.rs", "status": "modified", "additions": 51, "deletions": 41, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/53616f63b13935df6c761a449bfa940d3146ef47/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53616f63b13935df6c761a449bfa940d3146ef47/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=53616f63b13935df6c761a449bfa940d3146ef47", "patch": "@@ -250,54 +250,64 @@ impl<'a> FmtVisitor<'a> {\n                 }\n             }\n \n-            // cur_line += newline_count;\n-            // rewirte_next_comment = true;\n-\n-            for (mut i, c) in subslice.char_indices() {\n-                i += offset;\n-\n-                if c == '\\n' {\n-                    if !self.config\n-                        .file_lines()\n-                        .contains_line(file_name, status.cur_line)\n-                    {\n+            let newline_count = count_newlines(&subslice);\n+            if subslice.trim().is_empty() && newline_count > 0\n+                && self.config.file_lines().intersects_range(\n+                    file_name,\n+                    status.cur_line,\n+                    status.cur_line + newline_count,\n+                ) {\n+                self.push_vertical_spaces(newline_count);\n+                status.cur_line += newline_count;\n+                status.rewrite_next_comment = true;\n+                status.line_start = offset + newline_count;\n+            } else {\n+                for (mut i, c) in subslice.char_indices() {\n+                    i += offset;\n+\n+                    if c == '\\n' {\n+                        if !self.config\n+                            .file_lines()\n+                            .contains_line(file_name, status.cur_line)\n+                        {\n+                            status.last_wspace = None;\n+                        }\n+\n+                        if let Some(lw) = status.last_wspace {\n+                            self.buffer.push_str(&snippet[status.line_start..lw]);\n+                            self.buffer.push_str(\"\\n\");\n+                        } else {\n+                            self.buffer.push_str(&snippet[status.line_start..i + 1]);\n+                        }\n+\n+                        status.cur_line += 1;\n+                        status.line_start = i + 1;\n+                        status.last_wspace = None;\n+                        status.rewrite_next_comment = true;\n+                    } else if c.is_whitespace() {\n+                        if status.last_wspace.is_none() {\n+                            status.last_wspace = Some(i);\n+                        }\n+                    } else if c == ';' {\n+                        if status.last_wspace.is_some() {\n+                            status.line_start = i;\n+                        }\n+\n+                        status.rewrite_next_comment = true;\n                         status.last_wspace = None;\n-                    }\n-\n-                    if let Some(lw) = status.last_wspace {\n-                        self.buffer.push_str(&snippet[status.line_start..lw]);\n-                        self.buffer.push_str(\"\\n\");\n                     } else {\n-                        self.buffer.push_str(&snippet[status.line_start..i + 1]);\n-                    }\n-\n-                    status.cur_line += 1;\n-                    status.line_start = i + 1;\n-                    status.last_wspace = None;\n-                    status.rewrite_next_comment = true;\n-                } else if c.is_whitespace() {\n-                    if status.last_wspace.is_none() {\n-                        status.last_wspace = Some(i);\n-                    }\n-                } else if c == ';' {\n-                    if status.last_wspace.is_some() {\n-                        status.line_start = i;\n+                        status.rewrite_next_comment = true;\n+                        status.last_wspace = None;\n                     }\n+                }\n \n+                let remaining = snippet[status.line_start..subslice.len() + offset].trim();\n+                if !remaining.is_empty() {\n+                    self.buffer.push_str(remaining);\n+                    status.line_start = subslice.len() + offset;\n                     status.rewrite_next_comment = true;\n-                    status.last_wspace = None;\n-                } else {\n-                    status.rewrite_next_comment = true;\n-                    status.last_wspace = None;\n                 }\n             }\n-\n-            let remaining = snippet[status.line_start..subslice.len() + offset].trim();\n-            if !remaining.is_empty() {\n-                self.buffer.push_str(remaining);\n-                status.line_start = subslice.len() + offset;\n-                status.rewrite_next_comment = true;\n-            }\n         }\n \n         process_last_snippet(self, &snippet[status.line_start..], snippet);"}]}