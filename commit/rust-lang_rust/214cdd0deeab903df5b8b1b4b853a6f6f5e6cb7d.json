{"sha": "214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxNGNkZDBkZWVhYjkwM2RmNWI4YjFiNGI4NTNhNmY2ZjVlNmNiN2Q=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-14T00:06:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-14T19:24:09Z"}, "message": "rustc: Translate crust functions", "tree": {"sha": "b25007bdf44f0be3360d8b5d8feac831521bad6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b25007bdf44f0be3360d8b5d8feac831521bad6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d", "html_url": "https://github.com/rust-lang/rust/commit/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78034aa22aaca8d2e416752059a2d8e2a0d30768", "url": "https://api.github.com/repos/rust-lang/rust/commits/78034aa22aaca8d2e416752059a2d8e2a0d30768", "html_url": "https://github.com/rust-lang/rust/commit/78034aa22aaca8d2e416752059a2d8e2a0d30768"}], "stats": {"total": 401, "additions": 315, "deletions": 86}, "files": [{"sha": "7e86191caf6ada47fc5dddb049168d9832134565", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d", "patch": "@@ -28,6 +28,7 @@ type upcalls =\n      dynastack_free: ValueRef,\n      alloc_c_stack: ValueRef,\n      call_shim_on_c_stack: ValueRef,\n+     call_shim_on_rust_stack: ValueRef,\n      rust_personality: ValueRef,\n      reset_stack_limit: ValueRef};\n \n@@ -106,6 +107,9 @@ fn declare_upcalls(targ_cfg: @session::config,\n                 // arguments: void *args, void *fn_ptr\n                 [T_ptr(T_i8()), T_ptr(T_i8())],\n                 int_t),\n+          call_shim_on_rust_stack:\n+              d(\"call_shim_on_rust_stack\",\n+                [T_ptr(T_i8()), T_ptr(T_i8())], int_t),\n           rust_personality:\n               d(\"rust_personality\", [], T_i32()),\n           reset_stack_limit:"}, {"sha": "f5f924b5691381c4d311582154660be6ecd2056b", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d", "patch": "@@ -4193,14 +4193,17 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n // Ties up the llstaticallocas -> llloadenv -> llderivedtydescs ->\n // lldynamicallocas -> lltop edges, and builds the return block.\n fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n+    tie_up_header_blocks(fcx, lltop);\n+    let ret_cx = new_raw_block_ctxt(fcx, fcx.llreturn);\n+    trans_fn_cleanups(fcx, ret_cx);\n+    RetVoid(ret_cx);\n+}\n+\n+fn tie_up_header_blocks(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n     Br(new_raw_block_ctxt(fcx, fcx.llstaticallocas), fcx.llloadenv);\n     Br(new_raw_block_ctxt(fcx, fcx.llloadenv), fcx.llderivedtydescs_first);\n     Br(new_raw_block_ctxt(fcx, fcx.llderivedtydescs), fcx.lldynamicallocas);\n     Br(new_raw_block_ctxt(fcx, fcx.lldynamicallocas), lltop);\n-\n-    let ret_cx = new_raw_block_ctxt(fcx, fcx.llreturn);\n-    trans_fn_cleanups(fcx, ret_cx);\n-    RetVoid(ret_cx);\n }\n \n enum self_arg { impl_self(ty::t), no_self, }\n@@ -4552,13 +4555,20 @@ fn param_bounds(ccx: @crate_ctxt, tp: ast::ty_param) -> ty::param_bounds {\n     ccx.tcx.ty_param_bounds.get(tp.id)\n }\n \n-fn register_fn_full(ccx: @crate_ctxt, sp: span, path: path, _flav: str,\n+fn register_fn_full(ccx: @crate_ctxt, sp: span, path: path, flav: str,\n                     tps: [ast::ty_param], node_id: ast::node_id,\n                     node_type: ty::t) {\n     let llfty = type_of_fn_from_ty(ccx, node_type,\n                                    vec::map(tps, {|p| param_bounds(ccx, p)}));\n+    register_fn_fuller(ccx, sp, path, flav, node_id, node_type,\n+                       lib::llvm::CCallConv, llfty);\n+}\n+\n+fn register_fn_fuller(ccx: @crate_ctxt, sp: span, path: path, _flav: str,\n+                      node_id: ast::node_id, node_type: ty::t,\n+                      cc: lib::llvm::CallConv, llfty: TypeRef) {\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n-    let llfn: ValueRef = decl_cdecl_fn(ccx.llmod, ps, llfty);\n+    let llfn: ValueRef = decl_fn(ccx.llmod, ps, cc, llfty);\n     ccx.item_ids.insert(node_id, llfn);\n     ccx.item_symbols.insert(node_id, ps);\n \n@@ -4747,9 +4757,13 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option<ast::native_abi>,\n           either::right(abi_) { *abi = option::some(abi_); }\n         }\n       }\n-      ast::item_fn(_, tps, _) {\n-        register_fn(ccx, i.span, my_path, \"fn\", tps,\n-                    i.id);\n+      ast::item_fn(decl, tps, _) {\n+        if decl.purity != ast::crust_fn {\n+            register_fn(ccx, i.span, my_path, \"fn\", tps,\n+                        i.id);\n+        } else {\n+            native::register_crust_fn(ccx, i.span, my_path, i.id);\n+        }\n       }\n       ast::item_impl(tps, _, _, methods) {\n         let path = my_path + [path_name(int::str(i.id))];"}, {"sha": "3830c36387960b7e2e25ca7df48d2ba8a73b750a", "filename": "src/comp/middle/trans/native.rs", "status": "modified", "additions": 240, "deletions": 75, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fnative.rs?ref=214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d", "patch": "@@ -1,13 +1,15 @@\n import driver::session::session;\n+import syntax::codemap::span;\n import ctypes::c_uint;\n import front::attr;\n import lib::llvm::{ llvm, TypeRef, ValueRef };\n import syntax::ast;\n+import back::link;\n import common::*;\n import build::*;\n import base::*;\n \n-export link_name, trans_native_mod, trans_crust_fn;\n+export link_name, trans_native_mod, register_crust_fn, trans_crust_fn;\n \n fn link_name(i: @ast::native_item) -> str {\n     alt attr::get_meta_item_value_str_by_name(i.attrs, \"link_name\") {\n@@ -20,34 +22,110 @@ type c_stack_tys = {\n     arg_tys: [TypeRef],\n     ret_ty: TypeRef,\n     ret_def: bool,\n-    base_fn_ty: TypeRef,\n     bundle_ty: TypeRef,\n     shim_fn_ty: TypeRef\n };\n \n-fn c_stack_tys(ccx: @crate_ctxt,\n-               id: ast::node_id) -> @c_stack_tys {\n+fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n+                       id: ast::node_id) -> ([TypeRef], TypeRef, ty::t) {\n     alt ty::get(ty::node_id_to_type(ccx.tcx, id)).struct {\n       ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n         let llargtys = type_of_explicit_args(ccx, arg_tys);\n         let llretty = type_of(ccx, ret_ty);\n-        let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n-        ret @{\n-            arg_tys: llargtys,\n-            ret_ty: llretty,\n-            ret_def: !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty),\n-            base_fn_ty: T_fn(llargtys, llretty),\n-            bundle_ty: bundle_ty,\n-            shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void())\n-        };\n+        (llargtys, llretty, ret_ty)\n       }\n       _ {\n           // Precondition?\n-          ccx.tcx.sess.bug(\"c_stack_tys called on non-function type\");\n+          ccx.tcx.sess.bug(\"c_arg_and_ret_lltys called on non-function type\");\n       }\n     }\n }\n \n+fn c_stack_tys(ccx: @crate_ctxt,\n+               id: ast::node_id) -> @c_stack_tys {\n+    let (llargtys, llretty, ret_ty) = c_arg_and_ret_lltys(ccx, id);\n+    let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n+    ret @{\n+        arg_tys: llargtys,\n+        ret_ty: llretty,\n+        ret_def: !ty::type_is_bot(ret_ty) && !ty::type_is_nil(ret_ty),\n+        bundle_ty: bundle_ty,\n+        shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void())\n+    };\n+}\n+\n+type shim_arg_builder = fn(bcx: @block_ctxt, tys: @c_stack_tys,\n+                           llargbundle: ValueRef) -> [ValueRef];\n+\n+type shim_ret_builder = fn(bcx: @block_ctxt, tys: @c_stack_tys,\n+                           llargbundle: ValueRef, llretval: ValueRef);\n+\n+fn build_shim_fn_(ccx: @crate_ctxt,\n+                  shim_name: str,\n+                  llbasefn: ValueRef,\n+                  tys: @c_stack_tys,\n+                  cc: lib::llvm::CallConv,\n+                  arg_builder: shim_arg_builder,\n+                  ret_builder: shim_ret_builder) -> ValueRef {\n+\n+    let llshimfn = decl_internal_cdecl_fn(\n+        ccx.llmod, shim_name, tys.shim_fn_ty);\n+\n+    // Declare the body of the shim function:\n+    let fcx = new_fn_ctxt(ccx, [], llshimfn, none);\n+    let bcx = new_top_block_ctxt(fcx, none);\n+    let lltop = bcx.llbb;\n+    let llargbundle = llvm::LLVMGetParam(llshimfn, 0 as c_uint);\n+    let llargvals = arg_builder(bcx, tys, llargbundle);\n+\n+    // Create the call itself and store the return value:\n+    let llretval = CallWithConv(bcx, llbasefn,\n+                                llargvals, cc); // r\n+\n+    ret_builder(bcx, tys, llargbundle, llretval);\n+\n+    build_return(bcx);\n+    finish_fn(fcx, lltop);\n+\n+    ret llshimfn;\n+}\n+\n+type wrap_arg_builder = fn(bcx: @block_ctxt, tys: @c_stack_tys,\n+                           llwrapfn: ValueRef,\n+                           llargbundle: ValueRef);\n+\n+type wrap_ret_builder = fn(bcx: @block_ctxt, tys: @c_stack_tys,\n+                           llargbundle: ValueRef);\n+\n+fn build_wrap_fn_(ccx: @crate_ctxt,\n+                  tys: @c_stack_tys,\n+                  llshimfn: ValueRef,\n+                  llwrapfn: ValueRef,\n+                  shim_upcall: ValueRef,\n+                  arg_builder: wrap_arg_builder,\n+                  ret_builder: wrap_ret_builder) {\n+\n+    let fcx = new_fn_ctxt(ccx, [], llwrapfn, none);\n+    let bcx = new_top_block_ctxt(fcx, none);\n+    let lltop = bcx.llbb;\n+\n+    // Allocate the struct and write the arguments into it.\n+    let llargbundle = alloca(bcx, tys.bundle_ty);\n+    arg_builder(bcx, tys, llwrapfn, llargbundle);\n+\n+    // Create call itself.\n+    let llshimfnptr = PointerCast(bcx, llshimfn, T_ptr(T_i8()));\n+    let llrawargbundle = PointerCast(bcx, llargbundle, T_ptr(T_i8()));\n+    Call(bcx, shim_upcall, [llrawargbundle, llshimfnptr]);\n+    ret_builder(bcx, tys, llargbundle);\n+\n+    tie_up_header_blocks(fcx, lltop);\n+\n+    // Make sure our standard return block (that we didn't use) is terminated\n+    let ret_cx = new_raw_block_ctxt(fcx, fcx.llreturn);\n+    Unreachable(ret_cx);\n+}\n+\n // For each native function F, we generate a wrapper function W and a shim\n // function S that all work together.  The wrapper function W is the function\n // that other rust code actually invokes.  Its job is to marshall the\n@@ -89,77 +167,74 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                      native_item: @ast::native_item,\n                      tys: @c_stack_tys,\n                      cc: lib::llvm::CallConv) -> ValueRef {\n-        let lname = link_name(native_item);\n-\n-        // Declare the \"prototype\" for the base function F:\n-        let llbasefn = decl_fn(ccx.llmod, lname, cc, tys.base_fn_ty);\n \n-        // Create the shim function:\n-        let shim_name = lname + \"__c_stack_shim\";\n-        let llshimfn = decl_internal_cdecl_fn(\n-            ccx.llmod, shim_name, tys.shim_fn_ty);\n-\n-        // Declare the body of the shim function:\n-        let fcx = new_fn_ctxt(ccx, [], llshimfn, none);\n-        let bcx = new_top_block_ctxt(fcx, none);\n-        let lltop = bcx.llbb;\n-        let llargbundle = llvm::LLVMGetParam(llshimfn, 0 as c_uint);\n-        let i = 0u, n = vec::len(tys.arg_tys);\n-        let llargvals = [];\n-        while i < n {\n-            let llargval = load_inbounds(bcx, llargbundle, [0, i as int]);\n-            llargvals += [llargval];\n-            i += 1u;\n+        fn build_args(bcx: @block_ctxt, tys: @c_stack_tys,\n+                      llargbundle: ValueRef) -> [ValueRef] {\n+            let llargvals = [];\n+            let i = 0u;\n+            let n = vec::len(tys.arg_tys);\n+            while i < n {\n+                let llargval = load_inbounds(bcx, llargbundle, [0, i as int]);\n+                llargvals += [llargval];\n+                i += 1u;\n+            }\n+            ret llargvals;\n         }\n \n-        // Create the call itself and store the return value:\n-        let llretval = CallWithConv(bcx, llbasefn,\n-                                    llargvals, cc); // r\n-        if tys.ret_def {\n-            // R** llretptr = &args->r;\n-            let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n-            // R* llretloc = *llretptr; /* (args->r) */\n-            let llretloc = Load(bcx, llretptr);\n-            // *args->r = r;\n-            Store(bcx, llretval, llretloc);\n+        fn build_ret(bcx: @block_ctxt, tys: @c_stack_tys,\n+                     llargbundle: ValueRef, llretval: ValueRef)  {\n+            if tys.ret_def {\n+                let n = vec::len(tys.arg_tys);\n+                // R** llretptr = &args->r;\n+                let llretptr = GEPi(bcx, llargbundle, [0, n as int]);\n+                // R* llretloc = *llretptr; /* (args->r) */\n+                let llretloc = Load(bcx, llretptr);\n+                // *args->r = r;\n+                Store(bcx, llretval, llretloc);\n+            }\n         }\n \n-        // Finish up:\n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n-\n-        ret llshimfn;\n+        let lname = link_name(native_item);\n+        // Declare the \"prototype\" for the base function F:\n+        let llbasefnty = T_fn(tys.arg_tys, tys.ret_ty);\n+        let llbasefn = decl_fn(ccx.llmod, lname, cc, llbasefnty);\n+        // Name the shim function\n+        let shim_name = lname + \"__c_stack_shim\";\n+        ret build_shim_fn_(ccx, shim_name, llbasefn, tys, cc,\n+                           build_args, build_ret);\n     }\n \n     fn build_wrap_fn(ccx: @crate_ctxt,\n                      tys: @c_stack_tys,\n                      num_tps: uint,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n-        let fcx = new_fn_ctxt(ccx, [], llwrapfn, none);\n-        let bcx = new_top_block_ctxt(fcx, none);\n-        let lltop = bcx.llbb;\n-\n-        // Allocate the struct and write the arguments into it.\n-        let llargbundle = alloca(bcx, tys.bundle_ty);\n-        let i = 0u, n = vec::len(tys.arg_tys);\n-        let implicit_args = 2u + num_tps; // ret + env\n-        while i < n {\n-            let llargval = llvm::LLVMGetParam(llwrapfn,\n-                                              (i + implicit_args) as c_uint);\n-            store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n-            i += 1u;\n+\n+        fn build_args(bcx: @block_ctxt, tys: @c_stack_tys,\n+                      llwrapfn: ValueRef, llargbundle: ValueRef,\n+                      num_tps: uint) {\n+            let i = 0u, n = vec::len(tys.arg_tys);\n+            let implicit_args = 2u + num_tps; // ret + env\n+            while i < n {\n+                let llargval = llvm::LLVMGetParam(\n+                    llwrapfn,\n+                    (i + implicit_args) as c_uint);\n+                store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n+                i += 1u;\n+            }\n+            let llretptr = llvm::LLVMGetParam(llwrapfn, 0 as c_uint);\n+            store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n+        }\n+\n+        fn build_ret(bcx: @block_ctxt, _tys: @c_stack_tys,\n+                     _llargbundle: ValueRef) {\n+            RetVoid(bcx);\n         }\n-        let llretptr = llvm::LLVMGetParam(llwrapfn, 0 as c_uint);\n-        store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n-\n-        // Create call itself.\n-        let call_shim_on_c_stack = ccx.upcalls.call_shim_on_c_stack;\n-        let llshimfnptr = PointerCast(bcx, llshimfn, T_ptr(T_i8()));\n-        let llrawargbundle = PointerCast(bcx, llargbundle, T_ptr(T_i8()));\n-        Call(bcx, call_shim_on_c_stack, [llrawargbundle, llshimfnptr]);\n-        build_return(bcx);\n-        finish_fn(fcx, lltop);\n+\n+        build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n+                       ccx.upcalls.call_shim_on_c_stack,\n+                       bind build_args(_, _ ,_ , _, num_tps),\n+                       build_ret);\n     }\n \n     let cc = lib::llvm::CCallConv;\n@@ -180,7 +255,7 @@ fn trans_native_mod(ccx: @crate_ctxt,\n               build_wrap_fn(ccx, tys, vec::len(tps), llshimfn, llwrapfn);\n             }\n             none {\n-              ccx.sess.span_fatal(\n+              ccx.sess.span_bug(\n                   native_item.span,\n                   \"unbound function item in trans_native_mod\");\n             }\n@@ -191,6 +266,96 @@ fn trans_native_mod(ccx: @crate_ctxt,\n }\n \n fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n-                  body: ast::blk, llfndecl: ValueRef, id: ast::node_id) {\n-    trans_fn(ccx, path, decl, body, llfndecl, no_self, [], none, id)\n+                  body: ast::blk, llwrapfn: ValueRef, id: ast::node_id) {\n+\n+    fn build_rust_fn(ccx: @crate_ctxt, path: ast_map::path,\n+                     decl: ast::fn_decl, body: ast::blk,\n+                     id: ast::node_id) -> ValueRef {\n+        let t = ty::node_id_to_type(ccx.tcx, id);\n+        let ps = link::mangle_internal_name_by_path(\n+            ccx, path + [ast_map::path_name(\"__rust_abi\")]);\n+        let llty = type_of_fn_from_ty(ccx, t, []);\n+        let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n+        trans_fn(ccx, path, decl, body, llfndecl, no_self, [], none, id);\n+        ret llfndecl;\n+    }\n+\n+    fn build_shim_fn(ccx: @crate_ctxt, path: ast_map::path,\n+                     llrustfn: ValueRef, tys: @c_stack_tys) -> ValueRef {\n+\n+        fn build_args(bcx: @block_ctxt, tys: @c_stack_tys,\n+                      llargbundle: ValueRef) -> [ValueRef] {\n+            let llargvals = [];\n+            let i = 0u;\n+            let n = vec::len(tys.arg_tys);\n+            let llretptr = load_inbounds(bcx, llargbundle, [0, n as int]);\n+            llargvals += [llretptr];\n+            let llenvptr = C_null(T_opaque_box_ptr(bcx_ccx(bcx)));\n+            llargvals += [llenvptr];\n+            while i < n {\n+                let llargval = load_inbounds(bcx, llargbundle, [0, i as int]);\n+                llargvals += [llargval];\n+                i += 1u;\n+            }\n+            ret llargvals;\n+        }\n+\n+        fn build_ret(_bcx: @block_ctxt, _tys: @c_stack_tys,\n+                     _llargbundle: ValueRef, _llretval: ValueRef)  {\n+            // Nop. The return pointer in the Rust ABI function\n+            // is wired directly into the return slot in the shim struct\n+        }\n+\n+        let shim_name = link::mangle_internal_name_by_path(\n+            ccx, path + [ast_map::path_name(\"__rust_stack_shim\")]);\n+        ret build_shim_fn_(ccx, shim_name, llrustfn, tys,\n+                           lib::llvm::CCallConv,\n+                           build_args, build_ret);\n+    }\n+\n+    fn build_wrap_fn(ccx: @crate_ctxt, llshimfn: ValueRef,\n+                     llwrapfn: ValueRef, tys: @c_stack_tys) {\n+\n+        fn build_args(bcx: @block_ctxt, tys: @c_stack_tys,\n+                      llwrapfn: ValueRef, llargbundle: ValueRef) {\n+            let llretptr = alloca(bcx, tys.ret_ty);\n+            let i = 0u, n = vec::len(tys.arg_tys);\n+            while i < n {\n+                let llargval = llvm::LLVMGetParam(\n+                    llwrapfn, i as c_uint);\n+                store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n+                i += 1u;\n+            }\n+            store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n+        }\n+\n+        fn build_ret(bcx: @block_ctxt, tys: @c_stack_tys,\n+                     llargbundle: ValueRef) {\n+            let n = vec::len(tys.arg_tys);\n+            let llretval = load_inbounds(bcx, llargbundle, [0, n as int]);\n+            let llretval = Load(bcx, llretval);\n+            Ret(bcx, llretval);\n+        }\n+\n+        build_wrap_fn_(ccx, tys, llshimfn, llwrapfn,\n+                       ccx.upcalls.call_shim_on_rust_stack,\n+                       build_args, build_ret);\n+    }\n+\n+    let tys = c_stack_tys(ccx, id);\n+    // The internal Rust ABI function - runs on the Rust stack\n+    let llrustfn = build_rust_fn(ccx, path, decl, body, id);\n+    // The internal shim function - runs on the Rust stack\n+    let llshimfn = build_shim_fn(ccx, path, llrustfn, tys);\n+    // The external C function - runs on the C stack\n+    build_wrap_fn(ccx, llshimfn, llwrapfn, tys)\n+}\n+\n+fn register_crust_fn(ccx: @crate_ctxt, sp: span,\n+                     path: ast_map::path, node_id: ast::node_id) {\n+    let t = ty::node_id_to_type(ccx.tcx, node_id);\n+    let (llargtys, llretty, _) = c_arg_and_ret_lltys(ccx, node_id);\n+    let llfty = T_fn(llargtys, llretty);\n+    register_fn_fuller(ccx, sp, path, \"crust fn\", node_id,\n+                       t, lib::llvm::CCallConv, llfty);\n }\n\\ No newline at end of file"}, {"sha": "918630b18f6711d0500c59455acb85002fa73abb", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d", "patch": "@@ -657,8 +657,8 @@ rust_dbg_lock_signal(lock_and_signal *lock) {\n typedef void *(*dbg_callback)(void*);\n \n extern \"C\" CDECL void *\n-rust_dbg_call(dbg_callback *cb, void *data) {\n-    return (*cb)(data);\n+rust_dbg_call(dbg_callback cb, void *data) {\n+    return cb(data);\n }\n \n //"}, {"sha": "230117ee9fc62b8e614bf35c9e9f1ce374f996e7", "filename": "src/test/run-pass/crust-call-deep.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Ftest%2Frun-pass%2Fcrust-call-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Ftest%2Frun-pass%2Fcrust-call-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-call-deep.rs?ref=214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d", "patch": "@@ -0,0 +1,23 @@\n+native mod rustrt {\n+    fn rust_dbg_call(cb: *u8,\n+                     data: ctypes::uintptr_t) -> ctypes::uintptr_t;\n+}\n+\n+crust fn cb(data: ctypes::uintptr_t) -> ctypes::uintptr_t {\n+    if data == 1u {\n+        data\n+    } else {\n+        count(data - 1u) + 1u\n+    }\n+}\n+\n+fn count(n: uint) -> uint {\n+    #debug(\"n = %?\", n);\n+    rustrt::rust_dbg_call(cb, n)\n+}\n+\n+fn main() {\n+    let result = count(1000u);\n+    #debug(\"result = %?\", result);\n+    assert result == 1000u;\n+}\n\\ No newline at end of file"}, {"sha": "16ec9f3953c1534b7eb7e82822faffcc51c3f8e8", "filename": "src/test/run-pass/crust-call.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Ftest%2Frun-pass%2Fcrust-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d/src%2Ftest%2Frun-pass%2Fcrust-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcrust-call.rs?ref=214cdd0deeab903df5b8b1b4b853a6f6f5e6cb7d", "patch": "@@ -0,0 +1,23 @@\n+native mod rustrt {\n+    fn rust_dbg_call(cb: *u8,\n+                     data: ctypes::uintptr_t) -> ctypes::uintptr_t;\n+}\n+\n+crust fn cb(data: ctypes::uintptr_t) -> ctypes::uintptr_t {\n+    if data == 1u {\n+        data\n+    } else {\n+        fact(data - 1u) * data\n+    }\n+}\n+\n+fn fact(n: uint) -> uint {\n+    #debug(\"n = %?\", n);\n+    rustrt::rust_dbg_call(cb, n)\n+}\n+\n+fn main() {\n+    let result = fact(10u);\n+    #debug(\"result = %?\", result);\n+    assert result == 3628800u;\n+}\n\\ No newline at end of file"}]}