{"sha": "b7613f82814e803bf75c074ae4e50a584fee3e70", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NjEzZjgyODE0ZTgwM2JmNzVjMDc0YWU0ZTUwYTU4NGZlZTNlNzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-10T19:21:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-06-10T19:21:24Z"}, "message": "Auto merge of #42563 - eddyb:infer, r=nikomatsakis\n\nDisentangle InferCtxt, MemCategorizationContext and ExprUseVisitor.\n\nAt some point in the past, `InferCtxt` started being used to replace an old \"`Typer`\" abstraction, which provided access to `TypeckTables` and had optionally type inference to account for.\nThat didn't play so nicely with the `'gcx`/`'tcx` split and I had to introduce `borrowck_fake_infer_ctxt`.\nThe situation wasn't great but it wasn't too painful inside `rustc` itself.\n\nRecently I've found that method being used in clippy, which does need EUV (before we make it plausible to run lints on HAIR or MIR), and set out to separate inference from tables, for the sake of lint authors.\nAlso fixes #42435 to make it trivial to compute type layout or use EUV from lints.\n\nThe remaining uses of `TypeckTables` in `InferCtxt` are for closure kinds and signatures, used in trait selection and projection normalization. The solution there is likely to add them as bounds to `ParamEnv`.\n\nr? @nikomatsakis\ncc @mcarton @llogiq @Manishearth", "tree": {"sha": "33bd019446df904ca0d8a5b5aa20f48f75adc9c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33bd019446df904ca0d8a5b5aa20f48f75adc9c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7613f82814e803bf75c074ae4e50a584fee3e70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7613f82814e803bf75c074ae4e50a584fee3e70", "html_url": "https://github.com/rust-lang/rust/commit/b7613f82814e803bf75c074ae4e50a584fee3e70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7613f82814e803bf75c074ae4e50a584fee3e70/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "995f741a0e3a57d4142c0590b3266514fa0a0e29", "url": "https://api.github.com/repos/rust-lang/rust/commits/995f741a0e3a57d4142c0590b3266514fa0a0e29", "html_url": "https://github.com/rust-lang/rust/commit/995f741a0e3a57d4142c0590b3266514fa0a0e29"}, {"sha": "fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3", "html_url": "https://github.com/rust-lang/rust/commit/fc5c31c48cf19757ebf4b750efa34e7cb5f995e3"}], "stats": {"total": 1065, "additions": 440, "deletions": 625}, "files": [{"sha": "4bc0005d568a44151e3c8625d7c62fec1f1eaedf", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 30, "deletions": 208, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -19,11 +19,8 @@ pub use self::freshen::TypeFreshener;\n pub use self::region_inference::{GenericKind, VerifyBound};\n \n use hir::def_id::DefId;\n-use hir;\n use middle::free_region::{FreeRegionMap, RegionRelations};\n use middle::region::RegionMaps;\n-use middle::mem_categorization as mc;\n-use middle::mem_categorization::McResult;\n use middle::lang_items;\n use mir::tcx::LvalueTy;\n use ty::subst::{Kind, Subst, Substs};\n@@ -34,9 +31,8 @@ use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::RelateResult;\n use traits::{self, ObligationCause, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use std::cell::{Cell, RefCell, Ref, RefMut};\n+use std::cell::{Cell, RefCell, Ref};\n use std::fmt;\n-use std::ops::Deref;\n use syntax::ast;\n use errors::DiagnosticBuilder;\n use syntax_pos::{self, Span, DUMMY_SP};\n@@ -76,71 +72,14 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<T> = Result<T, FixupError>; // \"fixup result\"\n \n-/// A version of &ty::TypeckTables which can be `Missing` (not needed),\n-/// `InProgress` (during typeck) or `Interned` (result of typeck).\n-/// Only the `InProgress` version supports `borrow_mut`.\n-#[derive(Copy, Clone)]\n-pub enum InferTables<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    Interned(&'a ty::TypeckTables<'gcx>),\n-    InProgress(&'a RefCell<ty::TypeckTables<'tcx>>),\n-    Missing\n-}\n-\n-pub enum InferTablesRef<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    Interned(&'a ty::TypeckTables<'gcx>),\n-    InProgress(Ref<'a, ty::TypeckTables<'tcx>>)\n-}\n-\n-impl<'a, 'gcx, 'tcx> Deref for InferTablesRef<'a, 'gcx, 'tcx> {\n-    type Target = ty::TypeckTables<'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        match *self {\n-            InferTablesRef::Interned(tables) => tables,\n-            InferTablesRef::InProgress(ref tables) => tables\n-        }\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> InferTables<'a, 'gcx, 'tcx> {\n-    pub fn borrow(self) -> InferTablesRef<'a, 'gcx, 'tcx> {\n-        match self {\n-            InferTables::Interned(tables) => InferTablesRef::Interned(tables),\n-            InferTables::InProgress(tables) => InferTablesRef::InProgress(tables.borrow()),\n-            InferTables::Missing => {\n-                bug!(\"InferTables: infcx.tables.borrow() with no tables\")\n-            }\n-        }\n-    }\n-\n-    pub fn expect_interned(self) -> &'a ty::TypeckTables<'gcx> {\n-        match self {\n-            InferTables::Interned(tables) => tables,\n-            InferTables::InProgress(_) => {\n-                bug!(\"InferTables: infcx.tables.expect_interned() during type-checking\");\n-            }\n-            InferTables::Missing => {\n-                bug!(\"InferTables: infcx.tables.expect_interned() with no tables\")\n-            }\n-        }\n-    }\n-\n-    pub fn borrow_mut(self) -> RefMut<'a, ty::TypeckTables<'tcx>> {\n-        match self {\n-            InferTables::Interned(_) => {\n-                bug!(\"InferTables: infcx.tables.borrow_mut() outside of type-checking\");\n-            }\n-            InferTables::InProgress(tables) => tables.borrow_mut(),\n-            InferTables::Missing => {\n-                bug!(\"InferTables: infcx.tables.borrow_mut() with no tables\")\n-            }\n-        }\n-    }\n-}\n-\n pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n-    pub tables: InferTables<'a, 'gcx, 'tcx>,\n+    /// During type-checking/inference of a body, `in_progress_tables`\n+    /// contains a reference to the tables being built up, which are\n+    /// used for reading closure kinds/signatures as they are inferred,\n+    /// and for error reporting logic to read arbitrary node types.\n+    pub in_progress_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n \n     // Cache for projections. This cache is snapshotted along with the\n     // infcx.\n@@ -396,106 +335,45 @@ impl fmt::Display for FixupError {\n     }\n }\n \n-pub trait InferEnv<'a, 'tcx> {\n-    fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>);\n-}\n-\n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for () {\n-    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>) {\n-        (None, None)\n-    }\n-}\n-\n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for &'a ty::TypeckTables<'tcx> {\n-    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>) {\n-        (Some(self), None)\n-    }\n-}\n-\n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for ty::TypeckTables<'tcx> {\n-    fn to_parts(self, _: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>) {\n-        (None, Some(self))\n-    }\n-}\n-\n-impl<'a, 'tcx> InferEnv<'a, 'tcx> for hir::BodyId {\n-    fn to_parts(self, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                -> (Option<&'a ty::TypeckTables<'tcx>>,\n-                    Option<ty::TypeckTables<'tcx>>) {\n-        let def_id = tcx.hir.body_owner_def_id(self);\n-        (Some(tcx.typeck_tables_of(def_id)), None)\n-    }\n-}\n-\n-/// Helper type of a temporary returned by tcx.infer_ctxt(...).\n+/// Helper type of a temporary returned by tcx.infer_ctxt().\n /// Necessary because we can't write the following bound:\n /// F: for<'b, 'tcx> where 'gcx: 'tcx FnOnce(InferCtxt<'b, 'gcx, 'tcx>).\n pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     global_tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     arena: DroplessArena,\n     fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n-    tables: Option<&'a ty::TypeckTables<'gcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n-    pub fn infer_ctxt<E: InferEnv<'a, 'gcx>>(self, env: E) -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n-        let (tables, fresh_tables) = env.to_parts(self);\n+    pub fn infer_ctxt(self) -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         InferCtxtBuilder {\n             global_tcx: self,\n             arena: DroplessArena::new(),\n-            fresh_tables: fresh_tables.map(RefCell::new),\n-            tables: tables,\n-        }\n-    }\n-\n-    /// Fake InferCtxt with the global tcx. Used by pre-MIR borrowck\n-    /// for MemCategorizationContext/ExprUseVisitor.\n-    /// If any inference functionality is used, ICEs will occur.\n-    pub fn borrowck_fake_infer_ctxt(self, body: hir::BodyId)\n-                                    -> InferCtxt<'a, 'gcx, 'gcx> {\n-        let (tables, _) = body.to_parts(self);\n-        InferCtxt {\n-            tcx: self,\n-            tables: InferTables::Interned(tables.unwrap()),\n-            type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n-            int_unification_table: RefCell::new(UnificationTable::new()),\n-            float_unification_table: RefCell::new(UnificationTable::new()),\n-            region_vars: RegionVarBindings::new(self),\n-            selection_cache: traits::SelectionCache::new(),\n-            evaluation_cache: traits::EvaluationCache::new(),\n-            projection_cache: RefCell::new(traits::ProjectionCache::new()),\n-            reported_trait_errors: RefCell::new(FxHashSet()),\n-            tainted_by_errors_flag: Cell::new(false),\n-            err_count_on_creation: self.sess.err_count(),\n-            in_snapshot: Cell::new(false),\n+            fresh_tables: None,\n         }\n     }\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n+    /// Used only by `rustc_typeck` during body type-checking/inference,\n+    /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n+    pub fn with_fresh_in_progress_tables(mut self) -> Self {\n+        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty()));\n+        self\n+    }\n+\n     pub fn enter<F, R>(&'tcx mut self, f: F) -> R\n         where F: for<'b> FnOnce(InferCtxt<'b, 'gcx, 'tcx>) -> R\n     {\n         let InferCtxtBuilder {\n             global_tcx,\n             ref arena,\n             ref fresh_tables,\n-            tables,\n         } = *self;\n-        let tables = tables.map(InferTables::Interned).unwrap_or_else(|| {\n-            fresh_tables.as_ref().map_or(InferTables::Missing, InferTables::InProgress)\n-        });\n+        let in_progress_tables = fresh_tables.as_ref();\n         global_tcx.enter_local(arena, |tcx| f(InferCtxt {\n-            tcx: tcx,\n-            tables: tables,\n+            tcx,\n+            in_progress_tables,\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             type_variables: RefCell::new(type_variable::TypeVariableTable::new()),\n             int_unification_table: RefCell::new(UnificationTable::new()),\n@@ -618,7 +496,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(()).enter(|infcx| {\n+        self.infer_ctxt().enter(|infcx| {\n             value.trans_normalize(&infcx, param_env)\n         })\n     }\n@@ -640,7 +518,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(()).enter(|infcx| {\n+        self.infer_ctxt().enter(|infcx| {\n             value.trans_normalize(&infcx, env.reveal_all())\n        })\n     }\n@@ -844,10 +722,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             was_in_snapshot: in_snapshot,\n             // Borrow tables \"in progress\" (i.e. during typeck)\n             // to ban writes from within a snapshot to them.\n-            _in_progress_tables: match self.tables {\n-                InferTables::InProgress(ref tables) => tables.try_borrow().ok(),\n-                _ => None\n-            }\n+            _in_progress_tables: self.in_progress_tables.map(|tables| {\n+                tables.borrow()\n+            })\n         }\n     }\n \n@@ -1190,28 +1067,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tainted_by_errors_flag.set(true)\n     }\n \n-    pub fn node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        match self.tables.borrow().node_types.get(&id) {\n-            Some(&t) => t,\n-            // FIXME\n-            None if self.is_tainted_by_errors() =>\n-                self.tcx.types.err,\n-            None => {\n-                bug!(\"no type for node {}: {} in fcx\",\n-                     id, self.tcx.hir.node_to_string(id));\n-            }\n-        }\n-    }\n-\n-    pub fn expr_ty(&self, ex: &hir::Expr) -> Ty<'tcx> {\n-        match self.tables.borrow().node_types.get(&ex.id) {\n-            Some(&t) => t,\n-            None => {\n-                bug!(\"no type for expr in fcx\");\n-            }\n-        }\n-    }\n-\n     pub fn resolve_regions_and_report_errors(&self,\n                                              region_context: DefId,\n                                              region_map: &RegionMaps,\n@@ -1310,21 +1165,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut r)\n     }\n \n-    /// Resolves all type variables in `t` and then, if any were left\n-    /// unresolved, substitutes an error type. This is used after the\n-    /// main checking when doing a second pass before writeback. The\n-    /// justification is that writeback will produce an error for\n-    /// these unconstrained type variables.\n-    fn resolve_type_vars_or_error(&self, t: &Ty<'tcx>) -> mc::McResult<Ty<'tcx>> {\n-        let ty = self.resolve_type_vars_if_possible(t);\n-        if ty.references_error() || ty.is_ty_var() {\n-            debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n-            Err(())\n-        } else {\n-            Ok(ty)\n-        }\n-    }\n-\n     pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<T> {\n         /*!\n          * Attempts to resolve all type/region variables in\n@@ -1484,30 +1324,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.region_vars.verify_generic_bound(origin, kind, a, bound);\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        let ty = self.node_type(id);\n-        self.resolve_type_vars_or_error(&ty)\n-    }\n-\n-    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        let ty = self.tables.borrow().expr_ty_adjusted(expr);\n-        self.resolve_type_vars_or_error(&ty)\n-    }\n-\n     pub fn type_moves_by_default(&self,\n                                  param_env: ty::ParamEnv<'tcx>,\n                                  ty: Ty<'tcx>,\n                                  span: Span)\n                                  -> bool {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n-        if let Some((param_env, ty)) = self.tcx.lift_to_global(&(param_env, ty)) {\n-            // Even if the type may have no inference variables, during\n-            // type-checking closure types are in local tables only.\n-            let local_closures = match self.tables {\n-                InferTables::InProgress(_) => ty.has_closure_types(),\n-                _ => false\n-            };\n-            if !local_closures {\n+        // Even if the type may have no inference variables, during\n+        // type-checking closure types are in local tables only.\n+        if !self.in_progress_tables.is_some() || !ty.has_closure_types() {\n+            if let Some((param_env, ty)) = self.tcx.lift_to_global(&(param_env, ty)) {\n                 return ty.moves_by_default(self.tcx.global_tcx(), param_env, span);\n             }\n         }\n@@ -1521,15 +1347,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         !traits::type_known_to_meet_bound(self, param_env, ty, copy_def_id, span)\n     }\n \n-    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n-        self.tables.borrow().upvar_capture_map.get(&upvar_id).cloned()\n-    }\n-\n     pub fn closure_kind(&self,\n                         def_id: DefId)\n                         -> Option<ty::ClosureKind>\n     {\n-        if let InferTables::InProgress(tables) = self.tables {\n+        if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                 return tables.borrow()\n                              .closure_kinds\n@@ -1547,7 +1369,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn closure_type(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n-        if let InferTables::InProgress(tables) = self.tables {\n+        if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                 if let Some(&ty) = tables.borrow().closure_tys.get(&id) {\n                     return ty;"}, {"sha": "40734469718baea8057890212683e2470206fdcc", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -27,6 +27,7 @@ use self::TargetLint::*;\n \n use dep_graph::DepNode;\n use middle::privacy::AccessLevels;\n+use traits::Reveal;\n use ty::{self, TyCtxt};\n use session::{config, early_error, Session};\n use lint::{Level, LevelSource, Lint, LintId, LintPass, LintSource};\n@@ -411,8 +412,8 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     /// Side-tables for the body we are in.\n     pub tables: &'a ty::TypeckTables<'tcx>,\n \n-    /// The crate being checked.\n-    pub krate: &'a hir::Crate,\n+    /// Parameter environment for the item we are in.\n+    pub param_env: ty::ParamEnv<'tcx>,\n \n     /// Items accessible from the crate being checked.\n     pub access_levels: &'a AccessLevels,\n@@ -869,6 +870,17 @@ impl<'a> LintContext<'a> for EarlyContext<'a> {\n     }\n }\n \n+impl<'a, 'tcx> LateContext<'a, 'tcx> {\n+    fn with_param_env<F>(&mut self, id: ast::NodeId, f: F)\n+        where F: FnOnce(&mut Self),\n+    {\n+        let old_param_env = self.param_env;\n+        self.param_env = self.tcx.param_env(self.tcx.hir.local_def_id(id));\n+        f(self);\n+        self.param_env = old_param_env;\n+    }\n+}\n+\n impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable\n@@ -902,17 +914,21 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n-            run_lints!(cx, check_item, late_passes, it);\n-            hir_visit::walk_item(cx, it);\n-            run_lints!(cx, check_item_post, late_passes, it);\n+            cx.with_param_env(it.id, |cx| {\n+                run_lints!(cx, check_item, late_passes, it);\n+                hir_visit::walk_item(cx, it);\n+                run_lints!(cx, check_item_post, late_passes, it);\n+            });\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n-            run_lints!(cx, check_foreign_item, late_passes, it);\n-            hir_visit::walk_foreign_item(cx, it);\n-            run_lints!(cx, check_foreign_item_post, late_passes, it);\n+            cx.with_param_env(it.id, |cx| {\n+                run_lints!(cx, check_foreign_item, late_passes, it);\n+                hir_visit::walk_foreign_item(cx, it);\n+                run_lints!(cx, check_foreign_item_post, late_passes, it);\n+            });\n         })\n     }\n \n@@ -1026,17 +1042,21 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n-            run_lints!(cx, check_trait_item, late_passes, trait_item);\n-            hir_visit::walk_trait_item(cx, trait_item);\n-            run_lints!(cx, check_trait_item_post, late_passes, trait_item);\n+            cx.with_param_env(trait_item.id, |cx| {\n+                run_lints!(cx, check_trait_item, late_passes, trait_item);\n+                hir_visit::walk_trait_item(cx, trait_item);\n+                run_lints!(cx, check_trait_item_post, late_passes, trait_item);\n+            });\n         });\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n-            run_lints!(cx, check_impl_item, late_passes, impl_item);\n-            hir_visit::walk_impl_item(cx, impl_item);\n-            run_lints!(cx, check_impl_item_post, late_passes, impl_item);\n+            cx.with_param_env(impl_item.id, |cx| {\n+                run_lints!(cx, check_impl_item, late_passes, impl_item);\n+                hir_visit::walk_impl_item(cx, impl_item);\n+                run_lints!(cx, check_impl_item_post, late_passes, impl_item);\n+            });\n         });\n     }\n \n@@ -1330,7 +1350,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut cx = LateContext {\n         tcx: tcx,\n         tables: &ty::TypeckTables::empty(),\n-        krate: krate,\n+        param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n         access_levels: access_levels,\n         lint_sess: LintSession::new(&tcx.sess.lint_store),\n     };"}, {"sha": "58e77f40d981d4b692f5c16601e7c1bff13f719b", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -235,17 +235,14 @@ impl OverloadedCallType {\n ///////////////////////////////////////////////////////////////////////////\n // The ExprUseVisitor type\n //\n-// This is the code that actually walks the tree. Like\n-// mem_categorization, it requires a TYPER, which is a type that\n-// supplies types from the tree. After type checking is complete, you\n-// can just use the tcx as the typer.\n+// This is the code that actually walks the tree.\n pub struct ExprUseVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n     delegate: &'a mut Delegate<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n }\n \n-// If the TYPER results in an error, it's because the type check\n+// If the MC results in an error, it's because the type check\n // failed (or will fail, when the error is uncovered and reported\n // during writeback). In this case, we just ignore this part of the\n // code.\n@@ -264,29 +261,32 @@ macro_rules! return_if_err {\n     )\n }\n \n-impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n+               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               param_env: ty::ParamEnv<'tcx>,\n                region_maps: &'a RegionMaps,\n-               infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               param_env: ty::ParamEnv<'tcx>)\n+               tables: &'a ty::TypeckTables<'tcx>)\n                -> Self\n     {\n-        ExprUseVisitor::with_options(delegate,\n-                                     infcx,\n-                                     param_env,\n-                                     region_maps,\n-                                     mc::MemCategorizationOptions::default())\n+        ExprUseVisitor {\n+            mc: mc::MemCategorizationContext::new(tcx, region_maps, tables),\n+            delegate,\n+            param_env,\n+        }\n     }\n+}\n \n-    pub fn with_options(delegate: &'a mut (Delegate<'tcx>+'a),\n-                        infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                        param_env: ty::ParamEnv<'tcx>,\n-                        region_maps: &'a RegionMaps,\n-                        options: mc::MemCategorizationOptions)\n-               -> Self\n+impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n+    pub fn with_infer(delegate: &'a mut (Delegate<'tcx>+'a),\n+                      infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                      param_env: ty::ParamEnv<'tcx>,\n+                      region_maps: &'a RegionMaps,\n+                      tables: &'a ty::TypeckTables<'tcx>)\n+                      -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::with_options(infcx, region_maps, options),\n+            mc: mc::MemCategorizationContext::with_infer(infcx, region_maps, tables),\n             delegate,\n             param_env,\n         }\n@@ -296,7 +296,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"consume_body(body={:?})\", body);\n \n         for arg in &body.arguments {\n-            let arg_ty = return_if_err!(self.mc.infcx.node_ty(arg.pat.id));\n+            let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.id));\n \n             let fn_body_scope_r = self.tcx().node_scope_region(body.value.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -312,7 +312,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n-        self.mc.infcx.tcx\n+        self.mc.tcx\n     }\n \n     fn delegate_consume(&mut self,\n@@ -322,7 +322,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"delegate_consume(consume_id={}, cmt={:?})\",\n                consume_id, cmt);\n \n-        let mode = copy_or_move(self.mc.infcx, self.param_env, &cmt, DirectRefMove);\n+        let mode = copy_or_move(&self.mc, self.param_env, &cmt, DirectRefMove);\n         self.delegate.consume(consume_id, consume_span, cmt, mode);\n     }\n \n@@ -441,7 +441,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             hir::ExprAddrOf(m, ref base) => {   // &base\n                 // make sure that the thing we are pointing out stays valid\n                 // for the lifetime `scope_r` of the resulting ptr:\n-                let expr_ty = return_if_err!(self.mc.infcx.node_ty(expr.id));\n+                let expr_ty = return_if_err!(self.mc.expr_ty(expr));\n                 if let ty::TyRef(r, _) = expr_ty.sty {\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.borrow_expr(&base, r, bk, AddrOf);\n@@ -505,7 +505,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n \n             hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n-                if self.mc.infcx.tables.borrow().is_method_call(expr) {\n+                if self.mc.tables.is_method_call(expr) {\n                     self.consume_expr(lhs);\n                 } else {\n                     self.mutate_expr(expr, &lhs, MutateMode::WriteAndRead);\n@@ -528,7 +528,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn walk_callee(&mut self, call: &hir::Expr, callee: &hir::Expr) {\n-        let callee_ty = return_if_err!(self.mc.infcx.expr_ty_adjusted(callee));\n+        let callee_ty = return_if_err!(self.mc.expr_ty_adjusted(callee));\n         debug!(\"walk_callee: callee={:?} callee_ty={:?}\",\n                callee, callee_ty);\n         match callee_ty.sty {\n@@ -537,7 +537,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n             ty::TyError => { }\n             _ => {\n-                let def_id = self.mc.infcx.tables.borrow().type_dependent_defs[&call.id].def_id();\n+                let def_id = self.mc.tables.type_dependent_defs[&call.id].def_id();\n                 match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n                         let call_scope_r = self.tcx().node_scope_region(call.id);\n@@ -678,8 +678,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     // consumed or borrowed as part of the automatic adjustment\n     // process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr) {\n-        //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adjustments = self.mc.infcx.tables.borrow().expr_adjustments(expr).to_vec();\n+        let adjustments = self.mc.tables.expr_adjustments(expr);\n         let mut cmt = return_if_err!(self.mc.cat_expr_unadjusted(expr));\n         for adjustment in adjustments {\n             debug!(\"walk_adjustment expr={:?} adj={:?}\", expr, adjustment);\n@@ -796,12 +795,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                                mode: &mut TrackMatchMode) {\n         debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n-        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n+        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n             match pat.node {\n                 PatKind::Binding(hir::BindByRef(..), ..) =>\n                     mode.lub(BorrowingMatch),\n                 PatKind::Binding(hir::BindByValue(..), ..) => {\n-                    match copy_or_move(self.mc.infcx, self.param_env, &cmt_pat, PatBindingMove) {\n+                    match copy_or_move(&self.mc, self.param_env, &cmt_pat, PatBindingMove) {\n                         Copy => mode.lub(CopyingMatch),\n                         Move(..) => mode.lub(MovingMatch),\n                     }\n@@ -818,14 +817,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"walk_pat cmt_discr={:?} pat={:?}\", cmt_discr, pat);\n \n         let tcx = self.tcx();\n-        let infcx = self.mc.infcx;\n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n-        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n+                let pat_ty = return_if_err!(mc.node_ty(pat.id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n@@ -843,7 +841,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     hir::BindByValue(..) => {\n-                        let mode = copy_or_move(infcx, param_env, &cmt_pat, PatBindingMove);\n+                        let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);\n                     }\n@@ -855,14 +853,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // the interior nodes (enum variants and structs), as opposed\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n-        return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+        return_if_err!(mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n             let qpath = match pat.node {\n                 PatKind::Path(ref qpath) |\n                 PatKind::TupleStruct(ref qpath, ..) |\n                 PatKind::Struct(ref qpath, ..) => qpath,\n                 _ => return\n             };\n-            let def = infcx.tables.borrow().qpath_def(qpath, pat.id);\n+            let def = mc.tables.qpath_def(qpath, pat.id);\n             match def {\n                 Def::Variant(variant_did) |\n                 Def::VariantCtor(variant_did, ..) => {\n@@ -896,13 +894,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 let id_var = self.tcx().hir.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: id_var,\n                                              closure_expr_id: closure_expr.id };\n-                let upvar_capture = self.mc.infcx.upvar_capture(upvar_id).unwrap();\n+                let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                    fn_decl_span,\n                                                                    freevar.def));\n                 match upvar_capture {\n                     ty::UpvarCapture::ByValue => {\n-                        let mode = copy_or_move(self.mc.infcx,\n+                        let mode = copy_or_move(&self.mc,\n                                                 self.param_env,\n                                                 &cmt_var,\n                                                 CaptureMove);\n@@ -929,18 +927,18 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n         let var_id = self.tcx().hir.as_local_node_id(upvar_def.def_id()).unwrap();\n-        let var_ty = self.mc.infcx.node_ty(var_id)?;\n+        let var_ty = self.mc.node_ty(var_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }\n \n-fn copy_or_move<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+fn copy_or_move<'a, 'gcx, 'tcx>(mc: &mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n                                 param_env: ty::ParamEnv<'tcx>,\n                                 cmt: &mc::cmt<'tcx>,\n                                 move_reason: MoveReason)\n                                 -> ConsumeMode\n {\n-    if infcx.type_moves_by_default(param_env, cmt.ty, cmt.span) {\n+    if mc.type_moves_by_default(param_env, cmt.ty, cmt.span) {\n         Move(move_reason)\n     } else {\n         Copy"}, {"sha": "259079cf16048bbfa0b65f0282a57be72eb3bd65", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 105, "deletions": 103, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -76,6 +76,7 @@ use infer::InferCtxt;\n use hir::def::{Def, CtorKind};\n use ty::adjustment;\n use ty::{self, Ty, TyCtxt};\n+use ty::fold::TypeFoldable;\n \n use hir::{MutImmutable, MutMutable, PatKind};\n use hir::pat_util::EnumerateAndAdjustIterator;\n@@ -281,20 +282,10 @@ impl ast_node for hir::Pat {\n \n #[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub region_maps: &'a RegionMaps,\n-    options: MemCategorizationOptions,\n-}\n-\n-#[derive(Copy, Clone, Default)]\n-pub struct MemCategorizationOptions {\n-    // If true, then when analyzing a closure upvar, if the closure\n-    // has a missing kind, we treat it like a Fn closure. When false,\n-    // we ICE if the closure has a missing kind. Should be false\n-    // except during closure kind inference. It is used by the\n-    // mem-categorization code to be able to have stricter assertions\n-    // (which are always true except during upvar inference).\n-    pub during_closure_kind_inference: bool,\n+    pub tables: &'a ty::TypeckTables<'tcx>,\n+    infcx: Option<&'a InferCtxt<'a, 'gcx, 'tcx>>,\n }\n \n pub type McResult<T> = Result<T, ()>;\n@@ -395,51 +386,90 @@ impl MutabilityCategory {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-    /// Context should be the `DefId` we use to fetch region-maps.\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-               region_maps: &'a RegionMaps)\n-               -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-        MemCategorizationContext::with_options(infcx,\n-                                               region_maps,\n-                                               MemCategorizationOptions::default())\n+impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               region_maps: &'a RegionMaps,\n+               tables: &'a ty::TypeckTables<'tcx>)\n+               -> MemCategorizationContext<'a, 'tcx, 'tcx> {\n+        MemCategorizationContext { tcx, region_maps, tables, infcx: None }\n     }\n+}\n \n-    pub fn with_options(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-                        region_maps: &'a RegionMaps,\n-                        options: MemCategorizationOptions)\n-                        -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+    pub fn with_infer(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                      region_maps: &'a RegionMaps,\n+                      tables: &'a ty::TypeckTables<'tcx>)\n+                      -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         MemCategorizationContext {\n-            infcx: infcx,\n-            region_maps: region_maps,\n-            options: options,\n+            tcx: infcx.tcx,\n+            region_maps,\n+            tables,\n+            infcx: Some(infcx),\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n-        self.infcx.tcx\n+    pub fn type_moves_by_default(&self,\n+                                 param_env: ty::ParamEnv<'tcx>,\n+                                 ty: Ty<'tcx>,\n+                                 span: Span)\n+                                 -> bool {\n+        self.infcx.map(|infcx| infcx.type_moves_by_default(param_env, ty, span))\n+            .or_else(|| {\n+                self.tcx.lift_to_global(&(param_env, ty)).map(|(param_env, ty)| {\n+                    ty.moves_by_default(self.tcx.global_tcx(), param_env, span)\n+                })\n+            })\n+            .unwrap_or(true)\n     }\n \n-    fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        match self.infcx.node_ty(expr.id) {\n-            Ok(t) => Ok(t),\n-            Err(()) => {\n-                debug!(\"expr_ty({:?}) yielded Err\", expr);\n-                Err(())\n+    fn resolve_type_vars_if_possible<T>(&self, value: &T) -> T\n+        where T: TypeFoldable<'tcx>\n+    {\n+        self.infcx.map(|infcx| infcx.resolve_type_vars_if_possible(value))\n+            .unwrap_or_else(|| value.clone())\n+    }\n+\n+    fn is_tainted_by_errors(&self) -> bool {\n+        self.infcx.map_or(false, |infcx| infcx.is_tainted_by_errors())\n+    }\n+\n+    fn resolve_type_vars_or_error(&self,\n+                                  id: ast::NodeId,\n+                                  ty: Option<Ty<'tcx>>)\n+                                  -> McResult<Ty<'tcx>> {\n+        match ty {\n+            Some(ty) => {\n+                let ty = self.resolve_type_vars_if_possible(&ty);\n+                if ty.references_error() || ty.is_ty_var() {\n+                    debug!(\"resolve_type_vars_or_error: error from {:?}\", ty);\n+                    Err(())\n+                } else {\n+                    Ok(ty)\n+                }\n+            }\n+            // FIXME\n+            None if self.is_tainted_by_errors() => Err(()),\n+            None => {\n+                bug!(\"no type for node {}: {} in mem_categorization\",\n+                     id, self.tcx.hir.node_to_string(id));\n             }\n         }\n     }\n \n-    fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        self.infcx.expr_ty_adjusted(expr)\n+    pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n+        self.resolve_type_vars_or_error(id, self.tables.node_id_to_type_opt(id))\n     }\n \n-    fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        self.infcx.node_ty(id)\n+    pub fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n+        self.resolve_type_vars_or_error(expr.id, self.tables.expr_ty_opt(expr))\n+    }\n+\n+    pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n+        self.resolve_type_vars_or_error(expr.id, self.tables.expr_ty_adjusted_opt(expr))\n     }\n \n     fn pat_ty(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n-        let base_ty = self.infcx.node_ty(pat.id)?;\n+        let base_ty = self.node_ty(pat.id)?;\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n@@ -479,7 +509,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        helper(self, expr, self.infcx.tables.borrow().expr_adjustments(expr))\n+        helper(self, expr, self.tables.expr_adjustments(expr))\n     }\n \n     pub fn cat_expr_adjusted(&self, expr: &hir::Expr,\n@@ -496,12 +526,12 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         where F: FnOnce() -> McResult<cmt<'tcx>>\n     {\n         debug!(\"cat_expr_adjusted_with({:?}): {:?}\", adjustment, expr);\n-        let target = self.infcx.resolve_type_vars_if_possible(&adjustment.target);\n+        let target = self.resolve_type_vars_if_possible(&adjustment.target);\n         match adjustment.kind {\n             adjustment::Adjust::Deref(overloaded) => {\n                 // Equivalent to *expr or something similar.\n                 let base = if let Some(deref) = overloaded {\n-                    let ref_ty = self.tcx().mk_ref(deref.region, ty::TypeAndMut {\n+                    let ref_ty = self.tcx.mk_ref(deref.region, ty::TypeAndMut {\n                         ty: target,\n                         mutbl: deref.mutbl,\n                     });\n@@ -531,7 +561,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let expr_ty = self.expr_ty(expr)?;\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n-            if self.infcx.tables.borrow().is_method_call(expr) {\n+            if self.tables.is_method_call(expr) {\n                 self.cat_overloaded_lvalue(expr, e_base, false)\n             } else {\n                 let base_cmt = self.cat_expr(&e_base)?;\n@@ -554,7 +584,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprIndex(ref base, _) => {\n-            if self.infcx.tables.borrow().is_method_call(expr) {\n+            if self.tables.is_method_call(expr) {\n                 // If this is an index implemented by a method call, then it\n                 // will include an implicit deref of the result.\n                 // The call to index() returns a `&T` value, which\n@@ -568,7 +598,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprPath(ref qpath) => {\n-            let def = self.infcx.tables.borrow().qpath_def(qpath, expr.id);\n+            let def = self.tables.qpath_def(qpath, expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -619,49 +649,17 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           Def::Upvar(def_id, _, fn_node_id) => {\n-              let var_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-              let ty = self.node_ty(fn_node_id)?;\n-              match ty.sty {\n-                  ty::TyClosure(closure_id, _) => {\n-                      match self.infcx.closure_kind(closure_id) {\n-                          Some(kind) => {\n-                              self.cat_upvar(id, span, var_id, fn_node_id, kind)\n-                          }\n-                          None => {\n-                              if !self.options.during_closure_kind_inference {\n-                                  span_bug!(\n-                                      span,\n-                                      \"No closure kind for {:?}\",\n-                                      closure_id);\n-                              }\n-\n-                              // during closure kind inference, we\n-                              // don't know the closure kind yet, but\n-                              // it's ok because we detect that we are\n-                              // accessing an upvar and handle that\n-                              // case specially anyhow. Use Fn\n-                              // arbitrarily.\n-                              self.cat_upvar(id, span, var_id, fn_node_id, ty::ClosureKind::Fn)\n-                          }\n-                      }\n-                  }\n-                  _ => {\n-                      span_bug!(\n-                          span,\n-                          \"Upvar of non-closure {} - {:?}\",\n-                          fn_node_id,\n-                          ty);\n-                  }\n-              }\n+              let var_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n+              self.cat_upvar(id, span, var_id, fn_node_id)\n           }\n \n           Def::Local(def_id) => {\n-            let vid = self.tcx().hir.as_local_node_id(def_id).unwrap();\n+            let vid = self.tcx.hir.as_local_node_id(def_id).unwrap();\n             Ok(Rc::new(cmt_ {\n                 id: id,\n                 span: span,\n                 cat: Categorization::Local(vid),\n-                mutbl: MutabilityCategory::from_local(self.tcx(), vid),\n+                mutbl: MutabilityCategory::from_local(self.tcx, vid),\n                 ty: expr_ty,\n                 note: NoteNone\n             }))\n@@ -677,8 +675,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  id: ast::NodeId,\n                  span: Span,\n                  var_id: ast::NodeId,\n-                 fn_node_id: ast::NodeId,\n-                 kind: ty::ClosureKind)\n+                 fn_node_id: ast::NodeId)\n                  -> McResult<cmt<'tcx>>\n     {\n         // An upvar can have up to 3 components. We translate first to a\n@@ -704,12 +701,17 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n \n+        let kind = match self.tables.closure_kinds.get(&fn_node_id) {\n+            Some(&(kind, _)) => kind,\n+            None => span_bug!(span, \"missing closure kind\")\n+        };\n+\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n         let var_ty = self.node_ty(var_id)?;\n \n         // Mutability of original variable itself\n-        let var_mutbl = MutabilityCategory::from_local(self.tcx(), var_id);\n+        let var_mutbl = MutabilityCategory::from_local(self.tcx, var_id);\n \n         // Construct the upvar. This represents access to the field\n         // from the environment (perhaps we should eventually desugar\n@@ -743,7 +745,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // for that.\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n-        let upvar_capture = self.infcx.upvar_capture(upvar_id).unwrap();\n+        let upvar_capture = self.tables.upvar_capture(upvar_id);\n         let cmt_result = match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n                 cmt_result\n@@ -776,11 +778,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  -> cmt_<'tcx>\n     {\n         // Region of environment pointer\n-        let env_region = self.tcx().mk_region(ty::ReFree(ty::FreeRegion {\n+        let env_region = self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: self.tcx().hir.local_def_id(upvar_id.closure_expr_id),\n+            scope: self.tcx.hir.local_def_id(upvar_id.closure_expr_id),\n             bound_region: ty::BrEnv\n         }));\n \n@@ -797,7 +799,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // one.\n         let cmt_result = cmt_ {\n             mutbl: McImmutable,\n-            ty: self.tcx().types.err,\n+            ty: self.tcx.types.err,\n             ..cmt_result\n         };\n \n@@ -829,7 +831,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn temporary_scope(&self, id: ast::NodeId) -> ty::Region<'tcx>\n     {\n         let scope = self.region_maps.temporary_scope(id);\n-        self.tcx().mk_region(match scope {\n+        self.tcx.mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic\n         })\n@@ -840,20 +842,20 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                            span: Span,\n                            expr_ty: Ty<'tcx>)\n                            -> cmt<'tcx> {\n-        let promotable = self.tcx().rvalue_promotable_to_static.borrow().get(&id).cloned()\n+        let promotable = self.tcx.rvalue_promotable_to_static.borrow().get(&id).cloned()\n                                    .unwrap_or(false);\n \n         // When the corresponding feature isn't toggled, only promote `[T; 0]`.\n         let promotable = match expr_ty.sty {\n             ty::TyArray(_, 0) => true,\n-            _ => promotable && self.tcx().sess.features.borrow().rvalue_static_promotion,\n+            _ => promotable && self.tcx.sess.features.borrow().rvalue_static_promotion,\n         };\n \n         // Compute maximum lifetime of this rvalue. This is 'static if\n         // we can promote to a constant, otherwise equal to enclosing temp\n         // lifetime.\n         let re = if promotable {\n-            self.tcx().types.re_static\n+            self.tcx.types.re_static\n         } else {\n             self.temporary_scope(id)\n         };\n@@ -934,7 +936,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 span_bug!(expr.span, \"cat_overloaded_lvalue: base is not a reference\")\n             }\n         };\n-        let ref_ty = self.tcx().mk_ref(region, ty::TypeAndMut {\n+        let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n             ty: lvalue_ty,\n             mutbl,\n         });\n@@ -1049,14 +1051,14 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, mut op: F) -> McResult<()>\n-        where F: FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat),\n+        where F: FnMut(cmt<'tcx>, &hir::Pat),\n     {\n         self.cat_pattern_(cmt, pat, &mut op)\n     }\n \n     // FIXME(#19596) This is a workaround, but there should be a better way to do this\n     fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &hir::Pat, op: &mut F) -> McResult<()>\n-        where F : FnMut(&MemCategorizationContext<'a, 'gcx, 'tcx>, cmt<'tcx>, &hir::Pat)\n+        where F : FnMut(cmt<'tcx>, &hir::Pat)\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1105,7 +1107,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"cat_pattern: {:?} cmt={:?}\", pat, cmt);\n \n-        op(self, cmt.clone(), pat);\n+        op(cmt.clone(), pat);\n \n         // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n         // alone) because PatKind::Struct can also refer to variants.\n@@ -1121,8 +1123,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     Def::Variant(variant_did) |\n                     Def::VariantCtor(variant_did, ..) => {\n                         // univariant enums do not need downcasts\n-                        let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n-                        if !self.tcx().adt_def(enum_did).is_univariant() {\n+                        let enum_did = self.tcx.parent_def_id(variant_did).unwrap();\n+                        if !self.tcx.adt_def(enum_did).is_univariant() {\n                             self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n                         } else {\n                             cmt\n@@ -1136,11 +1138,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         match pat.node {\n           PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-            let def = self.infcx.tables.borrow().qpath_def(qpath, pat.id);\n+            let def = self.tables.qpath_def(qpath, pat.id);\n             let expected_len = match def {\n                 Def::VariantCtor(def_id, CtorKind::Fn) => {\n-                    let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n-                    self.tcx().adt_def(enum_def).variant_with_id(def_id).fields.len()\n+                    let enum_def = self.tcx.parent_def_id(def_id).unwrap();\n+                    self.tcx.adt_def(enum_def).variant_with_id(def_id).fields.len()\n                 }\n                 Def::StructCtor(_, CtorKind::Fn) => {\n                     match self.pat_ty(&pat)?.sty {"}, {"sha": "64438f586d7f515fe8de9b83c1f6b96152b60df3", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -29,7 +29,7 @@ use hir::{self, intravisit, Local, Pat, Body};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::map::NodeExpr;\n use hir::def_id::DefId;\n-use infer::{self, InferCtxt, InferTables, InferTablesRef};\n+use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use std::fmt;\n@@ -72,9 +72,12 @@ struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn node_matches_type(&mut self, node_id: &'gcx NodeId) -> bool {\n-        match self.infcx.tables.borrow().node_types.get(node_id) {\n-            Some(&ty) => {\n+    fn node_matches_type(&mut self, node_id: NodeId) -> bool {\n+        let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n+            tables.borrow().node_id_to_type_opt(node_id)\n+        });\n+        match ty_opt {\n+            Some(ty) => {\n                 let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n                 ty.walk().any(|inner_ty| {\n                     inner_ty == *self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n@@ -88,7 +91,7 @@ impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n                     }\n                 })\n             }\n-            _ => false,\n+            None => false,\n         }\n     }\n }\n@@ -99,15 +102,15 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_local(&mut self, local: &'gcx Local) {\n-        if self.found_local_pattern.is_none() && self.node_matches_type(&local.id) {\n+        if self.found_local_pattern.is_none() && self.node_matches_type(local.id) {\n             self.found_local_pattern = Some(&*local.pat);\n         }\n         intravisit::walk_local(self, local);\n     }\n \n     fn visit_body(&mut self, body: &'gcx Body) {\n         for argument in &body.arguments {\n-            if self.found_arg_pattern.is_none() && self.node_matches_type(&argument.id) {\n+            if self.found_arg_pattern.is_none() && self.node_matches_type(argument.id) {\n                 self.found_arg_pattern = Some(&*argument.pat);\n             }\n         }\n@@ -652,18 +655,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             obligation.cause.span,\n                             format!(\"the requirement to implement `{}` derives from here\", kind));\n \n-                        let infer_tables = match self.tables {\n-                            InferTables::Interned(tables) =>\n-                                Some(InferTablesRef::Interned(tables)),\n-                            InferTables::InProgress(tables) =>\n-                                Some(InferTablesRef::InProgress(tables.borrow())),\n-                            InferTables::Missing => None,\n-                        };\n-\n                         // Additional context information explaining why the closure only implements\n                         // a particular trait.\n-                        if let Some(tables) = infer_tables {\n-                            match tables.closure_kinds.get(&node_id) {\n+                        if let Some(tables) = self.in_progress_tables {\n+                            match tables.borrow().closure_kinds.get(&node_id) {\n                                 Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) => {\n                                     err.span_note(span, &format!(\n                                         \"closure is `FnOnce` because it moves the \\"}, {"sha": "3ce7ee847cca6547e6b3b506b73bede769c8afcc", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -484,7 +484,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let elaborated_env = ty::ParamEnv::new(tcx.intern_predicates(&predicates),\n                                            unnormalized_env.reveal);\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let predicates = match fully_normalize(\n             &infcx,\n             cause,\n@@ -598,7 +598,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::empty(Reveal::All);\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = FulfillmentContext::new();"}, {"sha": "18734e2dbc3f19f4d75cd9485f8dfb224e684360", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -125,7 +125,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n     match ancestors.defs(tcx, item.name, item.kind).next() {\n         Some(node_item) => {\n-            let substs = tcx.infer_ctxt(()).enter(|infcx| {\n+            let substs = tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = ty::ParamEnv::empty(Reveal::All);\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(&infcx, param_env, impl_data.impl_def_id,\n@@ -188,7 +188,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let impl1_trait_ref = tcx.impl_trait_ref(impl1_def_id).unwrap();\n \n     // Create a infcx, taking the predicates of impl1 as assumptions:\n-    let result = tcx.infer_ctxt(()).enter(|infcx| {\n+    let result = tcx.infer_ctxt().enter(|infcx| {\n         // Normalize the trait reference. The WF rules ought to ensure\n         // that this always succeeds.\n         let impl1_trait_ref ="}, {"sha": "f80caeec460facf955f6ea261bb2b72109feda3c", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'gcx, 'tcx> Children {\n             let possible_sibling = *slot;\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt(()).enter(|infcx| {\n+            let (le, ge) = tcx.infer_ctxt().enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);"}, {"sha": "734ba2a2d39096ade9dff9b37dc1ca926b724a36", "filename": "src/librustc/traits/trans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftrans%2Fmod.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n             // Do the initial selection for the obligation. This yields the\n             // shallow result we are looking for -- that is, what specific impl.\n-            self.infer_ctxt(()).enter(|infcx| {\n+            self.infer_ctxt().enter(|infcx| {\n                 let mut selcx = SelectionContext::new(&infcx);\n \n                 let param_env = ty::ParamEnv::empty(Reveal::All);"}, {"sha": "2d81606329e57d89e530101e7a1cb116b85a7f59", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -376,8 +376,8 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n-    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture<'tcx>> {\n-        Some(self.upvar_capture_map.get(&upvar_id).unwrap().clone())\n+    pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n+        self.upvar_capture_map[&upvar_id]\n     }\n }\n "}, {"sha": "a7029ac5fa9f11600d77c0b994532dbea48646b1", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -175,7 +175,7 @@ impl<'tcx> ty::ParamEnv<'tcx> {\n                                        self_type: Ty<'tcx>, span: Span)\n                                        -> Result<(), CopyImplementationError<'tcx>> {\n         // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt(()).enter(|infcx| {\n+        tcx.infer_ctxt().enter(|infcx| {\n             let (adt, substs) = match self_type.sty {\n                 ty::TyAdt(adt, substs) => (adt, substs),\n                 _ => return Err(CopyImplementationError::NotAnAdt),\n@@ -977,7 +977,7 @@ fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n-    tcx.infer_ctxt(())\n+    tcx.infer_ctxt()\n        .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n                                                        param_env,\n                                                        ty,\n@@ -991,7 +991,7 @@ fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n-    tcx.infer_ctxt(())\n+    tcx.infer_ctxt()\n        .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n                                                        param_env,\n                                                        ty,\n@@ -1005,7 +1005,7 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n-    tcx.infer_ctxt(())\n+    tcx.infer_ctxt()\n        .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n                                                        param_env,\n                                                        ty,"}, {"sha": "ae2be28c198bffa0d02693145f0e2c28fbac598d", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -192,7 +192,6 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     debug!(\"check_loans(body id={})\", body.value.id);\n \n     let def_id = bccx.tcx.hir.body_owner_def_id(body.id());\n-    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body.id());\n     let param_env = bccx.tcx.param_env(def_id);\n     let mut clcx = CheckLoanCtxt {\n         bccx: bccx,\n@@ -201,7 +200,8 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans: all_loans,\n         param_env,\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, &bccx.region_maps, &infcx, param_env).consume_body(body);\n+    euv::ExprUseVisitor::new(&mut clcx, bccx.tcx, param_env, &bccx.region_maps, bccx.tables)\n+        .consume_body(body);\n }\n \n #[derive(PartialEq)]"}, {"sha": "7dcb6ce76a401618660faaf42f0841824b5f3d61", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -18,7 +18,6 @@\n \n use borrowck::*;\n use borrowck::move_data::MoveData;\n-use rustc::infer::InferCtxt;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n@@ -40,19 +39,18 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                     body: hir::BodyId)\n                                     -> (Vec<Loan<'tcx>>, move_data::MoveData<'tcx>) {\n     let def_id = bccx.tcx.hir.body_owner_def_id(body);\n-    let infcx = bccx.tcx.borrowck_fake_infer_ctxt(body);\n     let param_env = bccx.tcx.param_env(def_id);\n     let mut glcx = GatherLoanCtxt {\n         bccx: bccx,\n-        infcx: &infcx,\n         all_loans: Vec::new(),\n         item_ub: region::CodeExtent::Misc(body.node_id),\n         move_data: MoveData::new(),\n         move_error_collector: move_error::MoveErrorCollector::new(),\n     };\n \n     let body = glcx.bccx.tcx.hir.body(body);\n-    euv::ExprUseVisitor::new(&mut glcx, &bccx.region_maps, &infcx, param_env).consume_body(body);\n+    euv::ExprUseVisitor::new(&mut glcx, bccx.tcx, param_env, &bccx.region_maps, bccx.tables)\n+        .consume_body(body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n@@ -61,7 +59,6 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n struct GatherLoanCtxt<'a, 'tcx: 'a> {\n     bccx: &'a BorrowckCtxt<'a, 'tcx>,\n-    infcx: &'a InferCtxt<'a, 'tcx, 'tcx>,\n     move_data: move_data::MoveData<'tcx>,\n     move_error_collector: move_error::MoveErrorCollector<'tcx>,\n     all_loans: Vec<Loan<'tcx>>,\n@@ -158,7 +155,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n-        let ty = self.infcx.tables.borrow().node_id_to_type(id);\n+        let ty = self.bccx.tables.node_id_to_type(id);\n         gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }"}, {"sha": "fcdabf89e3cdd2226e9631cdd457b31f66929f94", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -493,19 +493,18 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n ///\n /// FIXME: this should be done by borrowck.\n fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n-    cx.tcx.infer_ctxt(cx.tables).enter(|infcx| {\n-        let mut checker = MutationChecker {\n-            cx: cx,\n-        };\n-        ExprUseVisitor::new(&mut checker, cx.region_maps, &infcx, cx.param_env).walk_expr(guard);\n-    });\n+    let mut checker = MutationChecker {\n+        cx: cx,\n+    };\n+    ExprUseVisitor::new(&mut checker, cx.tcx, cx.param_env, cx.region_maps, cx.tables)\n+        .walk_expr(guard);\n }\n \n-struct MutationChecker<'a, 'gcx: 'a> {\n-    cx: &'a MatchVisitor<'a, 'gcx>,\n+struct MutationChecker<'a, 'tcx: 'a> {\n+    cx: &'a MatchVisitor<'a, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n+impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn matched_pat(&mut self, _: &Pat, _: cmt, _: euv::MatchMode) {}\n     fn consume(&mut self, _: ast::NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}"}, {"sha": "ec7510546a044e01ff4c9641647837e922813f69", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -483,7 +483,7 @@ fn resolve_trait_associated_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n            trait_ref);\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),"}, {"sha": "62e20a90f8a0860e3b37543472a4e1390d062085", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -154,7 +154,7 @@ fn test_env<F>(source_string: &str,\n                              index,\n                              \"test_crate\",\n                              |tcx| {\n-        tcx.infer_ctxt(()).enter(|infcx| {\n+        tcx.infer_ctxt().enter(|infcx| {\n             let mut region_maps = RegionMaps::new();\n             body(Env {\n                 infcx: &infcx,"}, {"sha": "9800012917c504475cc494efa845d302c6b47f1f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -32,7 +32,7 @@ use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::cfg;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty};\n use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n use util::nodemap::NodeSet;\n@@ -893,7 +893,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             for adjustment in cx.tables.expr_adjustments(expr) {\n                 if let Adjust::Deref(Some(deref)) = adjustment.kind {\n                     let (def_id, substs) = deref.method_call(cx.tcx, source);\n-                    if method_call_refers_to_method(cx.tcx, method, def_id, substs, id) {\n+                    if method_call_refers_to_method(cx, method, def_id, substs, id) {\n                         return true;\n                     }\n                 }\n@@ -904,7 +904,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             if cx.tables.is_method_call(expr) {\n                 let def_id = cx.tables.type_dependent_defs[&id].def_id();\n                 let substs = cx.tables.node_substs(id);\n-                if method_call_refers_to_method(cx.tcx, method, def_id, substs, id) {\n+                if method_call_refers_to_method(cx, method, def_id, substs, id) {\n                     return true;\n                 }\n             }\n@@ -920,8 +920,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     match def {\n                         Def::Method(def_id) => {\n                             let substs = cx.tables.node_substs(callee.id);\n-                            method_call_refers_to_method(\n-                                cx.tcx, method, def_id, substs, id)\n+                            method_call_refers_to_method(cx, method, def_id, substs, id)\n                         }\n                         _ => false,\n                     }\n@@ -932,12 +931,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n         // Check if the method call to the method with the ID `callee_id`\n         // and instantiated with `callee_substs` refers to method `method`.\n-        fn method_call_refers_to_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        fn method_call_refers_to_method<'a, 'tcx>(cx: &LateContext<'a, 'tcx>,\n                                                   method: &ty::AssociatedItem,\n                                                   callee_id: DefId,\n                                                   callee_substs: &Substs<'tcx>,\n                                                   expr_id: ast::NodeId)\n                                                   -> bool {\n+            let tcx = cx.tcx;\n             let callee_item = tcx.associated_item(callee_id);\n \n             match callee_item.container {\n@@ -951,13 +951,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                     let trait_ref = ty::TraitRef::from_method(tcx, trait_def_id, callee_substs);\n                     let trait_ref = ty::Binder(trait_ref);\n                     let span = tcx.hir.span(expr_id);\n-                    let param_env = tcx.param_env(method.def_id);\n                     let obligation =\n                         traits::Obligation::new(traits::ObligationCause::misc(span, expr_id),\n-                                                param_env,\n+                                                cx.param_env,\n                                                 trait_ref.to_poly_trait_predicate());\n \n-                    tcx.infer_ctxt(()).enter(|infcx| {\n+                    tcx.infer_ctxt().enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n                             // The method comes from a `T: Trait` bound.\n@@ -1224,11 +1223,9 @@ impl LintPass for UnionsWithDropFields {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n     fn check_item(&mut self, ctx: &LateContext, item: &hir::Item) {\n         if let hir::ItemUnion(ref vdata, _) = item.node {\n-            let item_def_id = ctx.tcx.hir.local_def_id(item.id);\n-            let param_env = ctx.tcx.param_env(item_def_id);\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.type_of(ctx.tcx.hir.local_def_id(field.id));\n-                if field_ty.needs_drop(ctx.tcx, param_env) {\n+                if field_ty.needs_drop(ctx.tcx, ctx.param_env) {\n                     ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n                                   field.span,\n                                   \"union contains a field with possibly non-trivial drop code, \\"}, {"sha": "32bde42b5261f64b4d6c25ffa0317698bb3d235c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -725,7 +725,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 // sizes only make sense for non-generic types\n                 let item_def_id = cx.tcx.hir.local_def_id(it.id);\n                 let t = cx.tcx.type_of(item_def_id);\n-                let param_env = cx.tcx.param_env(item_def_id).reveal_all();\n+                let param_env = cx.param_env.reveal_all();\n                 let ty = cx.tcx.erase_regions(&t);\n                 let layout = ty.layout(cx.tcx, param_env).unwrap_or_else(|e| {\n                     bug!(\"failed to get layout for `{}`: {}\", t, e)"}, {"sha": "56c0e18d6f91a39b3897f869cd1ef9cc2f4b4783", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -83,7 +83,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n     };\n \n     let src = MirSource::from_node(tcx, id);\n-    tcx.infer_ctxt(body_id).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let cx = Cx::new(&infcx, src);\n         let mut mir = if cx.tables().tainted_by_errors {\n             build::construct_error(cx, body_id)\n@@ -171,7 +171,7 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n {\n     let span = tcx.hir.span(ctor_id);\n     if let hir::VariantData::Tuple(ref fields, ctor_id) = *v {\n-        tcx.infer_ctxt(()).enter(|infcx| {\n+        tcx.infer_ctxt().enter(|infcx| {\n             let (mut mir, src) =\n                 shim::build_adt_ctor(&infcx, ctor_id, fields, span);\n \n@@ -365,13 +365,14 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n             let var_id = tcx.hir.as_local_node_id(fv.def.def_id()).unwrap();\n-            let by_ref = hir.tables().upvar_capture(ty::UpvarId {\n+            let capture = hir.tables().upvar_capture(ty::UpvarId {\n                 var_id: var_id,\n                 closure_expr_id: fn_id\n-            }).map_or(false, |capture| match capture {\n+            });\n+            let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n                 ty::UpvarCapture::ByRef(..) => true\n-            });\n+            };\n             let mut decl = UpvarDecl {\n                 debug_name: keywords::Invalid.name(),\n                 by_ref: by_ref"}, {"sha": "474feefabbb88dcc12d14967818e0217031e5805", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -758,13 +758,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 var_id: id_var,\n                 closure_expr_id: closure_expr_id,\n             };\n-            let upvar_capture = match cx.tables().upvar_capture(upvar_id) {\n-                Some(c) => c,\n-                None => {\n-                    span_bug!(expr.span, \"no upvar_capture for {:?}\", upvar_id);\n-                }\n-            };\n-            match upvar_capture {\n+            match cx.tables().upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => field_kind,\n                 ty::UpvarCapture::ByRef(borrow) => {\n                     ExprKind::Deref {\n@@ -878,7 +872,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         var_id: id_var,\n         closure_expr_id: closure_expr.id,\n     };\n-    let upvar_capture = cx.tables().upvar_capture(upvar_id).unwrap();\n+    let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.id);\n     let var_ty = cx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {"}, {"sha": "2bb6b39966a82021fda4658c87ef462863f80167", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -37,6 +37,7 @@ pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     pub param_env: ty::ParamEnv<'tcx>,\n     pub region_maps: Rc<RegionMaps>,\n+    pub tables: &'a ty::TypeckTables<'gcx>,\n \n     /// This is `Constness::Const` if we are compiling a `static`,\n     /// `const`, or the body of a `const fn`.\n@@ -67,6 +68,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n \n         let param_env = tcx.param_env(src_def_id);\n         let region_maps = tcx.region_maps(src_def_id);\n+        let tables = tcx.typeck_tables_of(src_def_id);\n \n         let attrs = tcx.hir.attrs(src_id);\n \n@@ -82,7 +84,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n \n-        Cx { tcx, infcx, param_env, region_maps, constness, src, check_overflow }\n+        Cx { tcx, infcx, param_env, region_maps, tables, constness, src, check_overflow }\n     }\n }\n \n@@ -184,7 +186,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn tables(&self) -> &'a ty::TypeckTables<'gcx> {\n-        self.infcx.tables.expect_interned()\n+        self.tables\n     }\n \n     pub fn check_overflow(&self) -> bool {"}, {"sha": "d60e761bc0b948e4c50462a5e9584d522e683922", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -998,7 +998,7 @@ impl MirPass for QualifyAndPromoteConstants {\n         // Statics must be Sync.\n         if mode == Mode::Static {\n             let ty = mir.return_ty;\n-            tcx.infer_ctxt(()).enter(|infcx| {\n+            tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n                 let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                 let mut fulfillment_cx = traits::FulfillmentContext::new();"}, {"sha": "e23f0705b6a028dc83b2d00d91c608877d868b27", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -759,7 +759,7 @@ impl MirPass for TypeckMir {\n             return;\n         }\n         let param_env = tcx.param_env(def_id);\n-        tcx.infer_ctxt(()).enter(|infcx| {\n+        tcx.infer_ctxt().enter(|infcx| {\n             let mut checker = TypeChecker::new(&infcx, item_id, param_env);\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);"}, {"sha": "e539cc1ae8bf237f9ff503c742569938b03b2789", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -51,7 +51,6 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::collections::hash_map::Entry;\n use std::cmp::Ordering;\n-use std::mem;\n \n struct CheckCrateVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -138,13 +137,14 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n             self.check_const_eval(&body.value);\n         }\n \n-        let outer_penv = self.tcx.infer_ctxt(body_id).enter(|infcx| {\n-            let param_env = self.tcx.param_env(item_def_id);\n-            let outer_penv = mem::replace(&mut self.param_env, param_env);\n-            let region_maps = &self.tcx.region_maps(item_def_id);\n-            euv::ExprUseVisitor::new(self, region_maps, &infcx, param_env).consume_body(body);\n-            outer_penv\n-        });\n+        let outer_penv = self.param_env;\n+        self.param_env = self.tcx.param_env(item_def_id);\n+\n+        let tcx = self.tcx;\n+        let param_env = self.param_env;\n+        let region_maps = self.tcx.region_maps(item_def_id);\n+        euv::ExprUseVisitor::new(self, tcx, param_env, &region_maps, self.tables)\n+            .consume_body(body);\n \n         self.visit_body(body);\n "}, {"sha": "29742469f84d95d8077c113b0f02df22214bff89", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -219,7 +219,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                          param_env,\n                                                          normalize_cause.clone());\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let inh = Inherited::new(infcx, impl_m.def_id);\n         let infcx = &inh.infcx;\n \n@@ -726,7 +726,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                     impl_trait_ref: ty::TraitRef<'tcx>) {\n     debug!(\"compare_const_impl(impl_trait_ref={:?})\", impl_trait_ref);\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let inh = Inherited::new(infcx, impl_c.def_id);\n         let infcx = &inh.infcx;"}, {"sha": "93057f91997daf2af2b6c2aa952a40fbbf45395d", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -79,7 +79,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n     // check that the impl type can be made to match the trait type.\n \n-    tcx.infer_ctxt(()).enter(|ref infcx| {\n+    tcx.infer_ctxt().enter(|ref infcx| {\n         let impl_param_env = tcx.param_env(self_type_did);\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();"}, {"sha": "844065cb3348e5d57ce20f313c3b7541485dd0d5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -108,7 +108,7 @@ use lint;\n use util::common::{ErrorReported, indenter};\n use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n \n-use std::cell::{Cell, RefCell};\n+use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::collections::hash_map::Entry;\n use std::cmp;\n use std::mem::replace;\n@@ -147,6 +147,33 @@ mod compare_method;\n mod intrinsic;\n mod op;\n \n+/// A wrapper for InferCtxt's `in_progress_tables` field.\n+#[derive(Copy, Clone)]\n+struct MaybeInProgressTables<'a, 'tcx: 'a> {\n+    maybe_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n+}\n+\n+impl<'a, 'tcx> MaybeInProgressTables<'a, 'tcx> {\n+    fn borrow(self) -> Ref<'a, ty::TypeckTables<'tcx>> {\n+        match self.maybe_tables {\n+            Some(tables) => tables.borrow(),\n+            None => {\n+                bug!(\"MaybeInProgressTables: inh/fcx.tables.borrow() with no tables\")\n+            }\n+        }\n+    }\n+\n+    fn borrow_mut(self) -> RefMut<'a, ty::TypeckTables<'tcx>> {\n+        match self.maybe_tables {\n+            Some(tables) => tables.borrow_mut(),\n+            None => {\n+                bug!(\"MaybeInProgressTables: inh/fcx.tables.borrow_mut() with no tables\")\n+            }\n+        }\n+    }\n+}\n+\n+\n /// closures defined within the function.  For example:\n ///\n ///     fn foo() {\n@@ -159,6 +186,8 @@ mod op;\n pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     infcx: InferCtxt<'a, 'gcx, 'tcx>,\n \n+    tables: MaybeInProgressTables<'a, 'tcx>,\n+\n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n \n     fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n@@ -535,9 +564,8 @@ pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n-        let tables = ty::TypeckTables::empty();\n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt(tables),\n+            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(),\n             def_id,\n         }\n     }\n@@ -562,6 +590,9 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         });\n \n         Inherited {\n+            tables: MaybeInProgressTables {\n+                maybe_tables: infcx.in_progress_tables,\n+            },\n             infcx: infcx,\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n             locals: RefCell::new(NodeMap()),\n@@ -3302,14 +3333,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_expr_has_type(base_expr, struct_ty);\n             match struct_ty.sty {\n                 ty::TyAdt(adt, substs) if adt.is_struct() => {\n-                    self.tables.borrow_mut().fru_field_types.insert(\n-                        expr.id,\n-                        adt.struct_variant().fields.iter().map(|f| {\n-                            self.normalize_associated_types_in(\n-                                expr.span, &f.ty(self.tcx, substs)\n-                            )\n-                        }).collect()\n-                    );\n+                    let fru_field_types = adt.struct_variant().fields.iter().map(|f| {\n+                        self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n+                    }).collect();\n+                    self.tables.borrow_mut().fru_field_types.insert(expr.id, fru_field_types);\n                 }\n                 _ => {\n                     span_err!(self.tcx.sess, base_expr.span, E0436,\n@@ -4186,7 +4213,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::StmtSemi(ref e, _) => e,\n             _ => return,\n         };\n-        let last_expr_ty = self.expr_ty(last_expr);\n+        let last_expr_ty = self.node_ty(last_expr.id);\n         if self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err() {\n             return;\n         }"}, {"sha": "952321c946bf67475d4a606c5a97139468fa6477", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -824,18 +824,24 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Create a temporary `MemCategorizationContext` and pass it to the closure.\n+    fn with_mc<F, R>(&self, f: F) -> R\n+        where F: for<'b> FnOnce(mc::MemCategorizationContext<'b, 'gcx, 'tcx>) -> R\n+    {\n+        f(mc::MemCategorizationContext::with_infer(&self.infcx,\n+                                                   &self.region_maps,\n+                                                   &self.tables.borrow()))\n+    }\n+\n     /// Invoked on any adjustments that occur. Checks that if this is a region pointer being\n     /// dereferenced, the lifetime of the pointer includes the deref expr.\n     fn constrain_adjustments(&mut self, expr: &hir::Expr) -> mc::McResult<mc::cmt<'tcx>> {\n         debug!(\"constrain_adjustments(expr={:?})\", expr);\n \n-        let mut cmt = {\n-            let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-            mc.cat_expr_unadjusted(expr)?\n-        };\n+        let mut cmt = self.with_mc(|mc| mc.cat_expr_unadjusted(expr))?;\n \n-        //NOTE(@jroesch): mixed RefCell borrow causes crash\n-        let adjustments = self.tables.borrow().expr_adjustments(&expr).to_vec();\n+        let tables = self.tables.borrow();\n+        let adjustments = tables.expr_adjustments(&expr);\n         if adjustments.is_empty() {\n             return Ok(cmt);\n         }\n@@ -886,10 +892,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                                                expr.id, expr_region);\n             }\n \n-            {\n-                let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-                cmt = mc.cat_expr_adjusted(expr, cmt, &adjustment)?;\n-            }\n+            cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n \n             if let Categorization::Deref(_, mc::BorrowedPtr(_, r_ptr)) = cmt.cat {\n                 self.mk_subregion_due_to_dereference(expr.span,\n@@ -981,10 +984,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     mutability: hir::Mutability, base: &hir::Expr) {\n         debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n-        let cmt = {\n-            let mc = mc::MemCategorizationContext::new(self, &self.region_maps);\n-            ignore_err!(mc.cat_expr(base))\n-        };\n+        let cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(base)));\n \n         debug!(\"link_addr_of: cmt={:?}\", cmt);\n \n@@ -1000,22 +1000,20 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             None => { return; }\n             Some(ref expr) => &**expr,\n         };\n-        let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n-        let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n-        self.link_pattern(mc, discr_cmt, &local.pat);\n+        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(init_expr)));\n+        self.link_pattern(discr_cmt, &local.pat);\n     }\n \n     /// Computes the guarantors for any ref bindings in a match and\n     /// then ensures that the lifetime of the resulting pointer is\n     /// linked to the lifetime of its guarantor (if any).\n     fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n         debug!(\"regionck::for_match()\");\n-        let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n-        let discr_cmt = ignore_err!(mc.cat_expr(discr));\n+        let discr_cmt = ignore_err!(self.with_mc(|mc| mc.cat_expr(discr)));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n         for arm in arms {\n             for root_pat in &arm.pats {\n-                self.link_pattern(mc, discr_cmt.clone(), &root_pat);\n+                self.link_pattern(discr_cmt.clone(), &root_pat);\n             }\n         }\n     }\n@@ -1025,30 +1023,28 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// linked to the lifetime of its guarantor (if any).\n     fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n-        let mc = &mc::MemCategorizationContext::new(self, &self.region_maps);\n         for arg in args {\n             let arg_ty = self.node_ty(arg.id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n-            let arg_cmt = mc.cat_rvalue(\n-                arg.id, arg.pat.span, re_scope, arg_ty);\n+            let arg_cmt = self.with_mc(|mc| {\n+                mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty)\n+            });\n             debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                    arg_ty,\n                    arg_cmt,\n                    arg);\n-            self.link_pattern(mc, arg_cmt, &arg.pat);\n+            self.link_pattern(arg_cmt, &arg.pat);\n         }\n     }\n \n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n-    fn link_pattern<'t>(&self,\n-                        mc: &mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n-                        discr_cmt: mc::cmt<'tcx>,\n-                        root_pat: &hir::Pat) {\n+    fn link_pattern(&self, discr_cmt: mc::cmt<'tcx>, root_pat: &hir::Pat) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n                discr_cmt,\n                root_pat);\n-        let _ = mc.cat_pattern(discr_cmt, root_pat, |_, sub_cmt, sub_pat| {\n+        let _ = self.with_mc(|mc| {\n+            mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(hir::BindByRef(mutbl), ..) => {\n@@ -1057,7 +1053,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     }\n                     _ => {}\n                 }\n-            });\n+            })\n+        });\n     }\n \n     /// Link lifetime of borrowed pointer resulting from autoref to lifetimes in the value being\n@@ -1215,8 +1212,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         // Detect by-ref upvar `x`:\n         let cause = match note {\n             mc::NoteUpvarRef(ref upvar_id) => {\n-                let upvar_capture_map = &self.tables.borrow_mut().upvar_capture_map;\n-                match upvar_capture_map.get(upvar_id) {\n+                match self.tables.borrow().upvar_capture_map.get(upvar_id) {\n                     Some(&ty::UpvarCapture::ByRef(ref upvar_borrow)) => {\n                         // The mutability of the upvar may have been modified\n                         // by the above adjustment, so update our local variable."}, {"sha": "59ca896b347f1fec8428be0758151c1c089a51c8", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 86, "deletions": 121, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -53,31 +53,22 @@ use rustc::hir;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::util::nodemap::NodeMap;\n \n-///////////////////////////////////////////////////////////////////////////\n-// PUBLIC ENTRY POINTS\n+use std::collections::hash_map::Entry;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_analyze(&self, body: &'gcx hir::Body) {\n-        let mut seed = SeedBorrowKind::new(self);\n-        seed.visit_body(body);\n-\n-        let mut adjust = AdjustBorrowKind::new(self, seed.temp_closure_kinds);\n-        adjust.visit_body(body);\n+        InferBorrowKindVisitor { fcx: self }.visit_body(body);\n \n         // it's our job to process these.\n         assert!(self.deferred_call_resolutions.borrow().is_empty());\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// SEED BORROW KIND\n-\n-struct SeedBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct InferBorrowKindVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n         NestedVisitorMap::None\n     }\n@@ -87,7 +78,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n             hir::ExprClosure(cc, _, body_id, _) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n-                self.check_closure(expr, cc);\n+                self.fcx.analyze_closure(expr.id, expr.span, body, cc);\n             }\n \n             _ => { }\n@@ -97,85 +88,75 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for SeedBorrowKind<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> SeedBorrowKind<'a, 'gcx, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>) -> SeedBorrowKind<'a, 'gcx, 'tcx> {\n-        SeedBorrowKind { fcx: fcx, temp_closure_kinds: NodeMap() }\n-    }\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+    fn analyze_closure(&self,\n+                       id: ast::NodeId,\n+                       span: Span,\n+                       body: &hir::Body,\n+                       capture_clause: hir::CaptureClause) {\n+        /*!\n+         * Analysis starting point.\n+         */\n \n-    fn check_closure(&mut self,\n-                     expr: &hir::Expr,\n-                     capture_clause: hir::CaptureClause)\n-    {\n-        if !self.fcx.tables.borrow().closure_kinds.contains_key(&expr.id) {\n-            self.temp_closure_kinds.insert(expr.id, (ty::ClosureKind::Fn, None));\n-            debug!(\"check_closure: adding closure {:?} as Fn\", expr.id);\n-        }\n+        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n \n-        self.fcx.tcx.with_freevars(expr.id, |freevars| {\n+        let infer_kind = match self.tables.borrow_mut().closure_kinds.entry(id) {\n+            Entry::Occupied(_) => false,\n+            Entry::Vacant(entry) => {\n+                debug!(\"check_closure: adding closure {:?} as Fn\", id);\n+                entry.insert((ty::ClosureKind::Fn, None));\n+                true\n+            }\n+        };\n+\n+        self.tcx.with_freevars(id, |freevars| {\n             for freevar in freevars {\n                 let def_id = freevar.def.def_id();\n-                let var_node_id = self.fcx.tcx.hir.as_local_node_id(def_id).unwrap();\n+                let var_node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                             closure_expr_id: expr.id };\n+                                             closure_expr_id: id };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n \n                 let capture_kind = match capture_clause {\n                     hir::CaptureByValue => {\n                         ty::UpvarCapture::ByValue\n                     }\n                     hir::CaptureByRef => {\n-                        let origin = UpvarRegion(upvar_id, expr.span);\n-                        let freevar_region = self.fcx.next_region_var(origin);\n+                        let origin = UpvarRegion(upvar_id, span);\n+                        let freevar_region = self.next_region_var(origin);\n                         let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n                                                              region: freevar_region };\n                         ty::UpvarCapture::ByRef(upvar_borrow)\n                     }\n                 };\n \n-                self.fcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n+                self.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n             }\n         });\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// ADJUST BORROW KIND\n-\n-struct AdjustBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n-}\n-\n-impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n-    fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-           temp_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>)\n-           -> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n-        AdjustBorrowKind { fcx: fcx, temp_closure_kinds: temp_closure_kinds }\n-    }\n-\n-    fn analyze_closure(&mut self,\n-                       id: ast::NodeId,\n-                       span: Span,\n-                       body: &hir::Body) {\n-        /*!\n-         * Analysis starting point.\n-         */\n-\n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n \n         {\n-            let body_owner_def_id = self.fcx.tcx.hir.body_owner_def_id(body.id());\n-            let region_maps = &self.fcx.tcx.region_maps(body_owner_def_id);\n-            let param_env = self.fcx.param_env;\n-            let mut euv =\n-                euv::ExprUseVisitor::with_options(self,\n-                                                  self.fcx,\n-                                                  param_env,\n-                                                  region_maps,\n-                                                  mc::MemCategorizationOptions {\n-                                                      during_closure_kind_inference: true\n-                                                  });\n-            euv.consume_body(body);\n+            let body_owner_def_id = self.tcx.hir.body_owner_def_id(body.id());\n+            let region_maps = &self.tcx.region_maps(body_owner_def_id);\n+            let mut delegate = InferBorrowKind {\n+                fcx: self,\n+                adjust_closure_kinds: NodeMap(),\n+                adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n+            };\n+            euv::ExprUseVisitor::with_infer(&mut delegate,\n+                                            &self.infcx,\n+                                            self.param_env,\n+                                            region_maps,\n+                                            &self.tables.borrow())\n+                .consume_body(body);\n+\n+            // Write the adjusted values back into the main tables.\n+            if infer_kind {\n+                if let Some(kind) = delegate.adjust_closure_kinds.remove(&id) {\n+                    self.tables.borrow_mut().closure_kinds.insert(id, kind);\n+                }\n+            }\n+            self.tables.borrow_mut().upvar_capture_map.extend(\n+                delegate.adjust_upvar_captures);\n         }\n \n         // Now that we've analyzed the closure, we know how each\n@@ -191,7 +172,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Extract the type variables UV0...UVn.\n-        let (def_id, closure_substs) = match self.fcx.node_ty(id).sty {\n+        let (def_id, closure_substs) = match self.node_ty(id).sty {\n             ty::TyClosure(def_id, substs) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n@@ -206,44 +187,41 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n                id, closure_substs, final_upvar_tys);\n         for (upvar_ty, final_upvar_ty) in\n-            closure_substs.upvar_tys(def_id, self.fcx.tcx).zip(final_upvar_tys)\n+            closure_substs.upvar_tys(def_id, self.tcx).zip(final_upvar_tys)\n         {\n-            self.fcx.demand_eqtype(span, final_upvar_ty, upvar_ty);\n+            self.demand_eqtype(span, final_upvar_ty, upvar_ty);\n         }\n \n-        // If we are also inferred the closure kind here, update the\n-        // main table and process any deferred resolutions.\n-        if let Some(&(kind, context)) = self.temp_closure_kinds.get(&id) {\n-            self.fcx.tables.borrow_mut().closure_kinds.insert(id, (kind, context));\n-            let closure_def_id = self.fcx.tcx.hir.local_def_id(id);\n-            debug!(\"closure_kind({:?}) = {:?}\", closure_def_id, kind);\n-\n+        // If we are also inferred the closure kind here,\n+        // process any deferred resolutions.\n+        if infer_kind {\n+            let closure_def_id = self.tcx.hir.local_def_id(id);\n             let deferred_call_resolutions =\n-                self.fcx.remove_deferred_call_resolutions(closure_def_id);\n+                self.remove_deferred_call_resolutions(closure_def_id);\n             for deferred_call_resolution in deferred_call_resolutions {\n-                deferred_call_resolution.resolve(self.fcx);\n+                deferred_call_resolution.resolve(self);\n             }\n         }\n     }\n \n     // Returns a list of `ClosureUpvar`s for each upvar.\n-    fn final_upvar_tys(&mut self, closure_id: ast::NodeId) -> Vec<Ty<'tcx>> {\n+    fn final_upvar_tys(&self, closure_id: ast::NodeId) -> Vec<Ty<'tcx>> {\n         // Presently an unboxed closure type cannot \"escape\" out of a\n         // function, so we will only encounter ones that originated in the\n         // local crate or were inlined into it along with some function.\n         // This may change if abstract return types of some sort are\n         // implemented.\n-        let tcx = self.fcx.tcx;\n+        let tcx = self.tcx;\n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter().map(|freevar| {\n                 let def_id = freevar.def.def_id();\n                 let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                let freevar_ty = self.fcx.node_ty(var_id);\n+                let freevar_ty = self.node_ty(var_id);\n                 let upvar_id = ty::UpvarId {\n                     var_id: var_id,\n                     closure_expr_id: closure_id\n                 };\n-                let capture = self.fcx.upvar_capture(upvar_id).unwrap();\n+                let capture = self.tables.borrow().upvar_capture(upvar_id);\n \n                 debug!(\"var_id={:?} freevar_ty={:?} capture={:?}\",\n                        var_id, freevar_ty, capture);\n@@ -260,7 +238,15 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n             }).collect()\n         })\n     }\n+}\n \n+struct InferBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+    adjust_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n+    adjust_upvar_captures: ty::UpvarCaptureMap<'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     fn adjust_upvar_borrow_kind_for_consume(&mut self,\n                                             cmt: mc::cmt<'tcx>,\n                                             mode: euv::ConsumeMode)\n@@ -297,9 +283,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                                                  guarantor.span,\n                                                  tcx.hir.name(upvar_id.var_id));\n \n-                        let upvar_capture_map =\n-                            &mut self.fcx.tables.borrow_mut().upvar_capture_map;\n-                        upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n+                        self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n                     mc::NoteClosureEnv(upvar_id) => {\n                         // we get just a closureenv ref if this is a\n@@ -410,11 +394,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                 // upvar, then we need to modify the\n                 // borrow_kind of the upvar to make sure it\n                 // is inferred to mutable if necessary\n-                {\n-                    let upvar_capture_map = &mut self.fcx.tables.borrow_mut().upvar_capture_map;\n-                    let ub = upvar_capture_map.get_mut(&upvar_id).unwrap();\n-                    self.adjust_upvar_borrow_kind(upvar_id, ub, borrow_kind);\n-                }\n+                self.adjust_upvar_borrow_kind(upvar_id, borrow_kind);\n \n                 // also need to be in an FnMut closure since this is not an ImmBorrow\n                 self.adjust_closure_kind(upvar_id.closure_expr_id,\n@@ -448,22 +428,25 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     /// some particular use.\n     fn adjust_upvar_borrow_kind(&mut self,\n                                 upvar_id: ty::UpvarId,\n-                                upvar_capture: &mut ty::UpvarCapture,\n                                 kind: ty::BorrowKind) {\n+        let upvar_capture = self.adjust_upvar_captures.get(&upvar_id).cloned()\n+            .unwrap_or_else(|| self.fcx.tables.borrow().upvar_capture(upvar_id));\n         debug!(\"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n                upvar_id, upvar_capture, kind);\n \n-        match *upvar_capture {\n+        match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n                 // Upvar is already by-value, the strongest criteria.\n             }\n-            ty::UpvarCapture::ByRef(ref mut upvar_borrow) => {\n+            ty::UpvarCapture::ByRef(mut upvar_borrow) => {\n                 match (upvar_borrow.kind, kind) {\n                     // Take RHS:\n                     (ty::ImmBorrow, ty::UniqueImmBorrow) |\n                     (ty::ImmBorrow, ty::MutBorrow) |\n                     (ty::UniqueImmBorrow, ty::MutBorrow) => {\n                         upvar_borrow.kind = kind;\n+                        self.adjust_upvar_captures.insert(upvar_id,\n+                            ty::UpvarCapture::ByRef(upvar_borrow));\n                     }\n                     // Take LHS:\n                     (ty::ImmBorrow, ty::ImmBorrow) |\n@@ -484,7 +467,9 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n                closure_id, new_kind, upvar_span, var_name);\n \n-        if let Some(&(existing_kind, _)) = self.temp_closure_kinds.get(&closure_id) {\n+        let closure_kind = self.adjust_closure_kinds.get(&closure_id).cloned()\n+            .or_else(|| self.fcx.tables.borrow().closure_kinds.get(&closure_id).cloned());\n+        if let Some((existing_kind, _)) = closure_kind {\n             debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n                    closure_id, existing_kind, new_kind);\n \n@@ -500,7 +485,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n                 (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n                 (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n                     // new kind is stronger than the old kind\n-                    self.temp_closure_kinds.insert(\n+                    self.adjust_closure_kinds.insert(\n                         closure_id,\n                         (new_kind, Some((upvar_span, var_name)))\n                     );\n@@ -510,27 +495,7 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'gcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_fn(&mut self,\n-                fn_kind: intravisit::FnKind<'gcx>,\n-                decl: &'gcx hir::FnDecl,\n-                body: hir::BodyId,\n-                span: Span,\n-                id: ast::NodeId)\n-    {\n-        intravisit::walk_fn(self, fn_kind, decl, body, span, id);\n-\n-        let body = self.fcx.tcx.hir.body(body);\n-        self.visit_body(body);\n-        self.analyze_closure(id, span, body);\n-    }\n-}\n-\n-impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for AdjustBorrowKind<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n     fn consume(&mut self,\n                _consume_id: ast::NodeId,\n                _consume_span: Span,"}, {"sha": "ccbc02990418f2b89088f5b1d20c7ae891de25e5", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -208,7 +208,7 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            source,\n            target);\n \n-    tcx.infer_ctxt(()).enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let cause = ObligationCause::misc(span, impl_node_id);\n         let check_mutbl = |mt_a: ty::TypeAndMut<'tcx>,\n                            mt_b: ty::TypeAndMut<'tcx>,"}, {"sha": "078ae34bc524c41cc9830964b1a35955d52d6aff", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i + 1)..] {\n-                self.tcx.infer_ctxt(()).enter(|infcx| {\n+                self.tcx.infer_ctxt().enter(|infcx| {\n                     if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n                     }"}, {"sha": "26ea3ab3a3358aa3d5f30c083b83205155ffbdc2", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7613f82814e803bf75c074ae4e50a584fee3e70/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b7613f82814e803bf75c074ae4e50a584fee3e70", "patch": "@@ -155,7 +155,7 @@ fn require_same_types<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 expected: Ty<'tcx>,\n                                 actual: Ty<'tcx>)\n                                 -> bool {\n-    tcx.infer_ctxt(()).enter(|ref infcx| {\n+    tcx.infer_ctxt().enter(|ref infcx| {\n         let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n         let mut fulfill_cx = FulfillmentContext::new();\n         match infcx.at(&cause, param_env).eq(expected, actual) {"}]}