{"sha": "ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMGYwZmMzMWU4NGRlYjdhZWJmOGFiNmVjNTEwMDUxZDUzMWM5ZjI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-02-06T15:27:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-02-06T15:27:23Z"}, "message": "Merge #3031\n\n3031: Move imports locator to ide_db r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "696f118a3555b446f930becee802574e344d1afc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/696f118a3555b446f930becee802574e344d1afc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJePDBbCRBK7hj4Ov3rIwAAdHIIAIGaCL/ZHD9QY4YCUCv1hKh9\nENArrcRIWzaS5JlBFBp9W6+PYAnUovYLlOqaN4zZBHF64l9dylvF9znXdDNcVH/K\nBBYrXXbABhOuRoHZ/6GNozbIoABnZ/8lVLIbfXiG/xRsQUO8SRX3Y+pPzwZ0GnoP\n4Qf10ZjvV8v1INF5qw9WfVMWZpOe9wBejlt6cIXfm1FEOg1jc0hLLCA2+avvlNNh\nmPPt3KfafuYo8TVJkcOLfkJSIcxHIAxLo99963Vf6wSRC70dLbE1ARvcgBsV6jnP\nHebXyg7Ul96jzku+O6QR9Izb/52WVa32bw1ebAkmighu4jQC7ih1IsyiD4nyWR0=\n=uRqy\n-----END PGP SIGNATURE-----\n", "payload": "tree 696f118a3555b446f930becee802574e344d1afc\nparent aa571e378b67134903a66094cf9aa7b2ce7118e8\nparent dfbe96750b69fc69e64f3a6094e2c1d574ab42fa\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1581002843 +0000\ncommitter GitHub <noreply@github.com> 1581002843 +0000\n\nMerge #3031\n\n3031: Move imports locator to ide_db r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "html_url": "https://github.com/rust-lang/rust/commit/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa571e378b67134903a66094cf9aa7b2ce7118e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa571e378b67134903a66094cf9aa7b2ce7118e8", "html_url": "https://github.com/rust-lang/rust/commit/aa571e378b67134903a66094cf9aa7b2ce7118e8"}, {"sha": "dfbe96750b69fc69e64f3a6094e2c1d574ab42fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/dfbe96750b69fc69e64f3a6094e2c1d574ab42fa", "html_url": "https://github.com/rust-lang/rust/commit/dfbe96750b69fc69e64f3a6094e2c1d574ab42fa"}], "stats": {"total": 526, "additions": 264, "deletions": 262}, "files": [{"sha": "4a7d8cfa95a54008e284440d2ea3b9a102d0819d", "filename": "crates/ra_ide/src/assists.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fassists.rs?ref=ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "patch": "@@ -3,9 +3,9 @@\n use either::Either;\n use ra_assists::{AssistAction, AssistLabel};\n use ra_db::{FilePosition, FileRange};\n-use ra_ide_db::RootDatabase;\n+use ra_ide_db::{imports_locator::ImportsLocatorIde, RootDatabase};\n \n-use crate::{imports_locator::ImportsLocatorIde, FileId, SourceChange, SourceFileEdit};\n+use crate::{FileId, SourceChange, SourceFileEdit};\n \n pub use ra_assists::AssistId;\n "}, {"sha": "689921f3f235666208d7f666d689ee2308db6a6a", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "patch": "@@ -26,7 +26,6 @@ mod syntax_highlighting;\n mod parent_module;\n mod references;\n mod impls;\n-mod imports_locator;\n mod assists;\n mod diagnostics;\n mod syntax_tree;"}, {"sha": "c215040f4711873f77587f0c64a2ca997e7f115e", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "patch": "@@ -10,7 +10,6 @@\n //! resolved to the search element definition, we get a reference.\n \n mod classify;\n-mod name_definition;\n mod rename;\n mod search_scope;\n \n@@ -29,9 +28,9 @@ use crate::{display::ToNav, FilePosition, FileRange, NavigationTarget, RangeInfo\n \n pub(crate) use self::{\n     classify::{classify_name, classify_name_ref},\n-    name_definition::{NameDefinition, NameKind},\n     rename::rename,\n };\n+pub(crate) use ra_ide_db::defs::{NameDefinition, NameKind};\n \n pub use self::search_scope::SearchScope;\n \n@@ -137,7 +136,7 @@ pub(crate) fn find_all_refs(\n     };\n \n     let search_scope = {\n-        let base = def.search_scope(db);\n+        let base = SearchScope::for_def(&def, db);\n         match search_scope {\n             None => base,\n             Some(scope) => base.intersection(&scope),"}, {"sha": "0326fd379eed523281a67253b7251681206ddd42", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 3, "deletions": 109, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "patch": "@@ -2,119 +2,13 @@\n \n use hir::{InFile, PathResolution, SourceBinder};\n use ra_prof::profile;\n-use ra_syntax::{ast, match_ast, AstNode};\n+use ra_syntax::{ast, AstNode};\n use test_utils::tested_by;\n \n-use super::{\n-    name_definition::{from_assoc_item, from_module_def, from_struct_field},\n-    NameDefinition, NameKind,\n-};\n+use super::{NameDefinition, NameKind};\n use ra_ide_db::RootDatabase;\n \n-pub(crate) fn classify_name(\n-    sb: &mut SourceBinder<RootDatabase>,\n-    name: InFile<&ast::Name>,\n-) -> Option<NameDefinition> {\n-    let _p = profile(\"classify_name\");\n-    let parent = name.value.syntax().parent()?;\n-\n-    match_ast! {\n-        match parent {\n-            ast::BindPat(it) => {\n-                let src = name.with_value(it);\n-                let local = sb.to_def(src)?;\n-                Some(NameDefinition {\n-                    visibility: None,\n-                    container: local.module(sb.db),\n-                    kind: NameKind::Local(local),\n-                })\n-            },\n-            ast::RecordFieldDef(it) => {\n-                let src = name.with_value(it);\n-                let field: hir::StructField = sb.to_def(src)?;\n-                Some(from_struct_field(sb.db, field))\n-            },\n-            ast::Module(it) => {\n-                let def = sb.to_def(name.with_value(it))?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::StructDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Struct = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::EnumDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Enum = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::TraitDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Trait = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::StaticDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Static = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::EnumVariant(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::EnumVariant = sb.to_def(src)?;\n-                Some(from_module_def(sb.db, def.into(), None))\n-            },\n-            ast::FnDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Function = sb.to_def(src)?;\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(sb.db, def.into()))\n-                } else {\n-                    Some(from_module_def(sb.db, def.into(), None))\n-                }\n-            },\n-            ast::ConstDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::Const = sb.to_def(src)?;\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(sb.db, def.into()))\n-                } else {\n-                    Some(from_module_def(sb.db, def.into(), None))\n-                }\n-            },\n-            ast::TypeAliasDef(it) => {\n-                let src = name.with_value(it);\n-                let def: hir::TypeAlias = sb.to_def(src)?;\n-                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n-                    Some(from_assoc_item(sb.db, def.into()))\n-                } else {\n-                    Some(from_module_def(sb.db, def.into(), None))\n-                }\n-            },\n-            ast::MacroCall(it) => {\n-                let src = name.with_value(it);\n-                let def = sb.to_def(src.clone())?;\n-\n-                let module = sb.to_module_def(src.file_id.original_file(sb.db))?;\n-\n-                Some(NameDefinition {\n-                    visibility: None,\n-                    container: module,\n-                    kind: NameKind::Macro(def),\n-                })\n-            },\n-            ast::TypeParam(it) => {\n-                let src = name.with_value(it);\n-                let def = sb.to_def(src)?;\n-                Some(NameDefinition {\n-                    visibility: None,\n-                    container: def.module(sb.db),\n-                    kind: NameKind::TypeParam(def),\n-                })\n-            },\n-            _ => None,\n-        }\n-    }\n-}\n+pub use ra_ide_db::defs::{classify_name, from_assoc_item, from_module_def, from_struct_field};\n \n pub(crate) fn classify_name_ref(\n     sb: &mut SourceBinder<RootDatabase>,"}, {"sha": "71565e6d395d8031a1ca60ea9e6c855886eff28d", "filename": "crates/ra_ide/src/references/name_definition.rs", "status": "removed", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/aa571e378b67134903a66094cf9aa7b2ce7118e8/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa571e378b67134903a66094cf9aa7b2ce7118e8/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs?ref=aa571e378b67134903a66094cf9aa7b2ce7118e8", "patch": "@@ -1,85 +0,0 @@\n-//! `NameDefinition` keeps information about the element we want to search references for.\n-//! The element is represented by `NameKind`. It's located inside some `container` and\n-//! has a `visibility`, which defines a search scope.\n-//! Note that the reference search is possible for not all of the classified items.\n-\n-use hir::{\n-    Adt, AssocItem, HasSource, ImplBlock, Local, MacroDef, Module, ModuleDef, StructField,\n-    TypeParam, VariantDef,\n-};\n-use ra_syntax::{ast, ast::VisibilityOwner};\n-\n-use ra_ide_db::RootDatabase;\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub enum NameKind {\n-    Macro(MacroDef),\n-    Field(StructField),\n-    AssocItem(AssocItem),\n-    Def(ModuleDef),\n-    SelfType(ImplBlock),\n-    Local(Local),\n-    TypeParam(TypeParam),\n-}\n-\n-#[derive(PartialEq, Eq)]\n-pub(crate) struct NameDefinition {\n-    pub visibility: Option<ast::Visibility>,\n-    /// FIXME: this doesn't really make sense. For example, builtin types don't\n-    /// really have a module.\n-    pub container: Module,\n-    pub kind: NameKind,\n-}\n-\n-pub(super) fn from_assoc_item(db: &RootDatabase, item: AssocItem) -> NameDefinition {\n-    let container = item.module(db);\n-    let visibility = match item {\n-        AssocItem::Function(f) => f.source(db).value.visibility(),\n-        AssocItem::Const(c) => c.source(db).value.visibility(),\n-        AssocItem::TypeAlias(a) => a.source(db).value.visibility(),\n-    };\n-    let kind = NameKind::AssocItem(item);\n-    NameDefinition { kind, container, visibility }\n-}\n-\n-pub(super) fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDefinition {\n-    let kind = NameKind::Field(field);\n-    let parent = field.parent_def(db);\n-    let container = parent.module(db);\n-    let visibility = match parent {\n-        VariantDef::Struct(s) => s.source(db).value.visibility(),\n-        VariantDef::Union(e) => e.source(db).value.visibility(),\n-        VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n-    };\n-    NameDefinition { kind, container, visibility }\n-}\n-\n-pub(super) fn from_module_def(\n-    db: &RootDatabase,\n-    def: ModuleDef,\n-    module: Option<Module>,\n-) -> NameDefinition {\n-    let kind = NameKind::Def(def);\n-    let (container, visibility) = match def {\n-        ModuleDef::Module(it) => {\n-            let container = it.parent(db).or_else(|| Some(it)).unwrap();\n-            let visibility = it.declaration_source(db).and_then(|s| s.value.visibility());\n-            (container, visibility)\n-        }\n-        ModuleDef::EnumVariant(it) => {\n-            let container = it.module(db);\n-            let visibility = it.source(db).value.parent_enum().visibility();\n-            (container, visibility)\n-        }\n-        ModuleDef::Function(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Const(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Static(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Trait(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).value.visibility()),\n-        ModuleDef::BuiltinType(..) => (module.unwrap(), None),\n-    };\n-    NameDefinition { kind, container, visibility }\n-}"}, {"sha": "279f57be06a1c6f884032f80b60465eba16ec7c1", "filename": "crates/ra_ide/src/references/search_scope.rs", "status": "modified", "additions": 50, "deletions": 52, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fsearch_scope.rs?ref=ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "patch": "@@ -19,59 +19,13 @@ pub struct SearchScope {\n }\n \n impl SearchScope {\n-    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n-        SearchScope { entries }\n-    }\n-    pub fn single_file(file: FileId) -> SearchScope {\n-        SearchScope::new(std::iter::once((file, None)).collect())\n-    }\n-    pub(crate) fn intersection(&self, other: &SearchScope) -> SearchScope {\n-        let (mut small, mut large) = (&self.entries, &other.entries);\n-        if small.len() > large.len() {\n-            mem::swap(&mut small, &mut large)\n-        }\n-\n-        let res = small\n-            .iter()\n-            .filter_map(|(file_id, r1)| {\n-                let r2 = large.get(file_id)?;\n-                let r = intersect_ranges(*r1, *r2)?;\n-                Some((*file_id, r))\n-            })\n-            .collect();\n-        return SearchScope::new(res);\n-\n-        fn intersect_ranges(\n-            r1: Option<TextRange>,\n-            r2: Option<TextRange>,\n-        ) -> Option<Option<TextRange>> {\n-            match (r1, r2) {\n-                (None, r) | (r, None) => Some(r),\n-                (Some(r1), Some(r2)) => {\n-                    let r = r1.intersection(&r2)?;\n-                    Some(Some(r))\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl IntoIterator for SearchScope {\n-    type Item = (FileId, Option<TextRange>);\n-    type IntoIter = std::collections::hash_map::IntoIter<FileId, Option<TextRange>>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.entries.into_iter()\n-    }\n-}\n-\n-impl NameDefinition {\n-    pub(crate) fn search_scope(&self, db: &RootDatabase) -> SearchScope {\n+    pub(crate) fn for_def(def: &NameDefinition, db: &RootDatabase) -> SearchScope {\n         let _p = profile(\"search_scope\");\n \n-        let module_src = self.container.definition_source(db);\n+        let module_src = def.container.definition_source(db);\n         let file_id = module_src.file_id.original_file(db);\n \n-        if let NameKind::Local(var) = self.kind {\n+        if let NameKind::Local(var) = def.kind {\n             let range = match var.parent(db) {\n                 DefWithBody::Function(f) => f.source(db).value.syntax().text_range(),\n                 DefWithBody::Const(c) => c.source(db).value.syntax().text_range(),\n@@ -82,10 +36,10 @@ impl NameDefinition {\n             return SearchScope::new(res);\n         }\n \n-        let vis = self.visibility.as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n+        let vis = def.visibility.as_ref().map(|v| v.syntax().to_string()).unwrap_or_default();\n \n         if vis.as_str() == \"pub(super)\" {\n-            if let Some(parent_module) = self.container.parent(db) {\n+            if let Some(parent_module) = def.container.parent(db) {\n                 let mut res = FxHashMap::default();\n                 let parent_src = parent_module.definition_source(db);\n                 let file_id = parent_src.file_id.original_file(db);\n@@ -118,7 +72,7 @@ impl NameDefinition {\n                 return SearchScope::new(res);\n             }\n             if vis.as_str() == \"pub\" {\n-                let krate = self.container.krate();\n+                let krate = def.container.krate();\n                 for rev_dep in krate.reverse_dependencies(db) {\n                     let root_file = rev_dep.root_file(db);\n                     let source_root_id = db.file_source_root(root_file);\n@@ -137,4 +91,48 @@ impl NameDefinition {\n         res.insert(file_id, range);\n         SearchScope::new(res)\n     }\n+\n+    fn new(entries: FxHashMap<FileId, Option<TextRange>>) -> SearchScope {\n+        SearchScope { entries }\n+    }\n+    pub fn single_file(file: FileId) -> SearchScope {\n+        SearchScope::new(std::iter::once((file, None)).collect())\n+    }\n+    pub(crate) fn intersection(&self, other: &SearchScope) -> SearchScope {\n+        let (mut small, mut large) = (&self.entries, &other.entries);\n+        if small.len() > large.len() {\n+            mem::swap(&mut small, &mut large)\n+        }\n+\n+        let res = small\n+            .iter()\n+            .filter_map(|(file_id, r1)| {\n+                let r2 = large.get(file_id)?;\n+                let r = intersect_ranges(*r1, *r2)?;\n+                Some((*file_id, r))\n+            })\n+            .collect();\n+        return SearchScope::new(res);\n+\n+        fn intersect_ranges(\n+            r1: Option<TextRange>,\n+            r2: Option<TextRange>,\n+        ) -> Option<Option<TextRange>> {\n+            match (r1, r2) {\n+                (None, r) | (r, None) => Some(r),\n+                (Some(r1), Some(r2)) => {\n+                    let r = r1.intersection(&r2)?;\n+                    Some(Some(r))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl IntoIterator for SearchScope {\n+    type Item = (FileId, Option<TextRange>);\n+    type IntoIter = std::collections::hash_map::IntoIter<FileId, Option<TextRange>>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.entries.into_iter()\n+    }\n }"}, {"sha": "cee6dde8e0dc248bcde3f097245a8249846c20ad", "filename": "crates/ra_ide_db/src/defs.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fdefs.rs?ref=ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "patch": "@@ -0,0 +1,196 @@\n+//! `NameDefinition` keeps information about the element we want to search references for.\n+//! The element is represented by `NameKind`. It's located inside some `container` and\n+//! has a `visibility`, which defines a search scope.\n+//! Note that the reference search is possible for not all of the classified items.\n+\n+// FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n+\n+use hir::{\n+    Adt, AssocItem, HasSource, ImplBlock, InFile, Local, MacroDef, Module, ModuleDef, SourceBinder,\n+    StructField, TypeParam, VariantDef,\n+};\n+use ra_prof::profile;\n+use ra_syntax::{\n+    ast::{self, AstNode, VisibilityOwner},\n+    match_ast,\n+};\n+\n+use crate::RootDatabase;\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum NameKind {\n+    Macro(MacroDef),\n+    Field(StructField),\n+    AssocItem(AssocItem),\n+    Def(ModuleDef),\n+    SelfType(ImplBlock),\n+    Local(Local),\n+    TypeParam(TypeParam),\n+}\n+\n+#[derive(PartialEq, Eq)]\n+pub struct NameDefinition {\n+    pub visibility: Option<ast::Visibility>,\n+    /// FIXME: this doesn't really make sense. For example, builtin types don't\n+    /// really have a module.\n+    pub container: Module,\n+    pub kind: NameKind,\n+}\n+\n+pub fn classify_name(\n+    sb: &mut SourceBinder<RootDatabase>,\n+    name: InFile<&ast::Name>,\n+) -> Option<NameDefinition> {\n+    let _p = profile(\"classify_name\");\n+    let parent = name.value.syntax().parent()?;\n+\n+    match_ast! {\n+        match parent {\n+            ast::BindPat(it) => {\n+                let src = name.with_value(it);\n+                let local = sb.to_def(src)?;\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: local.module(sb.db),\n+                    kind: NameKind::Local(local),\n+                })\n+            },\n+            ast::RecordFieldDef(it) => {\n+                let src = name.with_value(it);\n+                let field: hir::StructField = sb.to_def(src)?;\n+                Some(from_struct_field(sb.db, field))\n+            },\n+            ast::Module(it) => {\n+                let def = sb.to_def(name.with_value(it))?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::StructDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Struct = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::EnumDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Enum = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::TraitDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Trait = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::StaticDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Static = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::EnumVariant(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::EnumVariant = sb.to_def(src)?;\n+                Some(from_module_def(sb.db, def.into(), None))\n+            },\n+            ast::FnDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Function = sb.to_def(src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(sb.db, def.into()))\n+                } else {\n+                    Some(from_module_def(sb.db, def.into(), None))\n+                }\n+            },\n+            ast::ConstDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::Const = sb.to_def(src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(sb.db, def.into()))\n+                } else {\n+                    Some(from_module_def(sb.db, def.into(), None))\n+                }\n+            },\n+            ast::TypeAliasDef(it) => {\n+                let src = name.with_value(it);\n+                let def: hir::TypeAlias = sb.to_def(src)?;\n+                if parent.parent().and_then(ast::ItemList::cast).is_some() {\n+                    Some(from_assoc_item(sb.db, def.into()))\n+                } else {\n+                    Some(from_module_def(sb.db, def.into(), None))\n+                }\n+            },\n+            ast::MacroCall(it) => {\n+                let src = name.with_value(it);\n+                let def = sb.to_def(src.clone())?;\n+\n+                let module = sb.to_module_def(src.file_id.original_file(sb.db))?;\n+\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: module,\n+                    kind: NameKind::Macro(def),\n+                })\n+            },\n+            ast::TypeParam(it) => {\n+                let src = name.with_value(it);\n+                let def = sb.to_def(src)?;\n+                Some(NameDefinition {\n+                    visibility: None,\n+                    container: def.module(sb.db),\n+                    kind: NameKind::TypeParam(def),\n+                })\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub fn from_assoc_item(db: &RootDatabase, item: AssocItem) -> NameDefinition {\n+    let container = item.module(db);\n+    let visibility = match item {\n+        AssocItem::Function(f) => f.source(db).value.visibility(),\n+        AssocItem::Const(c) => c.source(db).value.visibility(),\n+        AssocItem::TypeAlias(a) => a.source(db).value.visibility(),\n+    };\n+    let kind = NameKind::AssocItem(item);\n+    NameDefinition { kind, container, visibility }\n+}\n+\n+pub fn from_struct_field(db: &RootDatabase, field: StructField) -> NameDefinition {\n+    let kind = NameKind::Field(field);\n+    let parent = field.parent_def(db);\n+    let container = parent.module(db);\n+    let visibility = match parent {\n+        VariantDef::Struct(s) => s.source(db).value.visibility(),\n+        VariantDef::Union(e) => e.source(db).value.visibility(),\n+        VariantDef::EnumVariant(e) => e.source(db).value.parent_enum().visibility(),\n+    };\n+    NameDefinition { kind, container, visibility }\n+}\n+\n+pub fn from_module_def(\n+    db: &RootDatabase,\n+    def: ModuleDef,\n+    module: Option<Module>,\n+) -> NameDefinition {\n+    let kind = NameKind::Def(def);\n+    let (container, visibility) = match def {\n+        ModuleDef::Module(it) => {\n+            let container = it.parent(db).or_else(|| Some(it)).unwrap();\n+            let visibility = it.declaration_source(db).and_then(|s| s.value.visibility());\n+            (container, visibility)\n+        }\n+        ModuleDef::EnumVariant(it) => {\n+            let container = it.module(db);\n+            let visibility = it.source(db).value.parent_enum().visibility();\n+            (container, visibility)\n+        }\n+        ModuleDef::Function(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Const(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Static(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Trait(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::TypeAlias(it) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Struct(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Union(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::Adt(Adt::Enum(it)) => (it.module(db), it.source(db).value.visibility()),\n+        ModuleDef::BuiltinType(..) => (module.unwrap(), None),\n+    };\n+    NameDefinition { kind, container, visibility }\n+}"}, {"sha": "21e6376085686348b8fdd360e028d2bb913cd182", "filename": "crates/ra_ide_db/src/imports_locator.rs", "status": "renamed", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fimports_locator.rs?ref=ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "patch": "@@ -3,32 +3,30 @@\n \n use hir::{db::HirDatabase, ModuleDef, SourceBinder};\n use ra_assists::ImportsLocator;\n-use ra_ide_db::{\n-    symbol_index::{self, FileSymbol},\n-    RootDatabase,\n-};\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, SyntaxKind::NAME};\n \n use crate::{\n-    references::{classify_name, NameDefinition, NameKind},\n-    Query,\n+    defs::classify_name,\n+    defs::NameKind,\n+    symbol_index::{self, FileSymbol, Query},\n+    RootDatabase,\n };\n \n-pub(crate) struct ImportsLocatorIde<'a> {\n+pub struct ImportsLocatorIde<'a> {\n     source_binder: SourceBinder<'a, RootDatabase>,\n }\n \n impl<'a> ImportsLocatorIde<'a> {\n-    pub(crate) fn new(db: &'a RootDatabase) -> Self {\n+    pub fn new(db: &'a RootDatabase) -> Self {\n         Self { source_binder: SourceBinder::new(db) }\n     }\n \n     fn get_name_definition(\n         &mut self,\n         db: &impl HirDatabase,\n         import_candidate: &FileSymbol,\n-    ) -> Option<NameDefinition> {\n+    ) -> Option<NameKind> {\n         let _p = profile(\"get_name_definition\");\n         let file_id = import_candidate.file_id.into();\n         let candidate_node = import_candidate.ptr.to_node(&db.parse_or_expand(file_id)?);\n@@ -41,6 +39,7 @@ impl<'a> ImportsLocatorIde<'a> {\n             &mut self.source_binder,\n             hir::InFile { file_id, value: &ast::Name::cast(candidate_name_node)? },\n         )\n+        .map(|it| it.kind)\n     }\n }\n \n@@ -67,7 +66,7 @@ impl ImportsLocator for ImportsLocatorIde<'_> {\n             .into_iter()\n             .chain(lib_results.into_iter())\n             .filter_map(|import_candidate| self.get_name_definition(db, &import_candidate))\n-            .filter_map(|name_definition_to_import| match name_definition_to_import.kind {\n+            .filter_map(|name_definition_to_import| match name_definition_to_import {\n                 NameKind::Def(module_def) => Some(module_def),\n                 _ => None,\n             })", "previous_filename": "crates/ra_ide/src/imports_locator.rs"}, {"sha": "877ac3c38e3cf24402f4189918d6d7dea8aac867", "filename": "crates/ra_ide_db/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2/crates%2Fra_ide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Flib.rs?ref=ff0f0fc31e84deb7aebf8ab6ec510051d531c9f2", "patch": "@@ -7,6 +7,8 @@ pub mod line_index_utils;\n pub mod feature_flags;\n pub mod symbol_index;\n pub mod change;\n+pub mod defs;\n+pub mod imports_locator;\n mod wasm_shims;\n \n use std::sync::Arc;"}]}