{"sha": "3be2c3b3092e934bdc2db67d5bdcabd611deca9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZTJjM2IzMDkyZTkzNGJkYzJkYjY3ZDViZGNhYmQ2MTFkZWNhOWM=", "commit": {"author": {"name": "Ruud van Asseldonk", "email": "dev@veniogames.com", "date": "2016-11-12T14:58:58Z"}, "committer": {"name": "Ruud van Asseldonk", "email": "dev@veniogames.com", "date": "2016-11-30T10:09:29Z"}, "message": "Move small-copy optimization into <&[u8] as Read>\n\nBased on the discussion in https://github.com/rust-lang/rust/pull/37573,\nit is likely better to keep this limited to std::io, instead of\nmodifying a function which users expect to be a memcpy.", "tree": {"sha": "c52d41e6d87f47378f9b93e5bd62b34c6e1172f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c52d41e6d87f47378f9b93e5bd62b34c6e1172f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3be2c3b3092e934bdc2db67d5bdcabd611deca9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3be2c3b3092e934bdc2db67d5bdcabd611deca9c", "html_url": "https://github.com/rust-lang/rust/commit/3be2c3b3092e934bdc2db67d5bdcabd611deca9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3be2c3b3092e934bdc2db67d5bdcabd611deca9c/comments", "author": {"login": "ruuda", "id": 506953, "node_id": "MDQ6VXNlcjUwNjk1Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/506953?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ruuda", "html_url": "https://github.com/ruuda", "followers_url": "https://api.github.com/users/ruuda/followers", "following_url": "https://api.github.com/users/ruuda/following{/other_user}", "gists_url": "https://api.github.com/users/ruuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/ruuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ruuda/subscriptions", "organizations_url": "https://api.github.com/users/ruuda/orgs", "repos_url": "https://api.github.com/users/ruuda/repos", "events_url": "https://api.github.com/users/ruuda/events{/privacy}", "received_events_url": "https://api.github.com/users/ruuda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ruuda", "id": 506953, "node_id": "MDQ6VXNlcjUwNjk1Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/506953?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ruuda", "html_url": "https://github.com/ruuda", "followers_url": "https://api.github.com/users/ruuda/followers", "following_url": "https://api.github.com/users/ruuda/following{/other_user}", "gists_url": "https://api.github.com/users/ruuda/gists{/gist_id}", "starred_url": "https://api.github.com/users/ruuda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ruuda/subscriptions", "organizations_url": "https://api.github.com/users/ruuda/orgs", "repos_url": "https://api.github.com/users/ruuda/repos", "events_url": "https://api.github.com/users/ruuda/events{/privacy}", "received_events_url": "https://api.github.com/users/ruuda/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "341805288e8a055162bef64055a7962ecffbf103", "url": "https://api.github.com/repos/rust-lang/rust/commits/341805288e8a055162bef64055a7962ecffbf103", "html_url": "https://github.com/rust-lang/rust/commit/341805288e8a055162bef64055a7962ecffbf103"}], "stats": {"total": 38, "additions": 23, "deletions": 15}, "files": [{"sha": "a4a90e7a9da7a3bc80df580ea4b86bf25d054e5d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3be2c3b3092e934bdc2db67d5bdcabd611deca9c/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3be2c3b3092e934bdc2db67d5bdcabd611deca9c/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=3be2c3b3092e934bdc2db67d5bdcabd611deca9c", "patch": "@@ -515,19 +515,9 @@ impl<T> SliceExt for [T] {\n     fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n         assert!(self.len() == src.len(),\n                 \"destination and source slices have different lengths\");\n-        // First check if the amount of elements we want to copy is small:\n-        // `copy_nonoverlapping` will do a memcopy, which involves an indirect\n-        // function call when `memcpy` is in the dynamically-linked libc. For\n-        // small elements (such as a single byte or pointer), the overhead is\n-        // significant. If the element is big then the assignment is a memcopy\n-        // anyway.\n-        if self.len() == 1 {\n-            self[0] = src[0];\n-        } else {\n-            unsafe {\n-                ptr::copy_nonoverlapping(\n-                    src.as_ptr(), self.as_mut_ptr(), self.len());\n-            }\n+        unsafe {\n+            ptr::copy_nonoverlapping(\n+                src.as_ptr(), self.as_mut_ptr(), self.len());\n         }\n     }\n "}, {"sha": "f691289811bc6514d57262cf753f778e6a5af0ae", "filename": "src/libstd/io/impls.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3be2c3b3092e934bdc2db67d5bdcabd611deca9c/src%2Flibstd%2Fio%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3be2c3b3092e934bdc2db67d5bdcabd611deca9c/src%2Flibstd%2Fio%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fimpls.rs?ref=3be2c3b3092e934bdc2db67d5bdcabd611deca9c", "patch": "@@ -157,7 +157,16 @@ impl<'a> Read for &'a [u8] {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         let amt = cmp::min(buf.len(), self.len());\n         let (a, b) = self.split_at(amt);\n-        buf[..amt].copy_from_slice(a);\n+\n+        // First check if the amount of bytes we want to read is small:\n+        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n+        // for a single byte the overhead is significant.\n+        if amt == 1 {\n+            buf[0] = a[0];\n+        } else {\n+            buf[..amt].copy_from_slice(a);\n+        }\n+\n         *self = b;\n         Ok(amt)\n     }\n@@ -169,7 +178,16 @@ impl<'a> Read for &'a [u8] {\n                                   \"failed to fill whole buffer\"));\n         }\n         let (a, b) = self.split_at(buf.len());\n-        buf.copy_from_slice(a);\n+\n+        // First check if the amount of bytes we want to read is small:\n+        // `copy_from_slice` will generally expand to a call to `memcpy`, and\n+        // for a single byte the overhead is significant.\n+        if buf.len() == 1 {\n+            buf[0] = a[0];\n+        } else {\n+            buf.copy_from_slice(a);\n+        }\n+\n         *self = b;\n         Ok(())\n     }"}]}