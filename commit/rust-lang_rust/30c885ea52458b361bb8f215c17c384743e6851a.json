{"sha": "30c885ea52458b361bb8f215c17c384743e6851a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYzg4NWVhNTI0NThiMzYxYmI4ZjIxNWMxN2MzODQ3NDNlNjg1MWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-03T18:39:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-10T09:37:10Z"}, "message": "uv: Remove lots of uv/C++ wrappers", "tree": {"sha": "71ca222f9536fd2344ee37562848a25954b4198a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71ca222f9536fd2344ee37562848a25954b4198a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30c885ea52458b361bb8f215c17c384743e6851a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30c885ea52458b361bb8f215c17c384743e6851a", "html_url": "https://github.com/rust-lang/rust/commit/30c885ea52458b361bb8f215c17c384743e6851a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30c885ea52458b361bb8f215c17c384743e6851a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3851f908d16b55dfe69d5a423ecbef4cd224fae2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3851f908d16b55dfe69d5a423ecbef4cd224fae2", "html_url": "https://github.com/rust-lang/rust/commit/3851f908d16b55dfe69d5a423ecbef4cd224fae2"}], "stats": {"total": 1265, "additions": 310, "deletions": 955}, "files": [{"sha": "77e70acca8d5e5563bedd28ef7c9cd8fb876f58c", "filename": "src/librustuv/addrinfo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Faddrinfo.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -110,12 +110,12 @@ impl GetAddrInfoRequest {\n         self.get_req_data().getaddrinfo_cb = Some(wrapper_cb);\n \n         unsafe {\n-            assert!(0 == uvll::getaddrinfo(loop_.native_handle(),\n-                                           self.native_handle(),\n-                                           getaddrinfo_cb,\n-                                           c_node_ptr,\n-                                           c_service_ptr,\n-                                           hint_ptr));\n+            assert!(0 == uvll::uv_getaddrinfo(loop_.native_handle(),\n+                                              self.native_handle(),\n+                                              getaddrinfo_cb,\n+                                              c_node_ptr,\n+                                              c_service_ptr,\n+                                              hint_ptr));\n         }\n \n         extern \"C\" fn getaddrinfo_cb(req: *uvll::uv_getaddrinfo_t,\n@@ -127,7 +127,7 @@ impl GetAddrInfoRequest {\n             let data = req.get_req_data();\n             (*data.getaddrinfo_cb.get_ref())(req, &addrinfo, err);\n             unsafe {\n-                uvll::freeaddrinfo(res);\n+                uvll::uv_freeaddrinfo(res);\n             }\n         }\n     }"}, {"sha": "79e57db1bf5913e7535979e8bf66f182d4394f81", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -26,7 +26,7 @@ impl AsyncWatcher {\n             watcher.install_watcher_data();\n             let data = watcher.get_watcher_data();\n             data.async_cb = Some(cb);\n-            assert_eq!(0, uvll::async_init(loop_.native_handle(), handle, async_cb));\n+            assert_eq!(0, uvll::uv_async_init(loop_.native_handle(), handle, async_cb));\n             return watcher;\n         }\n \n@@ -42,7 +42,7 @@ impl AsyncWatcher {\n     pub fn send(&mut self) {\n         unsafe {\n             let handle = self.native_handle();\n-            uvll::async_send(handle);\n+            uvll::uv_async_send(handle);\n         }\n     }\n }"}, {"sha": "e3fe6c95bafe7fd84db827040148cc73eddd0066", "filename": "src/librustuv/file.rs", "status": "modified", "additions": 81, "deletions": 30, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ffile.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -42,8 +42,9 @@ impl FsRequest {\n             me.req_boilerplate(Some(cb))\n         };\n         let ret = path.with_ref(|p| unsafe {\n-            uvll::fs_open(loop_.native_handle(),\n-                          self.native_handle(), p, flags, mode, complete_cb_ptr)\n+            uvll::uv_fs_open(loop_.native_handle(),\n+                             self.native_handle(), p, flags as c_int,\n+                             mode as c_int, complete_cb_ptr)\n         });\n         assert_eq!(ret, 0);\n     }\n@@ -52,17 +53,18 @@ impl FsRequest {\n                      flags: int, mode: int) -> Result<c_int, UvError> {\n         let complete_cb_ptr = self.req_boilerplate(None);\n         let result = path.with_ref(|p| unsafe {\n-            uvll::fs_open(loop_.native_handle(),\n-                    self.native_handle(), p, flags, mode, complete_cb_ptr)\n+            uvll::uv_fs_open(loop_.native_handle(),\n+                             self.native_handle(), p, flags as c_int,\n+                             mode as c_int, complete_cb_ptr)\n         });\n         self.sync_cleanup(result)\n     }\n \n     pub fn unlink(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         let ret = path.with_ref(|p| unsafe {\n-            uvll::fs_unlink(loop_.native_handle(),\n-                          self.native_handle(), p, complete_cb_ptr)\n+            uvll::uv_fs_unlink(loop_.native_handle(),\n+                               self.native_handle(), p, complete_cb_ptr)\n         });\n         assert_eq!(ret, 0);\n     }\n@@ -71,8 +73,8 @@ impl FsRequest {\n       -> Result<c_int, UvError> {\n         let complete_cb_ptr = self.req_boilerplate(None);\n         let result = path.with_ref(|p| unsafe {\n-            uvll::fs_unlink(loop_.native_handle(),\n-                          self.native_handle(), p, complete_cb_ptr)\n+            uvll::uv_fs_unlink(loop_.native_handle(),\n+                               self.native_handle(), p, complete_cb_ptr)\n         });\n         self.sync_cleanup(result)\n     }\n@@ -89,8 +91,8 @@ impl FsRequest {\n     pub fn stat(mut self, loop_: &Loop, path: &CString, cb: FsCallback) {\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         let ret = path.with_ref(|p| unsafe {\n-            uvll::fs_stat(loop_.native_handle(),\n-                          self.native_handle(), p, complete_cb_ptr)\n+            uvll::uv_fs_stat(loop_.native_handle(),\n+                             self.native_handle(), p, complete_cb_ptr)\n         });\n         assert_eq!(ret, 0);\n     }\n@@ -101,9 +103,9 @@ impl FsRequest {\n         let base_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let ret = unsafe {\n-            uvll::fs_write(loop_.native_handle(), self.native_handle(),\n-                           fd, base_ptr,\n-                           len, offset, complete_cb_ptr)\n+            uvll::uv_fs_write(loop_.native_handle(), self.native_handle(),\n+                              fd, base_ptr,\n+                              len as c_uint, offset, complete_cb_ptr)\n         };\n         assert_eq!(ret, 0);\n     }\n@@ -113,9 +115,9 @@ impl FsRequest {\n         let base_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let result = unsafe {\n-            uvll::fs_write(loop_.native_handle(), self.native_handle(),\n-                           fd, base_ptr,\n-                           len, offset, complete_cb_ptr)\n+            uvll::uv_fs_write(loop_.native_handle(), self.native_handle(),\n+                              fd, base_ptr,\n+                              len as c_uint, offset, complete_cb_ptr)\n         };\n         self.sync_cleanup(result)\n     }\n@@ -126,9 +128,9 @@ impl FsRequest {\n         let buf_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let ret = unsafe {\n-            uvll::fs_read(loop_.native_handle(), self.native_handle(),\n-                           fd, buf_ptr,\n-                           len, offset, complete_cb_ptr)\n+            uvll::uv_fs_read(loop_.native_handle(), self.native_handle(),\n+                             fd, buf_ptr,\n+                             len as c_uint, offset, complete_cb_ptr)\n         };\n         assert_eq!(ret, 0);\n     }\n@@ -138,30 +140,44 @@ impl FsRequest {\n         let buf_ptr = buf.base as *c_void;\n         let len = buf.len as uint;\n         let result = unsafe {\n-            uvll::fs_read(loop_.native_handle(), self.native_handle(),\n-                           fd, buf_ptr,\n-                           len, offset, complete_cb_ptr)\n+            uvll::uv_fs_read(loop_.native_handle(), self.native_handle(),\n+                             fd, buf_ptr,\n+                             len as c_uint, offset, complete_cb_ptr)\n         };\n         self.sync_cleanup(result)\n     }\n \n+<<<<<<< HEAD\n     pub fn close(mut self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         assert_eq!(unsafe {\n             uvll::fs_close(loop_.native_handle(), self.native_handle(),\n                            fd, complete_cb_ptr)\n         }, 0);\n+=======\n+    pub fn close(self, loop_: &Loop, fd: c_int, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = unsafe {\n+            uvll::uv_fs_close(loop_.native_handle(), self.native_handle(),\n+                              fd, complete_cb_ptr)\n+        };\n+        assert_eq!(ret, 0);\n+>>>>>>> 1850d26... Remove lots of uv/C++ wrappers\n     }\n     pub fn close_sync(mut self, loop_: &Loop,\n                       fd: c_int) -> Result<c_int, UvError> {\n         let complete_cb_ptr = self.req_boilerplate(None);\n         let result = unsafe {\n-            uvll::fs_close(loop_.native_handle(), self.native_handle(),\n-                           fd, complete_cb_ptr)\n+            uvll::uv_fs_close(loop_.native_handle(), self.native_handle(),\n+                              fd, complete_cb_ptr)\n         };\n         self.sync_cleanup(result)\n     }\n \n+<<<<<<< HEAD\n     pub fn mkdir(mut self, loop_: &Loop, path: &CString, mode: c_int,\n                  cb: FsCallback) {\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n@@ -198,10 +214,36 @@ impl FsRequest {\n             uvll::fs_chmod(loop_.native_handle(), self.native_handle(), p, mode,\n                            complete_cb_ptr)\n         }), 0);\n+=======\n+    pub fn mkdir(self, loop_: &Loop, path: &CString, mode: int, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::uv_fs_mkdir(loop_.native_handle(),\n+                              self.native_handle(), p,\n+                              mode as c_int, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+    }\n+\n+    pub fn rmdir(self, loop_: &Loop, path: &CString, cb: FsCallback) {\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::uv_fs_rmdir(loop_.native_handle(),\n+                              self.native_handle(), p, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+>>>>>>> 1850d26... Remove lots of uv/C++ wrappers\n     }\n \n     pub fn readdir(mut self, loop_: &Loop, path: &CString,\n                    flags: c_int, cb: FsCallback) {\n+<<<<<<< HEAD\n         let complete_cb_ptr = self.req_boilerplate(Some(cb));\n         assert_eq!(path.with_ref(|p| unsafe {\n             uvll::fs_readdir(loop_.native_handle(),\n@@ -276,6 +318,17 @@ impl FsRequest {\n             uvll::uv_fs_fdatasync(loop_.native_handle(), self.native_handle(), fd,\n                                   complete_cb_ptr)\n         }, 0);\n+=======\n+        let complete_cb_ptr = {\n+            let mut me = self;\n+            me.req_boilerplate(Some(cb))\n+        };\n+        let ret = path.with_ref(|p| unsafe {\n+            uvll::uv_fs_readdir(loop_.native_handle(),\n+                                self.native_handle(), p, flags, complete_cb_ptr)\n+        });\n+        assert_eq!(ret, 0);\n+>>>>>>> 1850d26... Remove lots of uv/C++ wrappers\n     }\n \n     // accessors/utility funcs\n@@ -287,12 +340,10 @@ impl FsRequest {\n             None => Ok(result)\n         }\n     }\n-    fn req_boilerplate(&mut self, cb: Option<FsCallback>) -> *u8 {\n+    fn req_boilerplate(&mut self, cb: Option<FsCallback>) -> uvll::uv_fs_cb {\n         let result = match cb {\n-            Some(_) => {\n-                compl_cb as *u8\n-            },\n-            None => 0 as *u8\n+            Some(_) => compl_cb,\n+            None => 0 as uvll::uv_fs_cb\n         };\n         self.install_req_data(cb);\n         result\n@@ -365,7 +416,7 @@ impl FsRequest {\n             let data = uvll::get_data_for_req(self.native_handle());\n             let _data = transmute::<*c_void, ~RequestData>(data);\n             uvll::set_data_for_req(self.native_handle(), null::<()>());\n-            uvll::fs_req_cleanup(self.native_handle());\n+            uvll::uv_fs_req_cleanup(self.native_handle());\n             free_req(self.native_handle() as *c_void)\n         }\n     }"}, {"sha": "7c9b0ff461ccd447f4e5febefd05d35825801b76", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -21,7 +21,7 @@ impl IdleWatcher {\n         unsafe {\n             let handle = uvll::malloc_handle(uvll::UV_IDLE);\n             assert!(handle.is_not_null());\n-            assert_eq!(uvll::idle_init(loop_.native_handle(), handle), 0);\n+            assert_eq!(uvll::uv_idle_init(loop_.native_handle(), handle), 0);\n             let mut watcher: IdleWatcher = NativeHandle::from_native_handle(handle);\n             watcher.install_watcher_data();\n             return watcher\n@@ -35,14 +35,14 @@ impl IdleWatcher {\n         }\n \n         unsafe {\n-            assert_eq!(uvll::idle_start(self.native_handle(), idle_cb), 0)\n+            assert_eq!(uvll::uv_idle_start(self.native_handle(), idle_cb), 0)\n         }\n     }\n \n     pub fn restart(&mut self) {\n         unsafe {\n             assert!(self.get_watcher_data().idle_cb.is_some());\n-            assert_eq!(uvll::idle_start(self.native_handle(), idle_cb), 0)\n+            assert_eq!(uvll::uv_idle_start(self.native_handle(), idle_cb), 0)\n         }\n     }\n \n@@ -52,7 +52,7 @@ impl IdleWatcher {\n         // free\n \n         unsafe {\n-            assert_eq!(uvll::idle_stop(self.native_handle()), 0);\n+            assert_eq!(uvll::uv_idle_stop(self.native_handle()), 0);\n         }\n     }\n }"}, {"sha": "64aea4f01744d14e444d73537d37b6b025410503", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -49,7 +49,7 @@ use std::str::raw::from_c_str;\n use std::vec;\n use std::ptr;\n use std::str;\n-use std::libc::{c_void, c_int, size_t, malloc, free};\n+use std::libc::{c_void, c_int, size_t, malloc, free, c_char, c_uint};\n use std::cast::transmute;\n use std::ptr::null;\n use std::unstable::finally::Finally;\n@@ -127,11 +127,11 @@ impl Loop {\n     }\n \n     pub fn run(&mut self) {\n-        unsafe { uvll::run(self.native_handle()) };\n+        unsafe { uvll::uv_run(self.native_handle(), uvll::RUN_DEFAULT) };\n     }\n \n     pub fn close(&mut self) {\n-        unsafe { uvll::loop_delete(self.native_handle()) };\n+        unsafe { uvll::uv_loop_delete(self.native_handle()) };\n     }\n }\n \n@@ -240,7 +240,9 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n             data.close_cb = Some(cb);\n         }\n \n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n+        unsafe {\n+            uvll::uv_close(self.native_handle() as *uvll::uv_handle_t, close_cb);\n+        }\n \n         extern fn close_cb(handle: *uvll::uv_handle_t) {\n             let mut h: Handle = NativeHandle::from_native_handle(handle);\n@@ -251,7 +253,9 @@ impl<H, W: Watcher + NativeHandle<*H>> WatcherInterop for W {\n     }\n \n     fn close_async(self) {\n-        unsafe { uvll::close(self.native_handle(), close_cb); }\n+        unsafe {\n+            uvll::uv_close(self.native_handle() as *uvll::uv_handle_t, close_cb);\n+        }\n \n         extern fn close_cb(handle: *uvll::uv_handle_t) {\n             let mut h: Handle = NativeHandle::from_native_handle(handle);\n@@ -270,7 +274,7 @@ impl UvError {\n     pub fn name(&self) -> ~str {\n         unsafe {\n             let inner = match self { &UvError(a) => a };\n-            let name_str = uvll::err_name(inner);\n+            let name_str = uvll::uv_err_name(inner);\n             assert!(name_str.is_not_null());\n             from_c_str(name_str)\n         }\n@@ -279,7 +283,7 @@ impl UvError {\n     pub fn desc(&self) -> ~str {\n         unsafe {\n             let inner = match self { &UvError(a) => a };\n-            let desc_str = uvll::strerror(inner);\n+            let desc_str = uvll::uv_strerror(inner);\n             assert!(desc_str.is_not_null());\n             from_c_str(desc_str)\n         }\n@@ -309,7 +313,7 @@ pub fn uv_error_to_io_error(uverr: UvError) -> IoError {\n         use std::rt::io::*;\n \n         // uv error descriptions are static\n-        let c_desc = uvll::strerror(*uverr);\n+        let c_desc = uvll::uv_strerror(*uverr);\n         let desc = str::raw::c_str_to_static_slice(c_desc);\n \n         let kind = match *uverr {\n@@ -360,7 +364,7 @@ pub fn empty_buf() -> Buf {\n /// Borrow a slice to a Buf\n pub fn slice_to_uv_buf(v: &[u8]) -> Buf {\n     let data = vec::raw::to_ptr(v);\n-    unsafe { uvll::buf_init(data, v.len()) }\n+    unsafe { uvll::uv_buf_init(data as *c_char, v.len() as c_uint) }\n }\n \n // XXX: Do these conversions without copying\n@@ -376,7 +380,7 @@ pub fn vec_to_uv_buf(v: ~[u8]) -> Buf {\n             let data = data as *mut u8;\n             ptr::copy_memory(data, b, l)\n         }\n-        uvll::buf_init(data, v.len())\n+        uvll::uv_buf_init(data as *c_char, v.len() as c_uint)\n     }\n }\n "}, {"sha": "e9f3f2bba4c5e855c6dd974183cb0e8b7f25371d", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::libc::{size_t, ssize_t, c_int, c_void, c_uint};\n+use std::libc::{size_t, ssize_t, c_int, c_void, c_uint, c_char};\n use std::vec;\n use std::str;\n use std::rt::io::net::ip::{SocketAddr, Ipv4Addr, Ipv6Addr};\n@@ -70,8 +70,10 @@ fn uv_socket_addr_as_socket_addr<T>(addr: UvSocketAddr, f: &fn(SocketAddr) -> T)\n         unsafe {\n             let buf_ptr = vec::raw::to_ptr(buf);\n             match addr {\n-                UvIpv4SocketAddr(addr) => uvll::ip4_name(addr, buf_ptr, ip_size as size_t),\n-                UvIpv6SocketAddr(addr) => uvll::ip6_name(addr, buf_ptr, ip_size as size_t),\n+                UvIpv4SocketAddr(addr) =>\n+                    uvll::uv_ip4_name(addr, buf_ptr as *c_char, ip_size as size_t),\n+                UvIpv6SocketAddr(addr) =>\n+                    uvll::uv_ip6_name(addr, buf_ptr as *c_char, ip_size as size_t),\n             }\n         };\n         buf\n@@ -119,7 +121,7 @@ impl Watcher for StreamWatcher { }\n impl StreamWatcher {\n     pub fn read_start(&mut self, alloc: AllocCallback, cb: ReadCallback) {\n         unsafe {\n-            match uvll::read_start(self.native_handle(), alloc_cb, read_cb) {\n+            match uvll::uv_read_start(self.native_handle(), alloc_cb, read_cb) {\n                 0 => {\n                     let data = self.get_watcher_data();\n                     data.alloc_cb = Some(alloc);\n@@ -152,14 +154,14 @@ impl StreamWatcher {\n         // but read_stop may be called from inside one of them and we\n         // would end up freeing the in-use environment\n         let handle = self.native_handle();\n-        unsafe { assert_eq!(uvll::read_stop(handle), 0); }\n+        unsafe { assert_eq!(uvll::uv_read_stop(handle), 0); }\n     }\n \n     pub fn write(&mut self, buf: Buf, cb: ConnectionCallback) {\n         let req = WriteRequest::new();\n         return unsafe {\n-            match uvll::write(req.native_handle(), self.native_handle(),\n-                              [buf], write_cb) {\n+            match uvll::uv_write(req.native_handle(), self.native_handle(),\n+                                 [buf], write_cb) {\n                 0 => {\n                     let data = self.get_watcher_data();\n                     assert!(data.write_cb.is_none());\n@@ -192,7 +194,7 @@ impl StreamWatcher {\n \n         return unsafe {\n             static BACKLOG: c_int = 128; // XXX should be configurable\n-            match uvll::listen(self.native_handle(), BACKLOG, connection_cb) {\n+            match uvll::uv_listen(self.native_handle(), BACKLOG, connection_cb) {\n                 0 => Ok(()),\n                 n => Err(UvError(n))\n             }\n@@ -210,7 +212,7 @@ impl StreamWatcher {\n     pub fn accept(&mut self, stream: StreamWatcher) {\n         let self_handle = self.native_handle() as *c_void;\n         let stream_handle = stream.native_handle() as *c_void;\n-        assert_eq!(0, unsafe { uvll::accept(self_handle, stream_handle) } );\n+        assert_eq!(0, unsafe { uvll::uv_accept(self_handle, stream_handle) } );\n     }\n }\n \n@@ -231,7 +233,7 @@ impl TcpWatcher {\n         unsafe {\n             let handle = malloc_handle(UV_TCP);\n             assert!(handle.is_not_null());\n-            assert_eq!(0, uvll::tcp_init(loop_.native_handle(), handle));\n+            assert_eq!(0, uvll::uv_tcp_init(loop_.native_handle(), handle));\n             let mut watcher: TcpWatcher = NativeHandle::from_native_handle(handle);\n             watcher.install_watcher_data();\n             return watcher;\n@@ -304,7 +306,7 @@ impl UdpWatcher {\n         unsafe {\n             let handle = malloc_handle(UV_UDP);\n             assert!(handle.is_not_null());\n-            assert_eq!(0, uvll::udp_init(loop_.native_handle(), handle));\n+            assert_eq!(0, uvll::uv_udp_init(loop_.native_handle(), handle));\n             let mut watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n             watcher.install_watcher_data();\n             return watcher;\n@@ -333,7 +335,7 @@ impl UdpWatcher {\n             data.udp_recv_cb = Some(cb);\n         }\n \n-        unsafe { uvll::udp_recv_start(self.native_handle(), alloc_cb, recv_cb); }\n+        unsafe { uvll::uv_udp_recv_start(self.native_handle(), alloc_cb, recv_cb); }\n \n         extern fn alloc_cb(handle: *uvll::uv_udp_t, suggested_size: size_t) -> Buf {\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n@@ -361,7 +363,7 @@ impl UdpWatcher {\n     }\n \n     pub fn recv_stop(&mut self) {\n-        unsafe { uvll::udp_recv_stop(self.native_handle()); }\n+        unsafe { uvll::uv_udp_recv_stop(self.native_handle()); }\n     }\n \n     pub fn send(&mut self, buf: Buf, address: SocketAddr, cb: UdpSendCallback) {"}, {"sha": "0b65c55636d40de9aa1cee2f81d3a559d0a2c3e5", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -26,7 +26,7 @@ impl Pipe {\n             let handle = uvll::malloc_handle(uvll::UV_NAMED_PIPE);\n             assert!(handle.is_not_null());\n             let ipc = ipc as libc::c_int;\n-            assert_eq!(uvll::pipe_init(loop_.native_handle(), handle, ipc), 0);\n+            assert_eq!(uvll::uv_pipe_init(loop_.native_handle(), handle, ipc), 0);\n             let mut ret: Pipe =\n                     NativeHandle::from_native_handle(handle);\n             ret.install_watcher_data();\n@@ -40,7 +40,7 @@ impl Pipe {\n \n     #[fixed_stack_segment] #[inline(never)]\n     pub fn open(&mut self, file: libc::c_int) -> Result<(), UvError> {\n-        match unsafe { uvll::pipe_open(self.native_handle(), file) } {\n+        match unsafe { uvll::uv_pipe_open(self.native_handle(), file) } {\n             0 => Ok(()),\n             n => Err(UvError(n))\n         }\n@@ -49,7 +49,7 @@ impl Pipe {\n     #[fixed_stack_segment] #[inline(never)]\n     pub fn bind(&mut self, name: &CString) -> Result<(), UvError> {\n         do name.with_ref |name| {\n-            match unsafe { uvll::pipe_bind(self.native_handle(), name) } {\n+            match unsafe { uvll::uv_pipe_bind(self.native_handle(), name) } {\n                 0 => Ok(()),\n                 n => Err(UvError(n))\n             }\n@@ -68,7 +68,7 @@ impl Pipe {\n         let name = do name.with_ref |p| { p };\n \n         unsafe {\n-            uvll::pipe_connect(connect.native_handle(),\n+            uvll::uv_pipe_connect(connect.native_handle(),\n                                self.native_handle(),\n                                name,\n                                connect_cb)"}, {"sha": "ce281b656d39f98a7702feca127af1c13f954e6b", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -94,7 +94,7 @@ impl Process {\n                 };\n \n                 match unsafe {\n-                    uvll::spawn(loop_.native_handle(), **self, options)\n+                    uvll::uv_spawn(loop_.native_handle(), **self, options)\n                 } {\n                     0 => {\n                         (*self).get_watcher_data().exit_cb = Some(exit_cb.take());\n@@ -111,7 +111,7 @@ impl Process {\n     /// This is a wrapper around `uv_process_kill`\n     pub fn kill(&self, signum: int) -> Result<(), UvError> {\n         match unsafe {\n-            uvll::process_kill(self.native_handle(), signum as libc::c_int)\n+            uvll::uv_process_kill(self.native_handle(), signum as libc::c_int)\n         } {\n             0 => Ok(()),\n             err => Err(UvError(err))"}, {"sha": "d5774b5aaab35d828e89168005e6951820b3a5d9", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -24,7 +24,7 @@ impl SignalWatcher {\n         unsafe {\n             let handle = uvll::malloc_handle(uvll::UV_SIGNAL);\n             assert!(handle.is_not_null());\n-            assert!(0 == uvll::signal_init(loop_.native_handle(), handle));\n+            assert!(0 == uvll::uv_signal_init(loop_.native_handle(), handle));\n             let mut watcher: SignalWatcher = NativeHandle::from_native_handle(handle);\n             watcher.install_watcher_data();\n             return watcher;\n@@ -35,8 +35,8 @@ impl SignalWatcher {\n             -> Result<(), UvError>\n     {\n         return unsafe {\n-            match uvll::signal_start(self.native_handle(), signal_cb,\n-                                     signum as c_int) {\n+            match uvll::uv_signal_start(self.native_handle(), signal_cb,\n+                                        signum as c_int) {\n                 0 => {\n                     let data = self.get_watcher_data();\n                     data.signal_cb = Some(callback);\n@@ -56,7 +56,7 @@ impl SignalWatcher {\n \n     pub fn stop(&mut self) {\n         unsafe {\n-            uvll::signal_stop(self.native_handle());\n+            uvll::uv_signal_stop(self.native_handle());\n         }\n     }\n }"}, {"sha": "4fc4934bf650af62e3361ce9c6337a5c100a6bf9", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -21,7 +21,7 @@ impl TimerWatcher {\n         unsafe {\n             let handle = uvll::malloc_handle(uvll::UV_TIMER);\n             assert!(handle.is_not_null());\n-            assert!(0 == uvll::timer_init(loop_.native_handle(), handle));\n+            assert!(0 == uvll::uv_timer_init(loop_.native_handle(), handle));\n             let mut watcher: TimerWatcher = NativeHandle::from_native_handle(handle);\n             watcher.install_watcher_data();\n             return watcher;\n@@ -35,7 +35,7 @@ impl TimerWatcher {\n         }\n \n         unsafe {\n-            uvll::timer_start(self.native_handle(), timer_cb, timeout, repeat);\n+            uvll::uv_timer_start(self.native_handle(), timer_cb, timeout, repeat);\n         }\n \n         extern fn timer_cb(handle: *uvll::uv_timer_t, status: c_int) {\n@@ -49,7 +49,7 @@ impl TimerWatcher {\n \n     pub fn stop(&mut self) {\n         unsafe {\n-            uvll::timer_stop(self.native_handle());\n+            uvll::uv_timer_stop(self.native_handle());\n         }\n     }\n }"}, {"sha": "ad5f5043737f2ff97bad1bfa361e4ec5dceb00d4", "filename": "src/librustuv/tty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftty.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -28,8 +28,8 @@ impl TTY {\n         assert!(handle.is_not_null());\n \n         let ret = unsafe {\n-            uvll::tty_init(loop_.native_handle(), handle, fd as libc::c_int,\n-                           readable as libc::c_int)\n+            uvll::uv_tty_init(loop_.native_handle(), handle, fd as libc::c_int,\n+                              readable as libc::c_int)\n         };\n         match ret {\n             0 => {\n@@ -51,7 +51,7 @@ impl TTY {\n     #[fixed_stack_segment] #[inline(never)]\n     pub fn set_mode(&self, raw: bool) -> Result<(), UvError> {\n         let raw = raw as libc::c_int;\n-        match unsafe { uvll::tty_set_mode(self.native_handle(), raw) } {\n+        match unsafe { uvll::uv_tty_set_mode(self.native_handle(), raw) } {\n             0 => Ok(()),\n             n => Err(UvError(n))\n         }\n@@ -64,8 +64,8 @@ impl TTY {\n         let widthptr: *libc::c_int = &width;\n         let heightptr: *libc::c_int = &width;\n \n-        match unsafe { uvll::tty_get_winsize(self.native_handle(),\n-                                             widthptr, heightptr) } {\n+        match unsafe { uvll::uv_tty_get_winsize(self.native_handle(),\n+                                                widthptr, heightptr) } {\n             0 => Ok((width as int, height as int)),\n             n => Err(UvError(n))\n         }"}, {"sha": "b4382ab4cee2564e49eaa4fcee773f120a6e5d87", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -990,7 +990,7 @@ impl RtioSocket for UvTcpAcceptor {\n \n fn accept_simultaneously(stream: StreamWatcher, a: int) -> Result<(), IoError> {\n     let r = unsafe {\n-        uvll::tcp_simultaneous_accepts(stream.native_handle(), a as c_int)\n+        uvll::uv_tcp_simultaneous_accepts(stream.native_handle(), a as c_int)\n     };\n \n     match status_to_maybe_uv_error(r) {\n@@ -1194,7 +1194,9 @@ impl RtioTcpStream for UvTcpStream {\n \n     fn control_congestion(&mut self) -> Result<(), IoError> {\n         do self.home_for_io |self_| {\n-            let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 0 as c_int) };\n+            let r = unsafe {\n+                uvll::uv_tcp_nodelay(self_.watcher.native_handle(), 0 as c_int)\n+            };\n \n             match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n@@ -1205,7 +1207,9 @@ impl RtioTcpStream for UvTcpStream {\n \n     fn nodelay(&mut self) -> Result<(), IoError> {\n         do self.home_for_io |self_| {\n-            let r = unsafe { uvll::tcp_nodelay(self_.watcher.native_handle(), 1 as c_int) };\n+            let r = unsafe {\n+                uvll::uv_tcp_nodelay(self_.watcher.native_handle(), 1 as c_int)\n+            };\n \n             match status_to_maybe_uv_error(r) {\n                 Some(err) => Err(uv_error_to_io_error(err)),\n@@ -1217,8 +1221,8 @@ impl RtioTcpStream for UvTcpStream {\n     fn keepalive(&mut self, delay_in_seconds: uint) -> Result<(), IoError> {\n         do self.home_for_io |self_| {\n             let r = unsafe {\n-                uvll::tcp_keepalive(self_.watcher.native_handle(), 1 as c_int,\n-                                    delay_in_seconds as c_uint)\n+                uvll::uv_tcp_keepalive(self_.watcher.native_handle(), 1 as c_int,\n+                                       delay_in_seconds as c_uint)\n             };\n \n             match status_to_maybe_uv_error(r) {\n@@ -1231,7 +1235,8 @@ impl RtioTcpStream for UvTcpStream {\n     fn letdie(&mut self) -> Result<(), IoError> {\n         do self.home_for_io |self_| {\n             let r = unsafe {\n-                uvll::tcp_keepalive(self_.watcher.native_handle(), 0 as c_int, 0 as c_uint)\n+                uvll::uv_tcp_keepalive(self_.watcher.native_handle(),\n+                                       0 as c_int, 0 as c_uint)\n             };\n \n             match status_to_maybe_uv_error(r) {\n@@ -1338,8 +1343,9 @@ impl RtioUdpSocket for UvUdpSocket {\n         do self.home_for_io |self_| {\n             let r = unsafe {\n                 do multi.to_str().with_c_str |m_addr| {\n-                    uvll::udp_set_membership(self_.watcher.native_handle(), m_addr,\n-                                             ptr::null(), uvll::UV_JOIN_GROUP)\n+                    uvll::uv_udp_set_membership(self_.watcher.native_handle(),\n+                                                m_addr, ptr::null(),\n+                                                uvll::UV_JOIN_GROUP)\n                 }\n             };\n \n@@ -1354,8 +1360,9 @@ impl RtioUdpSocket for UvUdpSocket {\n         do self.home_for_io |self_| {\n             let r = unsafe {\n                 do multi.to_str().with_c_str |m_addr| {\n-                    uvll::udp_set_membership(self_.watcher.native_handle(), m_addr,\n-                                             ptr::null(), uvll::UV_LEAVE_GROUP)\n+                    uvll::uv_udp_set_membership(self_.watcher.native_handle(),\n+                                                m_addr, ptr::null(),\n+                                                uvll::UV_LEAVE_GROUP)\n                 }\n             };\n \n@@ -1370,7 +1377,8 @@ impl RtioUdpSocket for UvUdpSocket {\n         do self.home_for_io |self_| {\n \n             let r = unsafe {\n-                uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 1 as c_int)\n+                uvll::uv_udp_set_multicast_loop(self_.watcher.native_handle(),\n+                                                1 as c_int)\n             };\n \n             match status_to_maybe_uv_error(r) {\n@@ -1384,7 +1392,8 @@ impl RtioUdpSocket for UvUdpSocket {\n         do self.home_for_io |self_| {\n \n             let r = unsafe {\n-                uvll::udp_set_multicast_loop(self_.watcher.native_handle(), 0 as c_int)\n+                uvll::uv_udp_set_multicast_loop(self_.watcher.native_handle(),\n+                                                0 as c_int)\n             };\n \n             match status_to_maybe_uv_error(r) {\n@@ -1398,7 +1407,8 @@ impl RtioUdpSocket for UvUdpSocket {\n         do self.home_for_io |self_| {\n \n             let r = unsafe {\n-                uvll::udp_set_multicast_ttl(self_.watcher.native_handle(), ttl as c_int)\n+                uvll::uv_udp_set_multicast_ttl(self_.watcher.native_handle(),\n+                                               ttl as c_int)\n             };\n \n             match status_to_maybe_uv_error(r) {\n@@ -1412,7 +1422,7 @@ impl RtioUdpSocket for UvUdpSocket {\n         do self.home_for_io |self_| {\n \n             let r = unsafe {\n-                uvll::udp_set_ttl(self_.watcher.native_handle(), ttl as c_int)\n+                uvll::uv_udp_set_ttl(self_.watcher.native_handle(), ttl as c_int)\n             };\n \n             match status_to_maybe_uv_error(r) {\n@@ -1426,7 +1436,8 @@ impl RtioUdpSocket for UvUdpSocket {\n         do self.home_for_io |self_| {\n \n             let r = unsafe {\n-                uvll::udp_set_broadcast(self_.watcher.native_handle(), 1 as c_int)\n+                uvll::uv_udp_set_broadcast(self_.watcher.native_handle(),\n+                                           1 as c_int)\n             };\n \n             match status_to_maybe_uv_error(r) {\n@@ -1440,7 +1451,8 @@ impl RtioUdpSocket for UvUdpSocket {\n         do self.home_for_io |self_| {\n \n             let r = unsafe {\n-                uvll::udp_set_broadcast(self_.watcher.native_handle(), 0 as c_int)\n+                uvll::uv_udp_set_broadcast(self_.watcher.native_handle(),\n+                                           0 as c_int)\n             };\n \n             match status_to_maybe_uv_error(r) {\n@@ -1861,7 +1873,7 @@ impl RtioTTY for UvTTY {\n     }\n \n     fn isatty(&self) -> bool {\n-        unsafe { uvll::guess_handle(self.fd) == uvll::UV_TTY as c_int }\n+        unsafe { uvll::uv_guess_handle(self.fd) == uvll::UV_TTY }\n     }\n }\n "}, {"sha": "120a69fb244980f19c0a7879d85b603dd8d54ce5", "filename": "src/librustuv/uvll.rs", "status": "modified", "additions": 140, "deletions": 502, "changes": 642, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fuvll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Flibrustuv%2Fuvll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvll.rs?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -33,7 +33,6 @@ use std::libc::{size_t, c_int, c_uint, c_void, c_char, uintptr_t};\n use std::libc::ssize_t;\n use std::libc::{malloc, free};\n use std::libc;\n-use std::ptr;\n use std::vec;\n \n pub use self::errors::*;\n@@ -95,6 +94,13 @@ pub struct uv_buf_t {\n     base: *u8,\n }\n \n+#[repr(C)]\n+pub enum uv_run_mode {\n+    RUN_DEFAULT = 0,\n+    RUN_ONCE,\n+    RUN_NOWAIT,\n+}\n+\n pub struct uv_process_options_t {\n     exit_cb: uv_exit_cb,\n     file: *libc::c_char,\n@@ -276,6 +282,7 @@ pub struct addrinfo {\n #[cfg(windows)] pub type uv_uid_t = libc::c_uchar;\n #[cfg(windows)] pub type uv_gid_t = libc::c_uchar;\n \n+#[repr(C)]\n #[deriving(Eq)]\n pub enum uv_handle_type {\n     UV_UNKNOWN_HANDLE,\n@@ -299,6 +306,7 @@ pub enum uv_handle_type {\n     UV_HANDLE_TYPE_MAX\n }\n \n+#[repr(C)]\n #[cfg(unix)]\n #[deriving(Eq)]\n pub enum uv_req_type {\n@@ -316,6 +324,7 @@ pub enum uv_req_type {\n \n // uv_req_type may have additional fields defined by UV_REQ_TYPE_PRIVATE.\n // See UV_REQ_TYPE_PRIVATE at libuv/include/uv-win.h\n+#[repr(C)]\n #[cfg(windows)]\n #[deriving(Eq)]\n pub enum uv_req_type {\n@@ -339,6 +348,7 @@ pub enum uv_req_type {\n     UV_REQ_TYPE_MAX\n }\n \n+#[repr(C)]\n #[deriving(Eq)]\n pub enum uv_membership {\n     UV_LEAVE_GROUP,\n@@ -349,7 +359,7 @@ pub unsafe fn malloc_handle(handle: uv_handle_type) -> *c_void {\n     #[fixed_stack_segment]; #[inline(never)];\n \n     assert!(handle != UV_UNKNOWN_HANDLE && handle != UV_HANDLE_TYPE_MAX);\n-    let size = rust_uv_handle_size(handle as uint);\n+    let size = uv_handle_size(handle);\n     let p = malloc(size);\n     assert!(p.is_not_null());\n     return p;\n@@ -365,7 +375,7 @@ pub unsafe fn malloc_req(req: uv_req_type) -> *c_void {\n     #[fixed_stack_segment]; #[inline(never)];\n \n     assert!(req != UV_UNKNOWN_REQ && req != UV_REQ_TYPE_MAX);\n-    let size = rust_uv_req_size(req as uint);\n+    let size = uv_req_size(req);\n     let p = malloc(size);\n     assert!(p.is_not_null());\n     return p;\n@@ -400,54 +410,6 @@ pub unsafe fn loop_new() -> *c_void {\n     return rust_uv_loop_new();\n }\n \n-pub unsafe fn loop_delete(loop_handle: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_loop_delete(loop_handle);\n-}\n-\n-pub unsafe fn run(loop_handle: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_run(loop_handle);\n-}\n-\n-pub unsafe fn close<T>(handle: *T, cb: uv_close_cb) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_close(handle as *c_void, cb);\n-}\n-\n-pub unsafe fn walk(loop_handle: *c_void, cb: uv_walk_cb, arg: *c_void) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_walk(loop_handle, cb, arg);\n-}\n-\n-pub unsafe fn idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_idle_init(loop_handle, handle)\n-}\n-\n-pub unsafe fn idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_idle_start(handle, cb)\n-}\n-\n-pub unsafe fn idle_stop(handle: *uv_idle_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_idle_stop(handle)\n-}\n-\n-pub unsafe fn udp_init(loop_handle: *uv_loop_t, handle: *uv_udp_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_init(loop_handle, handle);\n-}\n-\n pub unsafe fn udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -478,19 +440,6 @@ pub unsafe fn udp_send6<T>(req: *uv_udp_send_t, handle: *T, buf_in: &[uv_buf_t],\n     return rust_uv_udp_send6(req, handle as *c_void, buf_ptr, buf_cnt, addr, cb);\n }\n \n-pub unsafe fn udp_recv_start(server: *uv_udp_t, on_alloc: uv_alloc_cb,\n-                             on_recv: uv_udp_recv_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_recv_start(server, on_alloc, on_recv);\n-}\n-\n-pub unsafe fn udp_recv_stop(server: *uv_udp_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_recv_stop(server);\n-}\n-\n pub unsafe fn get_udp_handle_from_send_req(send_req: *uv_udp_send_t) -> *uv_udp_t {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -503,43 +452,6 @@ pub unsafe fn udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_i\n     return rust_uv_udp_getsockname(handle, name);\n }\n \n-pub unsafe fn udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n-                                 interface_addr: *c_char, membership: uv_membership) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_set_membership(handle, multicast_addr, interface_addr, membership as c_int);\n-}\n-\n-pub unsafe fn udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_set_multicast_loop(handle, on);\n-}\n-\n-pub unsafe fn udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_set_multicast_ttl(handle, ttl);\n-}\n-\n-pub unsafe fn udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_set_ttl(handle, ttl);\n-}\n-\n-pub unsafe fn udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_udp_set_broadcast(handle, on);\n-}\n-\n-pub unsafe fn tcp_init(loop_handle: *c_void, handle: *uv_tcp_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_init(loop_handle, handle);\n-}\n-\n pub unsafe fn tcp_connect(connect_ptr: *uv_connect_t, tcp_handle_ptr: *uv_tcp_t,\n                           addr_ptr: *sockaddr_in, after_connect_cb: uv_connect_cb) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -578,108 +490,17 @@ pub unsafe fn tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_i\n     return rust_uv_tcp_getsockname(handle, name);\n }\n \n-pub unsafe fn tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_nodelay(handle, enable);\n-}\n-\n-pub unsafe fn tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_keepalive(handle, enable, delay);\n-}\n-\n-pub unsafe fn tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_tcp_simultaneous_accepts(handle, enable);\n-}\n-\n-pub unsafe fn listen<T>(stream: *T, backlog: c_int,\n-                        cb: uv_connection_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_listen(stream as *c_void, backlog, cb);\n-}\n-\n-pub unsafe fn accept(server: *c_void, client: *c_void) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_accept(server as *c_void, client as *c_void);\n-}\n-\n-pub unsafe fn write<T>(req: *uv_write_t,\n-                       stream: *T,\n+pub unsafe fn uv_write(req: *uv_write_t,\n+                       stream: *uv_stream_t,\n                        buf_in: &[uv_buf_t],\n                        cb: uv_write_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n+    externfn!(fn uv_write(req: *uv_write_t, stream: *uv_stream_t,\n+                          buf_in: *uv_buf_t, buf_cnt: c_int,\n+                          cb: uv_write_cb) -> c_int)\n \n     let buf_ptr = vec::raw::to_ptr(buf_in);\n     let buf_cnt = buf_in.len() as i32;\n-    return rust_uv_write(req as *c_void, stream as *c_void, buf_ptr, buf_cnt, cb);\n-}\n-pub unsafe fn read_start(stream: *uv_stream_t,\n-                         on_alloc: uv_alloc_cb,\n-                         on_read: uv_read_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_read_start(stream as *c_void, on_alloc, on_read);\n-}\n-\n-pub unsafe fn read_stop(stream: *uv_stream_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_read_stop(stream as *c_void);\n-}\n-\n-pub unsafe fn strerror(err: c_int) -> *c_char {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_strerror(err);\n-}\n-pub unsafe fn err_name(err: c_int) -> *c_char {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_err_name(err);\n-}\n-\n-pub unsafe fn async_init(loop_handle: *c_void,\n-                         async_handle: *uv_async_t,\n-                         cb: uv_async_cb) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_async_init(loop_handle, async_handle, cb);\n-}\n-\n-pub unsafe fn async_send(async_handle: *uv_async_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_async_send(async_handle);\n-}\n-pub unsafe fn buf_init(input: *u8, len: uint) -> uv_buf_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let out_buf = uv_buf_t { base: ptr::null(), len: 0 as size_t };\n-    let out_buf_ptr = ptr::to_unsafe_ptr(&out_buf);\n-    rust_uv_buf_init(out_buf_ptr, input, len as size_t);\n-    return out_buf;\n-}\n-\n-pub unsafe fn timer_init(loop_ptr: *c_void, timer_ptr: *uv_timer_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_timer_init(loop_ptr, timer_ptr);\n-}\n-pub unsafe fn timer_start(timer_ptr: *uv_timer_t,\n-                          cb: uv_timer_cb, timeout: u64,\n-                          repeat: u64) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_timer_start(timer_ptr, cb, timeout, repeat);\n-}\n-pub unsafe fn timer_stop(timer_ptr: *uv_timer_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_timer_stop(timer_ptr);\n+    return uv_write(req, stream, buf_ptr, buf_cnt, cb);\n }\n \n pub unsafe fn is_ip4_addr(addr: *sockaddr) -> bool {\n@@ -731,18 +552,6 @@ pub unsafe fn free_ip6_addr(addr: *sockaddr_in6) {\n     rust_uv_free_ip6_addr(addr);\n }\n \n-pub unsafe fn ip4_name(addr: *sockaddr_in, dst: *u8, size: size_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_ip4_name(addr, dst, size);\n-}\n-\n-pub unsafe fn ip6_name(addr: *sockaddr_in6, dst: *u8, size: size_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_ip6_name(addr, dst, size);\n-}\n-\n pub unsafe fn ip4_port(addr: *sockaddr_in) -> c_uint {\n     #[fixed_stack_segment]; #[inline(never)];\n \n@@ -755,99 +564,6 @@ pub unsafe fn ip6_port(addr: *sockaddr_in6) -> c_uint {\n     return rust_uv_ip6_port(addr);\n }\n \n-pub unsafe fn fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, flags: int, mode: int,\n-                cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_open(loop_ptr, req, path, flags as c_int, mode as c_int, cb)\n-}\n-\n-pub unsafe fn fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_unlink(loop_ptr, req, path, cb)\n-}\n-pub unsafe fn fs_write(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n-                       len: uint, offset: i64, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_write(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n-}\n-pub unsafe fn fs_read(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n-                       len: uint, offset: i64, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_read(loop_ptr, req, fd, buf, len as c_uint, offset, cb)\n-}\n-pub unsafe fn fs_close(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n-                cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_close(loop_ptr, req, fd, cb)\n-}\n-pub unsafe fn fs_stat(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_stat(loop_ptr, req, path, cb)\n-}\n-pub unsafe fn fs_fstat(loop_ptr: *uv_loop_t, req: *uv_fs_t, fd: c_int, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_fstat(loop_ptr, req, fd, cb)\n-}\n-pub unsafe fn fs_mkdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                       mode: c_int, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_mkdir(loop_ptr, req, path, mode as c_int, cb)\n-}\n-pub unsafe fn fs_rmdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_rmdir(loop_ptr, req, path, cb)\n-}\n-pub unsafe fn fs_rename(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                        to: *c_char, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_rename(loop_ptr, req, path, to, cb)\n-}\n-pub unsafe fn fs_chmod(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                       mode: c_int, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_chmod(loop_ptr, req, path, mode as c_int, cb)\n-}\n-pub unsafe fn fs_readdir(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n-                flags: c_int, cb: *u8) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_readdir(loop_ptr, req, path, flags, cb)\n-}\n-pub unsafe fn populate_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_populate_uv_stat(req_in, stat_out)\n-}\n-pub unsafe fn fs_req_cleanup(req: *uv_fs_t) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    rust_uv_fs_req_cleanup(req);\n-}\n-\n-pub unsafe fn spawn(loop_ptr: *c_void, result: *uv_process_t,\n-                    options: uv_process_options_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_spawn(loop_ptr, result, options);\n-}\n-\n-pub unsafe fn process_kill(p: *uv_process_t, signum: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_process_kill(p, signum);\n-}\n-\n pub unsafe fn process_pid(p: *uv_process_t) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n     return rust_uv_process_pid(p);\n@@ -871,11 +587,6 @@ pub unsafe fn set_stdio_container_stream(c: *uv_stdio_container_t,\n     rust_set_stdio_container_stream(c, stream);\n }\n \n-pub unsafe fn pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_pipe_init(loop_ptr, p, ipc)\n-}\n-\n // data access helpers\n pub unsafe fn get_result_from_fs_req(req: *uv_fs_t) -> c_int {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -947,114 +658,24 @@ pub unsafe fn set_data_for_req<T, U>(req: *T, data: *U) {\n \n     rust_uv_set_data_for_req(req as *c_void, data as *c_void);\n }\n-pub unsafe fn get_base_from_buf(buf: uv_buf_t) -> *u8 {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_base_from_buf(buf);\n-}\n-pub unsafe fn get_len_from_buf(buf: uv_buf_t) -> size_t {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    return rust_uv_get_len_from_buf(buf);\n-}\n-pub unsafe fn getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n-               getaddrinfo_cb: uv_getaddrinfo_cb,\n-               node: *c_char, service: *c_char,\n-               hints: *addrinfo) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_getaddrinfo(loop_, req, getaddrinfo_cb, node, service, hints);\n-}\n-pub unsafe fn freeaddrinfo(ai: *addrinfo) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_freeaddrinfo(ai);\n-}\n-pub unsafe fn pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_pipe_open(pipe, file)\n-}\n-pub unsafe fn pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_pipe_bind(pipe, name)\n-}\n-pub unsafe fn pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n-                           name: *c_char, cb: uv_connect_cb) {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_pipe_connect(req, handle, name, cb)\n-}\n-pub unsafe fn tty_init(loop_ptr: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n-                       readable: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_tty_init(loop_ptr, tty, fd, readable)\n-}\n-pub unsafe fn tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_tty_set_mode(tty, mode)\n-}\n-pub unsafe fn tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n-                              height: *c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_tty_get_winsize(tty, width, height)\n-}\n-// FIXME(#9613) this should return uv_handle_type, not a c_int\n-pub unsafe fn guess_handle(fd: c_int) -> c_int {\n+pub unsafe fn populate_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t) {\n     #[fixed_stack_segment]; #[inline(never)];\n-    rust_uv_guess_handle(fd)\n-}\n \n-pub unsafe fn signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_signal_init(loop_, handle);\n-}\n-pub unsafe fn signal_start(handle: *uv_signal_t,\n-                           signal_cb: uv_signal_cb,\n-                           signum: c_int) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_signal_start(handle, signal_cb, signum);\n-}\n-pub unsafe fn signal_stop(handle: *uv_signal_t) -> c_int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-    return rust_uv_signal_stop(handle);\n+    rust_uv_populate_uv_stat(req_in, stat_out)\n }\n \n-pub struct uv_err_data {\n-    err_name: ~str,\n-    err_msg: ~str,\n-}\n \n // uv_support is the result of compiling rust_uv.cpp\n #[link_args = \"-luv_support -luv\"]\n extern {\n+    fn rust_uv_loop_new() -> *c_void;\n \n-    fn rust_uv_handle_size(type_: uintptr_t) -> size_t;\n-    fn rust_uv_req_size(type_: uintptr_t) -> size_t;\n     fn rust_uv_handle_type_max() -> uintptr_t;\n     fn rust_uv_req_type_max() -> uintptr_t;\n-\n-    // libuv public API\n-    fn rust_uv_loop_new() -> *c_void;\n-    fn rust_uv_loop_delete(lp: *c_void);\n-    fn rust_uv_run(loop_handle: *c_void);\n-    fn rust_uv_close(handle: *c_void, cb: uv_close_cb);\n-    fn rust_uv_walk(loop_handle: *c_void, cb: uv_walk_cb, arg: *c_void);\n-\n-    fn rust_uv_idle_init(loop_handle: *uv_loop_t, handle: *uv_idle_t) -> c_int;\n-    fn rust_uv_idle_start(handle: *uv_idle_t, cb: uv_idle_cb) -> c_int;\n-    fn rust_uv_idle_stop(handle: *uv_idle_t) -> c_int;\n-\n-    fn rust_uv_async_send(handle: *uv_async_t);\n-    fn rust_uv_async_init(loop_handle: *c_void,\n-                          async_handle: *uv_async_t,\n-                          cb: uv_async_cb) -> c_int;\n-    fn rust_uv_tcp_init(loop_handle: *c_void, handle_ptr: *uv_tcp_t) -> c_int;\n-    fn rust_uv_buf_init(out_buf: *uv_buf_t, base: *u8, len: size_t);\n-    fn rust_uv_strerror(err: c_int) -> *c_char;\n-    fn rust_uv_err_name(err: c_int) -> *c_char;\n     fn rust_uv_ip4_addrp(ip: *u8, port: c_int) -> *sockaddr_in;\n     fn rust_uv_ip6_addrp(ip: *u8, port: c_int) -> *sockaddr_in6;\n     fn rust_uv_free_ip4_addr(addr: *sockaddr_in);\n     fn rust_uv_free_ip6_addr(addr: *sockaddr_in6);\n-    fn rust_uv_ip4_name(src: *sockaddr_in, dst: *u8, size: size_t) -> c_int;\n-    fn rust_uv_ip6_name(src: *sockaddr_in6, dst: *u8, size: size_t) -> c_int;\n     fn rust_uv_ip4_port(src: *sockaddr_in) -> c_uint;\n     fn rust_uv_ip6_port(src: *sockaddr_in6) -> c_uint;\n     fn rust_uv_tcp_connect(req: *uv_connect_t, handle: *uv_tcp_t,\n@@ -1067,137 +688,121 @@ extern {\n     fn rust_uv_tcp_bind6(tcp_server: *uv_tcp_t, addr: *sockaddr_in6) -> c_int;\n     fn rust_uv_tcp_getpeername(tcp_handle_ptr: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n     fn rust_uv_tcp_getsockname(handle: *uv_tcp_t, name: *sockaddr_storage) -> c_int;\n-    fn rust_uv_tcp_nodelay(handle: *uv_tcp_t, enable: c_int) -> c_int;\n-    fn rust_uv_tcp_keepalive(handle: *uv_tcp_t, enable: c_int, delay: c_uint) -> c_int;\n-    fn rust_uv_tcp_simultaneous_accepts(handle: *uv_tcp_t, enable: c_int) -> c_int;\n-\n-    fn rust_uv_udp_init(loop_handle: *uv_loop_t, handle_ptr: *uv_udp_t) -> c_int;\n     fn rust_uv_udp_bind(server: *uv_udp_t, addr: *sockaddr_in, flags: c_uint) -> c_int;\n     fn rust_uv_udp_bind6(server: *uv_udp_t, addr: *sockaddr_in6, flags: c_uint) -> c_int;\n     fn rust_uv_udp_send(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n                         buf_cnt: c_int, addr: *sockaddr_in, cb: uv_udp_send_cb) -> c_int;\n     fn rust_uv_udp_send6(req: *uv_udp_send_t, handle: *uv_udp_t, buf_in: *uv_buf_t,\n                          buf_cnt: c_int, addr: *sockaddr_in6, cb: uv_udp_send_cb) -> c_int;\n-    fn rust_uv_udp_recv_start(server: *uv_udp_t,\n-                              on_alloc: uv_alloc_cb,\n-                              on_recv: uv_udp_recv_cb) -> c_int;\n-    fn rust_uv_udp_recv_stop(server: *uv_udp_t) -> c_int;\n     fn rust_uv_get_udp_handle_from_send_req(req: *uv_udp_send_t) -> *uv_udp_t;\n     fn rust_uv_udp_getsockname(handle: *uv_udp_t, name: *sockaddr_storage) -> c_int;\n-    fn rust_uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n-                                  interface_addr: *c_char, membership: c_int) -> c_int;\n-    fn rust_uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int;\n-    fn rust_uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n-    fn rust_uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int;\n-    fn rust_uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int;\n-\n     fn rust_uv_is_ipv4_sockaddr(addr: *sockaddr) -> c_int;\n     fn rust_uv_is_ipv6_sockaddr(addr: *sockaddr) -> c_int;\n     fn rust_uv_malloc_sockaddr_storage() -> *sockaddr_storage;\n     fn rust_uv_free_sockaddr_storage(ss: *sockaddr_storage);\n-\n-    fn rust_uv_listen(stream: *c_void, backlog: c_int,\n-                      cb: uv_connection_cb) -> c_int;\n-    fn rust_uv_accept(server: *c_void, client: *c_void) -> c_int;\n-    fn rust_uv_write(req: *c_void, stream: *c_void, buf_in: *uv_buf_t, buf_cnt: c_int,\n-                     cb: uv_write_cb) -> c_int;\n-    fn rust_uv_read_start(stream: *c_void,\n-                          on_alloc: uv_alloc_cb,\n-                          on_read: uv_read_cb) -> c_int;\n-    fn rust_uv_read_stop(stream: *c_void) -> c_int;\n-    fn rust_uv_timer_init(loop_handle: *c_void, timer_handle: *uv_timer_t) -> c_int;\n-    fn rust_uv_timer_start(timer_handle: *uv_timer_t, cb: uv_timer_cb, timeout: libc::uint64_t,\n-                           repeat: libc::uint64_t) -> c_int;\n-    fn rust_uv_timer_stop(handle: *uv_timer_t) -> c_int;\n-    fn rust_uv_fs_open(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                       flags: c_int, mode: c_int, cb: *u8) -> c_int;\n-    fn rust_uv_fs_unlink(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                       cb: *u8) -> c_int;\n-    fn rust_uv_fs_write(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n-                       buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n-    fn rust_uv_fs_read(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n-                       buf: *c_void, len: c_uint, offset: i64, cb: *u8) -> c_int;\n-    fn rust_uv_fs_close(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int,\n-                        cb: *u8) -> c_int;\n-    fn rust_uv_fs_stat(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char, cb: *u8) -> c_int;\n-    fn rust_uv_fs_fstat(loop_ptr: *c_void, req: *uv_fs_t, fd: c_int, cb: *u8) -> c_int;\n-    fn rust_uv_fs_mkdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                        mode: c_int, cb: *u8) -> c_int;\n-    fn rust_uv_fs_rmdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                        cb: *u8) -> c_int;\n-    fn rust_uv_fs_rename(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                         to: *c_char, cb: *u8) -> c_int;\n-    fn rust_uv_fs_chmod(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                        mode: c_int, cb: *u8) -> c_int;\n-    fn rust_uv_fs_readdir(loop_ptr: *c_void, req: *uv_fs_t, path: *c_char,\n-                        flags: c_int, cb: *u8) -> c_int;\n-    fn rust_uv_fs_req_cleanup(req: *uv_fs_t);\n     fn rust_uv_populate_uv_stat(req_in: *uv_fs_t, stat_out: *uv_stat_t);\n     fn rust_uv_get_result_from_fs_req(req: *uv_fs_t) -> c_int;\n     fn rust_uv_get_ptr_from_fs_req(req: *uv_fs_t) -> *libc::c_void;\n     fn rust_uv_get_path_from_fs_req(req: *uv_fs_t) -> *c_char;\n     fn rust_uv_get_loop_from_fs_req(req: *uv_fs_t) -> *uv_loop_t;\n     fn rust_uv_get_loop_from_getaddrinfo_req(req: *uv_fs_t) -> *uv_loop_t;\n-\n-    fn rust_uv_get_stream_handle_from_connect_req(connect_req: *uv_connect_t) -> *uv_stream_t;\n-    fn rust_uv_get_stream_handle_from_write_req(write_req: *uv_write_t) -> *uv_stream_t;\n+    fn rust_uv_get_stream_handle_from_connect_req(req: *uv_connect_t) -> *uv_stream_t;\n+    fn rust_uv_get_stream_handle_from_write_req(req: *uv_write_t) -> *uv_stream_t;\n     fn rust_uv_get_loop_for_uv_handle(handle: *c_void) -> *c_void;\n     fn rust_uv_get_data_for_uv_loop(loop_ptr: *c_void) -> *c_void;\n     fn rust_uv_set_data_for_uv_loop(loop_ptr: *c_void, data: *c_void);\n     fn rust_uv_get_data_for_uv_handle(handle: *c_void) -> *c_void;\n     fn rust_uv_set_data_for_uv_handle(handle: *c_void, data: *c_void);\n     fn rust_uv_get_data_for_req(req: *c_void) -> *c_void;\n     fn rust_uv_set_data_for_req(req: *c_void, data: *c_void);\n-    fn rust_uv_get_base_from_buf(buf: uv_buf_t) -> *u8;\n-    fn rust_uv_get_len_from_buf(buf: uv_buf_t) -> size_t;\n-    fn rust_uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n-                           getaddrinfo_cb: uv_getaddrinfo_cb,\n-                           node: *c_char, service: *c_char,\n-                           hints: *addrinfo) -> c_int;\n-    fn rust_uv_freeaddrinfo(ai: *addrinfo);\n-    fn rust_uv_spawn(loop_ptr: *c_void, outptr: *uv_process_t,\n-                     options: uv_process_options_t) -> c_int;\n-    fn rust_uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int;\n-    fn rust_uv_process_pid(p: *uv_process_t) -> c_int;\n     fn rust_set_stdio_container_flags(c: *uv_stdio_container_t, flags: c_int);\n     fn rust_set_stdio_container_fd(c: *uv_stdio_container_t, fd: c_int);\n     fn rust_set_stdio_container_stream(c: *uv_stdio_container_t,\n                                        stream: *uv_stream_t);\n-    fn rust_uv_pipe_init(loop_ptr: *c_void, p: *uv_pipe_t, ipc: c_int) -> c_int;\n-\n-    fn rust_uv_pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int;\n-    fn rust_uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int;\n-    fn rust_uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n-                            name: *c_char, cb: uv_connect_cb);\n-    fn rust_uv_tty_init(loop_ptr: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n-                        readable: c_int) -> c_int;\n-    fn rust_uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int;\n-    fn rust_uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n-                               height: *c_int) -> c_int;\n-    fn rust_uv_guess_handle(fd: c_int) -> c_int;\n-\n-    // XXX: see comments in addrinfo.rs\n-    // These should all really be constants...\n-    //#[rust_stack] pub fn rust_SOCK_STREAM() -> c_int;\n-    //#[rust_stack] pub fn rust_SOCK_DGRAM() -> c_int;\n-    //#[rust_stack] pub fn rust_SOCK_RAW() -> c_int;\n-    //#[rust_stack] pub fn rust_IPPROTO_UDP() -> c_int;\n-    //#[rust_stack] pub fn rust_IPPROTO_TCP() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_ADDRCONFIG() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_ALL() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_CANONNAME() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_NUMERICHOST() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_NUMERICSERV() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_PASSIVE() -> c_int;\n-    //#[rust_stack] pub fn rust_AI_V4MAPPED() -> c_int;\n-\n-    fn rust_uv_signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int;\n-    fn rust_uv_signal_start(handle: *uv_signal_t,\n-                            signal_cb: uv_signal_cb,\n-                            signum: c_int) -> c_int;\n-    fn rust_uv_signal_stop(handle: *uv_signal_t) -> c_int;\n-\n }\n+\n+// generic uv functions\n+externfn!(fn uv_loop_delete(l: *uv_loop_t))\n+externfn!(fn uv_handle_size(ty: uv_handle_type) -> size_t)\n+externfn!(fn uv_req_size(ty: uv_req_type) -> size_t)\n+externfn!(fn uv_run(l: *uv_loop_t, mode: uv_run_mode) -> c_int)\n+externfn!(fn uv_close(h: *uv_handle_t, cb: uv_close_cb))\n+externfn!(fn uv_walk(l: *uv_loop_t, cb: uv_walk_cb, arg: *c_void))\n+externfn!(fn uv_buf_init(base: *c_char, len: c_uint) -> uv_buf_t)\n+externfn!(fn uv_strerror(err: c_int) -> *c_char)\n+externfn!(fn uv_err_name(err: c_int) -> *c_char)\n+externfn!(fn uv_listen(s: *uv_stream_t, backlog: c_int,\n+                       cb: uv_connection_cb) -> c_int)\n+externfn!(fn uv_accept(server: *uv_stream_t, client: *uv_stream_t) -> c_int)\n+externfn!(fn uv_read_start(stream: *uv_stream_t,\n+                           on_alloc: uv_alloc_cb,\n+                           on_read: uv_read_cb) -> c_int)\n+externfn!(fn uv_read_stop(stream: *uv_stream_t) -> c_int)\n+\n+// idle bindings\n+externfn!(fn uv_idle_init(l: *uv_loop_t, i: *uv_idle_t) -> c_int)\n+externfn!(fn uv_idle_start(i: *uv_idle_t, cb: uv_idle_cb) -> c_int)\n+externfn!(fn uv_idle_stop(i: *uv_idle_t) -> c_int)\n+\n+// async bindings\n+externfn!(fn uv_async_init(l: *uv_loop_t, a: *uv_async_t,\n+                           cb: uv_async_cb) -> c_int)\n+externfn!(fn uv_async_send(a: *uv_async_t))\n+\n+// tcp bindings\n+externfn!(fn uv_tcp_init(l: *uv_loop_t, h: *uv_tcp_t) -> c_int)\n+externfn!(fn uv_ip4_name(src: *sockaddr_in, dst: *c_char,\n+                         size: size_t) -> c_int)\n+externfn!(fn uv_ip6_name(src: *sockaddr_in6, dst: *c_char,\n+                         size: size_t) -> c_int)\n+externfn!(fn uv_tcp_nodelay(h: *uv_tcp_t, enable: c_int) -> c_int)\n+externfn!(fn uv_tcp_keepalive(h: *uv_tcp_t, enable: c_int,\n+                              delay: c_uint) -> c_int)\n+externfn!(fn uv_tcp_simultaneous_accepts(h: *uv_tcp_t, enable: c_int) -> c_int)\n+\n+// udp bindings\n+externfn!(fn uv_udp_init(l: *uv_loop_t, h: *uv_udp_t) -> c_int)\n+externfn!(fn uv_udp_recv_start(server: *uv_udp_t,\n+                               on_alloc: uv_alloc_cb,\n+                               on_recv: uv_udp_recv_cb) -> c_int)\n+externfn!(fn uv_udp_set_membership(handle: *uv_udp_t, multicast_addr: *c_char,\n+                                   interface_addr: *c_char,\n+                                   membership: uv_membership) -> c_int)\n+externfn!(fn uv_udp_recv_stop(server: *uv_udp_t) -> c_int)\n+externfn!(fn uv_udp_set_multicast_loop(handle: *uv_udp_t, on: c_int) -> c_int)\n+externfn!(fn uv_udp_set_multicast_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int)\n+externfn!(fn uv_udp_set_ttl(handle: *uv_udp_t, ttl: c_int) -> c_int)\n+externfn!(fn uv_udp_set_broadcast(handle: *uv_udp_t, on: c_int) -> c_int)\n+\n+// timer bindings\n+externfn!(fn uv_timer_init(l: *uv_loop_t, t: *uv_timer_t) -> c_int)\n+externfn!(fn uv_timer_start(t: *uv_timer_t, cb: uv_timer_cb,\n+                            timeout: libc::uint64_t,\n+                            repeat: libc::uint64_t) -> c_int)\n+externfn!(fn uv_timer_stop(handle: *uv_timer_t) -> c_int)\n+\n+// fs operations\n+externfn!(fn uv_fs_open(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                        flags: c_int, mode: c_int, cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_unlink(loop_ptr: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                          cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_write(l: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n+                         len: c_uint, offset: i64, cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_read(l: *uv_loop_t, req: *uv_fs_t, fd: c_int, buf: *c_void,\n+                        len: c_uint, offset: i64, cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_close(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n+                         cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_stat(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                        cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_fstat(l: *uv_loop_t, req: *uv_fs_t, fd: c_int,\n+                         cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_mkdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                         mode: c_int, cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_rmdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                         cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_readdir(l: *uv_loop_t, req: *uv_fs_t, path: *c_char,\n+                           flags: c_int, cb: uv_fs_cb) -> c_int)\n+externfn!(fn uv_fs_req_cleanup(req: *uv_fs_t))\n externfn!(fn uv_fs_fsync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n                          cb: *u8) -> c_int)\n externfn!(fn uv_fs_fdatasync(handle: *uv_loop_t, req: *uv_fs_t, file: c_int,\n@@ -1215,6 +820,39 @@ externfn!(fn uv_fs_chown(handle: *uv_loop_t, req: *uv_fs_t, src: *c_char,\n externfn!(fn uv_fs_lstat(handle: *uv_loop_t, req: *uv_fs_t, file: *c_char,\n                          cb: *u8) -> c_int)\n \n+// getaddrinfo\n+externfn!(fn uv_getaddrinfo(loop_: *uv_loop_t, req: *uv_getaddrinfo_t,\n+                            getaddrinfo_cb: uv_getaddrinfo_cb,\n+                            node: *c_char, service: *c_char,\n+                            hints: *addrinfo) -> c_int)\n+externfn!(fn uv_freeaddrinfo(ai: *addrinfo))\n+\n+// process spawning\n+externfn!(fn uv_spawn(loop_ptr: *uv_loop_t, outptr: *uv_process_t,\n+                      options: uv_process_options_t) -> c_int)\n+externfn!(fn uv_process_kill(p: *uv_process_t, signum: c_int) -> c_int)\n+\n+// pipes\n+externfn!(fn uv_pipe_init(l: *uv_loop_t, p: *uv_pipe_t, ipc: c_int) -> c_int)\n+externfn!(fn uv_pipe_open(pipe: *uv_pipe_t, file: c_int) -> c_int)\n+externfn!(fn uv_pipe_bind(pipe: *uv_pipe_t, name: *c_char) -> c_int)\n+externfn!(fn uv_pipe_connect(req: *uv_connect_t, handle: *uv_pipe_t,\n+                             name: *c_char, cb: uv_connect_cb))\n+\n+// tty\n+externfn!(fn uv_tty_init(l: *uv_loop_t, tty: *uv_tty_t, fd: c_int,\n+                         readable: c_int) -> c_int)\n+externfn!(fn uv_tty_set_mode(tty: *uv_tty_t, mode: c_int) -> c_int)\n+externfn!(fn uv_tty_get_winsize(tty: *uv_tty_t, width: *c_int,\n+                                height: *c_int) -> c_int)\n+externfn!(fn uv_guess_handle(fd: c_int) -> uv_handle_type)\n+\n+// signals\n+externfn!(fn uv_signal_init(loop_: *uv_loop_t, handle: *uv_signal_t) -> c_int)\n+externfn!(fn uv_signal_start(h: *uv_signal_t, cb: uv_signal_cb,\n+                             signum: c_int) -> c_int)\n+externfn!(fn uv_signal_stop(handle: *uv_signal_t) -> c_int)\n+\n // libuv requires various system libraries to successfully link on some\n // platforms\n #[cfg(target_os = \"linux\")]"}, {"sha": "09aa806891ace92abab8ee998ac5038b61d7cd8c", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 0, "deletions": 352, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/30c885ea52458b361bb8f215c17c384743e6851a/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/30c885ea52458b361bb8f215c17c384743e6851a/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=30c885ea52458b361bb8f215c17c384743e6851a", "patch": "@@ -31,80 +31,11 @@ rust_uv_loop_new() {\n     return (void*)uv_loop_new();\n }\n \n-extern \"C\" void\n-rust_uv_loop_delete(uv_loop_t* loop) {\n-    // FIXME: This is a workaround for #1815. libev uses realloc(0) to\n-    // free the loop, which valgrind doesn't like. We have suppressions\n-    // to make valgrind ignore them.\n-    //\n-    // Valgrind also has a sanity check when collecting allocation backtraces\n-    // that the stack pointer must be at least 512 bytes into the stack (at\n-    // least 512 bytes of frames must have come before). When this is not\n-    // the case it doesn't collect the backtrace.\n-    //\n-    // Unfortunately, with our spaghetti stacks that valgrind check triggers\n-    // sometimes and we don't get the backtrace for the realloc(0), it\n-    // fails to be suppressed, and it gets reported as 0 bytes lost\n-    // from a malloc with no backtrace.\n-    //\n-    // This pads our stack with some extra space before deleting the loop\n-    alloca(512);\n-    uv_loop_delete(loop);\n-}\n-\n extern \"C\" void\n rust_uv_loop_set_data(uv_loop_t* loop, void* data) {\n     loop->data = data;\n }\n \n-extern \"C\" void\n-rust_uv_run(uv_loop_t* loop) {\n-    uv_run(loop, UV_RUN_DEFAULT);\n-}\n-\n-extern \"C\" void\n-rust_uv_close(uv_handle_t* handle, uv_close_cb cb) {\n-    uv_close(handle, cb);\n-}\n-\n-extern \"C\" void\n-rust_uv_walk(uv_loop_t* loop, uv_walk_cb cb, void* arg) {\n-    uv_walk(loop, cb, arg);\n-}\n-\n-extern \"C\" void\n-rust_uv_async_send(uv_async_t* handle) {\n-    uv_async_send(handle);\n-}\n-\n-extern \"C\" int\n-rust_uv_async_init(uv_loop_t* loop_handle,\n-        uv_async_t* async_handle,\n-        uv_async_cb cb) {\n-    return uv_async_init(loop_handle, async_handle, cb);\n-}\n-\n-extern \"C\" int\n-rust_uv_timer_init(uv_loop_t* loop, uv_timer_t* timer) {\n-    return uv_timer_init(loop, timer);\n-}\n-\n-extern \"C\" int\n-rust_uv_timer_start(uv_timer_t* the_timer, uv_timer_cb cb,\n-                    int64_t timeout, int64_t repeat) {\n-    return uv_timer_start(the_timer, cb, timeout, repeat);\n-}\n-\n-extern \"C\" int\n-rust_uv_timer_stop(uv_timer_t* the_timer) {\n-    return uv_timer_stop(the_timer);\n-}\n-\n-extern \"C\" int\n-rust_uv_tcp_init(uv_loop_t* loop, uv_tcp_t* handle) {\n-    return uv_tcp_init(loop, handle);\n-}\n-\n extern \"C\" int\n rust_uv_tcp_connect(uv_connect_t* connect_ptr,\n         uv_tcp_t* tcp_ptr,\n@@ -159,29 +90,6 @@ rust_uv_tcp_getsockname\n     return uv_tcp_getsockname(handle, (sockaddr*)name, &namelen);\n }\n \n-extern \"C\" int\n-rust_uv_tcp_nodelay\n-(uv_tcp_t* handle, int enable) {\n-    return uv_tcp_nodelay(handle, enable);\n-}\n-\n-extern \"C\" int\n-rust_uv_tcp_keepalive\n-(uv_tcp_t* handle, int enable, unsigned int delay) {\n-    return uv_tcp_keepalive(handle, enable, delay);\n-}\n-\n-extern \"C\" int\n-rust_uv_tcp_simultaneous_accepts\n-(uv_tcp_t* handle, int enable) {\n-    return uv_tcp_simultaneous_accepts(handle, enable);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_init(uv_loop_t* loop, uv_udp_t* handle) {\n-    return uv_udp_init(loop, handle);\n-}\n-\n extern \"C\" int\n rust_uv_udp_bind(uv_udp_t* server, sockaddr_in* addr_ptr, unsigned flags) {\n     return uv_udp_bind(server, *addr_ptr, flags);\n@@ -204,16 +112,6 @@ rust_uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle, uv_buf_t* buf_in,\n     return uv_udp_send6(req, handle, buf_in, buf_cnt, *addr_ptr, cb);\n }\n \n-extern \"C\" int\n-rust_uv_udp_recv_start(uv_udp_t* server, uv_alloc_cb on_alloc, uv_udp_recv_cb on_read) {\n-    return uv_udp_recv_start(server, on_alloc, on_read);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_recv_stop(uv_udp_t* server) {\n-    return uv_udp_recv_stop(server);\n-}\n-\n extern \"C\" uv_udp_t*\n rust_uv_get_udp_handle_from_send_req(uv_udp_send_t* send_req) {\n     return send_req->handle;\n@@ -228,47 +126,6 @@ rust_uv_udp_getsockname\n     return uv_udp_getsockname(handle, (sockaddr*)name, &namelen);\n }\n \n-extern \"C\" int\n-rust_uv_udp_set_membership\n-(uv_udp_t* handle, const char* m_addr, const char* i_addr, uv_membership membership) {\n-    return uv_udp_set_membership(handle, m_addr, i_addr, membership);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_set_multicast_loop\n-(uv_udp_t* handle, int on) {\n-    return uv_udp_set_multicast_loop(handle, on);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_set_multicast_ttl\n-(uv_udp_t* handle, int ttl) {\n-    return uv_udp_set_multicast_ttl(handle, ttl);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_set_ttl\n-(uv_udp_t* handle, int ttl) {\n-    return uv_udp_set_ttl(handle, ttl);\n-}\n-\n-extern \"C\" int\n-rust_uv_udp_set_broadcast\n-(uv_udp_t* handle, int on) {\n-    return uv_udp_set_broadcast(handle, on);\n-}\n-\n-extern \"C\" int\n-rust_uv_listen(uv_stream_t* stream, int backlog,\n-        uv_connection_cb cb) {\n-    return uv_listen(stream, backlog, cb);\n-}\n-\n-extern \"C\" int\n-rust_uv_accept(uv_stream_t* server, uv_stream_t* client) {\n-    return uv_accept(server, client);\n-}\n-\n extern \"C\" uv_stream_t*\n rust_uv_get_stream_handle_from_connect_req(uv_connect_t* connect) {\n     return connect->handle;\n@@ -319,43 +176,6 @@ rust_uv_set_data_for_req(uv_req_t* req, void* data) {\n     req->data = data;\n }\n \n-extern \"C\" char*\n-rust_uv_get_base_from_buf(uv_buf_t buf) {\n-    return buf.base;\n-}\n-\n-extern \"C\" size_t\n-rust_uv_get_len_from_buf(uv_buf_t buf) {\n-    return buf.len;\n-}\n-\n-extern \"C\" const char*\n-rust_uv_strerror(int err) {\n-    return uv_strerror(err);\n-}\n-\n-extern \"C\" const char*\n-rust_uv_err_name(int err) {\n-    return uv_err_name(err);\n-}\n-\n-extern \"C\" int\n-rust_uv_write(uv_write_t* req, uv_stream_t* handle,\n-        uv_buf_t* bufs, int buf_cnt,\n-        uv_write_cb cb) {\n-    return uv_write(req, handle, bufs, buf_cnt, cb);\n-}\n-extern \"C\" int\n-rust_uv_read_start(uv_stream_t* stream, uv_alloc_cb on_alloc,\n-        uv_read_cb on_read) {\n-    return uv_read_start(stream, on_alloc, on_read);\n-}\n-\n-extern \"C\" int\n-rust_uv_read_stop(uv_stream_t* stream) {\n-    return uv_read_stop(stream);\n-}\n-\n extern \"C\" struct sockaddr_in\n rust_uv_ip4_addr(const char* ip, int port) {\n     struct sockaddr_in addr = uv_ip4_addr(ip, port);\n@@ -403,16 +223,6 @@ extern \"C\" void\n rust_uv_free_ip6_addr(sockaddr_in6 *addrp) {\n   free(addrp);\n }\n-\n-extern \"C\" int\n-rust_uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size) {\n-    return uv_ip4_name(src, dst, size);\n-}\n-extern \"C\" int\n-rust_uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size) {\n-    int result = uv_ip6_name(src, dst, size);\n-    return result;\n-}\n extern \"C\" unsigned int\n rust_uv_ip4_port(struct sockaddr_in* src) {\n     return ntohs(src->sin_port);\n@@ -422,18 +232,6 @@ rust_uv_ip6_port(struct sockaddr_in6* src) {\n     return ntohs(src->sin6_port);\n }\n \n-extern  \"C\" int\n-rust_uv_getaddrinfo(uv_loop_t* loop, uv_getaddrinfo_t* handle,\n-                    uv_getaddrinfo_cb cb,\n-                    char* node, char* service,\n-                    addrinfo* hints) {\n-    return uv_getaddrinfo(loop, handle, cb, node, service, hints);\n-}\n-extern \"C\" void\n-rust_uv_freeaddrinfo(addrinfo* res) {\n-    uv_freeaddrinfo(res);\n-}\n-\n extern \"C\" int\n rust_uv_is_ipv4_sockaddr(sockaddr* addr) {\n     return addr->sa_family == AF_INET;\n@@ -466,31 +264,6 @@ rust_uv_addrinfo_as_sockaddr_in6(addrinfo* input) {\n     return (sockaddr_in6*)input->ai_addr;\n }\n \n-extern \"C\" int\n-rust_uv_idle_init(uv_loop_t* loop, uv_idle_t* idle) {\n-  return uv_idle_init(loop, idle);\n-}\n-\n-extern \"C\" int\n-rust_uv_idle_start(uv_idle_t* idle, uv_idle_cb cb) {\n-  return uv_idle_start(idle, cb);\n-}\n-\n-extern \"C\" int\n-rust_uv_idle_stop(uv_idle_t* idle) {\n-  return uv_idle_stop(idle);\n-}\n-\n-extern \"C\" size_t\n-rust_uv_handle_size(uintptr_t type) {\n-  return uv_handle_size((uv_handle_type)type);\n-}\n-\n-extern \"C\" size_t\n-rust_uv_req_size(uintptr_t type) {\n-  return uv_req_size((uv_req_type)type);\n-}\n-\n extern \"C\" uintptr_t\n rust_uv_handle_type_max() {\n   return UV_HANDLE_TYPE_MAX;\n@@ -501,33 +274,6 @@ rust_uv_req_type_max() {\n   return UV_REQ_TYPE_MAX;\n }\n \n-extern \"C\" int\n-rust_uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags,\n-                int mode, uv_fs_cb cb) {\n-  return uv_fs_open(loop, req, path, flags, mode, cb);\n-}\n-extern \"C\" int\n-rust_uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n-  return uv_fs_unlink(loop, req, path, cb);\n-}\n-extern \"C\" int\n-rust_uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,\n-                 size_t len, int64_t offset, uv_fs_cb cb) {\n-  return uv_fs_write(loop, req, fd, buf, len, offset, cb);\n-}\n-extern \"C\" int\n-rust_uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file fd, void* buf,\n-                 size_t len, int64_t offset, uv_fs_cb cb) {\n-  return uv_fs_read(loop, req, fd, buf, len, offset, cb);\n-}\n-extern \"C\" int\n-rust_uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file fd, uv_fs_cb cb) {\n-  return uv_fs_close(loop, req, fd, cb);\n-}\n-extern \"C\" void\n-rust_uv_fs_req_cleanup(uv_fs_t* req) {\n-  uv_fs_req_cleanup(req);\n-}\n extern \"C\" int\n rust_uv_get_result_from_fs_req(uv_fs_t* req) {\n   return req->result;\n@@ -550,15 +296,6 @@ rust_uv_get_loop_from_getaddrinfo_req(uv_getaddrinfo_t* req) {\n   return req->loop;\n }\n \n-extern \"C\" int\n-rust_uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n-  return uv_fs_stat(loop, req, path, cb);\n-}\n-extern \"C\" int\n-rust_uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n-  return uv_fs_fstat(loop, req, file, cb);\n-}\n-\n extern \"C\" void\n rust_uv_populate_uv_stat(uv_fs_t* req_in, uv_stat_t* stat_out) {\n   stat_out->st_dev = req_in->statbuf.st_dev;\n@@ -583,39 +320,6 @@ rust_uv_populate_uv_stat(uv_fs_t* req_in, uv_stat_t* stat_out) {\n   stat_out->st_birthtim.tv_nsec = req_in->statbuf.st_birthtim.tv_nsec;\n }\n \n-extern \"C\" int\n-rust_uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {\n-  return uv_fs_mkdir(loop, req, path, mode, cb);\n-}\n-extern \"C\" int\n-rust_uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n-  return uv_fs_rmdir(loop, req, path, cb);\n-}\n-\n-extern \"C\" int\n-rust_uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags, uv_fs_cb cb) {\n-  return uv_fs_readdir(loop, req, path, flags, cb);\n-}\n-extern \"C\" int\n-rust_uv_fs_rename(uv_loop_t *loop, uv_fs_t* req, const char *path,\n-                  const char *to, uv_fs_cb cb) {\n-    return uv_fs_rename(loop, req, path, to, cb);\n-}\n-extern \"C\" int\n-rust_uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {\n-  return uv_fs_chmod(loop, req, path, mode, cb);\n-}\n-\n-extern \"C\" int\n-rust_uv_spawn(uv_loop_t *loop, uv_process_t *p, uv_process_options_t options) {\n-  return uv_spawn(loop, p, options);\n-}\n-\n-extern \"C\" int\n-rust_uv_process_kill(uv_process_t *p, int signum) {\n-  return uv_process_kill(p, signum);\n-}\n-\n extern \"C\" void\n rust_set_stdio_container_flags(uv_stdio_container_t *c, int flags) {\n   c->flags = (uv_stdio_flags) flags;\n@@ -635,59 +339,3 @@ extern \"C\" int\n rust_uv_process_pid(uv_process_t* p) {\n   return p->pid;\n }\n-\n-extern \"C\" int\n-rust_uv_pipe_init(uv_loop_t *loop, uv_pipe_t* p, int ipc) {\n-  return uv_pipe_init(loop, p, ipc);\n-}\n-\n-extern \"C\" int\n-rust_uv_pipe_open(uv_pipe_t *pipe, int file) {\n-    return uv_pipe_open(pipe, file);\n-}\n-\n-extern \"C\" int\n-rust_uv_pipe_bind(uv_pipe_t *pipe, char *name) {\n-    return uv_pipe_bind(pipe, name);\n-}\n-\n-extern \"C\" void\n-rust_uv_pipe_connect(uv_connect_t *req, uv_pipe_t *handle,\n-                     char *name, uv_connect_cb cb) {\n-    uv_pipe_connect(req, handle, name, cb);\n-}\n-\n-extern \"C\" int\n-rust_uv_tty_init(uv_loop_t *loop, uv_tty_t *tty, int fd, int readable) {\n-    return uv_tty_init(loop, tty, fd, readable);\n-}\n-\n-extern \"C\" int\n-rust_uv_tty_set_mode(uv_tty_t *tty, int mode) {\n-    return uv_tty_set_mode(tty, mode);\n-}\n-\n-extern \"C\" int\n-rust_uv_tty_get_winsize(uv_tty_t *tty, int *width, int *height) {\n-    return uv_tty_get_winsize(tty, width, height);\n-}\n-\n-extern \"C\" int\n-rust_uv_guess_handle(int fd) {\n-    return uv_guess_handle(fd);\n-}\n-\n-extern \"C\" int\n-rust_uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) {\n-  return uv_signal_init(loop, handle);\n-}\n-\n-extern \"C\" int\n-rust_uv_signal_start(uv_signal_t* handle, uv_signal_cb signal_cb, int signum) {\n-  return uv_signal_start(handle, signal_cb, signum);\n-}\n-\n-extern \"C\" int\n-rust_uv_signal_stop(uv_signal_t* handle) {\n-  return uv_signal_stop(handle);\n-}"}]}