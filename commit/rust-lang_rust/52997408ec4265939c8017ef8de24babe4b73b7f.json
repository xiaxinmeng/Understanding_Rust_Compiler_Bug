{"sha": "52997408ec4265939c8017ef8de24babe4b73b7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyOTk3NDA4ZWM0MjY1OTM5YzgwMTdlZjhkZTI0YmFiZTRiNzNiN2Y=", "commit": {"author": {"name": "Liigo Zhuang", "email": "com.liigo@gmail.com", "date": "2014-12-25T05:39:29Z"}, "committer": {"name": "Liigo Zhuang", "email": "com.liigo@gmail.com", "date": "2015-01-21T13:31:09Z"}, "message": "rustdoc: eliminates raw markdown code (links, headers, etc.) from tooltips of sidebar", "tree": {"sha": "34b769c1159e293d9b499630c1c3817512727caf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34b769c1159e293d9b499630c1c3817512727caf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52997408ec4265939c8017ef8de24babe4b73b7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52997408ec4265939c8017ef8de24babe4b73b7f", "html_url": "https://github.com/rust-lang/rust/commit/52997408ec4265939c8017ef8de24babe4b73b7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52997408ec4265939c8017ef8de24babe4b73b7f/comments", "author": {"login": "liigo", "id": 346530, "node_id": "MDQ6VXNlcjM0NjUzMA==", "avatar_url": "https://avatars.githubusercontent.com/u/346530?v=4", "gravatar_id": "", "url": "https://api.github.com/users/liigo", "html_url": "https://github.com/liigo", "followers_url": "https://api.github.com/users/liigo/followers", "following_url": "https://api.github.com/users/liigo/following{/other_user}", "gists_url": "https://api.github.com/users/liigo/gists{/gist_id}", "starred_url": "https://api.github.com/users/liigo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/liigo/subscriptions", "organizations_url": "https://api.github.com/users/liigo/orgs", "repos_url": "https://api.github.com/users/liigo/repos", "events_url": "https://api.github.com/users/liigo/events{/privacy}", "received_events_url": "https://api.github.com/users/liigo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "liigo", "id": 346530, "node_id": "MDQ6VXNlcjM0NjUzMA==", "avatar_url": "https://avatars.githubusercontent.com/u/346530?v=4", "gravatar_id": "", "url": "https://api.github.com/users/liigo", "html_url": "https://github.com/liigo", "followers_url": "https://api.github.com/users/liigo/followers", "following_url": "https://api.github.com/users/liigo/following{/other_user}", "gists_url": "https://api.github.com/users/liigo/gists{/gist_id}", "starred_url": "https://api.github.com/users/liigo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/liigo/subscriptions", "organizations_url": "https://api.github.com/users/liigo/orgs", "repos_url": "https://api.github.com/users/liigo/repos", "events_url": "https://api.github.com/users/liigo/events{/privacy}", "received_events_url": "https://api.github.com/users/liigo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c06442bcd340a55c24ce30bfe2c43054f232d93", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c06442bcd340a55c24ce30bfe2c43054f232d93", "html_url": "https://github.com/rust-lang/rust/commit/0c06442bcd340a55c24ce30bfe2c43054f232d93"}], "stats": {"total": 113, "additions": 108, "deletions": 5}, "files": [{"sha": "7ebb3d4b86aca7ff05c6da63e9ed7ac562a1af9d", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 92, "deletions": 4, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/52997408ec4265939c8017ef8de24babe4b73b7f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52997408ec4265939c8017ef8de24babe4b73b7f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=52997408ec4265939c8017ef8de24babe4b73b7f", "patch": "@@ -74,14 +74,34 @@ type headerfn = extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n \n #[repr(C)]\n struct hoedown_renderer {\n-    opaque: *mut hoedown_html_renderer_state,\n+    opaque: *mut libc::c_void,\n+\n     blockcode: Option<blockcodefn>,\n     blockquote: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                      *mut libc::c_void)>,\n     blockhtml: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n                                     *mut libc::c_void)>,\n     header: Option<headerfn>,\n-    other: [libc::size_t; 28],\n+\n+    other_block_level_callbacks: [libc::size_t, ..9],\n+\n+    /* span level callbacks - NULL or return 0 prints the span verbatim */\n+    other_span_level_callbacks_1: [libc::size_t, ..9],\n+    link: Option<extern \"C\" fn (*mut hoedown_buffer, *const hoedown_buffer,\n+                                *const hoedown_buffer, *const hoedown_buffer,\n+                                *mut libc::c_void) -> libc::c_int>,\n+    other_span_level_callbacks_2: [libc::size_t, ..5],\n+    // hoedown will add `math` callback here, but we use an old version of it.\n+\n+    /* low level callbacks - NULL copies input directly into the output */\n+    entity: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                 *mut libc::c_void)>,\n+    normal_text: Option<extern \"C\" fn(*mut hoedown_buffer, *const hoedown_buffer,\n+                                      *mut libc::c_void)>,\n+\n+    /* header and footer */\n+    doc_header: Option<extern \"C\" fn(*mut hoedown_buffer, *mut libc::c_void)>,\n+    doc_footer: Option<extern \"C\" fn(*mut hoedown_buffer, *mut libc::c_void)>,\n }\n \n #[repr(C)]\n@@ -134,6 +154,8 @@ extern {\n     fn hoedown_document_free(md: *mut hoedown_document);\n \n     fn hoedown_buffer_new(unit: libc::size_t) -> *mut hoedown_buffer;\n+    fn hoedown_buffer_put(b: *mut hoedown_buffer, c: *const libc::c_char,\n+                          n: libc::size_t);\n     fn hoedown_buffer_puts(b: *mut hoedown_buffer, c: *const libc::c_char);\n     fn hoedown_buffer_free(b: *mut hoedown_buffer);\n \n@@ -279,7 +301,8 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n             dfltblk: (*renderer).blockcode.unwrap(),\n             toc_builder: if print_toc {Some(TocBuilder::new())} else {None}\n         };\n-        (*(*renderer).opaque).opaque = &mut opaque as *mut _ as *mut libc::c_void;\n+        (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n+                = &mut opaque as *mut _ as *mut libc::c_void;\n         (*renderer).blockcode = Some(block as blockcodefn);\n         (*renderer).header = Some(header as headerfn);\n \n@@ -355,7 +378,8 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n         let renderer = hoedown_html_renderer_new(0, 0);\n         (*renderer).blockcode = Some(block as blockcodefn);\n         (*renderer).header = Some(header as headerfn);\n-        (*(*renderer).opaque).opaque = tests as *mut _ as *mut libc::c_void;\n+        (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n+                = tests as *mut _ as *mut libc::c_void;\n \n         let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n         hoedown_document_render(document, ob, doc.as_ptr(),\n@@ -442,9 +466,59 @@ impl<'a> fmt::String for MarkdownWithToc<'a> {\n     }\n }\n \n+pub fn plain_summary_line(md: &str) -> String {\n+    extern \"C\" fn link(_ob: *mut hoedown_buffer,\n+                       _link: *const hoedown_buffer,\n+                       _title: *const hoedown_buffer,\n+                       content: *const hoedown_buffer,\n+                       opaque: *mut libc::c_void) -> libc::c_int\n+    {\n+        unsafe {\n+            if !content.is_null() && (*content).size > 0 {\n+                // FIXME(liigo): I don't know why the parameter `_ob` is\n+                // not the value passed in by `hoedown_document_render`.\n+                // I have to manually pass in `ob` through `opaque` currently.\n+                let ob = opaque as *mut hoedown_buffer;\n+                hoedown_buffer_put(ob, (*content).data as *const libc::c_char,\n+                                   (*content).size);\n+            }\n+        }\n+        1\n+    }\n+\n+    extern \"C\" fn normal_text(_ob: *mut hoedown_buffer,\n+                              text: *const hoedown_buffer,\n+                              opaque: *mut libc::c_void)\n+    {\n+        unsafe {\n+            let ob = opaque as *mut hoedown_buffer;\n+            hoedown_buffer_put(ob, (*text).data as *const libc::c_char,\n+                               (*text).size);\n+        }\n+    }\n+\n+    unsafe {\n+        let ob = hoedown_buffer_new(DEF_OUNIT);\n+        let mut plain_renderer: hoedown_renderer = ::std::mem::zeroed();\n+        let renderer = &mut plain_renderer as *mut hoedown_renderer;\n+        (*renderer).opaque = ob as *mut libc::c_void;\n+        (*renderer).link = Some(link);\n+        (*renderer).normal_text = Some(normal_text);\n+\n+        let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n+        hoedown_document_render(document, ob, md.as_ptr(),\n+                                md.len() as libc::size_t);\n+        hoedown_document_free(document);\n+        let plain = String::from_raw_buf_len((*ob).data, (*ob).size as uint);\n+        hoedown_buffer_free(ob);\n+        plain\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::{LangString, Markdown};\n+    use super::plain_summary_line;\n \n     #[test]\n     fn test_lang_string_parse() {\n@@ -478,4 +552,18 @@ mod tests {\n         let markdown = \"# title\";\n         format!(\"{}\", Markdown(markdown.as_slice()));\n     }\n+\n+    #[test]\n+    fn test_plain_summary_line() {\n+        fn t(input: &str, expect: &str) {\n+            let output = plain_summary_line(input);\n+            assert_eq!(output, expect);\n+        }\n+\n+        t(\"hello [Rust](http://rust-lang.org) :)\", \"hello Rust :)\");\n+        t(\"code `let x = i32;` ...\", \"code `let x = i32;` ...\");\n+        t(\"type `Type<'static>` ...\", \"type `Type<'static>` ...\");\n+        t(\"# top header\", \"top header\");\n+        t(\"## header\", \"header\");\n+    }\n }"}, {"sha": "3ec29dab555a8560b6532de17ee617b6489b53b7", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/52997408ec4265939c8017ef8de24babe4b73b7f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52997408ec4265939c8017ef8de24babe4b73b7f/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=52997408ec4265939c8017ef8de24babe4b73b7f", "patch": "@@ -2197,6 +2197,21 @@ fn item_typedef(w: &mut fmt::Formatter, it: &clean::Item,\n     document(w, it)\n }\n \n+fn escape_title(title: &str) -> String {\n+    let title = markdown::plain_summary_line(title);\n+    let mut result = String::with_capacity(title.len());\n+    for c in title.chars() {\n+        match c {\n+            '<' => result.push_str(\"&lt;\"),\n+            '>' => result.push_str(\"&gt;\"),\n+            '\"' => result.push_str(\"&quot;\"),\n+            '\\'' => result.push_str(\"&#39;\"),\n+            _ => result.push(c),\n+        }\n+    }\n+    result\n+}\n+\n impl<'a> fmt::String for Sidebar<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let cx = self.cx;\n@@ -2236,7 +2251,7 @@ impl<'a> fmt::String for Sidebar<'a> {\n                        } else {\n                            format!(\"{}.{}.html\", short, name.as_slice())\n                        },\n-                       title = doc.as_ref().unwrap().as_slice(),\n+                       title = escape_title(doc.as_ref().unwrap().as_slice()),\n                        name = name.as_slice()));\n             }\n             try!(write!(w, \"</div>\"));"}]}