{"sha": "74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0ZjdlMDY5MzkwOWE0NWY5MTU5YzZkMmVmNzJiNDJmY2I0ZjFiYWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-03T23:36:07Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-04T04:11:20Z"}, "message": "rollup merge of #21899: nikomatsakis/closure-unify-anyhow\n\nThis *almost* completes the job for #16440. The idea is that even if we do not know whether some closure type `C` implements `Fn` or `FnMut` (etc), we still know its argument and return types. So if we see an obligation `C : Fn(_0)`, we can unify `_0` with those argument types while still considering the obligation ambiguous and unsatisfied. This helps to make a lot of progress with type inference even before closure kind inference is done.\n\nAs part of this PR, the explicit `:` syntax is removed from the AST and completely ignored. We still infer the closure kind based on the expected type if that is available. There are several reasons for this. First, deciding the closure kind earlier is always better, as it allows us to make more progress. Second, this retains a (admittedly obscure) way for users to manually specify the closure kind, which is useful for writing tests if nothing else. Finally, there are still some cases where inference can fail, so it may be useful to have this manual override. (The expectation is that we will eventually revisit an explicit syntax for specifying the closure kind, but it will not be `:` and may be some sort of generalization of the `||` syntax to handle other traits as well.)\n\nThis commit does not *quite* fix #16640 because a snapshot is still needed to enable the obsolete syntax errors for explicit `&mut:` and friends.\n\nr? @eddyb as he reviewed the prior patch in this direction", "tree": {"sha": "4a275ef4606878200f7a1e7ee57cf9fa1bb75b16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a275ef4606878200f7a1e7ee57cf9fa1bb75b16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "html_url": "https://github.com/rust-lang/rust/commit/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d921f557d6d9e509ce0d696d7b2178628989935", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d921f557d6d9e509ce0d696d7b2178628989935", "html_url": "https://github.com/rust-lang/rust/commit/1d921f557d6d9e509ce0d696d7b2178628989935"}, {"sha": "8ddcb06b1d021560bfe641c0dbc452a04e80388e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ddcb06b1d021560bfe641c0dbc452a04e80388e", "html_url": "https://github.com/rust-lang/rust/commit/8ddcb06b1d021560bfe641c0dbc452a04e80388e"}], "stats": {"total": 598, "additions": 349, "deletions": 249}, "files": [{"sha": "ea584407944abeaa89d657e1cf47953fa62700ef", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'v> Visitor<'v> for CheckLoopVisitor<'a> {\n             ast::ExprLoop(ref b, _) => {\n                 self.with_context(Loop, |v| v.visit_block(&**b));\n             }\n-            ast::ExprClosure(_, _, _, ref b) => {\n+            ast::ExprClosure(_, _, ref b) => {\n                 self.with_context(Closure, |v| v.visit_block(&**b));\n             }\n             ast::ExprBreak(_) => self.require_loop(\"break\", e.span),"}, {"sha": "c0fabb2a3481d7c622145e6ec939388e7f49ee40", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -959,7 +959,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&**e, succ)\n           }\n \n-          ast::ExprClosure(_, _, _, ref blk) => {\n+          ast::ExprClosure(_, _, ref blk) => {\n               debug!(\"{} is an ExprClosure\",\n                      expr_to_string(expr));\n "}, {"sha": "156ff43e2bab3c690e1e491c6d33ace9dfef276f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -739,7 +739,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             };\n \n             match fn_expr.node {\n-                ast::ExprClosure(_, _, _, ref body) => body.id,\n+                ast::ExprClosure(_, _, ref body) => body.id,\n                 _ => unreachable!()\n             }\n         };"}, {"sha": "c2a451b405bb5008018d635a94662460178a746c", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 54, "deletions": 21, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -80,37 +80,23 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n            obligation.repr(selcx.tcx()));\n \n     let infcx = selcx.infcx();\n-    let result = infcx.try(|snapshot| {\n+    infcx.try(|snapshot| {\n         let (skol_predicate, skol_map) =\n             infcx.skolemize_late_bound_regions(&obligation.predicate, snapshot);\n \n         let skol_obligation = obligation.with(skol_predicate);\n         match project_and_unify_type(selcx, &skol_obligation) {\n-            Ok(Some(obligations)) => {\n+            Ok(result) => {\n                 match infcx.leak_check(&skol_map, snapshot) {\n-                    Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, &obligations)),\n-                    Err(e) => Err(Some(MismatchedProjectionTypes { err: e })),\n+                    Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, &result)),\n+                    Err(e) => Err(MismatchedProjectionTypes { err: e }),\n                 }\n             }\n-            Ok(None) => {\n-                // Signal ambiguity using Err just so that infcx.try()\n-                // rolls back the snapshot. We adapt below.\n-                Err(None)\n-            }\n             Err(e) => {\n-                Err(Some(e))\n+                Err(e)\n             }\n         }\n-    });\n-\n-    // Above, we use Err(None) to signal ambiguity so that the\n-    // snapshot will be rolled back. But here, we want to translate to\n-    // Ok(None). Kind of weird.\n-    match result {\n-        Ok(obligations) => Ok(Some(obligations)),\n-        Err(None) => Ok(None),\n-        Err(Some(e)) => Err(e),\n-    }\n+    })\n }\n \n /// Evaluates constraints of the form:\n@@ -132,7 +118,10 @@ fn project_and_unify_type<'cx,'tcx>(\n                                             obligation.cause.clone(),\n                                             obligation.recursion_depth) {\n             Some(n) => n,\n-            None => { return Ok(None); }\n+            None => {\n+                consider_unification_despite_ambiguity(selcx, obligation);\n+                return Ok(None);\n+            }\n         };\n \n     debug!(\"project_and_unify_type: normalized_ty={} obligations={}\",\n@@ -147,6 +136,50 @@ fn project_and_unify_type<'cx,'tcx>(\n     }\n }\n \n+fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext<'cx,'tcx>,\n+                                                    obligation: &ProjectionObligation<'tcx>) {\n+    debug!(\"consider_unification_despite_ambiguity(obligation={})\",\n+           obligation.repr(selcx.tcx()));\n+\n+    let def_id = obligation.predicate.projection_ty.trait_ref.def_id;\n+    match selcx.tcx().lang_items.fn_trait_kind(def_id) {\n+        Some(_) => { }\n+        None => { return; }\n+    }\n+\n+    let infcx = selcx.infcx();\n+    let self_ty = obligation.predicate.projection_ty.trait_ref.self_ty();\n+    let self_ty = infcx.shallow_resolve(self_ty);\n+    debug!(\"consider_unification_despite_ambiguity: self_ty.sty={:?}\",\n+           self_ty.sty);\n+    match self_ty.sty {\n+        ty::ty_closure(closure_def_id, _, substs) => {\n+            let closure_typer = selcx.closure_typer();\n+            let closure_type = closure_typer.closure_type(closure_def_id, substs);\n+            let ty::Binder((_, ret_type)) =\n+                util::closure_trait_ref_and_return_type(infcx.tcx,\n+                                                        def_id,\n+                                                        self_ty,\n+                                                        &closure_type.sig,\n+                                                        util::TupleArgumentsFlag::No);\n+            let (ret_type, _) =\n+                infcx.replace_late_bound_regions_with_fresh_var(\n+                    obligation.cause.span,\n+                    infer::AssocTypeProjection(obligation.predicate.projection_ty.item_name),\n+                    &ty::Binder(ret_type));\n+            debug!(\"consider_unification_despite_ambiguity: ret_type={:?}\",\n+                   ret_type.repr(selcx.tcx()));\n+            let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+            let obligation_ty = obligation.predicate.ty;\n+            match infer::mk_eqty(infcx, true, origin, obligation_ty, ret_type) {\n+                Ok(()) => { }\n+                Err(_) => { /* ignore errors */ }\n+            }\n+        }\n+        _ => { }\n+    }\n+}\n+\n /// Normalizes any associated type projections in `value`, replacing\n /// them with a fully resolved type where possible. The return value\n /// combines the normalized result and any additional obligations that"}, {"sha": "b8af91add9efb56d6485cfcf145d88b39e873d85", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -233,21 +233,77 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //    is `Vec<Foo>:Iterable<Bar>`, but the impl specifies\n     //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.\n \n-    /// Evaluates whether the obligation can be satisfied. Returns an indication of whether the\n-    /// obligation can be satisfied and, if so, by what means. Never affects surrounding typing\n-    /// environment.\n+    /// Attempts to satisfy the obligation. If successful, this will affect the surrounding\n+    /// type environment by performing unification.\n     pub fn select(&mut self, obligation: &TraitObligation<'tcx>)\n                   -> SelectionResult<'tcx, Selection<'tcx>> {\n         debug!(\"select({})\", obligation.repr(self.tcx()));\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(None, obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n-            None => Ok(None),\n+            None => {\n+                self.consider_unification_despite_ambiguity(obligation);\n+                Ok(None)\n+            }\n             Some(candidate) => Ok(Some(try!(self.confirm_candidate(obligation, candidate)))),\n         }\n     }\n \n+    /// In the particular case of unboxed closure obligations, we can\n+    /// sometimes do some amount of unification for the\n+    /// argument/return types even though we can't yet fully match obligation.\n+    /// The particular case we are interesting in is an obligation of the form:\n+    ///\n+    ///    C : FnFoo<A>\n+    ///\n+    /// where `C` is an unboxed closure type and `FnFoo` is one of the\n+    /// `Fn` traits. Because we know that users cannot write impls for closure types\n+    /// themselves, the only way that `C : FnFoo` can fail to match is under two\n+    /// conditions:\n+    ///\n+    /// 1. The closure kind for `C` is not yet known, because inference isn't complete.\n+    /// 2. The closure kind for `C` *is* known, but doesn't match what is needed.\n+    ///    For example, `C` may be a `FnOnce` closure, but a `Fn` closure is needed.\n+    ///\n+    /// In either case, we always know what argument types are\n+    /// expected by `C`, no matter what kind of `Fn` trait it\n+    /// eventually matches. So we can go ahead and unify the argument\n+    /// types, even though the end result is ambiguous.\n+    ///\n+    /// Note that this is safe *even if* the trait would never be\n+    /// matched (case 2 above). After all, in that case, an error will\n+    /// result, so it kind of doesn't matter what we do --- unifying\n+    /// the argument types can only be helpful to the user, because\n+    /// once they patch up the kind of closure that is expected, the\n+    /// argment types won't really change.\n+    fn consider_unification_despite_ambiguity(&mut self, obligation: &TraitObligation<'tcx>) {\n+        // Is this a `C : FnFoo(...)` trait reference for some trait binding `FnFoo`?\n+        match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n+            Some(_) => { }\n+            None => { return; }\n+        }\n+\n+        // Is the self-type a closure type? We ignore bindings here\n+        // because if it is a closure type, it must be a closure type from\n+        // within this current fn, and hence none of the higher-ranked\n+        // lifetimes can appear inside the self-type.\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let (closure_def_id, substs) = match self_ty.sty {\n+            ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n+            _ => { return; }\n+        };\n+        assert!(!substs.has_escaping_regions());\n+\n+        let closure_trait_ref = self.closure_trait_ref(obligation, closure_def_id, substs);\n+        match self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                           obligation.predicate.to_poly_trait_ref(),\n+                                           closure_trait_ref) {\n+            Ok(()) => { }\n+            Err(_) => { /* Silently ignore errors. */ }\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //\n@@ -1003,7 +1059,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                    candidates: &mut SelectionCandidateSet<'tcx>)\n                                    -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.fn_family_trait_kind(obligation.predicate.0.def_id()) {\n+        let kind = match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -2303,22 +2359,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         impl_obligations\n     }\n \n-    fn fn_family_trait_kind(&self,\n-                            trait_def_id: ast::DefId)\n-                            -> Option<ty::ClosureKind>\n-    {\n-        let tcx = self.tcx();\n-        if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n-            Some(ty::FnClosureKind)\n-        } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n-            Some(ty::FnMutClosureKind)\n-        } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n-            Some(ty::FnOnceClosureKind)\n-        } else {\n-            None\n-        }\n-    }\n-\n     #[allow(unused_comparisons)]\n     fn derived_cause(&self,\n                      obligation: &TraitObligation<'tcx>,"}, {"sha": "b9d2b9ec263ab450480bf3fa02db5c5505a6dd28", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -324,7 +324,7 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                         tcx: &ty::ctxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         ast_map::NodeExpr(expr) => match expr.node {\n-            ast::ExprClosure(_, _, _, ref block) => {\n+            ast::ExprClosure(_, _, ref block) => {\n                 block.id\n             }\n             _ => {"}, {"sha": "dd739059ed0ddf13c10d19ea06ce7a9aab9a90bb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -4521,7 +4521,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 visit::walk_expr(self, expr);\n             }\n \n-            ExprClosure(_, _, ref fn_decl, ref block) => {\n+            ExprClosure(_, ref fn_decl, ref block) => {\n                 self.resolve_function(ClosureRibKind(expr.id),\n                                       Some(&**fn_decl), NoTypeParameters,\n                                       &**block);"}, {"sha": "b0ce9641cf440e8a658e9bcb314d129720692fbe", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -1394,7 +1394,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                                       type, found {:?}\", ty)[]),\n                 }\n             },\n-            ast::ExprClosure(_, _, ref decl, ref body) => {\n+            ast::ExprClosure(_, ref decl, ref body) => {\n                 if generated_code(body.span) {\n                     return\n                 }"}, {"sha": "6901eb25b31feb1dda95147af59f7ec977ba1b13", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -1340,7 +1340,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n         }\n         Some(ast_map::NodeExpr(e)) => {\n             match e.node {\n-                ast::ExprClosure(_, _, _, ref blk) => {\n+                ast::ExprClosure(_, _, ref blk) => {\n                     blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected expr variant in has_nested_returns\")"}, {"sha": "c6b70e1a1abc354a47b187b628d4d94b93c584ce", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -1283,7 +1283,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ast_map::NodeExpr(ref expr) => {\n             match expr.node {\n-                ast::ExprClosure(_, _, ref fn_decl, ref top_level_block) => {\n+                ast::ExprClosure(_, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(&name[]);\n                     (name, &**fn_decl,\n@@ -3595,7 +3595,7 @@ fn create_scope_map(cx: &CrateContext,\n                 })\n             }\n \n-            ast::ExprClosure(_, _, ref decl, ref block) => {\n+            ast::ExprClosure(_, ref decl, ref block) => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,"}, {"sha": "44eb5b190e1a65666aafad1f46abd1cb44ac9793", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -1095,7 +1095,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ast::ExprVec(..) | ast::ExprRepeat(..) => {\n             tvec::trans_fixed_vstore(bcx, expr, dest)\n         }\n-        ast::ExprClosure(_, _, ref decl, ref body) => {\n+        ast::ExprClosure(_, ref decl, ref body) => {\n             closure::trans_closure_expr(bcx, &**decl, &**body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {"}, {"sha": "b2a676e878e6302e556e8aab29e462d8942da6fb", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 90, "deletions": 61, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -25,46 +25,21 @@ use util::ppaux::Repr;\n pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n                                    expr: &ast::Expr,\n                                    _capture: ast::CaptureClause,\n-                                   opt_kind: Option<ast::ClosureKind>,\n                                    decl: &'tcx ast::FnDecl,\n                                    body: &'tcx ast::Block,\n                                    expected: Expectation<'tcx>) {\n     debug!(\"check_expr_closure(expr={},expected={})\",\n            expr.repr(fcx.tcx()),\n            expected.repr(fcx.tcx()));\n \n-    let expected_sig_and_kind = expected.to_option(fcx).and_then(|ty| {\n-        deduce_expectations_from_expected_type(fcx, ty)\n-    });\n-\n-    match opt_kind {\n-        None => {\n-            // If users didn't specify what sort of closure they want,\n-            // examine the expected type. For now, if we see explicit\n-            // evidence than an unboxed closure is desired, we'll use\n-            // that. Otherwise, we leave it unspecified, to be filled\n-            // in by upvar inference.\n-            match expected_sig_and_kind {\n-                None => { // don't have information about the kind, request explicit annotation\n-                    check_closure(fcx, expr, None, decl, body, None);\n-                },\n-                Some((sig, kind)) => {\n-                    check_closure(fcx, expr, Some(kind), decl, body, Some(sig));\n-                }\n-            }\n-        }\n-\n-        Some(kind) => {\n-            let kind = match kind {\n-                ast::FnClosureKind => ty::FnClosureKind,\n-                ast::FnMutClosureKind => ty::FnMutClosureKind,\n-                ast::FnOnceClosureKind => ty::FnOnceClosureKind,\n-            };\n-\n-            let expected_sig = expected_sig_and_kind.map(|t| t.0);\n-            check_closure(fcx, expr, Some(kind), decl, body, expected_sig);\n-        }\n-    }\n+    // It's always helpful for inference if we know the kind of\n+    // closure sooner rather than later, so first examine the expected\n+    // type, and see if can glean a closure kind from there.\n+    let (expected_sig,expected_kind) = match expected.to_option(fcx) {\n+        Some(ty) => deduce_expectations_from_expected_type(fcx, ty),\n+        None => (None, None)\n+    };\n+    check_closure(fcx, expr, expected_kind, decl, body, expected_sig)\n }\n \n fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n@@ -133,55 +108,92 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n fn deduce_expectations_from_expected_type<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_ty: Ty<'tcx>)\n-    -> Option<(ty::FnSig<'tcx>,ty::ClosureKind)>\n+    -> (Option<ty::FnSig<'tcx>>,Option<ty::ClosureKind>)\n {\n+    debug!(\"deduce_expectations_from_expected_type(expected_ty={})\",\n+           expected_ty.repr(fcx.tcx()));\n+\n     match expected_ty.sty {\n         ty::ty_trait(ref object_type) => {\n             let proj_bounds = object_type.projection_bounds_with_self_ty(fcx.tcx(),\n                                                                          fcx.tcx().types.err);\n-            proj_bounds.iter()\n-                       .filter_map(|pb| deduce_expectations_from_projection(fcx, pb))\n-                       .next()\n+            let expectations =\n+                proj_bounds.iter()\n+                           .filter_map(|pb| deduce_expectations_from_projection(fcx, pb))\n+                           .next();\n+\n+            match expectations {\n+                Some((sig, kind)) => (Some(sig), Some(kind)),\n+                None => (None, None)\n+            }\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n             deduce_expectations_from_obligations(fcx, vid)\n         }\n         _ => {\n-            None\n+            (None, None)\n         }\n     }\n }\n \n fn deduce_expectations_from_obligations<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     expected_vid: ty::TyVid)\n-    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n+    -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>)\n {\n     let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n     // Here `expected_ty` is known to be a type inference variable.\n \n-    fulfillment_cx.pending_obligations()\n-                  .iter()\n-                  .filter_map(|obligation| {\n-                      match obligation.predicate {\n-                          ty::Predicate::Projection(ref proj_predicate) => {\n-                              let trait_ref = proj_predicate.to_poly_trait_ref();\n-                              let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n-                              match self_ty.sty {\n-                                  ty::ty_infer(ty::TyVar(v)) if expected_vid == v => {\n-                                      deduce_expectations_from_projection(fcx, proj_predicate)\n-                                  }\n-                                  _ => {\n-                                      None\n-                                  }\n-                              }\n-                          }\n-                          _ => {\n-                              None\n-                          }\n-                      }\n-                  })\n-                  .next()\n+    let expected_sig_and_kind =\n+        fulfillment_cx\n+        .pending_obligations()\n+        .iter()\n+        .filter_map(|obligation| {\n+            debug!(\"deduce_expectations_from_obligations: obligation.predicate={}\",\n+                   obligation.predicate.repr(fcx.tcx()));\n+\n+            match obligation.predicate {\n+                // Given a Projection predicate, we can potentially infer\n+                // the complete signature.\n+                ty::Predicate::Projection(ref proj_predicate) => {\n+                    let trait_ref = proj_predicate.to_poly_trait_ref();\n+                    self_type_matches_expected_vid(fcx, trait_ref, expected_vid)\n+                        .and_then(|_| deduce_expectations_from_projection(fcx, proj_predicate))\n+                }\n+                _ => {\n+                    None\n+                }\n+            }\n+        })\n+        .next();\n+\n+    match expected_sig_and_kind {\n+        Some((sig, kind)) => { return (Some(sig), Some(kind)); }\n+        None => { }\n+    }\n+\n+    // Even if we can't infer the full signature, we may be able to\n+    // infer the kind. This can occur if there is a trait-reference\n+    // like `F : Fn<A>`.\n+    let expected_kind =\n+        fulfillment_cx\n+        .pending_obligations()\n+        .iter()\n+        .filter_map(|obligation| {\n+            let opt_trait_ref = match obligation.predicate {\n+                ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref()),\n+                ty::Predicate::Trait(ref data) => Some(data.to_poly_trait_ref()),\n+                ty::Predicate::Equate(..) => None,\n+                ty::Predicate::RegionOutlives(..) => None,\n+                ty::Predicate::TypeOutlives(..) => None,\n+            };\n+            opt_trait_ref\n+                .and_then(|trait_ref| self_type_matches_expected_vid(fcx, trait_ref, expected_vid))\n+                .and_then(|trait_ref| fcx.tcx().lang_items.fn_trait_kind(trait_ref.def_id()))\n+        })\n+        .next();\n+\n+    (None, expected_kind)\n }\n \n /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n@@ -229,3 +241,20 @@ fn deduce_expectations_from_projection<'a,'tcx>(\n     return Some((fn_sig, kind));\n }\n \n+fn self_type_matches_expected_vid<'a,'tcx>(\n+    fcx: &FnCtxt<'a,'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+    expected_vid: ty::TyVid)\n+    -> Option<ty::PolyTraitRef<'tcx>>\n+{\n+    let self_ty = fcx.infcx().shallow_resolve(trait_ref.self_ty());\n+    debug!(\"self_type_matches_expected_vid(trait_ref={}, self_ty={})\",\n+           trait_ref.repr(fcx.tcx()),\n+           self_ty.repr(fcx.tcx()));\n+    match self_ty.sty {\n+        ty::ty_infer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n+        _ => None,\n+    }\n+}\n+\n+"}, {"sha": "adf15fbf28a8f040708e9e9aaea3b371558fdd9a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -3736,8 +3736,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       ast::ExprMatch(ref discrim, ref arms, match_src) => {\n         _match::check_match(fcx, expr, &**discrim, arms.as_slice(), expected, match_src);\n       }\n-      ast::ExprClosure(capture, opt_kind, ref decl, ref body) => {\n-          closure::check_expr_closure(fcx, expr, capture, opt_kind, &**decl, &**body, expected);\n+      ast::ExprClosure(capture, ref decl, ref body) => {\n+          closure::check_expr_closure(fcx, expr, capture, &**decl, &**body, expected);\n       }\n       ast::ExprBlock(ref b) => {\n         check_block_with_expected(fcx, &**b, expected);"}, {"sha": "9df0403794d7c8e8bd03087dda0a33a387ab2a47", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -638,7 +638,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr);\n         }\n \n-        ast::ExprClosure(_, _, _, ref body) => {\n+        ast::ExprClosure(_, _, ref body) => {\n             check_expr_fn_block(rcx, expr, &**body);\n         }\n "}, {"sha": "f452c8488ce1c7eb2fe900db03205d06889460ac", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -83,7 +83,7 @@ struct SeedBorrowKind<'a,'tcx:'a> {\n impl<'a, 'tcx, 'v> Visitor<'v> for SeedBorrowKind<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         match expr.node {\n-            ast::ExprClosure(cc, _, _, ref body) => {\n+            ast::ExprClosure(cc, _, ref body) => {\n                 self.check_closure(expr, cc, &**body);\n             }\n "}, {"sha": "f047a36c56095fcc3433b872c2edb9480f1addb7", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -118,7 +118,7 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n                                     MethodCall::expr(e.id));\n \n         match e.node {\n-            ast::ExprClosure(_, _, ref decl, _) => {\n+            ast::ExprClosure(_, ref decl, _) => {\n                 for input in &decl.inputs {\n                     let _ = self.visit_node_id(ResolvingExpr(e.span),\n                                                input.id);"}, {"sha": "34eeedeaa7650bba3e232b1f6fe901982fb1071e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -48,7 +48,6 @@ pub use self::TraitItem::*;\n pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n pub use self::UintTy::*;\n-pub use self::ClosureKind::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::VariantKind::*;\n@@ -736,7 +735,7 @@ pub enum Expr_ {\n     // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     ExprMatch(P<Expr>, Vec<Arm>, MatchSource),\n-    ExprClosure(CaptureClause, Option<ClosureKind>, P<FnDecl>, P<Block>),\n+    ExprClosure(CaptureClause, P<FnDecl>, P<Block>),\n     ExprBlock(P<Block>),\n \n     ExprAssign(P<Expr>, P<Expr>),\n@@ -1687,13 +1686,6 @@ impl ForeignItem_ {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum ClosureKind {\n-    FnClosureKind,\n-    FnMutClosureKind,\n-    FnOnceClosureKind,\n-}\n-\n /// The data we save and restore about an inlined item or method.  This is not\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans."}, {"sha": "a85b87f47d6ee0d1a9338f262a8344bed2624ff9", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -218,7 +218,7 @@ impl<'a> FnLikeNode<'a> {\n                 }\n             }\n             ast_map::NodeExpr(e) => match e.node {\n-                ast::ExprClosure(_, _, ref decl, ref block) =>\n+                ast::ExprClosure(_, ref decl, ref block) =>\n                     closure(ClosureParts::new(&**decl, &**block, e.id, e.span)),\n                 _ => panic!(\"expr FnLikeNode that is not fn-like\"),\n             },"}, {"sha": "53c35ef34cd0d4293ed2803b08a26af76a62f710", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -876,14 +876,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn lambda_fn_decl(&self, span: Span,\n                       fn_decl: P<ast::FnDecl>, blk: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(span, ast::ExprClosure(ast::CaptureByRef, None, fn_decl, blk))\n+        self.expr(span, ast::ExprClosure(ast::CaptureByRef, fn_decl, blk))\n     }\n     fn lambda(&self, span: Span, ids: Vec<ast::Ident>, blk: P<ast::Block>) -> P<ast::Expr> {\n         let fn_decl = self.fn_decl(\n             ids.iter().map(|id| self.arg(span, *id, self.ty_infer(span))).collect(),\n             self.ty_infer(span));\n \n-        self.expr(span, ast::ExprClosure(ast::CaptureByRef, None, fn_decl, blk))\n+        self.expr(span, ast::ExprClosure(ast::CaptureByRef, fn_decl, blk))\n     }\n     fn lambda0(&self, span: Span, blk: P<ast::Block>) -> P<ast::Expr> {\n         self.lambda(span, Vec::new(), blk)"}, {"sha": "739c73a70b02b1779f81232ded7357b73d0c877d", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -66,7 +66,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         cx.ident_of(\"Rand\"),\n         cx.ident_of(\"rand\")\n     );\n-    let mut rand_call = |&mut: cx: &mut ExtCtxt, span| {\n+    let rand_call = |&: cx: &mut ExtCtxt, span| {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n                             vec!(rng.clone()))"}, {"sha": "77440914342fb2ef4a60710bf3c16376db58934b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -322,11 +322,10 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             fld.cx.expr_match(span, into_iter_expr, vec![iter_arm])\n         }\n \n-        ast::ExprClosure(capture_clause, opt_kind, fn_decl, block) => {\n+        ast::ExprClosure(capture_clause, fn_decl, block) => {\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n             let new_node = ast::ExprClosure(capture_clause,\n-                                            opt_kind,\n                                             rewritten_fn_decl,\n                                             rewritten_block);\n             P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})"}, {"sha": "07b6af651f610eec1e10c9744fcd64d725657dfd", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -1325,9 +1325,8 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n                         arms.move_map(|x| folder.fold_arm(x)),\n                         source)\n             }\n-            ExprClosure(capture_clause, opt_kind, decl, body) => {\n+            ExprClosure(capture_clause, decl, body) => {\n                 ExprClosure(capture_clause,\n-                            opt_kind,\n                             folder.fold_fn_decl(decl),\n                             folder.fold_block(body))\n             }"}, {"sha": "60de6c909b78bfc2d8fb7371bea068650da2a536", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -27,6 +27,7 @@ pub enum ObsoleteSyntax {\n     ProcType,\n     ProcExpr,\n     ClosureType,\n+    ClosureKind,\n }\n \n pub trait ParserObsoleteMethods {\n@@ -65,6 +66,10 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n                 \"`|usize| -> bool` closure type syntax\",\n                 \"use unboxed closures instead, no type annotation needed\"\n             ),\n+            ObsoleteSyntax::ClosureKind => (\n+                \"`:`, `&mut:`, or `&:` syntax\",\n+                \"rely on inference instead\"\n+            ),\n             ObsoleteSyntax::Sized => (\n                 \"`Sized? T` syntax for removing the `Sized` bound\",\n                 \"write `T: ?Sized` instead\""}, {"sha": "2cb265033c399842c6783b9af1e97c7f29f5dc7b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -28,8 +28,6 @@ use ast::{ExprLit, ExprLoop, ExprMac, ExprRange};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprQPath};\n use ast::{ExprRepeat, ExprRet, ExprStruct, ExprTup, ExprUnary};\n use ast::{ExprVec, ExprWhile, ExprWhileLet, ExprForLoop, Field, FnDecl};\n-use ast::{FnClosureKind, FnMutClosureKind};\n-use ast::{FnOnceClosureKind};\n use ast::{ForeignItem, ForeignItemStatic, ForeignItemFn, ForeignMod, FunctionRetTy};\n use ast::{Ident, Inherited, ImplItem, Item, Item_, ItemStatic};\n use ast::{ItemEnum, ItemFn, ItemForeignMod, ItemImpl, ItemConst};\n@@ -57,7 +55,7 @@ use ast::{TyFixedLengthVec, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n use ast::{TyRptr, TyTup, TyU32, TyVec, UnUniq};\n-use ast::{TypeImplItem, TypeTraitItem, Typedef, ClosureKind};\n+use ast::{TypeImplItem, TypeTraitItem, Typedef,};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause};\n@@ -1139,29 +1137,36 @@ impl<'a> Parser<'a> {\n         TyInfer\n     }\n \n-    /// Parses an optional closure kind (`&:`, `&mut:`, or `:`).\n-    pub fn parse_optional_closure_kind(&mut self) -> Option<ClosureKind> {\n-        if self.check(&token::BinOp(token::And)) &&\n-                self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n-                self.look_ahead(2, |t| *t == token::Colon) {\n+    /// Parses an obsolete closure kind (`&:`, `&mut:`, or `:`).\n+    pub fn parse_obsolete_closure_kind(&mut self) {\n+        // let lo = self.span.lo;\n+        if\n+            self.check(&token::BinOp(token::And)) &&\n+            self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n+            self.look_ahead(2, |t| *t == token::Colon)\n+        {\n             self.bump();\n             self.bump();\n             self.bump();\n-            return Some(FnMutClosureKind)\n-        }\n-\n-        if self.token == token::BinOp(token::And) &&\n-                    self.look_ahead(1, |t| *t == token::Colon) {\n+        } else if\n+            self.token == token::BinOp(token::And) &&\n+            self.look_ahead(1, |t| *t == token::Colon)\n+        {\n             self.bump();\n             self.bump();\n-            return Some(FnClosureKind)\n-        }\n-\n-        if self.eat(&token::Colon) {\n-            return Some(FnOnceClosureKind)\n+            return;\n+        } else if\n+            self.eat(&token::Colon)\n+        {\n+            /* nothing */\n+        } else {\n+            return;\n         }\n \n-        return None\n+        // SNAP 474b324\n+        // Enable these obsolete errors after snapshot:\n+        // let span = mk_sp(lo, self.span.hi);\n+        // self.obsolete(span, ObsoleteSyntax::ClosureKind);\n     }\n \n     pub fn parse_ty_bare_fn_or_ty_closure(&mut self, lifetime_defs: Vec<LifetimeDef>) -> Ty_ {\n@@ -3047,7 +3052,7 @@ impl<'a> Parser<'a> {\n                              -> P<Expr>\n     {\n         let lo = self.span.lo;\n-        let (decl, optional_closure_kind) = self.parse_fn_block_decl();\n+        let decl = self.parse_fn_block_decl();\n         let body = self.parse_expr();\n         let fakeblock = P(ast::Block {\n             id: ast::DUMMY_NODE_ID,\n@@ -3060,7 +3065,7 @@ impl<'a> Parser<'a> {\n         self.mk_expr(\n             lo,\n             fakeblock.span.hi,\n-            ExprClosure(capture_clause, optional_closure_kind, decl, fakeblock))\n+            ExprClosure(capture_clause, decl, fakeblock))\n     }\n \n     pub fn parse_else_expr(&mut self) -> P<Expr> {\n@@ -4529,30 +4534,29 @@ impl<'a> Parser<'a> {\n     }\n \n     // parse the |arg, arg| header on a lambda\n-    fn parse_fn_block_decl(&mut self) -> (P<FnDecl>, Option<ClosureKind>) {\n-        let (optional_closure_kind, inputs_captures) = {\n+    fn parse_fn_block_decl(&mut self) -> P<FnDecl> {\n+        let inputs_captures = {\n             if self.eat(&token::OrOr) {\n-                (None, Vec::new())\n+                Vec::new()\n             } else {\n                 self.expect(&token::BinOp(token::Or));\n-                let optional_closure_kind =\n-                    self.parse_optional_closure_kind();\n+                self.parse_obsolete_closure_kind();\n                 let args = self.parse_seq_to_before_end(\n                     &token::BinOp(token::Or),\n                     seq_sep_trailing_allowed(token::Comma),\n                     |p| p.parse_fn_block_arg()\n                 );\n                 self.bump();\n-                (optional_closure_kind, args)\n+                args\n             }\n         };\n         let output = self.parse_ret_ty();\n \n-        (P(FnDecl {\n+        P(FnDecl {\n             inputs: inputs_captures,\n             output: output,\n             variadic: false\n-        }), optional_closure_kind)\n+        })\n     }\n \n     /// Parses the `(arg, arg) -> return_type` header on a procedure."}, {"sha": "ee8e207fa6c059b909914232d1d501cda015a9f0", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -11,11 +11,9 @@\n pub use self::AnnNode::*;\n \n use abi;\n-use ast::{self, FnClosureKind, FnMutClosureKind};\n-use ast::{FnOnceClosureKind};\n+use ast;\n use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n-use ast::{ClosureKind};\n use ast_util;\n use owned_slice::OwnedSlice;\n use attr::{AttrMetaMethods, AttributeMethods};\n@@ -350,7 +348,7 @@ pub fn method_to_string(p: &ast::Method) -> String {\n }\n \n pub fn fn_block_to_string(p: &ast::FnDecl) -> String {\n-    $to_string(|s| s.print_fn_block_args(p, None))\n+    $to_string(|s| s.print_fn_block_args(p))\n }\n \n pub fn path_to_string(p: &ast::Path) -> String {\n@@ -1747,10 +1745,10 @@ impl<'a> State<'a> {\n                 }\n                 try!(self.bclose_(expr.span, indent_unit));\n             }\n-            ast::ExprClosure(capture_clause, opt_kind, ref decl, ref body) => {\n+            ast::ExprClosure(capture_clause, ref decl, ref body) => {\n                 try!(self.print_capture_clause(capture_clause));\n \n-                try!(self.print_fn_block_args(&**decl, opt_kind));\n+                try!(self.print_fn_block_args(&**decl));\n                 try!(space(&mut self.s));\n \n                 if !body.stmts.is_empty() || !body.expr.is_some() {\n@@ -2350,16 +2348,9 @@ impl<'a> State<'a> {\n \n     pub fn print_fn_block_args(\n             &mut self,\n-            decl: &ast::FnDecl,\n-            closure_kind: Option<ClosureKind>)\n+            decl: &ast::FnDecl)\n             -> IoResult<()> {\n         try!(word(&mut self.s, \"|\"));\n-        match closure_kind {\n-            None => {}\n-            Some(FnClosureKind) => try!(self.word_space(\"&:\")),\n-            Some(FnMutClosureKind) => try!(self.word_space(\"&mut:\")),\n-            Some(FnOnceClosureKind) => try!(self.word_space(\":\")),\n-        }\n         try!(self.print_fn_args(decl, None));\n         try!(word(&mut self.s, \"|\"));\n "}, {"sha": "fbcfcaadf12b71c29782e0ae4d5944b92043232a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -836,7 +836,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 visitor.visit_arm(arm)\n             }\n         }\n-        ExprClosure(_, _, ref function_declaration, ref body) => {\n+        ExprClosure(_, ref function_declaration, ref body) => {\n             visitor.visit_fn(FkFnBlock,\n                              &**function_declaration,\n                              &**body,"}, {"sha": "7033f5caef6c6a22d7e144861dfa008ade2f4815", "filename": "src/test/compile-fail/borrow-immutable-upvar-mutation.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrow-immutable-upvar-mutation.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -8,34 +8,38 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n // Tests that we can't assign to or mutably borrow upvars from `Fn`\n // closures (issue #17780)\n \n fn set(x: &mut usize) { *x = 5; }\n \n+fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+\n fn main() {\n     // By-ref captures\n     {\n         let mut x = 0us;\n-        let _f = |&:| x = 42; //~ ERROR cannot assign\n+        let _f = to_fn(|| x = 42); //~ ERROR cannot assign\n \n         let mut y = 0us;\n-        let _g = |&:| set(&mut y); //~ ERROR cannot borrow\n+        let _g = to_fn(|| set(&mut y)); //~ ERROR cannot borrow\n \n         let mut z = 0us;\n-        let _h = |&mut:| { set(&mut z); |&:| z = 42; }; //~ ERROR cannot assign\n+        let _h = to_fn_mut(|| { set(&mut z); to_fn(|| z = 42); }); //~ ERROR cannot assign\n     }\n+\n     // By-value captures\n     {\n         let mut x = 0us;\n-        let _f = move |&:| x = 42; //~ ERROR cannot assign\n+        let _f = to_fn(move || x = 42); //~ ERROR cannot assign\n \n         let mut y = 0us;\n-        let _g = move |&:| set(&mut y); //~ ERROR cannot borrow\n+        let _g = to_fn(move || set(&mut y)); //~ ERROR cannot borrow\n \n         let mut z = 0us;\n-        let _h = move |&mut:| { set(&mut z); move |&:| z = 42; }; //~ ERROR cannot assign\n+        let _h = to_fn_mut(move || { set(&mut z); to_fn(move || z = 42); }); //~ ERROR cannot assign\n     }\n }"}, {"sha": "a1708e7f497286c81a4d6007aafb13c7ea4420c0", "filename": "src/test/compile-fail/borrowck-move-by-capture.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-by-capture.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -8,11 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax)]\n+#![feature(box_syntax,unboxed_closures)]\n+\n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n \n pub fn main() {\n     let bar = box 3;\n-    let _g = |&mut:| {\n-        let _h = move |:| -> isize { *bar }; //~ ERROR cannot move out of captured outer variable\n-    };\n+    let _g = to_fn_mut(|| {\n+        let _h = to_fn_once(move || -> isize { *bar }); //~ ERROR cannot move out of\n+    });\n }"}, {"sha": "738755855c0703211532b79c82ce43e92581bebc", "filename": "src/test/compile-fail/cannot-mutate-captured-non-mut-var.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -8,12 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unboxed_closures)]\n+\n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n+\n fn main() {\n     let x = 1;\n-    move|:| { x = 2; };\n+    to_fn_once(move|:| { x = 2; });\n     //~^ ERROR: cannot assign to immutable captured outer variable\n \n     let s = std::old_io::stdin();\n-    move|:| { s.read_to_end(); };\n+    to_fn_once(move|:| { s.read_to_end(); });\n     //~^ ERROR: cannot borrow immutable captured outer variable\n }"}, {"sha": "df4dab2552e7de8922613d5f6a683a4a338778b3", "filename": "src/test/compile-fail/issue-11925.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-11925.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax)]\n+#![feature(box_syntax, unboxed_closures)]\n+\n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n \n fn main() {\n     let r = {\n         let x = box 42;\n-        let f = move|:| &x; //~ ERROR: `x` does not live long enough\n+        let f = to_fn_once(move|| &x); //~ ERROR: `x` does not live long enough\n         f()\n     };\n "}, {"sha": "40d446b91a5a8b659d56cb79dcbec7b202c8249d", "filename": "src/test/compile-fail/issue-12127.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fissue-12127.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fissue-12127.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12127.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -8,14 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax)]\n+#![feature(box_syntax, unboxed_closures)]\n \n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n fn do_it(x: &isize) { }\n \n fn main() {\n     let x = box 22;\n-    let f = move|:| do_it(&*x);\n-    (move|:| {\n+    let f = to_fn_once(move|| do_it(&*x));\n+    to_fn_once(move|| {\n         f();\n         f();\n         //~^ ERROR: use of moved value: `f`"}, {"sha": "4251be36ab43805591025cea7e8a01b83f6294b2", "filename": "src/test/compile-fail/moves-based-on-type-move-out-of-closure-env-issue-1965.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-move-out-of-closure-env-issue-1965.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -8,13 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax)]\n+#![feature(box_syntax, unboxed_closures)]\n \n use std::usize;\n \n+fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n+\n fn test(_x: Box<usize>) {}\n \n fn main() {\n     let i = box 3;\n-    let _f = |&:| test(i); //~ ERROR cannot move out\n+    let _f = to_fn(|| test(i)); //~ ERROR cannot move out\n }"}, {"sha": "2d559794919817754daa3e1c606253d58c39afd2", "filename": "src/test/compile-fail/unboxed-closer-non-implicit-copyable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Funboxed-closer-non-implicit-copyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Funboxed-closer-non-implicit-copyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closer-non-implicit-copyable.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -10,8 +10,10 @@\n \n #![feature(unboxed_closures)]\n \n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n+\n fn main() {\n-    let f = move|:| ();\n+    let f = to_fn_once(move|| ());\n     f();\n     f(); //~ ERROR use of moved value\n }"}, {"sha": "224cbc2bef3245c624a949cc1e382cd92304417b", "filename": "src/test/compile-fail/unboxed-closure-illegal-move.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-illegal-move.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -15,31 +15,35 @@\n // if the upvar is captured by ref or the closure takes self by\n // reference.\n \n+fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n+\n fn main() {\n     // By-ref cases\n     {\n         let x = box 0us;\n-        let f = |&:| drop(x); //~ ERROR cannot move\n+        let f = to_fn(|| drop(x)); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = |&mut:| drop(x); //~ ERROR cannot move\n+        let f = to_fn_mut(|| drop(x)); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = |:| drop(x); // OK -- FnOnce\n+        let f = to_fn_once(|| drop(x)); // OK -- FnOnce\n     }\n     // By-value cases\n     {\n         let x = box 0us;\n-        let f = move |&:| drop(x); //~ ERROR cannot move\n+        let f = to_fn(move || drop(x)); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = move |&mut:| drop(x); //~ ERROR cannot move\n+        let f = to_fn_mut(move || drop(x)); //~ ERROR cannot move\n     }\n     {\n         let x = box 0us;\n-        let f = move |:| drop(x); // this one is ok\n+        let f = to_fn_once(move || drop(x)); // this one is ok\n     }\n }"}, {"sha": "650bb17bb7758f9ce60d81d2dcc7ec38ff7cab7b", "filename": "src/test/compile-fail/unboxed-closures-mutate-upvar.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-mutate-upvar.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -12,51 +12,56 @@\n // as `mut` through a closure. Also test that we CAN mutate a moved copy,\n // unless this is a `Fn` closure. Issue #16749.\n \n+#![feature(unboxed_closures)]\n+\n use std::mem;\n \n+fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+\n fn a() {\n     let n = 0u8;\n-    let mut f = |&mut:| { //~ ERROR closure cannot assign\n+    let mut f = to_fn_mut(|| { //~ ERROR closure cannot assign\n         n += 1;\n-    };\n+    });\n }\n \n fn b() {\n     let mut n = 0u8;\n-    let mut f = |&mut:| {\n+    let mut f = to_fn_mut(|| {\n         n += 1; // OK\n-    };\n+    });\n }\n \n fn c() {\n     let n = 0u8;\n-    let mut f = move |&mut:| {\n+    let mut f = to_fn_mut(move || {\n         // If we just did a straight-forward desugaring, this would\n         // compile, but we do something a bit more subtle, and hence\n         // we get an error.\n         n += 1; //~ ERROR cannot assign\n-    };\n+    });\n }\n \n fn d() {\n     let mut n = 0u8;\n-    let mut f = move |&mut:| {\n+    let mut f = to_fn_mut(move || {\n         n += 1; // OK\n-    };\n+    });\n }\n \n fn e() {\n     let n = 0u8;\n-    let mut f = move |&:| {\n+    let mut f = to_fn(move || {\n         n += 1; //~ ERROR cannot assign\n-    };\n+    });\n }\n \n fn f() {\n     let mut n = 0u8;\n-    let mut f = move |&:| {\n+    let mut f = to_fn(move || {\n         n += 1; //~ ERROR cannot assign\n-    };\n+    });\n }\n \n fn main() { }"}, {"sha": "f430e9fc7590228fba05867ea5a3e855a85f8188", "filename": "src/test/compile-fail/unboxed-closures-static-call-wrong-trait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -10,8 +10,10 @@\n \n #![feature(unboxed_closures)]\n \n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+\n fn main() {\n-    let mut_ = |&mut: x| x;\n+    let mut_ = to_fn_mut(|x| x);\n     mut_.call((0, )); //~ ERROR does not implement any method in scope named `call`\n }\n "}, {"sha": "c2a2e5162ace070a12c18aa6383f7cc9078ab323", "filename": "src/test/compile-fail/unboxed-closures-vtable-mismatch.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-vtable-mismatch.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -12,12 +12,14 @@\n \n use std::ops::FnMut;\n \n+fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+\n fn call_it<F:FnMut(isize,isize)->isize>(y: isize, mut f: F) -> isize {\n     f(2, y)\n }\n \n pub fn main() {\n-    let f = |&mut: x: usize, y: isize| -> isize { (x as isize) + y };\n+    let f = to_fn_mut(|x: usize, y: isize| -> isize { (x as isize) + y });\n     let z = call_it(3, f);\n     //~^ ERROR type mismatch\n     //~| ERROR type mismatch"}, {"sha": "2ada0dd22e75f4a160cdbc28aa8972a451b6cac5", "filename": "src/test/compile-fail/unboxed-closures-wrong-trait.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1d921f557d6d9e509ce0d696d7b2178628989935/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d921f557d6d9e509ce0d696d7b2178628989935/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-trait.rs?ref=1d921f557d6d9e509ce0d696d7b2178628989935", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(lang_items, overloaded_calls, unboxed_closures)]\n-\n-fn c<F:Fn(isize, isize) -> isize>(f: F) -> isize {\n-    f(5, 6)\n-}\n-\n-fn main() {\n-    let z: isize = 7;\n-    assert_eq!(c(|&mut: x: isize, y| x + y + z), 10);\n-    //~^ ERROR not implemented\n-    //~| ERROR not implemented\n-}\n-"}, {"sha": "3bd0273216de31e352315a0d7dd93e9dfa7272b5", "filename": "src/test/run-pass/closure-inference.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-inference.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n \n-fn foo(i: int) -> int { i + 1 }\n+fn foo(i: isize) -> isize { i + 1 }\n \n fn apply<A, F>(f: F, v: A) -> A where F: FnOnce(A) -> A { f(v) }\n \n pub fn main() {\n-    let f = {|: i| foo(i)};\n+    let f = {|i| foo(i)};\n     assert_eq!(apply(f, 2), 3);\n }"}, {"sha": "0cd8c13a4e10a60644ec0c80d887de9f236d1919", "filename": "src/test/run-pass/last-use-in-cap-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flast-use-in-cap-clause.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -14,9 +14,9 @@\n #![feature(box_syntax)]\n #![feature(unboxed_closures)]\n \n-struct A { a: Box<int> }\n+struct A { a: Box<isize> }\n \n-fn foo() -> Box<FnMut() -> int + 'static> {\n+fn foo() -> Box<FnMut() -> isize + 'static> {\n     let k = box 22;\n     let _u = A {a: k.clone()};\n     let result  = |&mut:| 22;"}, {"sha": "8e3d44df798a7679333ad85536e334b4d73c906c", "filename": "src/test/run-pass/unboxed-closures-zero-args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Frun-pass%2Funboxed-closures-zero-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74f7e0693909a45f9159c6d2ef72b42fcb4f1bac/src%2Ftest%2Frun-pass%2Funboxed-closures-zero-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-zero-args.rs?ref=74f7e0693909a45f9159c6d2ef72b42fcb4f1bac", "patch": "@@ -11,7 +11,7 @@\n #![feature(unboxed_closures)]\n \n fn main() {\n-    let mut zero = |&mut:| {};\n-    let () = zero.call_mut(());\n+    let mut zero = || {};\n+    let () = zero();\n }\n "}]}