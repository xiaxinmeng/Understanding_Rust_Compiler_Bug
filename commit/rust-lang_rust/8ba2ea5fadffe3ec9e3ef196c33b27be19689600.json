{"sha": "8ba2ea5fadffe3ec9e3ef196c33b27be19689600", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiYTJlYTVmYWRmZmUzZWM5ZTNlZjE5NmMzM2IyN2JlMTk2ODk2MDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-23T04:21:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-03-23T04:21:45Z"}, "message": "Auto merge of #32058 - pczarn:hashmap-initial-refactoring, r=apasel422\n\nBasic refactoring of HashMap", "tree": {"sha": "2cc0976f57602cb40993323069b1dcd181bb52ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2cc0976f57602cb40993323069b1dcd181bb52ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ba2ea5fadffe3ec9e3ef196c33b27be19689600", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ba2ea5fadffe3ec9e3ef196c33b27be19689600", "html_url": "https://github.com/rust-lang/rust/commit/8ba2ea5fadffe3ec9e3ef196c33b27be19689600", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ba2ea5fadffe3ec9e3ef196c33b27be19689600/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dcc413e42f15f4fc51a0ca88a99cc89454ec43d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dcc413e42f15f4fc51a0ca88a99cc89454ec43d", "html_url": "https://github.com/rust-lang/rust/commit/0dcc413e42f15f4fc51a0ca88a99cc89454ec43d"}, {"sha": "64adca717fe0f1fac851e9d09972adecf21bf662", "url": "https://api.github.com/repos/rust-lang/rust/commits/64adca717fe0f1fac851e9d09972adecf21bf662", "html_url": "https://github.com/rust-lang/rust/commit/64adca717fe0f1fac851e9d09972adecf21bf662"}], "stats": {"total": 474, "additions": 250, "deletions": 224}, "files": [{"sha": "ed797a7ee08ff45845e8233ada10bad4cf72a5e5", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 183, "deletions": 182, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/8ba2ea5fadffe3ec9e3ef196c33b27be19689600/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba2ea5fadffe3ec9e3ef196c33b27be19689600/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=8ba2ea5fadffe3ec9e3ef196c33b27be19689600", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use self::Entry::*;\n-use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n use borrow::Borrow;\n@@ -26,7 +25,6 @@ use super::table::{\n     Bucket,\n     EmptyBucket,\n     FullBucket,\n-    FullBucketImm,\n     FullBucketMut,\n     RawTable,\n     SafeHash\n@@ -342,48 +340,62 @@ pub struct HashMap<K, V, S = RandomState> {\n }\n \n /// Search for a pre-hashed key.\n+#[inline]\n fn search_hashed<K, V, M, F>(table: M,\n                              hash: SafeHash,\n                              mut is_match: F)\n-                             -> SearchResult<K, V, M> where\n+                             -> InternalEntry<K, V, M> where\n     M: Deref<Target=RawTable<K, V>>,\n     F: FnMut(&K) -> bool,\n {\n     // This is the only function where capacity can be zero. To avoid\n     // undefined behavior when Bucket::new gets the raw bucket in this\n     // case, immediately return the appropriate search result.\n     if table.capacity() == 0 {\n-        return TableRef(table);\n+        return InternalEntry::TableIsEmpty;\n     }\n \n-    let size = table.size();\n+    let size = table.size() as isize;\n     let mut probe = Bucket::new(table, hash);\n-    let ib = probe.index();\n+    let ib = probe.index() as isize;\n \n-    while probe.index() != ib + size {\n+    loop {\n         let full = match probe.peek() {\n-            Empty(b) => return TableRef(b.into_table()), // hit an empty bucket\n-            Full(b) => b\n+            Empty(bucket) => {\n+                // Found a hole!\n+                return InternalEntry::Vacant {\n+                    hash: hash,\n+                    elem: NoElem(bucket),\n+                };\n+            }\n+            Full(bucket) => bucket\n         };\n \n-        if full.distance() + ib < full.index() {\n+        let robin_ib = full.index() as isize - full.displacement() as isize;\n+\n+        if ib < robin_ib {\n+            // Found a luckier bucket than me.\n             // We can finish the search early if we hit any bucket\n             // with a lower distance to initial bucket than we've probed.\n-            return TableRef(full.into_table());\n+            return InternalEntry::Vacant {\n+                hash: hash,\n+                elem: NeqElem(full, robin_ib as usize),\n+            };\n         }\n \n         // If the hash doesn't match, it can't be this one..\n         if hash == full.hash() {\n             // If the key doesn't match, it can't be this one..\n             if is_match(full.read().0) {\n-                return FoundExisting(full);\n+                return InternalEntry::Occupied {\n+                    elem: full\n+                };\n             }\n         }\n \n         probe = full.next();\n+        debug_assert!(probe.index() as isize != ib + size + 1);\n     }\n-\n-    TableRef(probe.into_table())\n }\n \n fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n@@ -393,7 +405,7 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n         None => return (retkey, retval)\n     };\n \n-    while gap.full().distance() != 0 {\n+    while gap.full().displacement() != 0 {\n         gap = match gap.shift() {\n             Some(b) => b,\n             None => break\n@@ -409,78 +421,63 @@ fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n /// to recalculate it.\n ///\n /// `hash`, `k`, and `v` are the elements to \"robin hood\" into the hashtable.\n-fn robin_hood<'a, K: 'a, V: 'a>(mut bucket: FullBucketMut<'a, K, V>,\n+fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                         mut ib: usize,\n                         mut hash: SafeHash,\n-                        mut k: K,\n-                        mut v: V)\n+                        mut key: K,\n+                        mut val: V)\n                         -> &'a mut V {\n     let starting_index = bucket.index();\n     let size = {\n         let table = bucket.table(); // FIXME \"lifetime too short\".\n         table.size()\n     };\n+    // Save the *starting point*.\n+    let mut bucket = bucket.stash();\n     // There can be at most `size - dib` buckets to displace, because\n     // in the worst case, there are `size` elements and we already are\n-    // `distance` buckets away from the initial one.\n-    let idx_end = starting_index + size - bucket.distance();\n+    // `displacement` buckets away from the initial one.\n+    let idx_end = starting_index + size - bucket.displacement();\n \n     loop {\n-        let (old_hash, old_key, old_val) = bucket.replace(hash, k, v);\n+        let (old_hash, old_key, old_val) = bucket.replace(hash, key, val);\n+        hash = old_hash;\n+        key = old_key;\n+        val = old_val;\n+\n         loop {\n             let probe = bucket.next();\n-            assert!(probe.index() != idx_end);\n+            debug_assert!(probe.index() != idx_end);\n \n             let full_bucket = match probe.peek() {\n                 Empty(bucket) => {\n                     // Found a hole!\n-                    let b = bucket.put(old_hash, old_key, old_val);\n+                    let bucket = bucket.put(hash, key, val);\n                     // Now that it's stolen, just read the value's pointer\n-                    // right out of the table!\n-                    return Bucket::at_index(b.into_table(), starting_index)\n-                               .peek()\n-                               .expect_full()\n-                               .into_mut_refs()\n-                               .1;\n+                    // right out of the table! Go back to the *starting point*.\n+                    //\n+                    // This use of `into_table` is misleading. It turns the\n+                    // bucket, which is a FullBucket on top of a\n+                    // FullBucketMut, into just one FullBucketMut. The \"table\"\n+                    // refers to the inner FullBucketMut in this context.\n+                    return bucket.into_table().into_mut_refs().1;\n                 },\n                 Full(bucket) => bucket\n             };\n \n-            let probe_ib = full_bucket.index() - full_bucket.distance();\n+            let probe_ib = full_bucket.index() - full_bucket.displacement();\n \n             bucket = full_bucket;\n \n             // Robin hood! Steal the spot.\n             if ib < probe_ib {\n                 ib = probe_ib;\n-                hash = old_hash;\n-                k = old_key;\n-                v = old_val;\n                 break;\n             }\n         }\n     }\n }\n \n-/// A result that works like Option<FullBucket<..>> but preserves\n-/// the reference that grants us access to the table in any case.\n-enum SearchResult<K, V, M> {\n-    // This is an entry that holds the given key:\n-    FoundExisting(FullBucket<K, V, M>),\n-\n-    // There was no such entry. The reference is given back:\n-    TableRef(M)\n-}\n-\n-impl<K, V, M> SearchResult<K, V, M> {\n-    fn into_option(self) -> Option<FullBucket<K, V, M>> {\n-        match self {\n-            FoundExisting(bucket) => Some(bucket),\n-            TableRef(_) => None\n-        }\n-    }\n-}\n-\n impl<K, V, S> HashMap<K, V, S>\n     where K: Eq + Hash, S: BuildHasher\n {\n@@ -491,20 +488,20 @@ impl<K, V, S> HashMap<K, V, S>\n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n-    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n+    #[inline]\n+    fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> InternalEntry<K, V, &'a RawTable<K, V>>\n         where K: Borrow<Q>, Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n-            .into_option()\n     }\n \n-    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n+    #[inline]\n+    fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> InternalEntry<K, V, &'a mut RawTable<K, V>>\n         where K: Borrow<Q>, Q: Eq + Hash\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n-            .into_option()\n     }\n \n     // The caller should ensure that invariants by Robin Hood Hashing hold.\n@@ -711,7 +708,7 @@ impl<K, V, S> HashMap<K, V, S>\n         loop {\n             bucket = match bucket.peek() {\n                 Full(full) => {\n-                    if full.distance() == 0 {\n+                    if full.displacement() == 0 {\n                         // This bucket occupies its ideal spot.\n                         // It indicates the start of another \"cluster\".\n                         bucket = full.into_bucket();\n@@ -804,53 +801,19 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// If the key already exists, the hashtable will be returned untouched\n     /// and a reference to the existing element will be returned.\n-    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> &mut V {\n-        self.insert_or_replace_with(hash, k, v, |_, _, _, _| ())\n-    }\n-\n-    fn insert_or_replace_with<'a, F>(&'a mut self,\n-                                     hash: SafeHash,\n-                                     k: K,\n-                                     v: V,\n-                                     mut found_existing: F)\n-                                     -> &'a mut V where\n-        F: FnMut(&mut K, &mut V, K, V),\n-    {\n-        // Worst case, we'll find one empty bucket among `size + 1` buckets.\n-        let size = self.table.size();\n-        let mut probe = Bucket::new(&mut self.table, hash);\n-        let ib = probe.index();\n-\n-        loop {\n-            let mut bucket = match probe.peek() {\n-                Empty(bucket) => {\n-                    // Found a hole!\n-                    return bucket.put(hash, k, v).into_mut_refs().1;\n-                }\n-                Full(bucket) => bucket\n-            };\n-\n-            // hash matches?\n-            if bucket.hash() == hash {\n-                // key matches?\n-                if k == *bucket.read_mut().0 {\n-                    let (bucket_k, bucket_v) = bucket.into_mut_refs();\n-                    debug_assert!(k == *bucket_k);\n-                    // Key already exists. Get its reference.\n-                    found_existing(bucket_k, bucket_v, k, v);\n-                    return bucket_v;\n-                }\n+    fn insert_hashed_nocheck(&mut self, hash: SafeHash, k: K, v: V) -> Option<V> {\n+        let entry = search_hashed(&mut self.table, hash, |key| *key == k).into_entry(k);\n+        match entry {\n+            Some(Occupied(mut elem)) => {\n+                Some(elem.insert(v))\n             }\n-\n-            let robin_ib = bucket.index() as isize - bucket.distance() as isize;\n-\n-            if (ib as isize) < robin_ib {\n-                // Found a luckier bucket than me. Better steal his spot.\n-                return robin_hood(bucket, robin_ib as usize, hash, k, v);\n+            Some(Vacant(elem)) => {\n+                elem.insert(v);\n+                None\n+            }\n+            None => {\n+                unreachable!()\n             }\n-\n-            probe = bucket.next();\n-            assert!(probe.index() != ib + size + 1);\n         }\n     }\n \n@@ -977,9 +940,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn entry(&mut self, key: K) -> Entry<K, V> {\n         // Gotta resize now.\n         self.reserve(1);\n-\n-        let hash = self.make_hash(&key);\n-        search_entry_hashed(&mut self.table, hash, key)\n+        self.search_mut(&key).into_entry(key).expect(\"unreachable\")\n     }\n \n     /// Returns the number of elements in the map.\n@@ -1082,7 +1043,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n         where K: Borrow<Q>, Q: Hash + Eq\n     {\n-        self.search(k).map(|bucket| bucket.into_refs().1)\n+        self.search(k).into_occupied_bucket().map(|bucket| bucket.into_refs().1)\n     }\n \n     /// Returns true if the map contains a value for the specified key.\n@@ -1105,7 +1066,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n         where K: Borrow<Q>, Q: Hash + Eq\n     {\n-        self.search(k).is_some()\n+        self.search(k).into_occupied_bucket().is_some()\n     }\n \n     /// Returns a mutable reference to the value corresponding to the key.\n@@ -1130,7 +1091,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n         where K: Borrow<Q>, Q: Hash + Eq\n     {\n-        self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n+        self.search_mut(k).into_occupied_bucket().map(|bucket| bucket.into_mut_refs().1)\n     }\n \n     /// Inserts a key-value pair into the map.\n@@ -1161,12 +1122,7 @@ impl<K, V, S> HashMap<K, V, S>\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n         let hash = self.make_hash(&k);\n         self.reserve(1);\n-\n-        let mut retval = None;\n-        self.insert_or_replace_with(hash, k, v, |_, val_ref, _, val| {\n-            retval = Some(replace(val_ref, val));\n-        });\n-        retval\n+        self.insert_hashed_nocheck(hash, k, v)\n     }\n \n     /// Removes a key from the map, returning the value at the key if the key\n@@ -1194,54 +1150,7 @@ impl<K, V, S> HashMap<K, V, S>\n             return None\n         }\n \n-        self.search_mut(k).map(|bucket| pop_internal(bucket).1)\n-    }\n-}\n-\n-fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHash, k: K)\n-        -> Entry<'a, K, V>\n-{\n-    // Worst case, we'll find one empty bucket among `size + 1` buckets.\n-    let size = table.size();\n-    let mut probe = Bucket::new(table, hash);\n-    let ib = probe.index();\n-\n-    loop {\n-        let bucket = match probe.peek() {\n-            Empty(bucket) => {\n-                // Found a hole!\n-                return Vacant(VacantEntry {\n-                    hash: hash,\n-                    key: k,\n-                    elem: NoElem(bucket),\n-                });\n-            },\n-            Full(bucket) => bucket\n-        };\n-\n-        // hash matches?\n-        if bucket.hash() == hash {\n-            // key matches?\n-            if k == *bucket.read().0 {\n-                return Occupied(OccupiedEntry{\n-                    elem: bucket,\n-                });\n-            }\n-        }\n-\n-        let robin_ib = bucket.index() as isize - bucket.distance() as isize;\n-\n-        if (ib as isize) < robin_ib {\n-            // Found a luckier bucket than me. Better steal his spot.\n-            return Vacant(VacantEntry {\n-                hash: hash,\n-                key: k,\n-                elem: NeqElem(bucket, robin_ib as usize),\n-            });\n-        }\n-\n-        probe = bucket.next();\n-        assert!(probe.index() != ib + size + 1);\n+        self.search_mut(k).into_occupied_bucket().map(|bucket| pop_internal(bucket).1)\n     }\n }\n \n@@ -1362,18 +1271,47 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n     inner: iter::Map<table::Drain<'a, K, V>, fn((SafeHash, K, V)) -> (K, V)>\n }\n \n-/// A view into a single occupied location in a HashMap.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+enum InternalEntry<K, V, M> {\n+    Occupied {\n+        elem: FullBucket<K, V, M>,\n+    },\n+    Vacant {\n+        hash: SafeHash,\n+        elem: VacantEntryState<K, V, M>,\n+    },\n+    TableIsEmpty,\n }\n \n-/// A view into a single empty location in a HashMap.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VacantEntry<'a, K: 'a, V: 'a> {\n-    hash: SafeHash,\n-    key: K,\n-    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n+impl<K, V, M> InternalEntry<K, V, M> {\n+    #[inline]\n+    fn into_occupied_bucket(self) -> Option<FullBucket<K, V, M>> {\n+        match self {\n+            InternalEntry::Occupied { elem } => Some(elem),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n+    #[inline]\n+    fn into_entry(self, key: K) -> Option<Entry<'a, K, V>> {\n+        match self {\n+            InternalEntry::Occupied { elem } => {\n+                Some(Occupied(OccupiedEntry {\n+                    key: Some(key),\n+                    elem: elem\n+                }))\n+            }\n+            InternalEntry::Vacant { hash, elem } => {\n+                Some(Vacant(VacantEntry {\n+                    hash: hash,\n+                    key: key,\n+                    elem: elem,\n+                }))\n+            }\n+            InternalEntry::TableIsEmpty => None\n+        }\n+    }\n }\n \n /// A view into a single location in a map, which may be vacant or occupied.\n@@ -1392,6 +1330,21 @@ pub enum Entry<'a, K: 'a, V: 'a> {\n     ),\n }\n \n+/// A view into a single occupied location in a HashMap.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n+    key: Option<K>,\n+    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n+/// A view into a single empty location in a HashMap.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct VacantEntry<'a, K: 'a, V: 'a> {\n+    hash: SafeHash,\n+    key: K,\n+    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n+}\n+\n /// Possible states of a VacantEntry.\n enum VacantEntryState<K, V, M> {\n     /// The index is occupied, but the key to insert has precedence,\n@@ -1592,6 +1545,12 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     pub fn remove(self) -> V {\n         pop_internal(self.elem).1\n     }\n+    /// Returns a key that was used for search.\n+    ///\n+    /// The key was retained for further use.\n+    fn take_key(&mut self) -> Option<K> {\n+        self.key.take()\n+    }\n }\n \n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n@@ -1696,26 +1655,30 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n     type Key = K;\n \n     fn get(&self, key: &Q) -> Option<&K> {\n-        self.search(key).map(|bucket| bucket.into_refs().0)\n+        self.search(key).into_occupied_bucket().map(|bucket| bucket.into_refs().0)\n     }\n \n     fn take(&mut self, key: &Q) -> Option<K> {\n         if self.table.size() == 0 {\n             return None\n         }\n \n-        self.search_mut(key).map(|bucket| pop_internal(bucket).0)\n+        self.search_mut(key).into_occupied_bucket().map(|bucket| pop_internal(bucket).0)\n     }\n \n     fn replace(&mut self, key: K) -> Option<K> {\n-        let hash = self.make_hash(&key);\n         self.reserve(1);\n \n-        let mut retkey = None;\n-        self.insert_or_replace_with(hash, key, (), |key_ref, _, key, _| {\n-            retkey = Some(replace(key_ref, key));\n-        });\n-        retkey\n+        match self.entry(key) {\n+            Occupied(mut occupied) => {\n+                let key = occupied.take_key().unwrap();\n+                Some(mem::replace(occupied.elem.read_mut().0, key))\n+            }\n+            Vacant(vacant) => {\n+                vacant.insert(());\n+                None\n+            }\n+        }\n     }\n }\n \n@@ -1750,6 +1713,20 @@ mod test_map {\n         assert_eq!(*m.get(&2).unwrap(), 4);\n     }\n \n+    #[test]\n+    fn test_clone() {\n+        let mut m = HashMap::new();\n+        assert_eq!(m.len(), 0);\n+        assert!(m.insert(1, 2).is_none());\n+        assert_eq!(m.len(), 1);\n+        assert!(m.insert(2, 4).is_none());\n+        assert_eq!(m.len(), 2);\n+        let m2 = m.clone();\n+        assert_eq!(*m2.get(&1).unwrap(), 2);\n+        assert_eq!(*m2.get(&2).unwrap(), 4);\n+        assert_eq!(m2.len(), 2);\n+    }\n+\n     thread_local! { static DROP_VECTOR: RefCell<Vec<isize>> = RefCell::new(Vec::new()) }\n \n     #[derive(Hash, PartialEq, Eq)]\n@@ -1841,7 +1818,7 @@ mod test_map {\n     }\n \n     #[test]\n-    fn test_move_iter_drops() {\n+    fn test_into_iter_drops() {\n         DROP_VECTOR.with(|v| {\n             *v.borrow_mut() = vec![0; 200];\n         });\n@@ -1906,11 +1883,35 @@ mod test_map {\n     }\n \n     #[test]\n-    fn test_empty_pop() {\n+    fn test_empty_remove() {\n         let mut m: HashMap<isize, bool> = HashMap::new();\n         assert_eq!(m.remove(&0), None);\n     }\n \n+    #[test]\n+    fn test_empty_entry() {\n+        let mut m: HashMap<isize, bool> = HashMap::new();\n+        match m.entry(0) {\n+            Occupied(_) => panic!(),\n+            Vacant(_) => {}\n+        }\n+        assert!(*m.entry(0).or_insert(true));\n+        assert_eq!(m.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_empty_iter() {\n+        let mut m: HashMap<isize, bool> = HashMap::new();\n+        assert_eq!(m.drain().next(), None);\n+        assert_eq!(m.keys().next(), None);\n+        assert_eq!(m.values().next(), None);\n+        assert_eq!(m.iter().next(), None);\n+        assert_eq!(m.iter_mut().next(), None);\n+        assert_eq!(m.len(), 0);\n+        assert!(m.is_empty());\n+        assert_eq!(m.into_iter().next(), None);\n+    }\n+\n     #[test]\n     fn test_lots_of_insertions() {\n         let mut m = HashMap::new();"}, {"sha": "5802a1fd2656769c5dbbb2608a55deffe8850455", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 67, "deletions": 42, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8ba2ea5fadffe3ec9e3ef196c33b27be19689600/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ba2ea5fadffe3ec9e3ef196c33b27be19689600/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=8ba2ea5fadffe3ec9e3ef196c33b27be19689600", "patch": "@@ -201,23 +201,47 @@ impl<K, V, M> EmptyBucket<K, V, M> {\n     pub fn table(&self) -> &M {\n         &self.table\n     }\n-    /// Move out the reference to the table.\n-    pub fn into_table(self) -> M {\n-        self.table\n-    }\n }\n \n impl<K, V, M> Bucket<K, V, M> {\n-    /// Move out the reference to the table.\n-    pub fn into_table(self) -> M {\n-        self.table\n-    }\n     /// Get the raw index.\n     pub fn index(&self) -> usize {\n         self.idx\n     }\n }\n \n+impl<K, V, M> Deref for FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> {\n+    type Target = RawTable<K, V>;\n+    fn deref(&self) -> &RawTable<K, V> {\n+        &self.table\n+    }\n+}\n+\n+/// `Put` is implemented for types which provide access to a table and cannot be invalidated\n+///  by filling a bucket. A similar implementation for `Take` is possible.\n+pub trait Put<K, V> {\n+    unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V>;\n+}\n+\n+\n+impl<'t, K, V> Put<K, V> for &'t mut RawTable<K, V> {\n+    unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V> {\n+        *self\n+    }\n+}\n+\n+impl<K, V, M> Put<K, V> for Bucket<K, V, M> where M: Put<K, V> {\n+    unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V> {\n+        self.table.borrow_table_mut()\n+    }\n+}\n+\n+impl<K, V, M> Put<K, V> for FullBucket<K, V, M> where M: Put<K, V> {\n+    unsafe fn borrow_table_mut(&mut self) -> &mut RawTable<K, V> {\n+        self.table.borrow_table_mut()\n+    }\n+}\n+\n impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n     pub fn new(table: M, hash: SafeHash) -> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as usize)\n@@ -268,22 +292,14 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> Bucket<K, V, M> {\n \n     /// Modifies the bucket pointer in place to make it point to the next slot.\n     pub fn next(&mut self) {\n-        // Branchless bucket iteration step.\n-        // As we reach the end of the table...\n-        // We take the current idx:          0111111b\n-        // Xor it by its increment:        ^ 1000000b\n-        //                               ------------\n-        //                                   1111111b\n-        // Then AND with the capacity:     & 1000000b\n-        //                               ------------\n-        // to get the backwards offset:      1000000b\n-        // ... and it's zero at all other times.\n-        let maybe_wraparound_dist = (self.idx ^ (self.idx + 1)) & self.table.capacity();\n-        // Finally, we obtain the offset 1 or the offset -cap + 1.\n-        let dist = 1 - (maybe_wraparound_dist as isize);\n-\n         self.idx += 1;\n-\n+        let range = self.table.capacity();\n+        // This code is branchless thanks to a conditional move.\n+        let dist = if self.idx & (range - 1) == 0 {\n+            1 - range as isize\n+        } else {\n+            1\n+        };\n         unsafe {\n             self.raw = self.raw.offset(dist);\n         }\n@@ -326,7 +342,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> EmptyBucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> EmptyBucket<K, V, M> {\n+impl<K, V, M> EmptyBucket<K, V, M> where M: Put<K, V> {\n     /// Puts given key and value pair, along with the key's hash,\n     /// into this bucket in the hashtable. Note how `self` is 'moved' into\n     /// this function, because this slot will no longer be empty when\n@@ -340,9 +356,9 @@ impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> EmptyBucket<K, V, M> {\n             *self.raw.hash = hash.inspect();\n             ptr::write(self.raw.key, key);\n             ptr::write(self.raw.val, value);\n-        }\n \n-        self.table.size += 1;\n+            self.table.borrow_table_mut().size += 1;\n+        }\n \n         FullBucket { raw: self.raw, idx: self.idx, table: self.table }\n     }\n@@ -365,12 +381,22 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n         }\n     }\n \n+    /// Duplicates the current position. This can be useful for operations\n+    /// on two or more buckets.\n+    pub fn stash(self) -> FullBucket<K, V, Self> {\n+        FullBucket {\n+            raw: self.raw,\n+            idx: self.idx,\n+            table: self,\n+        }\n+    }\n+\n     /// Get the distance between this bucket and the 'ideal' location\n     /// as determined by the key's hash stored in it.\n     ///\n     /// In the cited blog posts above, this is called the \"distance to\n     /// initial bucket\", or DIB. Also known as \"probe count\".\n-    pub fn distance(&self) -> usize {\n+    pub fn displacement(&self) -> usize {\n         // Calculates the distance one has to travel when going from\n         // `hash mod capacity` onwards to `idx mod capacity`, wrapping around\n         // if the destination is not reached before the end of the table.\n@@ -395,12 +421,15 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> FullBucket<K, V, M> {\n     }\n }\n \n-impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> FullBucket<K, V, M> {\n+// We take a mutable reference to the table instead of accepting anything that\n+// implements `DerefMut` to prevent fn `take` from being called on `stash`ed\n+// buckets.\n+impl<'t, K, V> FullBucket<K, V, &'t mut RawTable<K, V>> {\n     /// Removes this bucket's key and value from the hashtable.\n     ///\n     /// This works similarly to `put`, building an `EmptyBucket` out of the\n     /// taken bucket.\n-    pub fn take(mut self) -> (EmptyBucket<K, V, M>, K, V) {\n+    pub fn take(mut self) -> (EmptyBucket<K, V, &'t mut RawTable<K, V>>, K, V) {\n         self.table.size -= 1;\n \n         unsafe {\n@@ -416,7 +445,11 @@ impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> FullBucket<K, V, M> {\n             )\n         }\n     }\n+}\n \n+// This use of `Put` is misleading and restrictive, but safe and sufficient for our use cases\n+// where `M` is a full bucket or table reference type with mutable access to the table.\n+impl<K, V, M> FullBucket<K, V, M> where M: Put<K, V> {\n     pub fn replace(&mut self, h: SafeHash, k: K, v: V) -> (SafeHash, K, V) {\n         unsafe {\n             let old_hash = ptr::replace(self.raw.hash as *mut SafeHash, h);\n@@ -426,7 +459,9 @@ impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> FullBucket<K, V, M> {\n             (old_hash, old_key, old_val)\n         }\n     }\n+}\n \n+impl<K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + DerefMut {\n     /// Gets mutable references to the key and value at a given index.\n     pub fn read_mut(&mut self) -> (&mut K, &mut V) {\n         unsafe {\n@@ -436,7 +471,7 @@ impl<K, V, M: Deref<Target=RawTable<K, V>> + DerefMut> FullBucket<K, V, M> {\n     }\n }\n \n-impl<'t, K, V, M: Deref<Target=RawTable<K, V>> + 't> FullBucket<K, V, M> {\n+impl<'t, K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + 't {\n     /// Exchange a bucket state for immutable references into the table.\n     /// Because the underlying reference to the table is also consumed,\n     /// no further changes to the structure of the table are possible;\n@@ -450,7 +485,7 @@ impl<'t, K, V, M: Deref<Target=RawTable<K, V>> + 't> FullBucket<K, V, M> {\n     }\n }\n \n-impl<'t, K, V, M: Deref<Target=RawTable<K, V>> + DerefMut + 't> FullBucket<K, V, M> {\n+impl<'t, K, V, M> FullBucket<K, V, M> where M: Deref<Target=RawTable<K, V>> + DerefMut + 't {\n     /// This works similarly to `into_refs`, exchanging a bucket state\n     /// for mutable references into the table.\n     pub fn into_mut_refs(self) -> (&'t mut K, &'t mut V) {\n@@ -461,17 +496,7 @@ impl<'t, K, V, M: Deref<Target=RawTable<K, V>> + DerefMut + 't> FullBucket<K, V,\n     }\n }\n \n-impl<K, V, M> BucketState<K, V, M> {\n-    // For convenience.\n-    pub fn expect_full(self) -> FullBucket<K, V, M> {\n-        match self {\n-            Full(full) => full,\n-            Empty(..) => panic!(\"Expected full bucket\")\n-        }\n-    }\n-}\n-\n-impl<K, V, M: Deref<Target=RawTable<K, V>>> GapThenFull<K, V, M> {\n+impl<K, V, M> GapThenFull<K, V, M> where M: Deref<Target=RawTable<K, V>> {\n     #[inline]\n     pub fn full(&self) -> &FullBucket<K, V, M> {\n         &self.full"}]}