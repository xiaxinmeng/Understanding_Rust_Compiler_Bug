{"sha": "f0b514524fed8c8cca369a51feece8be50f8b82b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwYjUxNDUyNGZlZDhjOGNjYTM2OWE1MWZlZWNlOGJlNTBmOGI4MmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-03T13:12:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-03-03T13:12:08Z"}, "message": "Auto merge of #40133 - arielb1:operand-lifetimes, r=eddyb\n\n[MIR] improve operand lifetimes\n\nr? @eddyb", "tree": {"sha": "190d488fcebef18c1c13ae3c5df2fad14e70293e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/190d488fcebef18c1c13ae3c5df2fad14e70293e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0b514524fed8c8cca369a51feece8be50f8b82b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0b514524fed8c8cca369a51feece8be50f8b82b", "html_url": "https://github.com/rust-lang/rust/commit/f0b514524fed8c8cca369a51feece8be50f8b82b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0b514524fed8c8cca369a51feece8be50f8b82b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1476105dd3ae92042800d7b8e8e860dd4a60c59b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1476105dd3ae92042800d7b8e8e860dd4a60c59b", "html_url": "https://github.com/rust-lang/rust/commit/1476105dd3ae92042800d7b8e8e860dd4a60c59b"}, {"sha": "f99f1f8975ea00605e809de5a78d1876a67fc6ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/f99f1f8975ea00605e809de5a78d1876a67fc6ee", "html_url": "https://github.com/rust-lang/rust/commit/f99f1f8975ea00605e809de5a78d1876a67fc6ee"}], "stats": {"total": 486, "additions": 356, "deletions": 130}, "files": [{"sha": "a71d23e7e1e7ecf98a717219448c53dc0e8fd4fd", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -161,6 +161,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn create_drop_flag(&mut self, index: MovePathIndex) {\n         let tcx = self.tcx;\n         let patch = &mut self.patch;\n+        debug!(\"create_drop_flag({:?})\", self.mir.span);\n         self.drop_flags.entry(index).or_insert_with(|| {\n             patch.new_temp(tcx.types.bool)\n         });"}, {"sha": "3305cfc0dfe1a54a6cf4a461de8be5587cb4d1f7", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -67,7 +67,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 this.expr_into_pattern(block, pattern, init)\n                             }));\n                         } else {\n-                            this.storage_live_for_bindings(block, &pattern);\n+                            this.visit_bindings(&pattern, &mut |this, _, _, node, span, _| {\n+                                this.storage_live_binding(block, node, span);\n+                                this.schedule_drop_for_binding(node, span);\n+                            })\n                         }\n \n                         // Enter the visibility scope, after evaluating the initializer."}, {"sha": "8886a310429ea2fd86657c94040d62f7423d453f", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -56,8 +56,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let (usize_ty, bool_ty) = (this.hir.usize_ty(), this.hir.bool_ty());\n \n                 let slice = unpack!(block = this.as_lvalue(block, lhs));\n-\n-                let idx = unpack!(block = this.as_operand(block, index));\n+                // extent=None so lvalue indexes live forever. They are scalars so they\n+                // do not need storage annotations, and they are often copied between\n+                // places.\n+                let idx = unpack!(block = this.as_operand(block, None, index));\n \n                 // bounds check:\n                 let (len, lt) = (this.temp(usize_ty.clone()), this.temp(bool_ty));\n@@ -121,7 +123,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Some(Category::Lvalue) => false,\n                     _ => true,\n                 });\n-                this.as_temp(block, expr)\n+                this.as_temp(block, expr.temp_lifetime, expr)\n             }\n         }\n     }"}, {"sha": "8d79e755685d0842b125103533b9ad3591e57a51", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -13,29 +13,52 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::Category;\n use hair::*;\n+use rustc::middle::region::CodeExtent;\n use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    /// Returns an operand suitable for use until the end of the current\n+    /// scope expression.\n+    ///\n+    /// The operand returned from this function will *not be valid* after\n+    /// an ExprKind::Scope is passed, so please do *not* return it from\n+    /// functions to avoid bad miscompiles.\n+    pub fn as_local_operand<M>(&mut self, block: BasicBlock, expr: M)\n+                             -> BlockAnd<Operand<'tcx>>\n+        where M: Mirror<'tcx, Output = Expr<'tcx>>\n+    {\n+        let topmost_scope = self.topmost_scope(); // FIXME(#6393)\n+        self.as_operand(block, Some(topmost_scope), expr)\n+    }\n+\n     /// Compile `expr` into a value that can be used as an operand.\n     /// If `expr` is an lvalue like `x`, this will introduce a\n     /// temporary `tmp = x`, so that we capture the value of `x` at\n     /// this time.\n-    pub fn as_operand<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Operand<'tcx>>\n+    ///\n+    /// The operand is known to be live until the end of `scope`.\n+    pub fn as_operand<M>(&mut self,\n+                         block: BasicBlock,\n+                         scope: Option<CodeExtent>,\n+                         expr: M) -> BlockAnd<Operand<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_operand(block, expr)\n+        self.expr_as_operand(block, scope, expr)\n     }\n \n     fn expr_as_operand(&mut self,\n                        mut block: BasicBlock,\n+                       scope: Option<CodeExtent>,\n                        expr: Expr<'tcx>)\n                        -> BlockAnd<Operand<'tcx>> {\n         debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this| this.as_operand(block, value));\n+            return this.in_scope(extent, block, |this| {\n+                this.as_operand(block, scope, value)\n+            });\n         }\n \n         let category = Category::of(&expr.kind).unwrap();\n@@ -47,7 +70,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             Category::Lvalue |\n             Category::Rvalue(..) => {\n-                let operand = unpack!(block = this.as_temp(block, expr));\n+                let operand =\n+                    unpack!(block = this.as_temp(block, scope, expr));\n                 block.and(Operand::Consume(operand))\n             }\n         }"}, {"sha": "6694107a8d48510bb3991ff74fcc74462e17e6e9", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -21,22 +21,34 @@ use build::expr::category::{Category, RvalueFunc};\n use hair::*;\n use rustc_const_math::{ConstInt, ConstIsize};\n use rustc::middle::const_val::ConstVal;\n+use rustc::middle::region::CodeExtent;\n use rustc::ty;\n use rustc::mir::*;\n use syntax::ast;\n use syntax_pos::Span;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n+    /// See comment on `as_local_operand`\n+    pub fn as_local_rvalue<M>(&mut self, block: BasicBlock, expr: M)\n+                             -> BlockAnd<Rvalue<'tcx>>\n+        where M: Mirror<'tcx, Output = Expr<'tcx>>\n+    {\n+        let topmost_scope = self.topmost_scope(); // FIXME(#6393)\n+        self.as_rvalue(block, Some(topmost_scope), expr)\n+    }\n+\n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n+    pub fn as_rvalue<M>(&mut self, block: BasicBlock, scope: Option<CodeExtent>, expr: M)\n+                        -> BlockAnd<Rvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_rvalue(block, expr)\n+        self.expr_as_rvalue(block, scope, expr)\n     }\n \n     fn expr_as_rvalue(&mut self,\n                       mut block: BasicBlock,\n+                      scope: Option<CodeExtent>,\n                       expr: Expr<'tcx>)\n                       -> BlockAnd<Rvalue<'tcx>> {\n         debug!(\"expr_as_rvalue(block={:?}, expr={:?})\", block, expr);\n@@ -47,24 +59,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n+                this.in_scope(extent, block, |this| this.as_rvalue(block, scope, value))\n             }\n             ExprKind::Repeat { value, count } => {\n-                let value_operand = unpack!(block = this.as_operand(block, value));\n+                let value_operand = unpack!(block = this.as_operand(block, scope, value));\n                 block.and(Rvalue::Repeat(value_operand, count))\n             }\n             ExprKind::Borrow { region, borrow_kind, arg } => {\n                 let arg_lvalue = unpack!(block = this.as_lvalue(block, arg));\n                 block.and(Rvalue::Ref(region, borrow_kind, arg_lvalue))\n             }\n             ExprKind::Binary { op, lhs, rhs } => {\n-                let lhs = unpack!(block = this.as_operand(block, lhs));\n-                let rhs = unpack!(block = this.as_operand(block, rhs));\n+                let lhs = unpack!(block = this.as_operand(block, scope, lhs));\n+                let rhs = unpack!(block = this.as_operand(block, scope, rhs));\n                 this.build_binary_op(block, op, expr_span, expr.ty,\n                                      lhs, rhs)\n             }\n             ExprKind::Unary { op, arg } => {\n-                let arg = unpack!(block = this.as_operand(block, arg));\n+                let arg = unpack!(block = this.as_operand(block, scope, arg));\n                 // Check for -MIN on signed integers\n                 if this.hir.check_overflow() && op == UnOp::Neg && expr.ty.is_signed() {\n                     let bool_ty = this.hir.bool_ty();\n@@ -97,27 +109,27 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Cast { source } => {\n                 let source = this.hir.mirror(source);\n \n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::Misc, source, expr.ty))\n             }\n             ExprKind::Use { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Use(source))\n             }\n             ExprKind::ReifyFnPointer { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::ReifyFnPointer, source, expr.ty))\n             }\n             ExprKind::UnsafeFnPointer { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::UnsafeFnPointer, source, expr.ty))\n             }\n             ExprKind::ClosureFnPointer { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::ClosureFnPointer, source, expr.ty))\n             }\n             ExprKind::Unsize { source } => {\n-                let source = unpack!(block = this.as_operand(block, source));\n+                let source = unpack!(block = this.as_operand(block, scope, source));\n                 block.and(Rvalue::Cast(CastKind::Unsize, source, expr.ty))\n             }\n             ExprKind::Array { fields } => {\n@@ -151,7 +163,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let el_ty = expr.ty.sequence_element_type(this.hir.tcx());\n                 let fields: Vec<_> =\n                     fields.into_iter()\n-                          .map(|f| unpack!(block = this.as_operand(block, f)))\n+                          .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n                           .collect();\n \n                 block.and(Rvalue::Aggregate(AggregateKind::Array(el_ty), fields))\n@@ -160,15 +172,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // first process the set of fields\n                 let fields: Vec<_> =\n                     fields.into_iter()\n-                          .map(|f| unpack!(block = this.as_operand(block, f)))\n+                          .map(|f| unpack!(block = this.as_operand(block, scope, f)))\n                           .collect();\n \n                 block.and(Rvalue::Aggregate(AggregateKind::Tuple, fields))\n             }\n             ExprKind::Closure { closure_id, substs, upvars } => { // see (*) above\n                 let upvars =\n                     upvars.into_iter()\n-                          .map(|upvar| unpack!(block = this.as_operand(block, upvar)))\n+                          .map(|upvar| unpack!(block = this.as_operand(block, scope, upvar)))\n                           .collect();\n                 block.and(Rvalue::Aggregate(AggregateKind::Closure(closure_id, substs), upvars))\n             }\n@@ -180,10 +192,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 // first process the set of fields that were provided\n                 // (evaluating them in order given by user)\n-                let fields_map: FxHashMap<_, _> =\n-                    fields.into_iter()\n-                          .map(|f| (f.name, unpack!(block = this.as_operand(block, f.expr))))\n-                          .collect();\n+                let fields_map: FxHashMap<_, _> = fields.into_iter()\n+                    .map(|f| (f.name, unpack!(block = this.as_operand(block, scope, f.expr))))\n+                    .collect();\n \n                 let field_names = this.hir.all_fields(adt_def, variant_index);\n \n@@ -236,7 +247,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Some(Category::Rvalue(RvalueFunc::AsRvalue)) => false,\n                     _ => true,\n                 });\n-                let operand = unpack!(block = this.as_operand(block, expr));\n+                let operand = unpack!(block = this.as_operand(block, scope, expr));\n                 block.and(Rvalue::Use(operand))\n             }\n         }"}, {"sha": "69b95702009213432d1528cd281e09e85e3bc761", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -13,29 +13,38 @@\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::Category;\n use hair::*;\n+use rustc::middle::region::CodeExtent;\n use rustc::mir::*;\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n-    pub fn as_temp<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Lvalue<'tcx>>\n+    pub fn as_temp<M>(&mut self,\n+                      block: BasicBlock,\n+                      temp_lifetime: Option<CodeExtent>,\n+                      expr: M)\n+                      -> BlockAnd<Lvalue<'tcx>>\n         where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n-        self.expr_as_temp(block, expr)\n+        self.expr_as_temp(block, temp_lifetime, expr)\n     }\n \n-    fn expr_as_temp(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<Lvalue<'tcx>> {\n+    fn expr_as_temp(&mut self,\n+                    mut block: BasicBlock,\n+                    temp_lifetime: Option<CodeExtent>,\n+                    expr: Expr<'tcx>)\n+                    -> BlockAnd<Lvalue<'tcx>> {\n         debug!(\"expr_as_temp(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n-        if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this| this.as_temp(block, value));\n+        if let ExprKind::Scope { .. } = expr.kind {\n+            span_bug!(expr.span, \"unexpected scope expression in as_temp: {:?}\",\n+                      expr);\n         }\n \n         let expr_ty = expr.ty.clone();\n         let temp = this.temp(expr_ty.clone());\n-        let temp_lifetime = expr.temp_lifetime;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n "}, {"sha": "dab85106873299e2747b79e954f36c2c41941620", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     _ => false,\n                 };\n \n-                unpack!(block = this.as_rvalue(block, source));\n+                unpack!(block = this.as_local_rvalue(block, source));\n \n                 // This is an optimization. If the expression was a call then we already have an\n                 // unreachable block. Don't bother to terminate it and create a new one.\n@@ -65,7 +65,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n             ExprKind::If { condition: cond_expr, then: then_expr, otherwise: else_expr } => {\n-                let operand = unpack!(block = this.as_operand(block, cond_expr));\n+                let operand = unpack!(block = this.as_local_operand(block, cond_expr));\n \n                 let mut then_block = this.cfg.start_new_block();\n                 let mut else_block = this.cfg.start_new_block();\n@@ -107,15 +107,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     (this.cfg.start_new_block(), this.cfg.start_new_block(),\n                      this.cfg.start_new_block(), this.cfg.start_new_block());\n \n-                let lhs = unpack!(block = this.as_operand(block, lhs));\n+                let lhs = unpack!(block = this.as_local_operand(block, lhs));\n                 let blocks = match op {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n                 let term = TerminatorKind::if_(this.hir.tcx(), lhs, blocks.0, blocks.1);\n                 this.cfg.terminate(block, source_info, term);\n \n-                let rhs = unpack!(else_block = this.as_operand(else_block, rhs));\n+                let rhs = unpack!(else_block = this.as_local_operand(else_block, rhs));\n                 let term = TerminatorKind::if_(this.hir.tcx(), rhs, true_block, false_block);\n                 this.cfg.terminate(else_block, source_info, term);\n \n@@ -173,7 +173,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         if let Some(cond_expr) = opt_cond_expr {\n                             let loop_block_end;\n                             let cond = unpack!(\n-                                loop_block_end = this.as_operand(loop_block, cond_expr));\n+                                loop_block_end = this.as_local_operand(loop_block, cond_expr));\n                             body_block = this.cfg.start_new_block();\n                             let term = TerminatorKind::if_(this.hir.tcx(), cond,\n                                                            body_block, exit_block);\n@@ -206,10 +206,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     _ => false\n                 };\n-                let fun = unpack!(block = this.as_operand(block, fun));\n+                let fun = unpack!(block = this.as_local_operand(block, fun));\n                 let args: Vec<_> =\n                     args.into_iter()\n-                        .map(|arg| unpack!(block = this.as_operand(block, arg)))\n+                        .map(|arg| unpack!(block = this.as_local_operand(block, arg)))\n                         .collect();\n \n                 let success = this.cfg.start_new_block();\n@@ -265,7 +265,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     _ => true,\n                 });\n \n-                let rvalue = unpack!(block = this.as_rvalue(block, expr));\n+                let rvalue = unpack!(block = this.as_local_rvalue(block, expr));\n                 this.cfg.push_assign(block, source_info, destination, rvalue);\n                 block.unit()\n             }"}, {"sha": "be39dcbf6d08d84a3940a32188dffb6838710cfb", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -38,14 +38,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // Generate better code for things that don't need to be\n                 // dropped.\n                 if this.hir.needs_drop(lhs.ty) {\n-                    let rhs = unpack!(block = this.as_operand(block, rhs));\n+                    let rhs = unpack!(block = this.as_local_operand(block, rhs));\n                     let lhs = unpack!(block = this.as_lvalue(block, lhs));\n                     unpack!(block = this.build_drop_and_replace(\n                         block, lhs_span, lhs, rhs\n                     ));\n                     block.unit()\n                 } else {\n-                    let rhs = unpack!(block = this.as_rvalue(block, rhs));\n+                    let rhs = unpack!(block = this.as_local_rvalue(block, rhs));\n                     let lhs = unpack!(block = this.as_lvalue(block, lhs));\n                     this.cfg.push_assign(block, source_info, &lhs, rhs);\n                     block.unit()\n@@ -64,7 +64,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let lhs_ty = lhs.ty;\n \n                 // As above, RTL.\n-                let rhs = unpack!(block = this.as_operand(block, rhs));\n+                let rhs = unpack!(block = this.as_local_operand(block, rhs));\n                 let lhs = unpack!(block = this.as_lvalue(block, lhs));\n \n                 // we don't have to drop prior contents or anything\n@@ -122,7 +122,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     unpack!(block = this.as_lvalue(block, output))\n                 }).collect();\n                 let inputs = inputs.into_iter().map(|input| {\n-                    unpack!(block = this.as_operand(block, input))\n+                    unpack!(block = this.as_local_operand(block, input))\n                 }).collect();\n                 this.cfg.push(block, Statement {\n                     source_info: source_info,"}, {"sha": "705eb1f56608e49be2b7fdd1bef2458804f047a8", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 51, "deletions": 71, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -123,16 +123,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             PatternKind::Binding { mode: BindingMode::ByValue,\n                                    var,\n                                    subpattern: None, .. } => {\n-                self.storage_live_for_bindings(block, &irrefutable_pat);\n-                let lvalue = Lvalue::Local(self.var_indices[&var]);\n-                return self.into(&lvalue, block, initializer);\n+                let lvalue = self.storage_live_binding(block, var, irrefutable_pat.span);\n+                unpack!(block = self.into(&lvalue, block, initializer));\n+                self.schedule_drop_for_binding(var, irrefutable_pat.span);\n+                block.unit()\n+            }\n+            _ => {\n+                let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n+                self.lvalue_into_pattern(block, irrefutable_pat, &lvalue)\n             }\n-            _ => {}\n         }\n-        let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n-        self.lvalue_into_pattern(block,\n-                                 irrefutable_pat,\n-                                 &lvalue)\n     }\n \n     pub fn lvalue_into_pattern(&mut self,\n@@ -174,79 +174,70 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             scope_span: Span,\n                             pattern: &Pattern<'tcx>)\n                             -> Option<VisibilityScope> {\n-        match *pattern.kind {\n-            PatternKind::Binding { mutability, name, mode: _, var, ty, ref subpattern } => {\n-                if var_scope.is_none() {\n-                    var_scope = Some(self.new_visibility_scope(scope_span));\n-                }\n-                let source_info = SourceInfo {\n-                    span: pattern.span,\n-                    scope: var_scope.unwrap()\n-                };\n-                self.declare_binding(source_info, mutability, name, var, ty);\n-                if let Some(subpattern) = subpattern.as_ref() {\n-                    var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n-                }\n-            }\n-            PatternKind::Array { ref prefix, ref slice, ref suffix } |\n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n-                for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n-                }\n-            }\n-            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n-            }\n-            PatternKind::Deref { ref subpattern } => {\n-                var_scope = self.declare_bindings(var_scope, scope_span, subpattern);\n-            }\n-            PatternKind::Leaf { ref subpatterns } |\n-            PatternKind::Variant { ref subpatterns, .. } => {\n-                for subpattern in subpatterns {\n-                    var_scope = self.declare_bindings(var_scope, scope_span, &subpattern.pattern);\n-                }\n+        self.visit_bindings(pattern, &mut |this, mutability, name, var, span, ty| {\n+            if var_scope.is_none() {\n+                var_scope = Some(this.new_visibility_scope(scope_span));\n             }\n-        }\n+            let source_info = SourceInfo {\n+                span: span,\n+                scope: var_scope.unwrap()\n+            };\n+            this.declare_binding(source_info, mutability, name, var, ty);\n+        });\n         var_scope\n     }\n \n-    /// Emit `StorageLive` for every binding in the pattern.\n-    pub fn storage_live_for_bindings(&mut self,\n-                                     block: BasicBlock,\n-                                     pattern: &Pattern<'tcx>) {\n-        match *pattern.kind {\n-            PatternKind::Binding { var, ref subpattern, .. } => {\n-                let lvalue = Lvalue::Local(self.var_indices[&var]);\n-                let source_info = self.source_info(pattern.span);\n-                self.cfg.push(block, Statement {\n-                    source_info: source_info,\n-                    kind: StatementKind::StorageLive(lvalue)\n-                });\n+    pub fn storage_live_binding(&mut self, block: BasicBlock, var: NodeId, span: Span)\n+                            -> Lvalue<'tcx>\n+    {\n+        let local_id = self.var_indices[&var];\n+        let source_info = self.source_info(span);\n+        self.cfg.push(block, Statement {\n+            source_info: source_info,\n+            kind: StatementKind::StorageLive(Lvalue::Local(local_id))\n+        });\n+        Lvalue::Local(local_id)\n+    }\n \n+    pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n+        let local_id = self.var_indices[&var];\n+        let var_ty = self.local_decls[local_id].ty;\n+        let extent = self.hir.tcx().region_maps.var_scope(var);\n+        self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty);\n+    }\n+\n+    pub fn visit_bindings<F>(&mut self, pattern: &Pattern<'tcx>, mut f: &mut F)\n+        where F: FnMut(&mut Self, Mutability, Name, NodeId, Span, Ty<'tcx>)\n+    {\n+        match *pattern.kind {\n+            PatternKind::Binding { mutability, name, var, ty, ref subpattern, .. } => {\n+                f(self, mutability, name, var, pattern.span, ty);\n                 if let Some(subpattern) = subpattern.as_ref() {\n-                    self.storage_live_for_bindings(block, subpattern);\n+                    self.visit_bindings(subpattern, f);\n                 }\n             }\n             PatternKind::Array { ref prefix, ref slice, ref suffix } |\n             PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 for subpattern in prefix.iter().chain(slice).chain(suffix) {\n-                    self.storage_live_for_bindings(block, subpattern);\n+                    self.visit_bindings(subpattern, f);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n             }\n             PatternKind::Deref { ref subpattern } => {\n-                self.storage_live_for_bindings(block, subpattern);\n+                self.visit_bindings(subpattern, f);\n             }\n             PatternKind::Leaf { ref subpatterns } |\n             PatternKind::Variant { ref subpatterns, .. } => {\n                 for subpattern in subpatterns {\n-                    self.storage_live_for_bindings(block, &subpattern.pattern);\n+                    self.visit_bindings(&subpattern.pattern, f);\n                 }\n             }\n         }\n     }\n }\n \n+\n /// List of blocks for each arm (and potentially other metadata in the\n /// future).\n struct ArmBlocks {\n@@ -670,7 +661,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // guard, this block is simply unreachable\n             let guard = self.hir.mirror(guard);\n             let source_info = self.source_info(guard.span);\n-            let cond = unpack!(block = self.as_operand(block, guard));\n+            let cond = unpack!(block = self.as_local_operand(block, guard));\n             let otherwise = self.cfg.start_new_block();\n             self.cfg.terminate(block, source_info,\n                                TerminatorKind::if_(self.hir.tcx(), cond, arm_block, otherwise));\n@@ -691,25 +682,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n-            // Find the variable for the `var_id` being bound. It\n-            // should have been created by a previous call to\n-            // `declare_bindings`.\n-            let var_index = self.var_indices[&binding.var_id];\n-\n+            let source_info = self.source_info(binding.span);\n+            let local = self.storage_live_binding(block, binding.var_id, binding.span);\n+            self.schedule_drop_for_binding(binding.var_id, binding.span);\n             let rvalue = match binding.binding_mode {\n                 BindingMode::ByValue =>\n                     Rvalue::Use(Operand::Consume(binding.source)),\n                 BindingMode::ByRef(region, borrow_kind) =>\n                     Rvalue::Ref(region, borrow_kind, binding.source),\n             };\n-\n-            let source_info = self.source_info(binding.span);\n-            self.cfg.push(block, Statement {\n-                source_info: source_info,\n-                kind: StatementKind::StorageLive(Lvalue::Local(var_index))\n-            });\n-            self.cfg.push_assign(block, source_info,\n-                                 &Lvalue::Local(var_index), rvalue);\n+            self.cfg.push_assign(block, source_info, &local, rvalue);\n         }\n     }\n \n@@ -730,8 +712,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             name: Some(name),\n             source_info: Some(source_info),\n         });\n-        let extent = self.hir.tcx().region_maps.var_scope(var_id);\n-        self.schedule_drop(source_info.span, extent, &Lvalue::Local(var), var_ty);\n         self.var_indices.insert(var_id, var);\n \n         debug!(\"declare_binding: var={:?}\", var);"}, {"sha": "3dab1717f6b2e4a466534457c6eb971435eef903", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -253,9 +253,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             f: F)\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>)\n     {\n-        let extent = self.scopes.last().map(|scope| scope.extent).unwrap();\n+        let extent = self.topmost_scope();\n         let loop_scope = LoopScope {\n-            extent: extent.clone(),\n+            extent: extent,\n             continue_block: loop_block,\n             break_block: break_block,\n             break_destination: break_destination,\n@@ -416,6 +416,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.scopes[1].extent\n     }\n \n+    /// Returns the topmost active scope, which is known to be alive until\n+    /// the next scope expression.\n+    pub fn topmost_scope(&self) -> CodeExtent {\n+        self.scopes.last().expect(\"topmost_scope: no scopes present\").extent\n+    }\n+\n     // Scheduling drops\n     // ================\n     /// Indicates that `lvalue` should be dropped on exit from"}, {"sha": "5c1f1f8f2bb203b8e15811ee7582d30f703f069b", "filename": "src/test/codegen/lifetime_start_end.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Flifetime_start_end.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -11,11 +11,9 @@\n // compile-flags: -O -C no-prepopulate-passes\n \n #![crate_type = \"lib\"]\n-#![feature(rustc_attrs)]\n \n // CHECK-LABEL: @test\n #[no_mangle]\n-#[rustc_mir] // FIXME #27840 MIR has different codegen.\n pub fn test() {\n     let a = 0;\n     &a; // keep variable in an alloca\n@@ -33,11 +31,11 @@ pub fn test() {\n // CHECK: [[S__5:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_5 to i8*\n // CHECK: call void @llvm.lifetime.start(i{{[0-9 ]+}}, i8* [[S__5]])\n \n-// CHECK: [[E__5:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_5 to i8*\n-// CHECK: call void @llvm.lifetime.end(i{{[0-9 ]+}}, i8* [[E__5]])\n-\n // CHECK: [[E_b:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"** %b to i8*\n // CHECK: call void @llvm.lifetime.end(i{{[0-9 ]+}}, i8* [[E_b]])\n+\n+// CHECK: [[E__5:%[0-9]+]] = bitcast %\"core::option::Option<i32>\"* %_5 to i8*\n+// CHECK: call void @llvm.lifetime.end(i{{[0-9 ]+}}, i8* [[E__5]])\n     }\n \n     let c = 1;"}, {"sha": "b4f6b33be26a1634d69fa0d95028d3771198b578", "filename": "src/test/debuginfo/drop-locations.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Fdebuginfo%2Fdrop-locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Fdebuginfo%2Fdrop-locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fdrop-locations.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -14,7 +14,8 @@\n \n #![allow(unused)]\n \n-// compile-flags:-g\n+// compile-flags:-g -O -C no-prepopulate-passes\n+// -O -C no-prepopulate-passes added to work around https://bugs.llvm.org/show_bug.cgi?id=32123\n \n // This test checks that drop glue code gets attributed to scope's closing brace,\n // and function epilogues - to function's closing brace."}, {"sha": "9c924a23903f975d59ff6b9506500118af1dd342", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// this tests move up progration, which is not yet implemented\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that codegen of assignment expressions is sane. Assignments\n+// tend to be absent in simple code, so subtle breakage in them can\n+// leave a quite hard-to-find trail of destruction.\n+\n+fn main() {\n+    let nodrop_x = false;\n+    let nodrop_y;\n+\n+    nodrop_y = nodrop_x;\n+\n+    let drop_x : Option<Box<u32>> = None;\n+    let drop_y;\n+\n+    drop_y = drop_x;\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node4.SimplifyCfg.initial-after.mir\n+//     bb0: {\n+//         StorageLive(_1);\n+//         _1 = const false;\n+//         StorageLive(_2);\n+//         StorageLive(_3);\n+//         _3 = _1;\n+//         _2 = _3;\n+//         StorageDead(_3);\n+//         StorageLive(_4);\n+//         _4 = std::option::Option<std::boxed::Box<u32>>::None;\n+//         StorageLive(_6);\n+//         StorageLive(_7);\n+//         _7 = _4;\n+//         replace(_6 <- _7) -> [return: bb5, unwind: bb4];\n+//     }\n+//     bb1: {\n+//         resume;\n+//     }\n+//     bb2: {\n+//         drop(_4) -> bb1;\n+//     }\n+//     bb3: {\n+//         drop(_6) -> bb2;\n+//     }\n+//     bb4: {\n+//         drop(_7) -> bb3;\n+//     }\n+//     bb5: {\n+//         drop(_7) -> [return: bb6, unwind: bb3];\n+//     }\n+//     bb6: {\n+//         StorageDead(_7);\n+//         _0 = ();\n+//         drop(_6) -> [return: bb7, unwind: bb2];\n+//     }\n+//     bb7: {\n+//         StorageDead(_6);\n+//         drop(_4) -> bb8;\n+//     }\n+//     bb8: {\n+//         StorageDead(_4);\n+//         StorageDead(_2);\n+//         StorageDead(_1);\n+//         return;\n+//     }\n+// END rustc.node4.SimplifyCfg.initial-after.mir"}, {"sha": "1d452907cf59acad2c58c4fedb74da2b66e302cb", "filename": "src/test/mir-opt/issue-38669.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Fmir-opt%2Fissue-38669.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-38669.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// check that we don't StorageDead booleans before they are used\n+\n+fn main() {\n+    let mut should_break = false;\n+    loop {\n+        if should_break {\n+            break;\n+        }\n+        should_break = true;\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node4.SimplifyCfg.initial-after.mir\n+//     bb0: {\n+//         StorageLive(_1);\n+//         _1 = const false;\n+//         goto -> bb1;\n+//     }\n+//\n+//     bb1: {\n+//         StorageLive(_4);\n+//         _4 = _1;\n+//         switchInt(_4) -> [0u8: bb3, otherwise: bb2];\n+//     }\n+//\n+//     bb2: {\n+//         StorageLive(_6);\n+//         _0 = ();\n+//         StorageDead(_4);\n+//         StorageDead(_1);\n+//         return;\n+//     }\n+//\n+//     bb3: {\n+//         _3 = ();\n+//         StorageDead(_4);\n+//         _1 = const true;\n+//         _2 = ();\n+//         goto -> bb1;\n+//     }\n+// END rustc.node4.SimplifyCfg.initial-after.mir"}, {"sha": "3fbd1a36f2f169bcb935b452a0e38d75c90ff955", "filename": "src/test/mir-opt/storage_ranges.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fstorage_ranges.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -28,16 +28,15 @@ fn main() {\n //         StorageLive(_5);\n //         _5 = _1;\n //         _4 = std::option::Option<i32>::Some(_5,);\n-//         _3 = &_4;\n //         StorageDead(_5);\n+//         _3 = &_4;\n //         _2 = ();\n-//         StorageDead(_4);\n //         StorageDead(_3);\n+//         StorageDead(_4);\n //         StorageLive(_6);\n //         _6 = const 1i32;\n //         _0 = ();\n //         StorageDead(_6);\n //         StorageDead(_1);\n-//         return;\n-//     }\n+//      }\n // END rustc.node4.TypeckMir.before.mir"}, {"sha": "e7da43597f1691dfd4f4457d5583bb4041a60398", "filename": "src/test/run-pass/mir_drop_order.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0b514524fed8c8cca369a51feece8be50f8b82b/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs?ref=f0b514524fed8c8cca369a51feece8be50f8b82b", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::cell::RefCell;\n+use std::panic;\n+\n+pub struct DropLogger<'a> {\n+    id: usize,\n+    log: &'a panic::AssertUnwindSafe<RefCell<Vec<usize>>>\n+}\n+\n+impl<'a> Drop for DropLogger<'a> {\n+    fn drop(&mut self) {\n+        self.log.0.borrow_mut().push(self.id);\n+    }\n+}\n+\n+struct InjectedFailure;\n+\n+#[allow(unreachable_code)]\n+fn main() {\n+    let log = panic::AssertUnwindSafe(RefCell::new(vec![]));\n+    let d = |id| DropLogger { id: id, log: &log };\n+    let get = || -> Vec<_> {\n+        let mut m = log.0.borrow_mut();\n+        let n = m.drain(..);\n+        n.collect()\n+    };\n+\n+    {\n+        let _x = (d(0), &d(1), d(2), &d(3));\n+        // all borrows are extended - nothing has been dropped yet\n+        assert_eq!(get(), vec![]);\n+    }\n+    // in a let-statement, extended lvalues are dropped\n+    // *after* the let result (tho they have the same scope\n+    // as far as scope-based borrowck goes).\n+    assert_eq!(get(), vec![0, 2, 3, 1]);\n+\n+    let _ = std::panic::catch_unwind(|| {\n+        (d(4), &d(5), d(6), &d(7), panic!(InjectedFailure));\n+    });\n+\n+    // here, the temporaries (5/7) live until the end of the\n+    // containing statement, which is destroyed after the operands\n+    // (4/6) on a panic.\n+    assert_eq!(get(), vec![6, 4, 7, 5]);\n+}"}]}