{"sha": "e48685edef9889d7c0ae391cf050f878d228ae25", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ODY4NWVkZWY5ODg5ZDdjMGFlMzkxY2YwNTBmODc4ZDIyOGFlMjU=", "commit": {"author": {"name": "Takayuki Nakata", "email": "f.seasons017@gmail.com", "date": "2020-07-22T14:22:17Z"}, "committer": {"name": "Takayuki Nakata", "email": "f.seasons017@gmail.com", "date": "2020-08-05T14:00:03Z"}, "message": "Just check if it contains `_` in `for pat`", "tree": {"sha": "9a1440801cfa9d44b99e9de188c14cc404f692de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a1440801cfa9d44b99e9de188c14cc404f692de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e48685edef9889d7c0ae391cf050f878d228ae25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e48685edef9889d7c0ae391cf050f878d228ae25", "html_url": "https://github.com/rust-lang/rust/commit/e48685edef9889d7c0ae391cf050f878d228ae25", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e48685edef9889d7c0ae391cf050f878d228ae25/comments", "author": {"login": "giraffate", "id": 17407489, "node_id": "MDQ6VXNlcjE3NDA3NDg5", "avatar_url": "https://avatars.githubusercontent.com/u/17407489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/giraffate", "html_url": "https://github.com/giraffate", "followers_url": "https://api.github.com/users/giraffate/followers", "following_url": "https://api.github.com/users/giraffate/following{/other_user}", "gists_url": "https://api.github.com/users/giraffate/gists{/gist_id}", "starred_url": "https://api.github.com/users/giraffate/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/giraffate/subscriptions", "organizations_url": "https://api.github.com/users/giraffate/orgs", "repos_url": "https://api.github.com/users/giraffate/repos", "events_url": "https://api.github.com/users/giraffate/events{/privacy}", "received_events_url": "https://api.github.com/users/giraffate/received_events", "type": "User", "site_admin": false}, "committer": {"login": "giraffate", "id": 17407489, "node_id": "MDQ6VXNlcjE3NDA3NDg5", "avatar_url": "https://avatars.githubusercontent.com/u/17407489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/giraffate", "html_url": "https://github.com/giraffate", "followers_url": "https://api.github.com/users/giraffate/followers", "following_url": "https://api.github.com/users/giraffate/following{/other_user}", "gists_url": "https://api.github.com/users/giraffate/gists{/gist_id}", "starred_url": "https://api.github.com/users/giraffate/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/giraffate/subscriptions", "organizations_url": "https://api.github.com/users/giraffate/orgs", "repos_url": "https://api.github.com/users/giraffate/repos", "events_url": "https://api.github.com/users/giraffate/events{/privacy}", "received_events_url": "https://api.github.com/users/giraffate/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "228f668282daab05ec20adbbdeb227e923d10864", "url": "https://api.github.com/repos/rust-lang/rust/commits/228f668282daab05ec20adbbdeb227e923d10864", "html_url": "https://github.com/rust-lang/rust/commit/228f668282daab05ec20adbbdeb227e923d10864"}], "stats": {"total": 87, "additions": 1, "deletions": 86}, "files": [{"sha": "3104f0c137e891084f08efb18a9fff75d1043bb8", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 1, "deletions": 86, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e48685edef9889d7c0ae391cf050f878d228ae25/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e48685edef9889d7c0ae391cf050f878d228ae25/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=e48685edef9889d7c0ae391cf050f878d228ae25", "patch": "@@ -1052,82 +1052,6 @@ fn detect_manual_memcpy<'tcx>(\n     }\n }\n \n-// Scans for the usage of the for loop pattern\n-struct ForPatternVisitor<'a, 'tcx> {\n-    found_pattern: bool,\n-    // Pattern that we are searching for\n-    for_pattern: &'a Pat<'tcx>,\n-    cx: &'a LateContext<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for ForPatternVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        // Recursively explore an expression until a ExprKind::Path is found\n-        match &expr.kind {\n-            ExprKind::Array(expr_list) | ExprKind::MethodCall(_, _, expr_list, _) | ExprKind::Tup(expr_list) => {\n-                for expr in *expr_list {\n-                    self.visit_expr(expr)\n-                }\n-            },\n-            ExprKind::Binary(_, lhs_expr, rhs_expr) => {\n-                self.visit_expr(lhs_expr);\n-                self.visit_expr(rhs_expr);\n-            },\n-            ExprKind::Box(expr)\n-            | ExprKind::Unary(_, expr)\n-            | ExprKind::Cast(expr, _)\n-            | ExprKind::Type(expr, _)\n-            | ExprKind::AddrOf(_, _, expr)\n-            | ExprKind::Field(expr, _)\n-            | ExprKind::Struct(_, _, Some(expr)) => self.visit_expr(expr),\n-            _ => {\n-                // Exploration cannot continue ... calculate the hir_id of the current\n-                // expr assuming it is a Path\n-                if let Some(hir_id) = var_def_id(self.cx, &expr) {\n-                    // Pattern is found\n-                    if hir_id == self.for_pattern.hir_id {\n-                        self.found_pattern = true;\n-                    }\n-                    // If the for loop pattern is a tuple, determine whether the current\n-                    // expr is inside that tuple pattern\n-                    if let PatKind::Tuple(pat_list, _) = &self.for_pattern.kind {\n-                        let hir_id_list: Vec<HirId> = pat_list.iter().map(|p| p.hir_id).collect();\n-                        if hir_id_list.contains(&hir_id) {\n-                            self.found_pattern = true;\n-                        }\n-                    }\n-                }\n-            },\n-        }\n-    }\n-\n-    // This is triggered by walk_expr() for the case of vec.push(pat)\n-    fn visit_qpath(&mut self, qpath: &'tcx QPath<'_>, _: HirId, _: Span) {\n-        if_chain! {\n-            if let QPath::Resolved(_, path) = qpath;\n-            if let Res::Local(hir_id) = &path.res;\n-            then {\n-                if *hir_id == self.for_pattern.hir_id{\n-                    self.found_pattern = true;\n-                }\n-\n-                if let PatKind::Tuple(pat_list, _) = &self.for_pattern.kind {\n-                    let hir_id_list: Vec<HirId> = pat_list.iter().map(|p| p.hir_id).collect();\n-                    if hir_id_list.contains(&hir_id) {\n-                        self.found_pattern = true;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-}\n-\n // Scans the body of the for loop and determines whether lint should be given\n struct SameItemPushVisitor<'a, 'tcx> {\n     should_lint: bool,\n@@ -1218,16 +1142,7 @@ fn detect_same_item_push<'tcx>(\n         if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push {\n             // Make sure that the push does not involve possibly mutating values\n             if mutated_variables(pushed_item, cx).map_or(false, |mutvars| mutvars.is_empty()) {\n-                // Walk through the expression being pushed and make sure that it\n-                // does not contain the for loop pattern\n-                let mut for_pat_visitor = ForPatternVisitor {\n-                    found_pattern: false,\n-                    for_pattern: pat,\n-                    cx,\n-                };\n-                walk_expr(&mut for_pat_visitor, pushed_item);\n-\n-                if !for_pat_visitor.found_pattern {\n+                if let PatKind::Wild = pat.kind {\n                     let vec_str = snippet_with_macro_callsite(cx, vec.span, \"\");\n                     let item_str = snippet_with_macro_callsite(cx, pushed_item.span, \"\");\n "}]}