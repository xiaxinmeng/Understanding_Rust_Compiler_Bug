{"sha": "1eca34de7dd55719cd83153994e5caf2027f62a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlY2EzNGRlN2RkNTU3MTljZDgzMTUzOTk0ZTVjYWYyMDI3ZjYyYTI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-20T22:17:12Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-11-26T16:23:57Z"}, "message": "libstd: Remove all non-`proc` uses of `do` from libstd", "tree": {"sha": "14ba2903a9ead6e569d08a33c9ebfc2c6ba07e9e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14ba2903a9ead6e569d08a33c9ebfc2c6ba07e9e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1eca34de7dd55719cd83153994e5caf2027f62a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1eca34de7dd55719cd83153994e5caf2027f62a2", "html_url": "https://github.com/rust-lang/rust/commit/1eca34de7dd55719cd83153994e5caf2027f62a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1eca34de7dd55719cd83153994e5caf2027f62a2/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6801bc8f552ce740deb60212903ba43de197689c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6801bc8f552ce740deb60212903ba43de197689c", "html_url": "https://github.com/rust-lang/rust/commit/6801bc8f552ce740deb60212903ba43de197689c"}], "stats": {"total": 1617, "additions": 722, "deletions": 895}, "files": [{"sha": "18b6a1ef52a00da0bc94438095a2a9d2e378ad9e", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -290,7 +290,7 @@ impl<'self> AsciiStr for &'self [Ascii] {\n \n     #[inline]\n     fn eq_ignore_case(self, other: &[Ascii]) -> bool {\n-        do self.iter().zip(other.iter()).all |(&a, &b)| { a.eq_ignore_case(b) }\n+        self.iter().zip(other.iter()).all(|(&a, &b)| a.eq_ignore_case(b))\n     }\n }\n "}, {"sha": "4405d5be3886b2db733adaf9668d984206134fa3", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 23, "deletions": 37, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -56,24 +56,24 @@ pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> @[A] {\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline]\n pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n-    do build(Some(lhs.len() + rhs.len())) |push| {\n+    build(Some(lhs.len() + rhs.len()), |push| {\n         for x in lhs.iter() {\n             push((*x).clone());\n         }\n         for elt in rhs.iter() {\n             push(elt.clone());\n         }\n-    }\n+    })\n }\n \n \n /// Apply a function to each element of a vector and return the results\n pub fn map<T, U>(v: &[T], f: |x: &T| -> U) -> @[U] {\n-    do build(Some(v.len())) |push| {\n+    build(Some(v.len()), |push| {\n         for elem in v.iter() {\n             push(f(elem));\n         }\n-    }\n+    })\n }\n \n /**\n@@ -83,10 +83,10 @@ pub fn map<T, U>(v: &[T], f: |x: &T| -> U) -> @[U] {\n  * to the value returned by the function `op`.\n  */\n pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> @[T] {\n-    do build(Some(n_elts)) |push| {\n+    build(Some(n_elts), |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n-    }\n+    })\n }\n \n /**\n@@ -96,13 +96,13 @@ pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> @[T] {\n  * to the value `t`.\n  */\n pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> @[T] {\n-    do build(Some(n_elts)) |push| {\n+    build(Some(n_elts), |push| {\n         let mut i: uint = 0u;\n         while i < n_elts {\n             push(t.clone());\n             i += 1u;\n         }\n-    }\n+    })\n }\n \n /**\n@@ -137,11 +137,11 @@ impl<T> Clone for @[T] {\n impl<A> FromIterator<A> for @[A] {\n     fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> @[A] {\n         let (lower, _) = iterator.size_hint();\n-        do build(Some(lower)) |push| {\n+        build(Some(lower), |push| {\n             for x in *iterator {\n                 push(x);\n             }\n-        }\n+        })\n     }\n }\n \n@@ -259,9 +259,9 @@ pub mod raw {\n             use rt::local::Local;\n             use rt::task::Task;\n \n-            do Local::borrow |task: &mut Task| {\n+            Local::borrow(|task: &mut Task| {\n                 task.heap.realloc(ptr as *mut Box<()>, size) as *()\n-            }\n+            })\n         }\n     }\n \n@@ -295,11 +295,11 @@ mod test {\n     fn test() {\n         // Some code that could use that, then:\n         fn seq_range(lo: uint, hi: uint) -> @[uint] {\n-            do build(None) |push| {\n+            build(None, |push| {\n                 for i in range(lo, hi) {\n                     push(i);\n                 }\n-            }\n+            })\n         }\n \n         assert_eq!(seq_range(10, 15), @[10, 11, 12, 13, 14]);\n@@ -333,9 +333,7 @@ mod test {\n     #[bench]\n     fn bench_capacity(b: &mut bh) {\n         let x = @[1, 2, 3];\n-        do b.iter {\n-            capacity(x);\n-        }\n+        b.iter(|| capacity(x));\n     }\n \n     #[bench]\n@@ -359,54 +357,42 @@ mod test {\n     fn bench_append(b: &mut bh) {\n         let lhs = @[7, ..128];\n         let rhs = range(0, 256).to_owned_vec();\n-        do b.iter {\n-            append(lhs, rhs);\n-        }\n+        b.iter(|| append(lhs, rhs))\n     }\n \n     #[bench]\n     fn bench_map(b: &mut bh) {\n         let elts = range(0, 256).to_owned_vec();\n-        do b.iter {\n-            map(elts, |x| x*2);\n-        }\n+        b.iter(|| map(elts, |x| x*2))\n     }\n \n     #[bench]\n     fn bench_from_fn(b: &mut bh) {\n-        do b.iter {\n-            from_fn(1024, |x| x);\n-        }\n+        b.iter(|| from_fn(1024, |x| x));\n     }\n \n     #[bench]\n     fn bench_from_elem(b: &mut bh) {\n-        do b.iter {\n-            from_elem(1024, 0u64);\n-        }\n+        b.iter(|| from_elem(1024, 0u64));\n     }\n \n     #[bench]\n     fn bench_to_managed_move(b: &mut bh) {\n-        do b.iter {\n+        b.iter(|| {\n             let elts = range(0, 1024).to_owned_vec(); // yikes! can't move out of capture, though\n             to_managed_move(elts);\n-        }\n+        })\n     }\n \n     #[bench]\n     fn bench_to_managed(b: &mut bh) {\n         let elts = range(0, 1024).to_owned_vec();\n-        do b.iter {\n-            to_managed(elts);\n-        }\n+        b.iter(|| to_managed(elts));\n     }\n \n     #[bench]\n     fn bench_clone(b: &mut bh) {\n         let elts = to_managed(range(0, 1024).to_owned_vec());\n-        do b.iter {\n-            elts.clone();\n-        }\n+        b.iter(|| elts.clone());\n     }\n }"}, {"sha": "306ee331929bb70bc95eb1e47b40ab8a8b552938", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 42, "deletions": 54, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -49,15 +49,15 @@ let my_string = \"Hello, world!\";\n // Allocate the C string with an explicit local that owns the string. The\n // `c_buffer` pointer will be deallocated when `my_c_string` goes out of scope.\n let my_c_string = my_string.to_c_str();\n-do my_c_string.with_ref |c_buffer| {\n+my_c_string.with_ref(|c_buffer| {\n     unsafe { puts(c_buffer); }\n-}\n+})\n \n // Don't save off the allocation of the C string, the `c_buffer` will be\n // deallocated when this block returns!\n-do my_string.with_c_str |c_buffer| {\n+my_string.with_c_str(|c_buffer| {\n     unsafe { puts(c_buffer); }\n-}\n+})\n  ```\n \n */\n@@ -262,14 +262,12 @@ static BUF_LEN: uint = 128;\n impl<'self> ToCStr for &'self [u8] {\n     fn to_c_str(&self) -> CString {\n         let mut cs = unsafe { self.to_c_str_unchecked() };\n-        do cs.with_mut_ref |buf| {\n-            check_for_null(*self, buf);\n-        }\n+        cs.with_mut_ref(|buf| check_for_null(*self, buf));\n         cs\n     }\n \n     unsafe fn to_c_str_unchecked(&self) -> CString {\n-        do self.as_imm_buf |self_buf, self_len| {\n+        self.as_imm_buf(|self_buf, self_len| {\n             let buf = libc::malloc(self_len as libc::size_t + 1) as *mut u8;\n             if buf.is_null() {\n                 fail!(\"failed to allocate memory!\");\n@@ -279,7 +277,7 @@ impl<'self> ToCStr for &'self [u8] {\n             *ptr::mut_offset(buf, self_len as int) = 0;\n \n             CString::new(buf as *libc::c_char, true)\n-        }\n+        })\n     }\n \n     fn with_c_str<T>(&self, f: |*libc::c_char| -> T) -> T {\n@@ -298,13 +296,13 @@ unsafe fn with_c_str<T>(v: &[u8], checked: bool, f: |*libc::c_char| -> T) -> T {\n         vec::bytes::copy_memory(buf, v, v.len());\n         buf[v.len()] = 0;\n \n-        do buf.as_mut_buf |buf, _| {\n+        buf.as_mut_buf(|buf, _| {\n             if checked {\n                 check_for_null(v, buf as *mut libc::c_char);\n             }\n \n             f(buf as *libc::c_char)\n-        }\n+        })\n     } else if checked {\n         v.to_c_str().with_ref(f)\n     } else {\n@@ -390,24 +388,24 @@ mod tests {\n             let ptr = vec::raw::to_ptr(input);\n             let expected = [\"zero\", \"one\"];\n             let mut it = expected.iter();\n-            let result = do from_c_multistring(ptr as *libc::c_char, None) |c| {\n+            let result = from_c_multistring(ptr as *libc::c_char, None, |c| {\n                 let cbytes = c.as_bytes().slice_to(c.len());\n                 assert_eq!(cbytes, it.next().unwrap().as_bytes());\n-            };\n+            });\n             assert_eq!(result, 2);\n             assert!(it.next().is_none());\n         }\n     }\n \n     #[test]\n     fn test_str_to_c_str() {\n-        do \"\".to_c_str().with_ref |buf| {\n+        \"\".to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 0);\n             }\n-        }\n+        });\n \n-        do \"hello\".to_c_str().with_ref |buf| {\n+        \"hello\".to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n@@ -416,19 +414,19 @@ mod tests {\n                 assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 5), 0);\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn test_vec_to_c_str() {\n         let b: &[u8] = [];\n-        do b.to_c_str().with_ref |buf| {\n+        b.to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 0);\n             }\n-        }\n+        });\n \n-        do bytes!(\"hello\").to_c_str().with_ref |buf| {\n+        let _ = bytes!(\"hello\").to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 'h' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 1), 'e' as libc::c_char);\n@@ -437,17 +435,17 @@ mod tests {\n                 assert_eq!(*ptr::offset(buf, 4), 'o' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 5), 0);\n             }\n-        }\n+        });\n \n-        do bytes!(\"foo\", 0xff).to_c_str().with_ref |buf| {\n+        let _ = bytes!(\"foo\", 0xff).to_c_str().with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 'f' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 1), 'o' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 2), 'o' as libc::c_char);\n                 assert_eq!(*ptr::offset(buf, 3), 0xff);\n                 assert_eq!(*ptr::offset(buf, 4), 0);\n             }\n-        }\n+        });\n     }\n \n     #[test]\n@@ -500,18 +498,16 @@ mod tests {\n         use c_str::null_byte::cond;\n \n         let mut error_happened = false;\n-        do cond.trap(|err| {\n+        cond.trap(|err| {\n             assert_eq!(err, bytes!(\"he\", 0, \"llo\").to_owned())\n             error_happened = true;\n             Truncate\n-        }).inside {\n-            \"he\\x00llo\".to_c_str()\n-        };\n+        }).inside(|| \"he\\x00llo\".to_c_str());\n         assert!(error_happened);\n \n-        do cond.trap(|_| {\n+        cond.trap(|_| {\n             ReplaceWith('?' as libc::c_char)\n-        }).inside(|| \"he\\x00llo\".to_c_str()).with_ref |buf| {\n+        }).inside(|| \"he\\x00llo\".to_c_str()).with_ref(|buf| {\n             unsafe {\n                 assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n                 assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n@@ -521,21 +517,21 @@ mod tests {\n                 assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n                 assert_eq!(*buf.offset(6), 0);\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn test_to_c_str_unchecked() {\n         unsafe {\n-            do \"he\\x00llo\".to_c_str_unchecked().with_ref |buf| {\n+            \"he\\x00llo\".to_c_str_unchecked().with_ref(|buf| {\n                 assert_eq!(*buf.offset(0), 'h' as libc::c_char);\n                 assert_eq!(*buf.offset(1), 'e' as libc::c_char);\n                 assert_eq!(*buf.offset(2), 0);\n                 assert_eq!(*buf.offset(3), 'l' as libc::c_char);\n                 assert_eq!(*buf.offset(4), 'l' as libc::c_char);\n                 assert_eq!(*buf.offset(5), 'o' as libc::c_char);\n                 assert_eq!(*buf.offset(6), 0);\n-            }\n+            })\n         }\n     }\n \n@@ -579,15 +575,15 @@ mod bench {\n \n     #[inline]\n     fn check(s: &str, c_str: *libc::c_char) {\n-        do s.as_imm_buf |s_buf, s_len| {\n+        s.as_imm_buf(|s_buf, s_len| {\n             for i in range(0, s_len) {\n                 unsafe {\n                     assert_eq!(\n                         *ptr::offset(s_buf, i as int) as libc::c_char,\n                         *ptr::offset(c_str, i as int));\n                 }\n             }\n-        }\n+        })\n     }\n \n     static s_short: &'static str = \"Mary\";\n@@ -601,12 +597,10 @@ mod bench {\n         Mary had a little lamb, Little lamb\";\n \n     fn bench_to_str(bh: &mut BenchHarness, s: &str) {\n-        do bh.iter {\n+        bh.iter(|| {\n             let c_str = s.to_c_str();\n-            do c_str.with_ref |c_str_buf| {\n-                check(s, c_str_buf)\n-            }\n-        }\n+            c_str.with_ref(|c_str_buf| check(s, c_str_buf))\n+        })\n     }\n \n     #[bench]\n@@ -625,12 +619,10 @@ mod bench {\n     }\n \n     fn bench_to_c_str_unchecked(bh: &mut BenchHarness, s: &str) {\n-        do bh.iter {\n+        bh.iter(|| {\n             let c_str = unsafe { s.to_c_str_unchecked() };\n-            do c_str.with_ref |c_str_buf| {\n-                check(s, c_str_buf)\n-            }\n-        }\n+            c_str.with_ref(|c_str_buf| check(s, c_str_buf))\n+        })\n     }\n \n     #[bench]\n@@ -649,11 +641,9 @@ mod bench {\n     }\n \n     fn bench_with_c_str(bh: &mut BenchHarness, s: &str) {\n-        do bh.iter {\n-            do s.with_c_str |c_str_buf| {\n-                check(s, c_str_buf)\n-            }\n-        }\n+        bh.iter(|| {\n+            s.with_c_str(|c_str_buf| check(s, c_str_buf))\n+        })\n     }\n \n     #[bench]\n@@ -672,13 +662,11 @@ mod bench {\n     }\n \n     fn bench_with_c_str_unchecked(bh: &mut BenchHarness, s: &str) {\n-        do bh.iter {\n+        bh.iter(|| {\n             unsafe {\n-                do s.with_c_str_unchecked |c_str_buf| {\n-                    check(s, c_str_buf)\n-                }\n+                s.with_c_str_unchecked(|c_str_buf| check(s, c_str_buf))\n             }\n-        }\n+        })\n     }\n \n     #[bench]"}, {"sha": "634558b9b971dcc769b653016330bf62fb4d21c8", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -82,6 +82,7 @@ pub struct RefCell<T> {\n     priv nc: NonCopyable\n }\n \n+<<<<<<< HEAD\n // Values [1, MAX-1] represent the number of `Ref` active\n // (will not outgrow its range since `uint` is the size of the address space)\n type BorrowFlag = uint;"}, {"sha": "7c972ed86b4ddbc37feb3ecefd18d006db142176", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -82,45 +82,45 @@ pub unsafe fn annihilate() {\n     //\n     // In this pass, nothing gets freed, so it does not matter whether\n     // we read the next field before or after the callback.\n-    do each_live_alloc(true) |box, uniq| {\n+    each_live_alloc(true, |box, uniq| {\n         stats.n_total_boxes += 1;\n         if uniq {\n             stats.n_unique_boxes += 1;\n         } else {\n             (*box).ref_count = managed::RC_IMMORTAL;\n         }\n         true\n-    };\n+    });\n \n     // Pass 2: Drop all boxes.\n     //\n     // In this pass, unique-managed boxes may get freed, but not\n     // managed boxes, so we must read the `next` field *after* the\n     // callback, as the original value may have been freed.\n-    do each_live_alloc(false) |box, uniq| {\n+    each_live_alloc(false, |box, uniq| {\n         if !uniq {\n             let tydesc = (*box).type_desc;\n             let data = &(*box).data as *();\n             ((*tydesc).drop_glue)(data as *i8);\n         }\n         true\n-    };\n+    });\n \n     // Pass 3: Free all boxes.\n     //\n     // In this pass, managed boxes may get freed (but not\n     // unique-managed boxes, though I think that none of those are\n     // left), so we must read the `next` field before, since it will\n     // not be valid after.\n-    do each_live_alloc(true) |box, uniq| {\n+    each_live_alloc(true, |box, uniq| {\n         if !uniq {\n             stats.n_bytes_freed +=\n                 (*((*box).type_desc)).size\n                 + mem::size_of::<raw::Box<()>>();\n             local_free(box as *i8);\n         }\n         true\n-    };\n+    });\n \n     if debug_mem() {\n         // We do logging here w/o allocation."}, {"sha": "6d152d8c179a818fce9a97f9217d754c37790f56", "filename": "src/libstd/either.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Feither.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -209,23 +209,23 @@ pub type Rights<L, R, Iter> = FilterMap<'static, Either<L, R>, R, Iter>;\n /// Extracts all the left values\n pub fn lefts<L, R, Iter: Iterator<Either<L, R>>>(eithers: Iter)\n     -> Lefts<L, R, Iter> {\n-    do eithers.filter_map |elt| {\n+    eithers.filter_map(|elt| {\n         match elt {\n             Left(x) => Some(x),\n             _ => None,\n         }\n-    }\n+    })\n }\n \n /// Extracts all the right values\n pub fn rights<L, R, Iter: Iterator<Either<L, R>>>(eithers: Iter)\n     -> Rights<L, R, Iter> {\n-    do eithers.filter_map |elt| {\n+    eithers.filter_map(|elt| {\n         match elt {\n             Right(x) => Some(x),\n             _ => None,\n         }\n-    }\n+    })\n }\n \n "}, {"sha": "33ef4731405fa7d76719c6b462c8aebaf5b0d8ba", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -801,12 +801,12 @@ impl<'self> Formatter<'self> {\n     }\n \n     fn runplural(&mut self, value: uint, pieces: &[rt::Piece]) {\n-        do ::uint::to_str_bytes(value, 10) |buf| {\n+        ::uint::to_str_bytes(value, 10, |buf| {\n             let valuestr = str::from_utf8_slice(buf);\n             for piece in pieces.iter() {\n                 self.run(piece, Some(valuestr));\n             }\n-        }\n+        })\n     }\n \n     // Helper methods used for padding and processing formatting arguments that\n@@ -868,9 +868,9 @@ impl<'self> Formatter<'self> {\n                     self.fill = '0';\n                     sign(self);\n                 }\n-                do self.with_padding(min - actual_len, parse::AlignRight) |me| {\n+                self.with_padding(min - actual_len, parse::AlignRight, |me| {\n                     emit(me);\n-                }\n+                })\n             }\n         }\n     }\n@@ -924,9 +924,9 @@ impl<'self> Formatter<'self> {\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n-                do self.with_padding(width - s.len(), parse::AlignLeft) |me| {\n+                self.with_padding(width - s.len(), parse::AlignLeft, |me| {\n                     me.buf.write(s.as_bytes());\n-                }\n+                })\n             }\n         }\n     }\n@@ -1007,18 +1007,18 @@ macro_rules! int_base(($ty:ident, $into:ident, $base:expr,\n                        $name:ident, $prefix:expr) => {\n     impl $name for $ty {\n         fn fmt(c: &$ty, f: &mut Formatter) {\n-            do ::$into::to_str_bytes(*c as $into, $base) |buf| {\n+            ::$into::to_str_bytes(*c as $into, $base, |buf| {\n                 f.pad_integral(buf, $prefix, true);\n-            }\n+            })\n         }\n     }\n })\n macro_rules! upper_hex(($ty:ident, $into:ident) => {\n     impl UpperHex for $ty {\n         fn fmt(c: &$ty, f: &mut Formatter) {\n-            do ::$into::to_str_bytes(*c as $into, 16) |buf| {\n+            ::$into::to_str_bytes(*c as $into, 16, |buf| {\n                 upperhex(buf, f);\n-            }\n+            })\n         }\n     }\n })\n@@ -1045,9 +1045,9 @@ macro_rules! integer(($signed:ident, $unsigned:ident) => {\n         // nothing else should do that, however.\n         impl Signed for $signed {\n             fn fmt(c: &$signed, f: &mut Formatter) {\n-                do ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10) |buf| {\n+                ::$unsigned::to_str_bytes(c.abs() as $unsigned, 10, |buf| {\n                     f.pad_integral(buf, \"\", *c >= 0);\n-                }\n+                })\n             }\n         }\n         int_base!($signed, $unsigned, 2, Binary, \"0b\")\n@@ -1104,9 +1104,9 @@ impl<T> Poly for T {\n impl<T> Pointer for *T {\n     fn fmt(t: &*T, f: &mut Formatter) {\n         f.flags |= 1 << (parse::FlagAlternate as uint);\n-        do ::uint::to_str_bytes(*t as uint, 16) |buf| {\n+        ::uint::to_str_bytes(*t as uint, 16, |buf| {\n             f.pad_integral(buf, \"0x\", true);\n-        }\n+        })\n     }\n }\n impl<T> Pointer for *mut T {"}, {"sha": "5a671eea7a34851f1dfd99047ee6d882af52513f", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -83,44 +83,44 @@ impl<A:IterBytes> Hash for A {\n     #[inline]\n     fn hash_keyed(&self, k0: u64, k1: u64) -> u64 {\n         let mut s = State::new(k0, k1);\n-        do self.iter_bytes(true) |bytes| {\n+        self.iter_bytes(true, |bytes| {\n             s.input(bytes);\n             true\n-        };\n+        });\n         s.result_u64()\n     }\n }\n \n fn hash_keyed_2<A: IterBytes,\n                 B: IterBytes>(a: &A, b: &B, k0: u64, k1: u64) -> u64 {\n     let mut s = State::new(k0, k1);\n-    do a.iter_bytes(true) |bytes| {\n+    a.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do b.iter_bytes(true) |bytes| {\n+    });\n+    b.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n+    });\n     s.result_u64()\n }\n \n fn hash_keyed_3<A: IterBytes,\n                 B: IterBytes,\n                 C: IterBytes>(a: &A, b: &B, c: &C, k0: u64, k1: u64) -> u64 {\n     let mut s = State::new(k0, k1);\n-    do a.iter_bytes(true) |bytes| {\n+    a.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do b.iter_bytes(true) |bytes| {\n+    });\n+    b.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do c.iter_bytes(true) |bytes| {\n+    });\n+    c.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n+    });\n     s.result_u64()\n }\n \n@@ -136,22 +136,22 @@ fn hash_keyed_4<A: IterBytes,\n                 k1: u64)\n                 -> u64 {\n     let mut s = State::new(k0, k1);\n-    do a.iter_bytes(true) |bytes| {\n+    a.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do b.iter_bytes(true) |bytes| {\n+    });\n+    b.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do c.iter_bytes(true) |bytes| {\n+    });\n+    c.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do d.iter_bytes(true) |bytes| {\n+    });\n+    d.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n+    });\n     s.result_u64()\n }\n \n@@ -169,26 +169,26 @@ fn hash_keyed_5<A: IterBytes,\n                 k1: u64)\n                 -> u64 {\n     let mut s = State::new(k0, k1);\n-    do a.iter_bytes(true) |bytes| {\n+    a.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do b.iter_bytes(true) |bytes| {\n+    });\n+    b.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do c.iter_bytes(true) |bytes| {\n+    });\n+    c.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do d.iter_bytes(true) |bytes| {\n+    });\n+    d.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n-    do e.iter_bytes(true) |bytes| {\n+    });\n+    e.iter_bytes(true, |bytes| {\n         s.input(bytes);\n         true\n-    };\n+    });\n     s.result_u64()\n }\n "}, {"sha": "a61871cbb5e277efca3e4a10ff55ada72c1fb408", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -110,15 +110,15 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                 k: &K)\n                              -> SearchResult {\n         let mut ret = TableFull;\n-        do self.bucket_sequence(hash) |i| {\n+        self.bucket_sequence(hash, |i| {\n             match self.buckets[i] {\n                 Some(ref bkt) if bkt.hash == hash && *k == bkt.key => {\n                     ret = FoundEntry(i); false\n                 },\n                 None => { ret = FoundHole(i); false }\n                 _ => true,\n             }\n-        };\n+        });\n         ret\n     }\n \n@@ -128,15 +128,15 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n                                                   k: &Q)\n                                                -> SearchResult {\n         let mut ret = TableFull;\n-        do self.bucket_sequence(hash) |i| {\n+        self.bucket_sequence(hash, |i| {\n             match self.buckets[i] {\n                 Some(ref bkt) if bkt.hash == hash && k.equiv(&bkt.key) => {\n                     ret = FoundEntry(i); false\n                 },\n                 None => { ret = FoundHole(i); false }\n                 _ => true,\n             }\n-        };\n+        });\n         ret\n     }\n \n@@ -236,9 +236,7 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n         let len_buckets = self.buckets.len();\n         let bucket = self.buckets[idx].take();\n \n-        let value = do bucket.map |bucket| {\n-            bucket.value\n-        };\n+        let value = bucket.map(|bucket| bucket.value);\n \n         /* re-inserting buckets may cause changes in size, so remember\n         what our new size is ahead of time before we start insertions */\n@@ -500,12 +498,12 @@ impl<K:Hash + Eq,V:Eq> Eq for HashMap<K, V> {\n     fn eq(&self, other: &HashMap<K, V>) -> bool {\n         if self.len() != other.len() { return false; }\n \n-        do self.iter().all |(key, value)| {\n+        self.iter().all(|(key, value)| {\n             match other.find(key) {\n                 None => false,\n                 Some(v) => value == v\n             }\n-        }\n+        })\n     }\n \n     fn ne(&self, other: &HashMap<K, V>) -> bool { !self.eq(other) }"}, {"sha": "d1502df047e704ffa23d677fe120ce76eff1f563", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 25, "deletions": 43, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -76,15 +76,15 @@ pub struct File {\n }\n \n fn io_raise<T>(f: |io: &mut IoFactory| -> Result<T, IoError>) -> Option<T> {\n-    do with_local_io |io| {\n+    with_local_io(|io| {\n         match f(io) {\n             Ok(t) => Some(t),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n                 None\n             }\n         }\n-    }\n+    })\n }\n \n impl File {\n@@ -97,17 +97,17 @@ impl File {\n     ///\n     ///     let p = Path::new(\"/some/file/path.txt\");\n     ///\n-    ///     do io_error::cond.trap(|_| {\n+    ///     io_error::cond.trap(|_| {\n     ///         // hoo-boy...\n-    ///     }).inside {\n+    ///     }).inside(|| {\n     ///         let file = match File::open_mode(&p, Open, ReadWrite) {\n     ///             Some(s) => s,\n     ///             None => fail!(\"whoops! I'm sure this raised, anyways..\")\n     ///         };\n     ///         // do some stuff with that file\n     ///\n     ///         // the file will be closed at the end of this block\n-    ///     }\n+    ///     })\n     ///     // ..\n     ///\n     /// `FileMode` and `FileAccess` provide information about the permissions\n@@ -132,7 +132,7 @@ impl File {\n     pub fn open_mode(path: &Path,\n                      mode: FileMode,\n                      access: FileAccess) -> Option<File> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.fs_open(&path.to_c_str(), mode, access) {\n                 Ok(fd) => Some(File {\n                     path: path.clone(),\n@@ -144,7 +144,7 @@ impl File {\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     /// Attempts to open a file in read-only mode. This function is equivalent to\n@@ -244,7 +244,7 @@ impl File {\n /// directory, the user lacks permissions to remove the file, or if some\n /// other filesystem-level error occurs.\n pub fn unlink(path: &Path) {\n-    do io_raise |io| { io.fs_unlink(&path.to_c_str()) };\n+    io_raise(|io| io.fs_unlink(&path.to_c_str()));\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -272,9 +272,7 @@ pub fn unlink(path: &Path) {\n /// requisite permissions to perform a `stat` call on the given path or if\n /// there is no entry in the filesystem at the provided path.\n pub fn stat(path: &Path) -> FileStat {\n-    do io_raise |io| {\n-        io.fs_stat(&path.to_c_str())\n-    }.unwrap_or_else(dummystat)\n+    io_raise(|io| io.fs_stat(&path.to_c_str())).unwrap_or_else(dummystat)\n }\n \n fn dummystat() -> FileStat {\n@@ -310,9 +308,7 @@ fn dummystat() -> FileStat {\n ///\n /// See `stat`\n pub fn lstat(path: &Path) -> FileStat {\n-    do io_raise |io| {\n-        io.fs_lstat(&path.to_c_str())\n-    }.unwrap_or_else(dummystat)\n+    io_raise(|io| io.fs_lstat(&path.to_c_str())).unwrap_or_else(dummystat)\n }\n \n /// Rename a file or directory to a new name.\n@@ -330,9 +326,7 @@ pub fn lstat(path: &Path) -> FileStat {\n /// the process lacks permissions to view the contents, or if some other\n /// intermittent I/O error occurs.\n pub fn rename(from: &Path, to: &Path) {\n-    do io_raise |io| {\n-        io.fs_rename(&from.to_c_str(), &to.to_c_str())\n-    };\n+    io_raise(|io| io.fs_rename(&from.to_c_str(), &to.to_c_str()));\n }\n \n /// Copies the contents of one file to another. This function will also\n@@ -403,9 +397,7 @@ pub fn copy(from: &Path, to: &Path) {\n /// condition. Some possible error situations are not having the permission to\n /// change the attributes of a file or the file not existing.\n pub fn chmod(path: &Path, mode: io::FilePermission) {\n-    do io_raise |io| {\n-        io.fs_chmod(&path.to_c_str(), mode)\n-    };\n+    io_raise(|io| io.fs_chmod(&path.to_c_str(), mode));\n }\n \n /// Change the user and group owners of a file at the specified path.\n@@ -414,7 +406,7 @@ pub fn chmod(path: &Path, mode: io::FilePermission) {\n ///\n /// This funtion will raise on the `io_error` condition on failure.\n pub fn chown(path: &Path, uid: int, gid: int) {\n-    do io_raise |io| { io.fs_chown(&path.to_c_str(), uid, gid) };\n+    io_raise(|io| io.fs_chown(&path.to_c_str(), uid, gid));\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n@@ -425,7 +417,7 @@ pub fn chown(path: &Path, uid: int, gid: int) {\n ///\n /// This function will raise on the `io_error` condition on failure.\n pub fn link(src: &Path, dst: &Path) {\n-    do io_raise |io| { io.fs_link(&src.to_c_str(), &dst.to_c_str()) };\n+    io_raise(|io| io.fs_link(&src.to_c_str(), &dst.to_c_str()));\n }\n \n /// Creates a new symbolic link on the filesystem. The `dst` path will be a\n@@ -435,7 +427,7 @@ pub fn link(src: &Path, dst: &Path) {\n ///\n /// This function will raise on the `io_error` condition on failure.\n pub fn symlink(src: &Path, dst: &Path) {\n-    do io_raise |io| { io.fs_symlink(&src.to_c_str(), &dst.to_c_str()) };\n+    io_raise(|io| io.fs_symlink(&src.to_c_str(), &dst.to_c_str()));\n }\n \n /// Reads a symlink, returning the file that the symlink points to.\n@@ -446,7 +438,7 @@ pub fn symlink(src: &Path, dst: &Path) {\n /// conditions include reading a file that does not exist or reading a file\n /// which is not a symlink.\n pub fn readlink(path: &Path) -> Option<Path> {\n-    do io_raise |io| { io.fs_readlink(&path.to_c_str()) }\n+    io_raise(|io| io.fs_readlink(&path.to_c_str()))\n }\n \n /// Create a new, empty directory at the provided path\n@@ -466,9 +458,7 @@ pub fn readlink(path: &Path) -> Option<Path> {\n /// to make a new directory at the provided path, or if the directory already\n /// exists.\n pub fn mkdir(path: &Path, mode: FilePermission) {\n-    do io_raise |io| {\n-        io.fs_mkdir(&path.to_c_str(), mode)\n-    };\n+    io_raise(|io| io.fs_mkdir(&path.to_c_str(), mode));\n }\n \n /// Remove an existing, empty directory\n@@ -487,9 +477,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) {\n /// to remove the directory at the provided path, or if the directory isn't\n /// empty.\n pub fn rmdir(path: &Path) {\n-    do io_raise |io| {\n-        io.fs_rmdir(&path.to_c_str())\n-    };\n+    io_raise(|io| io.fs_rmdir(&path.to_c_str()));\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -516,9 +504,7 @@ pub fn rmdir(path: &Path) {\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n pub fn readdir(path: &Path) -> ~[Path] {\n-    do io_raise |io| {\n-        io.fs_readdir(&path.to_c_str(), 0)\n-    }.unwrap_or_else(|| ~[])\n+    io_raise(|io| io.fs_readdir(&path.to_c_str(), 0)).unwrap_or_else(|| ~[])\n }\n \n /// Returns an iterator which will recursively walk the directory structure\n@@ -599,9 +585,7 @@ pub fn rmdir_recursive(path: &Path) {\n /// happens.\n // FIXME(#10301) these arguments should not be u64\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) {\n-    do io_raise |io| {\n-        io.fs_utime(&path.to_c_str(), atime, mtime)\n-    };\n+    io_raise(|io| io.fs_utime(&path.to_c_str(), atime, mtime));\n }\n \n impl Reader for File {\n@@ -797,24 +781,22 @@ mod test {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n         let mut called = false;\n-        do io_error::cond.trap(|_| {\n+        io_error::cond.trap(|_| {\n             called = true;\n-        }).inside {\n+        }).inside(|| {\n             let result = File::open_mode(filename, Open, Read);\n             assert!(result.is_none());\n-        }\n+        });\n         assert!(called);\n     })\n \n     test!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n         let mut called = false;\n-        do io_error::cond.trap(|_| {\n+        io_error::cond.trap(|_| {\n             called = true;\n-        }).inside {\n-            unlink(filename);\n-        }\n+        }).inside(|| unlink(filename));\n         assert!(called);\n     })\n "}, {"sha": "8cc4e7b389b46075fe4b4010dc9aef7e3fe3a9b4", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -40,9 +40,9 @@ Some examples of obvious things you might want to do\n \n * Iterate over the lines of a file\n \n-    do File::open(\"message.txt\").each_line |line| {\n+    File::open(\"message.txt\").each_line(|line| {\n         println(line)\n-    }\n+    })\n \n * Pull the lines of a file into a vector of strings\n \n@@ -395,13 +395,11 @@ condition! {\n /// Helper for wrapper calls where you want to\n /// ignore any io_errors that might be raised\n pub fn ignore_io_error<T>(cb: || -> T) -> T {\n-    do io_error::cond.trap(|_| {\n+    io_error::cond.trap(|_| {\n         // just swallow the error.. downstream users\n         // who can make a decision based on a None result\n         // won't care\n-    }).inside {\n-        cb()\n-    }\n+    }).inside(|| cb())\n }\n \n /// Helper for catching an I/O error and wrapping it in a Result object. The\n@@ -501,7 +499,7 @@ pub trait Reader {\n             buf.reserve_additional(len);\n             vec::raw::set_len(buf, start_len + len);\n \n-            do (|| {\n+            (|| {\n                 while total_read < len {\n                     let len = buf.len();\n                     let slice = buf.mut_slice(start_len + total_read, len);\n@@ -515,9 +513,7 @@ pub trait Reader {\n                         }\n                     }\n                 }\n-            }).finally {\n-                vec::raw::set_len(buf, start_len + total_read);\n-            }\n+            }).finally(|| vec::raw::set_len(buf, start_len + total_read))\n         }\n     }\n \n@@ -542,17 +538,17 @@ pub trait Reader {\n     fn read_to_end(&mut self) -> ~[u8] {\n         let mut buf = vec::with_capacity(DEFAULT_BUF_SIZE);\n         let mut keep_reading = true;\n-        do io_error::cond.trap(|e| {\n+        io_error::cond.trap(|e| {\n             if e.kind == EndOfFile {\n                 keep_reading = false;\n             } else {\n                 io_error::cond.raise(e)\n             }\n-        }).inside {\n+        }).inside(|| {\n             while keep_reading {\n                 self.push_bytes(&mut buf, DEFAULT_BUF_SIZE)\n             }\n-        }\n+        });\n         return buf;\n     }\n "}, {"sha": "c21326262e4c659e847f33820fb747792fbb26e9", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 38, "deletions": 46, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -37,7 +37,7 @@ fn keep_going(data: &[u8], f: |*u8, uint| -> i64) -> i64 {\n     #[cfg(windows)] static eintr: int = 0; // doesn't matter\n     #[cfg(not(windows))] static eintr: int = libc::EINTR as int;\n \n-    let (data, origamt) = do data.as_imm_buf |data, amt| { (data, amt) };\n+    let (data, origamt) = data.as_imm_buf(|data, amt| (data, amt));\n     let mut data = data;\n     let mut amt = origamt;\n     while amt > 0 {\n@@ -83,11 +83,11 @@ impl FileDesc {\n     fn inner_read(&mut self, buf: &mut [u8]) -> Result<uint, IoError> {\n         #[cfg(windows)] type rlen = libc::c_uint;\n         #[cfg(not(windows))] type rlen = libc::size_t;\n-        let ret = do keep_going(buf) |buf, len| {\n+        let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::read(self.fd, buf as *mut libc::c_void, len as rlen) as i64\n             }\n-        };\n+        });\n         if ret == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else if ret < 0 {\n@@ -99,11 +99,11 @@ impl FileDesc {\n     fn inner_write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n         #[cfg(windows)] type wlen = libc::c_uint;\n         #[cfg(not(windows))] type wlen = libc::size_t;\n-        let ret = do keep_going(buf) |buf, len| {\n+        let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::write(self.fd, buf as *libc::c_void, len as wlen) as i64\n             }\n-        };\n+        });\n         if ret < 0 {\n             Err(super::last_error())\n         } else {\n@@ -344,12 +344,12 @@ impl CFile {\n \n impl rtio::RtioFileStream for CFile {\n     fn read(&mut self, buf: &mut [u8]) -> Result<int, IoError> {\n-        let ret = do keep_going(buf) |buf, len| {\n+        let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::fread(buf as *mut libc::c_void, 1, len as libc::size_t,\n                             self.file) as i64\n             }\n-        };\n+        });\n         if ret == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else if ret < 0 {\n@@ -360,12 +360,12 @@ impl rtio::RtioFileStream for CFile {\n     }\n \n     fn write(&mut self, buf: &[u8]) -> Result<(), IoError> {\n-        let ret = do keep_going(buf) |buf, len| {\n+        let ret = keep_going(buf, |buf, len| {\n             unsafe {\n                 libc::fwrite(buf as *libc::c_void, 1, len as libc::size_t,\n                             self.file) as i64\n             }\n-        };\n+        });\n         if ret < 0 {\n             Err(super::last_error())\n         } else {\n@@ -445,9 +445,9 @@ pub fn open(path: &CString, fm: io::FileMode, fa: io::FileAccess)\n \n     #[cfg(windows)]\n     fn os_open(path: &CString, flags: c_int, mode: c_int) -> c_int {\n-        do as_utf16_p(path.as_str().unwrap()) |path| {\n+        as_utf16_p(path.as_str().unwrap(), |path| {\n             unsafe { libc::wopen(path, flags, mode) }\n-        }\n+        })\n     }\n \n     #[cfg(unix)]\n@@ -463,9 +463,9 @@ pub fn mkdir(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n     fn os_mkdir(p: &CString, _mode: c_int) -> IoResult<()> {\n         super::mkerr_winbool(unsafe {\n             // FIXME: turn mode into something useful? #2623\n-            do as_utf16_p(p.as_str().unwrap()) |buf| {\n+            as_utf16_p(p.as_str().unwrap(), |buf| {\n                 libc::CreateDirectoryW(buf, ptr::mut_null())\n-            }\n+            })\n         })\n     }\n \n@@ -497,9 +497,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n             }\n             debug!(\"os::list_dir -- BEFORE OPENDIR\");\n \n-            let dir_ptr = do p.with_ref |buf| {\n-                opendir(buf)\n-            };\n+            let dir_ptr = p.with_ref(|buf| opendir(buf));\n \n             if (dir_ptr as uint != 0) {\n                 let mut paths = ~[];\n@@ -540,7 +538,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n             let p = CString::new(p.with_ref(|p| p), false);\n             let p = Path::new(p);\n             let star = p.join(\"*\");\n-            do as_utf16_p(star.as_str().unwrap()) |path_ptr| {\n+            as_utf16_p(star.as_str().unwrap(), |path_ptr| {\n                 let wfd_ptr = malloc_raw(rust_list_dir_wfd_size() as uint);\n                 let find_handle = FindFirstFileW(path_ptr, wfd_ptr as HANDLE);\n                 if find_handle as libc::c_int != INVALID_HANDLE_VALUE {\n@@ -565,7 +563,7 @@ pub fn readdir(p: &CString) -> IoResult<~[Path]> {\n                 } else {\n                     Err(super::last_error())\n                 }\n-            }\n+            })\n         }\n \n         get_list(p).map(|paths| prune(p, paths))\n@@ -578,9 +576,7 @@ pub fn unlink(p: &CString) -> IoResult<()> {\n     #[cfg(windows)]\n     fn os_unlink(p: &CString) -> IoResult<()> {\n         super::mkerr_winbool(unsafe {\n-            do as_utf16_p(p.as_str().unwrap()) |buf| {\n-                libc::DeleteFileW(buf)\n-            }\n+            as_utf16_p(p.as_str().unwrap(), |buf| libc::DeleteFileW(buf));\n         })\n     }\n \n@@ -596,11 +592,11 @@ pub fn rename(old: &CString, new: &CString) -> IoResult<()> {\n     #[cfg(windows)]\n     fn os_rename(old: &CString, new: &CString) -> IoResult<()> {\n         super::mkerr_winbool(unsafe {\n-            do as_utf16_p(old.as_str().unwrap()) |old| {\n-                do as_utf16_p(new.as_str().unwrap()) |new| {\n+            as_utf16_p(old.as_str().unwrap(), |old| {\n+                as_utf16_p(new.as_str().unwrap(), |new| {\n                     libc::MoveFileExW(old, new, libc::MOVEFILE_REPLACE_EXISTING)\n-                }\n-            }\n+                })\n+            })\n         })\n     }\n \n@@ -618,9 +614,7 @@ pub fn chmod(p: &CString, mode: io::FilePermission) -> IoResult<()> {\n     #[cfg(windows)]\n     fn os_chmod(p: &CString, mode: c_int) -> c_int {\n         unsafe {\n-            do as_utf16_p(p.as_str().unwrap()) |p| {\n-                libc::wchmod(p, mode)\n-            }\n+            as_utf16_p(p.as_str().unwrap(), |p| libc::wchmod(p, mode))\n         }\n     }\n \n@@ -636,7 +630,7 @@ pub fn rmdir(p: &CString) -> IoResult<()> {\n     #[cfg(windows)]\n     fn os_rmdir(p: &CString) -> c_int {\n         unsafe {\n-            do as_utf16_p(p.as_str().unwrap()) |p| { libc::wrmdir(p) }\n+            as_utf16_p(p.as_str().unwrap(), |p| libc::wrmdir(p))\n         }\n     }\n \n@@ -669,23 +663,23 @@ pub fn readlink(p: &CString) -> IoResult<Path> {\n     #[cfg(windows)]\n     fn os_readlink(p: &CString) -> IoResult<Path> {\n         let handle = unsafe {\n-            do as_utf16_p(p.as_str().unwrap()) |p| {\n+            as_utf16_p(p.as_str().unwrap(), |p| {\n                 libc::CreateFileW(p,\n                                   libc::GENERIC_READ,\n                                   libc::FILE_SHARE_READ,\n                                   ptr::mut_null(),\n                                   libc::OPEN_EXISTING,\n                                   libc::FILE_ATTRIBUTE_NORMAL,\n                                   ptr::mut_null())\n-            }\n+            })\n         };\n         if handle == ptr::mut_null() { return Err(super::last_error()) }\n-        let ret = do fill_utf16_buf_and_decode |buf, sz| {\n+        let ret = fill_utf16_buf_and_decode(|buf, sz| {\n             unsafe {\n                 libc::GetFinalPathNameByHandleW(handle, buf as *u16, sz,\n                                                 libc::VOLUME_NAME_NT)\n             }\n-        };\n+        });\n         let ret = match ret {\n             Some(s) => Ok(Path::new(s)),\n             None => Err(super::last_error()),\n@@ -722,11 +716,11 @@ pub fn symlink(src: &CString, dst: &CString) -> IoResult<()> {\n \n     #[cfg(windows)]\n     fn os_symlink(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(do as_utf16_p(src.as_str().unwrap()) |src| {\n-            do as_utf16_p(dst.as_str().unwrap()) |dst| {\n+        super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n+            as_utf16_p(dst.as_str().unwrap(), |dst| {\n                 unsafe { libc::CreateSymbolicLinkW(dst, src, 0) }\n-            }\n-        })\n+            })\n+        }))\n     }\n \n     #[cfg(unix)]\n@@ -742,11 +736,11 @@ pub fn link(src: &CString, dst: &CString) -> IoResult<()> {\n \n     #[cfg(windows)]\n     fn os_link(src: &CString, dst: &CString) -> IoResult<()> {\n-        super::mkerr_winbool(do as_utf16_p(src.as_str().unwrap()) |src| {\n-            do as_utf16_p(dst.as_str().unwrap()) |dst| {\n+        super::mkerr_winbool(as_utf16_p(src.as_str().unwrap(), |src| {\n+            as_utf16_p(dst.as_str().unwrap(), |dst| {\n                 unsafe { libc::CreateHardLinkW(dst, src, ptr::mut_null()) }\n-            }\n-        })\n+            })\n+        }))\n     }\n \n     #[cfg(unix)]\n@@ -851,12 +845,12 @@ pub fn stat(p: &CString) -> IoResult<io::FileStat> {\n     #[cfg(windows)]\n     fn os_stat(p: &CString) -> IoResult<io::FileStat> {\n         let mut stat: libc::stat = unsafe { intrinsics::uninit() };\n-        do as_utf16_p(p.as_str().unwrap()) |up| {\n+        as_utf16_p(p.as_str().unwrap(), |up| {\n             match unsafe { libc::wstat(up, &mut stat) } {\n                 0 => Ok(mkstat(&stat, p)),\n                 _ => Err(super::last_error()),\n             }\n-        }\n+        })\n     }\n \n     #[cfg(unix)]\n@@ -898,9 +892,7 @@ pub fn utime(p: &CString, atime: u64, mtime: u64) -> IoResult<()> {\n             modtime: (mtime / 1000) as libc::time64_t,\n         };\n         unsafe {\n-            do as_utf16_p(p.as_str().unwrap()) |p| {\n-                libc::wutime(p, &buf)\n-            }\n+            as_utf16_p(p.as_str().unwrap(), |p| libc::wutime(p, &buf))\n         }\n     }\n "}, {"sha": "ef531c8803c7625c3789f4f60d07d7fdede929e3", "filename": "src/libstd/io/native/process.rs", "status": "modified", "additions": 16, "deletions": 24, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -234,18 +234,18 @@ fn spawn_process_os(prog: &str, args: &[~str],\n         let mut pi = zeroed_process_information();\n         let mut create_err = None;\n \n-        do with_envp(env) |envp| {\n-            do with_dirp(dir) |dirp| {\n-                do cmd.with_c_str |cmdp| {\n+        with_envp(env, |envp| {\n+            with_dirp(dir, |dirp| {\n+                cmd.with_c_str(|cmdp| {\n                     let created = CreateProcessA(ptr::null(), cast::transmute(cmdp),\n                                                  ptr::mut_null(), ptr::mut_null(), TRUE,\n                                                  0, envp, dirp, &mut si, &mut pi);\n                     if created == FALSE {\n                         create_err = Some(os::last_os_error());\n                     }\n-                }\n-            }\n-        }\n+                })\n+            })\n+        });\n \n         CloseHandle(si.hStdInput);\n         CloseHandle(si.hStdOutput);\n@@ -411,22 +411,22 @@ fn spawn_process_os(prog: &str, args: &[~str],\n             close(fd as c_int);\n         }\n \n-        do with_dirp(dir) |dirp| {\n+        with_dirp(dir, |dirp| {\n             if !dirp.is_null() && chdir(dirp) == -1 {\n                 fail!(\"failure in chdir: {}\", os::last_os_error());\n             }\n-        }\n+        });\n \n-        do with_envp(env) |envp| {\n+        with_envp(env, |envp| {\n             if !envp.is_null() {\n                 set_environ(envp);\n             }\n-            do with_argv(prog, args) |argv| {\n+            with_argv(prog, args, |argv| {\n                 execvp(*argv, argv);\n                 // execvp only returns if an error occurred\n                 fail!(\"failure in execvp: {}\", os::last_os_error());\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n@@ -448,9 +448,7 @@ fn with_argv<T>(prog: &str, args: &[~str], cb: |**libc::c_char| -> T) -> T {\n     // Next, convert each of the byte strings into a pointer. This is\n     // technically unsafe as the caller could leak these pointers out of our\n     // scope.\n-    let mut ptrs = do tmps.map |tmp| {\n-        tmp.with_ref(|buf| buf)\n-    };\n+    let mut ptrs = tmps.map(|tmp| tmp.with_ref(|buf| buf));\n \n     // Finally, make sure we add a null pointer.\n     ptrs.push(ptr::null());\n@@ -475,14 +473,10 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*c_void| -> T) -> T {\n             }\n \n             // Once again, this is unsafe.\n-            let mut ptrs = do tmps.map |tmp| {\n-                tmp.with_ref(|buf| buf)\n-            };\n+            let mut ptrs = tmps.map(|tmp| tmp.with_ref(|buf| buf));\n             ptrs.push(ptr::null());\n \n-            do ptrs.as_imm_buf |buf, _| {\n-                unsafe { cb(cast::transmute(buf)) }\n-            }\n+            ptrs.as_imm_buf(|buf, _| unsafe { cb(cast::transmute(buf)) })\n         }\n         _ => cb(ptr::null())\n     }\n@@ -505,9 +499,7 @@ fn with_envp<T>(env: Option<~[(~str, ~str)]>, cb: |*mut c_void| -> T) -> T {\n \n             blk.push(0);\n \n-            do blk.as_imm_buf |p, _len| {\n-                unsafe { cb(cast::transmute(p)) }\n-            }\n+            blk.as_imm_buf(|p, _len| unsafe { cb(cast::transmute(p)) });\n         }\n         _ => cb(ptr::mut_null())\n     }"}, {"sha": "03af64cc6dccfe2e6c42f6a9a5288f75d22dd892", "filename": "src/libstd/io/net/addrinfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Faddrinfo.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -97,15 +97,15 @@ pub fn get_host_addresses(host: &str) -> Option<~[IpAddr]> {\n ///      consumption just yet.\n fn lookup(hostname: Option<&str>, servname: Option<&str>,\n           hint: Option<Hint>) -> Option<~[Info]> {\n-    do with_local_io |io| {\n+    with_local_io(|io| {\n         match io.get_host_addresses(hostname, servname, hint) {\n             Ok(i) => Some(i),\n             Err(ioerr) => {\n                 io_error::cond.raise(ioerr);\n                 None\n             }\n         }\n-    }\n+    })\n }\n \n #[cfg(test)]"}, {"sha": "e089628b9c779d84dabd00a16c39e55ad35db4e1", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 16, "deletions": 28, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -94,9 +94,7 @@ impl<'self> Parser<'self> {\n     // Commit only if parser read till EOF\n     fn read_till_eof<T>(&mut self, cb: |&mut Parser| -> Option<T>)\n                      -> Option<T> {\n-        do self.read_atomically |p| {\n-            cb(p).filtered(|_| p.is_eof())\n-        }\n+        self.read_atomically(|p| cb(p).filtered(|_| p.is_eof()))\n     }\n \n     // Return result of first successful parser\n@@ -120,15 +118,15 @@ impl<'self> Parser<'self> {\n                   pb: |&mut Parser| -> Option<B>,\n                   pc: |&mut Parser| -> Option<C>)\n                   -> Option<(A, B, C)> {\n-        do self.read_atomically |p| {\n+        self.read_atomically(|p| {\n             let a = pa(p);\n             let b = if a.is_some() { pb(p) } else { None };\n             let c = if b.is_some() { pc(p) } else { None };\n             match (a, b, c) {\n                 (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n                 _ => None\n             }\n-        }\n+        })\n     }\n \n     // Read next char\n@@ -144,9 +142,9 @@ impl<'self> Parser<'self> {\n \n     // Return char and advance iff next char is equal to requested\n     fn read_given_char(&mut self, c: char) -> Option<char> {\n-        do self.read_atomically |p| {\n+        self.read_atomically(|p| {\n             p.read_char().filtered(|&next| next == c)\n-        }\n+        })\n     }\n \n     // Read digit\n@@ -165,9 +163,9 @@ impl<'self> Parser<'self> {\n             }\n         }\n \n-        do self.read_atomically |p| {\n+        self.read_atomically(|p| {\n             p.read_char().and_then(|c| parse_digit(c, radix))\n-        }\n+        })\n     }\n \n     fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n@@ -195,9 +193,7 @@ impl<'self> Parser<'self> {\n \n     // Read number, failing if max_digits of number value exceeded\n     fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        do self.read_atomically |p| {\n-            p.read_number_impl(radix, max_digits, upto)\n-        }\n+        self.read_atomically(|p| p.read_number_impl(radix, max_digits, upto))\n     }\n \n     fn read_ipv4_addr_impl(&mut self) -> Option<IpAddr> {\n@@ -220,9 +216,7 @@ impl<'self> Parser<'self> {\n \n     // Read IPv4 address\n     fn read_ipv4_addr(&mut self) -> Option<IpAddr> {\n-        do self.read_atomically |p| {\n-            p.read_ipv4_addr_impl()\n-        }\n+        self.read_atomically(|p| p.read_ipv4_addr_impl())\n     }\n \n     fn read_ipv6_addr_impl(&mut self) -> Option<IpAddr> {\n@@ -238,13 +232,13 @@ impl<'self> Parser<'self> {\n             let mut i = 0;\n             while i < limit {\n                 if i < limit - 1 {\n-                    let ipv4 = do p.read_atomically |p| {\n+                    let ipv4 = p.read_atomically(|p| {\n                         if i == 0 || p.read_given_char(':').is_some() {\n                             p.read_ipv4_addr()\n                         } else {\n                             None\n                         }\n-                    };\n+                    });\n                     match ipv4 {\n                         Some(Ipv4Addr(a, b, c, d)) => {\n                             groups[i + 0] = (a as u16 << 8) | (b as u16);\n@@ -255,13 +249,13 @@ impl<'self> Parser<'self> {\n                     }\n                 }\n \n-                let group = do p.read_atomically |p| {\n+                let group = p.read_atomically(|p| {\n                     if i == 0 || p.read_given_char(':').is_some() {\n                         p.read_number(16, 4, 0x10000).map(|n| n as u16)\n                     } else {\n                         None\n                     }\n-                };\n+                });\n                 match group {\n                     Some(g) => groups[i] = g,\n                     None => return (i, false)\n@@ -296,9 +290,7 @@ impl<'self> Parser<'self> {\n     }\n \n     fn read_ipv6_addr(&mut self) -> Option<IpAddr> {\n-        do self.read_atomically |p| {\n-            p.read_ipv6_addr_impl()\n-        }\n+        self.read_atomically(|p| p.read_ipv6_addr_impl())\n     }\n \n     fn read_ip_addr(&mut self) -> Option<IpAddr> {\n@@ -330,17 +322,13 @@ impl<'self> Parser<'self> {\n \n impl FromStr for IpAddr {\n     fn from_str(s: &str) -> Option<IpAddr> {\n-        do Parser::new(s).read_till_eof |p| {\n-            p.read_ip_addr()\n-        }\n+        Parser::new(s).read_till_eof(|p| p.read_ip_addr())\n     }\n }\n \n impl FromStr for SocketAddr {\n     fn from_str(s: &str) -> Option<SocketAddr> {\n-        do Parser::new(s).read_till_eof |p| {\n-            p.read_socket_addr()\n-        }\n+        Parser::new(s).read_till_eof(|p| p.read_socket_addr())\n     }\n }\n "}, {"sha": "ac099e67f795fee5feeafb1dbb1da45730efb364", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -26,15 +26,15 @@ impl TcpStream {\n     }\n \n     pub fn connect(addr: SocketAddr) -> Option<TcpStream> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.tcp_connect(addr) {\n                 Ok(s) => Some(TcpStream::new(s)),\n                 Err(ioerr) => {\n                     io_error::cond.raise(ioerr);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     pub fn peer_name(&mut self) -> Option<SocketAddr> {\n@@ -92,15 +92,15 @@ pub struct TcpListener {\n \n impl TcpListener {\n     pub fn bind(addr: SocketAddr) -> Option<TcpListener> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.tcp_bind(addr) {\n                 Ok(l) => Some(TcpListener { obj: l }),\n                 Err(ioerr) => {\n                     io_error::cond.raise(ioerr);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     pub fn socket_name(&mut self) -> Option<SocketAddr> {"}, {"sha": "38def44d9d0e9a5419dfc561e1e75e89b6403cac", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -21,15 +21,15 @@ pub struct UdpSocket {\n \n impl UdpSocket {\n     pub fn bind(addr: SocketAddr) -> Option<UdpSocket> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.udp_bind(addr) {\n                 Ok(s) => Some(UdpSocket { obj: s }),\n                 Err(ioerr) => {\n                     io_error::cond.raise(ioerr);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     pub fn recvfrom(&mut self, buf: &mut [u8]) -> Option<(uint, SocketAddr)> {\n@@ -84,23 +84,21 @@ impl UdpStream {\n impl Reader for UdpStream {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         let peer = self.connectedTo;\n-        do self.as_socket |sock| {\n+        self.as_socket(|sock| {\n             match sock.recvfrom(buf) {\n                 Some((_nread, src)) if src != peer => Some(0),\n                 Some((nread, _src)) => Some(nread),\n                 None => None,\n             }\n-        }\n+        })\n     }\n \n     fn eof(&mut self) -> bool { fail!() }\n }\n \n impl Writer for UdpStream {\n     fn write(&mut self, buf: &[u8]) {\n-        do self.as_socket |sock| {\n-            sock.sendto(buf, self.connectedTo);\n-        }\n+        self.as_socket(|sock| sock.sendto(buf, self.connectedTo));\n     }\n }\n "}, {"sha": "eb86f0ef97fe3bd06c2705ebfa0747191fcb1ae1", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -59,15 +59,15 @@ impl UnixStream {\n     ///     stream.write([1, 2, 3]);\n     ///\n     pub fn connect<P: ToCStr>(path: &P) -> Option<UnixStream> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.unix_connect(&path.to_c_str()) {\n                 Ok(s) => Some(UnixStream::new(s)),\n                 Err(ioerr) => {\n                     io_error::cond.raise(ioerr);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n@@ -108,15 +108,15 @@ impl UnixListener {\n     ///     }\n     ///\n     pub fn bind<P: ToCStr>(path: &P) -> Option<UnixListener> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.unix_bind(&path.to_c_str()) {\n                 Ok(s) => Some(UnixListener{ obj: s }),\n                 Err(ioerr) => {\n                     io_error::cond.raise(ioerr);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n }\n "}, {"sha": "373de1649edc4370a20237fc8a84460306aafea1", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -44,15 +44,15 @@ impl PipeStream {\n     /// If the pipe cannot be created, an error will be raised on the\n     /// `io_error` condition.\n     pub fn open(fd: file::fd_t) -> Option<PipeStream> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.pipe_open(fd) {\n                 Ok(obj) => Some(PipeStream { obj: obj }),\n                 Err(e) => {\n                     io_error::cond.raise(e);\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     pub fn new(inner: ~RtioPipe) -> PipeStream {"}, {"sha": "308e969c43a1f57a3d465b1de73db52995ac2a42", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -121,7 +121,7 @@ impl Process {\n     /// source/destination\n     pub fn new(config: ProcessConfig) -> Option<Process> {\n         let config = Cell::new(config);\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.spawn(config.take()) {\n                 Ok((p, io)) => Some(Process{\n                     handle: p,\n@@ -134,7 +134,7 @@ impl Process {\n                     None\n                 }\n             }\n-        }\n+        })\n     }\n \n     /// Returns the process id of this child process"}, {"sha": "f6e79a03323218766861c71a1f6b0a3f3b4ba879", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -123,7 +123,7 @@ impl Listener {\n         if self.handles.contains_key(&signum) {\n             return true; // self is already listening to signum, so succeed\n         }\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.signal(signum, self.chan.clone()) {\n                 Ok(w) => {\n                     self.handles.insert(signum, w);\n@@ -134,7 +134,7 @@ impl Listener {\n                     None\n                 }\n             }\n-        }.is_some()\n+        }).is_some()\n     }\n \n     /// Unregisters a signal. If this listener currently had a handler\n@@ -212,13 +212,13 @@ mod test {\n         use super::User1;\n         let mut s = Listener::new();\n         let mut called = false;\n-        do io::io_error::cond.trap(|_| {\n+        io::io_error::cond.trap(|_| {\n             called = true;\n-        }).inside {\n+        }).inside(|| {\n             if s.register(User1) {\n                 fail!(\"Unexpected successful registry of signum {:?}\", User1);\n             }\n-        }\n+        });\n         assert!(called);\n     }\n }"}, {"sha": "2aa8b0c7ed6d54c77ae72529883f73228a4c9453", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -70,7 +70,7 @@ enum StdSource {\n }\n \n fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n-    do with_local_io |io| {\n+    with_local_io(|io| {\n         let fd = unsafe { libc::dup(fd) };\n         match io.tty_open(fd, readable) {\n             Ok(tty) => Some(f(TTY(tty))),\n@@ -84,14 +84,14 @@ fn src<T>(fd: libc::c_int, readable: bool, f: |StdSource| -> T) -> T {\n                 Some(f(File(io.fs_from_raw_fd(fd, CloseAsynchronously))))\n             }\n         }\n-    }.unwrap()\n+    }).unwrap()\n }\n \n /// Creates a new non-blocking handle to the stdin of the current process.\n ///\n /// See `stdout()` for notes about this function.\n pub fn stdin() -> StdReader {\n-    do src(libc::STDIN_FILENO, true) |src| { StdReader { inner: src } }\n+    src(libc::STDIN_FILENO, true, |src| StdReader { inner: src })\n }\n \n /// Creates a new non-blocking handle to the stdout of the current process.\n@@ -101,26 +101,26 @@ pub fn stdin() -> StdReader {\n /// task context because the stream returned will be a non-blocking object using\n /// the local scheduler to perform the I/O.\n pub fn stdout() -> StdWriter {\n-    do src(libc::STDOUT_FILENO, false) |src| { StdWriter { inner: src } }\n+    src(libc::STDOUT_FILENO, false, |src| StdWriter { inner: src })\n }\n \n /// Creates a new non-blocking handle to the stderr of the current process.\n ///\n /// See `stdout()` for notes about this function.\n pub fn stderr() -> StdWriter {\n-    do src(libc::STDERR_FILENO, false) |src| { StdWriter { inner: src } }\n+    src(libc::STDERR_FILENO, false, |src| StdWriter { inner: src })\n }\n \n // Helper to access the local task's stdout handle\n //\n // Note that this is not a safe function to expose because you can create an\n // aliased pointer very easily:\n //\n-//  do with_task_stdout |io1| {\n-//      do with_task_stdout |io2| {\n+//  with_task_stdout(|io1| {\n+//      with_task_stdout(|io2| {\n //          // io1 aliases io2\n-//      }\n-//  }\n+//      })\n+//  })\n fn with_task_stdout(f: |&mut Writer|) {\n     use rt::local::Local;\n     use rt::task::Task;\n@@ -158,42 +158,34 @@ fn with_task_stdout(f: |&mut Writer|) {\n /// will emit output to stderr, and while they are line buffered the log\n /// messages are always terminated in a newline (no need to flush).\n pub fn flush() {\n-    do with_task_stdout |io| {\n-        io.flush();\n-    }\n+    with_task_stdout(|io| io.flush())\n }\n \n /// Prints a string to the stdout of the current process. No newline is emitted\n /// after the string is printed.\n pub fn print(s: &str) {\n-    do with_task_stdout |io| {\n-        io.write(s.as_bytes());\n-    }\n+    with_task_stdout(|io| io.write(s.as_bytes()))\n }\n \n /// Prints a string as a line. to the stdout of the current process. A literal\n /// `\\n` character is printed to the console after the string.\n pub fn println(s: &str) {\n-    do with_task_stdout |io| {\n+    with_task_stdout(|io| {\n         io.write(s.as_bytes());\n         io.write(['\\n' as u8]);\n-    }\n+    })\n }\n \n /// Similar to `print`, but takes a `fmt::Arguments` structure to be compatible\n /// with the `format_args!` macro.\n pub fn print_args(fmt: &fmt::Arguments) {\n-    do with_task_stdout |io| {\n-        fmt::write(io, fmt);\n-    }\n+    with_task_stdout(|io| fmt::write(io, fmt))\n }\n \n /// Similar to `println`, but takes a `fmt::Arguments` structure to be\n /// compatible with the `format_args!` macro.\n pub fn println_args(fmt: &fmt::Arguments) {\n-    do with_task_stdout |io| {\n-        fmt::writeln(io, fmt);\n-    }\n+    with_task_stdout(|io| fmt::writeln(io, fmt))\n }\n \n /// Representation of a reader of a standard input stream"}, {"sha": "8dda79358887eac32eaadff4de407af3a4a31c3a", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -60,7 +60,7 @@ impl Timer {\n     /// for a number of milliseconds, or to possibly create channels which will\n     /// get notified after an amount of time has passed.\n     pub fn new() -> Option<Timer> {\n-        do with_local_io |io| {\n+        with_local_io(|io| {\n             match io.timer_init() {\n                 Ok(t) => Some(Timer { obj: t }),\n                 Err(ioerr) => {\n@@ -70,7 +70,7 @@ impl Timer {\n                 }\n             }\n \n-        }\n+        })\n     }\n \n     /// Blocks the current task for `msecs` milliseconds."}, {"sha": "89907c7434cdf554f175b9dc145477856697acfc", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -189,7 +189,7 @@ pub fn get<T: 'static, U>(key: Key<T>, f: |Option<&T>| -> U) -> U {\n /// on loan via this or the `get` methods. This is similar to how it's a runtime\n /// error to take two mutable loans on an `@mut` box.\n pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {\n-    do get_with(key, MutLoan) |x| {\n+    get_with(key, MutLoan, |x| {\n         match x {\n             None => f(None),\n             // We're violating a lot of compiler guarantees with this\n@@ -199,7 +199,7 @@ pub fn get_mut<T: 'static, U>(key: Key<T>, f: |Option<&mut T>| -> U) -> U {\n             // there is no need to be upset!\n             Some(x) => { f(Some(unsafe { cast::transmute_mut(x) })) }\n         }\n-    }\n+    })\n }\n \n fn get_with<T:'static,"}, {"sha": "fc56bf91c2a77da3be867d8b5ce627921ea67cae", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -420,10 +420,10 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     // base 2 number, and then we need another for a possible '-' character.\n     let mut buf = [0u8, ..65];\n     let mut cur = 0;\n-    do strconv::int_to_str_bytes_common(n, radix, strconv::SignNeg) |i| {\n+    strconv::int_to_str_bytes_common(n, radix, strconv::SignNeg, |i| {\n         buf[cur] = i;\n         cur += 1;\n-    }\n+    });\n     f(buf.slice(0, cur))\n }\n \n@@ -440,9 +440,9 @@ impl ToStrRadix for $T {\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         let mut buf: ~[u8] = ~[];\n-        do strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg) |i| {\n+        strconv::int_to_str_bytes_common(*self, radix, strconv::SignNeg, |i| {\n             buf.push(i);\n-        }\n+        });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n         unsafe { str::raw::from_utf8_owned(buf) }"}, {"sha": "3c276378df86356577e183bc6967af28dd545e42", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -271,10 +271,10 @@ pub fn to_str_bytes<U>(n: $T, radix: uint, f: |v: &[u8]| -> U) -> U {\n     // base 2 number.\n     let mut buf = [0u8, ..64];\n     let mut cur = 0;\n-    do strconv::int_to_str_bytes_common(n, radix, strconv::SignNone) |i| {\n+    strconv::int_to_str_bytes_common(n, radix, strconv::SignNone, |i| {\n         buf[cur] = i;\n         cur += 1;\n-    }\n+    });\n     f(buf.slice(0, cur))\n }\n \n@@ -291,9 +291,9 @@ impl ToStrRadix for $T {\n     #[inline]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         let mut buf = ~[];\n-        do strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone) |i| {\n+        strconv::int_to_str_bytes_common(*self, radix, strconv::SignNone, |i| {\n             buf.push(i);\n-        }\n+        });\n         // We know we generated valid utf-8, so we don't need to go through that\n         // check.\n         unsafe { str::raw::from_utf8_owned(buf) }"}, {"sha": "baa4423220c5dd392d4a2298807038278b9b6f86", "filename": "src/libstd/os.rs", "status": "modified", "additions": 61, "deletions": 67, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -58,29 +58,29 @@ static BUF_BYTES : uint = 2048u;\n #[cfg(unix)]\n pub fn getcwd() -> Path {\n     let mut buf = [0 as libc::c_char, ..BUF_BYTES];\n-    do buf.as_mut_buf |buf, len| {\n+    buf.as_mut_buf(|buf, len| {\n         unsafe {\n             if libc::getcwd(buf, len as size_t).is_null() {\n                 fail!()\n             }\n \n             Path::new(CString::new(buf as *c_char, false))\n         }\n-    }\n+    })\n }\n \n #[cfg(windows)]\n pub fn getcwd() -> Path {\n     use libc::DWORD;\n     use libc::GetCurrentDirectoryW;\n     let mut buf = [0 as u16, ..BUF_BYTES];\n-    do buf.as_mut_buf |buf, len| {\n+    buf.as_mut_buf(|buf, len| {\n         unsafe {\n             if libc::GetCurrentDirectoryW(len as DWORD, buf) == 0 as DWORD {\n                 fail!();\n             }\n         }\n-    }\n+    });\n     Path::new(str::from_utf16(buf))\n }\n \n@@ -104,7 +104,7 @@ pub mod win32 {\n             while !done {\n                 let mut k: DWORD = 0;\n                 let mut buf = vec::from_elem(n as uint, 0u16);\n-                do buf.as_mut_buf |b, _sz| {\n+                buf.as_mut_buf(|b, _sz| {\n                     k = f(b, TMPBUF_SZ as DWORD);\n                     if k == (0 as DWORD) {\n                         done = true;\n@@ -115,7 +115,7 @@ pub mod win32 {\n                     } else {\n                         done = true;\n                     }\n-                }\n+                });\n                 if k != 0 && done {\n                     let sub = buf.slice(0, k as uint);\n                     res = option::Some(str::from_utf16(sub));\n@@ -144,12 +144,10 @@ fn with_env_lock<T>(f: || -> T) -> T {\n     static mut lock: Mutex = MUTEX_INIT;\n \n     unsafe {\n-        return do (|| {\n+        return (|| {\n             lock.lock();\n             f()\n-        }).finally {\n-            lock.unlock();\n-        };\n+        }).finally(|| lock.unlock());\n     }\n }\n \n@@ -172,9 +170,9 @@ pub fn env() -> ~[(~str,~str)] {\n                        os::last_os_error());\n             }\n             let mut result = ~[];\n-            do c_str::from_c_multistring(ch as *libc::c_char, None) |cstr| {\n+            c_str::from_c_multistring(ch as *libc::c_char, None, |cstr| {\n                 result.push(cstr.as_str().unwrap().to_owned());\n-            };\n+            });\n             FreeEnvironmentStringsA(ch);\n             result\n         }\n@@ -207,10 +205,10 @@ pub fn env() -> ~[(~str,~str)] {\n             }\n             pairs\n         }\n-        do with_env_lock {\n+        with_env_lock(|| {\n             let unparsed_environ = get_env_pairs();\n             env_convert(unparsed_environ)\n-        }\n+        })\n     }\n }\n \n@@ -219,16 +217,14 @@ pub fn env() -> ~[(~str,~str)] {\n /// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n     unsafe {\n-        do with_env_lock {\n-            let s = do n.with_c_str |buf| {\n-                libc::getenv(buf)\n-            };\n+        with_env_lock(|| {\n+            let s = n.with_c_str(|buf| libc::getenv(buf));\n             if s.is_null() {\n                 None\n             } else {\n                 Some(str::raw::from_c_str(s))\n             }\n-        }\n+        })\n     }\n }\n \n@@ -237,14 +233,14 @@ pub fn getenv(n: &str) -> Option<~str> {\n /// None if the variable isn't set.\n pub fn getenv(n: &str) -> Option<~str> {\n     unsafe {\n-        do with_env_lock {\n+        with_env_lock(|| {\n             use os::win32::{as_utf16_p, fill_utf16_buf_and_decode};\n-            do as_utf16_p(n) |u| {\n-                do fill_utf16_buf_and_decode() |buf, sz| {\n+            as_utf16_p(n, |u| {\n+                fill_utf16_buf_and_decode(|buf, sz| {\n                     libc::GetEnvironmentVariableW(u, buf, sz)\n-                }\n-            }\n-        }\n+                })\n+            })\n+        })\n     }\n }\n \n@@ -254,13 +250,13 @@ pub fn getenv(n: &str) -> Option<~str> {\n /// process\n pub fn setenv(n: &str, v: &str) {\n     unsafe {\n-        do with_env_lock {\n-            do n.with_c_str |nbuf| {\n-                do v.with_c_str |vbuf| {\n+        with_env_lock(|| {\n+            n.with_c_str(|nbuf| {\n+                v.with_c_str(|vbuf| {\n                     libc::funcs::posix01::unistd::setenv(nbuf, vbuf, 1);\n-                }\n-            }\n-        }\n+                })\n+            })\n+        })\n     }\n }\n \n@@ -270,14 +266,14 @@ pub fn setenv(n: &str, v: &str) {\n /// process\n pub fn setenv(n: &str, v: &str) {\n     unsafe {\n-        do with_env_lock {\n+        with_env_lock(|| {\n             use os::win32::as_utf16_p;\n-            do as_utf16_p(n) |nbuf| {\n-                do as_utf16_p(v) |vbuf| {\n+            as_utf16_p(n, |nbuf| {\n+                as_utf16_p(v, |vbuf| {\n                     libc::SetEnvironmentVariableW(nbuf, vbuf);\n-                }\n-            }\n-        }\n+                })\n+            })\n+        })\n     }\n }\n \n@@ -286,22 +282,22 @@ pub fn unsetenv(n: &str) {\n     #[cfg(unix)]\n     fn _unsetenv(n: &str) {\n         unsafe {\n-            do with_env_lock {\n-                do n.with_c_str |nbuf| {\n+            with_env_lock(|| {\n+                n.with_c_str(|nbuf| {\n                     libc::funcs::posix01::unistd::unsetenv(nbuf);\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n     #[cfg(windows)]\n     fn _unsetenv(n: &str) {\n         unsafe {\n-            do with_env_lock {\n+            with_env_lock(|| {\n                 use os::win32::as_utf16_p;\n-                do as_utf16_p(n) |nbuf| {\n+                as_utf16_p(n, |nbuf| {\n                     libc::SetEnvironmentVariableW(nbuf, ptr::null());\n-                }\n-            }\n+                })\n+            })\n         }\n     }\n \n@@ -372,10 +368,10 @@ pub fn self_exe_path() -> Option<Path> {\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n-            let err = do v.as_mut_buf |buf,_| {\n+            let err = v.as_mut_buf(|buf,_| {\n                 sysctl(vec::raw::to_ptr(mib), mib.len() as ::libc::c_uint,\n                        buf as *mut c_void, &mut sz, ptr::null(), 0u as size_t)\n-            };\n+            });\n             if err != 0 { return None; }\n             if sz == 0 { return None; }\n             vec::raw::set_len(&mut v, sz as uint - 1); // chop off trailing NUL\n@@ -403,9 +399,9 @@ pub fn self_exe_path() -> Option<Path> {\n             _NSGetExecutablePath(ptr::mut_null(), &mut sz);\n             if sz == 0 { return None; }\n             let mut v: ~[u8] = vec::with_capacity(sz as uint);\n-            let err = do v.as_mut_buf |buf,_| {\n+            let err = v.as_mut_buf(|buf, _| {\n                 _NSGetExecutablePath(buf as *mut i8, &mut sz)\n-            };\n+            });\n             if err != 0 { return None; }\n             vec::raw::set_len(&mut v, sz as uint - 1); // chop off trailing NUL\n             Some(v)\n@@ -416,9 +412,9 @@ pub fn self_exe_path() -> Option<Path> {\n     fn load_self() -> Option<~[u8]> {\n         unsafe {\n             use os::win32::fill_utf16_buf_and_decode;\n-            do fill_utf16_buf_and_decode() |buf, sz| {\n+            fill_utf16_buf_and_decode(|buf, sz| {\n                 libc::GetModuleFileNameW(0u as libc::DWORD, buf, sz)\n-            }.map(|s| s.into_bytes())\n+            }).map(|s| s.into_bytes())\n         }\n     }\n \n@@ -452,13 +448,13 @@ pub fn homedir() -> Option<Path> {\n \n     #[cfg(windows)]\n     fn secondary() -> Option<Path> {\n-        do getenv(\"USERPROFILE\").and_then |p| {\n+        getenv(\"USERPROFILE\").and_then(|p| {\n             if !p.is_empty() {\n                 Path::new_opt(p)\n             } else {\n                 None\n             }\n-        }\n+        })\n     }\n }\n \n@@ -536,19 +532,19 @@ pub fn change_dir(p: &Path) -> bool {\n     fn chdir(p: &Path) -> bool {\n         unsafe {\n             use os::win32::as_utf16_p;\n-            return do as_utf16_p(p.as_str().unwrap()) |buf| {\n+            return as_utf16_p(p.as_str().unwrap(), |buf| {\n                 libc::SetCurrentDirectoryW(buf) != (0 as libc::BOOL)\n-            };\n+            });\n         }\n     }\n \n     #[cfg(unix)]\n     fn chdir(p: &Path) -> bool {\n-        do p.with_c_str |buf| {\n+        p.with_c_str(|buf| {\n             unsafe {\n                 libc::chdir(buf) == (0 as c_int)\n             }\n-        }\n+        })\n     }\n }\n \n@@ -637,15 +633,15 @@ pub fn last_os_error() -> ~str {\n \n         let mut buf = [0 as c_char, ..TMPBUF_SZ];\n \n-        do buf.as_mut_buf |buf, len| {\n+        buf.as_mut_buf(|buf, len| {\n             unsafe {\n                 if strerror_r(errno() as c_int, buf, len as size_t) < 0 {\n                     fail!(\"strerror_r failure\");\n                 }\n \n                 str::raw::from_c_str(buf as *c_char)\n             }\n-        }\n+        })\n     }\n \n     #[cfg(windows)]\n@@ -678,7 +674,7 @@ pub fn last_os_error() -> ~str {\n         let mut buf = [0 as WCHAR, ..TMPBUF_SZ];\n \n         unsafe {\n-            do buf.as_mut_buf |buf, len| {\n+            buf.as_mut_buf(|buf, len| {\n                 let res = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |\n                                          FORMAT_MESSAGE_IGNORE_INSERTS,\n                                          ptr::mut_null(),\n@@ -690,7 +686,7 @@ pub fn last_os_error() -> ~str {\n                 if res == 0 {\n                     fail!(\"[{}] FormatMessage failure\", errno());\n                 }\n-            }\n+            });\n \n             str::from_utf16(buf)\n         }\n@@ -1466,13 +1462,11 @@ mod tests {\n         let size = MemoryMap::granularity() * 2;\n \n         let fd = unsafe {\n-            let fd = do path.with_c_str |path| {\n+            let fd = path.with_c_str(|path| {\n                 open(path, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR)\n-            };\n+            });\n             lseek_(fd, size);\n-            do \"x\".with_c_str |x| {\n-                assert!(write(fd, x as *c_void, 1) == 1);\n-            }\n+            \"x\".with_c_str(|x| assert!(write(fd, x as *c_void, 1) == 1));\n             fd\n         };\n         let chunk = match MemoryMap::new(size / 2, [\n@@ -1491,7 +1485,7 @@ mod tests {\n             assert!(*chunk.data == 0xbe);\n             close(fd);\n         }\n-        do io::ignore_io_error { fs::unlink(&path); }\n+        io::ignore_io_error(|| fs::unlink(&path));\n     }\n \n     // More recursive_mkdir tests are in extra::tempfile"}, {"sha": "2b6009206acf7fc91ec0b9f1cfe5784847d635ab", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -530,9 +530,7 @@ pub struct Display<'self, P> {\n \n impl<'self, P: GenericPath> fmt::Default for Display<'self, P> {\n     fn fmt(d: &Display<P>, f: &mut fmt::Formatter) {\n-        do d.with_str |s| {\n-            f.pad(s)\n-        }\n+        d.with_str(|s| f.pad(s))\n     }\n }\n "}, {"sha": "877df1fb644f49c443c78eb67ca2c76841d67fd8", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -51,9 +51,9 @@ impl IsaacRng {\n         unsafe {\n             let ptr = raw::to_mut_ptr(rng.rsl);\n \n-            do raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl)) |slice| {\n+            raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n                 OSRng::new().fill_bytes(slice);\n-            }\n+            })\n         }\n \n         rng.init(true);\n@@ -94,7 +94,7 @@ impl IsaacRng {\n             }}\n         );\n \n-        do 4.times { mix!(); }\n+        4.times(|| mix!());\n \n         if use_rsl {\n             macro_rules! memloop (\n@@ -256,9 +256,9 @@ impl Isaac64Rng {\n         unsafe {\n             let ptr = raw::to_mut_ptr(rng.rsl);\n \n-            do raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl)) |slice| {\n+            raw::mut_buf_as_slice(ptr as *mut u8, mem::size_of_val(&rng.rsl), |slice| {\n                 OSRng::new().fill_bytes(slice);\n-            }\n+            })\n         }\n \n         rng.init(true);"}, {"sha": "9506a772ee811107f80882942507d73f3af7c3ad", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -168,6 +168,28 @@ impl<T> Drop for Rc<T> {\n     }\n }\n \n+impl<T> Clone for RcMut<T> {\n+    /// Return a shallow copy of the reference counted pointer.\n+    #[inline]\n+    fn clone(&self) -> RcMut<T> {\n+        unsafe {\n+            (*self.ptr).count += 1;\n+            RcMut{ptr: self.ptr}\n+        }\n+    }\n+}\n+\n+impl<T: DeepClone> DeepClone for RcMut<T> {\n+    /// Return a deep copy of the reference counted pointer.\n+    #[inline]\n+    fn deep_clone(&self) -> RcMut<T> {\n+        self.with_borrow(|x| {\n+            // FIXME: #6497: should avoid freeze (slow)\n+            unsafe { RcMut::new_unchecked(x.deep_clone()) }\n+        })\n+    }\n+}\n+\n #[cfg(test)]\n mod test_rc {\n     use super::*;\n@@ -177,19 +199,19 @@ mod test_rc {\n     fn test_clone() {\n         let x = Rc::from_send(RefCell::new(5));\n         let y = x.clone();\n-        do x.borrow().with_mut |inner| {\n+        x.borrow().with_mut(|inner| {\n             *inner = 20;\n-        }\n+        });\n         assert_eq!(y.borrow().with(|v| *v), 20);\n     }\n \n     #[test]\n     fn test_deep_clone() {\n         let x = Rc::from_send(RefCell::new(5));\n         let y = x.deep_clone();\n-        do x.borrow().with_mut |inner| {\n+        x.borrow().with_mut(|inner| {\n             *inner = 20;\n-        }\n+        });\n         assert_eq!(y.borrow().with(|v| *v), 5);\n     }\n "}, {"sha": "8a3e60eb3e2d521dc9da6356a47d49c6f7a6439b", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -50,16 +50,12 @@ pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n     #[inline]\n     pub fn bump(&mut self, sz: uint) {\n-        do self.inner.move_ptr() |p| {\n-            ((p as uint) + sz) as *c_void\n-        };\n+        self.inner.move_ptr(|p| ((p as uint) + sz) as *c_void)\n     }\n \n     #[inline]\n     pub fn align(&mut self, a: uint) {\n-        do self.inner.move_ptr() |p| {\n-            align(p as uint, a) as *c_void\n-        };\n+        self.inner.move_ptr(|p| align(p as uint, a) as *c_void)\n     }\n \n     #[inline]"}, {"sha": "d26989c36e66a92142eb8e8ec86b0db78efca17a", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -53,18 +53,18 @@ impl Repr for bool {\n \n impl Repr for int {\n     fn write_repr(&self, writer: &mut io::Writer) {\n-        do ::int::to_str_bytes(*self, 10u) |bits| {\n+        ::int::to_str_bytes(*self, 10u, |bits| {\n             writer.write(bits);\n-        }\n+        })\n     }\n }\n \n macro_rules! int_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n     fn write_repr(&self, writer: &mut io::Writer) {\n-        do ::$ty::to_str_bytes(*self, 10u) |bits| {\n+        ::$ty::to_str_bytes(*self, 10u, |bits| {\n             writer.write(bits);\n             writer.write(bytes!($suffix));\n-        }\n+        })\n     }\n }))\n \n@@ -163,9 +163,9 @@ impl<'self> ReprVisitor<'self> {\n \n     #[inline]\n     pub fn write<T:Repr>(&mut self) -> bool {\n-        do self.get |this, v:&T| {\n+        self.get(|this, v:&T| {\n             v.write_repr(unsafe { ::cast::transmute_copy(&this.writer) });\n-        }\n+        })\n     }\n \n     pub fn write_escaped_slice(&mut self, slice: &str) {\n@@ -234,9 +234,9 @@ impl<'self> ReprVisitor<'self> {\n             }\n             '\\x20'..'\\x7e' => self.writer.write([ch as u8]),\n             _ => {\n-                do char::escape_unicode(ch) |c| {\n+                char::escape_unicode(ch, |c| {\n                     self.writer.write([c as u8]);\n-                }\n+                })\n             }\n         }\n     }\n@@ -265,31 +265,29 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n     fn visit_f64(&mut self) -> bool { self.write::<f64>() }\n \n     fn visit_char(&mut self) -> bool {\n-        do self.get::<char> |this, &ch| {\n+        self.get::<char>(|this, &ch| {\n             this.writer.write(['\\'' as u8]);\n             this.write_escaped_char(ch, false);\n             this.writer.write(['\\'' as u8]);\n-        }\n+        })\n     }\n \n     fn visit_estr_box(&mut self) -> bool {\n-        do self.get::<@str> |this, s| {\n+        self.get::<@str>(|this, s| {\n             this.writer.write(['@' as u8]);\n             this.write_escaped_slice(*s);\n-        }\n+        })\n     }\n \n     fn visit_estr_uniq(&mut self) -> bool {\n-        do self.get::<~str> |this, s| {\n+        self.get::<~str>(|this, s| {\n             this.writer.write(['~' as u8]);\n             this.write_escaped_slice(*s);\n-        }\n+        })\n     }\n \n     fn visit_estr_slice(&mut self) -> bool {\n-        do self.get::<&str> |this, s| {\n-            this.write_escaped_slice(*s);\n-        }\n+        self.get::<&str>(|this, s| this.write_escaped_slice(*s))\n     }\n \n     // Type no longer exists, vestigial function.\n@@ -299,91 +297,91 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n     fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['@' as u8]);\n         self.write_mut_qualifier(mtbl);\n-        do self.get::<&raw::Box<()>> |this, b| {\n+        self.get::<&raw::Box<()>>(|this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n             this.visit_ptr_inner(p, inner);\n-        }\n+        })\n     }\n \n     fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['~' as u8]);\n-        do self.get::<*c_void> |this, b| {\n+        self.get::<*c_void>(|this, b| {\n             this.visit_ptr_inner(*b, inner);\n-        }\n+        })\n     }\n \n     fn visit_uniq_managed(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['~' as u8]);\n-        do self.get::<&raw::Box<()>> |this, b| {\n+        self.get::<&raw::Box<()>>(|this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n             this.visit_ptr_inner(p, inner);\n-        }\n+        })\n     }\n \n     fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n-        do self.get::<*c_void> |this, p| {\n+        self.get::<*c_void>(|this, p| {\n             write!(this.writer, \"({} as *\", *p);\n             this.write_mut_qualifier(mtbl);\n             this.writer.write(\"())\".as_bytes());\n-        }\n+        })\n     }\n \n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['&' as u8]);\n         self.write_mut_qualifier(mtbl);\n-        do self.get::<*c_void> |this, p| {\n+        self.get::<*c_void>(|this, p| {\n             this.visit_ptr_inner(*p, inner);\n-        }\n+        })\n     }\n \n     // Type no longer exists, vestigial function.\n     fn visit_vec(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool { fail!(); }\n \n     fn visit_unboxed_vec(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<raw::Vec<()>> |this, b| {\n+        self.get::<raw::Vec<()>>(|this, b| {\n             this.write_unboxed_vec_repr(mtbl, b, inner);\n-        }\n+        })\n     }\n \n     fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Box<raw::Vec<()>>> |this, b| {\n+        self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n             this.writer.write(['@' as u8]);\n             this.write_mut_qualifier(mtbl);\n             this.write_unboxed_vec_repr(mtbl, &b.data, inner);\n-        }\n+        })\n     }\n \n     fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Vec<()>> |this, b| {\n+        self.get::<&raw::Vec<()>>(|this, b| {\n             this.writer.write(['~' as u8]);\n             this.write_unboxed_vec_repr(mtbl, *b, inner);\n-        }\n+        })\n     }\n \n     fn visit_evec_uniq_managed(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&raw::Box<raw::Vec<()>>> |this, b| {\n+        self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n             this.writer.write(['~' as u8]);\n             this.write_unboxed_vec_repr(mtbl, &b.data, inner);\n-        }\n+        })\n     }\n \n     fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<raw::Slice<()>> |this, s| {\n+        self.get::<raw::Slice<()>>(|this, s| {\n             this.writer.write(['&' as u8]);\n             this.write_mut_qualifier(mtbl);\n             let size = unsafe {\n                 if (*inner).size == 0 { 1 } else { (*inner).size }\n             };\n             this.write_vec_range(s.data, s.len * size, inner);\n-        }\n+        })\n     }\n \n     fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n                         _: uint, inner: *TyDesc) -> bool {\n         let assumed_size = if sz == 0 { n } else { sz };\n-        do self.get::<()> |this, b| {\n+        self.get::<()>(|this, b| {\n             this.write_vec_range(ptr::to_unsafe_ptr(b), assumed_size, inner);\n-        }\n+        })\n     }\n \n     fn visit_enter_rec(&mut self, _n_fields: uint,\n@@ -600,10 +598,10 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n \n     fn visit_opaque_box(&mut self) -> bool {\n         self.writer.write(['@' as u8]);\n-        do self.get::<&raw::Box<()>> |this, b| {\n+        self.get::<&raw::Box<()>>(|this, b| {\n             let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n             this.visit_ptr_inner(p, b.type_desc);\n-        }\n+        })\n     }\n \n     fn visit_closure_ptr(&mut self, _ck: uint) -> bool { true }"}, {"sha": "d857f39ceaf0aa9cd94f8a92248448906ae9d61e", "filename": "src/libstd/rt/basic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbasic.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -71,13 +71,13 @@ impl BasicLoop {\n \n     fn remote_work(&mut self) {\n         let messages = unsafe {\n-            do self.messages.with |messages| {\n+            self.messages.with(|messages| {\n                 if messages.len() > 0 {\n                     Some(util::replace(messages, ~[]))\n                 } else {\n                     None\n                 }\n-            }\n+            })\n         };\n         let messages = match messages {\n             Some(m) => m, None => return\n@@ -139,11 +139,11 @@ impl EventLoop for BasicLoop {\n             unsafe {\n                 // We block here if we have no messages to process and we may\n                 // receive a message at a later date\n-                do self.messages.hold_and_wait |messages| {\n+                self.messages.hold_and_wait(|messages| {\n                     self.remotes.len() > 0 &&\n                         messages.len() == 0 &&\n                         self.work.len() == 0\n-                }\n+                })\n             }\n         }\n     }\n@@ -189,19 +189,19 @@ impl BasicRemote {\n impl RemoteCallback for BasicRemote {\n     fn fire(&mut self) {\n         unsafe {\n-            do self.queue.hold_and_signal |queue| {\n+            self.queue.hold_and_signal(|queue| {\n                 queue.push(RunRemote(self.id));\n-            }\n+            })\n         }\n     }\n }\n \n impl Drop for BasicRemote {\n     fn drop(&mut self) {\n         unsafe {\n-            do self.queue.hold_and_signal |queue| {\n+            self.queue.hold_and_signal(|queue| {\n                 queue.push(RemoveRemote(self.id));\n-            }\n+            })\n         }\n     }\n }"}, {"sha": "30c2264bd869790afa919e109ce568d1cdf4c9e2", "filename": "src/libstd/rt/borrowck.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fborrowck.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -35,9 +35,7 @@ pub struct BorrowRecord {\n }\n \n fn try_take_task_borrow_list() -> Option<~[BorrowRecord]> {\n-    do Local::borrow |task: &mut Task| {\n-        task.borrow_list.take()\n-    }\n+    Local::borrow(|task: &mut Task| task.borrow_list.take())\n }\n \n fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n@@ -47,9 +45,7 @@ fn swap_task_borrow_list(f: |~[BorrowRecord]| -> ~[BorrowRecord]) {\n     };\n     let borrows = f(borrows);\n     let borrows = Cell::new(borrows);\n-    do Local::borrow |task: &mut Task| {\n-        task.borrow_list = Some(borrows.take());\n-    }\n+    Local::borrow(|task: &mut Task| task.borrow_list = Some(borrows.take()))\n }\n \n pub fn clear_task_borrow_list() {\n@@ -64,9 +60,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) ->\n     match try_take_task_borrow_list() {\n         None => { // not recording borrows\n             let msg = \"borrowed\";\n-            do msg.with_c_str |msg_p| {\n-                task::begin_unwind_raw(msg_p, file, line);\n-            }\n+            msg.with_c_str(|msg_p| task::begin_unwind_raw(msg_p, file, line))\n         }\n         Some(borrow_list) => { // recording borrows\n             let mut msg = ~\"borrowed\";\n@@ -80,9 +74,7 @@ unsafe fn fail_borrowed(box: *mut raw::Box<()>, file: *c_char, line: size_t) ->\n                     sep = \" and at \";\n                 }\n             }\n-            do msg.with_c_str |msg_p| {\n-                task::begin_unwind_raw(msg_p, file, line)\n-            }\n+            msg.with_c_str(|msg_p| task::begin_unwind_raw(msg_p, file, line))\n         }\n     }\n }\n@@ -158,33 +150,35 @@ pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n         // was not borrowed before\n         let a = a as *mut raw::Box<()>;\n         debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n-        do swap_task_borrow_list |borrow_list| {\n+        swap_task_borrow_list(|borrow_list| {\n             let mut borrow_list = borrow_list;\n             borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n             borrow_list\n-        }\n+        })\n     }\n }\n \n-pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n-                              file: *c_char, line: size_t) {\n+pub unsafe fn unrecord_borrow(a: *u8,\n+                              old_ref_count: uint,\n+                              file: *c_char,\n+                              line: size_t) {\n     if (old_ref_count & ALL_BITS) == 0 {\n         // was not borrowed before, so we should find the record at\n         // the end of the list\n         let a = a as *mut raw::Box<()>;\n         debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n-        do swap_task_borrow_list |borrow_list| {\n+        swap_task_borrow_list(|borrow_list| {\n             let mut borrow_list = borrow_list;\n             assert!(!borrow_list.is_empty());\n             let br = borrow_list.pop();\n             if br.box != a || br.file != file || br.line != line {\n                 let err = format!(\"wrong borrow found, br={:?}\", br);\n-                do err.with_c_str |msg_p| {\n+                err.with_c_str(|msg_p| {\n                     task::begin_unwind_raw(msg_p, file, line)\n-                }\n+                })\n             }\n             borrow_list\n-        }\n+        })\n     }\n }\n "}, {"sha": "e3e425f620bd1f6ef38554ad283082481e1a9965", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -165,14 +165,14 @@ impl<T: Send> ChanOne<T> {\n                     // Port is blocked. Wake it up.\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n                     if do_resched {\n-                        do recvr.wake().map |woken_task| {\n+                        recvr.wake().map(|woken_task| {\n                             Scheduler::run_task(woken_task);\n-                        };\n+                        });\n                     } else {\n                         let recvr = Cell::new(recvr);\n-                        do Local::borrow |sched: &mut Scheduler| {\n+                        Local::borrow(|sched: &mut Scheduler| {\n                             sched.enqueue_blocked_task(recvr.take());\n-                        }\n+                        })\n                     }\n                 }\n             }\n@@ -209,9 +209,9 @@ impl<T: Send> PortOne<T> {\n             // No data available yet.\n             // Switch to the scheduler to put the ~Task into the Packet state.\n             let sched: ~Scheduler = Local::take();\n-            do sched.deschedule_running_task_and_then |sched, task| {\n+            sched.deschedule_running_task_and_then(|sched, task| {\n                 self.block_on(sched, task);\n-            }\n+            })\n         }\n \n         // Task resumes.\n@@ -230,9 +230,9 @@ impl<T: Send> SelectInner for PortOne<T> {\n         // The optimistic check is never necessary for correctness. For testing\n         // purposes, making it randomly return false simulates a racing sender.\n         use rand::{Rand};\n-        let actually_check = do Local::borrow |sched: &mut Scheduler| {\n+        let actually_check = Local::borrow(|sched: &mut Scheduler| {\n             Rand::rand(&mut sched.rng)\n-        };\n+        });\n         if actually_check {\n             unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n         } else {\n@@ -387,9 +387,9 @@ impl<T: Send> Drop for ChanOne<T> {\n                     // The port is blocked waiting for a message we will never send. Wake it.\n                     rtassert!((*self.packet()).payload.is_none());\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    do recvr.wake().map |woken_task| {\n+                    recvr.wake().map(|woken_task| {\n                         Scheduler::run_task(woken_task);\n-                    };\n+                    });\n                 }\n             }\n         }\n@@ -491,15 +491,15 @@ impl<T: Send> GenericPort<T> for Port<T> {\n \n     fn try_recv(&self) -> Option<T> {\n         let mut b = self.next.borrow_mut();\n-        do b.get().take().map_default(None) |pone| {\n+        b.get().take().map_default(None, |pone| {\n             match pone.try_recv() {\n                 Some(StreamPayload { val, next }) => {\n                     *b.get() = Some(next);\n                     Some(val)\n                 }\n                 None => None\n             }\n-        }\n+        })\n     }\n }\n \n@@ -516,7 +516,7 @@ impl<T: Send> Peekable<T> for Port<T> {\n impl<'self, T: Send> SelectInner for &'self Port<T> {\n     #[inline]\n     fn optimistic_check(&mut self) -> bool {\n-        do self.next.with_mut |pone| { pone.get_mut_ref().optimistic_check() }\n+        self.next.with_mut(|pone| { pone.get_mut_ref().optimistic_check() })\n     }\n \n     #[inline]\n@@ -527,7 +527,7 @@ impl<'self, T: Send> SelectInner for &'self Port<T> {\n \n     #[inline]\n     fn unblock_from(&mut self) -> bool {\n-        do self.next.with_mut |pone| { pone.get_mut_ref().unblock_from() }\n+        self.next.with_mut(|pone| { pone.get_mut_ref().unblock_from() })\n     }\n }\n \n@@ -871,7 +871,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_thread_close_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n                 let port_cell = Cell::new(port);\n@@ -881,13 +881,13 @@ mod test {\n                 let _chan = chan;\n                 thread.join();\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn oneshot_multi_thread_send_close_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n                 let chan_cell = Cell::new(chan);\n@@ -902,13 +902,13 @@ mod test {\n                 thread1.join();\n                 thread2.join();\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn oneshot_multi_thread_recv_close_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<int>();\n                 let chan_cell = Cell::new(chan);\n@@ -929,13 +929,13 @@ mod test {\n                 thread1.join();\n                 thread2.join();\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn oneshot_multi_thread_send_recv_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_newsched_task {\n                 let (port, chan) = oneshot::<~int>();\n                 let chan_cell = Cell::new(chan);\n@@ -949,13 +949,13 @@ mod test {\n                 thread1.join();\n                 thread2.join();\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn stream_send_recv_stress() {\n         if util::limit_thread_creation_due_to_osx_and_valgrind() { return; }\n-        do stress_factor().times {\n+        stress_factor().times(|| {\n             do run_in_mt_newsched_task {\n                 let (port, chan) = stream::<~int>();\n \n@@ -984,17 +984,17 @@ mod test {\n                     };\n                 }\n             }\n-        }\n+        })\n     }\n \n     #[test]\n     fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n-        do run_in_newsched_task {\n+        run_in_newsched_task(|| {\n             let (port, chan) = stream();\n-            do 10000.times { chan.send(()) }\n-            do 10000.times { port.recv() }\n-        }\n+            10000.times(|| { chan.send(()) });\n+            10000.times(|| { port.recv() });\n+        })\n     }\n \n     #[test]\n@@ -1004,16 +1004,16 @@ mod test {\n             let (port, chan) = stream();\n             let chan = SharedChan::new(chan);\n             let total = stress_factor() + 100;\n-            do total.times {\n+            total.times(|| {\n                 let chan_clone = chan.clone();\n                 do spawntask_random {\n                     chan_clone.send(());\n                 }\n-            }\n+            });\n \n-            do total.times {\n+            total.times(|| {\n                 port.recv();\n-            }\n+            })\n         }\n     }\n \n@@ -1026,22 +1026,22 @@ mod test {\n             let end_chan = SharedChan::new(end_chan);\n             let port = SharedPort::new(port);\n             let total = stress_factor() + 100;\n-            do total.times {\n+            total.times(|| {\n                 let end_chan_clone = end_chan.clone();\n                 let port_clone = port.clone();\n                 do spawntask_random {\n                     port_clone.recv();\n                     end_chan_clone.send(());\n                 }\n-            }\n+            });\n \n-            do total.times {\n+            total.times(|| {\n                 chan.send(());\n-            }\n+            });\n \n-            do total.times {\n+            total.times(|| {\n                 end_port.recv();\n-            }\n+            })\n         }\n     }\n \n@@ -1066,29 +1066,29 @@ mod test {\n             let send_total = 10;\n             let recv_total = 20;\n             do spawntask_random {\n-                do send_total.times {\n+                send_total.times(|| {\n                     let chan_clone = chan.clone();\n                     do spawntask_random {\n                         chan_clone.send(());\n                     }\n-                }\n+                })\n             }\n             let end_chan_clone = end_chan.clone();\n             do spawntask_random {\n-                do recv_total.times {\n+                recv_total.times(|| {\n                     let port_clone = port.clone();\n                     let end_chan_clone = end_chan_clone.clone();\n                     do spawntask_random {\n                         let recvd = port_clone.try_recv().is_some();\n                         end_chan_clone.send(recvd);\n                     }\n-                }\n+                })\n             }\n \n             let mut recvd = 0;\n-            do recv_total.times {\n+            recv_total.times(|| {\n                 recvd += if end_port.recv() { 1 } else { 0 };\n-            }\n+            });\n \n             assert!(recvd == send_total);\n         }\n@@ -1107,7 +1107,7 @@ mod test {\n             let pipe = megapipe();\n             let total = stress_factor() + 10;\n             let mut rng = rand::rng();\n-            do total.times {\n+            total.times(|| {\n                 let msgs = rng.gen_range(0u, 10);\n                 let pipe_clone = pipe.clone();\n                 let end_chan_clone = end_chan.clone();\n@@ -1121,11 +1121,11 @@ mod test {\n                 }\n \n                 end_chan_clone.send(());\n-            }\n+            });\n \n-            do total.times {\n+            total.times(|| {\n                 end_port.recv();\n-            }\n+            })\n         }\n     }\n \n@@ -1152,13 +1152,13 @@ mod test {\n \n             let cs = Cell::new((cone, cstream, cshared, mp));\n             unsafe {\n-                do atomically {\n+                atomically(|| {\n                     let (cone, cstream, cshared, mp) = cs.take();\n                     cone.send_deferred(());\n                     cstream.send_deferred(());\n                     cshared.send_deferred(());\n                     mp.send_deferred(());\n-                }\n+                })\n             }\n         }\n     }"}, {"sha": "56c77ffaa0d3772a18d7a4adc298f1410fa238fa", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -257,10 +257,7 @@ impl Death {\n     /// Collect failure exit codes from children and propagate them to a parent.\n     pub fn collect_failure(&mut self, result: UnwindResult) {\n         let result = Cell::new(result);\n-\n-        do self.on_exit.take().map |on_exit| {\n-            on_exit(result.take());\n-        };\n+        self.on_exit.take().map(|on_exit| on_exit(result.take()));\n     }\n \n     /// Enter a possibly-nested \"atomic\" section of code. Just for assertions."}, {"sha": "23345926543c094b921da596e90e17bbd8dcd7e1", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -34,10 +34,10 @@ impl Local for Task {\n         let mut res: Option<T> = None;\n         let res_ptr: *mut Option<T> = &mut res;\n         unsafe {\n-            do local_ptr::borrow |task| {\n+            local_ptr::borrow(|task| {\n                 let result = f(task);\n                 *res_ptr = Some(result);\n-            }\n+            })\n         }\n         match res {\n             Some(r) => { r }\n@@ -57,10 +57,10 @@ impl Local for Task {\n impl Local for Scheduler {\n     fn put(value: ~Scheduler) {\n         let value = Cell::new(value);\n-        do Local::borrow |task: &mut Task| {\n+        Local::borrow(|task: &mut Task| {\n             let task = task;\n             task.sched = Some(value.take());\n-        };\n+        });\n     }\n     #[inline]\n     fn take() -> ~Scheduler {\n@@ -71,15 +71,15 @@ impl Local for Scheduler {\n         }\n     }\n     fn exists(_: Option<Scheduler>) -> bool {\n-        do Local::borrow |task: &mut Task| {\n+        Local::borrow(|task: &mut Task| {\n             match task.sched {\n                 Some(ref _task) => true,\n                 None => false\n             }\n-        }\n+        })\n     }\n     fn borrow<T>(f: |&mut Scheduler| -> T) -> T {\n-        do Local::borrow |task: &mut Task| {\n+        Local::borrow(|task: &mut Task| {\n             match task.sched {\n                 Some(~ref mut task) => {\n                     f(task)\n@@ -88,7 +88,7 @@ impl Local for Scheduler {\n                     rtabort!(\"no scheduler\")\n                 }\n             }\n-        }\n+        })\n     }\n     unsafe fn unsafe_take() -> ~Scheduler { rtabort!(\"unimpl\") }\n     unsafe fn unsafe_borrow() -> *mut Scheduler {"}, {"sha": "a7805a9f55925bff4a84b42f9be054b522dce1a2", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -302,9 +302,7 @@ pub unsafe fn local_free(ptr: *libc::c_char) {\n }\n \n pub fn live_allocs() -> *mut Box {\n-    do Local::borrow |task: &mut Task| {\n-        task.heap.live_allocs\n-    }\n+    Local::borrow(|task: &mut Task| task.heap.live_allocs)\n }\n \n #[cfg(test)]\n@@ -313,15 +311,11 @@ mod bench {\n \n     #[bench]\n     fn alloc_managed_small(bh: &mut BenchHarness) {\n-        do bh.iter {\n-            @10;\n-        }\n+        bh.iter(|| @10);\n     }\n \n     #[bench]\n     fn alloc_managed_big(bh: &mut BenchHarness) {\n-        do bh.iter {\n-            @[10, ..1000];\n-        }\n+        bh.iter(|| @[10, ..1000]);\n     }\n }"}, {"sha": "eb7d8ef2f5fe2b2dca3e23d840299512fd140685", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -110,11 +110,7 @@ pub unsafe fn borrow<T>(f: |&mut T|) {\n     let unsafe_ptr = cast::transmute_mut_region(&mut *value);\n     let value_cell = Cell::new(value);\n \n-    do (|| {\n-        f(unsafe_ptr);\n-    }).finally {\n-        put(value_cell.take());\n-    }\n+    (|| f(unsafe_ptr)).finally(|| put(value_cell.take()));\n }\n \n /// Borrow a mutable reference to the thread-local value"}, {"sha": "13e18f7d9b75ee83c5c8d82f41bc6fc3d6a23c11", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -142,19 +142,17 @@ fn update_log_settings(crate_map: &CrateMap, settings: ~str) {\n     if settings.len() > 0 {\n         if settings == ~\"::help\" || settings == ~\"?\" {\n             rterrln!(\"\\nCrate log map:\\n\");\n-            do iter_crate_map(crate_map) |entry| {\n-                rterrln!(\" {}\", entry.name);\n-            }\n+            iter_crate_map(crate_map, |entry| rterrln!(\" {}\", entry.name));\n             unsafe { exit(1); }\n         }\n         dirs = parse_logging_spec(settings);\n     }\n \n     let mut n_matches: u32 = 0;\n-    do iter_crate_map(crate_map) |entry| {\n+    iter_crate_map(crate_map, |entry| {\n         let m = update_entry(dirs, entry);\n         n_matches += m;\n-    }\n+    });\n \n     if n_matches < (dirs.len() as u32) {\n         rterrln!(\"warning: got {} RUST_LOG specs but only matched\\n\\"}, {"sha": "7f607fcf12a63a70290add3a0b4cb3fe57191688", "filename": "src/libstd/rt/mpmc_bounded_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -68,9 +68,9 @@ impl<T: Send> State<T> {\n         } else {\n             capacity\n         };\n-        let buffer = do vec::from_fn(capacity) |i:uint| {\n+        let buffer = vec::from_fn(capacity, |i:uint| {\n             Node{sequence:AtomicUint::new(i),value:None}\n-        };\n+        });\n         State{\n             pad0: [0, ..64],\n             buffer: buffer,"}, {"sha": "519274bb131cf70f8056b82cdc4abf9d5eb8762b", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -236,9 +236,9 @@ impl Scheduler {\n             // Our scheduler must be in the task before the event loop\n             // is started.\n             let self_sched = Cell::new(self);\n-            do Local::borrow |stask: &mut Task| {\n+            Local::borrow(|stask: &mut Task| {\n                 stask.sched = Some(self_sched.take());\n-            };\n+            });\n \n             (*event_loop).run();\n         }\n@@ -538,9 +538,7 @@ impl Scheduler {\n     /// As enqueue_task, but with the possibility for the blocked task to\n     /// already have been killed.\n     pub fn enqueue_blocked_task(&mut self, blocked_task: BlockedTask) {\n-        do blocked_task.wake().map |task| {\n-            self.enqueue_task(task);\n-        };\n+        blocked_task.wake().map(|task| self.enqueue_task(task));\n     }\n \n     // * Core Context Switching Functions\n@@ -643,9 +641,9 @@ impl Scheduler {\n     // * Context Swapping Helpers - Here be ugliness!\n \n     pub fn resume_task_immediately(~self, task: ~Task) {\n-        do self.change_task_context(task) |sched, stask| {\n+        self.change_task_context(task, |sched, stask| {\n             sched.sched_task = Some(stask);\n-        }\n+        })\n     }\n \n     fn resume_task_immediately_cl(sched: ~Scheduler,\n@@ -686,15 +684,15 @@ impl Scheduler {\n                                          f: |&mut Scheduler, BlockedTask|) {\n         // This is where we convert the BlockedTask-taking closure into one\n         // that takes just a Task\n-        do self.change_task_context(next_task) |sched, task| {\n+        self.change_task_context(next_task, |sched, task| {\n             f(sched, BlockedTask::block(task))\n-        }\n+        })\n     }\n \n     fn switch_task(sched: ~Scheduler, task: ~Task) {\n-        do sched.switch_running_tasks_and_then(task) |sched, last_task| {\n+        sched.switch_running_tasks_and_then(task, |sched, last_task| {\n             sched.enqueue_blocked_task(last_task);\n-        };\n+        });\n     }\n \n     // * Task Context Helpers\n@@ -705,10 +703,10 @@ impl Scheduler {\n         // Similar to deschedule running task and then, but cannot go through\n         // the task-blocking path. The task is already dying.\n         let stask = self.sched_task.take_unwrap();\n-        do self.change_task_context(stask) |sched, mut dead_task| {\n+        self.change_task_context(stask, |sched, mut dead_task| {\n             let coroutine = dead_task.coroutine.take_unwrap();\n             coroutine.recycle(&mut sched.stack_pool);\n-        }\n+        })\n     }\n \n     pub fn run_task(task: ~Task) {\n@@ -718,9 +716,9 @@ impl Scheduler {\n \n     pub fn run_task_later(next_task: ~Task) {\n         let next_task = Cell::new(next_task);\n-        do Local::borrow |sched: &mut Scheduler| {\n+        Local::borrow(|sched: &mut Scheduler| {\n             sched.enqueue_task(next_task.take());\n-        };\n+        });\n     }\n \n     /// Yield control to the scheduler, executing another task. This is guaranteed\n@@ -731,9 +729,9 @@ impl Scheduler {\n         self.yield_check_count = reset_yield_check(&mut self.rng);\n         // Tell the scheduler to start stealing on the next iteration\n         self.steal_for_yield = true;\n-        do self.deschedule_running_task_and_then |sched, task| {\n+        self.deschedule_running_task_and_then(|sched, task| {\n             sched.enqueue_blocked_task(task);\n-        }\n+        })\n     }\n \n     pub fn maybe_yield(mut ~self) {\n@@ -852,23 +850,23 @@ fn new_sched_rng() -> XorShiftRng {\n     use iter::Iterator;\n     use rand::SeedableRng;\n \n-    let fd = do \"/dev/urandom\".with_c_str |name| {\n+    let fd = \"/dev/urandom\".with_c_str(|name| {\n         unsafe { libc::open(name, libc::O_RDONLY, 0) }\n-    };\n+    });\n     if fd == -1 {\n         rtabort!(\"could not open /dev/urandom for reading.\")\n     }\n \n     let mut seeds = [0u32, .. 4];\n     let size = mem::size_of_val(&seeds);\n     loop {\n-        let nbytes = do seeds.as_mut_buf |buf, _| {\n+        let nbytes = seeds.as_mut_buf(|buf, _| {\n             unsafe {\n                 libc::read(fd,\n                            buf as *mut libc::c_void,\n                            size as libc::size_t)\n             }\n-        };\n+        });\n         rtassert!(nbytes as uint == size);\n \n         if !seeds.iter().all(|x| *x == 0) {"}, {"sha": "569d96ae388d3588895fd213680b6c58e4f3b621", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -142,15 +142,15 @@ impl Task {\n                              -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n-        do Local::borrow |running_task: &mut Task| {\n+        Local::borrow(|running_task: &mut Task| {\n             let mut sched = running_task.sched.take_unwrap();\n             let new_task = ~running_task.new_child_homed(&mut sched.stack_pool,\n                                                          stack_size,\n                                                          home.take(),\n                                                          f.take());\n             running_task.sched = Some(sched);\n             new_task\n-        }\n+        })\n     }\n \n     pub fn build_child(stack_size: Option<uint>, f: proc()) -> ~Task {\n@@ -163,15 +163,15 @@ impl Task {\n                             -> ~Task {\n         let f = Cell::new(f);\n         let home = Cell::new(home);\n-        do Local::borrow |running_task: &mut Task| {\n+        Local::borrow(|running_task: &mut Task| {\n             let mut sched = running_task.sched.take_unwrap();\n             let new_task = ~Task::new_root_homed(&mut sched.stack_pool,\n                                                  stack_size,\n                                                  home.take(),\n                                                  f.take());\n             running_task.sched = Some(sched);\n             new_task\n-        }\n+        })\n     }\n \n     pub fn build_root(stack_size: Option<uint>, f: proc()) -> ~Task {\n@@ -280,10 +280,10 @@ impl Task {\n \n         // The only try/catch block in the world. Attempt to run the task's\n         // client-specified code and catch any failures.\n-        do self.unwinder.try {\n+        self.unwinder.try(|| {\n \n             // Run the task main function, then do some cleanup.\n-            do f.finally {\n+            f.finally(|| {\n \n                 // First, destroy task-local storage. This may run user dtors.\n                 //\n@@ -320,8 +320,8 @@ impl Task {\n                     None => {}\n                 }\n                 self.logger.take();\n-            }\n-        }\n+            })\n+        });\n \n         // Cleanup the dynamic borrowck debugging info\n         borrowck::clear_task_borrow_list();\n@@ -364,7 +364,7 @@ impl Task {\n     // Grab both the scheduler and the task from TLS and check if the\n     // task is executing on an appropriate scheduler.\n     pub fn on_appropriate_sched() -> bool {\n-        do Local::borrow |task: &mut Task| {\n+        Local::borrow(|task: &mut Task| {\n             let sched_id = task.sched.get_ref().sched_id();\n             let sched_run_anything = task.sched.get_ref().run_anything;\n             match task.task_type {\n@@ -383,7 +383,7 @@ impl Task {\n                     rtabort!(\"type error: expected: GreenTask, found: SchedTask\");\n                 }\n             }\n-        }\n+        })\n     }\n }\n \n@@ -431,9 +431,9 @@ impl Coroutine {\n             unsafe {\n \n                 // Again - might work while safe, or it might not.\n-                do Local::borrow |sched: &mut Scheduler| {\n+                Local::borrow(|sched: &mut Scheduler| {\n                     sched.run_cleanup_job();\n-                }\n+                });\n \n                 // To call the run method on a task we need a direct\n                 // reference to it. The task is in TLS, so we can\n@@ -442,7 +442,7 @@ impl Coroutine {\n                 // need to unsafe_borrow.\n                 let task: *mut Task = Local::unsafe_borrow();\n \n-                do (*task).run {\n+                (*task).run(|| {\n                     // N.B. Removing `start` from the start wrapper\n                     // closure by emptying a cell is critical for\n                     // correctness. The ~Task pointer, and in turn the\n@@ -455,7 +455,7 @@ impl Coroutine {\n                     // scope while the task is still running.\n                     let start = start_cell.take();\n                     start();\n-                };\n+                });\n             }\n \n             // We remove the sched from the Task in TLS right now.\n@@ -584,7 +584,7 @@ pub extern \"C\" fn rust_stack_exhausted() {\n         //  #2361 - possible implementation of not using landing pads\n \n         if in_green_task_context() {\n-            do Local::borrow |task: &mut Task| {\n+            Local::borrow(|task: &mut Task| {\n                 let n = task.name.as_ref().map(|n| n.as_slice()).unwrap_or(\"<unnamed>\");\n \n                 // See the message below for why this is not emitted to the\n@@ -593,7 +593,7 @@ pub extern \"C\" fn rust_stack_exhausted() {\n                 // call would happen to initialized it (calling out to libuv),\n                 // and the FFI call needs 2MB of stack when we just ran out.\n                 rterrln!(\"task '{}' has overflowed its stack\", n);\n-            }\n+            })\n         } else {\n             rterrln!(\"stack overflow in non-task context\");\n         }"}, {"sha": "360764daf156c4fc9d30b08e471ac30506f121f4", "filename": "src/libstd/rt/tube.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftube.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -68,9 +68,9 @@ impl<T> Tube<T> {\n                 assert!(self.p.refcount() > 1); // There better be somebody to wake us up\n                 assert!((*state).blocked_task.is_none());\n                 let sched: ~Scheduler = Local::take();\n-                do sched.deschedule_running_task_and_then |_, task| {\n+                sched.deschedule_running_task_and_then(|_, task| {\n                     (*state).blocked_task = Some(task);\n-                }\n+                });\n                 rtdebug!(\"waking after tube recv\");\n                 let buf = &mut (*state).buf;\n                 assert!(!buf.is_empty());"}, {"sha": "02ea8ab4f5037b65fc442cd770081280eae4e47b", "filename": "src/libstd/rt/work_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fwork_queue.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -37,25 +37,25 @@ impl<T: Send> WorkQueue<T> {\n \n     pub fn pop(&mut self) -> Option<T> {\n         unsafe {\n-            do self.queue.with |q| {\n+            self.queue.with(|q| {\n                 if !q.is_empty() {\n                     Some(q.shift())\n                 } else {\n                     None\n                 }\n-            }\n+            })\n         }\n     }\n \n     pub fn steal(&mut self) -> Option<T> {\n         unsafe {\n-            do self.queue.with |q| {\n+            self.queue.with(|q| {\n                 if !q.is_empty() {\n                     Some(q.pop())\n                 } else {\n                     None\n                 }\n-            }\n+            })\n         }\n     }\n "}, {"sha": "7f977fdd2a39f5a15b49fc093adbc033bae900b8", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -221,20 +221,20 @@ impl Process {\n         let ch_clone = ch.clone();\n \n         do spawn {\n-            do io::ignore_io_error {\n+            io::ignore_io_error(|| {\n                 match error.take() {\n                     Some(ref mut e) => ch.send((2, e.read_to_end())),\n                     None => ch.send((2, ~[]))\n                 }\n-            }\n+            })\n         }\n         do spawn {\n-            do io::ignore_io_error {\n+            io::ignore_io_error(|| {\n                 match output.take() {\n                     Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n                     None => ch_clone.send((1, ~[]))\n                 }\n-            }\n+            })\n         }\n \n         let status = self.finish();"}, {"sha": "b619085e201809b1ddfac57d0cfd8f6e9873c3f1", "filename": "src/libstd/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -59,10 +59,10 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     let p = Cell::new(p);\n     let c = Cell::new(c);\n \n-    do (|| {\n+    (|| {\n         let c = Cell::new(c.take());\n         let sched: ~Scheduler = Local::take();\n-        do sched.deschedule_running_task_and_then |sched, task| {\n+        sched.deschedule_running_task_and_then(|sched, task| {\n             let task_handles = task.make_selectable(ports.len());\n \n             for (index, (port, task_handle)) in\n@@ -77,12 +77,12 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n             let c = Cell::new(c.take());\n             do sched.event_loop.callback { c.take().send_deferred(()) }\n         }\n-    }).finally {\n+    }).finally(|| {\n         // Unkillable is necessary not because getting killed is dangerous here,\n         // but to force the recv not to use the same kill-flag that we used for\n         // selecting. Otherwise a user-sender could spuriously wakeup us here.\n         p.take().recv();\n-    }\n+    });\n \n     // Task resumes. Now unblock ourselves from all the ports we blocked on.\n     // If the success index wasn't reset, 'take' will just take all of them."}, {"sha": "b2ded6ab7541e28a5fd07e36d75cb7ff311c8218", "filename": "src/libstd/str.rs", "status": "modified", "additions": 62, "deletions": 106, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -410,11 +410,11 @@ impl<'self> Iterator<(uint, char)> for CharOffsetIterator<'self> {\n     fn next(&mut self) -> Option<(uint, char)> {\n         // Compute the byte offset by using the pointer offset between\n         // the original string slice and the iterator's remaining part\n-        let offset = do self.string.as_imm_buf |a, _| {\n-            do self.iter.string.as_imm_buf |b, _| {\n+        let offset = self.string.as_imm_buf(|a, _| {\n+            self.iter.string.as_imm_buf(|b, _| {\n                 b as uint - a as uint\n-            }\n-        };\n+            })\n+        });\n         self.iter.next().map(|ch| (offset, ch))\n     }\n \n@@ -428,11 +428,11 @@ impl<'self> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'self> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n         self.iter.next_back().map(|ch| {\n-            let offset = do self.string.as_imm_buf |a, _| {\n-                do self.iter.string.as_imm_buf |b, len| {\n+            let offset = self.string.as_imm_buf(|a, _| {\n+                self.iter.string.as_imm_buf(|b, len| {\n                     b as uint - a as uint + len\n-                }\n-            };\n+                })\n+            });\n             (offset, ch)\n         })\n     }\n@@ -716,14 +716,14 @@ impl<'self> Iterator<char> for NormalizationIterator<'self> {\n \n         if !self.sorted {\n             for ch in self.iter {\n-                do decomposer(ch) |d| {\n+                decomposer(ch, |d| {\n                     let class = canonical_combining_class(d);\n                     if class == 0 && !self.sorted {\n                         canonical_sort(self.buffer);\n                         self.sorted = true;\n                     }\n                     self.buffer.push((d, class));\n-                }\n+                });\n                 if self.sorted { break }\n             }\n         }\n@@ -781,8 +781,8 @@ Section: Comparing strings\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do a.as_imm_buf |ap, alen| {\n-        do b.as_imm_buf |bp, blen| {\n+    a.as_imm_buf(|ap, alen| {\n+        b.as_imm_buf(|bp, blen| {\n             if (alen != blen) { false }\n             else {\n                 unsafe {\n@@ -791,16 +791,16 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n                                  alen as libc::size_t) == 0\n                 }\n             }\n-        }\n-    }\n+        })\n+    })\n }\n \n /// Bytewise slice equality\n #[cfg(test)]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do a.as_imm_buf |ap, alen| {\n-        do b.as_imm_buf |bp, blen| {\n+    a.as_imm_buf(|ap, alen| {\n+        b.as_imm_buf(|bp, blen| {\n             if (alen != blen) { false }\n             else {\n                 unsafe {\n@@ -809,8 +809,8 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n                                  alen as libc::size_t) == 0\n                 }\n             }\n-        }\n-    }\n+        })\n+    })\n }\n \n /// Bytewise string equality\n@@ -1029,9 +1029,7 @@ pub mod raw {\n     /// Create a Rust string from a *u8 buffer of the given length\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len);\n-        do v.as_mut_buf |vbuf, _len| {\n-            ptr::copy_memory(vbuf, buf as *u8, len)\n-        };\n+        v.as_mut_buf(|vbuf, _len| ptr::copy_memory(vbuf, buf as *u8, len));\n         vec::raw::set_len(&mut v, len);\n \n         assert!(is_utf8(v));\n@@ -1059,9 +1057,7 @@ pub mod raw {\n \n     /// Converts a vector of bytes to a new owned string.\n     pub unsafe fn from_utf8(v: &[u8]) -> ~str {\n-        do v.as_imm_buf |buf, len| {\n-            from_buf_len(buf, len)\n-        }\n+        v.as_imm_buf(|buf, len| from_buf_len(buf, len))\n     }\n \n     /// Converts an owned vector of bytes to a new owned string. This assumes\n@@ -1112,12 +1108,12 @@ pub mod raw {\n     /// Caller must check slice boundaries!\n     #[inline]\n     pub unsafe fn slice_unchecked<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        do s.as_imm_buf |sbuf, _n| {\n+        s.as_imm_buf(|sbuf, _n| {\n              cast::transmute(Slice {\n                  data: sbuf.offset(begin as int),\n                  len: end - begin,\n              })\n-        }\n+        })\n     }\n \n     /// Appends a byte to a string.\n@@ -1351,7 +1347,7 @@ impl<'self> Str for @str {\n impl<'self> Container for &'self str {\n     #[inline]\n     fn len(&self) -> uint {\n-        do self.as_imm_buf |_p, n| { n }\n+        self.as_imm_buf(|_p, n| n)\n     }\n }\n \n@@ -1876,11 +1872,11 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     fn lines_any(&self) -> AnyLineIterator<'self> {\n-        do self.lines().map |line| {\n+        self.lines().map(|line| {\n             let l = line.len();\n             if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n             else { line }\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -1973,9 +1969,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n         for c in self.chars() {\n-            do c.escape_default |c| {\n-                out.push_char(c);\n-            }\n+            c.escape_default(|c| out.push_char(c));\n         }\n         out\n     }\n@@ -1984,9 +1978,7 @@ impl<'self> StrSlice<'self> for &'self str {\n         let mut out: ~str = ~\"\";\n         out.reserve_at_least(self.len());\n         for c in self.chars() {\n-            do c.escape_unicode |c| {\n-                out.push_char(c);\n-            }\n+            c.escape_unicode(|c| out.push_char(c));\n         }\n         out\n     }\n@@ -2044,17 +2036,15 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     #[inline]\n     fn to_owned(&self) -> ~str {\n-        do self.as_imm_buf |src, len| {\n+        self.as_imm_buf(|src, len| {\n             unsafe {\n                 let mut v = vec::with_capacity(len);\n \n-                do v.as_mut_buf |dst, _| {\n-                    ptr::copy_memory(dst, src, len);\n-                }\n+                v.as_mut_buf(|dst, _| ptr::copy_memory(dst, src, len));\n                 vec::raw::set_len(&mut v, len);\n                 ::cast::transmute(v)\n             }\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -2250,8 +2240,8 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     fn subslice_offset(&self, inner: &str) -> uint {\n-        do self.as_imm_buf |a, a_len| {\n-            do inner.as_imm_buf |b, b_len| {\n+        self.as_imm_buf(|a, a_len| {\n+            inner.as_imm_buf(|b, b_len| {\n                 let a_start: uint;\n                 let a_end: uint;\n                 let b_start: uint;\n@@ -2263,8 +2253,8 @@ impl<'self> StrSlice<'self> for &'self str {\n                 assert!(a_start <= b_start);\n                 assert!(b_end <= a_end);\n                 b_start - a_start\n-            }\n-        }\n+            })\n+        })\n     }\n \n     #[inline]\n@@ -2382,11 +2372,11 @@ impl OwnedStr for ~str {\n \n             // Attempt to not use an intermediate buffer by just pushing bytes\n             // directly onto this string.\n-            let used = do self.as_mut_buf |buf, _| {\n-                do vec::raw::mut_buf_as_slice(buf.offset(cur_len as int), 4) |slc| {\n+            let used = self.as_mut_buf(|buf, _| {\n+                vec::raw::mut_buf_as_slice(buf.offset(cur_len as int), 4, |slc| {\n                     c.encode_utf8(slc)\n-                }\n-            };\n+                })\n+            });\n             raw::set_len(self, cur_len + used);\n         }\n     }\n@@ -3156,13 +3146,11 @@ mod tests {\n                   0x6d_u8];\n \n         let mut error_happened = false;\n-        let _x = do cond.trap(|err| {\n+        let _x = cond.trap(|err| {\n             assert_eq!(err, ~\"from_utf8: input is not UTF-8; first bad byte is 255\");\n             error_happened = true;\n             ~\"\"\n-        }).inside {\n-            from_utf8(bb)\n-        };\n+        }).inside(|| from_utf8(bb));\n         assert!(error_happened);\n     }\n \n@@ -3201,11 +3189,9 @@ mod tests {\n \n     #[test]\n     fn test_as_imm_buf() {\n-        do \"\".as_imm_buf |_, len| {\n-            assert_eq!(len, 0);\n-        }\n+        \"\".as_imm_buf(|_, len| assert_eq!(len, 0));\n \n-        do \"hello\".as_imm_buf |buf, len| {\n+        \"hello\".as_imm_buf(|buf, len| {\n             assert_eq!(len, 5);\n             unsafe {\n                 assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n@@ -3214,7 +3200,7 @@ mod tests {\n                 assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n                 assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n             }\n-        }\n+        })\n     }\n \n     #[test]\n@@ -3864,9 +3850,7 @@ mod bench {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        do bh.iter {\n-            assert_eq!(s.chars().len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.chars().len(), len));\n     }\n \n     #[bench]\n@@ -3879,48 +3863,38 @@ mod bench {\n         Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        do bh.iter {\n-            assert_eq!(s.chars().len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.chars().len(), len));\n     }\n \n     #[bench]\n     fn char_iterator_rev(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        do bh.iter {\n-            assert_eq!(s.chars_rev().len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.chars_rev().len(), len));\n     }\n \n     #[bench]\n     fn char_indicesator(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        do bh.iter {\n-            assert_eq!(s.char_indices().len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.char_indices().len(), len));\n     }\n \n     #[bench]\n     fn char_indicesator_rev(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let len = s.char_len();\n \n-        do bh.iter {\n-            assert_eq!(s.char_indices_rev().len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.char_indices_rev().len(), len));\n     }\n \n     #[bench]\n     fn split_unicode_ascii(bh: &mut BenchHarness) {\n         let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        do bh.iter {\n-            assert_eq!(s.split('V').len(), 3);\n-        }\n+        bh.iter(|| assert_eq!(s.split('V').len(), 3));\n     }\n \n     #[bench]\n@@ -3934,9 +3908,7 @@ mod bench {\n         }\n         let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n \n-        do bh.iter {\n-            assert_eq!(s.split(NotAscii('V')).len(), 3);\n-        }\n+        bh.iter(|| assert_eq!(s.split(NotAscii('V')).len(), 3));\n     }\n \n \n@@ -3945,9 +3917,7 @@ mod bench {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').len();\n \n-        do bh.iter {\n-            assert_eq!(s.split(' ').len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.split(' ').len(), len));\n     }\n \n     #[bench]\n@@ -3961,9 +3931,7 @@ mod bench {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').len();\n \n-        do bh.iter {\n-            assert_eq!(s.split(NotAscii(' ')).len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.split(NotAscii(' ')).len(), len));\n     }\n \n     #[bench]\n@@ -3972,29 +3940,23 @@ mod bench {\n         let len = s.split(' ').len();\n         fn pred(c: char) -> bool { c == ' ' }\n \n-        do bh.iter {\n-            assert_eq!(s.split(pred).len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.split(pred).len(), len));\n     }\n \n     #[bench]\n     fn split_closure(bh: &mut BenchHarness) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').len();\n \n-        do bh.iter {\n-            assert_eq!(s.split(|c: char| c == ' ').len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.split(|c: char| c == ' ').len(), len));\n     }\n \n     #[bench]\n     fn split_slice(bh: &mut BenchHarness) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n         let len = s.split(' ').len();\n \n-        do bh.iter {\n-            assert_eq!(s.split(&[' ']).len(), len);\n-        }\n+        bh.iter(|| assert_eq!(s.split(&[' ']).len(), len));\n     }\n \n     #[bench]\n@@ -4004,43 +3966,37 @@ mod bench {\n                         Lorem ipsum dolor sit amet, consectetur. \");\n \n         assert_eq!(100, s.len());\n-        do bh.iter {\n-            is_utf8(s);\n-        }\n+        bh.iter(|| is_utf8(s));\n     }\n \n     #[bench]\n     fn is_utf8_100_multibyte(bh: &mut BenchHarness) {\n         let s = bytes!(\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\");\n         assert_eq!(100, s.len());\n-        do bh.iter {\n-            is_utf8(s);\n-        }\n+        bh.iter(|| is_utf8(s));\n     }\n \n     #[bench]\n     fn bench_with_capacity(bh: &mut BenchHarness) {\n-        do bh.iter {\n-            with_capacity(100);\n-        }\n+        bh.iter(|| with_capacity(100));\n     }\n \n     #[bench]\n     fn bench_push_str(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        do bh.iter {\n+        bh.iter(|| {\n             let mut r = ~\"\";\n             r.push_str(s);\n-        }\n+        });\n     }\n \n     #[bench]\n     fn bench_connect(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n         let sep = \"\u2192\";\n         let v = [s, s, s, s, s, s, s, s, s, s];\n-        do bh.iter {\n+        bh.iter(|| {\n             assert_eq!(v.connect(sep).len(), s.len() * 10 + sep.len() * 9);\n-        }\n+        })\n     }\n }"}, {"sha": "85f66d4ada827bdafd3f64e4d6fbe5cda7c517c5", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -432,12 +432,12 @@ pub fn with_task_name<U>(blk: |Option<&str>| -> U) -> U {\n     use rt::task::Task;\n \n     if in_green_task_context() {\n-        do Local::borrow |task: &mut Task| {\n+        Local::borrow(|task: &mut Task| {\n             match task.name {\n                 Some(ref name) => blk(Some(name.as_slice())),\n                 None => blk(None)\n             }\n-        }\n+        })\n     } else {\n         fail!(\"no task name exists in non-green task context\")\n     }\n@@ -459,9 +459,7 @@ pub fn failing() -> bool {\n \n     use rt::task::Task;\n \n-    do Local::borrow |local: &mut Task| {\n-        local.unwinder.unwinding\n-    }\n+    Local::borrow(|local: &mut Task| local.unwinder.unwinding)\n }\n \n // The following 8 tests test the following 2^3 combinations:"}, {"sha": "d81fe0c2fbd8a87460b988b17a428a350a0eb106", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -369,12 +369,12 @@ impl<A:IterBytes> ToBytes for A {\n         use io::mem;\n         use io::Writer;\n \n-        do mem::with_mem_writer |wr| {\n-            do self.iter_bytes(lsb0) |bytes| {\n+        mem::with_mem_writer(|wr| {\n+            self.iter_bytes(lsb0, |bytes| {\n                 wr.write(bytes);\n                 true\n-            };\n-        }\n+            });\n+        })\n     }\n }\n "}, {"sha": "8b534d7d3bebe43c957759e057b7baa2167bd545", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -489,7 +489,7 @@ pub struct TrieSetIterator<'self> {\n \n impl<'self> Iterator<uint> for TrieSetIterator<'self> {\n     fn next(&mut self) -> Option<uint> {\n-        do self.iter.next().map |(key, _)| { key }\n+        self.iter.next().map(|(key, _)| key)\n     }\n \n     fn size_hint(&self) -> (uint, Option<uint>) {\n@@ -594,12 +594,12 @@ mod test_map {\n         assert!(m.insert(1, 2));\n \n         let mut n = 0;\n-        do m.each |k, v| {\n+        m.each(|k, v| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n += 1;\n             true\n-        };\n+        });\n     }\n \n     #[test]\n@@ -611,7 +611,7 @@ mod test_map {\n         }\n \n         let mut n = uint::max_value - 10000;\n-        do m.each |k, v| {\n+        m.each(|k, v| {\n             if n == uint::max_value - 5000 { false } else {\n                 assert!(n < uint::max_value - 5000);\n \n@@ -620,7 +620,7 @@ mod test_map {\n                 n += 1;\n                 true\n             }\n-        };\n+        });\n     }\n \n     #[test]\n@@ -634,12 +634,12 @@ mod test_map {\n         assert!(m.insert(1, 2));\n \n         let mut n = 4;\n-        do m.each_reverse |k, v| {\n+        m.each_reverse(|k, v| {\n             assert_eq!(*k, n);\n             assert_eq!(*v, n * 2);\n             n -= 1;\n             true\n-        };\n+        });\n     }\n \n     #[test]\n@@ -651,7 +651,7 @@ mod test_map {\n         }\n \n         let mut n = uint::max_value - 1;\n-        do m.each_reverse |k, v| {\n+        m.each_reverse(|k, v| {\n             if n == uint::max_value - 5000 { false } else {\n                 assert!(n > uint::max_value - 5000);\n \n@@ -660,7 +660,7 @@ mod test_map {\n                 n -= 1;\n                 true\n             }\n-        };\n+        });\n     }\n \n     #[test]\n@@ -777,11 +777,11 @@ mod test_set {\n \n         let mut i = 0;\n \n-        do trie.each |x| {\n+        trie.each(|x| {\n             assert_eq!(expected[i], *x);\n             i += 1;\n             true\n-        };\n+        });\n     }\n \n     #[test]"}, {"sha": "ac4bc5754fb18ff271631a43cd2c4a88267caf2b", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -19,11 +19,11 @@ pub mod general_category {\n         use cmp::{Equal, Less, Greater};\n         use vec::ImmutableVector;\n         use option::None;\n-        (do r.bsearch |&(lo,hi)| {\n+        (r.bsearch(|&(lo,hi)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n-        }) != None\n+        })) != None\n     }\n \n \n@@ -3663,11 +3663,11 @@ pub mod derived_property {\n         use cmp::{Equal, Less, Greater};\n         use vec::ImmutableVector;\n         use option::None;\n-        (do r.bsearch |&(lo,hi)| {\n+        (r.bsearch(|&(lo,hi)| {\n             if lo <= c && c <= hi { Equal }\n             else if hi < c { Less }\n             else { Greater }\n-        }) != None\n+        })) != None\n     }\n \n "}, {"sha": "2a6e40dc3a0df93870ca30f9c6929a9f794f9f7e", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -27,11 +27,11 @@ pub struct DynamicLibrary { priv handle: *libc::c_void }\n \n impl Drop for DynamicLibrary {\n     fn drop(&mut self) {\n-        match do dl::check_for_errors_in {\n+        match dl::check_for_errors_in(|| {\n             unsafe {\n                 dl::close(self.handle)\n             }\n-        } {\n+        }) {\n             Ok(()) => {},\n             Err(str) => fail!(\"{}\", str)\n         }\n@@ -43,12 +43,12 @@ impl DynamicLibrary {\n     /// handle to the calling process\n     pub fn open(filename: Option<&path::Path>) -> Result<DynamicLibrary, ~str> {\n         unsafe {\n-            let maybe_library = do dl::check_for_errors_in {\n+            let maybe_library = dl::check_for_errors_in(|| {\n                 match filename {\n                     Some(name) => dl::open_external(name),\n                     None => dl::open_internal()\n                 }\n-            };\n+            });\n \n             // The dynamic library must not be constructed if there is\n             // an error opening the library so the destructor does not\n@@ -65,11 +65,11 @@ impl DynamicLibrary {\n         // This function should have a lifetime constraint of 'self on\n         // T but that feature is still unimplemented\n \n-        let maybe_symbol_value = do dl::check_for_errors_in {\n-            do symbol.with_c_str |raw_string| {\n+        let maybe_symbol_value = dl::check_for_errors_in(|| {\n+            symbol.with_c_str(|raw_string| {\n                 dl::symbol(self.handle, raw_string)\n-            }\n-        };\n+            })\n+        });\n \n         // The value must not be constructed if there is an error so\n         // the destructor does not run.\n@@ -144,9 +144,9 @@ pub mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n-        do filename.with_c_str |raw_name| {\n+        filename.with_c_str(|raw_name| {\n             dlopen(raw_name, Lazy as libc::c_int)\n-        }\n+        })\n     }\n \n     pub unsafe fn open_internal() -> *libc::c_void {\n@@ -162,7 +162,7 @@ pub mod dl {\n             // would cause this task to be descheduled, which could deadlock\n             // the scheduler if it happens while the lock is held.\n             // FIXME #9105 use a Rust mutex instead of C++ mutexes.\n-            do atomically {\n+            atomically(|| {\n                 lock.lock();\n                 let _old_error = dlerror();\n \n@@ -176,7 +176,7 @@ pub mod dl {\n                 };\n                 lock.unlock();\n                 ret\n-            }\n+            })\n         }\n     }\n \n@@ -213,9 +213,9 @@ pub mod dl {\n     use result::*;\n \n     pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n-        do os::win32::as_utf16_p(filename.as_str().unwrap()) |raw_name| {\n+        os::win32::as_utf16_p(filename.as_str().unwrap(), |raw_name| {\n             LoadLibraryW(raw_name)\n-        }\n+        })\n     }\n \n     pub unsafe fn open_internal() -> *libc::c_void {\n@@ -226,7 +226,7 @@ pub mod dl {\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n         unsafe {\n-            do atomically {\n+            atomically(|| {\n                 SetLastError(0);\n \n                 let result = f();\n@@ -237,7 +237,7 @@ pub mod dl {\n                 } else {\n                     Err(format!(\"Error code {}\", error))\n                 }\n-            }\n+            })\n         }\n     }\n "}, {"sha": "06f9ba65ae77331e014ffcf4e1c4bf3feb9abd5f", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -27,9 +27,7 @@ pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n pub fn fail_bounds_check(file: *c_char, line: size_t, index: size_t, len: size_t) -> ! {\n     let msg = format!(\"index out of bounds: the len is {} but the index is {}\",\n                       len as uint, index as uint);\n-    do msg.with_c_str |buf| {\n-        fail_(buf, file, line);\n-    }\n+    msg.with_c_str(|buf| fail_(buf, file, line))\n }\n \n #[lang=\"malloc\"]"}, {"sha": "1f243d08243dbbbb2e94a06405aa5496f6521980", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 19, "deletions": 38, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -134,9 +134,8 @@ impl<T: Send> UnsafeArc<T> {\n     /// If called when the task is already unkillable, unwrap will unkillably\n     /// block; otherwise, an unwrapping task can be killed by linked failure.\n     pub fn unwrap(self) -> T {\n-        let this = Cell::new(self); // argh\n         unsafe {\n-            let mut this = this.take();\n+            let mut this = this;\n             // The ~ dtor needs to run if this code succeeds.\n             let mut data: ~ArcData<T> = cast::transmute(this.data);\n             // Set up the unwrap protocol.\n@@ -164,7 +163,7 @@ impl<T: Send> UnsafeArc<T> {\n                     // Unlike the above one, this cell is necessary. It will get\n                     // taken either in the do block or in the finally block.\n                     let c2_and_data = Cell::new((c2,data));\n-                    do (|| {\n+                    (|| {\n                         p1.take().recv();\n                         // Got here. Back in the 'unkillable' without getting killed.\n                         let (c2, data) = c2_and_data.take();\n@@ -174,7 +173,7 @@ impl<T: Send> UnsafeArc<T> {\n                         // user_data\n                         let mut data = data;\n                         data.data.take_unwrap()\n-                    }).finally {\n+                    }).finally(|| {\n                         if task::failing() {\n                             // Killed during wait. Because this might happen while\n                             // someone else still holds a reference, we can't free\n@@ -185,15 +184,15 @@ impl<T: Send> UnsafeArc<T> {\n                         } else {\n                             assert!(c2_and_data.is_empty());\n                         }\n-                    }\n+                    })\n                 }\n             } else {\n                 // If 'put' returns the server end back to us, we were rejected;\n                 // someone else was trying to unwrap. Avoid guaranteed deadlock.\n                 cast::forget(data);\n                 fail!(\"Another task is already unwrapping this Arc!\");\n             }\n-        }\n+        })\n     }\n \n     /// As unwrap above, but without blocking. Returns 'UnsafeArcSelf(self)' if this is\n@@ -256,8 +255,6 @@ impl<T> Drop for UnsafeArc<T>{\n                 // *awake* task with the data.\n                 match data.unwrapper.take(Acquire) {\n                     Some(~(message,response)) => {\n-                        let cell = Cell::new((message, response, data));\n-                        let (message, response, data) = cell.take();\n                         // Send 'ready' and wait for a response.\n                         message.send(());\n                         // Unkillable wait. Message guaranteed to come.\n@@ -301,12 +298,10 @@ pub unsafe fn atomically<U>(f: || -> U) -> U {\n         Some(t) => {\n             match (*t).task_type {\n                 GreenTask(_) => {\n-                    do (|| {\n+                    (|| {\n                         (*t).death.inhibit_deschedule();\n                         f()\n-                    }).finally {\n-                        (*t).death.allow_deschedule();\n-                    }\n+                    }).finally(|| (*t).death.allow_deschedule())\n                 }\n                 SchedTask => f()\n             }\n@@ -425,9 +420,7 @@ impl<T:Send> Exclusive<T> {\n \n     #[inline]\n     pub unsafe fn with_imm<U>(&self, f: |x: &T| -> U) -> U {\n-        do self.with |x| {\n-            f(cast::transmute_immut(x))\n-        }\n+        self.with(|x| f(cast::transmute_immut(x)))\n     }\n \n     #[inline]\n@@ -469,7 +462,6 @@ impl<T:Send> Exclusive<T> {\n \n #[cfg(test)]\n mod tests {\n-    use cell::Cell;\n     use comm;\n     use option::*;\n     use prelude::*;\n@@ -489,7 +481,7 @@ mod tests {\n     fn test_atomically() {\n         // NB. The whole runtime will abort on an 'atomic-sleep' violation,\n         // so we can't really test for the converse behaviour.\n-        unsafe { do atomically { } } task::deschedule(); // oughtn't fail\n+        unsafe { atomically(|| ()) } task::deschedule(); // oughtn't fail\n     }\n \n     #[test]\n@@ -509,19 +501,15 @@ mod tests {\n \n                 do task::spawn || {\n                     for _ in range(0u, count) {\n-                        do total.with |count| {\n-                            **count += 1;\n-                        }\n+                        total.with(|count| **count += 1);\n                     }\n                     chan.send(());\n                 }\n             };\n \n             for f in futures.iter() { f.recv() }\n \n-            do total.with |total| {\n-                assert!(**total == num_tasks * count)\n-            };\n+            total.with(|total| assert!(**total == num_tasks * count));\n         }\n     }\n \n@@ -533,13 +521,9 @@ mod tests {\n             let x = Exclusive::new(1);\n             let x2 = x.clone();\n             do task::try || {\n-                do x2.with |one| {\n-                    assert_eq!(*one, 2);\n-                }\n+                x2.with(|one| assert_eq!(*one, 2))\n             };\n-            do x.with |one| {\n-                assert_eq!(*one, 1);\n-            }\n+            x.with(|one| assert_eq!(*one, 1));\n         }\n     }\n \n@@ -595,11 +579,11 @@ mod tests {\n     fn arclike_try_unwrap_unwrap_race() {\n         // When an unwrap and a try_unwrap race, the unwrapper should always win.\n         let x = UnsafeArc::new(~~\"hello\");\n-        let x2 = Cell::new(x.clone());\n+        let x2 = x.clone();\n         let (p,c) = comm::stream();\n         do task::spawn {\n             c.send(());\n-            assert!(x2.take().unwrap() == ~~\"hello\");\n+            assert!(x2.unwrap() == ~~\"hello\");\n             c.send(());\n         }\n         p.recv();\n@@ -620,21 +604,19 @@ mod tests {\n     #[test]\n     fn exclusive_new_unwrap_contended() {\n         let x = Exclusive::new(~~\"hello\");\n-        let x2 = Cell::new(x.clone());\n+        let x2 = x.clone();\n         do task::spawn {\n-            let x2 = x2.take();\n-            unsafe { do x2.with |_hello| { } }\n+            unsafe { x2.with(|_hello| ()); }\n             task::deschedule();\n         }\n         assert!(x.unwrap() == ~~\"hello\");\n \n         // Now try the same thing, but with the child task blocking.\n         let x = Exclusive::new(~~\"hello\");\n-        let x2 = Cell::new(x.clone());\n+        let x2 = x.clone();\n         let mut builder = task::task();\n         let res = builder.future_result();\n         do builder.spawn {\n-            let x2 = x2.take();\n             assert!(x2.unwrap() == ~~\"hello\");\n         }\n         // Have to get rid of our reference before blocking.\n@@ -645,11 +627,10 @@ mod tests {\n     #[test] #[should_fail]\n     fn exclusive_new_unwrap_conflict() {\n         let x = Exclusive::new(~~\"hello\");\n-        let x2 = Cell::new(x.clone());\n+        let x2 = x.clone();\n         let mut builder = task::task();\n         let res = builder.future_result();\n         do builder.spawn {\n-            let x2 = x2.take();\n             assert!(x2.unwrap() == ~~\"hello\");\n         }\n         assert!(x.unwrap() == ~~\"hello\");"}, {"sha": "30627327d732755988e8c8da4375187cb469862a", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 46, "deletions": 50, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eca34de7dd55719cd83153994e5caf2027f62a2/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=1eca34de7dd55719cd83153994e5caf2027f62a2", "patch": "@@ -137,14 +137,14 @@ pub fn from_fn<T>(n_elts: uint, op: |uint| -> T) -> ~[T] {\n         let mut v = with_capacity(n_elts);\n         let p = raw::to_mut_ptr(v);\n         let mut i: uint = 0u;\n-        do (|| {\n+        (|| {\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)), op(i));\n                 i += 1u;\n             }\n-        }).finally {\n+        }).finally(|| {\n             raw::set_len(&mut v, i);\n-        }\n+        });\n         v\n     }\n }\n@@ -164,14 +164,14 @@ pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> ~[T] {\n         let mut v = with_capacity(n_elts);\n         let p = raw::to_mut_ptr(v);\n         let mut i = 0u;\n-        do (|| {\n+        (|| {\n             while i < n_elts {\n                 intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)), t.clone());\n                 i += 1u;\n             }\n-        }).finally {\n+        }).finally(|| {\n             raw::set_len(&mut v, i);\n-        }\n+        });\n         v\n     }\n }\n@@ -982,14 +982,14 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     fn slice(&self, start: uint, end: uint) -> &'self [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n-        do self.as_imm_buf |p, _len| {\n+        self.as_imm_buf(|p, _len| {\n             unsafe {\n                 cast::transmute(Slice {\n                     data: ptr::offset(p, start as int),\n                     len: (end - start)\n                 })\n             }\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -1639,15 +1639,15 @@ impl<T> OwnedVector<T> for ~[T] {\n         self.pop()\n     }\n     fn truncate(&mut self, newlen: uint) {\n-        do self.as_mut_buf |p, oldlen| {\n+        self.as_mut_buf(|p, oldlen| {\n             assert!(newlen <= oldlen);\n             unsafe {\n                 // This loop is optimized out for non-drop types.\n                 for i in range(newlen, oldlen) {\n                     ptr::read_and_zero_ptr(ptr::mut_offset(p, i as int));\n                 }\n             }\n-        }\n+        });\n         unsafe { raw::set_len(self, newlen); }\n     }\n \n@@ -1932,14 +1932,14 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n-        do self.as_mut_buf |p, _len| {\n+        self.as_mut_buf(|p, _len| {\n             unsafe {\n                 cast::transmute(Slice {\n                     data: ptr::mut_offset(p, start as int) as *T,\n                     len: (end - start)\n                 })\n             }\n-        }\n+        })\n     }\n \n     #[inline]\n@@ -2153,10 +2153,10 @@ pub mod raw {\n     #[inline]\n     pub unsafe fn init_elem<T>(v: &mut [T], i: uint, val: T) {\n         let mut box = Some(val);\n-        do v.as_mut_buf |p, _len| {\n+        v.as_mut_buf(|p, _len| {\n             intrinsics::move_val_init(&mut(*ptr::mut_offset(p, i as int)),\n                                       box.take_unwrap());\n-        }\n+        })\n     }\n \n     /**\n@@ -2188,11 +2188,11 @@ pub mod raw {\n         assert!(dst.len() >= count);\n         assert!(src.len() >= count);\n \n-        do dst.as_mut_buf |p_dst, _len_dst| {\n-            do src.as_imm_buf |p_src, _len_src| {\n+        dst.as_mut_buf(|p_dst, _len_dst| {\n+            src.as_imm_buf(|p_src, _len_src| {\n                 ptr::copy_memory(p_dst, p_src, count)\n-            }\n-        }\n+            })\n+        })\n     }\n }\n \n@@ -2213,9 +2213,9 @@ pub mod bytes {\n     impl<'self> MutableByteVector for &'self mut [u8] {\n         #[inline]\n         fn set_memory(self, value: u8) {\n-            do self.as_mut_buf |p, len| {\n+            self.as_mut_buf(|p, len| {\n                 unsafe { ptr::set_memory(p, value, len) };\n-            }\n+            })\n         }\n     }\n \n@@ -2278,11 +2278,11 @@ pub mod bytes {\n         let old_len = dst.len();\n         dst.reserve_additional(src.len());\n         unsafe {\n-            do dst.as_mut_buf |p_dst, len_dst| {\n-                do src.as_imm_buf |p_src, len_src| {\n+            dst.as_mut_buf(|p_dst, len_dst| {\n+                src.as_imm_buf(|p_src, len_src| {\n                     ptr::copy_memory(p_dst.offset(len_dst as int), p_src, len_src)\n-                }\n-            }\n+                })\n+            });\n             vec::raw::set_len(dst, old_len + src.len());\n         }\n     }\n@@ -3276,10 +3276,10 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_from_fn_fail() {\n-        do from_fn(100) |v| {\n+        from_fn(100, |v| {\n             if v == 50 { fail!() }\n             (~0, @0)\n-        };\n+        });\n     }\n \n     #[test]\n@@ -3308,53 +3308,53 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_build_fail() {\n-        do build(None) |push| {\n+        build(None, |push| {\n             push((~0, @0));\n             push((~0, @0));\n             push((~0, @0));\n             push((~0, @0));\n             fail!();\n-        };\n+        });\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_grow_fn_fail() {\n         let mut v = ~[];\n-        do v.grow_fn(100) |i| {\n+        v.grow_fn(100, |i| {\n             if i == 50 {\n                 fail!()\n             }\n             (~0, @0)\n-        }\n+        })\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_map_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do v.map |_elt| {\n+        v.map(|_elt| {\n             if i == 2 {\n                 fail!()\n             }\n             i += 1;\n             ~[(~0, @0)]\n-        };\n+        });\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_flat_map_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do flat_map(v) |_elt| {\n+        flat_map(v, |_elt| {\n             if i == 2 {\n                 fail!()\n             }\n             i += 1;\n             ~[(~0, @0)]\n-        };\n+        });\n     }\n \n     #[test]\n@@ -3374,18 +3374,18 @@ mod tests {\n     #[should_fail]\n     fn test_as_imm_buf_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        do v.as_imm_buf |_buf, _i| {\n+        v.as_imm_buf(|_buf, _i| {\n             fail!()\n-        }\n+        })\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_as_mut_buf_fail() {\n         let mut v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        do v.as_mut_buf |_buf, _i| {\n+        v.as_mut_buf(|_buf, _i| {\n             fail!()\n-        }\n+        })\n     }\n \n     #[test]\n@@ -3843,52 +3843,48 @@ mod bench {\n         // out.\n         let v = vec::from_fn(100, |i| i ^ (i << 1) ^ (i >> 1));\n \n-        do bh.iter {\n+        bh.iter(|| {\n             let mut sum = 0;\n             for x in v.iter() {\n                 sum += *x;\n             }\n             // sum == 11806, to stop dead code elimination.\n             if sum == 0 {fail!()}\n-        }\n+        })\n     }\n \n     #[bench]\n     fn mut_iterator(bh: &mut BenchHarness) {\n         let mut v = vec::from_elem(100, 0);\n \n-        do bh.iter {\n+        bh.iter(|| {\n             let mut i = 0;\n             for x in v.mut_iter() {\n                 *x = i;\n                 i += 1;\n             }\n-        }\n+        })\n     }\n \n     #[bench]\n     fn add(bh: &mut BenchHarness) {\n         let xs: &[int] = [5, ..10];\n         let ys: &[int] = [5, ..10];\n-        do bh.iter() {\n+        bh.iter(|| {\n             xs + ys;\n-        }\n+        });\n     }\n \n     #[bench]\n     fn concat(bh: &mut BenchHarness) {\n         let xss: &[~[uint]] = vec::from_fn(100, |i| range(0, i).collect());\n-        do bh.iter {\n-            xss.concat_vec();\n-        }\n+        bh.iter(|| xss.concat_vec());\n     }\n \n     #[bench]\n     fn connect(bh: &mut BenchHarness) {\n         let xss: &[~[uint]] = vec::from_fn(100, |i| range(0, i).collect());\n-        do bh.iter {\n-            xss.connect_vec(&0);\n-        }\n+        bh.iter(|| xss.connect_vec(&0));\n     }\n \n     #[bench]"}]}