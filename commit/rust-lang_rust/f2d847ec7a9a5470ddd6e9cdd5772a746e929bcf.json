{"sha": "f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZDg0N2VjN2E5YTU0NzBkZGQ2ZTljZGQ1NzcyYTc0NmU5MjliY2Y=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-12T21:07:00Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-12T21:28:11Z"}, "message": "stdlib: Move bit vectors over to interior vectors", "tree": {"sha": "9a59c1a34930e6cd7b56c8e5f47d6e777275843f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a59c1a34930e6cd7b56c8e5f47d6e777275843f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf", "html_url": "https://github.com/rust-lang/rust/commit/f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "043096ea0ab0369fd32210bb9c75bdc9d5820cb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/043096ea0ab0369fd32210bb9c75bdc9d5820cb0", "html_url": "https://github.com/rust-lang/rust/commit/043096ea0ab0369fd32210bb9c75bdc9d5820cb0"}], "stats": {"total": 45, "additions": 32, "deletions": 13}, "files": [{"sha": "536d637562adbd095776632ec8ac780baeeea143", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=f2d847ec7a9a5470ddd6e9cdd5772a746e929bcf", "patch": "@@ -24,21 +24,21 @@ export eq_vec;\n //        an optimizing version of this module that produces a different obj\n //        for the case where nbits <= 32.\n \n-type t = rec(vec[mutable uint] storage, uint nbits);\n+type t = @rec(uint[mutable] storage, uint nbits);\n \n \n // FIXME: this should be a constant once they work\n fn uint_bits() -> uint { ret 32u + (1u << 32u >> 27u); }\n \n fn create(uint nbits, bool init) -> t {\n     auto elt = if (init) { !0u } else { 0u };\n-    auto storage = vec::init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n-    ret rec(storage=storage, nbits=nbits);\n+    auto storage = ivec::init_elt_mut[uint](elt, nbits / uint_bits() + 1u);\n+    ret @rec(storage=storage, nbits=nbits);\n }\n \n fn process(&fn(uint, uint) -> uint  op, &t v0, &t v1) -> bool {\n-    auto len = vec::len(v1.storage);\n-    assert (vec::len(v0.storage) == len);\n+    auto len = ivec::len(v1.storage);\n+    assert (ivec::len(v0.storage) == len);\n     assert (v0.nbits == v1.nbits);\n     auto changed = false;\n     for each (uint i in uint::range(0u, len)) {\n@@ -66,10 +66,10 @@ fn right(uint w0, uint w1) -> uint { ret w1; }\n fn copy(&t v0, t v1) -> bool { auto sub = right; ret process(sub, v0, v1); }\n \n fn clone(t v) -> t {\n-    auto storage = vec::init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n-    auto len = vec::len(v.storage);\n+    auto storage = ivec::init_elt_mut[uint](0u, v.nbits / uint_bits() + 1u);\n+    auto len = ivec::len(v.storage);\n     for each (uint i in uint::range(0u, len)) { storage.(i) = v.storage.(i); }\n-    ret rec(storage=storage, nbits=v.nbits);\n+    ret @rec(storage=storage, nbits=v.nbits);\n }\n \n fn get(&t v, uint i) -> bool {\n@@ -85,7 +85,7 @@ fn equal(&t v0, &t v1) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n \n-    auto len = vec::len(v1.storage);\n+    auto len = ivec::len(v1.storage);\n     auto i = 0u;\n     while (i < len) {\n         if (v0.storage.(i) != v1.storage.(i)) { ret false; }\n@@ -95,7 +95,7 @@ fn equal(&t v0, &t v1) -> bool {\n }\n \n fn clear(&t v) {\n-    for each (uint i in uint::range(0u, vec::len(v.storage))) {\n+    for each (uint i in uint::range(0u, ivec::len(v.storage))) {\n         v.storage.(i) = 0u;\n     }\n }\n@@ -105,7 +105,7 @@ fn set_all(&t v) {\n }\n \n fn invert(&t v) {\n-    for each (uint i in uint::range(0u, vec::len(v.storage))) {\n+    for each (uint i in uint::range(0u, ivec::len(v.storage))) {\n         v.storage.(i) = !v.storage.(i);\n     }\n }\n@@ -132,14 +132,14 @@ fn set(&t v, uint i, bool x) {\n \n /* true if all bits are 1 */\n fn is_true(&t v) -> bool {\n-    for (uint i in to_vec(v)) { if (i != 1u) { ret false; } }\n+    for (uint i in to_ivec(v)) { if (i != 1u) { ret false; } }\n     ret true;\n }\n \n \n /* true if all bits are non-1 */\n fn is_false(&t v) -> bool {\n-    for (uint i in to_vec(v)) { if (i == 1u) { ret false; } }\n+    for (uint i in to_ivec(v)) { if (i == 1u) { ret false; } }\n     ret true;\n }\n \n@@ -150,6 +150,11 @@ fn to_vec(&t v) -> vec[uint] {\n     ret vec::init_fn[uint](sub, v.nbits);\n }\n \n+fn to_ivec(&t v) -> uint[] {\n+    auto sub = bind init_to_vec(v, _);\n+    ret ivec::init_fn[uint](sub, v.nbits);\n+}\n+\n fn to_str(&t v) -> str {\n     auto rs = \"\";\n     for (uint i in bitv::to_vec(v)) {\n@@ -172,6 +177,20 @@ fn eq_vec(&t v0, &vec[uint] v1) -> bool {\n     }\n     ret true;\n }\n+\n+fn eq_ivec(&t v0, &uint[] v1) -> bool {\n+    assert (v0.nbits == ivec::len[uint](v1));\n+    auto len = v0.nbits;\n+    auto i = 0u;\n+    while (i < len) {\n+        auto w0 = get(v0, i);\n+        auto w1 = v1.(i);\n+        if (!w0 && w1 != 0u || w0 && w1 == 0u) { ret false; }\n+        i = i + 1u;\n+    }\n+    ret true;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}]}