{"sha": "8b7a41f23d421bb4d0dd0ef33be147dc5d065967", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiN2E0MWYyM2Q0MjFiYjRkMGRkMGVmMzNiZTE0N2RjNWQwNjU5Njc=", "commit": {"author": {"name": "Elly Jones", "email": "elly@leptoquark.net", "date": "2011-12-17T03:08:25Z"}, "committer": {"name": "Elly Jones", "email": "elly@leptoquark.net", "date": "2011-12-17T03:08:25Z"}, "message": "cargo: Support distributed package indexes.\n\nIndexes are listed in ~/.cargo/sources.json and ~/.cargo/local-sources.json, the\nformer of which is stored in the rust source tree in src/cargo. Each entry in\neither of these files is a source, which is a dictionary with (currently) a\nsingle key, \"url\". The supplied url should point to a json list, each element of\nwhich should be a dictionary with four keys: \"name\", \"uuid\", \"url\", and\n\"method\". The name and uuid serve to identify the package; the method describes\nhow to fetch the package; the url describes where to fetch it from. Currently\nsupported methods are \"git\", \"http\", and \"file\".\n\nSigned-off-by: Elly Jones <elly@leptoquark.net>", "tree": {"sha": "b82235b338a4f96a9f5561c9c1f9cf637776e6b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b82235b338a4f96a9f5561c9c1f9cf637776e6b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8b7a41f23d421bb4d0dd0ef33be147dc5d065967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8b7a41f23d421bb4d0dd0ef33be147dc5d065967", "html_url": "https://github.com/rust-lang/rust/commit/8b7a41f23d421bb4d0dd0ef33be147dc5d065967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8b7a41f23d421bb4d0dd0ef33be147dc5d065967/comments", "author": null, "committer": null, "parents": [{"sha": "10cf4a1b0a90787ed50f3153f481e7128cffbec7", "url": "https://api.github.com/repos/rust-lang/rust/commits/10cf4a1b0a90787ed50f3153f481e7128cffbec7", "html_url": "https://github.com/rust-lang/rust/commit/10cf4a1b0a90787ed50f3153f481e7128cffbec7"}], "stats": {"total": 171, "additions": 135, "deletions": 36}, "files": [{"sha": "0445765a77c8477365bba29da356c9528ca778c2", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 130, "deletions": 36, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/8b7a41f23d421bb4d0dd0ef33be147dc5d065967/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8b7a41f23d421bb4d0dd0ef33be147dc5d065967/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=8b7a41f23d421bb4d0dd0ef33be147dc5d065967", "patch": "@@ -26,10 +26,11 @@ tag _src {\n }\n \n type package = {\n-    source: _src,\n+//    source: _src,\n     name: str,\n     uuid: str,\n-    url: str\n+    url: str,\n+    method: str\n };\n \n type source = {\n@@ -64,6 +65,10 @@ fn warn(msg: str) {\n     io::stdout().write_line(\"warning: \" + msg);\n }\n \n+fn error(msg: str) {\n+    io::stdout().write_line(\"error: \" + msg);\n+}\n+\n fn load_link(mis: [@ast::meta_item]) -> (option::t<str>,\n                                          option::t<str>,\n                                          option::t<str>) {\n@@ -179,7 +184,7 @@ fn try_parse_sources(filename: str, sources: map::hashmap<str, source>) {\n     }\n }\n \n-fn load_one_source_package(c: cargo, src: source, p: map::hashmap<str, json::json>) {\n+fn load_one_source_package(&c: cargo, &src: source, p: map::hashmap<str, json::json>) {\n     let name = alt p.find(\"name\") {\n         some(json::string(_n)) { _n }\n         _ {\n@@ -204,16 +209,25 @@ fn load_one_source_package(c: cargo, src: source, p: map::hashmap<str, json::jso\n         }\n     };\n \n+    let method = alt p.find(\"method\") {\n+        some(json::string(_n)) { _n }\n+        _ {\n+            warn(\"Malformed source json: \" + src.name + \" (missing method)\");\n+            ret;\n+        }\n+    };\n+\n     vec::grow(src.packages, 1u, {\n-        source: _source(src),\n+        // source: _source(src),\n         name: name,\n         uuid: uuid,\n-        url: url\n+        url: url,\n+        method: method\n     });\n     info(\"  Loaded package: \" + src.name + \"/\" + name);\n }\n \n-fn load_source_packages(c: cargo, src: source) {\n+fn load_source_packages(&c: cargo, &src: source) {\n     info(\"Loading source: \" + src.name);\n     let dir = fs::connect(c.sourcedir, src.name);\n     let pkgfile = fs::connect(dir, \"packages.json\");\n@@ -229,7 +243,6 @@ fn load_source_packages(c: cargo, src: source) {\n                     }\n                     _ {\n                         warn(\"Malformed source json: \" + src.name + \" (non-dict pkg)\");\n-                        ret;\n                     }\n                 }\n             }\n@@ -269,17 +282,19 @@ fn configure() -> cargo {\n     need_dir(c.libdir);\n     need_dir(c.bindir);\n \n-    sources.values { |v|\n-        load_source_packages(c, v);\n+    sources.keys { |k|\n+        let s = sources.get(k);\n+        load_source_packages(c, s);\n+        sources.insert(k, s);\n     };\n \n     c\n }\n \n-fn for_each_package(c: cargo, b: block(package)) {\n+fn for_each_package(c: cargo, b: block(source, package)) {\n     c.sources.values({ |v|\n         for p in v.packages {\n-            b(p);\n+            b(v, p);\n         }\n     })\n }\n@@ -335,14 +350,25 @@ fn install_source(c: cargo, path: str) {\n     }\n }\n \n-fn install_git(c: cargo, wd: str, _path: str) {\n-    run::run_program(\"git\", [\"clone\", _path, wd]);\n+fn install_git(c: cargo, wd: str, url: str) {\n+    run::run_program(\"git\", [\"clone\", url, wd]);\n     install_source(c, wd);\n }\n \n-fn install_file(c: cargo, wd: str, _path: str) {\n+fn install_curl(c: cargo, wd: str, url: str) {\n+    let tarpath = fs::connect(wd, \"pkg.tar\");\n+    let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\",\n+                                         tarpath, url]);\n+    if p.status != 0 {\n+        fail #fmt[\"Fetch of %s failed: %s\", url, p.err];\n+    }\n     run::run_program(\"tar\", [\"-x\", \"--strip-components=1\",\n-                             \"-C\", wd, \"-f\", _path]);\n+                             \"-C\", wd, \"-f\", tarpath]);\n+}\n+\n+fn install_file(c: cargo, wd: str, path: str) {\n+    run::run_program(\"tar\", [\"-x\", \"--strip-components=1\",\n+                             \"-C\", wd, \"-f\", path]);\n     install_source(c, wd);\n }\n \n@@ -368,30 +394,90 @@ fn install_resolved(c: cargo, wd: str, key: str) {\n     }\n }\n \n+fn install_package(c: cargo, wd: str, pkg: package) {\n+    info(\"Installing with \" + pkg.method + \" from \" + pkg.url + \"...\");\n+    if pkg.method == \"git\" {\n+        install_git(c, wd, pkg.url);\n+    } else if pkg.method == \"http\" {\n+        install_curl(c, wd, pkg.url);\n+    } else if pkg.method == \"file\" {\n+        install_file(c, wd, pkg.url);\n+    }\n+}\n+\n fn install_uuid(c: cargo, wd: str, uuid: str) {\n     let ps = [];\n-    for_each_package(c, { |p|\n+    for_each_package(c, { |s, p|\n+        info(#fmt[\"%s ? %s\", p.uuid, uuid]);\n         if p.uuid == uuid {\n-            vec::grow(ps, 1u, p);\n+            vec::grow(ps, 1u, (s, p));\n         }\n     });\n-    info(\"Found:\");\n-    for p in ps {\n-        info(\"  \" + p.source.name + \"/\" + p.name);\n+    if vec::len(ps) == 1u {\n+        let (s, p) = ps[0];\n+        install_package(c, wd, p);\n+        ret;\n+    } else if vec::len(ps) == 0u {\n+        error(\"No packages.\");\n+        ret;\n+    }\n+    error(\"Found multiple packages:\");\n+    for (s,p) in ps {\n+        info(\"  \" + s.name + \"/\" + p.uuid + \" (\" + p.name + \")\");\n     }\n }\n \n fn install_named(c: cargo, wd: str, name: str) {\n     let ps = [];\n-    for_each_package(c, { |p|\n+    for_each_package(c, { |s, p|\n         if p.name == name {\n-            vec::grow(ps, 1u, p);\n+            vec::grow(ps, 1u, (s, p));\n         }\n     });\n-    info(\"Found:\");\n-    for p in ps {\n-        info(\"  \" + p.source.name + \"/\" + p.name);\n+    if vec::len(ps) == 1u {\n+        let (s, p) = ps[0];\n+        install_package(c, wd, p);\n+        ret;\n+    } else if vec::len(ps) == 0u {\n+        error(\"No packages.\");\n+        ret;\n+    }\n+    error(\"Found multiple packages:\");\n+    for (s,p) in ps {\n+        info(\"  \" + s.name + \"/\" + p.uuid + \" (\" + p.name + \")\");\n+    }\n+}\n+\n+fn install_uuid_specific(c: cargo, wd: str, src: str, uuid: str) {\n+    alt c.sources.find(src) {\n+        some(s) {\n+            if vec::any(s.packages, { |p|\n+                if p.uuid == uuid {\n+                    install_package(c, wd, p);\n+                    ret true;\n+                }\n+                ret false;\n+            }) { ret; }\n+        }\n+        _ { }\n     }\n+    error(\"Can't find package \" + src + \"/\" + uuid);\n+}\n+\n+fn install_named_specific(c: cargo, wd: str, src: str, name: str) {\n+    alt c.sources.find(src) {\n+        some(s) {\n+            if vec::any(s.packages, { |p|\n+                if p.name == name {\n+                    install_package(c, wd, p);\n+                    ret true;\n+                }\n+                ret false;\n+            }) { ret; }\n+        }\n+        _ { }\n+    }\n+    error(\"Can't find package \" + src + \"/\" + name);\n }\n \n fn cmd_install(c: cargo, argv: [str]) {\n@@ -406,19 +492,26 @@ fn cmd_install(c: cargo, argv: [str]) {\n         none. { fail \"needed temp dir\"; }\n     };\n \n-    if str::starts_with(argv[2], \"git:\") {\n-        install_git(c, wd, argv[2]);\n-    } else if str::starts_with(argv[2], \"github:\") {\n-        let path = rest(argv[2], 7u);\n-        install_git(c, wd, \"git://github.com/\" + path);\n-    } else if str::starts_with(argv[2], \"file:\") {\n-        let path = rest(argv[2], 5u);\n-        install_file(c, wd, path);\n-    } else if str::starts_with(argv[2], \"uuid:\") {\n+    if str::starts_with(argv[2], \"uuid:\") {\n         let uuid = rest(argv[2], 5u);\n-        install_uuid(c, wd, uuid);\n+        let idx = str::index(uuid, '/' as u8);\n+        if idx != -1 {\n+            let source = str::slice(uuid, 0u, idx as uint);\n+            uuid = str::slice(uuid, idx as uint + 1u, str::byte_len(uuid));\n+            install_uuid_specific(c, wd, source, uuid);\n+        } else {\n+            install_uuid(c, wd, uuid);\n+        }\n     } else {\n-        install_named(c, wd, argv[2]);\n+        let name = argv[2];\n+        let idx = str::index(name, '/' as u8);\n+        if idx != -1 {\n+            let source = str::slice(name, 0u, idx as uint);\n+            name = str::slice(name, idx as uint + 1u, str::byte_len(name));\n+            install_named_specific(c, wd, source, name);\n+        } else {\n+            install_named(c, wd, name);\n+        }\n     }\n }\n \n@@ -427,6 +520,7 @@ fn sync_one(c: cargo, name: str, src: source) {\n     let pkgfile = fs::connect(dir, \"packages.json\");\n     let url = src.url;\n     need_dir(dir);\n+    info(#fmt[\"fetching source %s...\", name]);\n     let p = run::program_output(\"curl\", [\"-f\", \"-s\", \"-o\", pkgfile, url]);\n     if p.status != 0 {\n         warn(#fmt[\"fetch for source %s (url %s) failed\", name, url]);"}, {"sha": "c76f133e8f21be236cdc72f71d20b271f797e05d", "filename": "src/cargo/sources.json", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8b7a41f23d421bb4d0dd0ef33be147dc5d065967/src%2Fcargo%2Fsources.json", "raw_url": "https://github.com/rust-lang/rust/raw/8b7a41f23d421bb4d0dd0ef33be147dc5d065967/src%2Fcargo%2Fsources.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fsources.json?ref=8b7a41f23d421bb4d0dd0ef33be147dc5d065967", "patch": "@@ -0,0 +1,5 @@\n+{\n+\t\"elly\": {\n+\t\t\"url\": \"https://raw.github.com/elly/rust-packages/master/packages.json\"\n+\t}\n+}"}]}