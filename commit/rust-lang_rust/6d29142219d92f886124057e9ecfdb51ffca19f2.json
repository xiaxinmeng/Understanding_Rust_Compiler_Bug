{"sha": "6d29142219d92f886124057e9ecfdb51ffca19f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkMjkxNDIyMTlkOTJmODg2MTI0MDU3ZTllY2ZkYjUxZmZjYTE5ZjI=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-09-01T19:44:07Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-10-16T03:10:11Z"}, "message": "path2: Extract posix/windows into their own files\n\nMove PosixPath into posix::Path.", "tree": {"sha": "872594a3d1b4e7181597f374baec15ebbeb11992", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/872594a3d1b4e7181597f374baec15ebbeb11992"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d29142219d92f886124057e9ecfdb51ffca19f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d29142219d92f886124057e9ecfdb51ffca19f2", "html_url": "https://github.com/rust-lang/rust/commit/6d29142219d92f886124057e9ecfdb51ffca19f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d29142219d92f886124057e9ecfdb51ffca19f2/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17ca6f0dfac37196ae1fa8e4d7674431534437d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/17ca6f0dfac37196ae1fa8e4d7674431534437d3", "html_url": "https://github.com/rust-lang/rust/commit/17ca6f0dfac37196ae1fa8e4d7674431534437d3"}], "stats": {"total": 3332, "additions": 1693, "deletions": 1639}, "files": [{"sha": "c10b6eeeda8300fa49c9ca098cf7485a8d39ccb2", "filename": "src/libstd/path2.rs", "status": "removed", "additions": 0, "deletions": 1639, "changes": 1639, "blob_url": "https://github.com/rust-lang/rust/blob/17ca6f0dfac37196ae1fa8e4d7674431534437d3/src%2Flibstd%2Fpath2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17ca6f0dfac37196ae1fa8e4d7674431534437d3/src%2Flibstd%2Fpath2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2.rs?ref=17ca6f0dfac37196ae1fa8e4d7674431534437d3", "patch": "@@ -1,1639 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Cross-platform file path handling (re-write)\n-\n-use container::Container;\n-use c_str::{CString, ToCStr};\n-use clone::Clone;\n-use cmp::Eq;\n-use from_str::FromStr;\n-use iterator::{AdditiveIterator, Extendable, Iterator};\n-use option::{Option, None, Some};\n-use str;\n-use str::{OwnedStr, Str, StrSlice};\n-use util;\n-use vec;\n-use vec::{CopyableVector, OwnedCopyableVector, OwnedVector};\n-use vec::{ImmutableEqVector, ImmutableVector, Vector, VectorVector};\n-\n-/// Typedef for the platform-native path type\n-#[cfg(unix)]\n-pub type Path = PosixPath;\n-// /// Typedef for the platform-native path type\n-//#[cfg(windows)]\n-//pub type Path = WindowsPath;\n-\n-/// Typedef for the platform-native component iterator\n-#[cfg(unix)]\n-pub type ComponentIter<'self> = PosixComponentIter<'self>;\n-// /// Typedef for the platform-native component iterator\n-//#[cfg(windows)]\n-//pub type ComponentIter<'self> = WindowsComponentIter<'self>;\n-\n-/// Iterator that yields successive components of a PosixPath\n-type PosixComponentIter<'self> = vec::SplitIterator<'self, u8>;\n-\n-// Condition that is raised when a NUL is found in a byte vector given to a Path function\n-condition! {\n-    // this should be a &[u8] but there's a lifetime issue\n-    null_byte: ~[u8] -> ~[u8];\n-}\n-\n-/// Represents a POSIX file path\n-#[deriving(Clone, DeepClone)]\n-pub struct PosixPath {\n-    priv repr: ~[u8], // assumed to never be empty or contain NULs\n-    priv sepidx: Option<uint> // index of the final separator in repr\n-}\n-\n-impl Eq for PosixPath {\n-    fn eq(&self, other: &PosixPath) -> bool {\n-        self.repr == other.repr\n-    }\n-}\n-\n-impl FromStr for PosixPath {\n-    fn from_str(s: &str) -> Option<PosixPath> {\n-        let v = s.as_bytes();\n-        if contains_nul(v) {\n-            None\n-        } else {\n-            Some(unsafe { GenericPathUnsafe::from_vec_unchecked(v) })\n-        }\n-    }\n-}\n-\n-/// A trait that represents the generic operations available on paths\n-pub trait GenericPath: Clone + GenericPathUnsafe {\n-    /// Creates a new Path from a byte vector.\n-    /// The resulting Path will always be normalized.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the path contains a NUL.\n-    #[inline]\n-    fn from_vec(path: &[u8]) -> Self {\n-        if contains_nul(path) {\n-            let path = self::null_byte::cond.raise(path.to_owned());\n-            assert!(!contains_nul(path));\n-            unsafe { GenericPathUnsafe::from_vec_unchecked(path) }\n-        } else {\n-            unsafe { GenericPathUnsafe::from_vec_unchecked(path) }\n-        }\n-    }\n-\n-    /// Creates a new Path from a string.\n-    /// The resulting Path will always be normalized.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the path contains a NUL.\n-    #[inline]\n-    fn from_str(path: &str) -> Self {\n-        GenericPath::from_vec(path.as_bytes())\n-    }\n-\n-    /// Creates a new Path from a CString.\n-    /// The resulting Path will always be normalized.\n-    #[inline]\n-    fn from_c_str(path: CString) -> Self {\n-        // CStrings can't contain NULs\n-        unsafe { GenericPathUnsafe::from_vec_unchecked(path.as_bytes()) }\n-    }\n-\n-    /// Returns the path as a string, if possible.\n-    /// If the path is not representable in utf-8, this returns None.\n-    #[inline]\n-    fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_bytes_slice_opt(self.as_vec())\n-    }\n-\n-    /// Returns the path as a byte vector\n-    fn as_vec<'a>(&'a self) -> &'a [u8];\n-\n-    /// Returns the directory component of `self`, as a byte vector (with no trailing separator).\n-    /// If `self` has no directory component, returns ['.'].\n-    fn dirname<'a>(&'a self) -> &'a [u8];\n-    /// Returns the directory component of `self`, as a string, if possible.\n-    /// See `dirname` for details.\n-    #[inline]\n-    fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_bytes_slice_opt(self.dirname())\n-    }\n-    /// Returns the file component of `self`, as a byte vector.\n-    /// If `self` represents the root of the file hierarchy, returns the empty vector.\n-    /// If `self` is \".\", returns the empty vector.\n-    fn filename<'a>(&'a self) -> &'a [u8];\n-    /// Returns the file component of `self`, as a string, if possible.\n-    /// See `filename` for details.\n-    #[inline]\n-    fn filename_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_bytes_slice_opt(self.filename())\n-    }\n-    /// Returns the stem of the filename of `self`, as a byte vector.\n-    /// The stem is the portion of the filename just before the last '.'.\n-    /// If there is no '.', the entire filename is returned.\n-    fn filestem<'a>(&'a self) -> &'a [u8] {\n-        let name = self.filename();\n-        let dot = '.' as u8;\n-        match name.rposition_elem(&dot) {\n-            None | Some(0) => name,\n-            Some(1) if name == bytes!(\"..\") => name,\n-            Some(pos) => name.slice_to(pos)\n-        }\n-    }\n-    /// Returns the stem of the filename of `self`, as a string, if possible.\n-    /// See `filestem` for details.\n-    #[inline]\n-    fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n-        str::from_bytes_slice_opt(self.filestem())\n-    }\n-    /// Returns the extension of the filename of `self`, as an optional byte vector.\n-    /// The extension is the portion of the filename just after the last '.'.\n-    /// If there is no extension, None is returned.\n-    /// If the filename ends in '.', the empty vector is returned.\n-    fn extension<'a>(&'a self) -> Option<&'a [u8]> {\n-        let name = self.filename();\n-        let dot = '.' as u8;\n-        match name.rposition_elem(&dot) {\n-            None | Some(0) => None,\n-            Some(1) if name == bytes!(\"..\") => None,\n-            Some(pos) => Some(name.slice_from(pos+1))\n-        }\n-    }\n-    /// Returns the extension of the filename of `self`, as a string, if possible.\n-    /// See `extension` for details.\n-    #[inline]\n-    fn extension_str<'a>(&'a self) -> Option<&'a str> {\n-        self.extension().chain(|v| str::from_bytes_slice_opt(v))\n-    }\n-\n-    /// Replaces the directory portion of the path with the given byte vector.\n-    /// If `self` represents the root of the filesystem hierarchy, the last path component\n-    /// of the given byte vector becomes the filename.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the dirname contains a NUL.\n-    #[inline]\n-    fn set_dirname(&mut self, dirname: &[u8]) {\n-        if contains_nul(dirname) {\n-            let dirname = self::null_byte::cond.raise(dirname.to_owned());\n-            assert!(!contains_nul(dirname));\n-            unsafe { self.set_dirname_unchecked(dirname) }\n-        } else {\n-            unsafe { self.set_dirname_unchecked(dirname) }\n-        }\n-    }\n-    /// Replaces the directory portion of the path with the given string.\n-    /// See `set_dirname` for details.\n-    #[inline]\n-    fn set_dirname_str(&mut self, dirname: &str) {\n-        self.set_dirname(dirname.as_bytes())\n-    }\n-    /// Replaces the filename portion of the path with the given byte vector.\n-    /// If the replacement name is [], this is equivalent to popping the path.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the filename contains a NUL.\n-    #[inline]\n-    fn set_filename(&mut self, filename: &[u8]) {\n-        if contains_nul(filename) {\n-            let filename = self::null_byte::cond.raise(filename.to_owned());\n-            assert!(!contains_nul(filename));\n-            unsafe { self.set_filename_unchecked(filename) }\n-        } else {\n-            unsafe { self.set_filename_unchecked(filename) }\n-        }\n-    }\n-    /// Replaces the filename portion of the path with the given string.\n-    /// See `set_filename` for details.\n-    #[inline]\n-    fn set_filename_str(&mut self, filename: &str) {\n-        self.set_filename(filename.as_bytes())\n-    }\n-    /// Replaces the filestem with the given byte vector.\n-    /// If there is no extension in `self` (or `self` has no filename), this is equivalent\n-    /// to `set_filename`. Otherwise, if the given byte vector is [], the extension (including\n-    /// the preceding '.') becomes the new filename.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the filestem contains a NUL.\n-    fn set_filestem(&mut self, filestem: &[u8]) {\n-        // borrowck is being a pain here\n-        let val = {\n-            let name = self.filename();\n-            if !name.is_empty() {\n-                let dot = '.' as u8;\n-                match name.rposition_elem(&dot) {\n-                    None | Some(0) => None,\n-                    Some(idx) => {\n-                        let mut v;\n-                        if contains_nul(filestem) {\n-                            let filestem = self::null_byte::cond.raise(filestem.to_owned());\n-                            assert!(!contains_nul(filestem));\n-                            v = vec::with_capacity(filestem.len() + name.len() - idx);\n-                            v.push_all(filestem);\n-                        } else {\n-                            v = vec::with_capacity(filestem.len() + name.len() - idx);\n-                            v.push_all(filestem);\n-                        }\n-                        v.push_all(name.slice_from(idx));\n-                        Some(v)\n-                    }\n-                }\n-            } else { None }\n-        };\n-        match val {\n-            None => self.set_filename(filestem),\n-            Some(v) => unsafe { self.set_filename_unchecked(v) }\n-        }\n-    }\n-    /// Replaces the filestem with the given string.\n-    /// See `set_filestem` for details.\n-    #[inline]\n-    fn set_filestem_str(&mut self, filestem: &str) {\n-        self.set_filestem(filestem.as_bytes())\n-    }\n-    /// Replaces the extension with the given byte vector.\n-    /// If there is no extension in `self`, this adds one.\n-    /// If the given byte vector is [], this removes the extension.\n-    /// If `self` has no filename, this is a no-op.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the extension contains a NUL.\n-    fn set_extension(&mut self, extension: &[u8]) {\n-        // borrowck causes problems here too\n-        let val = {\n-            let name = self.filename();\n-            if !name.is_empty() {\n-                let dot = '.' as u8;\n-                match name.rposition_elem(&dot) {\n-                    None | Some(0) => {\n-                        if extension.is_empty() {\n-                            None\n-                        } else {\n-                            let mut v;\n-                            if contains_nul(extension) {\n-                                let extension = self::null_byte::cond.raise(extension.to_owned());\n-                                assert!(!contains_nul(extension));\n-                                v = vec::with_capacity(name.len() + extension.len() + 1);\n-                                v.push_all(name);\n-                                v.push(dot);\n-                                v.push_all(extension);\n-                            } else {\n-                                v = vec::with_capacity(name.len() + extension.len() + 1);\n-                                v.push_all(name);\n-                                v.push(dot);\n-                                v.push_all(extension);\n-                            }\n-                            Some(v)\n-                        }\n-                    }\n-                    Some(idx) => {\n-                        if extension.is_empty() {\n-                            Some(name.slice_to(idx).to_owned())\n-                        } else {\n-                            let mut v;\n-                            if contains_nul(extension) {\n-                                let extension = self::null_byte::cond.raise(extension.to_owned());\n-                                assert!(!contains_nul(extension));\n-                                v = vec::with_capacity(idx + extension.len() + 1);\n-                                v.push_all(name.slice_to(idx+1));\n-                                v.push_all(extension);\n-                            } else {\n-                                v = vec::with_capacity(idx + extension.len() + 1);\n-                                v.push_all(name.slice_to(idx+1));\n-                                v.push_all(extension);\n-                            }\n-                            Some(v)\n-                        }\n-                    }\n-                }\n-            } else { None }\n-        };\n-        match val {\n-            None => (),\n-            Some(v) => unsafe { self.set_filename_unchecked(v) }\n-        }\n-    }\n-    /// Replaces the extension with the given string.\n-    /// See `set_extension` for details.\n-    #[inline]\n-    fn set_extension_str(&mut self, extension: &str) {\n-        self.set_extension(extension.as_bytes())\n-    }\n-\n-    /// Returns a new Path constructed by replacing the dirname with the given byte vector.\n-    /// See `set_dirname` for details.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the dirname contains a NUL.\n-    #[inline]\n-    fn with_dirname(&self, dirname: &[u8]) -> Self {\n-        let mut p = self.clone();\n-        p.set_dirname(dirname);\n-        p\n-    }\n-    /// Returns a new Path constructed by replacing the dirname with the given string.\n-    /// See `set_dirname` for details.\n-    #[inline]\n-    fn with_dirname_str(&self, dirname: &str) -> Self {\n-        self.with_dirname(dirname.as_bytes())\n-    }\n-    /// Returns a new Path constructed by replacing the filename with the given byte vector.\n-    /// See `set_filename` for details.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the filename contains a NUL.\n-    #[inline]\n-    fn with_filename(&self, filename: &[u8]) -> Self {\n-        let mut p = self.clone();\n-        p.set_filename(filename);\n-        p\n-    }\n-    /// Returns a new Path constructed by replacing the filename with the given string.\n-    /// See `set_filename` for details.\n-    #[inline]\n-    fn with_filename_str(&self, filename: &str) -> Self {\n-        self.with_filename(filename.as_bytes())\n-    }\n-    /// Returns a new Path constructed by setting the filestem to the given byte vector.\n-    /// See `set_filestem` for details.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the filestem contains a NUL.\n-    #[inline]\n-    fn with_filestem(&self, filestem: &[u8]) -> Self {\n-        let mut p = self.clone();\n-        p.set_filestem(filestem);\n-        p\n-    }\n-    /// Returns a new Path constructed by setting the filestem to the given string.\n-    /// See `set_filestem` for details.\n-    #[inline]\n-    fn with_filestem_str(&self, filestem: &str) -> Self {\n-        self.with_filestem(filestem.as_bytes())\n-    }\n-    /// Returns a new Path constructed by setting the extension to the given byte vector.\n-    /// See `set_extension` for details.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the extension contains a NUL.\n-    #[inline]\n-    fn with_extension(&self, extension: &[u8]) -> Self {\n-        let mut p = self.clone();\n-        p.set_extension(extension);\n-        p\n-    }\n-    /// Returns a new Path constructed by setting the extension to the given string.\n-    /// See `set_extension` for details.\n-    #[inline]\n-    fn with_extension_str(&self, extension: &str) -> Self {\n-        self.with_extension(extension.as_bytes())\n-    }\n-\n-    /// Returns the directory component of `self`, as a Path.\n-    /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n-    fn dir_path(&self) -> Self {\n-        GenericPath::from_vec(self.dirname())\n-    }\n-    /// Returns the file component of `self`, as a relative Path.\n-    /// If `self` represents the root of the filesystem hierarchy, returns None.\n-    fn file_path(&self) -> Option<Self> {\n-        match self.filename() {\n-            [] => None,\n-            v => Some(GenericPath::from_vec(v))\n-        }\n-    }\n-\n-    /// Pushes a path (as a byte vector) onto `self`.\n-    /// If the argument represents an absolute path, it replaces `self`.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the path contains a NUL.\n-    #[inline]\n-    fn push(&mut self, path: &[u8]) {\n-        if contains_nul(path) {\n-            let path = self::null_byte::cond.raise(path.to_owned());\n-            assert!(!contains_nul(path));\n-            unsafe { self.push_unchecked(path) }\n-        } else {\n-            unsafe { self.push_unchecked(path) }\n-        }\n-    }\n-    /// Pushes a path (as a string) onto `self.\n-    /// See `push` for details.\n-    #[inline]\n-    fn push_str(&mut self, path: &str) {\n-        self.push(path.as_bytes())\n-    }\n-    /// Pushes a Path onto `self`.\n-    /// If the argument represents an absolute path, it replaces `self`.\n-    #[inline]\n-    fn push_path(&mut self, path: &Self) {\n-        self.push(path.as_vec())\n-    }\n-    /// Pops the last path component off of `self` and returns it.\n-    /// If `self` represents the root of the file hierarchy, None is returned.\n-    fn pop_opt(&mut self) -> Option<~[u8]>;\n-    /// Pops the last path component off of `self` and returns it as a string, if possible.\n-    /// `self` will still be modified even if None is returned.\n-    /// See `pop_opt` for details.\n-    #[inline]\n-    fn pop_opt_str(&mut self) -> Option<~str> {\n-        self.pop_opt().chain(|v| str::from_bytes_owned_opt(v))\n-    }\n-\n-    /// Returns a new Path constructed by joining `self` with the given path (as a byte vector).\n-    /// If the given path is absolute, the new Path will represent just that.\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the path contains a NUL.\n-    #[inline]\n-    fn join(&self, path: &[u8]) -> Self {\n-        let mut p = self.clone();\n-        p.push(path);\n-        p\n-    }\n-    /// Returns a new Path constructed by joining `self` with the given path (as a string).\n-    /// See `join` for details.\n-    #[inline]\n-    fn join_str(&self, path: &str) -> Self {\n-        self.join(path.as_bytes())\n-    }\n-    /// Returns a new Path constructed by joining `self` with the given path.\n-    /// If the given path is absolute, the new Path will represent just that.\n-    #[inline]\n-    fn join_path(&self, path: &Self) -> Self {\n-        let mut p = self.clone();\n-        p.push_path(path);\n-        p\n-    }\n-\n-    /// Returns whether `self` represents an absolute path.\n-    fn is_absolute(&self) -> bool;\n-\n-    /// Returns whether `self` is equal to, or is an ancestor of, the given path.\n-    /// If both paths are relative, they are compared as though they are relative\n-    /// to the same parent path.\n-    fn is_ancestor_of(&self, other: &Self) -> bool;\n-\n-    /// Returns the Path that, were it joined to `base`, would yield `self`.\n-    /// If no such path exists, None is returned.\n-    /// If `self` is absolute and `base` is relative, or on Windows if both\n-    /// paths refer to separate drives, an absolute path is returned.\n-    fn path_relative_from(&self, base: &Self) -> Option<Self>;\n-}\n-\n-/// A trait that represents the unsafe operations on GenericPaths\n-pub trait GenericPathUnsafe {\n-    /// Creates a new Path from a byte vector without checking for null bytes.\n-    /// The resulting Path will always be normalized.\n-    unsafe fn from_vec_unchecked(path: &[u8]) -> Self;\n-\n-    /// Replaces the directory portion of the path with the given byte vector without\n-    /// checking for null bytes.\n-    /// See `set_dirname` for details.\n-    unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]);\n-\n-    /// Replaces the filename portion of the path with the given byte vector without\n-    /// checking for null bytes.\n-    /// See `set_filename` for details.\n-    unsafe fn set_filename_unchecked(&mut self, filename: &[u8]);\n-\n-    /// Pushes a path onto `self` without checking for null bytes.\n-    /// See `push` for details.\n-    unsafe fn push_unchecked(&mut self, path: &[u8]);\n-}\n-\n-#[inline(always)]\n-fn contains_nul(v: &[u8]) -> bool {\n-    v.iter().any(|&x| x == 0)\n-}\n-\n-impl ToCStr for PosixPath {\n-    #[inline]\n-    fn to_c_str(&self) -> CString {\n-        // The Path impl guarantees no internal NUL\n-        unsafe { self.as_vec().to_c_str_unchecked() }\n-    }\n-\n-    #[inline]\n-    unsafe fn to_c_str_unchecked(&self) -> CString {\n-        self.as_vec().to_c_str_unchecked()\n-    }\n-}\n-\n-impl GenericPathUnsafe for PosixPath {\n-    unsafe fn from_vec_unchecked(path: &[u8]) -> PosixPath {\n-        let path = PosixPath::normalize(path);\n-        assert!(!path.is_empty());\n-        let idx = path.rposition_elem(&posix::sep);\n-        PosixPath{ repr: path, sepidx: idx }\n-    }\n-\n-    unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]) {\n-        match self.sepidx {\n-            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => {\n-                self.repr = PosixPath::normalize(dirname);\n-            }\n-            None => {\n-                let mut v = vec::with_capacity(dirname.len() + self.repr.len() + 1);\n-                v.push_all(dirname);\n-                v.push(posix::sep);\n-                v.push_all(self.repr);\n-                self.repr = PosixPath::normalize(v);\n-            }\n-            Some(0) if self.repr.len() == 1 && self.repr[0] == posix::sep => {\n-                self.repr = PosixPath::normalize(dirname);\n-            }\n-            Some(idx) if dirname.is_empty() => {\n-                let v = PosixPath::normalize(self.repr.slice_from(idx+1));\n-                self.repr = v;\n-            }\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n-                self.repr = PosixPath::normalize(dirname);\n-            }\n-            Some(idx) => {\n-                let mut v = vec::with_capacity(dirname.len() + self.repr.len() - idx);\n-                v.push_all(dirname);\n-                v.push_all(self.repr.slice_from(idx));\n-                self.repr = PosixPath::normalize(v);\n-            }\n-        }\n-        self.sepidx = self.repr.rposition_elem(&posix::sep);\n-    }\n-\n-    unsafe fn set_filename_unchecked(&mut self, filename: &[u8]) {\n-        match self.sepidx {\n-            None if bytes!(\"..\") == self.repr => {\n-                let mut v = vec::with_capacity(3 + filename.len());\n-                v.push_all(dot_dot_static);\n-                v.push(posix::sep);\n-                v.push_all(filename);\n-                self.repr = PosixPath::normalize(v);\n-            }\n-            None => {\n-                self.repr = PosixPath::normalize(filename);\n-            }\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n-                let mut v = vec::with_capacity(self.repr.len() + 1 + filename.len());\n-                v.push_all(self.repr);\n-                v.push(posix::sep);\n-                v.push_all(filename);\n-                self.repr = PosixPath::normalize(v);\n-            }\n-            Some(idx) => {\n-                let mut v = vec::with_capacity(self.repr.len() - idx + filename.len());\n-                v.push_all(self.repr.slice_to(idx+1));\n-                v.push_all(filename);\n-                self.repr = PosixPath::normalize(v);\n-            }\n-        }\n-        self.sepidx = self.repr.rposition_elem(&posix::sep);\n-    }\n-\n-    unsafe fn push_unchecked(&mut self, path: &[u8]) {\n-        if !path.is_empty() {\n-            if path[0] == posix::sep {\n-                self.repr = PosixPath::normalize(path);\n-            }  else {\n-                let mut v = vec::with_capacity(self.repr.len() + path.len() + 1);\n-                v.push_all(self.repr);\n-                v.push(posix::sep);\n-                v.push_all(path);\n-                self.repr = PosixPath::normalize(v);\n-            }\n-            self.sepidx = self.repr.rposition_elem(&posix::sep);\n-        }\n-    }\n-}\n-\n-impl GenericPath for PosixPath {\n-    #[inline]\n-    fn as_vec<'a>(&'a self) -> &'a [u8] {\n-        self.repr.as_slice()\n-    }\n-\n-    fn dirname<'a>(&'a self) -> &'a [u8] {\n-        match self.sepidx {\n-            None if bytes!(\"..\") == self.repr => self.repr.as_slice(),\n-            None => dot_static,\n-            Some(0) => self.repr.slice_to(1),\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => self.repr.as_slice(),\n-            Some(idx) => self.repr.slice_to(idx)\n-        }\n-    }\n-\n-    fn filename<'a>(&'a self) -> &'a [u8] {\n-        match self.sepidx {\n-            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => &[],\n-            None => self.repr.as_slice(),\n-            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => &[],\n-            Some(idx) => self.repr.slice_from(idx+1)\n-        }\n-    }\n-\n-    fn pop_opt(&mut self) -> Option<~[u8]> {\n-        match self.sepidx {\n-            None if bytes!(\".\") == self.repr => None,\n-            None => {\n-                let mut v = ~['.' as u8];\n-                util::swap(&mut v, &mut self.repr);\n-                self.sepidx = None;\n-                Some(v)\n-            }\n-            Some(0) if bytes!(\"/\") == self.repr => None,\n-            Some(idx) => {\n-                let v = self.repr.slice_from(idx+1).to_owned();\n-                if idx == 0 {\n-                    self.repr.truncate(idx+1);\n-                } else {\n-                    self.repr.truncate(idx);\n-                }\n-                self.sepidx = self.repr.rposition_elem(&posix::sep);\n-                Some(v)\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn is_absolute(&self) -> bool {\n-        self.repr[0] == posix::sep\n-    }\n-\n-    fn is_ancestor_of(&self, other: &PosixPath) -> bool {\n-        if self.is_absolute() != other.is_absolute() {\n-            false\n-        } else {\n-            let mut ita = self.component_iter();\n-            let mut itb = other.component_iter();\n-            if bytes!(\".\") == self.repr {\n-                return itb.next() != Some(bytes!(\"..\"));\n-            }\n-            loop {\n-                match (ita.next(), itb.next()) {\n-                    (None, _) => break,\n-                    (Some(a), Some(b)) if a == b => { loop },\n-                    (Some(a), _) if a == bytes!(\"..\") => {\n-                        // if ita contains only .. components, it's an ancestor\n-                        return ita.all(|x| x == bytes!(\"..\"));\n-                    }\n-                    _ => return false\n-                }\n-            }\n-            true\n-        }\n-    }\n-\n-    fn path_relative_from(&self, base: &PosixPath) -> Option<PosixPath> {\n-        if self.is_absolute() != base.is_absolute() {\n-            if self.is_absolute() {\n-                Some(self.clone())\n-            } else {\n-                None\n-            }\n-        } else {\n-            let mut ita = self.component_iter();\n-            let mut itb = base.component_iter();\n-            let mut comps = ~[];\n-            loop {\n-                match (ita.next(), itb.next()) {\n-                    (None, None) => break,\n-                    (Some(a), None) => {\n-                        comps.push(a);\n-                        comps.extend(&mut ita);\n-                        break;\n-                    }\n-                    (None, _) => comps.push(dot_dot_static),\n-                    (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n-                    (Some(a), Some(b)) if b == bytes!(\".\") => comps.push(a),\n-                    (Some(_), Some(b)) if b == bytes!(\"..\") => return None,\n-                    (Some(a), Some(_)) => {\n-                        comps.push(dot_dot_static);\n-                        for _ in itb {\n-                            comps.push(dot_dot_static);\n-                        }\n-                        comps.push(a);\n-                        comps.extend(&mut ita);\n-                        break;\n-                    }\n-                }\n-            }\n-            Some(PosixPath::new(comps.connect_vec(&posix::sep)))\n-        }\n-    }\n-}\n-\n-impl PosixPath {\n-    /// Returns a new PosixPath from a byte vector\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the vector contains a NUL.\n-    #[inline]\n-    pub fn new(v: &[u8]) -> PosixPath {\n-        GenericPath::from_vec(v)\n-    }\n-\n-    /// Returns a new PosixPath from a string\n-    ///\n-    /// # Failure\n-    ///\n-    /// Raises the `null_byte` condition if the str contains a NUL.\n-    #[inline]\n-    pub fn from_str(s: &str) -> PosixPath {\n-        GenericPath::from_str(s)\n-    }\n-\n-    /// Converts the PosixPath into an owned byte vector\n-    pub fn into_vec(self) -> ~[u8] {\n-        self.repr\n-    }\n-\n-    /// Converts the PosixPath into an owned string, if possible\n-    pub fn into_str(self) -> Option<~str> {\n-        str::from_bytes_owned_opt(self.repr)\n-    }\n-\n-    /// Returns a normalized byte vector representation of a path, by removing all empty\n-    /// components, and unnecessary . and .. components.\n-    pub fn normalize<V: Vector<u8>+CopyableVector<u8>>(v: V) -> ~[u8] {\n-        // borrowck is being very picky\n-        let val = {\n-            let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == posix::sep;\n-            let v_ = if is_abs { v.as_slice().slice_from(1) } else { v.as_slice() };\n-            let comps = normalize_helper(v_, is_abs, posix::is_sep);\n-            match comps {\n-                None => None,\n-                Some(comps) => {\n-                    if is_abs && comps.is_empty() {\n-                        Some(~[posix::sep])\n-                    } else {\n-                        let n = if is_abs { comps.len() } else { comps.len() - 1} +\n-                                comps.iter().map(|v| v.len()).sum();\n-                        let mut v = vec::with_capacity(n);\n-                        let mut it = comps.move_iter();\n-                        if !is_abs {\n-                            match it.next() {\n-                                None => (),\n-                                Some(comp) => v.push_all(comp)\n-                            }\n-                        }\n-                        for comp in it {\n-                            v.push(posix::sep);\n-                            v.push_all(comp);\n-                        }\n-                        Some(v)\n-                    }\n-                }\n-            }\n-        };\n-        match val {\n-            None => v.into_owned(),\n-            Some(val) => val\n-        }\n-    }\n-\n-    /// Returns an iterator that yields each component of the path in turn.\n-    /// Does not distinguish between absolute and relative paths, e.g.\n-    /// /a/b/c and a/b/c yield the same set of components.\n-    /// A path of \"/\" yields no components. A path of \".\" yields one component.\n-    pub fn component_iter<'a>(&'a self) -> PosixComponentIter<'a> {\n-        let v = if self.repr[0] == posix::sep {\n-            self.repr.slice_from(1)\n-        } else { self.repr.as_slice() };\n-        let mut ret = v.split_iter(posix::is_sep);\n-        if v.is_empty() {\n-            // consume the empty \"\" component\n-            ret.next();\n-        }\n-        ret\n-    }\n-}\n-\n-// None result means the byte vector didn't need normalizing\n-fn normalize_helper<'a>(v: &'a [u8], is_abs: bool, f: &'a fn(&u8) -> bool) -> Option<~[&'a [u8]]> {\n-    if is_abs && v.as_slice().is_empty() {\n-        return None;\n-    }\n-    let mut comps: ~[&'a [u8]] = ~[];\n-    let mut n_up = 0u;\n-    let mut changed = false;\n-    for comp in v.split_iter(f) {\n-        if comp.is_empty() { changed = true }\n-        else if comp == bytes!(\".\") { changed = true }\n-        else if comp == bytes!(\"..\") {\n-            if is_abs && comps.is_empty() { changed = true }\n-            else if comps.len() == n_up { comps.push(dot_dot_static); n_up += 1 }\n-            else { comps.pop_opt(); changed = true }\n-        } else { comps.push(comp) }\n-    }\n-    if changed {\n-        if comps.is_empty() && !is_abs {\n-            if v == bytes!(\".\") {\n-                return None;\n-            }\n-            comps.push(dot_static);\n-        }\n-        Some(comps)\n-    } else {\n-        None\n-    }\n-}\n-\n-static dot_static: &'static [u8] = &'static ['.' as u8];\n-static dot_dot_static: &'static [u8] = &'static ['.' as u8, '.' as u8];\n-\n-/// Various POSIX helpers\n-pub mod posix {\n-    /// The standard path separator character\n-    pub static sep: u8 = '/' as u8;\n-\n-    /// Returns whether the given byte is a path separator\n-    #[inline]\n-    pub fn is_sep(u: &u8) -> bool {\n-        *u == sep\n-    }\n-}\n-\n-/// Various Windows helpers\n-pub mod windows {\n-    /// The standard path separator character\n-    pub static sep: u8 = '\\\\' as u8;\n-    /// The alternative path separator character\n-    pub static sep2: u8 = '/' as u8;\n-\n-    /// Returns whether the given byte is a path separator\n-    #[inline]\n-    pub fn is_sep(u: &u8) -> bool {\n-        *u == sep || *u == sep2\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use option::{Some, None};\n-    use iterator::Iterator;\n-    use str;\n-    use vec::Vector;\n-\n-    macro_rules! t(\n-        (s: $path:expr, $exp:expr) => (\n-            {\n-                let path = $path;\n-                assert_eq!(path.as_str(), Some($exp));\n-            }\n-        );\n-        (v: $path:expr, $exp:expr) => (\n-            {\n-                let path = $path;\n-                assert_eq!(path.as_vec(), $exp);\n-            }\n-        )\n-    )\n-\n-    macro_rules! b(\n-        ($($arg:expr),+) => (\n-            bytes!($($arg),+)\n-        )\n-    )\n-\n-    #[test]\n-    fn test_posix_paths() {\n-        t!(v: PosixPath::new([]), b!(\".\"));\n-        t!(v: PosixPath::new(b!(\"/\")), b!(\"/\"));\n-        t!(v: PosixPath::new(b!(\"a/b/c\")), b!(\"a/b/c\"));\n-        t!(v: PosixPath::new(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n-        t!(v: PosixPath::new(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n-        let p = PosixPath::new(b!(\"a/b/c\", 0xff));\n-        assert_eq!(p.as_str(), None);\n-\n-        t!(s: PosixPath::from_str(\"\"), \".\");\n-        t!(s: PosixPath::from_str(\"/\"), \"/\");\n-        t!(s: PosixPath::from_str(\"hi\"), \"hi\");\n-        t!(s: PosixPath::from_str(\"/lib\"), \"/lib\");\n-        t!(s: PosixPath::from_str(\"hi/there\"), \"hi/there\");\n-        t!(s: PosixPath::from_str(\"hi/there.txt\"), \"hi/there.txt\");\n-\n-        t!(s: PosixPath::from_str(\"hi/there/\"), \"hi/there\");\n-        t!(s: PosixPath::from_str(\"hi/../there\"), \"there\");\n-        t!(s: PosixPath::from_str(\"../hi/there\"), \"../hi/there\");\n-        t!(s: PosixPath::from_str(\"/../hi/there\"), \"/hi/there\");\n-        t!(s: PosixPath::from_str(\"foo/..\"), \".\");\n-        t!(s: PosixPath::from_str(\"/foo/..\"), \"/\");\n-        t!(s: PosixPath::from_str(\"/foo/../..\"), \"/\");\n-        t!(s: PosixPath::from_str(\"/foo/../../bar\"), \"/bar\");\n-        t!(s: PosixPath::from_str(\"/./hi/./there/.\"), \"/hi/there\");\n-        t!(s: PosixPath::from_str(\"/./hi/./there/./..\"), \"/hi\");\n-        t!(s: PosixPath::from_str(\"foo/../..\"), \"..\");\n-        t!(s: PosixPath::from_str(\"foo/../../..\"), \"../..\");\n-        t!(s: PosixPath::from_str(\"foo/../../bar\"), \"../bar\");\n-\n-        assert_eq!(PosixPath::new(b!(\"foo/bar\")).into_vec(), b!(\"foo/bar\").to_owned());\n-        assert_eq!(PosixPath::new(b!(\"/foo/../../bar\")).into_vec(),\n-                   b!(\"/bar\").to_owned());\n-        assert_eq!(PosixPath::from_str(\"foo/bar\").into_str(), Some(~\"foo/bar\"));\n-        assert_eq!(PosixPath::from_str(\"/foo/../../bar\").into_str(), Some(~\"/bar\"));\n-\n-        let p = PosixPath::new(b!(\"foo/bar\", 0x80));\n-        assert_eq!(p.as_str(), None);\n-        assert_eq!(PosixPath::new(b!(\"foo\", 0xff, \"/bar\")).into_str(), None);\n-    }\n-\n-    #[test]\n-    fn test_posix_null_byte() {\n-        use super::null_byte::cond;\n-\n-        let mut handled = false;\n-        let mut p = do cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"foo/bar\", 0));\n-            (b!(\"/bar\").to_owned())\n-        }).inside {\n-            PosixPath::new(b!(\"foo/bar\", 0))\n-        };\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"/bar\"));\n-\n-        handled = false;\n-        do cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n-            (b!(\"foo\").to_owned())\n-        }).inside {\n-            p.set_filename(b!(\"f\", 0, \"o\"))\n-        };\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"/foo\"));\n-\n-        handled = false;\n-        do cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"null/\", 0, \"/byte\"));\n-            (b!(\"null/byte\").to_owned())\n-        }).inside {\n-            p.set_dirname(b!(\"null/\", 0, \"/byte\"));\n-        };\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"null/byte/foo\"));\n-\n-        handled = false;\n-        do cond.trap(|v| {\n-            handled = true;\n-            assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n-            (b!(\"foo\").to_owned())\n-        }).inside {\n-            p.push(b!(\"f\", 0, \"o\"));\n-        };\n-        assert!(handled);\n-        assert_eq!(p.as_vec(), b!(\"null/byte/foo/foo\"));\n-    }\n-\n-    #[test]\n-    fn test_posix_null_byte_fail() {\n-        use super::null_byte::cond;\n-        use task;\n-\n-        macro_rules! t(\n-            ($name:expr => $code:block) => (\n-                {\n-                    let mut t = task::task();\n-                    t.supervised();\n-                    t.name($name);\n-                    let res = do t.try $code;\n-                    assert!(res.is_err());\n-                }\n-            )\n-        )\n-\n-        t!(~\"new() w/nul\" => {\n-            do cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside {\n-                PosixPath::new(b!(\"foo/bar\", 0))\n-            };\n-        })\n-\n-        t!(~\"set_filename w/nul\" => {\n-            let mut p = PosixPath::new(b!(\"foo/bar\"));\n-            do cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside {\n-                p.set_filename(b!(\"foo\", 0))\n-            };\n-        })\n-\n-        t!(~\"set_dirname w/nul\" => {\n-            let mut p = PosixPath::new(b!(\"foo/bar\"));\n-            do cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside {\n-                p.set_dirname(b!(\"foo\", 0))\n-            };\n-        })\n-\n-        t!(~\"push w/nul\" => {\n-            let mut p = PosixPath::new(b!(\"foo/bar\"));\n-            do cond.trap(|_| {\n-                (b!(\"null\", 0).to_owned())\n-            }).inside {\n-                p.push(b!(\"foo\", 0))\n-            };\n-        })\n-    }\n-\n-    #[test]\n-    fn test_posix_components() {\n-        macro_rules! t(\n-            (s: $path:expr, $op:ident, $exp:expr) => (\n-                {\n-                    let path = PosixPath::from_str($path);\n-                    assert_eq!(path.$op(), ($exp).as_bytes());\n-                }\n-            );\n-            (s: $path:expr, $op:ident, $exp:expr, opt) => (\n-                {\n-                    let path = PosixPath::from_str($path);\n-                    let left = path.$op().map(|&x| str::from_bytes_slice(x));\n-                    assert_eq!(left, $exp);\n-                }\n-            );\n-            (v: $path:expr, $op:ident, $exp:expr) => (\n-                {\n-                    let path = PosixPath::new($path);\n-                    assert_eq!(path.$op(), $exp);\n-                }\n-            )\n-        )\n-\n-        t!(v: b!(\"a/b/c\"), filename, b!(\"c\"));\n-        t!(v: b!(\"a/b/c\", 0xff), filename, b!(\"c\", 0xff));\n-        t!(v: b!(\"a/b\", 0xff, \"/c\"), filename, b!(\"c\"));\n-        t!(s: \"a/b/c\", filename, \"c\");\n-        t!(s: \"/a/b/c\", filename, \"c\");\n-        t!(s: \"a\", filename, \"a\");\n-        t!(s: \"/a\", filename, \"a\");\n-        t!(s: \".\", filename, \"\");\n-        t!(s: \"/\", filename, \"\");\n-        t!(s: \"..\", filename, \"\");\n-        t!(s: \"../..\", filename, \"\");\n-\n-        t!(v: b!(\"a/b/c\"), dirname, b!(\"a/b\"));\n-        t!(v: b!(\"a/b/c\", 0xff), dirname, b!(\"a/b\"));\n-        t!(v: b!(\"a/b\", 0xff, \"/c\"), dirname, b!(\"a/b\", 0xff));\n-        t!(s: \"a/b/c\", dirname, \"a/b\");\n-        t!(s: \"/a/b/c\", dirname, \"/a/b\");\n-        t!(s: \"a\", dirname, \".\");\n-        t!(s: \"/a\", dirname, \"/\");\n-        t!(s: \".\", dirname, \".\");\n-        t!(s: \"/\", dirname, \"/\");\n-        t!(s: \"..\", dirname, \"..\");\n-        t!(s: \"../..\", dirname, \"../..\");\n-\n-        t!(v: b!(\"hi/there.txt\"), filestem, b!(\"there\"));\n-        t!(v: b!(\"hi/there\", 0x80, \".txt\"), filestem, b!(\"there\", 0x80));\n-        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), filestem, b!(\"there\"));\n-        t!(s: \"hi/there.txt\", filestem, \"there\");\n-        t!(s: \"hi/there\", filestem, \"there\");\n-        t!(s: \"there.txt\", filestem, \"there\");\n-        t!(s: \"there\", filestem, \"there\");\n-        t!(s: \".\", filestem, \"\");\n-        t!(s: \"/\", filestem, \"\");\n-        t!(s: \"foo/.bar\", filestem, \".bar\");\n-        t!(s: \".bar\", filestem, \".bar\");\n-        t!(s: \"..bar\", filestem, \".\");\n-        t!(s: \"hi/there..txt\", filestem, \"there.\");\n-        t!(s: \"..\", filestem, \"\");\n-        t!(s: \"../..\", filestem, \"\");\n-\n-        t!(v: b!(\"hi/there.txt\"), extension, Some(b!(\"txt\")));\n-        t!(v: b!(\"hi/there\", 0x80, \".txt\"), extension, Some(b!(\"txt\")));\n-        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), extension, Some(b!(\"t\", 0x80, \"xt\")));\n-        t!(v: b!(\"hi/there\"), extension, None);\n-        t!(v: b!(\"hi/there\", 0x80), extension, None);\n-        t!(s: \"hi/there.txt\", extension, Some(\"txt\"), opt);\n-        t!(s: \"hi/there\", extension, None, opt);\n-        t!(s: \"there.txt\", extension, Some(\"txt\"), opt);\n-        t!(s: \"there\", extension, None, opt);\n-        t!(s: \".\", extension, None, opt);\n-        t!(s: \"/\", extension, None, opt);\n-        t!(s: \"foo/.bar\", extension, None, opt);\n-        t!(s: \".bar\", extension, None, opt);\n-        t!(s: \"..bar\", extension, Some(\"bar\"), opt);\n-        t!(s: \"hi/there..txt\", extension, Some(\"txt\"), opt);\n-        t!(s: \"..\", extension, None, opt);\n-        t!(s: \"../..\", extension, None, opt);\n-    }\n-\n-    #[test]\n-    fn test_posix_push() {\n-        macro_rules! t(\n-            (s: $path:expr, $join:expr) => (\n-                {\n-                    let path = ($path);\n-                    let join = ($join);\n-                    let mut p1 = PosixPath::from_str(path);\n-                    let p2 = p1.clone();\n-                    p1.push_str(join);\n-                    assert_eq!(p1, p2.join_str(join));\n-                }\n-            )\n-        )\n-\n-        t!(s: \"a/b/c\", \"..\");\n-        t!(s: \"/a/b/c\", \"d\");\n-        t!(s: \"a/b\", \"c/d\");\n-        t!(s: \"a/b\", \"/c/d\");\n-    }\n-\n-    #[test]\n-    fn test_posix_push_path() {\n-        macro_rules! t(\n-            (s: $path:expr, $push:expr, $exp:expr) => (\n-                {\n-                    let mut p = PosixPath::from_str($path);\n-                    let push = PosixPath::from_str($push);\n-                    p.push_path(&push);\n-                    assert_eq!(p.as_str(), Some($exp));\n-                }\n-            )\n-        )\n-\n-        t!(s: \"a/b/c\", \"d\", \"a/b/c/d\");\n-        t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n-        t!(s: \"a/b\", \"c/d\", \"a/b/c/d\");\n-        t!(s: \"a/b\", \"/c/d\", \"/c/d\");\n-        t!(s: \"a/b\", \".\", \"a/b\");\n-        t!(s: \"a/b\", \"../c\", \"a/c\");\n-    }\n-\n-    #[test]\n-    fn test_posix_pop() {\n-        macro_rules! t(\n-            (s: $path:expr, $left:expr, $right:expr) => (\n-                {\n-                    let mut p = PosixPath::from_str($path);\n-                    let file = p.pop_opt_str();\n-                    assert_eq!(p.as_str(), Some($left));\n-                    assert_eq!(file.map(|s| s.as_slice()), $right);\n-                }\n-            );\n-            (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n-                {\n-                    let mut p = PosixPath::new(b!($($path),+));\n-                    let file = p.pop_opt();\n-                    assert_eq!(p.as_vec(), b!($($left),+));\n-                    assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n-                }\n-            );\n-            (v: [$($path:expr),+], [$($left:expr),+], None) => (\n-                {\n-                    let mut p = PosixPath::new(b!($($path),+));\n-                    let file = p.pop_opt();\n-                    assert_eq!(p.as_vec(), b!($($left),+));\n-                    assert_eq!(file, None);\n-                }\n-            )\n-        )\n-\n-        t!(v: [\"a/b/c\"], [\"a/b\"], Some(\"c\"));\n-        t!(v: [\"a\"], [\".\"], Some(\"a\"));\n-        t!(v: [\".\"], [\".\"], None);\n-        t!(v: [\"/a\"], [\"/\"], Some(\"a\"));\n-        t!(v: [\"/\"], [\"/\"], None);\n-        t!(v: [\"a/b/c\", 0x80], [\"a/b\"], Some(\"c\", 0x80));\n-        t!(v: [\"a/b\", 0x80, \"/c\"], [\"a/b\", 0x80], Some(\"c\"));\n-        t!(v: [0xff], [\".\"], Some(0xff));\n-        t!(v: [\"/\", 0xff], [\"/\"], Some(0xff));\n-        t!(s: \"a/b/c\", \"a/b\", Some(\"c\"));\n-        t!(s: \"a\", \".\", Some(\"a\"));\n-        t!(s: \".\", \".\", None);\n-        t!(s: \"/a\", \"/\", Some(\"a\"));\n-        t!(s: \"/\", \"/\", None);\n-\n-        assert_eq!(PosixPath::new(b!(\"foo/bar\", 0x80)).pop_opt_str(), None);\n-        assert_eq!(PosixPath::new(b!(\"foo\", 0x80, \"/bar\")).pop_opt_str(), Some(~\"bar\"));\n-    }\n-\n-    #[test]\n-    fn test_posix_join() {\n-        t!(v: PosixPath::new(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n-        t!(v: PosixPath::new(b!(\"/a/b/c\")).join(b!(\"d\")), b!(\"/a/b/c/d\"));\n-        t!(v: PosixPath::new(b!(\"a/\", 0x80, \"/c\")).join(b!(0xff)), b!(\"a/\", 0x80, \"/c/\", 0xff));\n-        t!(s: PosixPath::from_str(\"a/b/c\").join_str(\"..\"), \"a/b\");\n-        t!(s: PosixPath::from_str(\"/a/b/c\").join_str(\"d\"), \"/a/b/c/d\");\n-        t!(s: PosixPath::from_str(\"a/b\").join_str(\"c/d\"), \"a/b/c/d\");\n-        t!(s: PosixPath::from_str(\"a/b\").join_str(\"/c/d\"), \"/c/d\");\n-        t!(s: PosixPath::from_str(\".\").join_str(\"a/b\"), \"a/b\");\n-        t!(s: PosixPath::from_str(\"/\").join_str(\"a/b\"), \"/a/b\");\n-    }\n-\n-    #[test]\n-    fn test_posix_join_path() {\n-        macro_rules! t(\n-            (s: $path:expr, $join:expr, $exp:expr) => (\n-                {\n-                    let path = PosixPath::from_str($path);\n-                    let join = PosixPath::from_str($join);\n-                    let res = path.join_path(&join);\n-                    assert_eq!(res.as_str(), Some($exp));\n-                }\n-            )\n-        )\n-\n-        t!(s: \"a/b/c\", \"..\", \"a/b\");\n-        t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n-        t!(s: \"a/b\", \"c/d\", \"a/b/c/d\");\n-        t!(s: \"a/b\", \"/c/d\", \"/c/d\");\n-        t!(s: \".\", \"a/b\", \"a/b\");\n-        t!(s: \"/\", \"a/b\", \"/a/b\");\n-    }\n-\n-    #[test]\n-    fn test_posix_with_helpers() {\n-        t!(v: PosixPath::new(b!(\"a/b/c\")).with_dirname(b!(\"d\")), b!(\"d/c\"));\n-        t!(v: PosixPath::new(b!(\"a/b/c\")).with_dirname(b!(\"d/e\")), b!(\"d/e/c\"));\n-        t!(v: PosixPath::new(b!(\"a/\", 0x80, \"b/c\")).with_dirname(b!(0xff)), b!(0xff, \"/c\"));\n-        t!(v: PosixPath::new(b!(\"a/b/\", 0x80)).with_dirname(b!(\"/\", 0xcd)),\n-              b!(\"/\", 0xcd, \"/\", 0x80));\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_dirname_str(\"d\"), \"d/c\");\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_dirname_str(\"d/e\"), \"d/e/c\");\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_dirname_str(\"\"), \"c\");\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_dirname_str(\"/\"), \"/c\");\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_dirname_str(\".\"), \"c\");\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_dirname_str(\"..\"), \"../c\");\n-        t!(s: PosixPath::from_str(\"/\").with_dirname_str(\"foo\"), \"foo\");\n-        t!(s: PosixPath::from_str(\"/\").with_dirname_str(\"\"), \".\");\n-        t!(s: PosixPath::from_str(\"/foo\").with_dirname_str(\"bar\"), \"bar/foo\");\n-        t!(s: PosixPath::from_str(\"..\").with_dirname_str(\"foo\"), \"foo\");\n-        t!(s: PosixPath::from_str(\"../..\").with_dirname_str(\"foo\"), \"foo\");\n-        t!(s: PosixPath::from_str(\"foo\").with_dirname_str(\"..\"), \"../foo\");\n-        t!(s: PosixPath::from_str(\"foo\").with_dirname_str(\"../..\"), \"../../foo\");\n-\n-        t!(v: PosixPath::new(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n-        t!(v: PosixPath::new(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n-        t!(v: PosixPath::new(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n-              b!(\"/\", 0xff, \"/\", 0xcd));\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_filename_str(\"d\"), \"a/b/d\");\n-        t!(s: PosixPath::from_str(\".\").with_filename_str(\"foo\"), \"foo\");\n-        t!(s: PosixPath::from_str(\"/a/b/c\").with_filename_str(\"d\"), \"/a/b/d\");\n-        t!(s: PosixPath::from_str(\"/\").with_filename_str(\"foo\"), \"/foo\");\n-        t!(s: PosixPath::from_str(\"/a\").with_filename_str(\"foo\"), \"/foo\");\n-        t!(s: PosixPath::from_str(\"foo\").with_filename_str(\"bar\"), \"bar\");\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_filename_str(\"\"), \"a/b\");\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_filename_str(\".\"), \"a/b\");\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_filename_str(\"..\"), \"a\");\n-        t!(s: PosixPath::from_str(\"/a\").with_filename_str(\"\"), \"/\");\n-        t!(s: PosixPath::from_str(\"foo\").with_filename_str(\"\"), \".\");\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_filename_str(\"d/e\"), \"a/b/d/e\");\n-        t!(s: PosixPath::from_str(\"a/b/c\").with_filename_str(\"/d\"), \"a/b/d\");\n-        t!(s: PosixPath::from_str(\"..\").with_filename_str(\"foo\"), \"../foo\");\n-        t!(s: PosixPath::from_str(\"../..\").with_filename_str(\"foo\"), \"../../foo\");\n-\n-        t!(v: PosixPath::new(b!(\"hi/there\", 0x80, \".txt\")).with_filestem(b!(0xff)),\n-              b!(\"hi/\", 0xff, \".txt\"));\n-        t!(v: PosixPath::new(b!(\"hi/there.txt\", 0x80)).with_filestem(b!(0xff)),\n-              b!(\"hi/\", 0xff, \".txt\", 0x80));\n-        t!(v: PosixPath::new(b!(\"hi/there\", 0xff)).with_filestem(b!(0x80)), b!(\"hi/\", 0x80));\n-        t!(v: PosixPath::new(b!(\"hi\", 0x80, \"/there\")).with_filestem([]), b!(\"hi\", 0x80));\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_filestem_str(\"here\"), \"hi/here.txt\");\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_filestem_str(\"\"), \"hi/.txt\");\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_filestem_str(\".\"), \"hi/..txt\");\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_filestem_str(\"..\"), \"hi/...txt\");\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_filestem_str(\"/\"), \"hi/.txt\");\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_filestem_str(\"foo/bar\"), \"hi/foo/bar.txt\");\n-        t!(s: PosixPath::from_str(\"hi/there.foo.txt\").with_filestem_str(\"here\"), \"hi/here.txt\");\n-        t!(s: PosixPath::from_str(\"hi/there\").with_filestem_str(\"here\"), \"hi/here\");\n-        t!(s: PosixPath::from_str(\"hi/there\").with_filestem_str(\"\"), \"hi\");\n-        t!(s: PosixPath::from_str(\"hi\").with_filestem_str(\"\"), \".\");\n-        t!(s: PosixPath::from_str(\"/hi\").with_filestem_str(\"\"), \"/\");\n-        t!(s: PosixPath::from_str(\"hi/there\").with_filestem_str(\"..\"), \".\");\n-        t!(s: PosixPath::from_str(\"hi/there\").with_filestem_str(\".\"), \"hi\");\n-        t!(s: PosixPath::from_str(\"hi/there.\").with_filestem_str(\"foo\"), \"hi/foo.\");\n-        t!(s: PosixPath::from_str(\"hi/there.\").with_filestem_str(\"\"), \"hi\");\n-        t!(s: PosixPath::from_str(\"hi/there.\").with_filestem_str(\".\"), \".\");\n-        t!(s: PosixPath::from_str(\"hi/there.\").with_filestem_str(\"..\"), \"hi/...\");\n-        t!(s: PosixPath::from_str(\"/\").with_filestem_str(\"foo\"), \"/foo\");\n-        t!(s: PosixPath::from_str(\".\").with_filestem_str(\"foo\"), \"foo\");\n-        t!(s: PosixPath::from_str(\"hi/there..\").with_filestem_str(\"here\"), \"hi/here.\");\n-        t!(s: PosixPath::from_str(\"hi/there..\").with_filestem_str(\"\"), \"hi\");\n-\n-        t!(v: PosixPath::new(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n-              b!(\"hi/there\", 0x80, \".exe\"));\n-        t!(v: PosixPath::new(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n-              b!(\"hi/there.\", 0xff));\n-        t!(v: PosixPath::new(b!(\"hi/there\", 0x80)).with_extension(b!(0xff)),\n-              b!(\"hi/there\", 0x80, \".\", 0xff));\n-        t!(v: PosixPath::new(b!(\"hi/there.\", 0xff)).with_extension([]), b!(\"hi/there\"));\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_extension_str(\"exe\"), \"hi/there.exe\");\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_extension_str(\"\"), \"hi/there\");\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_extension_str(\".\"), \"hi/there..\");\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_extension_str(\"..\"), \"hi/there...\");\n-        t!(s: PosixPath::from_str(\"hi/there\").with_extension_str(\"txt\"), \"hi/there.txt\");\n-        t!(s: PosixPath::from_str(\"hi/there\").with_extension_str(\".\"), \"hi/there..\");\n-        t!(s: PosixPath::from_str(\"hi/there\").with_extension_str(\"..\"), \"hi/there...\");\n-        t!(s: PosixPath::from_str(\"hi/there.\").with_extension_str(\"txt\"), \"hi/there.txt\");\n-        t!(s: PosixPath::from_str(\"hi/.foo\").with_extension_str(\"txt\"), \"hi/.foo.txt\");\n-        t!(s: PosixPath::from_str(\"hi/there.txt\").with_extension_str(\".foo\"), \"hi/there..foo\");\n-        t!(s: PosixPath::from_str(\"/\").with_extension_str(\"txt\"), \"/\");\n-        t!(s: PosixPath::from_str(\"/\").with_extension_str(\".\"), \"/\");\n-        t!(s: PosixPath::from_str(\"/\").with_extension_str(\"..\"), \"/\");\n-        t!(s: PosixPath::from_str(\".\").with_extension_str(\"txt\"), \".\");\n-    }\n-\n-    #[test]\n-    fn test_posix_setters() {\n-        macro_rules! t(\n-            (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n-                {\n-                    let path = $path;\n-                    let arg = $arg;\n-                    let mut p1 = PosixPath::from_str(path);\n-                    p1.$set(arg);\n-                    let p2 = PosixPath::from_str(path);\n-                    assert_eq!(p1, p2.$with(arg));\n-                }\n-            );\n-            (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n-                {\n-                    let path = $path;\n-                    let arg = $arg;\n-                    let mut p1 = PosixPath::new(path);\n-                    p1.$set(arg);\n-                    let p2 = PosixPath::new(path);\n-                    assert_eq!(p1, p2.$with(arg));\n-                }\n-            )\n-        )\n-\n-        t!(v: b!(\"a/b/c\"), set_dirname, with_dirname, b!(\"d\"));\n-        t!(v: b!(\"a/b/c\"), set_dirname, with_dirname, b!(\"d/e\"));\n-        t!(v: b!(\"a/\", 0x80, \"/c\"), set_dirname, with_dirname, b!(0xff));\n-        t!(s: \"a/b/c\", set_dirname_str, with_dirname_str, \"d\");\n-        t!(s: \"a/b/c\", set_dirname_str, with_dirname_str, \"d/e\");\n-        t!(s: \"/\", set_dirname_str, with_dirname_str, \"foo\");\n-        t!(s: \"/foo\", set_dirname_str, with_dirname_str, \"bar\");\n-        t!(s: \"a/b/c\", set_dirname_str, with_dirname_str, \"\");\n-        t!(s: \"../..\", set_dirname_str, with_dirname_str, \"x\");\n-        t!(s: \"foo\", set_dirname_str, with_dirname_str, \"../..\");\n-\n-        t!(v: b!(\"a/b/c\"), set_filename, with_filename, b!(\"d\"));\n-        t!(v: b!(\"/\"), set_filename, with_filename, b!(\"foo\"));\n-        t!(v: b!(0x80), set_filename, with_filename, b!(0xff));\n-        t!(s: \"a/b/c\", set_filename_str, with_filename_str, \"d\");\n-        t!(s: \"/\", set_filename_str, with_filename_str, \"foo\");\n-        t!(s: \".\", set_filename_str, with_filename_str, \"foo\");\n-        t!(s: \"a/b\", set_filename_str, with_filename_str, \"\");\n-        t!(s: \"a\", set_filename_str, with_filename_str, \"\");\n-\n-        t!(v: b!(\"hi/there.txt\"), set_filestem, with_filestem, b!(\"here\"));\n-        t!(v: b!(\"hi/there\", 0x80, \".txt\"), set_filestem, with_filestem, b!(\"here\", 0xff));\n-        t!(s: \"hi/there.txt\", set_filestem_str, with_filestem_str, \"here\");\n-        t!(s: \"hi/there.\", set_filestem_str, with_filestem_str, \"here\");\n-        t!(s: \"hi/there\", set_filestem_str, with_filestem_str, \"here\");\n-        t!(s: \"hi/there.txt\", set_filestem_str, with_filestem_str, \"\");\n-        t!(s: \"hi/there\", set_filestem_str, with_filestem_str, \"\");\n-\n-        t!(v: b!(\"hi/there.txt\"), set_extension, with_extension, b!(\"exe\"));\n-        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), set_extension, with_extension, b!(\"exe\", 0xff));\n-        t!(s: \"hi/there.txt\", set_extension_str, with_extension_str, \"exe\");\n-        t!(s: \"hi/there.\", set_extension_str, with_extension_str, \"txt\");\n-        t!(s: \"hi/there\", set_extension_str, with_extension_str, \"txt\");\n-        t!(s: \"hi/there.txt\", set_extension_str, with_extension_str, \"\");\n-        t!(s: \"hi/there\", set_extension_str, with_extension_str, \"\");\n-        t!(s: \".\", set_extension_str, with_extension_str, \"txt\");\n-    }\n-\n-    #[test]\n-    fn test_posix_getters() {\n-        macro_rules! t(\n-            (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n-                {\n-                    let path = $path;\n-                    assert_eq!(path.filename_str(), $filename);\n-                    assert_eq!(path.dirname_str(), $dirname);\n-                    assert_eq!(path.filestem_str(), $filestem);\n-                    assert_eq!(path.extension_str(), $ext);\n-                }\n-            );\n-            (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n-                {\n-                    let path = $path;\n-                    assert_eq!(path.filename(), $filename);\n-                    assert_eq!(path.dirname(), $dirname);\n-                    assert_eq!(path.filestem(), $filestem);\n-                    assert_eq!(path.extension(), $ext);\n-                }\n-            )\n-        )\n-\n-        t!(v: PosixPath::new(b!(\"a/b/c\")), b!(\"c\"), b!(\"a/b\"), b!(\"c\"), None);\n-        t!(v: PosixPath::new(b!(\"a/b/\", 0xff)), b!(0xff), b!(\"a/b\"), b!(0xff), None);\n-        t!(v: PosixPath::new(b!(\"hi/there.\", 0xff)), b!(\"there.\", 0xff), b!(\"hi\"),\n-              b!(\"there\"), Some(b!(0xff)));\n-        t!(s: PosixPath::from_str(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: PosixPath::from_str(\".\"), Some(\"\"), Some(\".\"), Some(\"\"), None);\n-        t!(s: PosixPath::from_str(\"/\"), Some(\"\"), Some(\"/\"), Some(\"\"), None);\n-        t!(s: PosixPath::from_str(\"..\"), Some(\"\"), Some(\"..\"), Some(\"\"), None);\n-        t!(s: PosixPath::from_str(\"../..\"), Some(\"\"), Some(\"../..\"), Some(\"\"), None);\n-        t!(s: PosixPath::from_str(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n-              Some(\"there\"), Some(\"txt\"));\n-        t!(s: PosixPath::from_str(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n-        t!(s: PosixPath::from_str(\"hi/there.\"), Some(\"there.\"), Some(\"hi\"),\n-              Some(\"there\"), Some(\"\"));\n-        t!(s: PosixPath::from_str(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n-        t!(s: PosixPath::from_str(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n-              Some(\".\"), Some(\"there\"));\n-        t!(s: PosixPath::new(b!(\"a/b/\", 0xff)), None, Some(\"a/b\"), None, None);\n-        t!(s: PosixPath::new(b!(\"a/b/\", 0xff, \".txt\")), None, Some(\"a/b\"), None, Some(\"txt\"));\n-        t!(s: PosixPath::new(b!(\"a/b/c.\", 0x80)), None, Some(\"a/b\"), Some(\"c\"), None);\n-        t!(s: PosixPath::new(b!(0xff, \"/b\")), Some(\"b\"), None, Some(\"b\"), None);\n-    }\n-\n-    #[test]\n-    fn test_posix_dir_file_path() {\n-        t!(v: PosixPath::new(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n-        t!(v: PosixPath::new(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n-        t!(s: PosixPath::from_str(\"hi/there\").dir_path(), \"hi\");\n-        t!(s: PosixPath::from_str(\"hi\").dir_path(), \".\");\n-        t!(s: PosixPath::from_str(\"/hi\").dir_path(), \"/\");\n-        t!(s: PosixPath::from_str(\"/\").dir_path(), \"/\");\n-        t!(s: PosixPath::from_str(\"..\").dir_path(), \"..\");\n-        t!(s: PosixPath::from_str(\"../..\").dir_path(), \"../..\");\n-\n-        macro_rules! t(\n-            (s: $path:expr, $exp:expr) => (\n-                {\n-                    let path = $path;\n-                    let left = path.chain_ref(|p| p.as_str());\n-                    assert_eq!(left, $exp);\n-                }\n-            );\n-            (v: $path:expr, $exp:expr) => (\n-                {\n-                    let path = $path;\n-                    let left = path.map(|p| p.as_vec());\n-                    assert_eq!(left, $exp);\n-                }\n-            )\n-        )\n-\n-        t!(v: PosixPath::new(b!(\"hi/there\", 0x80)).file_path(), Some(b!(\"there\", 0x80)));\n-        t!(v: PosixPath::new(b!(\"hi\", 0xff, \"/there\")).file_path(), Some(b!(\"there\")));\n-        t!(s: PosixPath::from_str(\"hi/there\").file_path(), Some(\"there\"));\n-        t!(s: PosixPath::from_str(\"hi\").file_path(), Some(\"hi\"));\n-        t!(s: PosixPath::from_str(\".\").file_path(), None);\n-        t!(s: PosixPath::from_str(\"/\").file_path(), None);\n-        t!(s: PosixPath::from_str(\"..\").file_path(), None);\n-        t!(s: PosixPath::from_str(\"../..\").file_path(), None);\n-    }\n-\n-    #[test]\n-    fn test_posix_is_absolute() {\n-        assert_eq!(PosixPath::from_str(\"a/b/c\").is_absolute(), false);\n-        assert_eq!(PosixPath::from_str(\"/a/b/c\").is_absolute(), true);\n-        assert_eq!(PosixPath::from_str(\"a\").is_absolute(), false);\n-        assert_eq!(PosixPath::from_str(\"/a\").is_absolute(), true);\n-        assert_eq!(PosixPath::from_str(\".\").is_absolute(), false);\n-        assert_eq!(PosixPath::from_str(\"/\").is_absolute(), true);\n-        assert_eq!(PosixPath::from_str(\"..\").is_absolute(), false);\n-        assert_eq!(PosixPath::from_str(\"../..\").is_absolute(), false);\n-    }\n-\n-    #[test]\n-    fn test_posix_is_ancestor_of() {\n-        macro_rules! t(\n-            (s: $path:expr, $dest:expr, $exp:expr) => (\n-                {\n-                    let path = PosixPath::from_str($path);\n-                    let dest = PosixPath::from_str($dest);\n-                    assert_eq!(path.is_ancestor_of(&dest), $exp);\n-                }\n-            )\n-        )\n-\n-        t!(s: \"a/b/c\", \"a/b/c/d\", true);\n-        t!(s: \"a/b/c\", \"a/b/c\", true);\n-        t!(s: \"a/b/c\", \"a/b\", false);\n-        t!(s: \"/a/b/c\", \"/a/b/c\", true);\n-        t!(s: \"/a/b\", \"/a/b/c\", true);\n-        t!(s: \"/a/b/c/d\", \"/a/b/c\", false);\n-        t!(s: \"/a/b\", \"a/b/c\", false);\n-        t!(s: \"a/b\", \"/a/b/c\", false);\n-        t!(s: \"a/b/c\", \"a/b/d\", false);\n-        t!(s: \"../a/b/c\", \"a/b/c\", false);\n-        t!(s: \"a/b/c\", \"../a/b/c\", false);\n-        t!(s: \"a/b/c\", \"a/b/cd\", false);\n-        t!(s: \"a/b/cd\", \"a/b/c\", false);\n-        t!(s: \"../a/b\", \"../a/b/c\", true);\n-        t!(s: \".\", \"a/b\", true);\n-        t!(s: \".\", \".\", true);\n-        t!(s: \"/\", \"/\", true);\n-        t!(s: \"/\", \"/a/b\", true);\n-        t!(s: \"..\", \"a/b\", true);\n-        t!(s: \"../..\", \"a/b\", true);\n-    }\n-\n-    #[test]\n-    fn test_posix_path_relative_from() {\n-        macro_rules! t(\n-            (s: $path:expr, $other:expr, $exp:expr) => (\n-                {\n-                    let path = PosixPath::from_str($path);\n-                    let other = PosixPath::from_str($other);\n-                    let res = path.path_relative_from(&other);\n-                    assert_eq!(res.chain_ref(|x| x.as_str()), $exp);\n-                }\n-            )\n-        )\n-\n-        t!(s: \"a/b/c\", \"a/b\", Some(\"c\"));\n-        t!(s: \"a/b/c\", \"a/b/d\", Some(\"../c\"));\n-        t!(s: \"a/b/c\", \"a/b/c/d\", Some(\"..\"));\n-        t!(s: \"a/b/c\", \"a/b/c\", Some(\".\"));\n-        t!(s: \"a/b/c\", \"a/b/c/d/e\", Some(\"../..\"));\n-        t!(s: \"a/b/c\", \"a/d/e\", Some(\"../../b/c\"));\n-        t!(s: \"a/b/c\", \"d/e/f\", Some(\"../../../a/b/c\"));\n-        t!(s: \"a/b/c\", \"/a/b/c\", None);\n-        t!(s: \"/a/b/c\", \"a/b/c\", Some(\"/a/b/c\"));\n-        t!(s: \"/a/b/c\", \"/a/b/c/d\", Some(\"..\"));\n-        t!(s: \"/a/b/c\", \"/a/b\", Some(\"c\"));\n-        t!(s: \"/a/b/c\", \"/a/b/c/d/e\", Some(\"../..\"));\n-        t!(s: \"/a/b/c\", \"/a/d/e\", Some(\"../../b/c\"));\n-        t!(s: \"/a/b/c\", \"/d/e/f\", Some(\"../../../a/b/c\"));\n-        t!(s: \"hi/there.txt\", \"hi/there\", Some(\"../there.txt\"));\n-        t!(s: \".\", \"a\", Some(\"..\"));\n-        t!(s: \".\", \"a/b\", Some(\"../..\"));\n-        t!(s: \".\", \".\", Some(\".\"));\n-        t!(s: \"a\", \".\", Some(\"a\"));\n-        t!(s: \"a/b\", \".\", Some(\"a/b\"));\n-        t!(s: \"..\", \".\", Some(\"..\"));\n-        t!(s: \"a/b/c\", \"a/b/c\", Some(\".\"));\n-        t!(s: \"/a/b/c\", \"/a/b/c\", Some(\".\"));\n-        t!(s: \"/\", \"/\", Some(\".\"));\n-        t!(s: \"/\", \".\", Some(\"/\"));\n-        t!(s: \"../../a\", \"b\", Some(\"../../../a\"));\n-        t!(s: \"a\", \"../../b\", None);\n-        t!(s: \"../../a\", \"../../b\", Some(\"../a\"));\n-        t!(s: \"../../a\", \"../../a/b\", Some(\"..\"));\n-        t!(s: \"../../a/b\", \"../../a\", Some(\"b\"));\n-    }\n-\n-    #[test]\n-    fn test_posix_component_iter() {\n-        macro_rules! t(\n-            (s: $path:expr, $exp:expr) => (\n-                {\n-                    let path = PosixPath::from_str($path);\n-                    let comps = path.component_iter().to_owned_vec();\n-                    let exp: &[&str] = $exp;\n-                    let exps = exp.iter().map(|x| x.as_bytes()).to_owned_vec();\n-                    assert_eq!(comps, exps);\n-                }\n-            );\n-            (v: [$($arg:expr),+], [$([$($exp:expr),*]),*]) => (\n-                {\n-                    let path = PosixPath::new(b!($($arg),+));\n-                    let comps = path.component_iter().to_owned_vec();\n-                    let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n-                    assert_eq!(comps.as_slice(), exp);\n-                }\n-            )\n-        )\n-\n-        t!(v: [\"a/b/c\"], [[\"a\"], [\"b\"], [\"c\"]]);\n-        t!(v: [\"/\", 0xff, \"/a/\", 0x80], [[0xff], [\"a\"], [0x80]]);\n-        t!(v: [\"../../foo\", 0xcd, \"bar\"], [[\"..\"], [\"..\"], [\"foo\", 0xcd, \"bar\"]]);\n-        t!(s: \"a/b/c\", [\"a\", \"b\", \"c\"]);\n-        t!(s: \"a/b/d\", [\"a\", \"b\", \"d\"]);\n-        t!(s: \"a/b/cd\", [\"a\", \"b\", \"cd\"]);\n-        t!(s: \"/a/b/c\", [\"a\", \"b\", \"c\"]);\n-        t!(s: \"a\", [\"a\"]);\n-        t!(s: \"/a\", [\"a\"]);\n-        t!(s: \"/\", []);\n-        t!(s: \".\", [\".\"]);\n-        t!(s: \"..\", [\"..\"]);\n-        t!(s: \"../..\", [\"..\", \"..\"]);\n-        t!(s: \"../../foo\", [\"..\", \"..\", \"foo\"]);\n-    }\n-}"}, {"sha": "148af0057f52c747334953787e184944015fbcd6", "filename": "src/libstd/path2/mod.rs", "status": "added", "additions": 519, "deletions": 0, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/6d29142219d92f886124057e9ecfdb51ffca19f2/src%2Flibstd%2Fpath2%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d29142219d92f886124057e9ecfdb51ffca19f2/src%2Flibstd%2Fpath2%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fmod.rs?ref=6d29142219d92f886124057e9ecfdb51ffca19f2", "patch": "@@ -0,0 +1,519 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Cross-platform file path handling (re-write)\n+\n+use container::Container;\n+use c_str::CString;\n+use clone::Clone;\n+use iterator::Iterator;\n+use option::{Option, None, Some};\n+use str;\n+use str::StrSlice;\n+use vec;\n+use vec::{CopyableVector, OwnedCopyableVector, OwnedVector};\n+use vec::{ImmutableEqVector, ImmutableVector};\n+\n+pub mod posix;\n+pub mod windows;\n+\n+/// Typedef for POSIX file paths.\n+/// See `posix::Path` for more info.\n+pub type PosixPath = posix::Path;\n+\n+// /// Typedef for Windows file paths.\n+// /// See `windows::Path` for more info.\n+// pub type WindowsPath = windows::Path;\n+\n+/// Typedef for the platform-native path type\n+#[cfg(unix)]\n+pub type Path = PosixPath;\n+// /// Typedef for the platform-native path type\n+//#[cfg(windows)]\n+//pub type Path = WindowsPath;\n+\n+/// Typedef for the POSIX path component iterator.\n+/// See `posix::ComponentIter` for more info.\n+pub type PosixComponentIter<'self> = posix::ComponentIter<'self>;\n+\n+// /// Typedef for the Windows path component iterator.\n+// /// See `windows::ComponentIter` for more info.\n+// pub type WindowsComponentIter<'self> = windows::ComponentIter<'self>;\n+\n+/// Typedef for the platform-native component iterator\n+#[cfg(unix)]\n+pub type ComponentIter<'self> = PosixComponentIter<'self>;\n+// /// Typedef for the platform-native component iterator\n+//#[cfg(windows)]\n+//pub type ComponentIter<'self> = WindowsComponentIter<'self>;\n+\n+// Condition that is raised when a NUL is found in a byte vector given to a Path function\n+condition! {\n+    // this should be a &[u8] but there's a lifetime issue\n+    null_byte: ~[u8] -> ~[u8];\n+}\n+\n+/// A trait that represents the generic operations available on paths\n+pub trait GenericPath: Clone + GenericPathUnsafe {\n+    /// Creates a new Path from a byte vector.\n+    /// The resulting Path will always be normalized.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the path contains a NUL.\n+    #[inline]\n+    fn from_vec(path: &[u8]) -> Self {\n+        if contains_nul(path) {\n+            let path = self::null_byte::cond.raise(path.to_owned());\n+            assert!(!contains_nul(path));\n+            unsafe { GenericPathUnsafe::from_vec_unchecked(path) }\n+        } else {\n+            unsafe { GenericPathUnsafe::from_vec_unchecked(path) }\n+        }\n+    }\n+\n+    /// Creates a new Path from a string.\n+    /// The resulting Path will always be normalized.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the path contains a NUL.\n+    #[inline]\n+    fn from_str(path: &str) -> Self {\n+        GenericPath::from_vec(path.as_bytes())\n+    }\n+\n+    /// Creates a new Path from a CString.\n+    /// The resulting Path will always be normalized.\n+    #[inline]\n+    fn from_c_str(path: CString) -> Self {\n+        // CStrings can't contain NULs\n+        unsafe { GenericPathUnsafe::from_vec_unchecked(path.as_bytes()) }\n+    }\n+\n+    /// Returns the path as a string, if possible.\n+    /// If the path is not representable in utf-8, this returns None.\n+    #[inline]\n+    fn as_str<'a>(&'a self) -> Option<&'a str> {\n+        str::from_bytes_slice_opt(self.as_vec())\n+    }\n+\n+    /// Returns the path as a byte vector\n+    fn as_vec<'a>(&'a self) -> &'a [u8];\n+\n+    /// Returns the directory component of `self`, as a byte vector (with no trailing separator).\n+    /// If `self` has no directory component, returns ['.'].\n+    fn dirname<'a>(&'a self) -> &'a [u8];\n+    /// Returns the directory component of `self`, as a string, if possible.\n+    /// See `dirname` for details.\n+    #[inline]\n+    fn dirname_str<'a>(&'a self) -> Option<&'a str> {\n+        str::from_bytes_slice_opt(self.dirname())\n+    }\n+    /// Returns the file component of `self`, as a byte vector.\n+    /// If `self` represents the root of the file hierarchy, returns the empty vector.\n+    /// If `self` is \".\", returns the empty vector.\n+    fn filename<'a>(&'a self) -> &'a [u8];\n+    /// Returns the file component of `self`, as a string, if possible.\n+    /// See `filename` for details.\n+    #[inline]\n+    fn filename_str<'a>(&'a self) -> Option<&'a str> {\n+        str::from_bytes_slice_opt(self.filename())\n+    }\n+    /// Returns the stem of the filename of `self`, as a byte vector.\n+    /// The stem is the portion of the filename just before the last '.'.\n+    /// If there is no '.', the entire filename is returned.\n+    fn filestem<'a>(&'a self) -> &'a [u8] {\n+        let name = self.filename();\n+        let dot = '.' as u8;\n+        match name.rposition_elem(&dot) {\n+            None | Some(0) => name,\n+            Some(1) if name == bytes!(\"..\") => name,\n+            Some(pos) => name.slice_to(pos)\n+        }\n+    }\n+    /// Returns the stem of the filename of `self`, as a string, if possible.\n+    /// See `filestem` for details.\n+    #[inline]\n+    fn filestem_str<'a>(&'a self) -> Option<&'a str> {\n+        str::from_bytes_slice_opt(self.filestem())\n+    }\n+    /// Returns the extension of the filename of `self`, as an optional byte vector.\n+    /// The extension is the portion of the filename just after the last '.'.\n+    /// If there is no extension, None is returned.\n+    /// If the filename ends in '.', the empty vector is returned.\n+    fn extension<'a>(&'a self) -> Option<&'a [u8]> {\n+        let name = self.filename();\n+        let dot = '.' as u8;\n+        match name.rposition_elem(&dot) {\n+            None | Some(0) => None,\n+            Some(1) if name == bytes!(\"..\") => None,\n+            Some(pos) => Some(name.slice_from(pos+1))\n+        }\n+    }\n+    /// Returns the extension of the filename of `self`, as a string, if possible.\n+    /// See `extension` for details.\n+    #[inline]\n+    fn extension_str<'a>(&'a self) -> Option<&'a str> {\n+        self.extension().chain(|v| str::from_bytes_slice_opt(v))\n+    }\n+\n+    /// Replaces the directory portion of the path with the given byte vector.\n+    /// If `self` represents the root of the filesystem hierarchy, the last path component\n+    /// of the given byte vector becomes the filename.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the dirname contains a NUL.\n+    #[inline]\n+    fn set_dirname(&mut self, dirname: &[u8]) {\n+        if contains_nul(dirname) {\n+            let dirname = self::null_byte::cond.raise(dirname.to_owned());\n+            assert!(!contains_nul(dirname));\n+            unsafe { self.set_dirname_unchecked(dirname) }\n+        } else {\n+            unsafe { self.set_dirname_unchecked(dirname) }\n+        }\n+    }\n+    /// Replaces the directory portion of the path with the given string.\n+    /// See `set_dirname` for details.\n+    #[inline]\n+    fn set_dirname_str(&mut self, dirname: &str) {\n+        self.set_dirname(dirname.as_bytes())\n+    }\n+    /// Replaces the filename portion of the path with the given byte vector.\n+    /// If the replacement name is [], this is equivalent to popping the path.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the filename contains a NUL.\n+    #[inline]\n+    fn set_filename(&mut self, filename: &[u8]) {\n+        if contains_nul(filename) {\n+            let filename = self::null_byte::cond.raise(filename.to_owned());\n+            assert!(!contains_nul(filename));\n+            unsafe { self.set_filename_unchecked(filename) }\n+        } else {\n+            unsafe { self.set_filename_unchecked(filename) }\n+        }\n+    }\n+    /// Replaces the filename portion of the path with the given string.\n+    /// See `set_filename` for details.\n+    #[inline]\n+    fn set_filename_str(&mut self, filename: &str) {\n+        self.set_filename(filename.as_bytes())\n+    }\n+    /// Replaces the filestem with the given byte vector.\n+    /// If there is no extension in `self` (or `self` has no filename), this is equivalent\n+    /// to `set_filename`. Otherwise, if the given byte vector is [], the extension (including\n+    /// the preceding '.') becomes the new filename.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the filestem contains a NUL.\n+    fn set_filestem(&mut self, filestem: &[u8]) {\n+        // borrowck is being a pain here\n+        let val = {\n+            let name = self.filename();\n+            if !name.is_empty() {\n+                let dot = '.' as u8;\n+                match name.rposition_elem(&dot) {\n+                    None | Some(0) => None,\n+                    Some(idx) => {\n+                        let mut v;\n+                        if contains_nul(filestem) {\n+                            let filestem = self::null_byte::cond.raise(filestem.to_owned());\n+                            assert!(!contains_nul(filestem));\n+                            v = vec::with_capacity(filestem.len() + name.len() - idx);\n+                            v.push_all(filestem);\n+                        } else {\n+                            v = vec::with_capacity(filestem.len() + name.len() - idx);\n+                            v.push_all(filestem);\n+                        }\n+                        v.push_all(name.slice_from(idx));\n+                        Some(v)\n+                    }\n+                }\n+            } else { None }\n+        };\n+        match val {\n+            None => self.set_filename(filestem),\n+            Some(v) => unsafe { self.set_filename_unchecked(v) }\n+        }\n+    }\n+    /// Replaces the filestem with the given string.\n+    /// See `set_filestem` for details.\n+    #[inline]\n+    fn set_filestem_str(&mut self, filestem: &str) {\n+        self.set_filestem(filestem.as_bytes())\n+    }\n+    /// Replaces the extension with the given byte vector.\n+    /// If there is no extension in `self`, this adds one.\n+    /// If the given byte vector is [], this removes the extension.\n+    /// If `self` has no filename, this is a no-op.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the extension contains a NUL.\n+    fn set_extension(&mut self, extension: &[u8]) {\n+        // borrowck causes problems here too\n+        let val = {\n+            let name = self.filename();\n+            if !name.is_empty() {\n+                let dot = '.' as u8;\n+                match name.rposition_elem(&dot) {\n+                    None | Some(0) => {\n+                        if extension.is_empty() {\n+                            None\n+                        } else {\n+                            let mut v;\n+                            if contains_nul(extension) {\n+                                let extension = self::null_byte::cond.raise(extension.to_owned());\n+                                assert!(!contains_nul(extension));\n+                                v = vec::with_capacity(name.len() + extension.len() + 1);\n+                                v.push_all(name);\n+                                v.push(dot);\n+                                v.push_all(extension);\n+                            } else {\n+                                v = vec::with_capacity(name.len() + extension.len() + 1);\n+                                v.push_all(name);\n+                                v.push(dot);\n+                                v.push_all(extension);\n+                            }\n+                            Some(v)\n+                        }\n+                    }\n+                    Some(idx) => {\n+                        if extension.is_empty() {\n+                            Some(name.slice_to(idx).to_owned())\n+                        } else {\n+                            let mut v;\n+                            if contains_nul(extension) {\n+                                let extension = self::null_byte::cond.raise(extension.to_owned());\n+                                assert!(!contains_nul(extension));\n+                                v = vec::with_capacity(idx + extension.len() + 1);\n+                                v.push_all(name.slice_to(idx+1));\n+                                v.push_all(extension);\n+                            } else {\n+                                v = vec::with_capacity(idx + extension.len() + 1);\n+                                v.push_all(name.slice_to(idx+1));\n+                                v.push_all(extension);\n+                            }\n+                            Some(v)\n+                        }\n+                    }\n+                }\n+            } else { None }\n+        };\n+        match val {\n+            None => (),\n+            Some(v) => unsafe { self.set_filename_unchecked(v) }\n+        }\n+    }\n+    /// Replaces the extension with the given string.\n+    /// See `set_extension` for details.\n+    #[inline]\n+    fn set_extension_str(&mut self, extension: &str) {\n+        self.set_extension(extension.as_bytes())\n+    }\n+\n+    /// Returns a new Path constructed by replacing the dirname with the given byte vector.\n+    /// See `set_dirname` for details.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the dirname contains a NUL.\n+    #[inline]\n+    fn with_dirname(&self, dirname: &[u8]) -> Self {\n+        let mut p = self.clone();\n+        p.set_dirname(dirname);\n+        p\n+    }\n+    /// Returns a new Path constructed by replacing the dirname with the given string.\n+    /// See `set_dirname` for details.\n+    #[inline]\n+    fn with_dirname_str(&self, dirname: &str) -> Self {\n+        self.with_dirname(dirname.as_bytes())\n+    }\n+    /// Returns a new Path constructed by replacing the filename with the given byte vector.\n+    /// See `set_filename` for details.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the filename contains a NUL.\n+    #[inline]\n+    fn with_filename(&self, filename: &[u8]) -> Self {\n+        let mut p = self.clone();\n+        p.set_filename(filename);\n+        p\n+    }\n+    /// Returns a new Path constructed by replacing the filename with the given string.\n+    /// See `set_filename` for details.\n+    #[inline]\n+    fn with_filename_str(&self, filename: &str) -> Self {\n+        self.with_filename(filename.as_bytes())\n+    }\n+    /// Returns a new Path constructed by setting the filestem to the given byte vector.\n+    /// See `set_filestem` for details.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the filestem contains a NUL.\n+    #[inline]\n+    fn with_filestem(&self, filestem: &[u8]) -> Self {\n+        let mut p = self.clone();\n+        p.set_filestem(filestem);\n+        p\n+    }\n+    /// Returns a new Path constructed by setting the filestem to the given string.\n+    /// See `set_filestem` for details.\n+    #[inline]\n+    fn with_filestem_str(&self, filestem: &str) -> Self {\n+        self.with_filestem(filestem.as_bytes())\n+    }\n+    /// Returns a new Path constructed by setting the extension to the given byte vector.\n+    /// See `set_extension` for details.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the extension contains a NUL.\n+    #[inline]\n+    fn with_extension(&self, extension: &[u8]) -> Self {\n+        let mut p = self.clone();\n+        p.set_extension(extension);\n+        p\n+    }\n+    /// Returns a new Path constructed by setting the extension to the given string.\n+    /// See `set_extension` for details.\n+    #[inline]\n+    fn with_extension_str(&self, extension: &str) -> Self {\n+        self.with_extension(extension.as_bytes())\n+    }\n+\n+    /// Returns the directory component of `self`, as a Path.\n+    /// If `self` represents the root of the filesystem hierarchy, returns `self`.\n+    fn dir_path(&self) -> Self {\n+        GenericPath::from_vec(self.dirname())\n+    }\n+    /// Returns the file component of `self`, as a relative Path.\n+    /// If `self` represents the root of the filesystem hierarchy, returns None.\n+    fn file_path(&self) -> Option<Self> {\n+        match self.filename() {\n+            [] => None,\n+            v => Some(GenericPath::from_vec(v))\n+        }\n+    }\n+\n+    /// Pushes a path (as a byte vector) onto `self`.\n+    /// If the argument represents an absolute path, it replaces `self`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the path contains a NUL.\n+    #[inline]\n+    fn push(&mut self, path: &[u8]) {\n+        if contains_nul(path) {\n+            let path = self::null_byte::cond.raise(path.to_owned());\n+            assert!(!contains_nul(path));\n+            unsafe { self.push_unchecked(path) }\n+        } else {\n+            unsafe { self.push_unchecked(path) }\n+        }\n+    }\n+    /// Pushes a path (as a string) onto `self.\n+    /// See `push` for details.\n+    #[inline]\n+    fn push_str(&mut self, path: &str) {\n+        self.push(path.as_bytes())\n+    }\n+    /// Pushes a Path onto `self`.\n+    /// If the argument represents an absolute path, it replaces `self`.\n+    #[inline]\n+    fn push_path(&mut self, path: &Self) {\n+        self.push(path.as_vec())\n+    }\n+    /// Pops the last path component off of `self` and returns it.\n+    /// If `self` represents the root of the file hierarchy, None is returned.\n+    fn pop_opt(&mut self) -> Option<~[u8]>;\n+    /// Pops the last path component off of `self` and returns it as a string, if possible.\n+    /// `self` will still be modified even if None is returned.\n+    /// See `pop_opt` for details.\n+    #[inline]\n+    fn pop_opt_str(&mut self) -> Option<~str> {\n+        self.pop_opt().chain(|v| str::from_bytes_owned_opt(v))\n+    }\n+\n+    /// Returns a new Path constructed by joining `self` with the given path (as a byte vector).\n+    /// If the given path is absolute, the new Path will represent just that.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the path contains a NUL.\n+    #[inline]\n+    fn join(&self, path: &[u8]) -> Self {\n+        let mut p = self.clone();\n+        p.push(path);\n+        p\n+    }\n+    /// Returns a new Path constructed by joining `self` with the given path (as a string).\n+    /// See `join` for details.\n+    #[inline]\n+    fn join_str(&self, path: &str) -> Self {\n+        self.join(path.as_bytes())\n+    }\n+    /// Returns a new Path constructed by joining `self` with the given path.\n+    /// If the given path is absolute, the new Path will represent just that.\n+    #[inline]\n+    fn join_path(&self, path: &Self) -> Self {\n+        let mut p = self.clone();\n+        p.push_path(path);\n+        p\n+    }\n+\n+    /// Returns whether `self` represents an absolute path.\n+    fn is_absolute(&self) -> bool;\n+\n+    /// Returns whether `self` is equal to, or is an ancestor of, the given path.\n+    /// If both paths are relative, they are compared as though they are relative\n+    /// to the same parent path.\n+    fn is_ancestor_of(&self, other: &Self) -> bool;\n+\n+    /// Returns the Path that, were it joined to `base`, would yield `self`.\n+    /// If no such path exists, None is returned.\n+    /// If `self` is absolute and `base` is relative, or on Windows if both\n+    /// paths refer to separate drives, an absolute path is returned.\n+    fn path_relative_from(&self, base: &Self) -> Option<Self>;\n+}\n+\n+/// A trait that represents the unsafe operations on GenericPaths\n+pub trait GenericPathUnsafe {\n+    /// Creates a new Path from a byte vector without checking for null bytes.\n+    /// The resulting Path will always be normalized.\n+    unsafe fn from_vec_unchecked(path: &[u8]) -> Self;\n+\n+    /// Replaces the directory portion of the path with the given byte vector without\n+    /// checking for null bytes.\n+    /// See `set_dirname` for details.\n+    unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]);\n+\n+    /// Replaces the filename portion of the path with the given byte vector without\n+    /// checking for null bytes.\n+    /// See `set_filename` for details.\n+    unsafe fn set_filename_unchecked(&mut self, filename: &[u8]);\n+\n+    /// Pushes a path onto `self` without checking for null bytes.\n+    /// See `push` for details.\n+    unsafe fn push_unchecked(&mut self, path: &[u8]);\n+}\n+\n+#[inline(always)]\n+fn contains_nul(v: &[u8]) -> bool {\n+    v.iter().any(|&x| x == 0)\n+}"}, {"sha": "fa6d1e32ebd09229d163ba09d71ff97e43b4fb1a", "filename": "src/libstd/path2/posix.rs", "status": "added", "additions": 1152, "deletions": 0, "changes": 1152, "blob_url": "https://github.com/rust-lang/rust/blob/6d29142219d92f886124057e9ecfdb51ffca19f2/src%2Flibstd%2Fpath2%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d29142219d92f886124057e9ecfdb51ffca19f2/src%2Flibstd%2Fpath2%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fposix.rs?ref=6d29142219d92f886124057e9ecfdb51ffca19f2", "patch": "@@ -0,0 +1,1152 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! POSIX file path handling\n+\n+use container::Container;\n+use c_str::{CString, ToCStr};\n+use clone::Clone;\n+use cmp::Eq;\n+use from_str::FromStr;\n+use iterator::{AdditiveIterator, Extendable, Iterator};\n+use option::{Option, None, Some};\n+use str;\n+use str::Str;\n+use util;\n+use vec;\n+use vec::CopyableVector;\n+use vec::{Vector, VectorVector};\n+use super::{GenericPath, GenericPathUnsafe};\n+\n+/// Iterator that yields successive components of a Path\n+pub type ComponentIter<'self> = vec::SplitIterator<'self, u8>;\n+\n+/// Represents a POSIX file path\n+#[deriving(Clone, DeepClone)]\n+pub struct Path {\n+    priv repr: ~[u8], // assumed to never be empty or contain NULs\n+    priv sepidx: Option<uint> // index of the final separator in repr\n+}\n+\n+/// The standard path separator character\n+pub static sep: u8 = '/' as u8;\n+\n+/// Returns whether the given byte is a path separator\n+#[inline]\n+pub fn is_sep(u: &u8) -> bool {\n+    *u == sep\n+}\n+\n+impl Eq for Path {\n+    fn eq(&self, other: &Path) -> bool {\n+        self.repr == other.repr\n+    }\n+}\n+\n+impl FromStr for Path {\n+    fn from_str(s: &str) -> Option<Path> {\n+        let v = s.as_bytes();\n+        if contains_nul(v) {\n+            None\n+        } else {\n+            Some(unsafe { GenericPathUnsafe::from_vec_unchecked(v) })\n+        }\n+    }\n+}\n+\n+impl ToCStr for Path {\n+    #[inline]\n+    fn to_c_str(&self) -> CString {\n+        // The Path impl guarantees no internal NUL\n+        unsafe { self.as_vec().to_c_str_unchecked() }\n+    }\n+\n+    #[inline]\n+    unsafe fn to_c_str_unchecked(&self) -> CString {\n+        self.as_vec().to_c_str_unchecked()\n+    }\n+}\n+\n+impl GenericPathUnsafe for Path {\n+    unsafe fn from_vec_unchecked(path: &[u8]) -> Path {\n+        let path = Path::normalize(path);\n+        assert!(!path.is_empty());\n+        let idx = path.rposition_elem(&sep);\n+        Path{ repr: path, sepidx: idx }\n+    }\n+\n+    unsafe fn set_dirname_unchecked(&mut self, dirname: &[u8]) {\n+        match self.sepidx {\n+            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => {\n+                self.repr = Path::normalize(dirname);\n+            }\n+            None => {\n+                let mut v = vec::with_capacity(dirname.len() + self.repr.len() + 1);\n+                v.push_all(dirname);\n+                v.push(sep);\n+                v.push_all(self.repr);\n+                self.repr = Path::normalize(v);\n+            }\n+            Some(0) if self.repr.len() == 1 && self.repr[0] == sep => {\n+                self.repr = Path::normalize(dirname);\n+            }\n+            Some(idx) if dirname.is_empty() => {\n+                let v = Path::normalize(self.repr.slice_from(idx+1));\n+                self.repr = v;\n+            }\n+            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n+                self.repr = Path::normalize(dirname);\n+            }\n+            Some(idx) => {\n+                let mut v = vec::with_capacity(dirname.len() + self.repr.len() - idx);\n+                v.push_all(dirname);\n+                v.push_all(self.repr.slice_from(idx));\n+                self.repr = Path::normalize(v);\n+            }\n+        }\n+        self.sepidx = self.repr.rposition_elem(&sep);\n+    }\n+\n+    unsafe fn set_filename_unchecked(&mut self, filename: &[u8]) {\n+        match self.sepidx {\n+            None if bytes!(\"..\") == self.repr => {\n+                let mut v = vec::with_capacity(3 + filename.len());\n+                v.push_all(dot_dot_static);\n+                v.push(sep);\n+                v.push_all(filename);\n+                self.repr = Path::normalize(v);\n+            }\n+            None => {\n+                self.repr = Path::normalize(filename);\n+            }\n+            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => {\n+                let mut v = vec::with_capacity(self.repr.len() + 1 + filename.len());\n+                v.push_all(self.repr);\n+                v.push(sep);\n+                v.push_all(filename);\n+                self.repr = Path::normalize(v);\n+            }\n+            Some(idx) => {\n+                let mut v = vec::with_capacity(self.repr.len() - idx + filename.len());\n+                v.push_all(self.repr.slice_to(idx+1));\n+                v.push_all(filename);\n+                self.repr = Path::normalize(v);\n+            }\n+        }\n+        self.sepidx = self.repr.rposition_elem(&sep);\n+    }\n+\n+    unsafe fn push_unchecked(&mut self, path: &[u8]) {\n+        if !path.is_empty() {\n+            if path[0] == sep {\n+                self.repr = Path::normalize(path);\n+            }  else {\n+                let mut v = vec::with_capacity(self.repr.len() + path.len() + 1);\n+                v.push_all(self.repr);\n+                v.push(sep);\n+                v.push_all(path);\n+                self.repr = Path::normalize(v);\n+            }\n+            self.sepidx = self.repr.rposition_elem(&sep);\n+        }\n+    }\n+}\n+\n+impl GenericPath for Path {\n+    #[inline]\n+    fn as_vec<'a>(&'a self) -> &'a [u8] {\n+        self.repr.as_slice()\n+    }\n+\n+    fn dirname<'a>(&'a self) -> &'a [u8] {\n+        match self.sepidx {\n+            None if bytes!(\"..\") == self.repr => self.repr.as_slice(),\n+            None => dot_static,\n+            Some(0) => self.repr.slice_to(1),\n+            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => self.repr.as_slice(),\n+            Some(idx) => self.repr.slice_to(idx)\n+        }\n+    }\n+\n+    fn filename<'a>(&'a self) -> &'a [u8] {\n+        match self.sepidx {\n+            None if bytes!(\".\") == self.repr || bytes!(\"..\") == self.repr => &[],\n+            None => self.repr.as_slice(),\n+            Some(idx) if self.repr.slice_from(idx+1) == bytes!(\"..\") => &[],\n+            Some(idx) => self.repr.slice_from(idx+1)\n+        }\n+    }\n+\n+    fn pop_opt(&mut self) -> Option<~[u8]> {\n+        match self.sepidx {\n+            None if bytes!(\".\") == self.repr => None,\n+            None => {\n+                let mut v = ~['.' as u8];\n+                util::swap(&mut v, &mut self.repr);\n+                self.sepidx = None;\n+                Some(v)\n+            }\n+            Some(0) if bytes!(\"/\") == self.repr => None,\n+            Some(idx) => {\n+                let v = self.repr.slice_from(idx+1).to_owned();\n+                if idx == 0 {\n+                    self.repr.truncate(idx+1);\n+                } else {\n+                    self.repr.truncate(idx);\n+                }\n+                self.sepidx = self.repr.rposition_elem(&sep);\n+                Some(v)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn is_absolute(&self) -> bool {\n+        self.repr[0] == sep\n+    }\n+\n+    fn is_ancestor_of(&self, other: &Path) -> bool {\n+        if self.is_absolute() != other.is_absolute() {\n+            false\n+        } else {\n+            let mut ita = self.component_iter();\n+            let mut itb = other.component_iter();\n+            if bytes!(\".\") == self.repr {\n+                return itb.next() != Some(bytes!(\"..\"));\n+            }\n+            loop {\n+                match (ita.next(), itb.next()) {\n+                    (None, _) => break,\n+                    (Some(a), Some(b)) if a == b => { loop },\n+                    (Some(a), _) if a == bytes!(\"..\") => {\n+                        // if ita contains only .. components, it's an ancestor\n+                        return ita.all(|x| x == bytes!(\"..\"));\n+                    }\n+                    _ => return false\n+                }\n+            }\n+            true\n+        }\n+    }\n+\n+    fn path_relative_from(&self, base: &Path) -> Option<Path> {\n+        if self.is_absolute() != base.is_absolute() {\n+            if self.is_absolute() {\n+                Some(self.clone())\n+            } else {\n+                None\n+            }\n+        } else {\n+            let mut ita = self.component_iter();\n+            let mut itb = base.component_iter();\n+            let mut comps = ~[];\n+            loop {\n+                match (ita.next(), itb.next()) {\n+                    (None, None) => break,\n+                    (Some(a), None) => {\n+                        comps.push(a);\n+                        comps.extend(&mut ita);\n+                        break;\n+                    }\n+                    (None, _) => comps.push(dot_dot_static),\n+                    (Some(a), Some(b)) if comps.is_empty() && a == b => (),\n+                    (Some(a), Some(b)) if b == bytes!(\".\") => comps.push(a),\n+                    (Some(_), Some(b)) if b == bytes!(\"..\") => return None,\n+                    (Some(a), Some(_)) => {\n+                        comps.push(dot_dot_static);\n+                        for _ in itb {\n+                            comps.push(dot_dot_static);\n+                        }\n+                        comps.push(a);\n+                        comps.extend(&mut ita);\n+                        break;\n+                    }\n+                }\n+            }\n+            Some(Path::new(comps.connect_vec(&sep)))\n+        }\n+    }\n+}\n+\n+impl Path {\n+    /// Returns a new Path from a byte vector\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the vector contains a NUL.\n+    #[inline]\n+    pub fn new(v: &[u8]) -> Path {\n+        GenericPath::from_vec(v)\n+    }\n+\n+    /// Returns a new Path from a string\n+    ///\n+    /// # Failure\n+    ///\n+    /// Raises the `null_byte` condition if the str contains a NUL.\n+    #[inline]\n+    pub fn from_str(s: &str) -> Path {\n+        GenericPath::from_str(s)\n+    }\n+\n+    /// Converts the Path into an owned byte vector\n+    pub fn into_vec(self) -> ~[u8] {\n+        self.repr\n+    }\n+\n+    /// Converts the Path into an owned string, if possible\n+    pub fn into_str(self) -> Option<~str> {\n+        str::from_bytes_owned_opt(self.repr)\n+    }\n+\n+    /// Returns a normalized byte vector representation of a path, by removing all empty\n+    /// components, and unnecessary . and .. components.\n+    pub fn normalize<V: Vector<u8>+CopyableVector<u8>>(v: V) -> ~[u8] {\n+        // borrowck is being very picky\n+        let val = {\n+            let is_abs = !v.as_slice().is_empty() && v.as_slice()[0] == sep;\n+            let v_ = if is_abs { v.as_slice().slice_from(1) } else { v.as_slice() };\n+            let comps = normalize_helper(v_, is_abs, is_sep);\n+            match comps {\n+                None => None,\n+                Some(comps) => {\n+                    if is_abs && comps.is_empty() {\n+                        Some(~[sep])\n+                    } else {\n+                        let n = if is_abs { comps.len() } else { comps.len() - 1} +\n+                                comps.iter().map(|v| v.len()).sum();\n+                        let mut v = vec::with_capacity(n);\n+                        let mut it = comps.move_iter();\n+                        if !is_abs {\n+                            match it.next() {\n+                                None => (),\n+                                Some(comp) => v.push_all(comp)\n+                            }\n+                        }\n+                        for comp in it {\n+                            v.push(sep);\n+                            v.push_all(comp);\n+                        }\n+                        Some(v)\n+                    }\n+                }\n+            }\n+        };\n+        match val {\n+            None => v.into_owned(),\n+            Some(val) => val\n+        }\n+    }\n+\n+    /// Returns an iterator that yields each component of the path in turn.\n+    /// Does not distinguish between absolute and relative paths, e.g.\n+    /// /a/b/c and a/b/c yield the same set of components.\n+    /// A path of \"/\" yields no components. A path of \".\" yields one component.\n+    pub fn component_iter<'a>(&'a self) -> ComponentIter<'a> {\n+        let v = if self.repr[0] == sep {\n+            self.repr.slice_from(1)\n+        } else { self.repr.as_slice() };\n+        let mut ret = v.split_iter(is_sep);\n+        if v.is_empty() {\n+            // consume the empty \"\" component\n+            ret.next();\n+        }\n+        ret\n+    }\n+}\n+\n+// None result means the byte vector didn't need normalizing\n+// FIXME (#8169): Pull this into parent module once visibility works\n+fn normalize_helper<'a>(v: &'a [u8], is_abs: bool, f: &'a fn(&u8) -> bool) -> Option<~[&'a [u8]]> {\n+    if is_abs && v.as_slice().is_empty() {\n+        return None;\n+    }\n+    let mut comps: ~[&'a [u8]] = ~[];\n+    let mut n_up = 0u;\n+    let mut changed = false;\n+    for comp in v.split_iter(f) {\n+        if comp.is_empty() { changed = true }\n+        else if comp == bytes!(\".\") { changed = true }\n+        else if comp == bytes!(\"..\") {\n+            if is_abs && comps.is_empty() { changed = true }\n+            else if comps.len() == n_up { comps.push(dot_dot_static); n_up += 1 }\n+            else { comps.pop_opt(); changed = true }\n+        } else { comps.push(comp) }\n+    }\n+    if changed {\n+        if comps.is_empty() && !is_abs {\n+            if v == bytes!(\".\") {\n+                return None;\n+            }\n+            comps.push(dot_static);\n+        }\n+        Some(comps)\n+    } else {\n+        None\n+    }\n+}\n+\n+// FIXME (#8169): Pull this into parent module once visibility works\n+#[inline(always)]\n+fn contains_nul(v: &[u8]) -> bool {\n+    v.iter().any(|&x| x == 0)\n+}\n+\n+static dot_static: &'static [u8] = &'static ['.' as u8];\n+static dot_dot_static: &'static [u8] = &'static ['.' as u8, '.' as u8];\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use option::{Some, None};\n+    use iterator::Iterator;\n+    use str;\n+    use vec::Vector;\n+\n+    macro_rules! t(\n+        (s: $path:expr, $exp:expr) => (\n+            {\n+                let path = $path;\n+                assert_eq!(path.as_str(), Some($exp));\n+            }\n+        );\n+        (v: $path:expr, $exp:expr) => (\n+            {\n+                let path = $path;\n+                assert_eq!(path.as_vec(), $exp);\n+            }\n+        )\n+    )\n+\n+    macro_rules! b(\n+        ($($arg:expr),+) => (\n+            bytes!($($arg),+)\n+        )\n+    )\n+\n+    #[test]\n+    fn test_paths() {\n+        t!(v: Path::new([]), b!(\".\"));\n+        t!(v: Path::new(b!(\"/\")), b!(\"/\"));\n+        t!(v: Path::new(b!(\"a/b/c\")), b!(\"a/b/c\"));\n+        t!(v: Path::new(b!(\"a/b/c\", 0xff)), b!(\"a/b/c\", 0xff));\n+        t!(v: Path::new(b!(0xff, \"/../foo\", 0x80)), b!(\"foo\", 0x80));\n+        let p = Path::new(b!(\"a/b/c\", 0xff));\n+        assert_eq!(p.as_str(), None);\n+\n+        t!(s: Path::from_str(\"\"), \".\");\n+        t!(s: Path::from_str(\"/\"), \"/\");\n+        t!(s: Path::from_str(\"hi\"), \"hi\");\n+        t!(s: Path::from_str(\"/lib\"), \"/lib\");\n+        t!(s: Path::from_str(\"hi/there\"), \"hi/there\");\n+        t!(s: Path::from_str(\"hi/there.txt\"), \"hi/there.txt\");\n+\n+        t!(s: Path::from_str(\"hi/there/\"), \"hi/there\");\n+        t!(s: Path::from_str(\"hi/../there\"), \"there\");\n+        t!(s: Path::from_str(\"../hi/there\"), \"../hi/there\");\n+        t!(s: Path::from_str(\"/../hi/there\"), \"/hi/there\");\n+        t!(s: Path::from_str(\"foo/..\"), \".\");\n+        t!(s: Path::from_str(\"/foo/..\"), \"/\");\n+        t!(s: Path::from_str(\"/foo/../..\"), \"/\");\n+        t!(s: Path::from_str(\"/foo/../../bar\"), \"/bar\");\n+        t!(s: Path::from_str(\"/./hi/./there/.\"), \"/hi/there\");\n+        t!(s: Path::from_str(\"/./hi/./there/./..\"), \"/hi\");\n+        t!(s: Path::from_str(\"foo/../..\"), \"..\");\n+        t!(s: Path::from_str(\"foo/../../..\"), \"../..\");\n+        t!(s: Path::from_str(\"foo/../../bar\"), \"../bar\");\n+\n+        assert_eq!(Path::new(b!(\"foo/bar\")).into_vec(), b!(\"foo/bar\").to_owned());\n+        assert_eq!(Path::new(b!(\"/foo/../../bar\")).into_vec(),\n+                   b!(\"/bar\").to_owned());\n+        assert_eq!(Path::from_str(\"foo/bar\").into_str(), Some(~\"foo/bar\"));\n+        assert_eq!(Path::from_str(\"/foo/../../bar\").into_str(), Some(~\"/bar\"));\n+\n+        let p = Path::new(b!(\"foo/bar\", 0x80));\n+        assert_eq!(p.as_str(), None);\n+        assert_eq!(Path::new(b!(\"foo\", 0xff, \"/bar\")).into_str(), None);\n+    }\n+\n+    #[test]\n+    fn test_null_byte() {\n+        use path2::null_byte::cond;\n+\n+        let mut handled = false;\n+        let mut p = do cond.trap(|v| {\n+            handled = true;\n+            assert_eq!(v.as_slice(), b!(\"foo/bar\", 0));\n+            (b!(\"/bar\").to_owned())\n+        }).inside {\n+            Path::new(b!(\"foo/bar\", 0))\n+        };\n+        assert!(handled);\n+        assert_eq!(p.as_vec(), b!(\"/bar\"));\n+\n+        handled = false;\n+        do cond.trap(|v| {\n+            handled = true;\n+            assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n+            (b!(\"foo\").to_owned())\n+        }).inside {\n+            p.set_filename(b!(\"f\", 0, \"o\"))\n+        };\n+        assert!(handled);\n+        assert_eq!(p.as_vec(), b!(\"/foo\"));\n+\n+        handled = false;\n+        do cond.trap(|v| {\n+            handled = true;\n+            assert_eq!(v.as_slice(), b!(\"null/\", 0, \"/byte\"));\n+            (b!(\"null/byte\").to_owned())\n+        }).inside {\n+            p.set_dirname(b!(\"null/\", 0, \"/byte\"));\n+        };\n+        assert!(handled);\n+        assert_eq!(p.as_vec(), b!(\"null/byte/foo\"));\n+\n+        handled = false;\n+        do cond.trap(|v| {\n+            handled = true;\n+            assert_eq!(v.as_slice(), b!(\"f\", 0, \"o\"));\n+            (b!(\"foo\").to_owned())\n+        }).inside {\n+            p.push(b!(\"f\", 0, \"o\"));\n+        };\n+        assert!(handled);\n+        assert_eq!(p.as_vec(), b!(\"null/byte/foo/foo\"));\n+    }\n+\n+    #[test]\n+    fn test_null_byte_fail() {\n+        use path2::null_byte::cond;\n+        use task;\n+\n+        macro_rules! t(\n+            ($name:expr => $code:block) => (\n+                {\n+                    let mut t = task::task();\n+                    t.supervised();\n+                    t.name($name);\n+                    let res = do t.try $code;\n+                    assert!(res.is_err());\n+                }\n+            )\n+        )\n+\n+        t!(~\"new() w/nul\" => {\n+            do cond.trap(|_| {\n+                (b!(\"null\", 0).to_owned())\n+            }).inside {\n+                Path::new(b!(\"foo/bar\", 0))\n+            };\n+        })\n+\n+        t!(~\"set_filename w/nul\" => {\n+            let mut p = Path::new(b!(\"foo/bar\"));\n+            do cond.trap(|_| {\n+                (b!(\"null\", 0).to_owned())\n+            }).inside {\n+                p.set_filename(b!(\"foo\", 0))\n+            };\n+        })\n+\n+        t!(~\"set_dirname w/nul\" => {\n+            let mut p = Path::new(b!(\"foo/bar\"));\n+            do cond.trap(|_| {\n+                (b!(\"null\", 0).to_owned())\n+            }).inside {\n+                p.set_dirname(b!(\"foo\", 0))\n+            };\n+        })\n+\n+        t!(~\"push w/nul\" => {\n+            let mut p = Path::new(b!(\"foo/bar\"));\n+            do cond.trap(|_| {\n+                (b!(\"null\", 0).to_owned())\n+            }).inside {\n+                p.push(b!(\"foo\", 0))\n+            };\n+        })\n+    }\n+\n+    #[test]\n+    fn test_components() {\n+        macro_rules! t(\n+            (s: $path:expr, $op:ident, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    assert_eq!(path.$op(), ($exp).as_bytes());\n+                }\n+            );\n+            (s: $path:expr, $op:ident, $exp:expr, opt) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let left = path.$op().map(|&x| str::from_bytes_slice(x));\n+                    assert_eq!(left, $exp);\n+                }\n+            );\n+            (v: $path:expr, $op:ident, $exp:expr) => (\n+                {\n+                    let path = Path::new($path);\n+                    assert_eq!(path.$op(), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(v: b!(\"a/b/c\"), filename, b!(\"c\"));\n+        t!(v: b!(\"a/b/c\", 0xff), filename, b!(\"c\", 0xff));\n+        t!(v: b!(\"a/b\", 0xff, \"/c\"), filename, b!(\"c\"));\n+        t!(s: \"a/b/c\", filename, \"c\");\n+        t!(s: \"/a/b/c\", filename, \"c\");\n+        t!(s: \"a\", filename, \"a\");\n+        t!(s: \"/a\", filename, \"a\");\n+        t!(s: \".\", filename, \"\");\n+        t!(s: \"/\", filename, \"\");\n+        t!(s: \"..\", filename, \"\");\n+        t!(s: \"../..\", filename, \"\");\n+\n+        t!(v: b!(\"a/b/c\"), dirname, b!(\"a/b\"));\n+        t!(v: b!(\"a/b/c\", 0xff), dirname, b!(\"a/b\"));\n+        t!(v: b!(\"a/b\", 0xff, \"/c\"), dirname, b!(\"a/b\", 0xff));\n+        t!(s: \"a/b/c\", dirname, \"a/b\");\n+        t!(s: \"/a/b/c\", dirname, \"/a/b\");\n+        t!(s: \"a\", dirname, \".\");\n+        t!(s: \"/a\", dirname, \"/\");\n+        t!(s: \".\", dirname, \".\");\n+        t!(s: \"/\", dirname, \"/\");\n+        t!(s: \"..\", dirname, \"..\");\n+        t!(s: \"../..\", dirname, \"../..\");\n+\n+        t!(v: b!(\"hi/there.txt\"), filestem, b!(\"there\"));\n+        t!(v: b!(\"hi/there\", 0x80, \".txt\"), filestem, b!(\"there\", 0x80));\n+        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), filestem, b!(\"there\"));\n+        t!(s: \"hi/there.txt\", filestem, \"there\");\n+        t!(s: \"hi/there\", filestem, \"there\");\n+        t!(s: \"there.txt\", filestem, \"there\");\n+        t!(s: \"there\", filestem, \"there\");\n+        t!(s: \".\", filestem, \"\");\n+        t!(s: \"/\", filestem, \"\");\n+        t!(s: \"foo/.bar\", filestem, \".bar\");\n+        t!(s: \".bar\", filestem, \".bar\");\n+        t!(s: \"..bar\", filestem, \".\");\n+        t!(s: \"hi/there..txt\", filestem, \"there.\");\n+        t!(s: \"..\", filestem, \"\");\n+        t!(s: \"../..\", filestem, \"\");\n+\n+        t!(v: b!(\"hi/there.txt\"), extension, Some(b!(\"txt\")));\n+        t!(v: b!(\"hi/there\", 0x80, \".txt\"), extension, Some(b!(\"txt\")));\n+        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), extension, Some(b!(\"t\", 0x80, \"xt\")));\n+        t!(v: b!(\"hi/there\"), extension, None);\n+        t!(v: b!(\"hi/there\", 0x80), extension, None);\n+        t!(s: \"hi/there.txt\", extension, Some(\"txt\"), opt);\n+        t!(s: \"hi/there\", extension, None, opt);\n+        t!(s: \"there.txt\", extension, Some(\"txt\"), opt);\n+        t!(s: \"there\", extension, None, opt);\n+        t!(s: \".\", extension, None, opt);\n+        t!(s: \"/\", extension, None, opt);\n+        t!(s: \"foo/.bar\", extension, None, opt);\n+        t!(s: \".bar\", extension, None, opt);\n+        t!(s: \"..bar\", extension, Some(\"bar\"), opt);\n+        t!(s: \"hi/there..txt\", extension, Some(\"txt\"), opt);\n+        t!(s: \"..\", extension, None, opt);\n+        t!(s: \"../..\", extension, None, opt);\n+    }\n+\n+    #[test]\n+    fn test_push() {\n+        macro_rules! t(\n+            (s: $path:expr, $join:expr) => (\n+                {\n+                    let path = ($path);\n+                    let join = ($join);\n+                    let mut p1 = Path::from_str(path);\n+                    let p2 = p1.clone();\n+                    p1.push_str(join);\n+                    assert_eq!(p1, p2.join_str(join));\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a/b/c\", \"..\");\n+        t!(s: \"/a/b/c\", \"d\");\n+        t!(s: \"a/b\", \"c/d\");\n+        t!(s: \"a/b\", \"/c/d\");\n+    }\n+\n+    #[test]\n+    fn test_push_path() {\n+        macro_rules! t(\n+            (s: $path:expr, $push:expr, $exp:expr) => (\n+                {\n+                    let mut p = Path::from_str($path);\n+                    let push = Path::from_str($push);\n+                    p.push_path(&push);\n+                    assert_eq!(p.as_str(), Some($exp));\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a/b/c\", \"d\", \"a/b/c/d\");\n+        t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n+        t!(s: \"a/b\", \"c/d\", \"a/b/c/d\");\n+        t!(s: \"a/b\", \"/c/d\", \"/c/d\");\n+        t!(s: \"a/b\", \".\", \"a/b\");\n+        t!(s: \"a/b\", \"../c\", \"a/c\");\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        macro_rules! t(\n+            (s: $path:expr, $left:expr, $right:expr) => (\n+                {\n+                    let mut p = Path::from_str($path);\n+                    let file = p.pop_opt_str();\n+                    assert_eq!(p.as_str(), Some($left));\n+                    assert_eq!(file.map(|s| s.as_slice()), $right);\n+                }\n+            );\n+            (v: [$($path:expr),+], [$($left:expr),+], Some($($right:expr),+)) => (\n+                {\n+                    let mut p = Path::new(b!($($path),+));\n+                    let file = p.pop_opt();\n+                    assert_eq!(p.as_vec(), b!($($left),+));\n+                    assert_eq!(file.map(|v| v.as_slice()), Some(b!($($right),+)));\n+                }\n+            );\n+            (v: [$($path:expr),+], [$($left:expr),+], None) => (\n+                {\n+                    let mut p = Path::new(b!($($path),+));\n+                    let file = p.pop_opt();\n+                    assert_eq!(p.as_vec(), b!($($left),+));\n+                    assert_eq!(file, None);\n+                }\n+            )\n+        )\n+\n+        t!(v: [\"a/b/c\"], [\"a/b\"], Some(\"c\"));\n+        t!(v: [\"a\"], [\".\"], Some(\"a\"));\n+        t!(v: [\".\"], [\".\"], None);\n+        t!(v: [\"/a\"], [\"/\"], Some(\"a\"));\n+        t!(v: [\"/\"], [\"/\"], None);\n+        t!(v: [\"a/b/c\", 0x80], [\"a/b\"], Some(\"c\", 0x80));\n+        t!(v: [\"a/b\", 0x80, \"/c\"], [\"a/b\", 0x80], Some(\"c\"));\n+        t!(v: [0xff], [\".\"], Some(0xff));\n+        t!(v: [\"/\", 0xff], [\"/\"], Some(0xff));\n+        t!(s: \"a/b/c\", \"a/b\", Some(\"c\"));\n+        t!(s: \"a\", \".\", Some(\"a\"));\n+        t!(s: \".\", \".\", None);\n+        t!(s: \"/a\", \"/\", Some(\"a\"));\n+        t!(s: \"/\", \"/\", None);\n+\n+        assert_eq!(Path::new(b!(\"foo/bar\", 0x80)).pop_opt_str(), None);\n+        assert_eq!(Path::new(b!(\"foo\", 0x80, \"/bar\")).pop_opt_str(), Some(~\"bar\"));\n+    }\n+\n+    #[test]\n+    fn test_join() {\n+        t!(v: Path::new(b!(\"a/b/c\")).join(b!(\"..\")), b!(\"a/b\"));\n+        t!(v: Path::new(b!(\"/a/b/c\")).join(b!(\"d\")), b!(\"/a/b/c/d\"));\n+        t!(v: Path::new(b!(\"a/\", 0x80, \"/c\")).join(b!(0xff)), b!(\"a/\", 0x80, \"/c/\", 0xff));\n+        t!(s: Path::from_str(\"a/b/c\").join_str(\"..\"), \"a/b\");\n+        t!(s: Path::from_str(\"/a/b/c\").join_str(\"d\"), \"/a/b/c/d\");\n+        t!(s: Path::from_str(\"a/b\").join_str(\"c/d\"), \"a/b/c/d\");\n+        t!(s: Path::from_str(\"a/b\").join_str(\"/c/d\"), \"/c/d\");\n+        t!(s: Path::from_str(\".\").join_str(\"a/b\"), \"a/b\");\n+        t!(s: Path::from_str(\"/\").join_str(\"a/b\"), \"/a/b\");\n+    }\n+\n+    #[test]\n+    fn test_join_path() {\n+        macro_rules! t(\n+            (s: $path:expr, $join:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let join = Path::from_str($join);\n+                    let res = path.join_path(&join);\n+                    assert_eq!(res.as_str(), Some($exp));\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a/b/c\", \"..\", \"a/b\");\n+        t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n+        t!(s: \"a/b\", \"c/d\", \"a/b/c/d\");\n+        t!(s: \"a/b\", \"/c/d\", \"/c/d\");\n+        t!(s: \".\", \"a/b\", \"a/b\");\n+        t!(s: \"/\", \"a/b\", \"/a/b\");\n+    }\n+\n+    #[test]\n+    fn test_with_helpers() {\n+        t!(v: Path::new(b!(\"a/b/c\")).with_dirname(b!(\"d\")), b!(\"d/c\"));\n+        t!(v: Path::new(b!(\"a/b/c\")).with_dirname(b!(\"d/e\")), b!(\"d/e/c\"));\n+        t!(v: Path::new(b!(\"a/\", 0x80, \"b/c\")).with_dirname(b!(0xff)), b!(0xff, \"/c\"));\n+        t!(v: Path::new(b!(\"a/b/\", 0x80)).with_dirname(b!(\"/\", 0xcd)),\n+              b!(\"/\", 0xcd, \"/\", 0x80));\n+        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"d\"), \"d/c\");\n+        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"d/e\"), \"d/e/c\");\n+        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"\"), \"c\");\n+        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"/\"), \"/c\");\n+        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\".\"), \"c\");\n+        t!(s: Path::from_str(\"a/b/c\").with_dirname_str(\"..\"), \"../c\");\n+        t!(s: Path::from_str(\"/\").with_dirname_str(\"foo\"), \"foo\");\n+        t!(s: Path::from_str(\"/\").with_dirname_str(\"\"), \".\");\n+        t!(s: Path::from_str(\"/foo\").with_dirname_str(\"bar\"), \"bar/foo\");\n+        t!(s: Path::from_str(\"..\").with_dirname_str(\"foo\"), \"foo\");\n+        t!(s: Path::from_str(\"../..\").with_dirname_str(\"foo\"), \"foo\");\n+        t!(s: Path::from_str(\"foo\").with_dirname_str(\"..\"), \"../foo\");\n+        t!(s: Path::from_str(\"foo\").with_dirname_str(\"../..\"), \"../../foo\");\n+\n+        t!(v: Path::new(b!(\"a/b/c\")).with_filename(b!(\"d\")), b!(\"a/b/d\"));\n+        t!(v: Path::new(b!(\"a/b/c\", 0xff)).with_filename(b!(0x80)), b!(\"a/b/\", 0x80));\n+        t!(v: Path::new(b!(\"/\", 0xff, \"/foo\")).with_filename(b!(0xcd)),\n+              b!(\"/\", 0xff, \"/\", 0xcd));\n+        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"d\"), \"a/b/d\");\n+        t!(s: Path::from_str(\".\").with_filename_str(\"foo\"), \"foo\");\n+        t!(s: Path::from_str(\"/a/b/c\").with_filename_str(\"d\"), \"/a/b/d\");\n+        t!(s: Path::from_str(\"/\").with_filename_str(\"foo\"), \"/foo\");\n+        t!(s: Path::from_str(\"/a\").with_filename_str(\"foo\"), \"/foo\");\n+        t!(s: Path::from_str(\"foo\").with_filename_str(\"bar\"), \"bar\");\n+        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"\"), \"a/b\");\n+        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\".\"), \"a/b\");\n+        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"..\"), \"a\");\n+        t!(s: Path::from_str(\"/a\").with_filename_str(\"\"), \"/\");\n+        t!(s: Path::from_str(\"foo\").with_filename_str(\"\"), \".\");\n+        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"d/e\"), \"a/b/d/e\");\n+        t!(s: Path::from_str(\"a/b/c\").with_filename_str(\"/d\"), \"a/b/d\");\n+        t!(s: Path::from_str(\"..\").with_filename_str(\"foo\"), \"../foo\");\n+        t!(s: Path::from_str(\"../..\").with_filename_str(\"foo\"), \"../../foo\");\n+\n+        t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_filestem(b!(0xff)),\n+              b!(\"hi/\", 0xff, \".txt\"));\n+        t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_filestem(b!(0xff)),\n+              b!(\"hi/\", 0xff, \".txt\", 0x80));\n+        t!(v: Path::new(b!(\"hi/there\", 0xff)).with_filestem(b!(0x80)), b!(\"hi/\", 0x80));\n+        t!(v: Path::new(b!(\"hi\", 0x80, \"/there\")).with_filestem([]), b!(\"hi\", 0x80));\n+        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"here\"), \"hi/here.txt\");\n+        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"\"), \"hi/.txt\");\n+        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\".\"), \"hi/..txt\");\n+        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"..\"), \"hi/...txt\");\n+        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"/\"), \"hi/.txt\");\n+        t!(s: Path::from_str(\"hi/there.txt\").with_filestem_str(\"foo/bar\"), \"hi/foo/bar.txt\");\n+        t!(s: Path::from_str(\"hi/there.foo.txt\").with_filestem_str(\"here\"), \"hi/here.txt\");\n+        t!(s: Path::from_str(\"hi/there\").with_filestem_str(\"here\"), \"hi/here\");\n+        t!(s: Path::from_str(\"hi/there\").with_filestem_str(\"\"), \"hi\");\n+        t!(s: Path::from_str(\"hi\").with_filestem_str(\"\"), \".\");\n+        t!(s: Path::from_str(\"/hi\").with_filestem_str(\"\"), \"/\");\n+        t!(s: Path::from_str(\"hi/there\").with_filestem_str(\"..\"), \".\");\n+        t!(s: Path::from_str(\"hi/there\").with_filestem_str(\".\"), \"hi\");\n+        t!(s: Path::from_str(\"hi/there.\").with_filestem_str(\"foo\"), \"hi/foo.\");\n+        t!(s: Path::from_str(\"hi/there.\").with_filestem_str(\"\"), \"hi\");\n+        t!(s: Path::from_str(\"hi/there.\").with_filestem_str(\".\"), \".\");\n+        t!(s: Path::from_str(\"hi/there.\").with_filestem_str(\"..\"), \"hi/...\");\n+        t!(s: Path::from_str(\"/\").with_filestem_str(\"foo\"), \"/foo\");\n+        t!(s: Path::from_str(\".\").with_filestem_str(\"foo\"), \"foo\");\n+        t!(s: Path::from_str(\"hi/there..\").with_filestem_str(\"here\"), \"hi/here.\");\n+        t!(s: Path::from_str(\"hi/there..\").with_filestem_str(\"\"), \"hi\");\n+\n+        t!(v: Path::new(b!(\"hi/there\", 0x80, \".txt\")).with_extension(b!(\"exe\")),\n+              b!(\"hi/there\", 0x80, \".exe\"));\n+        t!(v: Path::new(b!(\"hi/there.txt\", 0x80)).with_extension(b!(0xff)),\n+              b!(\"hi/there.\", 0xff));\n+        t!(v: Path::new(b!(\"hi/there\", 0x80)).with_extension(b!(0xff)),\n+              b!(\"hi/there\", 0x80, \".\", 0xff));\n+        t!(v: Path::new(b!(\"hi/there.\", 0xff)).with_extension([]), b!(\"hi/there\"));\n+        t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\"exe\"), \"hi/there.exe\");\n+        t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\"\"), \"hi/there\");\n+        t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\".\"), \"hi/there..\");\n+        t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\"..\"), \"hi/there...\");\n+        t!(s: Path::from_str(\"hi/there\").with_extension_str(\"txt\"), \"hi/there.txt\");\n+        t!(s: Path::from_str(\"hi/there\").with_extension_str(\".\"), \"hi/there..\");\n+        t!(s: Path::from_str(\"hi/there\").with_extension_str(\"..\"), \"hi/there...\");\n+        t!(s: Path::from_str(\"hi/there.\").with_extension_str(\"txt\"), \"hi/there.txt\");\n+        t!(s: Path::from_str(\"hi/.foo\").with_extension_str(\"txt\"), \"hi/.foo.txt\");\n+        t!(s: Path::from_str(\"hi/there.txt\").with_extension_str(\".foo\"), \"hi/there..foo\");\n+        t!(s: Path::from_str(\"/\").with_extension_str(\"txt\"), \"/\");\n+        t!(s: Path::from_str(\"/\").with_extension_str(\".\"), \"/\");\n+        t!(s: Path::from_str(\"/\").with_extension_str(\"..\"), \"/\");\n+        t!(s: Path::from_str(\".\").with_extension_str(\"txt\"), \".\");\n+    }\n+\n+    #[test]\n+    fn test_setters() {\n+        macro_rules! t(\n+            (s: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n+                {\n+                    let path = $path;\n+                    let arg = $arg;\n+                    let mut p1 = Path::from_str(path);\n+                    p1.$set(arg);\n+                    let p2 = Path::from_str(path);\n+                    assert_eq!(p1, p2.$with(arg));\n+                }\n+            );\n+            (v: $path:expr, $set:ident, $with:ident, $arg:expr) => (\n+                {\n+                    let path = $path;\n+                    let arg = $arg;\n+                    let mut p1 = Path::new(path);\n+                    p1.$set(arg);\n+                    let p2 = Path::new(path);\n+                    assert_eq!(p1, p2.$with(arg));\n+                }\n+            )\n+        )\n+\n+        t!(v: b!(\"a/b/c\"), set_dirname, with_dirname, b!(\"d\"));\n+        t!(v: b!(\"a/b/c\"), set_dirname, with_dirname, b!(\"d/e\"));\n+        t!(v: b!(\"a/\", 0x80, \"/c\"), set_dirname, with_dirname, b!(0xff));\n+        t!(s: \"a/b/c\", set_dirname_str, with_dirname_str, \"d\");\n+        t!(s: \"a/b/c\", set_dirname_str, with_dirname_str, \"d/e\");\n+        t!(s: \"/\", set_dirname_str, with_dirname_str, \"foo\");\n+        t!(s: \"/foo\", set_dirname_str, with_dirname_str, \"bar\");\n+        t!(s: \"a/b/c\", set_dirname_str, with_dirname_str, \"\");\n+        t!(s: \"../..\", set_dirname_str, with_dirname_str, \"x\");\n+        t!(s: \"foo\", set_dirname_str, with_dirname_str, \"../..\");\n+\n+        t!(v: b!(\"a/b/c\"), set_filename, with_filename, b!(\"d\"));\n+        t!(v: b!(\"/\"), set_filename, with_filename, b!(\"foo\"));\n+        t!(v: b!(0x80), set_filename, with_filename, b!(0xff));\n+        t!(s: \"a/b/c\", set_filename_str, with_filename_str, \"d\");\n+        t!(s: \"/\", set_filename_str, with_filename_str, \"foo\");\n+        t!(s: \".\", set_filename_str, with_filename_str, \"foo\");\n+        t!(s: \"a/b\", set_filename_str, with_filename_str, \"\");\n+        t!(s: \"a\", set_filename_str, with_filename_str, \"\");\n+\n+        t!(v: b!(\"hi/there.txt\"), set_filestem, with_filestem, b!(\"here\"));\n+        t!(v: b!(\"hi/there\", 0x80, \".txt\"), set_filestem, with_filestem, b!(\"here\", 0xff));\n+        t!(s: \"hi/there.txt\", set_filestem_str, with_filestem_str, \"here\");\n+        t!(s: \"hi/there.\", set_filestem_str, with_filestem_str, \"here\");\n+        t!(s: \"hi/there\", set_filestem_str, with_filestem_str, \"here\");\n+        t!(s: \"hi/there.txt\", set_filestem_str, with_filestem_str, \"\");\n+        t!(s: \"hi/there\", set_filestem_str, with_filestem_str, \"\");\n+\n+        t!(v: b!(\"hi/there.txt\"), set_extension, with_extension, b!(\"exe\"));\n+        t!(v: b!(\"hi/there.t\", 0x80, \"xt\"), set_extension, with_extension, b!(\"exe\", 0xff));\n+        t!(s: \"hi/there.txt\", set_extension_str, with_extension_str, \"exe\");\n+        t!(s: \"hi/there.\", set_extension_str, with_extension_str, \"txt\");\n+        t!(s: \"hi/there\", set_extension_str, with_extension_str, \"txt\");\n+        t!(s: \"hi/there.txt\", set_extension_str, with_extension_str, \"\");\n+        t!(s: \"hi/there\", set_extension_str, with_extension_str, \"\");\n+        t!(s: \".\", set_extension_str, with_extension_str, \"txt\");\n+    }\n+\n+    #[test]\n+    fn test_getters() {\n+        macro_rules! t(\n+            (s: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n+                {\n+                    let path = $path;\n+                    assert_eq!(path.filename_str(), $filename);\n+                    assert_eq!(path.dirname_str(), $dirname);\n+                    assert_eq!(path.filestem_str(), $filestem);\n+                    assert_eq!(path.extension_str(), $ext);\n+                }\n+            );\n+            (v: $path:expr, $filename:expr, $dirname:expr, $filestem:expr, $ext:expr) => (\n+                {\n+                    let path = $path;\n+                    assert_eq!(path.filename(), $filename);\n+                    assert_eq!(path.dirname(), $dirname);\n+                    assert_eq!(path.filestem(), $filestem);\n+                    assert_eq!(path.extension(), $ext);\n+                }\n+            )\n+        )\n+\n+        t!(v: Path::new(b!(\"a/b/c\")), b!(\"c\"), b!(\"a/b\"), b!(\"c\"), None);\n+        t!(v: Path::new(b!(\"a/b/\", 0xff)), b!(0xff), b!(\"a/b\"), b!(0xff), None);\n+        t!(v: Path::new(b!(\"hi/there.\", 0xff)), b!(\"there.\", 0xff), b!(\"hi\"),\n+              b!(\"there\"), Some(b!(0xff)));\n+        t!(s: Path::from_str(\"a/b/c\"), Some(\"c\"), Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::from_str(\".\"), Some(\"\"), Some(\".\"), Some(\"\"), None);\n+        t!(s: Path::from_str(\"/\"), Some(\"\"), Some(\"/\"), Some(\"\"), None);\n+        t!(s: Path::from_str(\"..\"), Some(\"\"), Some(\"..\"), Some(\"\"), None);\n+        t!(s: Path::from_str(\"../..\"), Some(\"\"), Some(\"../..\"), Some(\"\"), None);\n+        t!(s: Path::from_str(\"hi/there.txt\"), Some(\"there.txt\"), Some(\"hi\"),\n+              Some(\"there\"), Some(\"txt\"));\n+        t!(s: Path::from_str(\"hi/there\"), Some(\"there\"), Some(\"hi\"), Some(\"there\"), None);\n+        t!(s: Path::from_str(\"hi/there.\"), Some(\"there.\"), Some(\"hi\"),\n+              Some(\"there\"), Some(\"\"));\n+        t!(s: Path::from_str(\"hi/.there\"), Some(\".there\"), Some(\"hi\"), Some(\".there\"), None);\n+        t!(s: Path::from_str(\"hi/..there\"), Some(\"..there\"), Some(\"hi\"),\n+              Some(\".\"), Some(\"there\"));\n+        t!(s: Path::new(b!(\"a/b/\", 0xff)), None, Some(\"a/b\"), None, None);\n+        t!(s: Path::new(b!(\"a/b/\", 0xff, \".txt\")), None, Some(\"a/b\"), None, Some(\"txt\"));\n+        t!(s: Path::new(b!(\"a/b/c.\", 0x80)), None, Some(\"a/b\"), Some(\"c\"), None);\n+        t!(s: Path::new(b!(0xff, \"/b\")), Some(\"b\"), None, Some(\"b\"), None);\n+    }\n+\n+    #[test]\n+    fn test_dir_file_path() {\n+        t!(v: Path::new(b!(\"hi/there\", 0x80)).dir_path(), b!(\"hi\"));\n+        t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).dir_path(), b!(\"hi\", 0xff));\n+        t!(s: Path::from_str(\"hi/there\").dir_path(), \"hi\");\n+        t!(s: Path::from_str(\"hi\").dir_path(), \".\");\n+        t!(s: Path::from_str(\"/hi\").dir_path(), \"/\");\n+        t!(s: Path::from_str(\"/\").dir_path(), \"/\");\n+        t!(s: Path::from_str(\"..\").dir_path(), \"..\");\n+        t!(s: Path::from_str(\"../..\").dir_path(), \"../..\");\n+\n+        macro_rules! t(\n+            (s: $path:expr, $exp:expr) => (\n+                {\n+                    let path = $path;\n+                    let left = path.chain_ref(|p| p.as_str());\n+                    assert_eq!(left, $exp);\n+                }\n+            );\n+            (v: $path:expr, $exp:expr) => (\n+                {\n+                    let path = $path;\n+                    let left = path.map(|p| p.as_vec());\n+                    assert_eq!(left, $exp);\n+                }\n+            )\n+        )\n+\n+        t!(v: Path::new(b!(\"hi/there\", 0x80)).file_path(), Some(b!(\"there\", 0x80)));\n+        t!(v: Path::new(b!(\"hi\", 0xff, \"/there\")).file_path(), Some(b!(\"there\")));\n+        t!(s: Path::from_str(\"hi/there\").file_path(), Some(\"there\"));\n+        t!(s: Path::from_str(\"hi\").file_path(), Some(\"hi\"));\n+        t!(s: Path::from_str(\".\").file_path(), None);\n+        t!(s: Path::from_str(\"/\").file_path(), None);\n+        t!(s: Path::from_str(\"..\").file_path(), None);\n+        t!(s: Path::from_str(\"../..\").file_path(), None);\n+    }\n+\n+    #[test]\n+    fn test_is_absolute() {\n+        assert_eq!(Path::from_str(\"a/b/c\").is_absolute(), false);\n+        assert_eq!(Path::from_str(\"/a/b/c\").is_absolute(), true);\n+        assert_eq!(Path::from_str(\"a\").is_absolute(), false);\n+        assert_eq!(Path::from_str(\"/a\").is_absolute(), true);\n+        assert_eq!(Path::from_str(\".\").is_absolute(), false);\n+        assert_eq!(Path::from_str(\"/\").is_absolute(), true);\n+        assert_eq!(Path::from_str(\"..\").is_absolute(), false);\n+        assert_eq!(Path::from_str(\"../..\").is_absolute(), false);\n+    }\n+\n+    #[test]\n+    fn test_is_ancestor_of() {\n+        macro_rules! t(\n+            (s: $path:expr, $dest:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let dest = Path::from_str($dest);\n+                    assert_eq!(path.is_ancestor_of(&dest), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a/b/c\", \"a/b/c/d\", true);\n+        t!(s: \"a/b/c\", \"a/b/c\", true);\n+        t!(s: \"a/b/c\", \"a/b\", false);\n+        t!(s: \"/a/b/c\", \"/a/b/c\", true);\n+        t!(s: \"/a/b\", \"/a/b/c\", true);\n+        t!(s: \"/a/b/c/d\", \"/a/b/c\", false);\n+        t!(s: \"/a/b\", \"a/b/c\", false);\n+        t!(s: \"a/b\", \"/a/b/c\", false);\n+        t!(s: \"a/b/c\", \"a/b/d\", false);\n+        t!(s: \"../a/b/c\", \"a/b/c\", false);\n+        t!(s: \"a/b/c\", \"../a/b/c\", false);\n+        t!(s: \"a/b/c\", \"a/b/cd\", false);\n+        t!(s: \"a/b/cd\", \"a/b/c\", false);\n+        t!(s: \"../a/b\", \"../a/b/c\", true);\n+        t!(s: \".\", \"a/b\", true);\n+        t!(s: \".\", \".\", true);\n+        t!(s: \"/\", \"/\", true);\n+        t!(s: \"/\", \"/a/b\", true);\n+        t!(s: \"..\", \"a/b\", true);\n+        t!(s: \"../..\", \"a/b\", true);\n+    }\n+\n+    #[test]\n+    fn test_path_relative_from() {\n+        macro_rules! t(\n+            (s: $path:expr, $other:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let other = Path::from_str($other);\n+                    let res = path.path_relative_from(&other);\n+                    assert_eq!(res.chain_ref(|x| x.as_str()), $exp);\n+                }\n+            )\n+        )\n+\n+        t!(s: \"a/b/c\", \"a/b\", Some(\"c\"));\n+        t!(s: \"a/b/c\", \"a/b/d\", Some(\"../c\"));\n+        t!(s: \"a/b/c\", \"a/b/c/d\", Some(\"..\"));\n+        t!(s: \"a/b/c\", \"a/b/c\", Some(\".\"));\n+        t!(s: \"a/b/c\", \"a/b/c/d/e\", Some(\"../..\"));\n+        t!(s: \"a/b/c\", \"a/d/e\", Some(\"../../b/c\"));\n+        t!(s: \"a/b/c\", \"d/e/f\", Some(\"../../../a/b/c\"));\n+        t!(s: \"a/b/c\", \"/a/b/c\", None);\n+        t!(s: \"/a/b/c\", \"a/b/c\", Some(\"/a/b/c\"));\n+        t!(s: \"/a/b/c\", \"/a/b/c/d\", Some(\"..\"));\n+        t!(s: \"/a/b/c\", \"/a/b\", Some(\"c\"));\n+        t!(s: \"/a/b/c\", \"/a/b/c/d/e\", Some(\"../..\"));\n+        t!(s: \"/a/b/c\", \"/a/d/e\", Some(\"../../b/c\"));\n+        t!(s: \"/a/b/c\", \"/d/e/f\", Some(\"../../../a/b/c\"));\n+        t!(s: \"hi/there.txt\", \"hi/there\", Some(\"../there.txt\"));\n+        t!(s: \".\", \"a\", Some(\"..\"));\n+        t!(s: \".\", \"a/b\", Some(\"../..\"));\n+        t!(s: \".\", \".\", Some(\".\"));\n+        t!(s: \"a\", \".\", Some(\"a\"));\n+        t!(s: \"a/b\", \".\", Some(\"a/b\"));\n+        t!(s: \"..\", \".\", Some(\"..\"));\n+        t!(s: \"a/b/c\", \"a/b/c\", Some(\".\"));\n+        t!(s: \"/a/b/c\", \"/a/b/c\", Some(\".\"));\n+        t!(s: \"/\", \"/\", Some(\".\"));\n+        t!(s: \"/\", \".\", Some(\"/\"));\n+        t!(s: \"../../a\", \"b\", Some(\"../../../a\"));\n+        t!(s: \"a\", \"../../b\", None);\n+        t!(s: \"../../a\", \"../../b\", Some(\"../a\"));\n+        t!(s: \"../../a\", \"../../a/b\", Some(\"..\"));\n+        t!(s: \"../../a/b\", \"../../a\", Some(\"b\"));\n+    }\n+\n+    #[test]\n+    fn test_component_iter() {\n+        macro_rules! t(\n+            (s: $path:expr, $exp:expr) => (\n+                {\n+                    let path = Path::from_str($path);\n+                    let comps = path.component_iter().to_owned_vec();\n+                    let exp: &[&str] = $exp;\n+                    let exps = exp.iter().map(|x| x.as_bytes()).to_owned_vec();\n+                    assert_eq!(comps, exps);\n+                }\n+            );\n+            (v: [$($arg:expr),+], [$([$($exp:expr),*]),*]) => (\n+                {\n+                    let path = Path::new(b!($($arg),+));\n+                    let comps = path.component_iter().to_owned_vec();\n+                    let exp: &[&[u8]] = [$(b!($($exp),*)),*];\n+                    assert_eq!(comps.as_slice(), exp);\n+                }\n+            )\n+        )\n+\n+        t!(v: [\"a/b/c\"], [[\"a\"], [\"b\"], [\"c\"]]);\n+        t!(v: [\"/\", 0xff, \"/a/\", 0x80], [[0xff], [\"a\"], [0x80]]);\n+        t!(v: [\"../../foo\", 0xcd, \"bar\"], [[\"..\"], [\"..\"], [\"foo\", 0xcd, \"bar\"]]);\n+        t!(s: \"a/b/c\", [\"a\", \"b\", \"c\"]);\n+        t!(s: \"a/b/d\", [\"a\", \"b\", \"d\"]);\n+        t!(s: \"a/b/cd\", [\"a\", \"b\", \"cd\"]);\n+        t!(s: \"/a/b/c\", [\"a\", \"b\", \"c\"]);\n+        t!(s: \"a\", [\"a\"]);\n+        t!(s: \"/a\", [\"a\"]);\n+        t!(s: \"/\", []);\n+        t!(s: \".\", [\".\"]);\n+        t!(s: \"..\", [\"..\"]);\n+        t!(s: \"../..\", [\"..\", \"..\"]);\n+        t!(s: \"../../foo\", [\"..\", \"..\", \"foo\"]);\n+    }\n+}"}, {"sha": "1c3eb5c291dc60405562fdfd3f19bea2770473b1", "filename": "src/libstd/path2/windows.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6d29142219d92f886124057e9ecfdb51ffca19f2/src%2Flibstd%2Fpath2%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d29142219d92f886124057e9ecfdb51ffca19f2/src%2Flibstd%2Fpath2%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath2%2Fwindows.rs?ref=6d29142219d92f886124057e9ecfdb51ffca19f2", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows file path handling\n+\n+/// The standard path separator character\n+pub static sep: u8 = '\\\\' as u8;\n+/// The alternative path separator character\n+pub static sep2: u8 = '/' as u8;\n+\n+/// Returns whether the given byte is a path separator\n+#[inline]\n+pub fn is_sep(u: &u8) -> bool {\n+    *u == sep || *u == sep2\n+}"}]}