{"sha": "3f796fea9fab0222913f9f895af78b80c4c7660b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNzk2ZmVhOWZhYjAyMjI5MTNmOWY4OTVhZjc4YjgwYzRjNzY2MGI=", "commit": {"author": {"name": "Lukas Tobias Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-05T20:55:12Z"}, "committer": {"name": "Lukas Tobias Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-05T20:55:12Z"}, "message": "simplify", "tree": {"sha": "b8ced23c567c160f9207d52c30e0f08e1aead992", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8ced23c567c160f9207d52c30e0f08e1aead992"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f796fea9fab0222913f9f895af78b80c4c7660b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f796fea9fab0222913f9f895af78b80c4c7660b", "html_url": "https://github.com/rust-lang/rust/commit/3f796fea9fab0222913f9f895af78b80c4c7660b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f796fea9fab0222913f9f895af78b80c4c7660b/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d26fb188c14e38f5795d1be359defd257c464f37", "url": "https://api.github.com/repos/rust-lang/rust/commits/d26fb188c14e38f5795d1be359defd257c464f37", "html_url": "https://github.com/rust-lang/rust/commit/d26fb188c14e38f5795d1be359defd257c464f37"}], "stats": {"total": 81, "additions": 40, "deletions": 41}, "files": [{"sha": "6fcc58f612eeb40b7037cc046ba414d77827c7dd", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=3f796fea9fab0222913f9f895af78b80c4c7660b", "patch": "@@ -1744,6 +1744,10 @@ impl Type {\n         }\n     }\n \n+    pub fn strip_references(&self) -> Type {\n+        self.derived(self.ty.strip_references().clone())\n+    }\n+\n     pub fn is_unknown(&self) -> bool {\n         self.ty.is_unknown()\n     }"}, {"sha": "e0bf660c408032c5eb3b70f666d7723fafb49126", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=3f796fea9fab0222913f9f895af78b80c4c7660b", "patch": "@@ -218,9 +218,7 @@ fn hint_iterator(\n     ty: &hir::Type,\n ) -> Option<SmolStr> {\n     let db = sema.db;\n-    let strukt = std::iter::successors(Some(ty.clone()), |ty| ty.remove_ref())\n-        .last()\n-        .and_then(|strukt| strukt.as_adt())?;\n+    let strukt = ty.strip_references().as_adt()?;\n     let krate = strukt.krate(db);\n     if krate != famous_defs.core()? {\n         return None;"}, {"sha": "78154bf3ec605243f248226b12cd1ec287fcc430", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=3f796fea9fab0222913f9f895af78b80c4c7660b", "patch": "@@ -203,41 +203,37 @@ impl Completions {\n fn complete_enum_variants(\n     acc: &mut Completions,\n     ctx: &CompletionContext,\n-    ty: &hir::Type,\n+    enum_data: hir::Enum,\n     cb: impl Fn(&mut Completions, &CompletionContext, hir::Variant, hir::ModPath),\n ) {\n-    if let Some(hir::Adt::Enum(enum_data)) =\n-        iter::successors(Some(ty.clone()), |ty| ty.remove_ref()).last().and_then(|ty| ty.as_adt())\n-    {\n-        let variants = enum_data.variants(ctx.db);\n-\n-        let module = if let Some(module) = ctx.scope.module() {\n-            // Compute path from the completion site if available.\n-            module\n-        } else {\n-            // Otherwise fall back to the enum's definition site.\n-            enum_data.module(ctx.db)\n-        };\n-\n-        if let Some(impl_) = ctx.impl_def.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n-            if impl_.self_ty(ctx.db) == *ty {\n-                for &variant in &variants {\n-                    let self_path = hir::ModPath::from_segments(\n-                        hir::PathKind::Plain,\n-                        iter::once(known::SELF_TYPE).chain(iter::once(variant.name(ctx.db))),\n-                    );\n-                    cb(acc, ctx, variant, self_path);\n-                }\n+    let variants = enum_data.variants(ctx.db);\n+\n+    let module = if let Some(module) = ctx.scope.module() {\n+        // Compute path from the completion site if available.\n+        module\n+    } else {\n+        // Otherwise fall back to the enum's definition site.\n+        enum_data.module(ctx.db)\n+    };\n+\n+    if let Some(impl_) = ctx.impl_def.as_ref().and_then(|impl_| ctx.sema.to_def(impl_)) {\n+        if impl_.self_ty(ctx.db).as_adt() == Some(hir::Adt::Enum(enum_data)) {\n+            for &variant in &variants {\n+                let self_path = hir::ModPath::from_segments(\n+                    hir::PathKind::Plain,\n+                    iter::once(known::SELF_TYPE).chain(iter::once(variant.name(ctx.db))),\n+                );\n+                cb(acc, ctx, variant, self_path);\n             }\n         }\n+    }\n \n-        for variant in variants {\n-            if let Some(path) = module.find_use_path(ctx.db, hir::ModuleDef::from(variant)) {\n-                // Variants with trivial paths are already added by the existing completion logic,\n-                // so we should avoid adding these twice\n-                if path.segments().len() > 1 {\n-                    cb(acc, ctx, variant, path);\n-                }\n+    for variant in variants {\n+        if let Some(path) = module.find_use_path(ctx.db, hir::ModuleDef::from(variant)) {\n+            // Variants with trivial paths are already added by the existing completion logic,\n+            // so we should avoid adding these twice\n+            if path.segments().len() > 1 {\n+                cb(acc, ctx, variant, path);\n             }\n         }\n     }"}, {"sha": "8dc9ab73cbc679769358c2fbb69e6c8dc0319a49", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=3f796fea9fab0222913f9f895af78b80c4c7660b", "patch": "@@ -12,8 +12,10 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n     }\n \n     if !ctx.is_irrefutable_pat_binding {\n-        if let Some(ty) = ctx.expected_type.as_ref() {\n-            super::complete_enum_variants(acc, ctx, ty, |acc, ctx, variant, path| {\n+        if let Some(hir::Adt::Enum(e)) =\n+            ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n+        {\n+            super::complete_enum_variants(acc, ctx, e, |acc, ctx, variant, path| {\n                 acc.add_qualified_variant_pat(ctx, variant, path.clone());\n                 acc.add_qualified_enum_variant(ctx, variant, path);\n             });"}, {"sha": "962aaf0df367856263d9185cc37fe676875ebf71", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=3f796fea9fab0222913f9f895af78b80c4c7660b", "patch": "@@ -35,14 +35,11 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         None => return,\n     };\n \n-    let ref_removed_ty =\n-        std::iter::successors(Some(receiver_ty.clone()), |ty| ty.remove_ref()).last().unwrap();\n-\n     let cap = match ctx.config.snippet_cap {\n         Some(it) => it,\n         None => return,\n     };\n-    let try_enum = TryEnum::from_ty(&ctx.sema, &ref_removed_ty);\n+    let try_enum = TryEnum::from_ty(&ctx.sema, &receiver_ty.strip_references());\n     if let Some(try_enum) = &try_enum {\n         match try_enum {\n             TryEnum::Result => {"}, {"sha": "7875500c1228c155aa551ac3b0712f8fff4e2383", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f796fea9fab0222913f9f895af78b80c4c7660b/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=3f796fea9fab0222913f9f895af78b80c4c7660b", "patch": "@@ -17,8 +17,10 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         return;\n     }\n \n-    if let Some(ty) = &ctx.expected_type {\n-        super::complete_enum_variants(acc, ctx, ty, |acc, ctx, variant, path| {\n+    if let Some(hir::Adt::Enum(e)) =\n+        ctx.expected_type.as_ref().and_then(|ty| ty.strip_references().as_adt())\n+    {\n+        super::complete_enum_variants(acc, ctx, e, |acc, ctx, variant, path| {\n             acc.add_qualified_enum_variant(ctx, variant, path)\n         });\n     }"}]}