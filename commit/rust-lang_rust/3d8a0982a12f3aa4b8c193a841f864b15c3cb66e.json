{"sha": "3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkOGEwOTgyYTEyZjNhYTRiOGMxOTNhODQxZjg2NGIxNWMzY2I2NmU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-22T19:58:22Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-22T19:58:22Z"}, "message": "Merge #866\n\n866: Implement basic support for Associated Methods r=flodiebold a=vipentti\n\nThis is my attempt at learning to understand how the type inference works by adding basic support for associated methods. Currently it does not resolve associated types or constants. \r\n\r\nThe basic idea is that `Resolver::resolve_path` returns a new `PathResult` type, which has two variants, `FullyResolved` and `PartiallyResolved`, fully resolved matches the previous behavior, where as `PartiallyResolved` contains the `PerNs<Resolution` in addition to a `segment_index` which contains the index of the segment which we failed to resolve. This index can then be used to continue inference in `infer_path_expr` using the `Type` we managed to resolve.\r\n\r\nThis changes some of the previous apis, so looking for feedback and suggestions.\r\n\r\nThis should enable fixing #832\n\nCo-authored-by: Ville Penttinen <villem.penttinen@gmail.com>", "tree": {"sha": "e20ae00628cc28417e22621f583ba6988677ffcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e20ae00628cc28417e22621f583ba6988677ffcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "html_url": "https://github.com/rust-lang/rust/commit/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "bb665a70627cbc2f4fb930fefb04899941b6afa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb665a70627cbc2f4fb930fefb04899941b6afa6", "html_url": "https://github.com/rust-lang/rust/commit/bb665a70627cbc2f4fb930fefb04899941b6afa6"}, {"sha": "247d1c17b385ff8a8c1dda2e899495146b643b98", "url": "https://api.github.com/repos/rust-lang/rust/commits/247d1c17b385ff8a8c1dda2e899495146b643b98", "html_url": "https://github.com/rust-lang/rust/commit/247d1c17b385ff8a8c1dda2e899495146b643b98"}], "stats": {"total": 461, "additions": 430, "deletions": 31}, "files": [{"sha": "8067b8415f5e63ed32b12a8ac315868cf3094ae9", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "patch": "@@ -297,7 +297,14 @@ where\n             );\n             (res, if res.is_none() { ReachedFixedPoint::No } else { ReachedFixedPoint::Yes })\n         } else {\n-            self.result.resolve_path_fp(self.db, ResolveMode::Import, original_module, &import.path)\n+            let res = self.result.resolve_path_fp(\n+                self.db,\n+                ResolveMode::Import,\n+                original_module,\n+                &import.path,\n+            );\n+\n+            (res.resolved_def, res.reached_fixedpoint)\n         };\n \n         if reached_fixedpoint != ReachedFixedPoint::Yes {\n@@ -435,6 +442,27 @@ where\n     }\n }\n \n+#[derive(Debug, Clone)]\n+struct ResolvePathResult {\n+    resolved_def: PerNs<ModuleDef>,\n+    segment_index: Option<usize>,\n+    reached_fixedpoint: ReachedFixedPoint,\n+}\n+\n+impl ResolvePathResult {\n+    fn empty(reached_fixedpoint: ReachedFixedPoint) -> ResolvePathResult {\n+        ResolvePathResult::with(PerNs::none(), reached_fixedpoint, None)\n+    }\n+\n+    fn with(\n+        resolved_def: PerNs<ModuleDef>,\n+        reached_fixedpoint: ReachedFixedPoint,\n+        segment_index: Option<usize>,\n+    ) -> ResolvePathResult {\n+        ResolvePathResult { resolved_def, reached_fixedpoint, segment_index }\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum ResolveMode {\n     Import,\n@@ -468,8 +496,9 @@ impl ItemMap {\n         db: &impl PersistentHirDatabase,\n         original_module: Module,\n         path: &Path,\n-    ) -> PerNs<ModuleDef> {\n-        self.resolve_path_fp(db, ResolveMode::Other, original_module, path).0\n+    ) -> (PerNs<ModuleDef>, Option<usize>) {\n+        let res = self.resolve_path_fp(db, ResolveMode::Other, original_module, path);\n+        (res.resolved_def, res.segment_index)\n     }\n \n     fn resolve_in_prelude(\n@@ -534,7 +563,7 @@ impl ItemMap {\n         mode: ResolveMode,\n         original_module: Module,\n         path: &Path,\n-    ) -> (PerNs<ModuleDef>, ReachedFixedPoint) {\n+    ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n             PathKind::Crate => PerNs::types(original_module.crate_root(db).into()),\n@@ -549,7 +578,7 @@ impl ItemMap {\n             {\n                 let segment = match segments.next() {\n                     Some((_, segment)) => segment,\n-                    None => return (PerNs::none(), ReachedFixedPoint::Yes),\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n                 self.resolve_name_in_crate_root_or_extern_prelude(\n@@ -561,7 +590,7 @@ impl ItemMap {\n             PathKind::Plain => {\n                 let segment = match segments.next() {\n                     Some((_, segment)) => segment,\n-                    None => return (PerNs::none(), ReachedFixedPoint::Yes),\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 log::debug!(\"resolving {:?} in module\", segment);\n                 self.resolve_name_in_module(db, original_module, &segment.name)\n@@ -571,20 +600,20 @@ impl ItemMap {\n                     PerNs::types(p.into())\n                 } else {\n                     log::debug!(\"super path in root module\");\n-                    return (PerNs::none(), ReachedFixedPoint::Yes);\n+                    return ResolvePathResult::empty(ReachedFixedPoint::Yes);\n                 }\n             }\n             PathKind::Abs => {\n                 // 2018-style absolute path -- only extern prelude\n                 let segment = match segments.next() {\n                     Some((_, segment)) => segment,\n-                    None => return (PerNs::none(), ReachedFixedPoint::Yes),\n+                    None => return ResolvePathResult::empty(ReachedFixedPoint::Yes),\n                 };\n                 if let Some(def) = self.extern_prelude.get(&segment.name) {\n                     log::debug!(\"absolute path {:?} resolved to crate {:?}\", path, def);\n                     PerNs::types(*def)\n                 } else {\n-                    return (PerNs::none(), ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No); // extern crate declarations can add to the extern prelude\n                 }\n             }\n         };\n@@ -598,7 +627,7 @@ impl ItemMap {\n                     // (don't break here because `curr_per_ns` might contain\n                     // something in the value namespace, and it would be wrong\n                     // to return that)\n-                    return (PerNs::none(), ReachedFixedPoint::No);\n+                    return ResolvePathResult::empty(ReachedFixedPoint::No);\n                 }\n             };\n             // resolve segment in curr\n@@ -612,15 +641,15 @@ impl ItemMap {\n                         };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n                         let item_map = db.item_map(module.krate);\n-                        let def = item_map.resolve_path(db, *module, &path);\n-                        return (def, ReachedFixedPoint::Yes);\n+                        let (def, s) = item_map.resolve_path(db, *module, &path);\n+                        return ResolvePathResult::with(def, ReachedFixedPoint::Yes, s);\n                     }\n \n                     match self[module.module_id].items.get(&segment.name) {\n                         Some(res) if !res.def.is_none() => res.def,\n                         _ => {\n                             log::debug!(\"path segment {:?} not found\", segment.name);\n-                            return (PerNs::none(), ReachedFixedPoint::No);\n+                            return ResolvePathResult::empty(ReachedFixedPoint::No);\n                         }\n                     }\n                 }\n@@ -629,23 +658,33 @@ impl ItemMap {\n                     tested_by!(item_map_enum_importing);\n                     match e.variant(db, &segment.name) {\n                         Some(variant) => PerNs::both(variant.into(), variant.into()),\n-                        None => PerNs::none(),\n+                        None => {\n+                            return ResolvePathResult::with(\n+                                PerNs::types((*e).into()),\n+                                ReachedFixedPoint::Yes,\n+                                Some(i),\n+                            );\n+                        }\n                     }\n                 }\n-                _ => {\n+                s => {\n                     // could be an inherent method call in UFCS form\n-                    // (`Struct::method`), or some other kind of associated\n-                    // item... Which we currently don't handle (TODO)\n+                    // (`Struct::method`), or some other kind of associated item\n                     log::debug!(\n                         \"path segment {:?} resolved to non-module {:?}, but is not last\",\n                         segment.name,\n                         curr,\n                     );\n-                    return (PerNs::none(), ReachedFixedPoint::Yes);\n+\n+                    return ResolvePathResult::with(\n+                        PerNs::types((*s).into()),\n+                        ReachedFixedPoint::Yes,\n+                        Some(i),\n+                    );\n                 }\n             };\n         }\n-        (curr_per_ns, ReachedFixedPoint::Yes)\n+        ResolvePathResult::with(curr_per_ns, ReachedFixedPoint::Yes, None)\n     }\n }\n "}, {"sha": "57e7d0b9ad0e371d872f9c592b6d7d4e71efb501", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 83, "deletions": 6, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "patch": "@@ -32,6 +32,67 @@ pub(crate) struct ExprScope {\n     scope_id: ScopeId,\n }\n \n+#[derive(Debug, Clone)]\n+pub(crate) struct PathResult {\n+    /// The actual path resolution\n+    resolution: PerNs<Resolution>,\n+    /// The first index in the path that we\n+    /// were unable to resolve.\n+    /// When path is fully resolved, this is 0.\n+    remaining_index: usize,\n+}\n+\n+impl PathResult {\n+    /// Returns the remaining index in the result\n+    /// returns None if the path was fully resolved\n+    pub(crate) fn remaining_index(&self) -> Option<usize> {\n+        if self.remaining_index > 0 {\n+            Some(self.remaining_index)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Consumes `PathResult` and returns the contained `PerNs<Resolution>`\n+    /// if the path was fully resolved, meaning we have no remaining items\n+    pub(crate) fn into_fully_resolved(self) -> PerNs<Resolution> {\n+        if self.is_fully_resolved() {\n+            self.resolution\n+        } else {\n+            PerNs::none()\n+        }\n+    }\n+\n+    /// Consumes `PathResult` and returns the resolution and the\n+    /// remaining_index as a tuple.\n+    pub(crate) fn into_inner(self) -> (PerNs<Resolution>, Option<usize>) {\n+        let index = self.remaining_index();\n+        (self.resolution, index)\n+    }\n+\n+    /// Path is fully resolved when `remaining_index` is none\n+    /// and the resolution contains anything\n+    pub(crate) fn is_fully_resolved(&self) -> bool {\n+        !self.resolution.is_none() && self.remaining_index().is_none()\n+    }\n+\n+    fn empty() -> PathResult {\n+        PathResult { resolution: PerNs::none(), remaining_index: 0 }\n+    }\n+\n+    fn from_resolution(res: PerNs<Resolution>) -> PathResult {\n+        PathResult::from_resolution_with_index(res, 0)\n+    }\n+\n+    fn from_resolution_with_index(res: PerNs<Resolution>, remaining_index: usize) -> PathResult {\n+        if res.is_none() {\n+            PathResult::empty()\n+        } else {\n+            PathResult { resolution: res, remaining_index }\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n pub(crate) enum Scope {\n     /// All the items and imported names of a module\n@@ -67,21 +128,37 @@ impl Resolver {\n         resolution\n     }\n \n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<Resolution> {\n+    /// Returns the resolved path segments\n+    /// Which may be fully resolved, empty or partially resolved.\n+    pub(crate) fn resolve_path_segments(&self, db: &impl HirDatabase, path: &Path) -> PathResult {\n         if let Some(name) = path.as_ident() {\n-            self.resolve_name(db, name)\n+            PathResult::from_resolution(self.resolve_name(db, name))\n         } else if path.is_self() {\n-            self.resolve_name(db, &Name::self_param())\n+            PathResult::from_resolution(self.resolve_name(db, &Name::self_param()))\n         } else {\n             let (item_map, module) = match self.module() {\n                 Some(m) => m,\n-                _ => return PerNs::none(),\n+                _ => return PathResult::empty(),\n             };\n-            let module_res = item_map.resolve_path(db, module, path);\n-            module_res.map(Resolution::Def)\n+            let (module_res, segment_index) = item_map.resolve_path(db, module, path);\n+\n+            let def = module_res.map(Resolution::Def);\n+\n+            if let Some(index) = segment_index {\n+                PathResult::from_resolution_with_index(def, index)\n+            } else {\n+                PathResult::from_resolution(def)\n+            }\n         }\n     }\n \n+    /// Returns the fully resolved path if we were able to resolve it.\n+    /// otherwise returns `PerNs::none`\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<Resolution> {\n+        // into_fully_resolved() returns the fully resolved path or PerNs::none() otherwise\n+        self.resolve_path_segments(db, path).into_fully_resolved()\n+    }\n+\n     pub fn all_names(&self, db: &impl HirDatabase) -> FxHashMap<Name, PerNs<Resolution>> {\n         let mut names = FxHashMap::default();\n         for scope in self.scopes.iter().rev() {"}, {"sha": "ae595c16d98840bfd4bc4e7dfa121e21434b1ea0", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "patch": "@@ -37,7 +37,7 @@ use crate::{\n     FnSignature, ModuleDef, AdtDef,\n     HirDatabase,\n     type_ref::{TypeRef, Mutability},\n-    name::KnownName,\n+    name::{KnownName},\n     expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n     generics::GenericParams,\n     path::{ GenericArgs, GenericArg},\n@@ -1166,15 +1166,55 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path) -> Option<Ty> {\n-        let resolved = resolver.resolve_path(self.db, &path).take_values()?;\n+        let resolved = resolver.resolve_path_segments(self.db, &path);\n+\n+        let (def, remaining_index) = resolved.into_inner();\n+\n+        // if the remaining_index is None, we expect the path\n+        // to be fully resolved, in this case we continue with\n+        // the default by attempting to `take_values\u00b4 from the resolution.\n+        // Otherwise the path was partially resolved, which means\n+        // we might have resolved into a type for which\n+        // we may find some associated item starting at the\n+        // path.segment pointed to by `remaining_index\u00b4\n+        let resolved =\n+            if remaining_index.is_none() { def.take_values()? } else { def.take_types()? };\n+\n         match resolved {\n             Resolution::Def(def) => {\n                 let typable: Option<TypableDef> = def.into();\n                 let typable = typable?;\n-                let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n-                let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n-                let ty = self.insert_type_vars(ty);\n-                Some(ty)\n+\n+                if let Some(remaining_index) = remaining_index {\n+                    let ty = self.db.type_for_def(typable, Namespace::Types);\n+                    // TODO: Keep resolving the segments\n+                    // if we have more segments to process\n+                    let segment = &path.segments[remaining_index];\n+\n+                    // Attempt to find an impl_item for the type which has a name matching\n+                    // the current segment\n+                    let ty = ty.iterate_impl_items(self.db, |item| match item {\n+                        crate::ImplItem::Method(func) => {\n+                            let sig = func.signature(self.db);\n+                            if segment.name == *sig.name() {\n+                                return Some(type_for_fn(self.db, func));\n+                            }\n+                            None\n+                        }\n+\n+                        // TODO: Resolve associated const\n+                        crate::ImplItem::Const(_) => None,\n+\n+                        // TODO: Resolve associated types\n+                        crate::ImplItem::Type(_) => None,\n+                    });\n+                    ty\n+                } else {\n+                    let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n+                    let ty = self.db.type_for_def(typable, Namespace::Values).apply_substs(substs);\n+                    let ty = self.insert_type_vars(ty);\n+                    Some(ty)\n+                }\n             }\n             Resolution::LocalBinding(pat) => {\n                 let ty = self.type_of_pat.get(pat)?;"}, {"sha": "131d1fa16c6b6c4535e7bbfc2ae357939d235e8d", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_const.snap", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_const.snap", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_const.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_const.snap?ref=3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "patch": "@@ -0,0 +1,14 @@\n+---\n+created: \"2019-02-21T21:51:46.497925200Z\"\n+creator: insta@0.6.3\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[227; 305) '{     ...:ID; }': ()\n+[237; 238) 'x': [unknown]\n+[241; 252) 'Struct::FOO': [unknown]\n+[262; 263) 'y': [unknown]\n+[266; 275) 'Enum::BAR': [unknown]\n+[285; 286) 'z': [unknown]\n+[289; 302) 'TraitTest::ID': [unknown]\n+"}, {"sha": "8f27af88c9f29d4e8ec6a28a4f5102e6b7ddcb43", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_method_enum.snap", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_enum.snap", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_enum.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_enum.snap?ref=3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "patch": "@@ -0,0 +1,20 @@\n+---\n+created: \"2019-02-20T11:04:56.553382800Z\"\n+creator: insta@0.6.3\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[48; 68) '{     ...     }': A\n+[58; 62) 'A::B': A\n+[89; 109) '{     ...     }': A\n+[99; 103) 'A::C': A\n+[122; 179) '{     ...  c; }': ()\n+[132; 133) 'a': A\n+[136; 140) 'A::b': fn b() -> A\n+[136; 142) 'A::b()': A\n+[148; 149) 'a': A\n+[159; 160) 'c': A\n+[163; 167) 'A::c': fn c() -> A\n+[163; 169) 'A::c()': A\n+[175; 176) 'c': A\n+"}, {"sha": "fe5d6590e66d0e134f968391b97b36ddfa12ab53", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_method_generics.snap", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_generics.snap", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_generics.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_generics.snap?ref=3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "patch": "@@ -0,0 +1,16 @@\n+---\n+created: \"2019-02-21T10:25:18.568887300Z\"\n+creator: insta@0.6.3\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[64; 67) 'val': T\n+[82; 109) '{     ...     }': Gen<T>\n+[92; 103) 'Gen { val }': Gen<T>\n+[98; 101) 'val': T\n+[123; 155) '{     ...32); }': ()\n+[133; 134) 'a': Gen<[unknown]>\n+[137; 146) 'Gen::make': fn make<[unknown]>(T) -> Gen<T>\n+[137; 152) 'Gen::make(0u32)': Gen<[unknown]>\n+[147; 151) '0u32': u32\n+"}, {"sha": "29ca9b0ea9e56f609a6fa3f55bf2ea89701bbddd", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_method_struct.snap", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_struct.snap", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_struct.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_struct.snap?ref=3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "patch": "@@ -0,0 +1,16 @@\n+---\n+created: \"2019-02-20T11:04:56.553382800Z\"\n+creator: insta@0.6.3\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[50; 76) '{     ...     }': A\n+[60; 70) 'A { x: 0 }': A\n+[67; 68) '0': u32\n+[89; 123) '{     ...a.x; }': ()\n+[99; 100) 'a': A\n+[103; 109) 'A::new': fn new() -> A\n+[103; 111) 'A::new()': A\n+[117; 118) 'a': A\n+[117; 120) 'a.x': u32\n+"}, {"sha": "6584bef39229cc8e6b893848735c9b9431037748", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_associated_method_with_modules.snap", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_with_modules.snap", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_with_modules.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_associated_method_with_modules.snap?ref=3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "patch": "@@ -0,0 +1,23 @@\n+---\n+created: \"2019-02-21T08:55:53.926725400Z\"\n+creator: insta@0.6.3\n+source: crates/ra_hir/src/ty/tests.rs\n+expression: \"&result\"\n+---\n+[56; 64) '{ A {} }': A\n+[58; 62) 'A {}': A\n+[126; 132) '{ 99 }': u32\n+[128; 130) '99': u32\n+[202; 210) '{ C {} }': C\n+[204; 208) 'C {}': C\n+[241; 325) '{     ...g(); }': ()\n+[251; 252) 'x': A\n+[255; 266) 'a::A::thing': fn thing() -> A\n+[255; 268) 'a::A::thing()': A\n+[278; 279) 'y': u32\n+[282; 293) 'b::B::thing': fn thing() -> u32\n+[282; 295) 'b::B::thing()': u32\n+[305; 306) 'z': C\n+[309; 320) 'c::C::thing': fn thing() -> C\n+[309; 322) 'c::C::thing()': C\n+"}, {"sha": "f04e9109cf3adc1bb7abed3b72ee9d6ba1812236", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "patch": "@@ -607,6 +607,140 @@ fn test() -> i128 {\n     );\n }\n \n+#[test]\n+fn infer_associated_const() {\n+    check_inference(\n+        \"infer_associated_const\",\n+        r#\"\n+struct Struct;\n+\n+impl Struct {\n+    const FOO: u32 = 1;\n+}\n+\n+enum Enum;\n+\n+impl Enum {\n+    const BAR: u32 = 2;\n+}\n+\n+trait Trait {\n+    const ID: u32;\n+}\n+\n+struct TraitTest;\n+\n+impl Trait for TraitTest {\n+    const ID: u32 = 5;\n+}\n+\n+fn test() {\n+    let x = Struct::FOO;\n+    let y = Enum::BAR;\n+    let z = TraitTest::ID;\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_struct() {\n+    check_inference(\n+        \"infer_associated_method_struct\",\n+        r#\"\n+struct A { x: u32 };\n+\n+impl A {\n+    fn new() -> A {\n+        A { x: 0 }\n+    }\n+}\n+fn test() {\n+    let a = A::new();\n+    a.x;\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_enum() {\n+    check_inference(\n+        \"infer_associated_method_enum\",\n+        r#\"\n+enum A { B, C };\n+\n+impl A {\n+    pub fn b() -> A {\n+        A::B\n+    }\n+    pub fn c() -> A {\n+        A::C\n+    }\n+}\n+fn test() {\n+    let a = A::b();\n+    a;\n+    let c = A::c();\n+    c;\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn infer_associated_method_with_modules() {\n+    check_inference(\n+        \"infer_associated_method_with_modules\",\n+        r#\"\n+mod a {\n+    struct A;\n+    impl A { pub fn thing() -> A { A {} }}\n+}\n+\n+mod b {\n+    struct B;\n+    impl B { pub fn thing() -> u32 { 99 }}\n+\n+    mod c {\n+        struct C;\n+        impl C { pub fn thing() -> C { C {} }}\n+    }\n+}\n+use b::c;\n+\n+fn test() {\n+    let x = a::A::thing();\n+    let y = b::B::thing();\n+    let z = c::C::thing();\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+#[ignore] // FIXME: After https://github.com/rust-analyzer/rust-analyzer/pull/866 is merged\n+fn infer_associated_method_generics() {\n+    check_inference(\n+        \"infer_associated_method_generics\",\n+        r#\"\n+struct Gen<T> {\n+    val: T\n+}\n+\n+impl<T> Gen<T> {\n+    pub fn make(val: T) -> Gen<T> {\n+        Gen { val }\n+    }\n+}\n+\n+fn test() {\n+    let a = Gen::make(0u32);\n+}\n+\"#,\n+    );\n+}\n+\n #[test]\n fn no_panic_on_field_of_enum() {\n     check_inference("}, {"sha": "c62683ad4047418a7bcf22a90693bd3dc77fa060", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d8a0982a12f3aa4b8c193a841f864b15c3cb66e/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=3d8a0982a12f3aa4b8c193a841f864b15c3cb66e", "patch": "@@ -240,4 +240,24 @@ mod tests {\n         assert_eq!(\"usize\", &type_name);\n     }\n \n+    #[test]\n+    fn test_hover_infer_associated_method_result() {\n+        let (analysis, position) = single_file_with_position(\n+            \"\n+            struct Thing { x: u32 };\n+\n+            impl Thing {\n+                fn new() -> Thing {\n+                    Thing { x: 0 }\n+                }\n+            }\n+\n+            fn main() {\n+                let foo_<|>test = Thing::new();\n+            }\n+            \",\n+        );\n+        let hover = analysis.hover(position).unwrap().unwrap();\n+        assert_eq!(hover.info, \"Thing\");\n+    }\n }"}]}