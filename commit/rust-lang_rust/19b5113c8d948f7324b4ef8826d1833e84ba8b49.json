{"sha": "19b5113c8d948f7324b4ef8826d1833e84ba8b49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5YjUxMTNjOGQ5NDhmNzMyNGI0ZWY4ODI2ZDE4MzNlODRiYThiNDk=", "commit": {"author": {"name": "dragan.mladjenovic", "email": "dragan.mladjenovic@rt-rk.com", "date": "2018-03-14T18:24:01Z"}, "committer": {"name": "dragan.mladjenovic", "email": "dragan.mladjenovic@rt-rk.com", "date": "2018-03-14T19:18:30Z"}, "message": " rustc_trans: fix small aggregate returns for big-endian mips64 FFI\n\n Current model of threating small aggregate returns as smallest encompassing integer works only for little-endian mips64.\n The patch forces small aggregate return values to be viewed as one or two i64 chunks leaving to the casting implementation\n to handle endianes differences.", "tree": {"sha": "96a77db5eca69b4b952dbf2944209fce1225c502", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96a77db5eca69b4b952dbf2944209fce1225c502"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19b5113c8d948f7324b4ef8826d1833e84ba8b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19b5113c8d948f7324b4ef8826d1833e84ba8b49", "html_url": "https://github.com/rust-lang/rust/commit/19b5113c8d948f7324b4ef8826d1833e84ba8b49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19b5113c8d948f7324b4ef8826d1833e84ba8b49/comments", "author": null, "committer": null, "parents": [{"sha": "24e679c375da94b0f7db732c45c4c53724e8854d", "url": "https://api.github.com/repos/rust-lang/rust/commits/24e679c375da94b0f7db732c45c4c53724e8854d", "html_url": "https://github.com/rust-lang/rust/commit/24e679c375da94b0f7db732c45c4c53724e8854d"}], "stats": {"total": 14, "additions": 1, "deletions": 13}, "files": [{"sha": "231fe4c6edb6737d5f35264e868f8cc615ba7a9c", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19b5113c8d948f7324b4ef8826d1833e84ba8b49/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19b5113c8d948f7324b4ef8826d1833e84ba8b49/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=19b5113c8d948f7324b4ef8826d1833e84ba8b49", "patch": "@@ -28,18 +28,6 @@ fn extend_integer_width_mips(arg: &mut ArgType, bits: u64) {\n     arg.extend_integer_width_to(bits);\n }\n \n-fn bits_to_int_reg(bits: u64) -> Reg {\n-    if bits <= 8 {\n-        Reg::i8()\n-    } else if bits <= 16 {\n-        Reg::i16()\n-    } else if bits <= 32 {\n-        Reg::i32()\n-    } else {\n-        Reg::i64()\n-    }\n-}\n-\n fn float_reg<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &ArgType<'tcx>, i: usize) -> Option<Reg> {\n     match ret.layout.field(cx, i).abi {\n         layout::Abi::Scalar(ref scalar) => match scalar.value {\n@@ -82,7 +70,7 @@ fn classify_ret_ty<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, ret: &mut ArgType<'tcx>)\n \n         // Cast to a uniform int structure\n         ret.cast_to(Uniform {\n-            unit: bits_to_int_reg(bits),\n+            unit: Reg::i64(),\n             total: size\n         });\n     } else {"}]}