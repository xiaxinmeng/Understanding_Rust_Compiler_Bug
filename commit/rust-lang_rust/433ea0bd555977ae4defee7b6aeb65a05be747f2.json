{"sha": "433ea0bd555977ae4defee7b6aeb65a05be747f2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzM2VhMGJkNTU1OTc3YWU0ZGVmZWU3YjZhZWI2NWEwNWJlNzQ3ZjI=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-16T20:27:44Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-17T15:51:07Z"}, "message": "Add C -> Rust example to FFI chapter of the book.\n\nFixes #10489.", "tree": {"sha": "9c8a3c47f6c518e9253d06529332c58372b7ca1c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c8a3c47f6c518e9253d06529332c58372b7ca1c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/433ea0bd555977ae4defee7b6aeb65a05be747f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/433ea0bd555977ae4defee7b6aeb65a05be747f2", "html_url": "https://github.com/rust-lang/rust/commit/433ea0bd555977ae4defee7b6aeb65a05be747f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/433ea0bd555977ae4defee7b6aeb65a05be747f2/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1ab3799bdb9ac2bad8125a603ad1a4f62a6f544", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1ab3799bdb9ac2bad8125a603ad1a4f62a6f544", "html_url": "https://github.com/rust-lang/rust/commit/d1ab3799bdb9ac2bad8125a603ad1a4f62a6f544"}], "stats": {"total": 74, "additions": 46, "deletions": 28}, "files": [{"sha": "b4c181b7e72d91de50da68b0b28f6a4ff691ddf5", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/433ea0bd555977ae4defee7b6aeb65a05be747f2/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/433ea0bd555977ae4defee7b6aeb65a05be747f2/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=433ea0bd555977ae4defee7b6aeb65a05be747f2", "patch": "@@ -11,7 +11,7 @@ snappy includes a C interface (documented in\n The following is a minimal example of calling a foreign function which will\n compile if snappy is installed:\n \n-~~~~no_run\n+```no_run\n extern crate libc;\n use libc::size_t;\n \n@@ -24,7 +24,7 @@ fn main() {\n     let x = unsafe { snappy_max_compressed_length(100) };\n     println!(\"max compressed length of a 100 byte buffer: {}\", x);\n }\n-~~~~\n+```\n \n The `extern` block is a list of function signatures in a foreign library, in\n this case with the platform's C ABI. The `#[link(...)]` attribute is used to\n@@ -44,7 +44,7 @@ keeping the binding correct at runtime.\n \n The `extern` block can be extended to cover the entire snappy API:\n \n-~~~~no_run\n+```no_run\n extern crate libc;\n use libc::{c_int, size_t};\n \n@@ -66,7 +66,7 @@ extern {\n                                          compressed_length: size_t) -> c_int;\n }\n # fn main() {}\n-~~~~\n+```\n \n # Creating a safe interface\n \n@@ -79,7 +79,7 @@ vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous\n length is number of elements currently contained, and the capacity is the total size in elements of\n the allocated memory. The length is less than or equal to the capacity.\n \n-~~~~\n+```\n # extern crate libc;\n # use libc::{c_int, size_t};\n # unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -> c_int { 0 }\n@@ -89,7 +89,7 @@ pub fn validate_compressed_buffer(src: &[u8]) -> bool {\n         snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0\n     }\n }\n-~~~~\n+```\n \n The `validate_compressed_buffer` wrapper above makes use of an `unsafe` block, but it makes the\n guarantee that calling it is safe for all inputs by leaving off `unsafe` from the function\n@@ -103,7 +103,7 @@ required capacity to hold the compressed output. The vector can then be passed t\n `snappy_compress` function as an output parameter. An output parameter is also passed to retrieve\n the true length after compression for setting the length.\n \n-~~~~\n+```\n # extern crate libc;\n # use libc::{size_t, c_int};\n # unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,\n@@ -124,12 +124,12 @@ pub fn compress(src: &[u8]) -> Vec<u8> {\n         dst\n     }\n }\n-~~~~\n+```\n \n Decompression is similar, because snappy stores the uncompressed size as part of the compression\n format and `snappy_uncompressed_length` will retrieve the exact buffer size required.\n \n-~~~~\n+```\n # extern crate libc;\n # use libc::{size_t, c_int};\n # unsafe fn snappy_uncompress(compressed: *const u8,\n@@ -159,7 +159,7 @@ pub fn uncompress(src: &[u8]) -> Option<Vec<u8>> {\n         }\n     }\n }\n-~~~~\n+```\n \n For reference, the examples used here are also available as an [library on\n GitHub](https://github.com/thestinger/rust-snappy).\n@@ -185,7 +185,7 @@ A basic example is:\n \n Rust code:\n \n-~~~~no_run\n+```no_run\n extern fn callback(a: i32) {\n     println!(\"I'm called from C with value {0}\", a);\n }\n@@ -202,11 +202,11 @@ fn main() {\n         trigger_callback(); // Triggers the callback\n     }\n }\n-~~~~\n+```\n \n C code:\n \n-~~~~c\n+```c\n typedef void (*rust_callback)(int32_t);\n rust_callback cb;\n \n@@ -218,7 +218,7 @@ int32_t register_callback(rust_callback callback) {\n void trigger_callback() {\n   cb(7); // Will call callback(7) in Rust\n }\n-~~~~\n+```\n \n In this example Rust's `main()` will call `trigger_callback()` in C,\n which would, in turn, call back to `callback()` in Rust.\n@@ -238,7 +238,7 @@ referenced Rust object.\n \n Rust code:\n \n-~~~~no_run\n+```no_run\n #[repr(C)]\n struct RustObject {\n     a: i32,\n@@ -269,11 +269,11 @@ fn main() {\n         trigger_callback();\n     }\n }\n-~~~~\n+```\n \n C code:\n \n-~~~~c\n+```c\n typedef void (*rust_callback)(void*, int32_t);\n void* cb_target;\n rust_callback cb;\n@@ -287,7 +287,7 @@ int32_t register_callback(void* callback_target, rust_callback callback) {\n void trigger_callback() {\n   cb(cb_target, 7); // Will call callback(&rustObject, 7) in Rust\n }\n-~~~~\n+```\n \n ## Asynchronous callbacks\n \n@@ -366,13 +366,13 @@ the `link_args` attribute. This attribute is applied to `extern` blocks and\n specifies raw flags which need to get passed to the linker when producing an\n artifact. An example usage would be:\n \n-~~~ no_run\n+``` no_run\n #![feature(link_args)]\n \n #[link_args = \"-foo -bar -baz\"]\n extern {}\n # fn main() {}\n-~~~\n+```\n \n Note that this feature is currently hidden behind the `feature(link_args)` gate\n because this is not a sanctioned way of performing linking. Right now rustc\n@@ -393,9 +393,9 @@ the compiler that the unsafety does not leak out of the block.\n Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like\n this:\n \n-~~~~\n+```\n unsafe fn kaboom(ptr: *const int) -> int { *ptr }\n-~~~~\n+```\n \n This function can only be called from an `unsafe` block or another `unsafe` function.\n \n@@ -405,7 +405,7 @@ Foreign APIs often export a global variable which could do something like track\n global state. In order to access these variables, you declare them in `extern`\n blocks with the `static` keyword:\n \n-~~~no_run\n+```no_run\n extern crate libc;\n \n #[link(name = \"readline\")]\n@@ -417,13 +417,13 @@ fn main() {\n     println!(\"You have readline version {} installed.\",\n              rl_readline_version as int);\n }\n-~~~\n+```\n \n Alternatively, you may need to alter global state provided by a foreign\n interface. To do this, statics can be declared with `mut` so rust can mutate\n them.\n \n-~~~no_run\n+```no_run\n extern crate libc;\n \n use std::ffi::CString;\n@@ -440,15 +440,15 @@ fn main() {\n     // get a line, process it\n     unsafe { rl_prompt = ptr::null(); }\n }\n-~~~\n+```\n \n # Foreign calling conventions\n \n Most foreign code exposes a C ABI, and Rust uses the platform's C calling convention by default when\n calling foreign functions. Some foreign functions, most notably the Windows API, use other calling\n conventions. Rust provides a way to tell the compiler which convention to use:\n \n-~~~~\n+```\n extern crate libc;\n \n #[cfg(all(target_os = \"win32\", target_arch = \"x86\"))]\n@@ -458,7 +458,7 @@ extern \"stdcall\" {\n     fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -> libc::c_int;\n }\n # fn main() { }\n-~~~~\n+```\n \n This applies to the entire `extern` block. The list of supported ABI constraints\n are:\n@@ -518,3 +518,21 @@ with one of the non-nullable types, it is represented as a single pointer,\n and the non-data variant is represented as the null pointer. So\n `Option<extern \"C\" fn(c_int) -> c_int>` is how one represents a nullable\n function pointer using the C ABI.\n+\n+# Calling Rust code from C\n+\n+You may wish to compile Rust code in a way so that it can be called from C. This is\n+fairly easy, but requires a few things:\n+\n+```\n+#[no_mangle]\n+pub extern fn hello_rust() -> *const u8 {\n+    \"Hello, world!\\0\".as_ptr()\n+}\n+```\n+\n+The `extern` makes this function adhere to the C calling convention, as\n+discussed above in \"[Foreign Calling\n+Conventions](guide-ffi.html#foreign-calling-conventions)\". The `no_mangle`\n+attribute turns off Rust's name mangling, so that it is easier to link to.\n+"}]}