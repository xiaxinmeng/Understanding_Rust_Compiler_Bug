{"sha": "275889f7f464614069e88ea8efbf41c560da0a06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NTg4OWY3ZjQ2NDYxNDA2OWU4OGVhOGVmYmY0MWM1NjBkYTBhMDY=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-08-07T21:06:40Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-08-07T21:06:40Z"}, "message": "Remove remaining usage of aliases", "tree": {"sha": "9c79a8dbc226d245301a6cd458649b5066cde64c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c79a8dbc226d245301a6cd458649b5066cde64c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/275889f7f464614069e88ea8efbf41c560da0a06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/275889f7f464614069e88ea8efbf41c560da0a06", "html_url": "https://github.com/rust-lang/rust/commit/275889f7f464614069e88ea8efbf41c560da0a06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/275889f7f464614069e88ea8efbf41c560da0a06/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7f29683a8f63e967c471c8cc27c7e43709bc6d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7f29683a8f63e967c471c8cc27c7e43709bc6d1", "html_url": "https://github.com/rust-lang/rust/commit/f7f29683a8f63e967c471c8cc27c7e43709bc6d1"}], "stats": {"total": 174, "additions": 87, "deletions": 87}, "files": [{"sha": "e1a085fd76dbdb0b86ef1efc31e17761cb0a8444", "filename": "crates/core_simd/src/permute.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fpermute.rs?ref=275889f7f464614069e88ea8efbf41c560da0a06", "patch": "@@ -15,12 +15,12 @@ macro_rules! impl_shuffle_lane {\n             ///\n             /// ```\n             /// #![feature(portable_simd)]\n-            /// # use core_simd::*;\n-            /// let a = f32x4::from_array([1.0, 2.0, 3.0, 4.0]);\n-            /// let b = f32x4::from_array([5.0, 6.0, 7.0, 8.0]);\n+            /// # use core_simd::Simd;\n+            /// let a = Simd::from_array([1.0, 2.0, 3.0, 4.0]);\n+            /// let b = Simd::from_array([5.0, 6.0, 7.0, 8.0]);\n             /// const IDXS: [u32; 4] = [4,0,3,7];\n-            /// let c = f32x4::shuffle::<IDXS>(a,b);\n-            /// assert_eq!(f32x4::from_array([5.0, 1.0, 4.0, 8.0]), c);\n+            /// let c = Simd::<_, 4>::shuffle::<IDXS>(a,b);\n+            /// assert_eq!(Simd::from_array([5.0, 1.0, 4.0, 8.0]), c);\n             /// ```\n             #[inline]\n             pub fn shuffle<const IDX: [u32; $n]>(self, second: Self) -> Self {\n@@ -56,9 +56,9 @@ macro_rules! impl_shuffle_lane {\n             ///\n             /// ```\n             /// #![feature(portable_simd)]\n-            /// # use core_simd::SimdU32;\n-            /// let a = SimdU32::from_array([0, 1, 2, 3]);\n-            /// let b = SimdU32::from_array([4, 5, 6, 7]);\n+            /// # use core_simd::Simd;\n+            /// let a = Simd::from_array([0, 1, 2, 3]);\n+            /// let b = Simd::from_array([4, 5, 6, 7]);\n             /// let (x, y) = a.interleave(b);\n             /// assert_eq!(x.to_array(), [0, 4, 1, 5]);\n             /// assert_eq!(y.to_array(), [2, 6, 3, 7]);\n@@ -108,9 +108,9 @@ macro_rules! impl_shuffle_lane {\n             ///\n             /// ```\n             /// #![feature(portable_simd)]\n-            /// # use core_simd::SimdU32;\n-            /// let a = SimdU32::from_array([0, 4, 1, 5]);\n-            /// let b = SimdU32::from_array([2, 6, 3, 7]);\n+            /// # use core_simd::Simd;\n+            /// let a = Simd::from_array([0, 4, 1, 5]);\n+            /// let b = Simd::from_array([2, 6, 3, 7]);\n             /// let (x, y) = a.deinterleave(b);\n             /// assert_eq!(x.to_array(), [0, 1, 2, 3]);\n             /// assert_eq!(y.to_array(), [4, 5, 6, 7]);"}, {"sha": "26c9bc0af6e1daececa14463fba63118abf9826b", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=275889f7f464614069e88ea8efbf41c560da0a06", "patch": "@@ -9,7 +9,7 @@ pub use uint::*;\n // Vectors of pointers are not for public use at the current time.\n pub(crate) mod ptr;\n \n-use crate::{LaneCount, MaskElement, SupportedLaneCount};\n+use crate::{LaneCount, Mask, MaskElement, SupportedLaneCount};\n \n /// A SIMD vector of `LANES` elements of type `Element`.\n #[repr(simd)]\n@@ -54,16 +54,16 @@ where\n     /// # #![feature(portable_simd)]\n     /// # use core_simd::*;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-    /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let alt = Simd::from_array([-5, -4, -3, -2]);\n     ///\n-    /// let result = SimdI32::<4>::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n-    /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, 15]));\n+    /// let result = Simd::gather_or(&vec, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, Simd::from_array([-5, 13, 10, 15]));\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn gather_or(slice: &[Element], idxs: crate::SimdUsize<LANES>, or: Self) -> Self {\n-        Self::gather_select(slice, crate::MaskSize::splat(true), idxs, or)\n+    pub fn gather_or(slice: &[Element], idxs: Simd<usize, LANES>, or: Self) -> Self {\n+        Self::gather_select(slice, Mask::splat(true), idxs, or)\n     }\n \n     /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n@@ -72,14 +72,14 @@ where\n     /// # #![feature(portable_simd)]\n     /// # use core_simd::*;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n     ///\n-    /// let result = SimdI32::<4>::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n-    /// assert_eq!(result, SimdI32::from_array([0, 13, 10, 15]));\n+    /// let result = Simd::gather_or_default(&vec, idxs); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, Simd::from_array([0, 13, 10, 15]));\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn gather_or_default(slice: &[Element], idxs: crate::SimdUsize<LANES>) -> Self\n+    pub fn gather_or_default(slice: &[Element], idxs: Simd<usize, LANES>) -> Self\n     where\n         Element: Default,\n     {\n@@ -92,22 +92,22 @@ where\n     /// # #![feature(portable_simd)]\n     /// # use core_simd::*;\n     /// let vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 5]);\n-    /// let alt = SimdI32::from_array([-5, -4, -3, -2]);\n-    /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let idxs = Simd::from_array([9, 3, 0, 5]);\n+    /// let alt = Simd::from_array([-5, -4, -3, -2]);\n+    /// let mask = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n     ///\n-    /// let result = SimdI32::<4>::gather_select(&vec, mask, idxs, alt); // Note the lane that is out-of-bounds.\n-    /// assert_eq!(result, SimdI32::from_array([-5, 13, 10, -2]));\n+    /// let result = Simd::gather_select(&vec, mask, idxs, alt); // Note the lane that is out-of-bounds.\n+    /// assert_eq!(result, Simd::from_array([-5, 13, 10, -2]));\n     /// ```\n     #[must_use]\n     #[inline]\n     pub fn gather_select(\n         slice: &[Element],\n-        mask: crate::MaskSize<LANES>,\n-        idxs: crate::SimdUsize<LANES>,\n+        mask: Mask<isize, LANES>,\n+        idxs: Simd<usize, LANES>,\n         or: Self,\n     ) -> Self {\n-        let mask = (mask & idxs.lanes_lt(crate::SimdUsize::splat(slice.len()))).to_int();\n+        let mask = (mask & idxs.lanes_lt(Simd::splat(slice.len()))).to_int();\n         let base_ptr = crate::vector::ptr::SimdConstPtr::splat(slice.as_ptr());\n         // Ferris forgive me, I have done pointer arithmetic here.\n         let ptrs = base_ptr.wrapping_add(idxs);\n@@ -122,15 +122,15 @@ where\n     /// # #![feature(portable_simd)]\n     /// # use core_simd::*;\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n-    /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let vals = Simd::from_array([-27, 82, -41, 124]);\n     ///\n     /// vals.scatter(&mut vec, idxs); // index 0 receives two writes.\n     /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     #[inline]\n-    pub fn scatter(self, slice: &mut [Element], idxs: crate::SimdUsize<LANES>) {\n-        self.scatter_select(slice, crate::MaskSize::splat(true), idxs)\n+    pub fn scatter(self, slice: &mut [Element], idxs: Simd<usize, LANES>) {\n+        self.scatter_select(slice, Mask::splat(true), idxs)\n     }\n \n     /// SIMD scatter: write a SIMD vector's values into a slice, using potentially discontiguous indices.\n@@ -140,9 +140,9 @@ where\n     /// # #![feature(portable_simd)]\n     /// # use core_simd::*;\n     /// let mut vec: Vec<i32> = vec![10, 11, 12, 13, 14, 15, 16, 17, 18];\n-    /// let idxs = SimdUsize::<4>::from_array([9, 3, 0, 0]);\n-    /// let vals = SimdI32::from_array([-27, 82, -41, 124]);\n-    /// let mask = MaskSize::from_array([true, true, true, false]); // Note the mask of the last lane.\n+    /// let idxs = Simd::from_array([9, 3, 0, 0]);\n+    /// let vals = Simd::from_array([-27, 82, -41, 124]);\n+    /// let mask = Mask::from_array([true, true, true, false]); // Note the mask of the last lane.\n     ///\n     /// vals.scatter_select(&mut vec, mask, idxs); // index 0's second write is masked, thus omitted.\n     /// assert_eq!(vec, vec![-41, 11, 12, 82, 14, 15, 16, 17, 18]);\n@@ -151,11 +151,11 @@ where\n     pub fn scatter_select(\n         self,\n         slice: &mut [Element],\n-        mask: crate::MaskSize<LANES>,\n-        idxs: crate::SimdUsize<LANES>,\n+        mask: Mask<isize, LANES>,\n+        idxs: Simd<usize, LANES>,\n     ) {\n         // We must construct our scatter mask before we derive a pointer!\n-        let mask = (mask & idxs.lanes_lt(crate::SimdUsize::splat(slice.len()))).to_int();\n+        let mask = (mask & idxs.lanes_lt(Simd::splat(slice.len()))).to_int();\n         // SAFETY: This block works with *mut T derived from &mut 'a [T],\n         // which means it is delicate in Rust's borrowing model, circa 2021:\n         // &mut 'a [T] asserts uniqueness, so deriving &'a [T] invalidates live *mut Ts!"}, {"sha": "96aacdfcca1021ca49d7eb9e8eaa3cee9d3f4ab4", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=275889f7f464614069e88ea8efbf41c560da0a06", "patch": "@@ -1,29 +1,29 @@\n #![allow(non_camel_case_types)]\n \n-use crate::{LaneCount, SupportedLaneCount};\n+use crate::{LaneCount, Mask, Simd, SupportedLaneCount};\n \n-/// Implements inherent methods for a float vector `$name` containing multiple\n+/// Implements inherent methods for a float vector containing multiple\n /// `$lanes` of float `$type`, which uses `$bits_ty` as its binary\n-/// representation. Called from `define_float_vector!`.\n+/// representation.\n macro_rules! impl_float_vector {\n-    { $name:ident, $type:ident, $bits_ty:ident, $mask_ty:ident, $mask_impl_ty:ident } => {\n-        impl<const LANES: usize> $name<LANES>\n+    { $type:ty, $bits_ty:ty, $mask_ty:ty } => {\n+        impl<const LANES: usize> Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Raw transmutation to an unsigned integer vector type with the\n             /// same size and number of lanes.\n             #[inline]\n-            pub fn to_bits(self) -> crate::$bits_ty<LANES> {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<crate::$bits_ty<LANES>>());\n+            pub fn to_bits(self) -> Simd<$bits_ty, LANES> {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n                 unsafe { core::mem::transmute_copy(&self) }\n             }\n \n             /// Raw transmutation from an unsigned integer vector type with the\n             /// same size and number of lanes.\n             #[inline]\n-            pub fn from_bits(bits: crate::$bits_ty<LANES>) -> Self {\n-                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<crate::$bits_ty<LANES>>());\n+            pub fn from_bits(bits: Simd<$bits_ty, LANES>) -> Self {\n+                assert_eq!(core::mem::size_of::<Self>(), core::mem::size_of::<Simd<$bits_ty, LANES>>());\n                 unsafe { core::mem::transmute_copy(&bits) }\n             }\n \n@@ -64,58 +64,58 @@ macro_rules! impl_float_vector {\n             #[inline]\n             pub fn to_degrees(self) -> Self {\n                 // to_degrees uses a special constant for better precision, so extract that constant\n-                self * Self::splat($type::to_degrees(1.))\n+                self * Self::splat(<$type>::to_degrees(1.))\n             }\n \n             /// Converts each lane from degrees to radians.\n             #[inline]\n             pub fn to_radians(self) -> Self {\n-                self * Self::splat($type::to_radians(1.))\n+                self * Self::splat(<$type>::to_radians(1.))\n             }\n \n             /// Returns true for each lane if it has a positive sign, including\n             /// `+0.0`, `NaN`s with positive sign bit and positive infinity.\n             #[inline]\n-            pub fn is_sign_positive(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_sign_positive(self) -> Mask<$mask_ty, LANES> {\n                 !self.is_sign_negative()\n             }\n \n             /// Returns true for each lane if it has a negative sign, including\n             /// `-0.0`, `NaN`s with negative sign bit and negative infinity.\n             #[inline]\n-            pub fn is_sign_negative(self) -> crate::$mask_ty<LANES> {\n-                let sign_bits = self.to_bits() & crate::$bits_ty::splat((!0 >> 1) + 1);\n-                sign_bits.lanes_gt(crate::$bits_ty::splat(0))\n+            pub fn is_sign_negative(self) -> Mask<$mask_ty, LANES> {\n+                let sign_bits = self.to_bits() & Simd::splat((!0 >> 1) + 1);\n+                sign_bits.lanes_gt(Simd::splat(0))\n             }\n \n             /// Returns true for each lane if its value is `NaN`.\n             #[inline]\n-            pub fn is_nan(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_nan(self) -> Mask<$mask_ty, LANES> {\n                 self.lanes_ne(self)\n             }\n \n             /// Returns true for each lane if its value is positive infinity or negative infinity.\n             #[inline]\n-            pub fn is_infinite(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_infinite(self) -> Mask<$mask_ty, LANES> {\n                 self.abs().lanes_eq(Self::splat(<$type>::INFINITY))\n             }\n \n             /// Returns true for each lane if its value is neither infinite nor `NaN`.\n             #[inline]\n-            pub fn is_finite(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_finite(self) -> Mask<$mask_ty, LANES> {\n                 self.abs().lanes_lt(Self::splat(<$type>::INFINITY))\n             }\n \n             /// Returns true for each lane if its value is subnormal.\n             #[inline]\n-            pub fn is_subnormal(self) -> crate::$mask_ty<LANES> {\n-                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(crate::$bits_ty::splat(0))\n+            pub fn is_subnormal(self) -> Mask<$mask_ty, LANES> {\n+                self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(Simd::splat(0))\n             }\n \n             /// Returns true for each lane if its value is neither neither zero, infinite,\n             /// subnormal, or `NaN`.\n             #[inline]\n-            pub fn is_normal(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_normal(self) -> Mask<$mask_ty, LANES> {\n                 !(self.abs().lanes_eq(Self::splat(0.0)) | self.is_nan() | self.is_subnormal() | self.is_infinite())\n             }\n \n@@ -126,7 +126,7 @@ macro_rules! impl_float_vector {\n             /// * `NAN` if the number is `NAN`\n             #[inline]\n             pub fn signum(self) -> Self {\n-                self.is_nan().select(Self::splat($type::NAN), Self::splat(1.0).copysign(self))\n+                self.is_nan().select(Self::splat(<$type>::NAN), Self::splat(1.0).copysign(self))\n             }\n \n             /// Returns each lane with the magnitude of `self` and the sign of `sign`.\n@@ -189,8 +189,8 @@ pub type SimdF32<const LANES: usize> = crate::Simd<f32, LANES>;\n /// A SIMD vector of containing `LANES` `f64` values.\n pub type SimdF64<const LANES: usize> = crate::Simd<f64, LANES>;\n \n-impl_float_vector! { SimdF32, f32, SimdU32, Mask32, SimdI32 }\n-impl_float_vector! { SimdF64, f64, SimdU64, Mask64, SimdI64 }\n+impl_float_vector! { f32, u32, i32 }\n+impl_float_vector! { f64, u64, i64 }\n \n /// Vector of two `f32` values\n pub type f32x2 = SimdF32<2>;"}, {"sha": "38d90ad62c0de49831124740eb09caf1cb61a8a8", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=275889f7f464614069e88ea8efbf41c560da0a06", "patch": "@@ -1,23 +1,23 @@\n #![allow(non_camel_case_types)]\n \n-use crate::{LaneCount, SupportedLaneCount};\n+use crate::{LaneCount, Mask, Simd, SupportedLaneCount};\n \n /// Implements additional integer traits (Eq, Ord, Hash) on the specified vector `$name`, holding multiple `$lanes` of `$type`.\n macro_rules! impl_integer_vector {\n-    { $name:ident, $type:ty, $mask_ty:ident, $mask_impl_ty:ident } => {\n-        impl<const LANES: usize> $name<LANES>\n+    { $type:ty } => {\n+        impl<const LANES: usize> Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,\n         {\n             /// Returns true for each positive lane and false if it is zero or negative.\n             #[inline]\n-            pub fn is_positive(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_positive(self) -> Mask<$type, LANES> {\n                 self.lanes_gt(Self::splat(0))\n             }\n \n             /// Returns true for each negative lane and false if it is zero or positive.\n             #[inline]\n-            pub fn is_negative(self) -> crate::$mask_ty<LANES> {\n+            pub fn is_negative(self) -> Mask<$type, LANES> {\n                 self.lanes_lt(Self::splat(0))\n             }\n \n@@ -51,11 +51,11 @@ pub type SimdI64<const LANES: usize> = crate::Simd<i64, LANES>;\n /// A SIMD vector of containing `LANES` `isize` values.\n pub type SimdIsize<const LANES: usize> = crate::Simd<isize, LANES>;\n \n-impl_integer_vector! { SimdIsize, isize, MaskSize, SimdIsize }\n-impl_integer_vector! { SimdI16, i16, Mask16, SimdI16 }\n-impl_integer_vector! { SimdI32, i32, Mask32, SimdI32 }\n-impl_integer_vector! { SimdI64, i64, Mask64, SimdI64 }\n-impl_integer_vector! { SimdI8, i8, Mask8, SimdI8 }\n+impl_integer_vector! { isize }\n+impl_integer_vector! { i16 }\n+impl_integer_vector! { i32 }\n+impl_integer_vector! { i64 }\n+impl_integer_vector! { i8 }\n \n /// Vector of two `isize` values\n pub type isizex2 = SimdIsize<2>;"}, {"sha": "fc4082a4b555a1a3fd045559d3b34ccdd9283a59", "filename": "crates/core_simd/src/vector/ptr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fptr.rs?ref=275889f7f464614069e88ea8efbf41c560da0a06", "patch": "@@ -1,5 +1,5 @@\n //! Private implementation details of public gather/scatter APIs.\n-use crate::{LaneCount, SimdUsize, SupportedLaneCount};\n+use crate::{LaneCount, Simd, SupportedLaneCount};\n use core::mem;\n \n /// A vector of *const T.\n@@ -20,9 +20,9 @@ where\n \n     #[inline]\n     #[must_use]\n-    pub fn wrapping_add(self, addend: SimdUsize<LANES>) -> Self {\n+    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n         unsafe {\n-            let x: SimdUsize<LANES> = mem::transmute_copy(&self);\n+            let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n         }\n     }\n@@ -46,9 +46,9 @@ where\n \n     #[inline]\n     #[must_use]\n-    pub fn wrapping_add(self, addend: SimdUsize<LANES>) -> Self {\n+    pub fn wrapping_add(self, addend: Simd<usize, LANES>) -> Self {\n         unsafe {\n-            let x: SimdUsize<LANES> = mem::transmute_copy(&self);\n+            let x: Simd<usize, LANES> = mem::transmute_copy(&self);\n             mem::transmute_copy(&{ x + (addend * mem::size_of::<T>()) })\n         }\n     }"}, {"sha": "ea52e8f5ca7348dff1baa1054432f92279a30b34", "filename": "crates/core_simd/tests/permute.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Ftests%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Ftests%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fpermute.rs?ref=275889f7f464614069e88ea8efbf41c560da0a06", "patch": "@@ -1,6 +1,6 @@\n #![feature(portable_simd)]\n \n-use core_simd::SimdU32;\n+use core_simd::Simd;\n \n #[cfg(target_arch = \"wasm32\")]\n use wasm_bindgen_test::*;\n@@ -11,23 +11,23 @@ wasm_bindgen_test_configure!(run_in_browser);\n #[test]\n #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n fn simple_shuffle() {\n-    let a = SimdU32::from_array([2, 4, 1, 9]);\n+    let a = Simd::from_array([2, 4, 1, 9]);\n     let b = a;\n     assert_eq!(a.shuffle::<{ [3, 1, 4, 6] }>(b).to_array(), [9, 4, 2, 1]);\n }\n \n #[test]\n #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n fn reverse() {\n-    let a = SimdU32::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n+    let a = Simd::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n     assert_eq!(a.reverse().to_array(), [7, 6, 5, 4, 3, 2, 1, 0]);\n }\n \n #[test]\n #[cfg_attr(target_arch = \"wasm32\", wasm_bindgen_test)]\n fn interleave() {\n-    let a = SimdU32::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n-    let b = SimdU32::from_array([8, 9, 10, 11, 12, 13, 14, 15]);\n+    let a = Simd::from_array([0, 1, 2, 3, 4, 5, 6, 7]);\n+    let b = Simd::from_array([8, 9, 10, 11, 12, 13, 14, 15]);\n     let (lo, hi) = a.interleave(b);\n     assert_eq!(lo.to_array(), [0, 8, 1, 9, 2, 10, 3, 11]);\n     assert_eq!(hi.to_array(), [4, 12, 5, 13, 6, 14, 7, 15]);"}, {"sha": "c66c9d5bd36f59510e1905cbe12b85cdce9201e0", "filename": "crates/core_simd/tests/to_bytes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/275889f7f464614069e88ea8efbf41c560da0a06/crates%2Fcore_simd%2Ftests%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fto_bytes.rs?ref=275889f7f464614069e88ea8efbf41c560da0a06", "patch": "@@ -2,13 +2,13 @@\n #![allow(incomplete_features)]\n #![cfg(feature = \"const_evaluatable_checked\")]\n \n-use core_simd::SimdU32;\n+use core_simd::Simd;\n \n #[test]\n fn byte_convert() {\n-    let int = SimdU32::from_array([0xdeadbeef, 0x8badf00d]);\n+    let int = Simd::<u32, 2>::from_array([0xdeadbeef, 0x8badf00d]);\n     let bytes = int.to_ne_bytes();\n     assert_eq!(int[0].to_ne_bytes(), bytes[..4]);\n     assert_eq!(int[1].to_ne_bytes(), bytes[4..]);\n-    assert_eq!(SimdU32::from_ne_bytes(bytes), int);\n+    assert_eq!(Simd::<u32, 2>::from_ne_bytes(bytes), int);\n }"}]}