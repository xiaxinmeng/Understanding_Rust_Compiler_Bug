{"sha": "d1bfa51ea86259de21665077e4d32f8f8322b8e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxYmZhNTFlYTg2MjU5ZGUyMTY2NTA3N2U0ZDMyZjhmODMyMmI4ZTE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-11T19:59:30Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-04-15T13:24:30Z"}, "message": "std: Update documentation on the `comm` module\n\nSome of this documentation got a little out of date. There was no mention of a\n`SyncSender`, and the entire \"Outside the runtime\" section isn't really true any\nmore (or really all that relevant).\n\nThis also updates a few other doc blocks and adds some examples.", "tree": {"sha": "c61451cee6d933da073c9baf866d5f82e3829faa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c61451cee6d933da073c9baf866d5f82e3829faa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1bfa51ea86259de21665077e4d32f8f8322b8e1", "comment_count": 13, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1bfa51ea86259de21665077e4d32f8f8322b8e1", "html_url": "https://github.com/rust-lang/rust/commit/d1bfa51ea86259de21665077e4d32f8f8322b8e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1bfa51ea86259de21665077e4d32f8f8322b8e1/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab0d8472777d2359492dfdee1d21230fbf144f70", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab0d8472777d2359492dfdee1d21230fbf144f70", "html_url": "https://github.com/rust-lang/rust/commit/ab0d8472777d2359492dfdee1d21230fbf144f70"}], "stats": {"total": 100, "additions": 77, "deletions": 23}, "files": [{"sha": "397a2bd60be484a6db39d368dfc03b573d27d7d3", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 77, "deletions": 23, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/d1bfa51ea86259de21665077e4d32f8f8322b8e1/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1bfa51ea86259de21665077e4d32f8f8322b8e1/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=d1bfa51ea86259de21665077e4d32f8f8322b8e1", "patch": "@@ -16,19 +16,32 @@\n //! module are the building blocks for synchronization in rust.\n //!\n //! This module provides message-based communication over channels, concretely\n-//! defined as two types:\n+//! defined among three types:\n //!\n //! * `Sender`\n+//! * `SyncSender`\n //! * `Receiver`\n //!\n-//! A `Sender` is used to send data to a `Receiver`. A `Sender` is clone-able\n-//! such that many tasks can send simultaneously to one receiver. These\n-//! channels are *task blocking*, not *thread blocking*. This means that if one\n-//! task is blocked on a channel, other tasks can continue to make progress.\n+//! A `Sender` or `SyncSender` is used to send data to a `Receiver`. Both\n+//! senders are clone-able such that many tasks can send simultaneously to one\n+//! receiver.  These channels are *task blocking*, not *thread blocking*. This\n+//! means that if one task is blocked on a channel, other tasks can continue to\n+//! make progress.\n //!\n-//! Rust channels can be used as if they have an infinite internal buffer. What\n-//! this means is that the `send` operation will never block. `Receiver`s, on\n-//! the other hand, will block the task if there is no data to be received.\n+//! Rust channels come in one of two flavors:\n+//!\n+//! 1. An asynchronous, infinitely buffered channel. The `channel()` function\n+//!    will return a `(Sender, Receiver)` tuple where all sends will be\n+//!    **asynchronous** (they never block). The channel conceptually has an\n+//!    infinite buffer.\n+//!\n+//! 2. A synchronous, bounded channel. The `sync_channel()` function will return\n+//!    a `(SyncSender, Receiver)` tuple where the storage for pending messages\n+//!    is a pre-allocated buffer of a fixed size. All sends will be\n+//!    **synchronous** by blocking until there is buffer space available. Note\n+//!    that a bound of 0 is allowed, causing the channel to become a\n+//!    \"rendezvous\" channel where each sender atomically hands off a message to\n+//!    a receiver.\n //!\n //! ## Failure Propagation\n //!\n@@ -38,32 +51,40 @@\n //! `fail!`. The purpose of this is to allow propagation of failure among tasks\n //! that are linked to one another via channels.\n //!\n-//! There are methods on both of `Sender` and `Receiver` to perform their\n+//! There are methods on both of senders and receivers to perform their\n //! respective operations without failing, however.\n //!\n-//! ## Outside the Runtime\n+//! ## Runtime Requirements\n //!\n-//! All channels and ports work seamlessly inside and outside of the rust\n-//! runtime. This means that code may use channels to communicate information\n-//! inside and outside of the runtime. For example, if rust were embedded as an\n-//! FFI module in another application, the rust runtime would probably be\n-//! running in its own external thread pool. Channels created can communicate\n-//! from the native application threads to the rust threads through the use of\n-//! native mutexes and condition variables.\n+//! The channel types defined in this module generally have very few runtime\n+//! requirements in order to operate. The major requirement they have is for a\n+//! local rust `Task` to be available if any *blocking* operation is performed.\n //!\n-//! What this means is that if a native thread is using a channel, execution\n-//! will be blocked accordingly by blocking the OS thread.\n+//! If a local `Task` is not available (for example an FFI callback), then the\n+//! `send` operation is safe on a `Sender` (as well as a `send_opt`) as well as\n+//! the `try_send` method on a `SyncSender`, but no other operations are\n+//! guaranteed to be safe.\n+//!\n+//! Additionally, channels can interoperate between runtimes. If one task in a\n+//! program is running on libnative and another is running on libgreen, they can\n+//! still communicate with one another using channels.\n //!\n //! # Example\n //!\n-//! ```rust,should_fail\n+//! Simple usage:\n+//!\n+//! ```\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n //! spawn(proc() {\n //!     tx.send(10);\n //! });\n //! assert_eq!(rx.recv(), 10);\n+//! ```\n+//!\n+//! Shared usage:\n //!\n+//! ```\n //! // Create a shared channel which can be sent along from many tasks\n //! let (tx, rx) = channel();\n //! for i in range(0, 10) {\n@@ -77,13 +98,28 @@\n //!     let j = rx.recv();\n //!     assert!(0 <= j && j < 10);\n //! }\n+//! ```\n //!\n+//! Propagating failure:\n+//!\n+//! ```should_fail\n //! // The call to recv() will fail!() because the channel has already hung\n //! // up (or been deallocated)\n //! let (tx, rx) = channel::<int>();\n //! drop(tx);\n //! rx.recv();\n //! ```\n+//!\n+//! Synchronous channels:\n+//!\n+//! ```\n+//! let (tx, rx) = sync_channel(0);\n+//! spawn(proc() {\n+//!     // This will wait for the parent task to start receiving\n+//!     tx.send(53);\n+//! });\n+//! rx.recv();\n+//! ```\n \n // A description of how Rust's channel implementation works\n //\n@@ -354,9 +390,27 @@ enum Flavor<T> {\n     Sync(UnsafeArc<sync::Packet<T>>),\n }\n \n-/// Creates a new channel, returning the sender/receiver halves. All data sent\n-/// on the sender will become available on the receiver. See the documentation\n-/// of `Receiver` and `Sender` to see what's possible with them.\n+/// Creates a new asynchronous channel, returning the sender/receiver halves.\n+///\n+/// All data sent on the sender will become available on the receiver, and no\n+/// send will block the calling task (this channel has an \"infinite buffer\").\n+///\n+/// # Example\n+///\n+/// ```\n+/// let (tx, rx) = channel();\n+///\n+/// // Spawn off an expensive computation\n+/// spawn(proc() {\n+/// #   fn expensive_computation() {}\n+///     tx.send(expensive_computation());\n+/// });\n+///\n+/// // Do some useful work for awhile\n+///\n+/// // Let's see what that answer was\n+/// println!(\"{}\", rx.recv());\n+/// ```\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let (a, b) = UnsafeArc::new2(oneshot::Packet::new());\n     (Sender::new(Oneshot(b)), Receiver::new(Oneshot(a)))"}]}