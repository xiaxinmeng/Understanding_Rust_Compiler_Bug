{"sha": "937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzN2U4ZGEzNDllNjBkOGU1NmUxZWJiM2YwM2EzZTM5NGJmM2M5ZWI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-01T07:42:09Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-01-04T18:33:59Z"}, "message": "Purge FunctionContext", "tree": {"sha": "cfb5ce8e13137ce311e2c51c607e477a6032e611", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfb5ce8e13137ce311e2c51c607e477a6032e611"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "html_url": "https://github.com/rust-lang/rust/commit/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1be170b01addf84534b51d68e2d5ac76a1a42ac6", "url": "https://api.github.com/repos/rust-lang/rust/commits/1be170b01addf84534b51d68e2d5ac76a1a42ac6", "html_url": "https://github.com/rust-lang/rust/commit/1be170b01addf84534b51d68e2d5ac76a1a42ac6"}], "stats": {"total": 227, "additions": 82, "deletions": 145}, "files": [{"sha": "cdd909477fdc9fd28bca4a7221edf3f3a623603e", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -54,7 +54,7 @@ use callee::{Callee};\n use common::{C_bool, C_bytes_in_context, C_i32, C_uint};\n use collector::{self, TransItemCollectionMode};\n use common::{C_struct_in_context, C_u64, C_undef};\n-use common::{CrateContext, FunctionContext};\n+use common::CrateContext;\n use common::{fulfill_obligation};\n use common::{type_is_zero_size, val_ty};\n use common;\n@@ -590,32 +590,30 @@ pub fn trans_instance<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, instance: Instance\n \n     let fn_ty = FnType::new(ccx, abi, &sig, &[]);\n \n-    let fcx = FunctionContext::new(ccx, lldecl);\n     let mir = ccx.tcx().item_mir(instance.def);\n-    mir::trans_mir(&fcx, fn_ty, &mir, instance, &sig, abi);\n+    mir::trans_mir(ccx, lldecl, fn_ty, &mir, instance, &sig, abi);\n }\n \n pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                  def_id: DefId,\n                                  substs: &'tcx Substs<'tcx>,\n                                  disr: Disr,\n-                                 llfndecl: ValueRef) {\n-    attributes::inline(llfndecl, attributes::InlineAttr::Hint);\n-    attributes::set_frame_pointer_elimination(ccx, llfndecl);\n+                                 llfn: ValueRef) {\n+    attributes::inline(llfn, attributes::InlineAttr::Hint);\n+    attributes::set_frame_pointer_elimination(ccx, llfn);\n \n     let ctor_ty = ccx.tcx().item_type(def_id);\n     let ctor_ty = monomorphize::apply_param_substs(ccx.shared(), substs, &ctor_ty);\n \n     let sig = ccx.tcx().erase_late_bound_regions_and_normalize(&ctor_ty.fn_sig());\n     let fn_ty = FnType::new(ccx, Abi::Rust, &sig, &[]);\n \n-    let fcx = FunctionContext::new(ccx, llfndecl);\n-    let bcx = fcx.get_entry_block();\n+    let bcx = Builder::entry_block(ccx, llfn);\n     if !fn_ty.ret.is_ignore() {\n         // But if there are no nested returns, we skip the indirection\n         // and have a single retslot\n         let dest = if fn_ty.ret.is_indirect() {\n-            get_param(fcx.llfn, 0)\n+            get_param(llfn, 0)\n         } else {\n             // We create an alloca to hold a pointer of type `ret.original_ty`\n             // which will hold the pointer to the right alloca which has the"}, {"sha": "610446d316d8e06a1e058989999cfa3bfe28e688", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -50,6 +50,10 @@ fn noname() -> *const c_char {\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n+    pub fn entry_block(ccx: &'a CrateContext<'a, 'tcx>, llfn: ValueRef) -> Self {\n+        Builder::new_block(ccx, llfn, \"entry-block\")\n+    }\n+\n     pub fn new_block<'b>(ccx: &'a CrateContext<'a, 'tcx>, llfn: ValueRef, name: &'b str) -> Self {\n         let builder = Builder::with_ccx(ccx);\n         let llbb = unsafe {"}, {"sha": "e73bfd73e9b0783c2b2c8ea3a803b0e38c33621d", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -23,9 +23,9 @@ use rustc::traits;\n use abi::{Abi, FnType};\n use attributes;\n use base;\n-use common::{\n-    self, CrateContext, FunctionContext, SharedCrateContext\n-};\n+use builder::Builder;\n+use common::{self, CrateContext, SharedCrateContext};\n+use cleanup::CleanupScope;\n use adt::MaybeSizedValue;\n use consts;\n use declare;\n@@ -329,8 +329,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n     attributes::set_frame_pointer_elimination(ccx, lloncefn);\n \n     let orig_fn_ty = fn_ty;\n-    let fcx = FunctionContext::new(ccx, lloncefn);\n-    let mut bcx = fcx.get_entry_block();\n+    let mut bcx = Builder::entry_block(ccx, lloncefn);\n \n     let callee = Callee {\n         data: Fn(llreffn),\n@@ -339,7 +338,7 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // the first argument (`self`) will be the (by value) closure env.\n \n-    let mut llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(lloncefn);\n     let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(bcx.ccx, &[]);\n     let self_idx = fn_ty.ret.is_indirect() as usize;\n@@ -364,7 +363,9 @@ fn trans_fn_once_adapter_shim<'a, 'tcx>(\n \n     // Call the by-ref closure body with `self` in a cleanup scope,\n     // to drop `self` when the body returns, or in case it unwinds.\n-    let self_scope = fcx.schedule_drop_mem(&bcx, MaybeSizedValue::sized(llenv), closure_ty);\n+    let self_scope = CleanupScope::schedule_drop_mem(\n+        &bcx, MaybeSizedValue::sized(llenv), closure_ty\n+    );\n \n     let llfn = callee.reify(bcx.ccx);\n     let llret;\n@@ -488,10 +489,9 @@ fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn = declare::define_internal_fn(ccx, &function_name, tuple_fn_ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n     //\n-    let fcx = FunctionContext::new(ccx, llfn);\n-    let bcx = fcx.get_entry_block();\n+    let bcx = Builder::entry_block(ccx, llfn);\n \n-    let mut llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(llfn);\n \n     let self_arg = llargs.remove(fn_ty.ret.is_indirect() as usize);\n     let llfnpointer = llfnpointer.unwrap_or_else(|| {"}, {"sha": "b41b26e1d06f4da86eafea08b9d78bf22b420636", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -22,7 +22,7 @@ use llvm::BasicBlockRef;\n use base;\n use adt::MaybeSizedValue;\n use builder::Builder;\n-use common::{FunctionContext, Funclet};\n+use common::Funclet;\n use glue;\n use type_::Type;\n use rustc::ty::Ty;\n@@ -93,12 +93,12 @@ impl<'tcx> DropValue<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n+impl<'a, 'tcx> CleanupScope<'tcx> {\n     /// Schedules a (deep) drop of `val`, which is a pointer to an instance of `ty`\n     pub fn schedule_drop_mem(\n-        &self, bcx: &Builder<'a, 'tcx>, val: MaybeSizedValue, ty: Ty<'tcx>\n+        bcx: &Builder<'a, 'tcx>, val: MaybeSizedValue, ty: Ty<'tcx>\n     ) -> CleanupScope<'tcx> {\n-        if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n+        if !bcx.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n         let drop = DropValue {\n             val: val,\n             ty: ty,\n@@ -114,11 +114,11 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n     /// and dropping the contents associated with that variant\n     /// *without* executing any associated drop implementation.\n     pub fn schedule_drop_adt_contents(\n-        &self, bcx: &Builder<'a, 'tcx>, val: MaybeSizedValue, ty: Ty<'tcx>\n+        bcx: &Builder<'a, 'tcx>, val: MaybeSizedValue, ty: Ty<'tcx>\n     ) -> CleanupScope<'tcx> {\n         // `if` below could be \"!contents_needs_drop\"; skipping drop\n         // is just an optimization, so sound to be conservative.\n-        if !self.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n+        if !bcx.ccx.shared().type_needs_drop(ty) { return CleanupScope::noop(); }\n \n         let drop = DropValue {\n             val: val,\n@@ -128,10 +128,8 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n \n         CleanupScope::new(bcx, drop)\n     }\n-}\n \n-impl<'tcx> CleanupScope<'tcx> {\n-    fn new<'a>(bcx: &Builder<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n+    fn new(bcx: &Builder<'a, 'tcx>, drop_val: DropValue<'tcx>) -> CleanupScope<'tcx> {\n         CleanupScope {\n             cleanup: Some(drop_val),\n             landing_pad: if !bcx.ccx.sess().no_landing_pads() {\n@@ -149,7 +147,7 @@ impl<'tcx> CleanupScope<'tcx> {\n         }\n     }\n \n-    pub fn trans<'a>(self, bcx: &'a Builder<'a, 'tcx>) {\n+    pub fn trans(self, bcx: &'a Builder<'a, 'tcx>) {\n         if let Some(cleanup) = self.cleanup {\n             cleanup.trans(None, &bcx);\n         }"}, {"sha": "8dcb835350b373d1a6ec0524d91d16196522e319", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 67, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -13,7 +13,7 @@\n //! Code that is useful in various trans modules.\n \n use llvm;\n-use llvm::{ValueRef, BasicBlockRef, ContextRef, TypeKind};\n+use llvm::{ValueRef, ContextRef, TypeKind};\n use llvm::{True, False, Bool, OperandBundleDef};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n@@ -36,7 +36,6 @@ use rustc::hir;\n use libc::{c_uint, c_char};\n use std::borrow::Cow;\n use std::iter;\n-use std::ffi::CString;\n \n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n@@ -219,71 +218,6 @@ impl<'a, 'tcx> VariantInfo<'tcx> {\n     }\n }\n \n-// Function context. Every LLVM function we create will have one of these.\n-pub struct FunctionContext<'a, 'tcx: 'a> {\n-    // The ValueRef returned from a call to llvm::LLVMAddFunction; the\n-    // address of the first instruction in the sequence of\n-    // instructions for this function that will go in the .text\n-    // section of the executable we're generating.\n-    pub llfn: ValueRef,\n-\n-    // A marker for the place where we want to insert the function's static\n-    // allocas, so that LLVM will coalesce them into a single alloca call.\n-    alloca_insert_pt: Option<ValueRef>,\n-\n-    // This function's enclosing crate context.\n-    pub ccx: &'a CrateContext<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n-    /// Create a function context for the given function.\n-    /// Call FunctionContext::get_entry_block for the first entry block.\n-    pub fn new(ccx: &'a CrateContext<'a, 'tcx>, llfndecl: ValueRef) -> FunctionContext<'a, 'tcx> {\n-        let mut fcx = FunctionContext {\n-            llfn: llfndecl,\n-            alloca_insert_pt: None,\n-            ccx: ccx,\n-        };\n-\n-        let entry_bcx = Builder::new_block(fcx.ccx, fcx.llfn, \"entry-block\");\n-        entry_bcx.position_at_start(entry_bcx.llbb());\n-        // Use a dummy instruction as the insertion point for all allocas.\n-        // This is later removed in the drop of FunctionContext.\n-        fcx.alloca_insert_pt = Some(entry_bcx.load(C_null(Type::i8p(ccx))));\n-\n-        fcx\n-    }\n-\n-    pub fn new_block(&self, name: &str) -> BasicBlockRef {\n-        unsafe {\n-            let name = CString::new(name).unwrap();\n-            llvm::LLVMAppendBasicBlockInContext(\n-                self.ccx.llcx(),\n-                self.llfn,\n-                name.as_ptr()\n-            )\n-        }\n-    }\n-\n-    pub fn build_new_block(&self, name: &str) -> Builder<'a, 'tcx> {\n-        Builder::new_block(self.ccx, self.llfn, name)\n-    }\n-\n-    pub fn get_entry_block(&'a self) -> Builder<'a, 'tcx> {\n-        let builder = Builder::with_ccx(self.ccx);\n-        builder.position_at_end(unsafe { llvm::LLVMGetFirstBasicBlock(self.llfn) });\n-        builder\n-    }\n-}\n-\n-impl<'a, 'tcx> Drop for FunctionContext<'a, 'tcx> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            llvm::LLVMInstructionEraseFromParent(self.alloca_insert_pt.unwrap());\n-        }\n-    }\n-}\n-\n /// A structure representing an active landing pad for the duration of a basic\n /// block.\n ///"}, {"sha": "c6f8ba7b6dc78d79c5fdcb2f7955e086c24c1b27", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -14,7 +14,7 @@ use super::utils::{DIB, span_start};\n \n use llvm;\n use llvm::debuginfo::{DIScope, DISubprogram};\n-use common::{CrateContext, FunctionContext};\n+use common::CrateContext;\n use rustc::mir::{Mir, VisibilityScope};\n \n use libc::c_uint;\n@@ -44,7 +44,7 @@ impl MirDebugScope {\n \n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(fcx: &FunctionContext, mir: &Mir, debug_context: &FunctionDebugContext)\n+pub fn create_mir_scopes(ccx: &CrateContext, mir: &Mir, debug_context: &FunctionDebugContext)\n     -> IndexVec<VisibilityScope, MirDebugScope> {\n     let null_scope = MirDebugScope {\n         scope_metadata: ptr::null_mut(),\n@@ -71,7 +71,7 @@ pub fn create_mir_scopes(fcx: &FunctionContext, mir: &Mir, debug_context: &Funct\n     // Instantiate all scopes.\n     for idx in 0..mir.visibility_scopes.len() {\n         let scope = VisibilityScope::new(idx);\n-        make_mir_scope(fcx.ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n+        make_mir_scope(ccx, &mir, &has_variables, fn_metadata, scope, &mut scopes);\n     }\n \n     scopes"}, {"sha": "7a739071506dbe2f3b1c933d92dd4d4ef96f6b70", "filename": "src/librustc_trans/debuginfo/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fdoc.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -45,7 +45,7 @@\n //!\n //! All private state used by the module is stored within either the\n //! CrateDebugContext struct (owned by the CrateContext) or the\n-//! FunctionDebugContext (owned by the FunctionContext).\n+//! FunctionDebugContext (owned by the MirContext).\n //!\n //! This file consists of three conceptual sections:\n //! 1. The public interface of the module"}, {"sha": "d055e33919d1037c185f00ed98f5333ed1007b44", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -25,6 +25,7 @@ use rustc::ty::subst::Kind;\n use adt::{self, MaybeSizedValue};\n use base::*;\n use callee::Callee;\n+use cleanup::CleanupScope;\n use common::*;\n use machine::*;\n use monomorphize;\n@@ -34,7 +35,6 @@ use type_of::{type_of, sizing_type_of, align_of};\n use type_::Type;\n use value::Value;\n use Disr;\n-use cleanup::CleanupScope;\n use builder::Builder;\n \n use syntax_pos::DUMMY_SP;\n@@ -174,8 +174,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n     assert_eq!(g.ty(), get_drop_glue_type(ccx.shared(), g.ty()));\n     let (llfn, _) = ccx.drop_glues().borrow().get(&g).unwrap().clone();\n \n-    let fcx = FunctionContext::new(ccx, llfn);\n-    let mut bcx = fcx.get_entry_block();\n+    let mut bcx = Builder::entry_block(ccx, llfn);\n \n     ccx.stats().n_glues_created.set(ccx.stats().n_glues_created.get() + 1);\n     // All glue functions take values passed *by alias*; this is a\n@@ -246,7 +245,7 @@ pub fn implement_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, g: DropGlueKi\n             // Issue #23611: schedule cleanup of contents, re-inspecting the\n             // discriminant (if any) in case of variant swap in drop code.\n             let contents_scope = if !shallow_drop {\n-                fcx.schedule_drop_adt_contents(&bcx, ptr, t)\n+                CleanupScope::schedule_drop_adt_contents(&bcx, ptr, t)\n             } else {\n                 CleanupScope::noop()\n             };"}, {"sha": "7d094b89a059b02e5d615c354fded1337ac7cff3", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -89,7 +89,6 @@ fn get_simple_intrinsic(ccx: &CrateContext, name: &str) -> Option<ValueRef> {\n /// and in libcore/intrinsics.rs; if you need access to any llvm intrinsics,\n /// add them to librustc_trans/trans/context.rs\n pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                                      fcx: &FunctionContext,\n                                       callee_ty: Ty<'tcx>,\n                                       fn_ty: &FnType,\n                                       llargs: &[ValueRef],\n@@ -127,7 +126,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             bcx.call(expect, &[llargs[0], C_bool(ccx, false)], None)\n         }\n         \"try\" => {\n-            try_intrinsic(bcx, fcx, llargs[0], llargs[1], llargs[2], llresult);\n+            try_intrinsic(bcx, ccx, llargs[0], llargs[1], llargs[2], llresult);\n             C_nil(ccx)\n         }\n         \"breakpoint\" => {\n@@ -689,7 +688,7 @@ fn memset_intrinsic<'a, 'tcx>(\n \n fn try_intrinsic<'a, 'tcx>(\n     bcx: &Builder<'a, 'tcx>,\n-    fcx: &FunctionContext,\n+    ccx: &CrateContext,\n     func: ValueRef,\n     data: ValueRef,\n     local_ptr: ValueRef,\n@@ -701,7 +700,7 @@ fn try_intrinsic<'a, 'tcx>(\n     } else if wants_msvc_seh(bcx.sess()) {\n         trans_msvc_try(bcx, fcx, func, data, local_ptr, dest);\n     } else {\n-        trans_gnu_try(bcx, fcx, func, data, local_ptr, dest);\n+        trans_gnu_try(bcx, ccx, func, data, local_ptr, dest);\n     }\n }\n \n@@ -713,12 +712,12 @@ fn try_intrinsic<'a, 'tcx>(\n // writing, however, LLVM does not recommend the usage of these new instructions\n // as the old ones are still more optimized.\n fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                            fcx: &FunctionContext,\n+                            ccx: &CrateContext,\n                             func: ValueRef,\n                             data: ValueRef,\n                             local_ptr: ValueRef,\n                             dest: ValueRef) {\n-    let llfn = get_rust_try_fn(fcx, &mut |bcx| {\n+    let llfn = get_rust_try_fn(ccx, &mut |bcx| {\n         let ccx = bcx.ccx;\n \n         bcx.set_personality_fn(bcx.ccx.eh_personality());\n@@ -817,12 +816,12 @@ fn trans_msvc_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n // functions in play. By calling a shim we're guaranteed that our shim will have\n // the right personality function.\n fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n-                           fcx: &FunctionContext,\n+                           ccx: &CrateContext,\n                            func: ValueRef,\n                            data: ValueRef,\n                            local_ptr: ValueRef,\n                            dest: ValueRef) {\n-    let llfn = get_rust_try_fn(fcx, &mut |bcx| {\n+    let llfn = get_rust_try_fn(ccx, &mut |bcx| {\n         let ccx = bcx.ccx;\n \n         // Translates the shims described above:\n@@ -874,13 +873,12 @@ fn trans_gnu_try<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n // Helper function to give a Block to a closure to translate a shim function.\n // This is currently primarily used for the `try` intrinsic functions above.\n-fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+fn gen_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n                     output: Ty<'tcx>,\n                     trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n-    let ccx = fcx.ccx;\n     let sig = ccx.tcx().mk_fn_sig(inputs.into_iter(), output, false);\n \n     let rust_fn_ty = ccx.tcx().mk_fn_ptr(ccx.tcx().mk_bare_fn(ty::BareFnTy {\n@@ -889,19 +887,18 @@ fn gen_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(sig)\n     }));\n     let llfn = declare::define_internal_fn(ccx, name, rust_fn_ty);\n-    let fcx = FunctionContext::new(ccx, llfn);\n-    trans(fcx.get_entry_block());\n+    let bcx = Builder::entry_block(ccx, llfn);\n+    trans(bcx);\n     llfn\n }\n \n // Helper function used to get a handle to the `__rust_try` function used to\n // catch exceptions.\n //\n // This function is only generated once and is then cached.\n-fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n+fn get_rust_try_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                              trans: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n                              -> ValueRef {\n-    let ccx = fcx.ccx;\n     if let Some(llfn) = ccx.rust_try_fn().get() {\n         return llfn;\n     }\n@@ -915,7 +912,7 @@ fn get_rust_try_fn<'a, 'tcx>(fcx: &FunctionContext<'a, 'tcx>,\n         sig: ty::Binder(tcx.mk_fn_sig(iter::once(i8p), tcx.mk_nil(), false)),\n     }));\n     let output = tcx.types.i32;\n-    let rust_try = gen_fn(fcx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n+    let rust_try = gen_fn(ccx, \"__rust_try\", vec![fn_ty, i8p, i8p], output, trans);\n     ccx.rust_try_fn().set(Some(rust_try));\n     return rust_try\n }"}, {"sha": "e83b79f11f4dcd09ade6274016eca2808966c860", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -76,10 +76,9 @@ pub fn trans_object_shim<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n     let llfn = declare::define_internal_fn(ccx, &function_name, callee.ty);\n     attributes::set_frame_pointer_elimination(ccx, llfn);\n \n-    let fcx = FunctionContext::new(ccx, llfn);\n-    let bcx = fcx.get_entry_block();\n+    let bcx = Builder::entry_block(ccx, llfn);\n \n-    let mut llargs = get_params(fcx.llfn);\n+    let mut llargs = get_params(llfn);\n     let fn_ret = callee.ty.fn_ret();\n     let fn_ty = callee.direct_fn_type(ccx, &[]);\n "}, {"sha": "7f720f723b8d92196cd9782ab54dbca4cb6bdcef", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -302,7 +302,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Create the failure block and the conditional branch to it.\n                 let lltarget = llblock(self, &bcx, target);\n-                let panic_block = self.fcx.build_new_block(\"panic\");\n+                let panic_block = bcx.build_new_block(\"panic\");\n                 if expected {\n                     bcx.cond_br(cond, lltarget, panic_block.llbb());\n                 } else {\n@@ -546,7 +546,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 bug!(\"Cannot use direct operand with an intrinsic call\")\n                         };\n \n-                        trans_intrinsic_call(&bcx, self.fcx, callee.ty, &fn_ty, &llargs, dest,\n+                        trans_intrinsic_call(&bcx, callee.ty, &fn_ty, &llargs, dest,\n                             terminator.source_info.span);\n \n                         if let ReturnDest::IndirectOperand(dst, _) = ret_dest {\n@@ -793,13 +793,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         let target = self.build_block(target_bb);\n \n-        let bcx = self.fcx.build_new_block(\"cleanup\");\n+        let bcx = target.build_new_block(\"cleanup\");\n         self.landing_pads[target_bb] = Some(bcx.llbb());\n \n         let ccx = bcx.ccx;\n         let llpersonality = self.ccx.eh_personality();\n         let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-        let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.fcx.llfn);\n+        let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.llfn);\n         bcx.set_cleanup(llretval);\n         let slot = self.get_personality_slot(&bcx);\n         bcx.store(llretval, slot, None);\n@@ -809,15 +809,15 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n     fn unreachable_block(&mut self) -> BasicBlockRef {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let bl = self.fcx.build_new_block(\"unreachable\");\n+            let bl = self.build_block(mir::START_BLOCK).build_new_block(\"unreachable\");\n             bl.unreachable();\n             self.unreachable_block = Some(bl.llbb());\n             bl.llbb()\n         })\n     }\n \n     pub fn build_block(&self, bb: mir::BasicBlock) -> Builder<'a, 'tcx> {\n-        let builder = Builder::with_ccx(self.fcx.ccx);\n+        let builder = Builder::with_ccx(self.ccx);\n         builder.position_at_end(self.blocks[bb]);\n         builder\n     }"}, {"sha": "b7b3663b85a383c8cd087787383efda38f6c3496", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=937e8da349e60d8e56e1ebb3f03a3e394bf3c9eb", "patch": "@@ -20,7 +20,7 @@ use rustc::ty::TypeFoldable;\n use session::config::FullDebugInfo;\n use base;\n use builder::Builder;\n-use common::{self, CrateContext, FunctionContext, C_null, Funclet};\n+use common::{self, CrateContext, C_null, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::{self, Instance};\n use abi::FnType;\n@@ -31,6 +31,7 @@ use syntax::symbol::keywords;\n use syntax::abi::Abi;\n \n use std::iter;\n+use std::ffi::CString;\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -49,7 +50,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n     debug_context: debuginfo::FunctionDebugContext,\n \n-    fcx: &'a common::FunctionContext<'a, 'tcx>,\n+    llfn: ValueRef,\n \n     ccx: &'a CrateContext<'a, 'tcx>,\n \n@@ -199,7 +200,8 @@ impl<'tcx> LocalRef<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'a, 'tcx: 'a>(\n-    fcx: &'a FunctionContext<'a, 'tcx>,\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    llfn: ValueRef,\n     fn_ty: FnType,\n     mir: &'a Mir<'tcx>,\n     instance: Instance<'tcx>,\n@@ -208,29 +210,36 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n ) {\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n-        debuginfo::create_function_debug_context(fcx.ccx, instance, sig, abi, fcx.llfn, mir);\n-    let bcx = fcx.get_entry_block();\n+        debuginfo::create_function_debug_context(ccx, instance, sig, abi, llfn, mir);\n+    let bcx = Builder::entry_block(ccx, llfn);\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: IndexVec<mir::BasicBlock, BasicBlockRef> =\n         mir.basic_blocks().indices().map(|bb| {\n-            if bb == mir::START_BLOCK {\n-                fcx.new_block(\"start\")\n+            let name = if bb == mir::START_BLOCK {\n+                CString::new(\"start\").unwrap()\n             } else {\n-                fcx.new_block(&format!(\"{:?}\", bb))\n+                CString::new(format!(\"{:?}\", bb)).unwrap()\n+            };\n+            unsafe {\n+                llvm::LLVMAppendBasicBlockInContext(\n+                    ccx.llcx(),\n+                    llfn,\n+                    name.as_ptr()\n+                )\n             }\n         }).collect();\n \n     // Compute debuginfo scopes from MIR scopes.\n-    let scopes = debuginfo::create_mir_scopes(fcx, mir, &debug_context);\n+    let scopes = debuginfo::create_mir_scopes(ccx, mir, &debug_context);\n \n     let mut mircx = MirContext {\n         mir: mir,\n-        fcx: fcx,\n+        llfn: llfn,\n         fn_ty: fn_ty,\n-        ccx: fcx.ccx,\n+        ccx: ccx,\n         llpersonalityslot: None,\n         blocks: block_bcxs,\n         unreachable_block: None,\n@@ -281,7 +290,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n                 // Temporary or return pointer\n                 if local == mir::RETURN_POINTER && mircx.fn_ty.ret.is_indirect() {\n                     debug!(\"alloc: {:?} (return pointer) -> lvalue\", local);\n-                    let llretptr = llvm::get_param(fcx.llfn, 0);\n+                    let llretptr = llvm::get_param(llfn, 0);\n                     LocalRef::Lvalue(LvalueRef::new_sized(llretptr, LvalueTy::from_ty(ty)))\n                 } else if lvalue_locals.contains(local.index()) {\n                     debug!(\"alloc: {:?} -> lvalue\", local);\n@@ -319,7 +328,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n         if let CleanupKind::Funclet = *cleanup_kind {\n             let bcx = mircx.build_block(bb);\n             bcx.set_personality_fn(mircx.ccx.eh_personality());\n-            if base::wants_msvc_seh(fcx.ccx.sess()) {\n+            if base::wants_msvc_seh(ccx.sess()) {\n                 return Some(Funclet::new(bcx.cleanup_pad(None, &[])));\n             }\n         }\n@@ -358,7 +367,6 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             lvalue_locals: &BitVector)\n                             -> Vec<LocalRef<'tcx>> {\n     let mir = mircx.mir;\n-    let fcx = mircx.fcx;\n     let tcx = bcx.ccx.tcx();\n     let mut idx = 0;\n     let mut llarg_idx = mircx.fn_ty.ret.is_indirect() as usize;\n@@ -433,7 +441,7 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             if arg.pad.is_some() {\n                 llarg_idx += 1;\n             }\n-            let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n             llarg\n         } else if !lvalue_locals.contains(local.index()) &&\n@@ -449,13 +457,13 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             if arg.pad.is_some() {\n                 llarg_idx += 1;\n             }\n-            let llarg = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+            let llarg = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n             llarg_idx += 1;\n             let val = if common::type_is_fat_ptr(bcx.ccx, arg_ty) {\n                 let meta = &mircx.fn_ty.args[idx];\n                 idx += 1;\n                 assert_eq!((meta.cast, meta.pad), (None, None));\n-                let llmeta = llvm::get_param(fcx.llfn, llarg_idx as c_uint);\n+                let llmeta = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n                 llarg_idx += 1;\n                 OperandValue::Pair(llarg, llmeta)\n             } else {"}]}