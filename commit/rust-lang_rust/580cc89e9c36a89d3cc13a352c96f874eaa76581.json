{"sha": "580cc89e9c36a89d3cc13a352c96f874eaa76581", "node_id": "C_kwDOAAsO6NoAKDU4MGNjODllOWMzNmE4OWQzY2MxM2EzNTJjOTZmODc0ZWFhNzY1ODE", "commit": {"author": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-02-05T02:39:18Z"}, "committer": {"name": "est31", "email": "MTest31@outlook.com", "date": "2023-02-05T03:01:20Z"}, "message": "rustc_session: remove huge error imports", "tree": {"sha": "a1fa548def1baf945cd58caa0afd7a0eec7e5646", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1fa548def1baf945cd58caa0afd7a0eec7e5646"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/580cc89e9c36a89d3cc13a352c96f874eaa76581", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/580cc89e9c36a89d3cc13a352c96f874eaa76581", "html_url": "https://github.com/rust-lang/rust/commit/580cc89e9c36a89d3cc13a352c96f874eaa76581", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/580cc89e9c36a89d3cc13a352c96f874eaa76581/comments", "author": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "committer": {"login": "est31", "id": 8872119, "node_id": "MDQ6VXNlcjg4NzIxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/8872119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/est31", "html_url": "https://github.com/est31", "followers_url": "https://api.github.com/users/est31/followers", "following_url": "https://api.github.com/users/est31/following{/other_user}", "gists_url": "https://api.github.com/users/est31/gists{/gist_id}", "starred_url": "https://api.github.com/users/est31/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/est31/subscriptions", "organizations_url": "https://api.github.com/users/est31/orgs", "repos_url": "https://api.github.com/users/est31/repos", "events_url": "https://api.github.com/users/est31/events{/privacy}", "received_events_url": "https://api.github.com/users/est31/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "394fa192a94bf6fed793ac3f8ceacc7d35b55319", "url": "https://api.github.com/repos/rust-lang/rust/commits/394fa192a94bf6fed793ac3f8ceacc7d35b55319", "html_url": "https://github.com/rust-lang/rust/commit/394fa192a94bf6fed793ac3f8ceacc7d35b55319"}], "stats": {"total": 52, "additions": 23, "deletions": 29}, "files": [{"sha": "8a0176f6391743adb6a17ccf30a3fc49223b92b3", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/580cc89e9c36a89d3cc13a352c96f874eaa76581/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/580cc89e9c36a89d3cc13a352c96f874eaa76581/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=580cc89e9c36a89d3cc13a352c96f874eaa76581", "patch": "@@ -3,15 +3,7 @@ use crate::code_stats::CodeStats;\n pub use crate::code_stats::{DataTypeKind, FieldInfo, FieldKind, SizeKind, VariantInfo};\n use crate::config::Input;\n use crate::config::{self, CrateType, InstrumentCoverage, OptLevel, OutputType, SwitchWithOptPath};\n-use crate::errors::{\n-    BranchProtectionRequiresAArch64, CannotEnableCrtStaticLinux, CannotMixAndMatchSanitizers,\n-    LinkerPluginToWindowsNotSupported, NotCircumventFeature, OptimisationFuelExhausted,\n-    ProfileSampleUseFileDoesNotExist, ProfileUseFileDoesNotExist, SanitizerCfiEnabled,\n-    SanitizerNotSupported, SanitizersNotSupported, SkippingConstChecks,\n-    SplitDebugInfoUnstablePlatform, StackProtectorNotSupportedForTarget,\n-    TargetRequiresUnwindTables, UnleashedFeatureHelp, UnstableVirtualFunctionElimination,\n-    UnsupportedDwarfVersion,\n-};\n+use crate::errors;\n use crate::parse::{add_feature_diagnostics, ParseSess};\n use crate::search_paths::{PathKind, SearchPath};\n use crate::{filesearch, lint};\n@@ -246,23 +238,23 @@ impl Session {\n         if !unleashed_features.is_empty() {\n             let mut must_err = false;\n             // Create a diagnostic pointing at where things got unleashed.\n-            self.emit_warning(SkippingConstChecks {\n+            self.emit_warning(errors::SkippingConstChecks {\n                 unleashed_features: unleashed_features\n                     .iter()\n                     .map(|(span, gate)| {\n                         gate.map(|gate| {\n                             must_err = true;\n-                            UnleashedFeatureHelp::Named { span: *span, gate }\n+                            errors::UnleashedFeatureHelp::Named { span: *span, gate }\n                         })\n-                        .unwrap_or(UnleashedFeatureHelp::Unnamed { span: *span })\n+                        .unwrap_or(errors::UnleashedFeatureHelp::Unnamed { span: *span })\n                     })\n                     .collect(),\n             });\n \n             // If we should err, make sure we did.\n             if must_err && self.has_errors().is_none() {\n                 // We have skipped a feature gate, and not run into other errors... reject.\n-                self.emit_err(NotCircumventFeature);\n+                self.emit_err(errors::NotCircumventFeature);\n             }\n         }\n     }\n@@ -901,7 +893,7 @@ impl Session {\n                         // We only call `msg` in case we can actually emit warnings.\n                         // Otherwise, this could cause a `delay_good_path_bug` to\n                         // trigger (issue #79546).\n-                        self.emit_warning(OptimisationFuelExhausted { msg: msg() });\n+                        self.emit_warning(errors::OptimisationFuelExhausted { msg: msg() });\n                     }\n                     fuel.out_of_fuel = true;\n                 } else if fuel.remaining > 0 {\n@@ -1502,28 +1494,28 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         && sess.opts.cg.prefer_dynamic\n         && sess.target.is_like_windows\n     {\n-        sess.emit_err(LinkerPluginToWindowsNotSupported);\n+        sess.emit_err(errors::LinkerPluginToWindowsNotSupported);\n     }\n \n     // Make sure that any given profiling data actually exists so LLVM can't\n     // decide to silently skip PGO.\n     if let Some(ref path) = sess.opts.cg.profile_use {\n         if !path.exists() {\n-            sess.emit_err(ProfileUseFileDoesNotExist { path });\n+            sess.emit_err(errors::ProfileUseFileDoesNotExist { path });\n         }\n     }\n \n     // Do the same for sample profile data.\n     if let Some(ref path) = sess.opts.unstable_opts.profile_sample_use {\n         if !path.exists() {\n-            sess.emit_err(ProfileSampleUseFileDoesNotExist { path });\n+            sess.emit_err(errors::ProfileSampleUseFileDoesNotExist { path });\n         }\n     }\n \n     // Unwind tables cannot be disabled if the target requires them.\n     if let Some(include_uwtables) = sess.opts.cg.force_unwind_tables {\n         if sess.target.requires_uwtable && !include_uwtables {\n-            sess.emit_err(TargetRequiresUnwindTables);\n+            sess.emit_err(errors::TargetRequiresUnwindTables);\n         }\n     }\n \n@@ -1533,67 +1525,69 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n     match unsupported_sanitizers.into_iter().count() {\n         0 => {}\n         1 => {\n-            sess.emit_err(SanitizerNotSupported { us: unsupported_sanitizers.to_string() });\n+            sess.emit_err(errors::SanitizerNotSupported { us: unsupported_sanitizers.to_string() });\n         }\n         _ => {\n-            sess.emit_err(SanitizersNotSupported { us: unsupported_sanitizers.to_string() });\n+            sess.emit_err(errors::SanitizersNotSupported {\n+                us: unsupported_sanitizers.to_string(),\n+            });\n         }\n     }\n     // Cannot mix and match sanitizers.\n     let mut sanitizer_iter = sess.opts.unstable_opts.sanitizer.into_iter();\n     if let (Some(first), Some(second)) = (sanitizer_iter.next(), sanitizer_iter.next()) {\n-        sess.emit_err(CannotMixAndMatchSanitizers {\n+        sess.emit_err(errors::CannotMixAndMatchSanitizers {\n             first: first.to_string(),\n             second: second.to_string(),\n         });\n     }\n \n     // Cannot enable crt-static with sanitizers on Linux\n     if sess.crt_static(None) && !sess.opts.unstable_opts.sanitizer.is_empty() {\n-        sess.emit_err(CannotEnableCrtStaticLinux);\n+        sess.emit_err(errors::CannotEnableCrtStaticLinux);\n     }\n \n     // LLVM CFI and VFE both require LTO.\n     if sess.lto() != config::Lto::Fat {\n         if sess.is_sanitizer_cfi_enabled() {\n-            sess.emit_err(SanitizerCfiEnabled);\n+            sess.emit_err(errors::SanitizerCfiEnabled);\n         }\n         if sess.opts.unstable_opts.virtual_function_elimination {\n-            sess.emit_err(UnstableVirtualFunctionElimination);\n+            sess.emit_err(errors::UnstableVirtualFunctionElimination);\n         }\n     }\n \n     // LLVM CFI and KCFI are mutually exclusive\n     if sess.is_sanitizer_cfi_enabled() && sess.is_sanitizer_kcfi_enabled() {\n-        sess.emit_err(CannotMixAndMatchSanitizers {\n+        sess.emit_err(errors::CannotMixAndMatchSanitizers {\n             first: \"cfi\".to_string(),\n             second: \"kcfi\".to_string(),\n         });\n     }\n \n     if sess.opts.unstable_opts.stack_protector != StackProtector::None {\n         if !sess.target.options.supports_stack_protector {\n-            sess.emit_warning(StackProtectorNotSupportedForTarget {\n+            sess.emit_warning(errors::StackProtectorNotSupportedForTarget {\n                 stack_protector: sess.opts.unstable_opts.stack_protector,\n                 target_triple: &sess.opts.target_triple,\n             });\n         }\n     }\n \n     if sess.opts.unstable_opts.branch_protection.is_some() && sess.target.arch != \"aarch64\" {\n-        sess.emit_err(BranchProtectionRequiresAArch64);\n+        sess.emit_err(errors::BranchProtectionRequiresAArch64);\n     }\n \n     if let Some(dwarf_version) = sess.opts.unstable_opts.dwarf_version {\n         if dwarf_version > 5 {\n-            sess.emit_err(UnsupportedDwarfVersion { dwarf_version });\n+            sess.emit_err(errors::UnsupportedDwarfVersion { dwarf_version });\n         }\n     }\n \n     if !sess.target.options.supported_split_debuginfo.contains(&sess.split_debuginfo())\n         && !sess.opts.unstable_opts.unstable_options\n     {\n-        sess.emit_err(SplitDebugInfoUnstablePlatform { debuginfo: sess.split_debuginfo() });\n+        sess.emit_err(errors::SplitDebugInfoUnstablePlatform { debuginfo: sess.split_debuginfo() });\n     }\n }\n "}]}