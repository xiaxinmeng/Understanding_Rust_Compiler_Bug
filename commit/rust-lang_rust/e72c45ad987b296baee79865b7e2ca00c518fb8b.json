{"sha": "e72c45ad987b296baee79865b7e2ca00c518fb8b", "node_id": "C_kwDOAAsO6NoAKGU3MmM0NWFkOTg3YjI5NmJhZWU3OTg2NWI3ZTJjYTAwYzUxOGZiOGI", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-02T23:23:07Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-04-12T23:20:11Z"}, "message": "Point at which arg causes a binding to be constrained", "tree": {"sha": "09bde63c17260638b296b32bc69f76ff9a866718", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09bde63c17260638b296b32bc69f76ff9a866718"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e72c45ad987b296baee79865b7e2ca00c518fb8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e72c45ad987b296baee79865b7e2ca00c518fb8b", "html_url": "https://github.com/rust-lang/rust/commit/e72c45ad987b296baee79865b7e2ca00c518fb8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e72c45ad987b296baee79865b7e2ca00c518fb8b/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "url": "https://api.github.com/repos/rust-lang/rust/commits/42c4373ad11a86d3028ddfe29d7f33edc9670ba8", "html_url": "https://github.com/rust-lang/rust/commit/42c4373ad11a86d3028ddfe29d7f33edc9670ba8"}], "stats": {"total": 69, "additions": 56, "deletions": 13}, "files": [{"sha": "0d3e4bde497f80a87f5f074295789885977ba7ea", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e72c45ad987b296baee79865b7e2ca00c518fb8b/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e72c45ad987b296baee79865b7e2ca00c518fb8b/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=e72c45ad987b296baee79865b7e2ca00c518fb8b", "patch": "@@ -259,10 +259,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             hir.body(hir.maybe_body_owned_by(self.body_id).expect(\"expected item to have body\"));\n         expr_finder.visit_expr(body.value);\n \n-        let fudge_equals_found_ty = |use_ty: Ty<'tcx>| {\n+        let fudge_ty = |ty: Ty<'tcx>| {\n             use rustc_infer::infer::type_variable::*;\n             use rustc_middle::infer::unify_key::*;\n-            let use_ty = use_ty.fold_with(&mut BottomUpFolder {\n+            ty.fold_with(&mut BottomUpFolder {\n                 tcx: self.tcx,\n                 ty_op: |ty| {\n                     if let ty::Infer(infer) = ty.kind() {\n@@ -293,7 +293,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ct\n                     }\n                 },\n-            });\n+            })\n+        };\n+\n+        let fudge_equals_found_ty = |use_ty: Ty<'tcx>| {\n+            let use_ty = fudge_ty(use_ty);\n             self.can_eq(self.param_env, expected_ty, use_ty)\n         };\n \n@@ -303,18 +307,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         for window in expr_finder.uses.windows(2) {\n             let [binding, next_usage] = *window else { continue; };\n+\n+            // Don't go past the binding (always gonna be a nonsense label if so)\n+            if binding.hir_id == expr.hir_id {\n+                break;\n+            }\n+\n             let Some(next_use_ty) = self.node_ty_opt(next_usage.hir_id) else { continue; };\n-            if !fudge_equals_found_ty(next_use_ty) {\n-                err.span_label(\n-                    binding.span,\n-                    format!(\"here the type of `{ident}` is inferred to be `{next_use_ty}`\"),\n-                );\n-                return true;\n+\n+            // If the type is not constrained in a way making it not possible to\n+            // equate with `expected_ty` by this point, skip.\n+            if fudge_equals_found_ty(next_use_ty) {\n+                continue;\n             }\n \n-            if next_usage.hir_id == expr.hir_id {\n-                break;\n+            if let hir::Node::Expr(parent_expr) = hir.get_parent(binding.hir_id)\n+                && let hir::ExprKind::MethodCall(segment, rcvr, args, _) = parent_expr.kind\n+                && rcvr.hir_id == binding.hir_id\n+            {\n+                let Some(rcvr_ty) = self.node_ty_opt(rcvr.hir_id) else { continue; };\n+                let rcvr_ty = fudge_ty(rcvr_ty);\n+                if let Ok(method) =\n+                    self.lookup_method(rcvr_ty, segment, DUMMY_SP, parent_expr, rcvr, args)\n+                {\n+                    for (expected_arg_ty, arg_expr) in std::iter::zip(&method.sig.inputs()[1..], args) {\n+                        let Some(arg_ty) = self.node_ty_opt(arg_expr.hir_id) else { continue; };\n+                        let arg_ty = fudge_ty(arg_ty);\n+                        let _ = self.try_coerce(arg_expr, arg_ty, *expected_arg_ty, AllowTwoPhase::No, None);\n+                        if !self.can_eq(self.param_env, rcvr_ty, expected_ty) {\n+                            err.span_label(\n+                                arg_expr.span,\n+                                format!(\"this argument has type `{arg_ty}`...\")\n+                            );\n+                            err.span_label(\n+                                binding.span,\n+                                format!(\"... which constrains `{ident}` to have type `{next_use_ty}`\")\n+                            );\n+                            return true;\n+                        }\n+                    }\n+                }\n             }\n+\n+            err.span_label(\n+                binding.span,\n+                format!(\"here the type of `{ident}` is inferred to be `{next_use_ty}`\"),\n+            );\n+            return true;\n         }\n \n         // We must've not found something that constrained the expr."}, {"sha": "5d46368b1fd38052acbd5dfb0e3554abe7fcc042", "filename": "tests/ui/type/type-check/point-at-inference.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e72c45ad987b296baee79865b7e2ca00c518fb8b/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e72c45ad987b296baee79865b7e2ca00c518fb8b/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference.stderr?ref=e72c45ad987b296baee79865b7e2ca00c518fb8b", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/point-at-inference.rs:12:9\n    |\n LL |         foo.push(i);\n-   |         --- here the type of `foo` is inferred to be `Vec<&{integer}>`\n+   |         ---      - this argument has type `&{integer}`...\n+   |         |\n+   |         ... which causes `foo` to have type `Vec<&{integer}>`\n ...\n LL |     bar(foo);\n    |     --- ^^^ expected `Vec<i32>`, found `Vec<&{integer}>`"}, {"sha": "b97e74b7e53fa22d08189a899a1abfeb1caf01ca", "filename": "tests/ui/typeck/issue-107775.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e72c45ad987b296baee79865b7e2ca00c518fb8b/tests%2Fui%2Ftypeck%2Fissue-107775.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e72c45ad987b296baee79865b7e2ca00c518fb8b/tests%2Fui%2Ftypeck%2Fissue-107775.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fissue-107775.stderr?ref=e72c45ad987b296baee79865b7e2ca00c518fb8b", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-107775.rs:35:16\n    |\n LL |         map.insert(1, Struct::do_something);\n-   |         --- here the type of `map` is inferred to be `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n+   |         ---           -------------------- this argument has type `fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}`...\n+   |         |\n+   |         ... which causes `map` to have type `HashMap<{integer}, fn(u8) -> Pin<Box<dyn Future<Output = ()> + Send>> {<Struct as Trait>::do_something::<'_>}>`\n LL |         Self { map }\n    |                ^^^ expected `HashMap<u16, fn(u8) -> Pin<...>>`, found `HashMap<{integer}, ...>`\n    |"}]}