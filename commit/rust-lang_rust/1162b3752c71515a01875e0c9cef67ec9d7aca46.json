{"sha": "1162b3752c71515a01875e0c9cef67ec9d7aca46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNjJiMzc1MmM3MTUxNWEwMTg3NWUwYzljZWY2N2VjOWQ3YWNhNDY=", "commit": {"author": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2015-10-13T13:44:11Z"}, "committer": {"name": "Andrew Paseltiner", "email": "apaseltiner@gmail.com", "date": "2015-10-13T13:44:11Z"}, "message": "Correct spelling in docs", "tree": {"sha": "6989970e8058e01b0bd7f73dc490223dfa6a62a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6989970e8058e01b0bd7f73dc490223dfa6a62a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1162b3752c71515a01875e0c9cef67ec9d7aca46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1162b3752c71515a01875e0c9cef67ec9d7aca46", "html_url": "https://github.com/rust-lang/rust/commit/1162b3752c71515a01875e0c9cef67ec9d7aca46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1162b3752c71515a01875e0c9cef67ec9d7aca46/comments", "author": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apasel422", "id": 8644784, "node_id": "MDQ6VXNlcjg2NDQ3ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/8644784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apasel422", "html_url": "https://github.com/apasel422", "followers_url": "https://api.github.com/users/apasel422/followers", "following_url": "https://api.github.com/users/apasel422/following{/other_user}", "gists_url": "https://api.github.com/users/apasel422/gists{/gist_id}", "starred_url": "https://api.github.com/users/apasel422/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apasel422/subscriptions", "organizations_url": "https://api.github.com/users/apasel422/orgs", "repos_url": "https://api.github.com/users/apasel422/repos", "events_url": "https://api.github.com/users/apasel422/events{/privacy}", "received_events_url": "https://api.github.com/users/apasel422/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec4362da562a4b591a7d120c6677e14ea713481a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec4362da562a4b591a7d120c6677e14ea713481a", "html_url": "https://github.com/rust-lang/rust/commit/ec4362da562a4b591a7d120c6677e14ea713481a"}], "stats": {"total": 164, "additions": 82, "deletions": 82}, "files": [{"sha": "e2a957e396191150bda46f9610b0a9a44d8f9714", "filename": "COMPILER_TESTS.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/COMPILER_TESTS.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/COMPILER_TESTS.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COMPILER_TESTS.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -1,6 +1,6 @@\n # Compiler Test Documentation\n \n-In the Rust project, we use a special set of comands embedded in\n+In the Rust project, we use a special set of commands embedded in\n comments to test the Rust compiler. There are two groups of commands:\n \n 1. Header commands"}, {"sha": "05c17606ce0342f705cfe52c36dd24d7cfa075f8", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -76,7 +76,7 @@ Cleanup through RAII-style destructors is more likely to work than in catch bloc\n \n ## Why aren't modules type-parametric?\n \n-We want to maintain the option to parametrize at runtime. We may eventually change this limitation, but initially this is how type parameters were implemented.\n+We want to maintain the option to parameterize at runtime. We may eventually change this limitation, but initially this is how type parameters were implemented.\n \n ## Why aren't values type-parametric? Why only items?\n "}, {"sha": "6cc41bd9533c76f6ed51157a57b57c484daa106c", "filename": "src/doc/nomicon/casts.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fcasts.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fcasts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fcasts.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -52,7 +52,7 @@ For numeric casts, there are quite a few cases to consider:\n     * zero-extend if the source is unsigned\n     * sign-extend if the source is signed\n * casting from a float to an integer will round the float towards zero\n-    * **[NOTE: currently this will cause Undefined Behaviour if the rounded\n+    * **[NOTE: currently this will cause Undefined Behavior if the rounded\n       value cannot be represented by the target integer type][float-int]**.\n       This includes Inf and NaN. This is a bug and will be fixed.\n * casting from an integer to float will produce the floating point\n@@ -61,7 +61,7 @@ For numeric casts, there are quite a few cases to consider:\n * casting from an f32 to an f64 is perfect and lossless\n * casting from an f64 to an f32 will produce the closest possible value\n   (rounding strategy unspecified)\n-    * **[NOTE: currently this will cause Undefined Behaviour if the value\n+    * **[NOTE: currently this will cause Undefined Behavior if the value\n       is finite but larger or smaller than the largest or smallest finite\n       value representable by f32][float-float]**. This is a bug and will\n       be fixed."}, {"sha": "95bcdc02ba0292da5b0522e09efb66657bfb2b0f", "filename": "src/doc/nomicon/dropck.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fdropck.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fdropck.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fdropck.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -6,7 +6,7 @@ interacted with the *outlives* relationship in an inclusive manner. That is,\n when we talked about `'a: 'b`, it was ok for `'a` to live *exactly* as long as\n `'b`. At first glance, this seems to be a meaningless distinction. Nothing ever\n gets dropped at the same time as another, right? This is why we used the\n-following desugarring of `let` statements:\n+following desugaring of `let` statements:\n \n ```rust,ignore\n let x;"}, {"sha": "052e3c5fddc551ac81be5791c049ea302fff5d58", "filename": "src/doc/nomicon/exotic-sizes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fexotic-sizes.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fexotic-sizes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fexotic-sizes.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -20,7 +20,7 @@ information that \"completes\" them (more on this below).\n There are two major DSTs exposed by the language: trait objects, and slices.\n \n A trait object represents some type that implements the traits it specifies.\n-The exact original type is *erased* in favour of runtime reflection\n+The exact original type is *erased* in favor of runtime reflection\n with a vtable containing all the information necessary to use the type.\n This is the information that completes a trait object: a pointer to its vtable.\n \n@@ -128,7 +128,7 @@ But neither of these tricks work today, so all Void types get you is\n the ability to be confident that certain situations are statically impossible.\n \n One final subtle detail about empty types is that raw pointers to them are\n-actually valid to construct, but dereferencing them is Undefined Behaviour\n+actually valid to construct, but dereferencing them is Undefined Behavior\n because that doesn't actually make sense. That is, you could model C's `void *`\n type with `*const Void`, but this doesn't necessarily gain anything over using\n e.g. `*const ()`, which *is* safe to randomly dereference."}, {"sha": "1f72a4c17247057e92ce65e1512cdafda3d87004", "filename": "src/doc/nomicon/leaking.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fleaking.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fleaking.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fleaking.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -90,7 +90,7 @@ let mut vec = vec![Box::new(0); 4];\n println!(\"{}\", vec[0]);\n ```\n \n-This is pretty clearly Not Good. Unfortunately, we're kind've stuck between a\n+This is pretty clearly Not Good. Unfortunately, we're kind of stuck between a\n rock and a hard place: maintaining consistent state at every step has an\n enormous cost (and would negate any benefits of the API). Failing to maintain\n consistent state gives us Undefined Behavior in safe code (making the API\n@@ -248,4 +248,4 @@ let mut data = Box::new(0);\n ```\n \n Dang. Here the destructor running was pretty fundamental to the API, and it had\n-to be scrapped in favour of a completely different design.\n+to be scrapped in favor of a completely different design."}, {"sha": "978d0518729ea5705e37c19834a41b6337fb0e42", "filename": "src/doc/nomicon/meet-safe-and-unsafe.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fmeet-safe-and-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fmeet-safe-and-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fmeet-safe-and-unsafe.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -26,7 +26,7 @@ do some really crazy unsafe things.\n \n Safe Rust is the *true* Rust programming language. If all you do is write Safe\n Rust, you will never have to worry about type-safety or memory-safety. You will\n-never endure a null or dangling pointer, or any of that Undefined Behaviour\n+never endure a null or dangling pointer, or any of that Undefined Behavior\n nonsense.\n \n *That's totally awesome.*\n@@ -52,11 +52,11 @@ The only things that are different in Unsafe Rust are that you can:\n * Mutate statics\n \n That's it. The reason these operations are relegated to Unsafe is that misusing\n-any of these things will cause the ever dreaded Undefined Behaviour. Invoking\n-Undefined Behaviour gives the compiler full rights to do arbitrarily bad things\n-to your program. You definitely *should not* invoke Undefined Behaviour.\n+any of these things will cause the ever dreaded Undefined Behavior. Invoking\n+Undefined Behavior gives the compiler full rights to do arbitrarily bad things\n+to your program. You definitely *should not* invoke Undefined Behavior.\n \n-Unlike C, Undefined Behaviour is pretty limited in scope in Rust. All the core\n+Unlike C, Undefined Behavior is pretty limited in scope in Rust. All the core\n language cares about is preventing the following things:\n \n * Dereferencing null or dangling pointers\n@@ -71,9 +71,9 @@ language cares about is preventing the following things:\n * Unwinding into another language\n * Causing a [data race][race]\n \n-That's it. That's all the causes of Undefined Behaviour baked into Rust. Of\n+That's it. That's all the causes of Undefined Behavior baked into Rust. Of\n course, unsafe functions and traits are free to declare arbitrary other\n-constraints that a program must maintain to avoid Undefined Behaviour. However,\n+constraints that a program must maintain to avoid Undefined Behavior. However,\n generally violations of these constraints will just transitively lead to one of\n the above problems. Some additional constraints may also derive from compiler\n intrinsics that make special assumptions about how code can be optimized."}, {"sha": "f0732cf26562cf21459a5fc8bcffa574fc5d8386", "filename": "src/doc/nomicon/races.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fraces.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fraces.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fraces.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -6,7 +6,7 @@ Safe Rust guarantees an absence of data races, which are defined as:\n * one of them is a write\n * one of them is unsynchronized\n \n-A data race has Undefined Behaviour, and is therefore impossible to perform\n+A data race has Undefined Behavior, and is therefore impossible to perform\n in Safe Rust. Data races are *mostly* prevented through rust's ownership system:\n it's impossible to alias a mutable reference, so it's impossible to perform a\n data race. Interior mutability makes this more complicated, which is largely why\n@@ -53,7 +53,7 @@ thread::spawn(move || {\n // bounds checked, and there's no chance of the value getting changed\n // in the middle. However our program may panic if the thread we spawned\n // managed to increment before this ran. A race condition because correct\n-// program execution (panicing is rarely correct) depends on order of\n+// program execution (panicking is rarely correct) depends on order of\n // thread execution.\n println!(\"{}\", data[idx.load(Ordering::SeqCst)]);\n ```"}, {"sha": "f5d7023fad5de366e58844e0c5b579276f22baeb", "filename": "src/doc/nomicon/safe-unsafe-meaning.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsafe-unsafe-meaning.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -41,7 +41,7 @@ Some examples of unsafe functions:\n \n * `slice::get_unchecked` will perform unchecked indexing, allowing memory\n   safety to be freely violated.\n-* `ptr::offset` is an intrinsic that invokes Undefined Behaviour if it is\n+* `ptr::offset` is an intrinsic that invokes Undefined Behavior if it is\n   not \"in bounds\" as defined by LLVM.\n * `mem::transmute` reinterprets some value as having the given type,\n   bypassing type safety in arbitrary ways. (see [conversions] for details)\n@@ -59,9 +59,9 @@ As of Rust 1.0 there are exactly two unsafe traits:\n The need for unsafe traits boils down to the fundamental property of safe code:\n \n **No matter how completely awful Safe code is, it can't cause Undefined\n-Behaviour.**\n+Behavior.**\n \n-This means that Unsafe Rust, **the royal vanguard of Undefined Behaviour**, has to be\n+This means that Unsafe Rust, **the royal vanguard of Undefined Behavior**, has to be\n *super paranoid* about generic safe code. To be clear, Unsafe Rust is totally free to trust\n specific safe code. Anything else would degenerate into infinite spirals of\n paranoid despair. In particular it's generally regarded as ok to trust the standard library"}, {"sha": "134e47f18dcf0ccebf041854e4fa1af54460b1aa", "filename": "src/doc/nomicon/send-and-sync.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fsend-and-sync.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -15,7 +15,7 @@ implement, and other unsafe code can assume that they are correctly\n implemented. Since they're *marker traits* (they have no associated items like\n methods), correctly implemented simply means that they have the intrinsic\n properties an implementor should have. Incorrectly implementing Send or Sync can\n-cause Undefined Behaviour.\n+cause Undefined Behavior.\n \n Send and Sync are also automatically derived traits. This means that, unlike\n every other trait, if a type is composed entirely of Send or Sync types, then it"}, {"sha": "f1478b7f668d33e67cd035d0e557d1d991a92431", "filename": "src/doc/nomicon/transmutes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Ftransmutes.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Ftransmutes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Ftransmutes.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -8,7 +8,7 @@ horribly unsafe thing you can do in Rust. The railguards here are dental floss.\n \n `mem::transmute<T, U>` takes a value of type `T` and reinterprets it to have\n type `U`. The only restriction is that the `T` and `U` are verified to have the\n-same size. The ways to cause Undefined Behaviour with this are mind boggling.\n+same size. The ways to cause Undefined Behavior with this are mind boggling.\n \n * First and foremost, creating an instance of *any* type with an invalid state\n   is going to cause arbitrary chaos that can't really be predicted.\n@@ -26,7 +26,7 @@ same size. The ways to cause Undefined Behaviour with this are mind boggling.\n `mem::transmute_copy<T, U>` somehow manages to be *even more* wildly unsafe than\n this. It copies `size_of<U>` bytes out of an `&T` and interprets them as a `U`.\n The size check that `mem::transmute` has is gone (as it may be valid to copy\n-out a prefix), though it is Undefined Behaviour for `U` to be larger than `T`.\n+out a prefix), though it is Undefined Behavior for `U` to be larger than `T`.\n \n Also of course you can get most of the functionality of these functions using\n pointer casts."}, {"sha": "2c5ba79a5078f1820daba439f613085725df0896", "filename": "src/doc/nomicon/unbounded-lifetimes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funbounded-lifetimes.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -2,15 +2,15 @@\n \n Unsafe code can often end up producing references or lifetimes out of thin air.\n Such lifetimes come into the world as *unbounded*. The most common source of this\n-is derefencing a raw pointer, which produces a reference with an unbounded lifetime.\n+is dereferencing a raw pointer, which produces a reference with an unbounded lifetime.\n Such a lifetime becomes as big as context demands. This is in fact more powerful\n than simply becoming `'static`, because for instance `&'static &'a T`\n will fail to typecheck, but the unbound lifetime will perfectly mold into\n `&'a &'a T` as needed. However for most intents and purposes, such an unbounded\n lifetime can be regarded as `'static`.\n \n Almost no reference is `'static`, so this is probably wrong. `transmute` and\n-`transmute_copy` are the two other primary offenders. One should endeavour to\n+`transmute_copy` are the two other primary offenders. One should endeavor to\n bound an unbounded lifetime as quick as possible, especially across function\n boundaries.\n "}, {"sha": "c72ed8a76329982b2582202dbf4d4d1c5b83771f", "filename": "src/doc/nomicon/unchecked-uninit.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funchecked-uninit.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -38,7 +38,7 @@ dropping the old value: `write`, `copy`, and `copy_nonoverlapping`.\n   (this is equivalent to memcpy -- note that the argument order is reversed!)\n \n It should go without saying that these functions, if misused, will cause serious\n-havoc or just straight up Undefined Behaviour. The only things that these\n+havoc or just straight up Undefined Behavior. The only things that these\n functions *themselves* require is that the locations you want to read and write\n are allocated. However the ways writing arbitrary bits to arbitrary\n locations of memory can break things are basically uncountable!"}, {"sha": "05615d89bec77a530522a4e227bb0ea5309d92ee", "filename": "src/doc/nomicon/uninitialized.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Funinitialized.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Funinitialized.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funinitialized.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -4,7 +4,7 @@ All runtime-allocated memory in a Rust program begins its life as\n *uninitialized*. In this state the value of the memory is an indeterminate pile\n of bits that may or may not even reflect a valid state for the type that is\n supposed to inhabit that location of memory. Attempting to interpret this memory\n-as a value of *any* type will cause Undefined Behaviour. Do Not Do This.\n+as a value of *any* type will cause Undefined Behavior. Do Not Do This.\n \n Rust provides mechanisms to work with uninitialized memory in checked (safe) and\n-unchecked (unsafe) ways.\n\\ No newline at end of file\n+unchecked (unsafe) ways."}, {"sha": "e81f06b83b2496d61b7238a15758e4c8f240b8ce", "filename": "src/doc/nomicon/unwinding.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Funwinding.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Funwinding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Funwinding.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -42,7 +42,7 @@ should only panic for programming errors or *extreme* problems.\n \n Rust's unwinding strategy is not specified to be fundamentally compatible\n with any other language's unwinding. As such, unwinding into Rust from another\n-language, or unwinding into another language from Rust is Undefined Behaviour.\n+language, or unwinding into another language from Rust is Undefined Behavior.\n You must *absolutely* catch any panics at the FFI boundary! What you do at that\n point is up to you, but *something* must be done. If you fail to do this,\n at best, your application will crash and burn. At worst, your application *won't*"}, {"sha": "7ca369da0b886be266de71952bc08704f4bb6a49", "filename": "src/doc/nomicon/vec-layout.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fvec-layout.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fvec-layout.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fvec-layout.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -93,7 +93,7 @@ pub struct Vec<T> {\n If you don't care about the null-pointer optimization, then you can use the\n stable code. However we will be designing the rest of the code around enabling\n the optimization. In particular, `Unique::new` is unsafe to call, because\n-putting `null` inside of it is Undefined Behaviour. Our stable Unique doesn't\n+putting `null` inside of it is Undefined Behavior. Our stable Unique doesn't\n need `new` to be unsafe because it doesn't make any interesting guarantees about\n its contents.\n "}, {"sha": "5e747a8c71d41bd38daf0377bbe9a41df51d0d59", "filename": "src/doc/nomicon/vec-push-pop.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fvec-push-pop.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fvec-push-pop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fvec-push-pop.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -34,7 +34,7 @@ Easy! How about `pop`? Although this time the index we want to access is\n initialized, Rust won't just let us dereference the location of memory to move\n the value out, because that would leave the memory uninitialized! For this we\n need `ptr::read`, which just copies out the bits from the target address and\n-intrprets it as a value of type T. This will leave the memory at this address\n+interprets it as a value of type T. This will leave the memory at this address\n logically uninitialized, even though there is in fact a perfectly good instance\n of T there.\n "}, {"sha": "fb337a891a8d42ddb50ac5ed224d931b2fee71ae", "filename": "src/doc/nomicon/vec-zsts.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fvec-zsts.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fnomicon%2Fvec-zsts.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fvec-zsts.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -1,6 +1,6 @@\n % Handling Zero-Sized Types\n \n-It's time. We're going to fight the spectre that is zero-sized types. Safe Rust\n+It's time. We're going to fight the specter that is zero-sized types. Safe Rust\n *never* needs to care about this, but Vec is very intensive on raw pointers and\n raw allocations, which are exactly the two things that care about\n zero-sized types. We need to be careful of two things:"}, {"sha": "3032fa7116fe44aea396cee853c354fb65ac2d9c", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -3706,7 +3706,7 @@ repeated sub-expression is a coercion site for coercion to type `U`.\n Each sub-expression is a coercion site to the respective type, e.g. the\n zeroth sub-expression is a coercion site to type `U_0`.\n \n-* Parenthesised sub-expressions (`(e)`): if the expression has type `U`, then\n+* Parenthesized sub-expressions (`(e)`): if the expression has type `U`, then\n the sub-expression is a coercion site to `U`.\n \n * Blocks: if a block has type `U`, then the last expression in the block (if\n@@ -4072,7 +4072,7 @@ that have since been removed):\n \n * SML, OCaml: algebraic data types, pattern matching, type inference,\n   semicolon statement separation\n-* C++: references, RAII, smart pointers, move semantics, monomorphisation,\n+* C++: references, RAII, smart pointers, move semantics, monomorphization,\n   memory model\n * ML Kit, Cyclone: region based memory management\n * Haskell (GHC): typeclasses, type families"}, {"sha": "c55b38b915b3d1d9e6241d324cee7fec6a003271", "filename": "src/doc/style/features/modules.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Fmodules.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -17,12 +17,12 @@ Organize module headers as follows:\n Avoid using `#[path=\"...\"]` directives; make the file system and\n module hierarchy match, instead.\n \n-### Use the module hirearchy to organize APIs into coherent sections. [FIXME]\n+### Use the module hierarchy to organize APIs into coherent sections. [FIXME]\n \n > **[FIXME]** Flesh this out with examples; explain what a \"coherent\n > section\" is with examples.\n >\n-> The module hirearchy defines both the public and internal API of your module.\n+> The module hierarchy defines both the public and internal API of your module.\n > Breaking related functionality into submodules makes it understandable to both\n > users and contributors to the module.\n \n@@ -82,7 +82,7 @@ io/mod.rs\n ```\n \n While it is possible to define all of `io` within a single directory,\n-mirroring the module hirearchy in the directory structure makes\n+mirroring the module hierarchy in the directory structure makes\n submodules of `io::net` easier to find.\n \n ### Consider top-level definitions or reexports. [FIXME: needs RFC]\n@@ -104,13 +104,13 @@ while\n [`TcpStream`](https://doc.rust-lang.org/std/io/net/tcp/struct.TcpStream.html)\n is defined in `io/net/tcp.rs` and reexported in the `io` module.\n \n-### Use internal module hirearchies for organization. [FIXME: needs RFC]\n+### Use internal module hierarchies for organization. [FIXME: needs RFC]\n \n > **[FIXME]**\n > - Referencing internal modules from the standard library is subject to\n >   becoming outdated.\n \n-Internal module hirearchies (i.e., private submodules) may be used to\n+Internal module hierarchies (i.e., private submodules) may be used to\n hide implementation details that are not part of the module's API.\n \n For example, in [`std::io`](https://doc.rust-lang.org/std/io/), `mod mem`"}, {"sha": "feedd3937fc9dcac67e804cff5ced6af966c177e", "filename": "src/doc/style/features/traits/reuse.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fstyle%2Ffeatures%2Ftraits%2Freuse.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -5,7 +5,7 @@\n > **[FIXME]** We probably want to discourage this, at least when used in a way\n > that is publicly exposed.\n \n-Traits that provide default implmentations for function can provide code reuse\n+Traits that provide default implementations for function can provide code reuse\n across types. For example, a `print` method can be defined across multiple\n types as follows:\n "}, {"sha": "28702d95b60a7ab06fbdccf3b31ca14d6d0723b3", "filename": "src/doc/trpl/dining-philosophers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -13,7 +13,7 @@ Hoare in 1985.\n > dining room, furnished with a circular table, surrounded by five chairs, each\n > labelled by the name of the philosopher who was to sit in it. They sat\n > anticlockwise around the table. To the left of each philosopher there was\n-> laid a golden fork, and in the centre stood a large bowl of spaghetti, which\n+> laid a golden fork, and in the center stood a large bowl of spaghetti, which\n > was constantly replenished. A philosopher was expected to spend most of\n > their time thinking; but when they felt hungry, they went to the dining\n > room, sat down in their own chair, picked up their own fork on their left,"}, {"sha": "7e03bb72cad598e5b7972e850ba33a8f393d131b", "filename": "src/doc/trpl/syntax-index.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Ftrpl%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Ftrpl%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fsyntax-index.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -25,7 +25,7 @@\n * `pub`: denotes public visibility in `struct` fields, `impl` blocks, and modules.  See [Crates and Modules (Exporting a Public Interface)].\n * `ref`: by-reference binding.  See [Patterns (`ref` and `ref mut`)].\n * `return`: return from function.  See [Functions (Early Returns)].\n-* `Self`: implementer type alias.  See [Traits].\n+* `Self`: implementor type alias.  See [Traits].\n * `self`: method subject.  See [Method Syntax (Method Calls)].\n * `static`: global variable.  See [`const` and `static` (`static`)].\n * `struct`: structure definition.  See [Structs].\n@@ -68,7 +68,7 @@\n * `/` (`expr / expr`): arithmetic division.  Overloadable (`Div`).\n * `/=` (`var /= expr`): arithmetic division & assignment.\n * `:` (`pat: type`, `ident: type`): constraints.  See [Variable Bindings], [Functions], [Structs], [Traits].\n-* `:` (`ident: expr`): struct field initialiser.  See [Structs].\n+* `:` (`ident: expr`): struct field initializer.  See [Structs].\n * `:` (`'a: loop {\u2026}`): loop label.  See [Loops (Loops Labels)].\n * `;`: statement and item terminator.\n * `;` (`[\u2026; len]`): part of fixed-size array syntax.  See [Primitive Types (Arrays)].\n@@ -153,12 +153,12 @@\n <!-- Various things involving parens and tuples -->\n \n * `()`: empty tuple (*a.k.a.* unit), both literal and type.\n-* `(expr)`: parenthesised expression.\n+* `(expr)`: parenthesized expression.\n * `(expr,)`: single-element tuple expression.  See [Primitive Types (Tuples)].\n * `(type,)`: single-element tuple type.  See [Primitive Types (Tuples)].\n * `(expr, \u2026)`: tuple expression.  See [Primitive Types (Tuples)].\n * `(type, \u2026)`: tuple type.  See [Primitive Types (Tuples)].\n-* `expr(expr, \u2026)`: function call expression.  Also used to initialise tuple `struct`s and tuple `enum` variants.  See [Functions].\n+* `expr(expr, \u2026)`: function call expression.  Also used to initialize tuple `struct`s and tuple `enum` variants.  See [Functions].\n * `ident!(\u2026)`, `ident!{\u2026}`, `ident![\u2026]`: macro invocation.  See [Macros].\n * `expr.0`, `expr.1`, \u2026: tuple indexing.  See [Primitive Types (Tuple Indexing)].\n "}, {"sha": "f3a5d1dd886c82b86538372b525f35da1c8ebff7", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -221,7 +221,7 @@ Could not compile `hello`.\n To learn more, run the command again with --verbose.\n ```\n \n-Additionaly, variable bindings can be shadowed. This means that a later\n+Additionally, variable bindings can be shadowed. This means that a later\n variable binding with the same name as another binding, that's currently in\n scope, will override the previous binding.\n "}, {"sha": "996a590043a47c04b997bab097dfc0ee9cf02130", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -114,7 +114,7 @@ impl<T> RawVec<T> {\n \n     /// Reconstitutes a RawVec from a pointer and capacity.\n     ///\n-    /// # Undefined Behaviour\n+    /// # Undefined Behavior\n     ///\n     /// The ptr must be allocated, and with the given capacity. The\n     /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n@@ -248,7 +248,7 @@ impl<T> RawVec<T> {\n     ///\n     /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behaviour of this function may break.\n+    /// code *you* write that relies on the behavior of this function may break.\n     ///\n     /// # Panics\n     ///\n@@ -302,12 +302,12 @@ impl<T> RawVec<T> {\n     /// Ensures that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n-    /// space to get amortized `O(1)` behaviour. Will limit this behaviour\n+    /// space to get amortized `O(1)` behavior. Will limit this behavior\n     /// if it would needlessly cause itself to panic.\n     ///\n     /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n-    /// code *you* write that relies on the behaviour of this function may break.\n+    /// code *you* write that relies on the behavior of this function may break.\n     ///\n     /// This is ideal for implementing a bulk-push operation like `extend`.\n     ///\n@@ -430,7 +430,7 @@ impl<T> RawVec<T> {\n \n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n-    /// While it is not *strictly* Undefined Behaviour to call\n+    /// While it is not *strictly* Undefined Behavior to call\n     /// this procedure while some of the RawVec is unintialized,\n     /// it cetainly makes it trivial to trigger it.\n     ///"}, {"sha": "59ffc1bd36f821474deb3fb834371f20ece5f009", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -949,7 +949,7 @@ impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n     }\n }\n \n-/// Genericises over how to get the correct type of iterator from the correct type\n+/// Genericizes over how to get the correct type of iterator from the correct type\n /// of Node ownership.\n trait Traverse<N> {\n     fn traverse(node: N) -> Self;"}, {"sha": "4380f315ee7f12de54ae460c131e0c43f8c43e6c", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -818,7 +818,7 @@ impl<K, V, NodeRef> Handle<NodeRef, handle::Edge, handle::Internal> where\n         }\n     }\n \n-    /// Handle an underflow in this node's child. We favour handling \"to the left\" because we know\n+    /// Handle an underflow in this node's child. We favor handling \"to the left\" because we know\n     /// we're empty, but our neighbour can be full. Handling to the left means when we choose to\n     /// steal, we pop off the end of our neighbour (always fast) and \"unshift\" ourselves\n     /// (always slow, but at least faster since we know we're half-empty)."}, {"sha": "eea21988aa36021a9201eb4697083bc241756892", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -94,7 +94,7 @@ pub trait Write {\n         self.write_str(unsafe { str::from_utf8_unchecked(&utf_8[..bytes_written]) })\n     }\n \n-    /// Glue for usage of the `write!` macro with implementers of this trait.\n+    /// Glue for usage of the `write!` macro with implementors of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n     /// the `write!` macro itself.\n@@ -523,7 +523,7 @@ pub trait Binary {\n \n /// Format trait for the `x` character.\n ///\n-/// The `LowerHex` trait should format its output as a number in hexidecimal, with `a` through `f`\n+/// The `LowerHex` trait should format its output as a number in hexadecimal, with `a` through `f`\n /// in lower case.\n ///\n /// The alternate flag, `#`, adds a `0x` in front of the output.\n@@ -571,7 +571,7 @@ pub trait LowerHex {\n \n /// Format trait for the `X` character.\n ///\n-/// The `UpperHex` trait should format its output as a number in hexidecimal, with `A` through `F`\n+/// The `UpperHex` trait should format its output as a number in hexadecimal, with `A` through `F`\n /// in upper case.\n ///\n /// The alternate flag, `#`, adds a `0x` in front of the output.\n@@ -620,7 +620,7 @@ pub trait UpperHex {\n /// Format trait for the `p` character.\n ///\n /// The `Pointer` trait should format its output as a memory location. This is commonly presented\n-/// as hexidecimal.\n+/// as hexadecimal.\n ///\n /// For more information on formatters, see [the module-level documentation][module].\n ///"}, {"sha": "45b1c8a3599ca34c4b8aa88f40e389fa4cff1a4c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -301,7 +301,7 @@ extern \"rust-intrinsic\" {\n     /// # Safety\n     ///\n     /// Beyond requiring that the program must be allowed to access both regions\n-    /// of memory, it is Undefined Behaviour for source and destination to\n+    /// of memory, it is Undefined Behavior for source and destination to\n     /// overlap. Care must also be taken with the ownership of `src` and\n     /// `dst`. This method semantically moves the values of `src` into `dst`.\n     /// However it does not drop the contents of `dst`, or prevent the contents"}, {"sha": "5e888dce1ec6d7cd944bbfa2fc93cec84f2eb2c7", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -1453,7 +1453,7 @@ pub trait Iterator {\n ///\n /// This is an idiosyncratic helper to try to factor out the\n /// commonalities of {max,min}{,_by}. In particular, this avoids\n-/// having to implement optimisations several times.\n+/// having to implement optimizations several times.\n #[inline]\n fn select_fold1<I,B, FProj, FCmp>(mut it: I,\n                                   mut f_proj: FProj,"}, {"sha": "bb112327abf4b02f0075411958ca63a9af2c911b", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -279,7 +279,7 @@ macro_rules! unreachable {\n     });\n }\n \n-/// A standardised placeholder for marking unfinished code. It panics with the\n+/// A standardized placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n ///\n /// This can be useful if you are prototyping and are just looking to have your"}, {"sha": "f9480b4349d1107ece794503e96edbecfdff04f7", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -172,7 +172,7 @@ pub trait Copy : Clone {\n ///\n /// A somewhat surprising consequence of the definition is `&mut T` is\n /// `Sync` (if `T` is `Sync`) even though it seems that it might\n-/// provide unsynchronised mutation. The trick is a mutable reference\n+/// provide unsynchronized mutation. The trick is a mutable reference\n /// stored in an aliasable reference (that is, `& &mut T`) becomes\n /// read-only, as if it were a `& &T`, hence there is no risk of a data\n /// race.\n@@ -195,7 +195,7 @@ pub trait Copy : Clone {\n ///\n /// Any types with interior mutability must also use the `std::cell::UnsafeCell`\n /// wrapper around the value(s) which can be mutated when behind a `&`\n-/// reference; not doing this is undefined behaviour (for example,\n+/// reference; not doing this is undefined behavior (for example,\n /// `transmute`-ing from `&T` to `&mut T` is invalid).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]"}, {"sha": "a87d135e42592551f518118a93969ca1ad6e436a", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -37,7 +37,7 @@ pub use intrinsics::transmute;\n /// * You have two copies of a value (like when writing something like\n ///   [`mem::swap`][swap]), but need the destructor to only run once to\n ///   prevent a double `free`.\n-/// * Transferring resources across [FFI][ffi] boundries.\n+/// * Transferring resources across [FFI][ffi] boundaries.\n ///\n /// [swap]: fn.swap.html\n /// [ffi]: ../../book/ffi.html\n@@ -264,9 +264,9 @@ pub unsafe fn dropped<T>() -> T {\n /// This is useful for FFI functions and initializing arrays sometimes,\n /// but should generally be avoided.\n ///\n-/// # Undefined Behaviour\n+/// # Undefined Behavior\n ///\n-/// It is Undefined Behaviour to read uninitialized memory. Even just an\n+/// It is Undefined Behavior to read uninitialized memory. Even just an\n /// uninitialized boolean. For instance, if you branch on the value of such\n /// a boolean your program may take one, both, or neither of the branches.\n ///\n@@ -303,7 +303,7 @@ pub unsafe fn dropped<T>() -> T {\n ///\n ///     // DANGER ZONE: if anything panics or otherwise\n ///     // incorrectly reads the array here, we will have\n-///     // Undefined Behaviour.\n+///     // Undefined Behavior.\n ///\n ///     // It's ok to mutably iterate the data, since this\n ///     // doesn't involve reading it at all.\n@@ -340,7 +340,7 @@ pub unsafe fn uninitialized<T>() -> T {\n     intrinsics::uninit()\n }\n \n-/// Swap the values at two mutable locations of the same type, without deinitialising or copying\n+/// Swap the values at two mutable locations of the same type, without deinitializing or copying\n /// either one.\n ///\n /// # Examples\n@@ -376,7 +376,7 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n }\n \n /// Replaces the value at a mutable location with a new one, returning the old value, without\n-/// deinitialising or copying either one.\n+/// deinitializing or copying either one.\n ///\n /// This is primarily used for transferring and swapping ownership of a value in a mutable\n /// location."}, {"sha": "960240d7f5fc874728195dd730016f1dd661a158", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -69,7 +69,7 @@ pub const fn null<T>() -> *const T { 0 as *const T }\n pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n /// Swaps the values at two mutable locations of the same type, without\n-/// deinitialising either. They may overlap, unlike `mem::swap` which is\n+/// deinitializing either. They may overlap, unlike `mem::swap` which is\n /// otherwise equivalent.\n ///\n /// # Safety\n@@ -247,7 +247,7 @@ impl<T: ?Sized> *mut T {\n     /// # Safety\n     ///\n     /// The offset must be in-bounds of the object, or one-byte-past-the-end.\n-    /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n+    /// Otherwise `offset` invokes Undefined Behavior, regardless of whether\n     /// the pointer is used.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "84467be6eca5641d30e15a0a4240fc827b761ec1", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -94,7 +94,7 @@ impl<T> Clone for Slice<T> {\n /// Synthesizing a trait object with mismatched types\u2014one where the\n /// vtable does not correspond to the type of the value to which the\n /// data pointer points\u2014is highly likely to lead to undefined\n-/// behaviour.\n+/// behavior.\n ///\n /// # Examples\n ///"}, {"sha": "c0a85e0df067cb6e18a5791b19c0aea5ef0e1285", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -965,7 +965,7 @@ impl<'a> DoubleEndedIterator for Lines<'a> {\n #[allow(deprecated)]\n pub struct LinesAny<'a>(Lines<'a>);\n \n-/// A nameable, clonable fn type\n+/// A nameable, cloneable fn type\n #[derive(Clone)]\n struct LinesAnyMap;\n "}, {"sha": "be9db89e3d7971e58016212692f70ffe2d550f43", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -135,7 +135,7 @@ pub enum Count<'a> {\n }\n \n /// The parser structure for interpreting the input format string. This is\n-/// modelled as an iterator over `Piece` structures to form a stream of tokens\n+/// modeled as an iterator over `Piece` structures to form a stream of tokens\n /// being output.\n ///\n /// This is a recursive-descent parser for the sake of simplicity, and if"}, {"sha": "b82b7d122b3ce8205c760602202243faed391eeb", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -456,7 +456,7 @@ pub trait Labeller<'a,N,E> {\n     fn graph_id(&'a self) -> Id<'a>;\n \n     /// Maps `n` to a unique identifier with respect to `self`. The\n-    /// implementer is responsible for ensuring that the returned name\n+    /// implementor is responsible for ensuring that the returned name\n     /// is a valid DOT identifier.\n     fn node_id(&'a self, n: &N) -> Id<'a>;\n \n@@ -594,7 +594,7 @@ pub type Edges<'a,E> = Cow<'a,[E]>;\n /// that is bound by the self lifetime `'a`.\n ///\n /// The `nodes` and `edges` method each return instantiations of\n-/// `Cow<[T]>` to leave implementers the freedom to create\n+/// `Cow<[T]>` to leave implementors the freedom to create\n /// entirely new vectors or to pass back slices into internally owned\n /// vectors.\n pub trait GraphWalk<'a, N: Clone, E: Clone> {"}, {"sha": "83d82e433064346825374922611aec6259fc69a9", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -168,7 +168,7 @@ impl IndependentSample<f64> for GammaLargeShape {\n ///\n /// For `k > 0` integral, this distribution is the sum of the squares\n /// of `k` independent standard normal random variables. For other\n-/// `k`, this uses the equivalent characterisation `\u03c7\u00b2(k) = Gamma(k/2,\n+/// `k`, this uses the equivalent characterization `\u03c7\u00b2(k) = Gamma(k/2,\n /// 2)`.\n pub struct ChiSquared {\n     repr: ChiSquaredRepr,"}, {"sha": "0b7c5b0d840227313ded8c74dce1679b0938080d", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -207,7 +207,7 @@ fn test_resize_policy() {\n /// The hashes are all keyed by the thread-local random number generator\n /// on creation by default. This means that the ordering of the keys is\n /// randomized, but makes the tables more resistant to\n-/// denial-of-service attacks (Hash DoS). This behaviour can be\n+/// denial-of-service attacks (Hash DoS). This behavior can be\n /// overridden with one of the constructors.\n ///\n /// It is required that the keys implement the `Eq` and `Hash` traits, although\n@@ -324,7 +324,7 @@ fn search_hashed<K, V, M, F>(table: M,\n     F: FnMut(&K) -> bool,\n {\n     // This is the only function where capacity can be zero. To avoid\n-    // undefined behaviour when Bucket::new gets the raw bucket in this\n+    // undefined behavior when Bucket::new gets the raw bucket in this\n     // case, immediately return the appropriate search result.\n     if table.capacity() == 0 {\n         return TableRef(table);"}, {"sha": "a624b3521267af94106476098105af3f16a78ac6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -137,7 +137,7 @@\n //! not.\n //!\n //! Slices can only be handled through some kind of *pointer*, and as\n-//! such come in many flavours such as:\n+//! such come in many flavors such as:\n //!\n //! * `&[T]` - *shared slice*\n //! * `&mut [T]` - *mutable slice*"}, {"sha": "c6499687304ecdf0dca93d59879eb44d78eb7532", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -235,7 +235,7 @@ impl TcpListener {\n     /// to this listener. The port allocated can be queried via the\n     /// `socket_addr` function.\n     ///\n-    /// The address type can be any implementer of `ToSocketAddrs` trait. See\n+    /// The address type can be any implementor of `ToSocketAddrs` trait. See\n     /// its documentation for concrete examples.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn bind<A: ToSocketAddrs>(addr: A) -> io::Result<TcpListener> {"}, {"sha": "4e80fb2ceb09ed4ae4b1caac7cd88c0ddb2020ff", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1162b3752c71515a01875e0c9cef67ec9d7aca46/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=1162b3752c71515a01875e0c9cef67ec9d7aca46", "patch": "@@ -75,7 +75,7 @@ impl IntoInner<imp::Process> for Child {\n     fn into_inner(self) -> imp::Process { self.handle }\n }\n \n-/// A handle to a child procesess's stdin\n+/// A handle to a child process's stdin\n #[stable(feature = \"process\", since = \"1.0.0\")]\n pub struct ChildStdin {\n     inner: AnonPipe"}]}