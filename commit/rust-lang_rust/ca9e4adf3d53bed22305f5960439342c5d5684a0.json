{"sha": "ca9e4adf3d53bed22305f5960439342c5d5684a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhOWU0YWRmM2Q1M2JlZDIyMzA1ZjU5NjA0MzkzNDJjNWQ1Njg0YTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-20T07:27:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-20T07:27:36Z"}, "message": "Auto merge of #4511 - rust-lang:replace_uninitialized, r=flip1995\n\nNew lint: mem_replace_with_uninit\n\nchangelog: add `mem_replace_uninit` lint\n\nThis fixes #4485", "tree": {"sha": "4c3e1b712718963e9766c9f5179f1a77f80e45b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c3e1b712718963e9766c9f5179f1a77f80e45b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca9e4adf3d53bed22305f5960439342c5d5684a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca9e4adf3d53bed22305f5960439342c5d5684a0", "html_url": "https://github.com/rust-lang/rust/commit/ca9e4adf3d53bed22305f5960439342c5d5684a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca9e4adf3d53bed22305f5960439342c5d5684a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdaa93d6958b30001751b0c20a61478ce15fe061", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdaa93d6958b30001751b0c20a61478ce15fe061", "html_url": "https://github.com/rust-lang/rust/commit/cdaa93d6958b30001751b0c20a61478ce15fe061"}, {"sha": "8d884c8a1a5f7ed48fb86a2faf8af16707e6d114", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d884c8a1a5f7ed48fb86a2faf8af16707e6d114", "html_url": "https://github.com/rust-lang/rust/commit/8d884c8a1a5f7ed48fb86a2faf8af16707e6d114"}], "stats": {"total": 204, "additions": 171, "deletions": 33}, "files": [{"sha": "6c9d2020a823d79e7081f5414246b0250e5a5b02", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca9e4adf3d53bed22305f5960439342c5d5684a0/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ca9e4adf3d53bed22305f5960439342c5d5684a0/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=ca9e4adf3d53bed22305f5960439342c5d5684a0", "patch": "@@ -1050,6 +1050,7 @@ Released 2018-09-13\n [`mem_discriminant_non_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_discriminant_non_enum\n [`mem_forget`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_forget\n [`mem_replace_option_with_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_option_with_none\n+[`mem_replace_with_uninit`]: https://rust-lang.github.io/rust-clippy/master/index.html#mem_replace_with_uninit\n [`min_max`]: https://rust-lang.github.io/rust-clippy/master/index.html#min_max\n [`misaligned_transmute`]: https://rust-lang.github.io/rust-clippy/master/index.html#misaligned_transmute\n [`misrefactored_assign_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#misrefactored_assign_op"}, {"sha": "a8e6efc4ba43d48e790b264f1053d1b3730d6bdc", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca9e4adf3d53bed22305f5960439342c5d5684a0/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ca9e4adf3d53bed22305f5960439342c5d5684a0/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ca9e4adf3d53bed22305f5960439342c5d5684a0", "patch": "@@ -6,7 +6,7 @@\n \n A collection of lints to catch common mistakes and improve your [Rust](https://github.com/rust-lang/rust) code.\n \n-[There are 314 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n+[There are 315 lints included in this crate!](https://rust-lang.github.io/rust-clippy/master/index.html)\n \n We have a bunch of lint categories to allow you to choose how much Clippy is supposed to ~~annoy~~ help you:\n "}, {"sha": "79cbb916a5d045652cd9ec7d4a27bd4d73af02fa", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca9e4adf3d53bed22305f5960439342c5d5684a0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9e4adf3d53bed22305f5960439342c5d5684a0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ca9e4adf3d53bed22305f5960439342c5d5684a0", "patch": "@@ -783,6 +783,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         matches::SINGLE_MATCH,\n         mem_discriminant::MEM_DISCRIMINANT_NON_ENUM,\n         mem_replace::MEM_REPLACE_OPTION_WITH_NONE,\n+        mem_replace::MEM_REPLACE_WITH_UNINIT,\n         methods::CHARS_LAST_CMP,\n         methods::CHARS_NEXT_CMP,\n         methods::CLONE_DOUBLE_REF,\n@@ -1117,6 +1118,7 @@ pub fn register_plugins(reg: &mut rustc_driver::plugin::Registry<'_>, conf: &Con\n         loops::REVERSE_RANGE_LOOP,\n         loops::WHILE_IMMUTABLE_CONDITION,\n         mem_discriminant::MEM_DISCRIMINANT_NON_ENUM,\n+        mem_replace::MEM_REPLACE_WITH_UNINIT,\n         methods::CLONE_DOUBLE_REF,\n         methods::INTO_ITER_ON_ARRAY,\n         methods::TEMPORARY_CSTRING_AS_PTR,"}, {"sha": "3e1155806b9efa1c2c1c1bc5a97a2140699b6e8a", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 95, "deletions": 31, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/ca9e4adf3d53bed22305f5960439342c5d5684a0/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9e4adf3d53bed22305f5960439342c5d5684a0/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=ca9e4adf3d53bed22305f5960439342c5d5684a0", "patch": "@@ -1,4 +1,6 @@\n-use crate::utils::{match_def_path, match_qpath, paths, snippet_with_applicability, span_lint_and_sugg};\n+use crate::utils::{\n+    match_def_path, match_qpath, paths, snippet_with_applicability, span_help_and_lint, span_lint_and_sugg,\n+};\n use if_chain::if_chain;\n use rustc::hir::{Expr, ExprKind, MutMutable, QPath};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n@@ -32,7 +34,40 @@ declare_clippy_lint! {\n     \"replacing an `Option` with `None` instead of `take()`\"\n }\n \n-declare_lint_pass!(MemReplace => [MEM_REPLACE_OPTION_WITH_NONE]);\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `mem::replace(&mut _, mem::uninitialized())`\n+    /// and `mem::replace(&mut _, mem::zeroed())`.\n+    ///\n+    /// **Why is this bad?** This will lead to undefined behavior even if the\n+    /// value is overwritten later, because the uninitialized value may be\n+    /// observed in the case of a panic.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```\n+    /// use std::mem;\n+    ///# fn may_panic(v: Vec<i32>) -> Vec<i32> { v }\n+    ///\n+    /// #[allow(deprecated, invalid_value)]\n+    /// fn myfunc (v: &mut Vec<i32>) {\n+    ///     let taken_v = unsafe { mem::replace(v, mem::uninitialized()) };\n+    ///     let new_v = may_panic(taken_v); // undefined behavior on panic\n+    ///     mem::forget(mem::replace(v, new_v));\n+    /// }\n+    /// ```\n+    ///\n+    /// The [take_mut](https://docs.rs/take_mut) crate offers a sound solution,\n+    /// at the cost of either lazily creating a replacement value or aborting\n+    /// on panic, to ensure that the uninitialized value cannot be observed.\n+    pub MEM_REPLACE_WITH_UNINIT,\n+    correctness,\n+    \"`mem::replace(&mut _, mem::uninitialized())` or `mem::replace(&mut _, mem::zeroed())`\"\n+}\n+\n+declare_lint_pass!(MemReplace =>\n+    [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n@@ -45,37 +80,66 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemReplace {\n             if match_def_path(cx, def_id, &paths::MEM_REPLACE);\n \n             // Check that second argument is `Option::None`\n-            if let ExprKind::Path(ref replacement_qpath) = func_args[1].node;\n-            if match_qpath(replacement_qpath, &paths::OPTION_NONE);\n-\n             then {\n-                // Since this is a late pass (already type-checked),\n-                // and we already know that the second argument is an\n-                // `Option`, we do not need to check the first\n-                // argument's type. All that's left is to get\n-                // replacee's path.\n-                let replaced_path = match func_args[0].node {\n-                    ExprKind::AddrOf(MutMutable, ref replaced) => {\n-                        if let ExprKind::Path(QPath::Resolved(None, ref replaced_path)) = replaced.node {\n-                            replaced_path\n-                        } else {\n-                            return\n-                        }\n-                    },\n-                    ExprKind::Path(QPath::Resolved(None, ref replaced_path)) => replaced_path,\n-                    _ => return,\n-                };\n+                if let ExprKind::Path(ref replacement_qpath) = func_args[1].node {\n+                    if match_qpath(replacement_qpath, &paths::OPTION_NONE) {\n \n-                let mut applicability = Applicability::MachineApplicable;\n-                span_lint_and_sugg(\n-                    cx,\n-                    MEM_REPLACE_OPTION_WITH_NONE,\n-                    expr.span,\n-                    \"replacing an `Option` with `None`\",\n-                    \"consider `Option::take()` instead\",\n-                    format!(\"{}.take()\", snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)),\n-                    applicability,\n-                );\n+                        // Since this is a late pass (already type-checked),\n+                        // and we already know that the second argument is an\n+                        // `Option`, we do not need to check the first\n+                        // argument's type. All that's left is to get\n+                        // replacee's path.\n+                        let replaced_path = match func_args[0].node {\n+                            ExprKind::AddrOf(MutMutable, ref replaced) => {\n+                                if let ExprKind::Path(QPath::Resolved(None, ref replaced_path)) = replaced.node {\n+                                    replaced_path\n+                                } else {\n+                                    return\n+                                }\n+                            },\n+                            ExprKind::Path(QPath::Resolved(None, ref replaced_path)) => replaced_path,\n+                            _ => return,\n+                        };\n+\n+                        let mut applicability = Applicability::MachineApplicable;\n+                        span_lint_and_sugg(\n+                            cx,\n+                            MEM_REPLACE_OPTION_WITH_NONE,\n+                            expr.span,\n+                            \"replacing an `Option` with `None`\",\n+                            \"consider `Option::take()` instead\",\n+                            format!(\"{}.take()\", snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)),\n+                            applicability,\n+                        );\n+                    }\n+                }\n+                if let ExprKind::Call(ref repl_func, ref repl_args) = func_args[1].node {\n+                    if_chain! {\n+                        if repl_args.is_empty();\n+                        if let ExprKind::Path(ref repl_func_qpath) = repl_func.node;\n+                        if let Some(repl_def_id) = cx.tables.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n+                        then {\n+                            if match_def_path(cx, repl_def_id, &paths::MEM_UNINITIALIZED) {\n+                                span_help_and_lint(\n+                                    cx,\n+                                    MEM_REPLACE_WITH_UNINIT,\n+                                    expr.span,\n+                                    \"replacing with `mem::uninitialized()`\",\n+                                    \"consider using the `take_mut` crate instead\",\n+                                );\n+                            } else if match_def_path(cx, repl_def_id, &paths::MEM_ZEROED) &&\n+                                    !cx.tables.expr_ty(&func_args[1]).is_primitive() {\n+                                span_help_and_lint(\n+                                    cx,\n+                                    MEM_REPLACE_WITH_UNINIT,\n+                                    expr.span,\n+                                    \"replacing with `mem::zeroed()`\",\n+                                    \"consider using a default value or the `take_mut` crate instead\",\n+                                );\n+                            }\n+                        }\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "cda3d2024d2e67a57b479cb9404416c4f9e52fa6", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca9e4adf3d53bed22305f5960439342c5d5684a0/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9e4adf3d53bed22305f5960439342c5d5684a0/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=ca9e4adf3d53bed22305f5960439342c5d5684a0", "patch": "@@ -52,6 +52,8 @@ pub const MEM_FORGET: [&str; 3] = [\"core\", \"mem\", \"forget\"];\n pub const MEM_MAYBEUNINIT: [&str; 4] = [\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\"];\n pub const MEM_MAYBEUNINIT_UNINIT: [&str; 5] = [\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"];\n pub const MEM_REPLACE: [&str; 3] = [\"core\", \"mem\", \"replace\"];\n+pub const MEM_UNINITIALIZED: [&str; 3] = [\"core\", \"mem\", \"uninitialized\"];\n+pub const MEM_ZEROED: [&str; 3] = [\"core\", \"mem\", \"zeroed\"];\n pub const MUTEX: [&str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n pub const OPEN_OPTIONS: [&str; 3] = [\"std\", \"fs\", \"OpenOptions\"];\n pub const OPS_MODULE: [&str; 2] = [\"core\", \"ops\"];"}, {"sha": "49b7731865c4360f76eb4c989fa2255c354d9fd3", "filename": "src/lintlist/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ca9e4adf3d53bed22305f5960439342c5d5684a0/src%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9e4adf3d53bed22305f5960439342c5d5684a0/src%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flintlist%2Fmod.rs?ref=ca9e4adf3d53bed22305f5960439342c5d5684a0", "patch": "@@ -6,7 +6,7 @@ pub use lint::Lint;\n pub use lint::LINT_LEVELS;\n \n // begin lint list, do not remove this comment, it\u2019s used in `update_lints`\n-pub const ALL_LINTS: [Lint; 314] = [\n+pub const ALL_LINTS: [Lint; 315] = [\n     Lint {\n         name: \"absurd_extreme_comparisons\",\n         group: \"correctness\",\n@@ -1043,6 +1043,13 @@ pub const ALL_LINTS: [Lint; 314] = [\n         deprecation: None,\n         module: \"mem_replace\",\n     },\n+    Lint {\n+        name: \"mem_replace_with_uninit\",\n+        group: \"correctness\",\n+        desc: \"`mem::replace(&mut _, mem::uninitialized())` or `mem::replace(&mut _, mem::zeroed())`\",\n+        deprecation: None,\n+        module: \"mem_replace\",\n+    },\n     Lint {\n         name: \"min_max\",\n         group: \"correctness\","}, {"sha": "346972b7bb4e0d95e1353040c58c4ed714e8e01b", "filename": "tests/ui/repl_uninit.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ca9e4adf3d53bed22305f5960439342c5d5684a0/tests%2Fui%2Frepl_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca9e4adf3d53bed22305f5960439342c5d5684a0/tests%2Fui%2Frepl_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frepl_uninit.rs?ref=ca9e4adf3d53bed22305f5960439342c5d5684a0", "patch": "@@ -0,0 +1,35 @@\n+#![allow(deprecated, invalid_value)]\n+#![warn(clippy::all)]\n+\n+use std::mem;\n+\n+fn might_panic<X>(x: X) -> X {\n+    // in practice this would be a possibly-panicky operation\n+    x\n+}\n+\n+fn main() {\n+    let mut v = vec![0i32; 4];\n+    // the following is UB if `might_panic` panics\n+    unsafe {\n+        let taken_v = mem::replace(&mut v, mem::uninitialized());\n+        let new_v = might_panic(taken_v);\n+        std::mem::forget(mem::replace(&mut v, new_v));\n+    }\n+\n+    unsafe {\n+        let taken_v = mem::replace(&mut v, mem::zeroed());\n+        let new_v = might_panic(taken_v);\n+        std::mem::forget(mem::replace(&mut v, new_v));\n+    }\n+\n+    // this is silly but OK, because usize is a primitive type\n+    let mut u: usize = 42;\n+    let uref = &mut u;\n+    let taken_u = unsafe { mem::replace(uref, mem::zeroed()) };\n+    *uref = taken_u + 1;\n+\n+    // this is still not OK, because uninit\n+    let taken_u = unsafe { mem::replace(uref, mem::uninitialized()) };\n+    *uref = taken_u + 1;\n+}"}, {"sha": "c1f55d7601e5ccce9592e5653330435d7f114832", "filename": "tests/ui/repl_uninit.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ca9e4adf3d53bed22305f5960439342c5d5684a0/tests%2Fui%2Frepl_uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ca9e4adf3d53bed22305f5960439342c5d5684a0/tests%2Fui%2Frepl_uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frepl_uninit.stderr?ref=ca9e4adf3d53bed22305f5960439342c5d5684a0", "patch": "@@ -0,0 +1,27 @@\n+error: replacing with `mem::uninitialized()`\n+  --> $DIR/repl_uninit.rs:15:23\n+   |\n+LL |         let taken_v = mem::replace(&mut v, mem::uninitialized());\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::mem-replace-with-uninit` implied by `-D warnings`\n+   = help: consider using the `take_mut` crate instead\n+\n+error: replacing with `mem::zeroed()`\n+  --> $DIR/repl_uninit.rs:21:23\n+   |\n+LL |         let taken_v = mem::replace(&mut v, mem::zeroed());\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using a default value or the `take_mut` crate instead\n+\n+error: replacing with `mem::uninitialized()`\n+  --> $DIR/repl_uninit.rs:33:28\n+   |\n+LL |     let taken_u = unsafe { mem::replace(uref, mem::uninitialized()) };\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using the `take_mut` crate instead\n+\n+error: aborting due to 3 previous errors\n+"}]}