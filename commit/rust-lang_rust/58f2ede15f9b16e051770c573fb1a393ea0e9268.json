{"sha": "58f2ede15f9b16e051770c573fb1a393ea0e9268", "node_id": "C_kwDOAAsO6NoAKDU4ZjJlZGUxNWY5YjE2ZTA1MTc3MGM1NzNmYjFhMzkzZWEwZTkyNjg", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-24T20:01:47Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-07-24T23:35:40Z"}, "message": "interpret, ptr_offset_from: refactor and test too-far-apart check", "tree": {"sha": "353c7a31d92c621fecb3f7e79b243c4c88dc713e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/353c7a31d92c621fecb3f7e79b243c4c88dc713e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58f2ede15f9b16e051770c573fb1a393ea0e9268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58f2ede15f9b16e051770c573fb1a393ea0e9268", "html_url": "https://github.com/rust-lang/rust/commit/58f2ede15f9b16e051770c573fb1a393ea0e9268", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58f2ede15f9b16e051770c573fb1a393ea0e9268/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35a061724802377a21fc6dac1ebcbb9b8d1f558a", "url": "https://api.github.com/repos/rust-lang/rust/commits/35a061724802377a21fc6dac1ebcbb9b8d1f558a", "html_url": "https://github.com/rust-lang/rust/commit/35a061724802377a21fc6dac1ebcbb9b8d1f558a"}], "stats": {"total": 199, "additions": 152, "deletions": 47}, "files": [{"sha": "08209eb793216543453e86a23a3a15d08d3bec80", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/58f2ede15f9b16e051770c573fb1a393ea0e9268/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58f2ede15f9b16e051770c573fb1a393ea0e9268/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=58f2ede15f9b16e051770c573fb1a393ea0e9268", "patch": "@@ -7,7 +7,7 @@ use std::convert::TryFrom;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n     self,\n-    interpret::{ConstValue, GlobalId, InterpResult, Scalar},\n+    interpret::{ConstValue, GlobalId, InterpResult, PointerArithmetic, Scalar},\n     BinOp,\n };\n use rustc_middle::ty;\n@@ -328,15 +328,15 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             // We managed to find a valid allocation for one pointer, but not the other.\n                             // That means they are definitely not pointing to the same allocation.\n                             throw_ub_format!(\n-                                \"{} called on pointers into different allocations\",\n+                                \"`{}` called on pointers into different allocations\",\n                                 intrinsic_name\n                             );\n                         }\n                         (Ok((a_alloc_id, a_offset, _)), Ok((b_alloc_id, b_offset, _))) => {\n                             // Found allocation for both. They must be into the same allocation.\n                             if a_alloc_id != b_alloc_id {\n                                 throw_ub_format!(\n-                                    \"{} called on pointers into different allocations\",\n+                                    \"`{}` called on pointers into different allocations\",\n                                     intrinsic_name\n                                 );\n                             }\n@@ -346,47 +346,71 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     };\n \n                 // Compute distance.\n-                let distance = {\n-                    // The subtraction is always done in `isize` to enforce\n-                    // the \"no more than `isize::MAX` apart\" requirement.\n-                    let a_offset = ImmTy::from_uint(a_offset, isize_layout);\n-                    let b_offset = ImmTy::from_uint(b_offset, isize_layout);\n-                    let (val, overflowed, _ty) =\n-                        self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?;\n+                let dist = {\n+                    // Addresses are unsigned, so this is a `usize` computation. We have to do the\n+                    // overflow check separately anyway.\n+                    let (val, overflowed, _ty) = {\n+                        let a_offset = ImmTy::from_uint(a_offset, usize_layout);\n+                        let b_offset = ImmTy::from_uint(b_offset, usize_layout);\n+                        self.overflowing_binary_op(BinOp::Sub, &a_offset, &b_offset)?\n+                    };\n                     if overflowed {\n-                        throw_ub_format!(\"pointers were too far apart for {}\", intrinsic_name);\n+                        // a < b\n+                        if intrinsic_name == sym::ptr_offset_from_unsigned {\n+                            throw_ub_format!(\n+                                \"`{}` called when first pointer has smaller offset than second: {} < {}\",\n+                                intrinsic_name,\n+                                a_offset,\n+                                b_offset,\n+                            );\n+                        }\n+                        // The signed form of the intrinsic allows this. If we interpret the\n+                        // difference as isize, we'll get the proper signed difference. If that\n+                        // seems *positive*, they were more than isize::MAX apart.\n+                        let dist = val.to_machine_isize(self)?;\n+                        if dist >= 0 {\n+                            throw_ub_format!(\n+                                \"`{}` called when first pointer is too far before second\",\n+                                intrinsic_name\n+                            );\n+                        }\n+                        dist\n+                    } else {\n+                        // b >= a\n+                        let dist = val.to_machine_isize(self)?;\n+                        // If converting to isize produced a *negative* result, we had an overflow\n+                        // because they were more than isize::MAX apart.\n+                        if dist < 0 {\n+                            throw_ub_format!(\n+                                \"`{}` called when first pointer is too far ahead of second\",\n+                                intrinsic_name\n+                            );\n+                        }\n+                        dist\n                     }\n-                    val.to_machine_isize(self)?\n                 };\n \n                 // Check that the range between them is dereferenceable (\"in-bounds or one past the\n                 // end of the same allocation\"). This is like the check in ptr_offset_inbounds.\n-                let min_ptr = if distance >= 0 { b } else { a };\n+                let min_ptr = if dist >= 0 { b } else { a };\n                 self.check_ptr_access_align(\n                     min_ptr,\n-                    Size::from_bytes(distance.unsigned_abs()),\n+                    Size::from_bytes(dist.unsigned_abs()),\n                     Align::ONE,\n                     CheckInAllocMsg::OffsetFromTest,\n                 )?;\n \n-                if intrinsic_name == sym::ptr_offset_from_unsigned && distance < 0 {\n-                    throw_ub_format!(\n-                        \"{} called when first pointer has smaller offset than second: {} < {}\",\n-                        intrinsic_name,\n-                        a_offset,\n-                        b_offset,\n-                    );\n-                }\n-\n                 // Perform division by size to compute return value.\n                 let ret_layout = if intrinsic_name == sym::ptr_offset_from_unsigned {\n+                    assert!(0 <= dist && dist <= self.machine_isize_max());\n                     usize_layout\n                 } else {\n+                    assert!(self.machine_isize_min() <= dist && dist <= self.machine_isize_max());\n                     isize_layout\n                 };\n                 let pointee_layout = self.layout_of(substs.type_at(0))?;\n                 // If ret_layout is unsigned, we checked that so is the distance, so we are good.\n-                let val = ImmTy::from_int(distance, ret_layout);\n+                let val = ImmTy::from_int(dist, ret_layout);\n                 let size = ImmTy::from_int(pointee_layout.size.bytes(), ret_layout);\n                 self.exact_div(&val, &size, dest)?;\n             }"}, {"sha": "922bc8df7c32d5649d1375f8c8f2be4dddf39037", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58f2ede15f9b16e051770c573fb1a393ea0e9268/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58f2ede15f9b16e051770c573fb1a393ea0e9268/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=58f2ede15f9b16e051770c573fb1a393ea0e9268", "patch": "@@ -726,7 +726,7 @@ impl<T: ?Sized> *const T {\n     /// }\n     ///\n     /// // This would be incorrect, as the pointers are not correctly ordered:\n-    /// // ptr1.offset_from(ptr2)\n+    /// // ptr1.sub_ptr(ptr2)\n     /// ```\n     #[unstable(feature = \"ptr_sub_ptr\", issue = \"95892\")]\n     #[rustc_const_unstable(feature = \"const_ptr_sub_ptr\", issue = \"95892\")]"}, {"sha": "f3bf9c496da7b2aa12aca64b2d53dd8ec7aa7349", "filename": "src/test/ui/const-ptr/forbidden_slices.32bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58f2ede15f9b16e051770c573fb1a393ea0e9268/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58f2ede15f9b16e051770c573fb1a393ea0e9268/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.32bit.stderr?ref=58f2ede15f9b16e051770c573fb1a393ea0e9268", "patch": "@@ -222,7 +222,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned called on pointers into different allocations\n+   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -241,7 +241,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned called on pointers into different allocations\n+   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL"}, {"sha": "5f2821a91937baa712e7ed4d81449b244cce8b5e", "filename": "src/test/ui/const-ptr/forbidden_slices.64bit.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58f2ede15f9b16e051770c573fb1a393ea0e9268/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58f2ede15f9b16e051770c573fb1a393ea0e9268/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-ptr%2Fforbidden_slices.64bit.stderr?ref=58f2ede15f9b16e051770c573fb1a393ea0e9268", "patch": "@@ -222,7 +222,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned called on pointers into different allocations\n+   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL\n@@ -241,7 +241,7 @@ error[E0080]: could not evaluate static initializer\n LL |         unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from_unsigned called on pointers into different allocations\n+   |                  `ptr_offset_from_unsigned` called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u32>::sub_ptr` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n   ::: $SRC_DIR/core/src/slice/raw.rs:LL:COL"}, {"sha": "1f29a690550bc2368f7125daf94caddc868d02dd", "filename": "src/test/ui/consts/offset_from_ub.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/58f2ede15f9b16e051770c573fb1a393ea0e9268/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58f2ede15f9b16e051770c573fb1a393ea0e9268/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs?ref=58f2ede15f9b16e051770c573fb1a393ea0e9268", "patch": "@@ -2,6 +2,7 @@\n #![feature(core_intrinsics)]\n \n use std::intrinsics::{ptr_offset_from, ptr_offset_from_unsigned};\n+use std::ptr;\n \n #[repr(C)]\n struct Struct {\n@@ -75,9 +76,21 @@ pub const DIFFERENT_ALLOC_UNSIGNED: usize = {\n     let base_ptr: *const Struct = &uninit as *const _ as *const Struct;\n     let uninit2 = std::mem::MaybeUninit::<Struct>::uninit();\n     let field_ptr: *const Struct = &uninit2 as *const _ as *const Struct;\n-    let offset = unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) }; //~ERROR evaluation of constant value failed\n+    unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) } //~ERROR evaluation of constant value failed\n     //~| pointers into different allocations\n-    offset as usize\n+};\n+\n+pub const TOO_FAR_APART1: isize = {\n+    let ptr1 = ptr::null::<u8>();\n+    let ptr2 = ptr1.wrapping_add(isize::MAX as usize + 42);\n+    unsafe { ptr_offset_from(ptr2, ptr1) } //~ERROR evaluation of constant value failed\n+    //~| too far ahead\n+};\n+pub const TOO_FAR_APART2: isize = {\n+    let ptr1 = ptr::null::<u8>();\n+    let ptr2 = ptr1.wrapping_add(isize::MAX as usize + 42);\n+    unsafe { ptr_offset_from(ptr1, ptr2) } //~ERROR evaluation of constant value failed\n+    //~| too far before\n };\n \n const WRONG_ORDER_UNSIGNED: usize = {\n@@ -86,5 +99,27 @@ const WRONG_ORDER_UNSIGNED: usize = {\n     unsafe { ptr_offset_from_unsigned(p, p.add(2) ) } //~ERROR evaluation of constant value failed\n     //~| first pointer has smaller offset than second: 0 < 8\n };\n+pub const TOO_FAR_APART_UNSIGNED: usize = {\n+    let ptr1 = ptr::null::<u8>();\n+    let ptr2 = ptr1.wrapping_add(isize::MAX as usize + 42);\n+    // This would fit into a `usize` but we still don't allow it.\n+    unsafe { ptr_offset_from_unsigned(ptr2, ptr1) } //~ERROR evaluation of constant value failed\n+    //~| too far ahead\n+};\n+\n+// These do NOT complain that pointers are too far apart; they pass that check (to then fail the\n+// next one).\n+pub const OFFSET_VERY_FAR1: isize = {\n+    let ptr1 = ptr::null::<u8>();\n+    let ptr2 = ptr1.wrapping_offset(isize::MAX);\n+    unsafe { ptr2.offset_from(ptr1) }\n+    //~^ inside\n+};\n+pub const OFFSET_VERY_FAR2: isize = {\n+    let ptr1 = ptr::null::<u8>();\n+    let ptr2 = ptr1.wrapping_offset(isize::MAX);\n+    unsafe { ptr1.offset_from(ptr2.wrapping_offset(1)) }\n+    //~^ inside\n+};\n \n fn main() {}"}, {"sha": "62a087d94d3565894d4043cff00b66526097b54b", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 62, "deletions": 16, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/58f2ede15f9b16e051770c573fb1a393ea0e9268/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58f2ede15f9b16e051770c573fb1a393ea0e9268/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=58f2ede15f9b16e051770c573fb1a393ea0e9268", "patch": "@@ -1,71 +1,117 @@\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:17:27\n+  --> $DIR/offset_from_ub.rs:18:27\n    |\n LL |     let offset = unsafe { ptr_offset_from(field_ptr, base_ptr) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from called on pointers into different allocations\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from` called on pointers into different allocations\n \n error[E0080]: evaluation of constant value failed\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                  |\n-   |                  ptr_offset_from called on pointers into different allocations\n+   |                  `ptr_offset_from` called on pointers into different allocations\n    |                  inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $DIR/offset_from_ub.rs:23:14\n+  ::: $DIR/offset_from_ub.rs:24:14\n    |\n LL |     unsafe { (42 as *const u8).offset_from(&5u8) as usize }\n-   |              ----------------------------------- inside `NOT_PTR` at $DIR/offset_from_ub.rs:23:14\n+   |              ----------------------------------- inside `NOT_PTR` at $DIR/offset_from_ub.rs:24:14\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:30:14\n+  --> $DIR/offset_from_ub.rs:31:14\n    |\n LL |     unsafe { ptr_offset_from(field_ptr, base_ptr as *const u16) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ exact_div: 1_isize cannot be divided by 2_isize without remainder\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:36:14\n+  --> $DIR/offset_from_ub.rs:37:14\n    |\n LL |     unsafe { ptr_offset_from(ptr, ptr) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:43:14\n+  --> $DIR/offset_from_ub.rs:44:14\n    |\n LL |     unsafe { ptr_offset_from(ptr2, ptr1) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: 0x8[noalloc] is a dangling pointer (it has no provenance)\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:52:14\n+  --> $DIR/offset_from_ub.rs:53:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, start_ptr) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc18 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:61:14\n+  --> $DIR/offset_from_ub.rs:62:14\n    |\n LL |     unsafe { ptr_offset_from(start_ptr, end_ptr) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc21 has size 4, so pointer to 10 bytes starting at offset 0 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:69:14\n+  --> $DIR/offset_from_ub.rs:70:14\n    |\n LL |     unsafe { ptr_offset_from(end_ptr, end_ptr) }\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ out-of-bounds offset_from: alloc24 has size 4, so pointer at offset 10 is out-of-bounds\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/offset_from_ub.rs:78:27\n+  --> $DIR/offset_from_ub.rs:79:14\n    |\n-LL |     let offset = unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) };\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned called on pointers into different allocations\n+LL |     unsafe { ptr_offset_from_unsigned(field_ptr, base_ptr) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called on pointers into different allocations\n \n error[E0080]: evaluation of constant value failed\n   --> $DIR/offset_from_ub.rs:86:14\n    |\n+LL |     unsafe { ptr_offset_from(ptr2, ptr1) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from` called when first pointer is too far ahead of second\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:92:14\n+   |\n+LL |     unsafe { ptr_offset_from(ptr1, ptr2) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from` called when first pointer is too far before second\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:99:14\n+   |\n LL |     unsafe { ptr_offset_from_unsigned(p, p.add(2) ) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ptr_offset_from_unsigned called when first pointer has smaller offset than second: 0 < 8\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called when first pointer has smaller offset than second: 0 < 8\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/offset_from_ub.rs:106:14\n+   |\n+LL |     unsafe { ptr_offset_from_unsigned(ptr2, ptr1) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ptr_offset_from_unsigned` called when first pointer is too far ahead of second\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   |                  inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $DIR/offset_from_ub.rs:115:14\n+   |\n+LL |     unsafe { ptr2.offset_from(ptr1) }\n+   |              ---------------------- inside `OFFSET_VERY_FAR1` at $DIR/offset_from_ub.rs:115:14\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         unsafe { intrinsics::ptr_offset_from(self, origin) }\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  out-of-bounds offset_from: null pointer is a dangling pointer (it has no provenance)\n+   |                  inside `ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n+   |\n+  ::: $DIR/offset_from_ub.rs:121:14\n+   |\n+LL |     unsafe { ptr1.offset_from(ptr2.wrapping_offset(1)) }\n+   |              ----------------------------------------- inside `OFFSET_VERY_FAR2` at $DIR/offset_from_ub.rs:121:14\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 15 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}