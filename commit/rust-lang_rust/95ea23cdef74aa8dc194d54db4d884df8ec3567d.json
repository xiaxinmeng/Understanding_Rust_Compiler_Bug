{"sha": "95ea23cdef74aa8dc194d54db4d884df8ec3567d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZWEyM2NkZWY3NGFhOGRjMTk0ZDU0ZGI0ZDg4NGRmOGVjMzU2N2Q=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-30T19:10:42Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-01T15:18:34Z"}, "message": "Fix path comparison not comparing paths correctly with unequal lengths", "tree": {"sha": "df3b49b03456d5905ecc5fb419e52f1e18e9d76f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df3b49b03456d5905ecc5fb419e52f1e18e9d76f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95ea23cdef74aa8dc194d54db4d884df8ec3567d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95ea23cdef74aa8dc194d54db4d884df8ec3567d", "html_url": "https://github.com/rust-lang/rust/commit/95ea23cdef74aa8dc194d54db4d884df8ec3567d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95ea23cdef74aa8dc194d54db4d884df8ec3567d/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f4e9914ff77c76ad3cbdebe1e4e2c0a78818d63", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f4e9914ff77c76ad3cbdebe1e4e2c0a78818d63", "html_url": "https://github.com/rust-lang/rust/commit/3f4e9914ff77c76ad3cbdebe1e4e2c0a78818d63"}], "stats": {"total": 133, "additions": 85, "deletions": 48}, "files": [{"sha": "f6025c99a1406ac85b7dd279ff0c09f1d2b1e286", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 85, "deletions": 48, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/95ea23cdef74aa8dc194d54db4d884df8ec3567d/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95ea23cdef74aa8dc194d54db4d884df8ec3567d/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=95ea23cdef74aa8dc194d54db4d884df8ec3567d", "patch": "@@ -4,13 +4,14 @@ use std::{\n     iter::{self, successors},\n };\n \n-use ast::{\n-    edit::{AstNodeEdit, IndentLevel},\n-    PathSegmentKind, VisibilityOwner,\n-};\n+use itertools::{EitherOrBoth, Itertools};\n use syntax::{\n     algo,\n-    ast::{self, make, AstNode},\n+    ast::{\n+        self,\n+        edit::{AstNodeEdit, IndentLevel},\n+        make, AstNode, PathSegmentKind, VisibilityOwner,\n+    },\n     InsertPosition, SyntaxElement, SyntaxNode,\n };\n \n@@ -193,13 +194,13 @@ fn recursive_merge(\n             false => None,\n         })\n         .collect::<Option<Vec<_>>>()?;\n-    use_trees.sort_unstable_by(|a, b| path_cmp_opt(a.path(), b.path()));\n+    use_trees.sort_unstable_by(|a, b| path_cmp_for_sort(a.path(), b.path()));\n     for rhs_t in rhs.use_tree_list().into_iter().flat_map(|list| list.use_trees()) {\n         if !merge.is_tree_allowed(&rhs_t) {\n             return None;\n         }\n         let rhs_path = rhs_t.path();\n-        match use_trees.binary_search_by(|p| path_cmp_opt(p.path(), rhs_path.clone())) {\n+        match use_trees.binary_search_by(|p| path_cmp_bin_search(p.path(), rhs_path.clone())) {\n             Ok(idx) => {\n                 let lhs_t = &mut use_trees[idx];\n                 let lhs_path = lhs_t.path()?;\n@@ -307,39 +308,77 @@ fn path_len(path: ast::Path) -> usize {\n \n /// Orders paths in the following way:\n /// the sole self token comes first, after that come uppercase identifiers, then lowercase identifiers\n-// FIXME: rustfmt sort lowercase idents before uppercase, in general we want to have the same ordering rustfmt has\n+// FIXME: rustfmt sorts lowercase idents before uppercase, in general we want to have the same ordering rustfmt has\n // which is `self` and `super` first, then identifier imports with lowercase ones first, then glob imports and at last list imports.\n // Example foo::{self, foo, baz, Baz, Qux, *, {Bar}}\n-fn path_cmp(a: &ast::Path, b: &ast::Path) -> Ordering {\n-    match (path_is_self(a), path_is_self(b)) {\n-        (true, true) => Ordering::Equal,\n-        (true, false) => Ordering::Less,\n-        (false, true) => Ordering::Greater,\n-        (false, false) => {\n-            let a = segment_iter(a);\n-            let b = segment_iter(b);\n-            // cmp_by would be useful for us here but that is currently unstable\n-            // cmp doesnt work due the lifetimes on text's return type\n-            a.zip(b)\n-                .flat_map(|(seg, seg2)| seg.name_ref().zip(seg2.name_ref()))\n-                .find_map(|(a, b)| match a.text().cmp(b.text()) {\n-                    ord @ Ordering::Greater | ord @ Ordering::Less => Some(ord),\n-                    Ordering::Equal => None,\n-                })\n-                .unwrap_or(Ordering::Equal)\n-        }\n+fn path_cmp_for_sort(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n+    match (a, b) {\n+        (None, None) => Ordering::Equal,\n+        (None, Some(_)) => Ordering::Less,\n+        (Some(_), None) => Ordering::Greater,\n+        (Some(ref a), Some(ref b)) => match (path_is_self(a), path_is_self(b)) {\n+            (true, true) => Ordering::Equal,\n+            (true, false) => Ordering::Less,\n+            (false, true) => Ordering::Greater,\n+            (false, false) => path_cmp_short(a, b),\n+        },\n     }\n }\n \n-fn path_cmp_opt(a: Option<ast::Path>, b: Option<ast::Path>) -> Ordering {\n-    match (a, b) {\n+/// Path comparison func for binary searching for merging.\n+fn path_cmp_bin_search(lhs: Option<ast::Path>, rhs: Option<ast::Path>) -> Ordering {\n+    match (lhs, rhs) {\n         (None, None) => Ordering::Equal,\n         (None, Some(_)) => Ordering::Less,\n         (Some(_), None) => Ordering::Greater,\n-        (Some(a), Some(b)) => path_cmp(&a, &b),\n+        (Some(ref a), Some(ref b)) => path_cmp_short(a, b),\n     }\n }\n \n+/// Short circuiting comparison, if both paths are equal until one of them ends they are considered\n+/// equal\n+fn path_cmp_short(a: &ast::Path, b: &ast::Path) -> Ordering {\n+    let a = segment_iter(a);\n+    let b = segment_iter(b);\n+    // cmp_by would be useful for us here but that is currently unstable\n+    // cmp doesnt work due the lifetimes on text's return type\n+    a.zip(b)\n+        .find_map(|(a, b)| match path_segment_cmp(&a, &b) {\n+            Ordering::Equal => None,\n+            ord => Some(ord),\n+        })\n+        .unwrap_or(Ordering::Equal)\n+}\n+\n+/// Compares to paths, if one ends earlier than the other the has_tl parameters decide which is\n+/// greater as a a path that has a tree list should be greater, while one that just ends without\n+/// a tree list should be considered less.\n+fn use_tree_path_cmp(a: &ast::Path, a_has_tl: bool, b: &ast::Path, b_has_tl: bool) -> Ordering {\n+    let a_segments = segment_iter(a);\n+    let b_segments = segment_iter(b);\n+    // cmp_by would be useful for us here but that is currently unstable\n+    // cmp doesnt work due the lifetimes on text's return type\n+    a_segments\n+        .zip_longest(b_segments)\n+        .find_map(|zipped| match zipped {\n+            EitherOrBoth::Both(ref a, ref b) => match path_segment_cmp(a, b) {\n+                Ordering::Equal => None,\n+                ord => Some(ord),\n+            },\n+            EitherOrBoth::Left(_) if !b_has_tl => Some(Ordering::Greater),\n+            EitherOrBoth::Left(_) => Some(Ordering::Less),\n+            EitherOrBoth::Right(_) if !a_has_tl => Some(Ordering::Less),\n+            EitherOrBoth::Right(_) => Some(Ordering::Greater),\n+        })\n+        .unwrap_or(Ordering::Equal)\n+}\n+\n+fn path_segment_cmp(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n+    let a = a.name_ref();\n+    let b = b.name_ref();\n+    a.as_ref().map(ast::NameRef::text).cmp(&b.as_ref().map(ast::NameRef::text))\n+}\n+\n /// What type of merges are allowed.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum MergeBehaviour {\n@@ -389,7 +428,6 @@ impl ImportGroup {\n             PathSegmentKind::Name(name) => match name.text().as_str() {\n                 \"std\" => ImportGroup::Std,\n                 \"core\" => ImportGroup::Std,\n-                // FIXME: can be ThisModule as well\n                 _ => ImportGroup::ExternCrate,\n             },\n             PathSegmentKind::Type { .. } => unreachable!(),\n@@ -415,30 +453,30 @@ fn find_insert_position(\n         .as_syntax_node()\n         .children()\n         .filter_map(|node| ast::Use::cast(node.clone()).zip(Some(node)))\n-        .flat_map(|(use_, node)| use_.use_tree().and_then(|tree| tree.path()).zip(Some(node)));\n+        .flat_map(|(use_, node)| {\n+            let tree = use_.use_tree()?;\n+            let path = tree.path()?;\n+            let has_tl = tree.use_tree_list().is_some();\n+            Some((path, has_tl, node))\n+        });\n     // Iterator that discards anything thats not in the required grouping\n     // This implementation allows the user to rearrange their import groups as this only takes the first group that fits\n     let group_iter = path_node_iter\n         .clone()\n-        .skip_while(|(path, _)| ImportGroup::new(path) != group)\n-        .take_while(|(path, _)| ImportGroup::new(path) == group);\n+        .skip_while(|(path, ..)| ImportGroup::new(path) != group)\n+        .take_while(|(path, ..)| ImportGroup::new(path) == group);\n \n-    let segments = segment_iter(&insert_path);\n     // track the last element we iterated over, if this is still None after the iteration then that means we never iterated in the first place\n     let mut last = None;\n     // find the element that would come directly after our new import\n-    let post_insert =\n-        group_iter.inspect(|(_, node)| last = Some(node.clone())).find(|(path, _)| {\n-            let check_segments = segment_iter(&path);\n-            segments\n-                .clone()\n-                .zip(check_segments)\n-                .flat_map(|(seg, seg2)| seg.name_ref().zip(seg2.name_ref()))\n-                .all(|(l, r)| l.text() <= r.text())\n-        });\n+    let post_insert = group_iter.inspect(|(.., node)| last = Some(node.clone())).find(\n+        |&(ref path, has_tl, _)| {\n+            use_tree_path_cmp(&insert_path, false, path, has_tl) != Ordering::Greater\n+        },\n+    );\n     match post_insert {\n         // insert our import before that element\n-        Some((_, node)) => (InsertPosition::Before(node.into()), AddBlankLine::After),\n+        Some((.., node)) => (InsertPosition::Before(node.into()), AddBlankLine::After),\n         // there is no element after our new import, so append it to the end of the group\n         None => match last {\n             Some(node) => (InsertPosition::After(node.into()), AddBlankLine::Before),\n@@ -448,10 +486,10 @@ fn find_insert_position(\n                 let mut last = None;\n                 // find the group that comes after where we want to insert\n                 let post_group = path_node_iter\n-                    .inspect(|(_, node)| last = Some(node.clone()))\n-                    .find(|(p, _)| ImportGroup::new(p) > group);\n+                    .inspect(|(.., node)| last = Some(node.clone()))\n+                    .find(|(p, ..)| ImportGroup::new(p) > group);\n                 match post_group {\n-                    Some((_, node)) => {\n+                    Some((.., node)) => {\n                         (InsertPosition::Before(node.into()), AddBlankLine::AfterTwice)\n                     }\n                     // there is no such group, so append after the last one\n@@ -844,7 +882,6 @@ use foo::bar::baz::Qux;\",\n     }\n \n     #[test]\n-    #[ignore] // FIXME: Order changes when switching lhs and rhs\n     fn skip_merge_last_too_long2() {\n         check_last(\n             \"foo::bar::baz::Qux\","}]}