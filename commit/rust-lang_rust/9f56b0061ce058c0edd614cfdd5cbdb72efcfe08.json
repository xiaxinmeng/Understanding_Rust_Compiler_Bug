{"sha": "9f56b0061ce058c0edd614cfdd5cbdb72efcfe08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNTZiMDA2MWNlMDU4YzBlZGQ2MTRjZmRkNWNiZGI3MmVmY2ZlMDg=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-26T23:54:04Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-11-26T23:54:04Z"}, "message": "Pass exprs by @, always treat structural types by pointer, move path and name into trans_lval.", "tree": {"sha": "f1104c3adc0dd3e5a363ff662bb737c0217cd6a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f1104c3adc0dd3e5a363ff662bb737c0217cd6a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f56b0061ce058c0edd614cfdd5cbdb72efcfe08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f56b0061ce058c0edd614cfdd5cbdb72efcfe08", "html_url": "https://github.com/rust-lang/rust/commit/9f56b0061ce058c0edd614cfdd5cbdb72efcfe08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f56b0061ce058c0edd614cfdd5cbdb72efcfe08/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1600974a3a1dc2c2cbdfef6efdc5887a1dc13218", "url": "https://api.github.com/repos/rust-lang/rust/commits/1600974a3a1dc2c2cbdfef6efdc5887a1dc13218", "html_url": "https://github.com/rust-lang/rust/commit/1600974a3a1dc2c2cbdfef6efdc5887a1dc13218"}], "stats": {"total": 186, "additions": 98, "deletions": 88}, "files": [{"sha": "00e7f69e1867b75bcef3bd601ab09787f97dbdc9", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 98, "deletions": 88, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/9f56b0061ce058c0edd614cfdd5cbdb72efcfe08/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f56b0061ce058c0edd614cfdd5cbdb72efcfe08/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9f56b0061ce058c0edd614cfdd5cbdb72efcfe08", "patch": "@@ -679,9 +679,10 @@ fn copy_ty(@block_ctxt cx,\n         if (! is_init) {\n             r = drop_ty(r.bcx, dst, t);\n         }\n-        auto llty = type_of(cx.fcx.ccx, t);\n-        r = build_memcpy(r.bcx, dst, src, llty);\n-        ret res(r.bcx, src);\n+        // In this one surprising case, we do a load/store on\n+        // structure types. This results in a memcpy. Usually\n+        // we talk about structures by pointers in this file.\n+        ret res(r.bcx, r.bcx.build.Store(r.bcx.build.Load(src), dst));\n     }\n \n     cx.fcx.ccx.sess.bug(\"unexpected type in trans.copy_ty: \" +\n@@ -778,7 +779,7 @@ fn node_type(@crate_ctxt cx, &ast.ann a) -> TypeRef {\n }\n \n impure fn trans_unary(@block_ctxt cx, ast.unop op,\n-                      &ast.expr e, &ast.ann a) -> result {\n+                      @ast.expr e, &ast.ann a) -> result {\n \n     auto sub = trans_expr(cx, e);\n \n@@ -811,7 +812,7 @@ impure fn trans_unary(@block_ctxt cx, ast.unop op,\n }\n \n impure fn trans_binary(@block_ctxt cx, ast.binop op,\n-                       &ast.expr a, &ast.expr b) -> result {\n+                       @ast.expr a, @ast.expr b) -> result {\n \n     // First couple cases are lazy:\n \n@@ -997,7 +998,7 @@ fn join_results(@block_ctxt parent_cx,\n     ret res(join_cx, phi);\n }\n \n-impure fn trans_if(@block_ctxt cx, &ast.expr cond,\n+impure fn trans_if(@block_ctxt cx, @ast.expr cond,\n                    &ast.block thn, &option.t[ast.block] els) -> result {\n \n     auto cond_res = trans_expr(cx, cond);\n@@ -1023,7 +1024,7 @@ impure fn trans_if(@block_ctxt cx, &ast.expr cond,\n                      vec(then_res, else_res));\n }\n \n-impure fn trans_while(@block_ctxt cx, &ast.expr cond,\n+impure fn trans_while(@block_ctxt cx, @ast.expr cond,\n                       &ast.block body) -> result {\n \n     auto cond_cx = new_sub_block_ctxt(cx, \"while cond\");\n@@ -1043,7 +1044,7 @@ impure fn trans_while(@block_ctxt cx, &ast.expr cond,\n }\n \n impure fn trans_do_while(@block_ctxt cx, &ast.block body,\n-                         &ast.expr cond) -> result {\n+                         @ast.expr cond) -> result {\n \n     auto body_cx = new_sub_block_ctxt(cx, \"do-while loop body\");\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -1058,42 +1059,66 @@ impure fn trans_do_while(@block_ctxt cx, &ast.block body,\n     ret res(next_cx, body_res.val);\n }\n \n-// The additional bool returned indicates whether it's a local\n-// (that is represented as an alloca, hence needs a 'load' to be\n-// used as an rval).\n+// The additional bool returned indicates whether it's mem (that is\n+// represented as an alloca or heap, hence needs a 'load' to be used as an\n+// immediate).\n \n-fn trans_lval(@block_ctxt cx, &ast.expr e)\n-    -> tup(result, bool, ast.def_id) {\n-    alt (e.node) {\n-        case (ast.expr_name(?n, ?dopt, _)) {\n-            alt (dopt) {\n-                case (some[ast.def](?def)) {\n-                    alt (def) {\n-                        case (ast.def_arg(?did)) {\n-                            check (cx.fcx.llargs.contains_key(did));\n-                            ret tup(res(cx, cx.fcx.llargs.get(did)),\n-                                    false, did);\n-                        }\n-                        case (ast.def_local(?did)) {\n-                            check (cx.fcx.lllocals.contains_key(did));\n-                            ret tup(res(cx, cx.fcx.lllocals.get(did)),\n-                                    true, did);\n-                        }\n-                        case (ast.def_fn(?did)) {\n-                            check (cx.fcx.ccx.fn_ids.contains_key(did));\n-                            ret tup(res(cx, cx.fcx.ccx.fn_ids.get(did)),\n-                                    false, did);\n-                        }\n-                        case (_) {\n-                            cx.fcx.ccx.sess.unimpl(\"def variant in trans\");\n-                        }\n-                    }\n+fn trans_name(@block_ctxt cx, &ast.name n, &option.t[ast.def] dopt)\n+    -> tup(result, bool) {\n+    alt (dopt) {\n+        case (some[ast.def](?def)) {\n+            alt (def) {\n+                case (ast.def_arg(?did)) {\n+                    check (cx.fcx.llargs.contains_key(did));\n+                    ret tup(res(cx, cx.fcx.llargs.get(did)),\n+                            false);\n+                }\n+                case (ast.def_local(?did)) {\n+                    check (cx.fcx.lllocals.contains_key(did));\n+                    ret tup(res(cx, cx.fcx.lllocals.get(did)),\n+                            true);\n                 }\n-                case (none[ast.def]) {\n-                    cx.fcx.ccx.sess.err(\"unresolved expr_name in trans\");\n+                case (ast.def_fn(?did)) {\n+                    check (cx.fcx.ccx.fn_ids.contains_key(did));\n+                    ret tup(res(cx, cx.fcx.ccx.fn_ids.get(did)),\n+                            false);\n+                }\n+                case (_) {\n+                    cx.fcx.ccx.sess.unimpl(\"def variant in trans\");\n                 }\n             }\n         }\n+        case (none[ast.def]) {\n+            cx.fcx.ccx.sess.err(\"unresolved expr_name in trans\");\n+        }\n+    }\n+    fail;\n+}\n+\n+fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n+               &ast.ident field, &ast.ann ann) -> tup(result, bool) {\n+    auto lv = trans_lval(cx, base);\n+    auto r = lv._0;\n+    auto ty = typeck.expr_ty(base);\n+    alt (ty.struct) {\n+        case (typeck.ty_tup(?fields)) {\n+            let uint ix = typeck.field_num(cx.fcx.ccx.sess, sp, field);\n+            auto v = r.bcx.build.GEP(r.val, vec(C_int(0), C_int(ix as int)));\n+            ret tup(res(r.bcx, v), lv._1);\n+        }\n+    }\n+    cx.fcx.ccx.sess.unimpl(\"field variant in trans_field\");\n+    fail;\n+}\n+\n+fn trans_lval(@block_ctxt cx, @ast.expr e) -> tup(result, bool) {\n+    alt (e.node) {\n+        case (ast.expr_name(?n, ?dopt, _)) {\n+            ret trans_name(cx, n, dopt);\n+        }\n+        case (ast.expr_field(?base, ?ident, ?ann)) {\n+            ret trans_field(cx, e.span, base, ident, ann);\n+        }\n     }\n     cx.fcx.ccx.sess.unimpl(\"expr variant in trans_lval\");\n     fail;\n@@ -1105,15 +1130,15 @@ impure fn trans_exprs(@block_ctxt cx, &vec[@ast.expr] es)\n     let @block_ctxt bcx = cx;\n \n     for (@ast.expr e in es) {\n-        auto res = trans_expr(bcx, *e);\n+        auto res = trans_expr(bcx, e);\n         vs += res.val;\n         bcx = res.bcx;\n     }\n \n     ret tup(bcx, vs);\n }\n \n-impure fn trans_cast(@block_ctxt cx, &ast.expr e, &ast.ann ann) -> result {\n+impure fn trans_cast(@block_ctxt cx, @ast.expr e, &ast.ann ann) -> result {\n     auto e_res = trans_expr(cx, e);\n     auto llsrctype = val_ty(e_res.val);\n     auto t = node_ann_type(cx.fcx.ccx, ann);\n@@ -1144,7 +1169,7 @@ impure fn trans_cast(@block_ctxt cx, &ast.expr e, &ast.ann ann) -> result {\n     ret e_res;\n }\n \n-impure fn trans_call(@block_ctxt cx, &ast.expr f,\n+impure fn trans_call(@block_ctxt cx, @ast.expr f,\n                      vec[@ast.expr] args) -> result {\n     auto f_res = trans_lval(cx, f);\n     check (! f_res._1);\n@@ -1163,7 +1188,7 @@ impure fn trans_tup(@block_ctxt cx, vec[tup(bool, @ast.expr)] args,\n     auto r = res(cx, C_nil());\n     for (tup(bool, @ast.expr) arg in args) {\n         auto t = typeck.expr_ty(arg._1);\n-        auto src_res = trans_expr(r.bcx, *arg._1);\n+        auto src_res = trans_expr(r.bcx, arg._1);\n         auto dst_elt = r.bcx.build.GEP(tup_val, vec(C_int(0), C_int(i)));\n         // FIXME: calculate copy init-ness in typestate.\n         r = copy_ty(src_res.bcx, true, dst_elt, src_res.val, t);\n@@ -1173,46 +1198,31 @@ impure fn trans_tup(@block_ctxt cx, vec[tup(bool, @ast.expr)] args,\n }\n \n \n-impure fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n-                      &ast.ident field, &ast.ann ann) -> result {\n-    auto r = trans_expr(cx, *base);\n-    auto ty = typeck.expr_ty(base);\n-    alt (ty.struct) {\n-        case (typeck.ty_tup(?fields)) {\n-            let uint ix = typeck.field_num(cx.fcx.ccx.sess, sp, field);\n-            auto v = r.bcx.build.GEP(r.val, vec(C_int(ix as int)));\n-            ret res(r.bcx, v);\n-        }\n-    }\n-    cx.fcx.ccx.sess.unimpl(\"field variant in trans_field\");\n-    fail;\n-}\n-\n \n-impure fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n+impure fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, _)) {\n             ret trans_lit(cx, *lit);\n         }\n \n         case (ast.expr_unary(?op, ?x, ?ann)) {\n-            ret trans_unary(cx, op, *x, ann);\n+            ret trans_unary(cx, op, x, ann);\n         }\n \n         case (ast.expr_binary(?op, ?x, ?y, _)) {\n-            ret trans_binary(cx, op, *x, *y);\n+            ret trans_binary(cx, op, x, y);\n         }\n \n         case (ast.expr_if(?cond, ?thn, ?els, _)) {\n-            ret trans_if(cx, *cond, thn, els);\n+            ret trans_if(cx, cond, thn, els);\n         }\n \n         case (ast.expr_while(?cond, ?body, _)) {\n-            ret trans_while(cx, *cond, body);\n+            ret trans_while(cx, cond, body);\n         }\n \n         case (ast.expr_do_while(?body, ?cond, _)) {\n-            ret trans_do_while(cx, body, *cond);\n+            ret trans_do_while(cx, body, cond);\n         }\n \n         case (ast.expr_block(?blk, _)) {\n@@ -1226,46 +1236,45 @@ impure fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n             ret res(next_cx, sub.val);\n         }\n \n-        case (ast.expr_name(_,_,_)) {\n-            auto sub = trans_lval(cx, e);\n-            if (sub._1) {\n-                ret res(sub._0.bcx, cx.build.Load(sub._0.val));\n-            } else {\n-                ret sub._0;\n-            }\n-        }\n-\n         case (ast.expr_assign(?dst, ?src, ?ann)) {\n-            auto lhs_res = trans_lval(cx, *dst);\n+            auto lhs_res = trans_lval(cx, dst);\n             check (lhs_res._1);\n-            auto rhs_res = trans_expr(lhs_res._0.bcx, *src);\n+            auto rhs_res = trans_expr(lhs_res._0.bcx, src);\n             auto t = node_ann_type(cx.fcx.ccx, ann);\n             // FIXME: calculate copy init-ness in typestate.\n             ret copy_ty(rhs_res.bcx, true, lhs_res._0.val, rhs_res.val, t);\n         }\n \n         case (ast.expr_call(?f, ?args, _)) {\n-            ret trans_call(cx, *f, args);\n+            ret trans_call(cx, f, args);\n         }\n \n         case (ast.expr_cast(?e, _, ?ann)) {\n-            ret trans_cast(cx, *e, ann);\n+            ret trans_cast(cx, e, ann);\n         }\n \n         case (ast.expr_tup(?args, ?ann)) {\n             ret trans_tup(cx, args, ann);\n         }\n \n-        case (ast.expr_field(?base, ?ident, ?ann)) {\n-            ret trans_field(cx, e.span, base, ident, ann);\n-        }\n+        // lval cases fall through to trans_lval and then\n+        // possibly load the result (if it's non-structural).\n \n+        case (_) {\n+            auto t = typeck.expr_ty(e);\n+            auto sub = trans_lval(cx, e);\n+            if (sub._1 && ! typeck.type_is_structural(t)) {\n+                ret res(sub._0.bcx, cx.build.Load(sub._0.val));\n+            } else {\n+                ret sub._0;\n+            }\n+        }\n     }\n     cx.fcx.ccx.sess.unimpl(\"expr variant in trans_expr\");\n     fail;\n }\n \n-impure fn trans_log(@block_ctxt cx, &ast.expr e) -> result {\n+impure fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n     alt (e.node) {\n         case (ast.expr_lit(?lit, _)) {\n             alt (lit.node) {\n@@ -1293,7 +1302,7 @@ impure fn trans_log(@block_ctxt cx, &ast.expr e) -> result {\n     }\n }\n \n-impure fn trans_check_expr(@block_ctxt cx, &ast.expr e) -> result {\n+impure fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n     auto cond_res = trans_expr(cx, e);\n \n     // FIXME: need pretty-printer.\n@@ -1317,7 +1326,7 @@ impure fn trans_ret(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n     auto r = res(cx, C_nil());\n     alt (e) {\n         case (some[@ast.expr](?x)) {\n-            r = trans_expr(cx, *x);\n+            r = trans_expr(cx, x);\n         }\n     }\n \n@@ -1353,19 +1362,19 @@ impure fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n     auto sub = res(cx, C_nil());\n     alt (s.node) {\n         case (ast.stmt_log(?a)) {\n-            sub.bcx = trans_log(cx, *a).bcx;\n+            sub.bcx = trans_log(cx, a).bcx;\n         }\n \n         case (ast.stmt_check_expr(?a)) {\n-            sub.bcx = trans_check_expr(cx, *a).bcx;\n+            sub.bcx = trans_check_expr(cx, a).bcx;\n         }\n \n         case (ast.stmt_ret(?e)) {\n             sub.bcx = trans_ret(cx, e).bcx;\n         }\n \n         case (ast.stmt_expr(?e)) {\n-            sub.bcx = trans_expr(cx, *e).bcx;\n+            sub.bcx = trans_expr(cx, e).bcx;\n         }\n \n         case (ast.stmt_decl(?d)) {\n@@ -1375,8 +1384,9 @@ impure fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n                         case (some[@ast.expr](?e)) {\n                             check (cx.fcx.lllocals.contains_key(local.id));\n                             auto llptr = cx.fcx.lllocals.get(local.id);\n-                            sub = trans_expr(cx, *e);\n-                            sub.val = sub.bcx.build.Store(sub.val, llptr);\n+                            sub = trans_expr(cx, e);\n+                            copy_ty(sub.bcx, true, llptr, sub.val,\n+                                    typeck.expr_ty(e));\n                         }\n                     }\n                 }"}]}