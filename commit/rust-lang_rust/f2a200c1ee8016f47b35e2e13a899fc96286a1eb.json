{"sha": "f2a200c1ee8016f47b35e2e13a899fc96286a1eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYTIwMGMxZWU4MDE2ZjQ3YjM1ZTJlMTNhODk5ZmM5NjI4NmExZWI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-31T11:48:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-31T11:48:00Z"}, "message": "Merge #1742\n\n1742: cleanup main loop r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "00e5db62b89604bb005f45368d0caa2642a2d350", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00e5db62b89604bb005f45368d0caa2642a2d350"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2a200c1ee8016f47b35e2e13a899fc96286a1eb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdal5wCRBK7hj4Ov3rIwAAdHIIABuJ+GmUbk48b3UkesWPktBe\nnnRslLpruE3DWoxXDokodqSr1ehuckNUNZLqpu6Bgti+w1lgIpV5J3w7v1VGIxXW\nA2cL464DB9lxo9ZjqOghGGpv2N9NOOyhaBxetxXb9kZ2NfjztbuTfJj9My1U/iR3\nOUVUiPkvu/JIPHkYHza0/PvsqjImmheNQwSVtEIwR3voEU5RPYooTsRUosO6F/MA\naquFYqRoxzoMHYtJseQWFicekwOSMYyGDd+DbcaruKYIx5aZ3oOgIt+hv1LuNh/5\nlHSGhyATEoWAPU73ZoqAAfrXd6AK0S85virRDHSvrF4eD7t0cQZ+ntbnREBx2ng=\n=727M\n-----END PGP SIGNATURE-----\n", "payload": "tree 00e5db62b89604bb005f45368d0caa2642a2d350\nparent f90a88630195a1b6b542b5883295d66dd6c59cef\nparent 4e3f5cc7293d97aef4630ea30b8e9ad6931589a8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1567252080 +0000\ncommitter GitHub <noreply@github.com> 1567252080 +0000\n\nMerge #1742\n\n1742: cleanup main loop r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2a200c1ee8016f47b35e2e13a899fc96286a1eb", "html_url": "https://github.com/rust-lang/rust/commit/f2a200c1ee8016f47b35e2e13a899fc96286a1eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f90a88630195a1b6b542b5883295d66dd6c59cef", "url": "https://api.github.com/repos/rust-lang/rust/commits/f90a88630195a1b6b542b5883295d66dd6c59cef", "html_url": "https://github.com/rust-lang/rust/commit/f90a88630195a1b6b542b5883295d66dd6c59cef"}, {"sha": "4e3f5cc7293d97aef4630ea30b8e9ad6931589a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e3f5cc7293d97aef4630ea30b8e9ad6931589a8", "html_url": "https://github.com/rust-lang/rust/commit/4e3f5cc7293d97aef4630ea30b8e9ad6931589a8"}], "stats": {"total": 393, "additions": 172, "deletions": 221}, "files": [{"sha": "a083bb3112254e5ab829dc224e16374e476ec47d", "filename": "crates/ra_lsp_server/src/cargo_target_spec.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcargo_target_spec.rs?ref=f2a200c1ee8016f47b35e2e13a899fc96286a1eb", "patch": "@@ -1,10 +1,7 @@\n-use crate::{\n-    project_model::{self, TargetKind},\n-    world::WorldSnapshot,\n-    Result,\n-};\n-\n use ra_ide_api::{FileId, RunnableKind};\n+use ra_project_model::{self, ProjectWorkspace, TargetKind};\n+\n+use crate::{world::WorldSnapshot, Result};\n \n pub(crate) fn runnable_args(\n     world: &WorldSnapshot,\n@@ -66,15 +63,15 @@ impl CargoTargetSpec {\n         let file_id = world.analysis().crate_root(crate_id)?;\n         let path = world.vfs.read().file2path(ra_vfs::VfsFile(file_id.0));\n         let res = world.workspaces.iter().find_map(|ws| match ws {\n-            project_model::ProjectWorkspace::Cargo { cargo, .. } => {\n+            ProjectWorkspace::Cargo { cargo, .. } => {\n                 let tgt = cargo.target_by_root(&path)?;\n                 Some(CargoTargetSpec {\n                     package: tgt.package(&cargo).name(&cargo).to_string(),\n                     target: tgt.name(&cargo).to_string(),\n                     target_kind: tgt.kind(&cargo),\n                 })\n             }\n-            project_model::ProjectWorkspace::Json { .. } => None,\n+            ProjectWorkspace::Json { .. } => None,\n         });\n         Ok(res)\n     }"}, {"sha": "fa3d88abd8b793eb9c29c8a98020dba45c916669", "filename": "crates/ra_lsp_server/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Flib.rs?ref=f2a200c1ee8016f47b35e2e13a899fc96286a1eb", "patch": "@@ -4,11 +4,9 @@ mod cargo_target_spec;\n mod conv;\n mod main_loop;\n mod markdown;\n-mod project_model;\n pub mod req;\n pub mod config;\n mod world;\n-mod thread_worker;\n \n pub type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync>>;\n pub use crate::{"}, {"sha": "d40fed947514548775e3ff2c0799560329d0129d", "filename": "crates/ra_lsp_server/src/main.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs?ref=f2a200c1ee8016f47b35e2e13a899fc96286a1eb", "patch": "@@ -5,37 +5,37 @@ use ra_lsp_server::{show_message, Result, ServerConfig};\n use ra_prof;\n \n fn main() -> Result<()> {\n+    setup_logging()?;\n+    run_server()?;\n+    Ok(())\n+}\n+\n+fn setup_logging() -> Result<()> {\n     std::env::set_var(\"RUST_BACKTRACE\", \"short\");\n+\n     let logger = Logger::with_env_or_str(\"error\").duplicate_to_stderr(Duplicate::All);\n     match std::env::var(\"RA_LOG_DIR\") {\n         Ok(ref v) if v == \"1\" => logger.log_to_file().directory(\"log\").start()?,\n         _ => logger.start()?,\n     };\n+\n     ra_prof::set_filter(match std::env::var(\"RA_PROFILE\") {\n         Ok(spec) => ra_prof::Filter::from_spec(&spec),\n         Err(_) => ra_prof::Filter::disabled(),\n     });\n-    log::info!(\"lifecycle: server started\");\n-    match std::panic::catch_unwind(main_inner) {\n-        Ok(res) => {\n-            log::info!(\"lifecycle: terminating process with {:?}\", res);\n-            res\n-        }\n-        Err(_) => {\n-            log::error!(\"server panicked\");\n-            Err(\"server panicked\")?\n-        }\n-    }\n+    Ok(())\n }\n \n-fn main_inner() -> Result<()> {\n-    let cwd = std::env::current_dir()?;\n+fn run_server() -> Result<()> {\n+    log::info!(\"lifecycle: server started\");\n+\n     let (connection, io_threads) = Connection::stdio();\n     let server_capabilities = serde_json::to_value(ra_lsp_server::server_capabilities()).unwrap();\n \n     let initialize_params = connection.initialize(server_capabilities)?;\n     let initialize_params: lsp_types::InitializeParams = serde_json::from_value(initialize_params)?;\n \n+    let cwd = std::env::current_dir()?;\n     let root = initialize_params.root_uri.and_then(|it| it.to_file_path().ok()).unwrap_or(cwd);\n \n     let workspace_roots = initialize_params"}, {"sha": "80f0216e85b930cacc8d2ef190939bdba32cf9a0", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 151, "deletions": 126, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=f2a200c1ee8016f47b35e2e13a899fc96286a1eb", "patch": "@@ -4,12 +4,13 @@ pub(crate) mod pending_requests;\n \n use std::{error::Error, fmt, path::PathBuf, sync::Arc, time::Instant};\n \n-use crossbeam_channel::{select, unbounded, Receiver, RecvError, Sender};\n+use crossbeam_channel::{select, unbounded, RecvError, Sender};\n use lsp_server::{Connection, ErrorCode, Message, Notification, Request, RequestId, Response};\n use lsp_types::{ClientCapabilities, NumberOrString};\n-use ra_ide_api::{Canceled, FeatureFlags, FileId, LibraryData};\n+use ra_ide_api::{Canceled, FeatureFlags, FileId, LibraryData, SourceRootId};\n use ra_prof::profile;\n use ra_vfs::VfsTask;\n+use relative_path::RelativePathBuf;\n use serde::{de::DeserializeOwned, Serialize};\n use threadpool::ThreadPool;\n \n@@ -18,7 +19,6 @@ use crate::{\n         pending_requests::{PendingRequest, PendingRequests},\n         subscriptions::Subscriptions,\n     },\n-    project_model::workspace_loader,\n     req,\n     world::{Options, WorldSnapshot, WorldState},\n     Result, ServerConfig,\n@@ -54,14 +54,17 @@ pub fn main_loop(\n     connection: &Connection,\n ) -> Result<()> {\n     log::info!(\"server_config: {:#?}\", config);\n+\n     // FIXME: support dynamic workspace loading.\n     let workspaces = {\n-        let ws_worker = workspace_loader(config.with_sysroot);\n         let mut loaded_workspaces = Vec::new();\n         for ws_root in &ws_roots {\n-            ws_worker.sender().send(ws_root.clone()).unwrap();\n-            match ws_worker.receiver().recv().unwrap() {\n-                Ok(ws) => loaded_workspaces.push(ws),\n+            let workspace = ra_project_model::ProjectWorkspace::discover_with_sysroot(\n+                ws_root.as_path(),\n+                config.with_sysroot,\n+            );\n+            match workspace {\n+                Ok(workspace) => loaded_workspaces.push(workspace),\n                 Err(e) => {\n                     log::error!(\"loading workspace failed: {}\", e);\n \n@@ -75,11 +78,13 @@ pub fn main_loop(\n         }\n         loaded_workspaces\n     };\n+\n     let globs = config\n         .exclude_globs\n         .iter()\n         .map(|glob| ra_vfs_glob::Glob::new(glob))\n         .collect::<std::result::Result<Vec<_>, _>>()?;\n+\n     let feature_flags = {\n         let mut ff = FeatureFlags::default();\n         for (flag, value) in config.feature_flags {\n@@ -95,7 +100,8 @@ pub fn main_loop(\n         ff\n     };\n     log::info!(\"feature_flags: {:#?}\", feature_flags);\n-    let mut state = WorldState::new(\n+\n+    let mut world_state = WorldState::new(\n         ws_roots,\n         workspaces,\n         config.lru_capacity,\n@@ -113,31 +119,58 @@ pub fn main_loop(\n \n     let pool = ThreadPool::new(THREADPOOL_SIZE);\n     let (task_sender, task_receiver) = unbounded::<Task>();\n-    let mut pending_requests = PendingRequests::default();\n+    let (libdata_sender, libdata_receiver) = unbounded::<LibraryData>();\n+    let mut loop_state = LoopState::default();\n \n     log::info!(\"server initialized, serving requests\");\n-    let main_res = main_loop_inner(\n-        &pool,\n-        connection,\n-        task_sender,\n-        task_receiver.clone(),\n-        &mut state,\n-        &mut pending_requests,\n-    );\n+    {\n+        let task_sender = task_sender;\n+        let libdata_sender = libdata_sender;\n+        loop {\n+            log::trace!(\"selecting\");\n+            let event = select! {\n+                recv(&connection.receiver) -> msg => match msg {\n+                    Ok(msg) => Event::Msg(msg),\n+                    Err(RecvError) => Err(\"client exited without shutdown\")?,\n+                },\n+                recv(task_receiver) -> task => Event::Task(task.unwrap()),\n+                recv(world_state.task_receiver) -> task => match task {\n+                    Ok(task) => Event::Vfs(task),\n+                    Err(RecvError) => Err(\"vfs died\")?,\n+                },\n+                recv(libdata_receiver) -> data => Event::Lib(data.unwrap())\n+            };\n+            if let Event::Msg(Message::Request(req)) = &event {\n+                if connection.handle_shutdown(&req)? {\n+                    break;\n+                };\n+            }\n+            loop_turn(\n+                &pool,\n+                &task_sender,\n+                &libdata_sender,\n+                connection,\n+                &mut world_state,\n+                &mut loop_state,\n+                event,\n+            )?;\n+        }\n+    }\n \n     log::info!(\"waiting for tasks to finish...\");\n-    task_receiver\n-        .into_iter()\n-        .for_each(|task| on_task(task, &connection.sender, &mut pending_requests, &mut state));\n+    task_receiver.into_iter().for_each(|task| {\n+        on_task(task, &connection.sender, &mut loop_state.pending_requests, &mut world_state)\n+    });\n+    libdata_receiver.into_iter().for_each(|lib| drop(lib));\n     log::info!(\"...tasks have finished\");\n     log::info!(\"joining threadpool...\");\n     drop(pool);\n     log::info!(\"...threadpool has finished\");\n \n-    let vfs = Arc::try_unwrap(state.vfs).expect(\"all snapshots should be dead\");\n+    let vfs = Arc::try_unwrap(world_state.vfs).expect(\"all snapshots should be dead\");\n     drop(vfs);\n \n-    main_res\n+    Ok(())\n }\n \n #[derive(Debug)]\n@@ -192,121 +225,113 @@ impl fmt::Debug for Event {\n     }\n }\n \n-fn main_loop_inner(\n+#[derive(Debug, Default)]\n+struct LoopState {\n+    pending_requests: PendingRequests,\n+    subscriptions: Subscriptions,\n+    // We try not to index more than MAX_IN_FLIGHT_LIBS libraries at the same\n+    // time to always have a thread ready to react to input.\n+    in_flight_libraries: usize,\n+    pending_libraries: Vec<(SourceRootId, Vec<(FileId, RelativePathBuf, Arc<String>)>)>,\n+    workspace_loaded: bool,\n+}\n+\n+fn loop_turn(\n     pool: &ThreadPool,\n+    task_sender: &Sender<Task>,\n+    libdata_sender: &Sender<LibraryData>,\n     connection: &Connection,\n-    task_sender: Sender<Task>,\n-    task_receiver: Receiver<Task>,\n-    state: &mut WorldState,\n-    pending_requests: &mut PendingRequests,\n+    world_state: &mut WorldState,\n+    loop_state: &mut LoopState,\n+    event: Event,\n ) -> Result<()> {\n-    let mut subs = Subscriptions::default();\n-    // We try not to index more than MAX_IN_FLIGHT_LIBS libraries at the same\n-    // time to always have a thread ready to react to input.\n-    let mut in_flight_libraries = 0;\n-    let mut pending_libraries = Vec::new();\n-    let mut send_workspace_notification = true;\n-\n-    let (libdata_sender, libdata_receiver) = unbounded();\n-    loop {\n-        log::trace!(\"selecting\");\n-        let event = select! {\n-            recv(&connection.receiver) -> msg => match msg {\n-                Ok(msg) => Event::Msg(msg),\n-                Err(RecvError) => Err(\"client exited without shutdown\")?,\n-            },\n-            recv(task_receiver) -> task => Event::Task(task.unwrap()),\n-            recv(state.task_receiver) -> task => match task {\n-                Ok(task) => Event::Vfs(task),\n-                Err(RecvError) => Err(\"vfs died\")?,\n-            },\n-            recv(libdata_receiver) -> data => Event::Lib(data.unwrap())\n-        };\n-        let loop_start = Instant::now();\n-\n-        // NOTE: don't count blocking select! call as a loop-turn time\n-        let _p = profile(\"main_loop_inner/loop-turn\");\n-        log::info!(\"loop turn = {:?}\", event);\n-        let queue_count = pool.queued_count();\n-        if queue_count > 0 {\n-            log::info!(\"queued count = {}\", queue_count);\n-        }\n+    let loop_start = Instant::now();\n+\n+    // NOTE: don't count blocking select! call as a loop-turn time\n+    let _p = profile(\"main_loop_inner/loop-turn\");\n+    log::info!(\"loop turn = {:?}\", event);\n+    let queue_count = pool.queued_count();\n+    if queue_count > 0 {\n+        log::info!(\"queued count = {}\", queue_count);\n+    }\n \n-        let mut state_changed = false;\n-        match event {\n-            Event::Task(task) => {\n-                on_task(task, &connection.sender, pending_requests, state);\n-                state.maybe_collect_garbage();\n-            }\n-            Event::Vfs(task) => {\n-                state.vfs.write().handle_task(task);\n+    let mut state_changed = false;\n+    match event {\n+        Event::Task(task) => {\n+            on_task(task, &connection.sender, &mut loop_state.pending_requests, world_state);\n+            world_state.maybe_collect_garbage();\n+        }\n+        Event::Vfs(task) => {\n+            world_state.vfs.write().handle_task(task);\n+            state_changed = true;\n+        }\n+        Event::Lib(lib) => {\n+            world_state.add_lib(lib);\n+            world_state.maybe_collect_garbage();\n+            loop_state.in_flight_libraries -= 1;\n+        }\n+        Event::Msg(msg) => match msg {\n+            Message::Request(req) => on_request(\n+                world_state,\n+                &mut loop_state.pending_requests,\n+                pool,\n+                task_sender,\n+                &connection.sender,\n+                loop_start,\n+                req,\n+            )?,\n+            Message::Notification(not) => {\n+                on_notification(\n+                    &connection.sender,\n+                    world_state,\n+                    &mut loop_state.pending_requests,\n+                    &mut loop_state.subscriptions,\n+                    not,\n+                )?;\n                 state_changed = true;\n             }\n-            Event::Lib(lib) => {\n-                state.add_lib(lib);\n-                state.maybe_collect_garbage();\n-                in_flight_libraries -= 1;\n-            }\n-            Event::Msg(msg) => match msg {\n-                Message::Request(req) => {\n-                    if connection.handle_shutdown(&req)? {\n-                        return Ok(());\n-                    };\n-                    on_request(\n-                        state,\n-                        pending_requests,\n-                        pool,\n-                        &task_sender,\n-                        &connection.sender,\n-                        loop_start,\n-                        req,\n-                    )?\n-                }\n-                Message::Notification(not) => {\n-                    on_notification(&connection.sender, state, pending_requests, &mut subs, not)?;\n-                    state_changed = true;\n-                }\n-                Message::Response(resp) => log::error!(\"unexpected response: {:?}\", resp),\n-            },\n-        };\n+            Message::Response(resp) => log::error!(\"unexpected response: {:?}\", resp),\n+        },\n+    };\n \n-        pending_libraries.extend(state.process_changes());\n-        while in_flight_libraries < MAX_IN_FLIGHT_LIBS && !pending_libraries.is_empty() {\n-            let (root, files) = pending_libraries.pop().unwrap();\n-            in_flight_libraries += 1;\n-            let sender = libdata_sender.clone();\n-            pool.execute(move || {\n-                log::info!(\"indexing {:?} ... \", root);\n-                let _p = profile(&format!(\"indexed {:?}\", root));\n-                let data = LibraryData::prepare(root, files);\n-                sender.send(data).unwrap();\n-            });\n-        }\n+    loop_state.pending_libraries.extend(world_state.process_changes());\n+    while loop_state.in_flight_libraries < MAX_IN_FLIGHT_LIBS\n+        && !loop_state.pending_libraries.is_empty()\n+    {\n+        let (root, files) = loop_state.pending_libraries.pop().unwrap();\n+        loop_state.in_flight_libraries += 1;\n+        let sender = libdata_sender.clone();\n+        pool.execute(move || {\n+            log::info!(\"indexing {:?} ... \", root);\n+            let _p = profile(&format!(\"indexed {:?}\", root));\n+            let data = LibraryData::prepare(root, files);\n+            sender.send(data).unwrap();\n+        });\n+    }\n \n-        if send_workspace_notification\n-            && state.roots_to_scan == 0\n-            && pending_libraries.is_empty()\n-            && in_flight_libraries == 0\n-        {\n-            let n_packages: usize = state.workspaces.iter().map(|it| it.n_packages()).sum();\n-            if state.feature_flags().get(\"notifications.workspace-loaded\") {\n-                let msg = format!(\"workspace loaded, {} rust packages\", n_packages);\n-                show_message(req::MessageType::Info, msg, &connection.sender);\n-            }\n-            // Only send the notification first time\n-            send_workspace_notification = false;\n+    if !loop_state.workspace_loaded\n+        && world_state.roots_to_scan == 0\n+        && loop_state.pending_libraries.is_empty()\n+        && loop_state.in_flight_libraries == 0\n+    {\n+        loop_state.workspace_loaded = true;\n+        let n_packages: usize = world_state.workspaces.iter().map(|it| it.n_packages()).sum();\n+        if world_state.feature_flags().get(\"notifications.workspace-loaded\") {\n+            let msg = format!(\"workspace loaded, {} rust packages\", n_packages);\n+            show_message(req::MessageType::Info, msg, &connection.sender);\n         }\n+    }\n \n-        if state_changed {\n-            update_file_notifications_on_threadpool(\n-                pool,\n-                state.snapshot(),\n-                state.options.publish_decorations,\n-                task_sender.clone(),\n-                subs.subscriptions(),\n-            )\n-        }\n+    if state_changed {\n+        update_file_notifications_on_threadpool(\n+            pool,\n+            world_state.snapshot(),\n+            world_state.options.publish_decorations,\n+            task_sender.clone(),\n+            loop_state.subscriptions.subscriptions(),\n+        )\n     }\n+    Ok(())\n }\n \n fn on_task("}, {"sha": "bbeda723c9a44b4e5a3897abe6e934cd50c3a8c5", "filename": "crates/ra_lsp_server/src/main_loop/subscriptions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs?ref=f2a200c1ee8016f47b35e2e13a899fc96286a1eb", "patch": "@@ -1,7 +1,7 @@\n use ra_ide_api::FileId;\n use rustc_hash::FxHashSet;\n \n-#[derive(Default)]\n+#[derive(Default, Debug)]\n pub(crate) struct Subscriptions {\n     subs: FxHashSet<FileId>,\n }"}, {"sha": "6234563f2952895643afa855180cf74384a7f657", "filename": "crates/ra_lsp_server/src/project_model.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f90a88630195a1b6b542b5883295d66dd6c59cef/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a88630195a1b6b542b5883295d66dd6c59cef/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs?ref=f90a88630195a1b6b542b5883295d66dd6c59cef", "patch": "@@ -1,21 +0,0 @@\n-use std::path::PathBuf;\n-\n-use crate::{thread_worker::Worker, Result};\n-\n-pub use ra_project_model::{\n-    CargoWorkspace, Package, ProjectWorkspace, Sysroot, Target, TargetKind,\n-};\n-\n-pub fn workspace_loader(with_sysroot: bool) -> Worker<PathBuf, Result<ProjectWorkspace>> {\n-    Worker::<PathBuf, Result<ProjectWorkspace>>::spawn(\n-        \"workspace loader\",\n-        1,\n-        move |input_receiver, output_sender| {\n-            input_receiver\n-                .into_iter()\n-                .map(|path| ProjectWorkspace::discover_with_sysroot(path.as_path(), with_sysroot))\n-                .try_for_each(|it| output_sender.send(it))\n-                .unwrap()\n-        },\n-    )\n-}"}, {"sha": "68e5c124dc1943f048a83a208a5b8b951fbb9823", "filename": "crates/ra_lsp_server/src/thread_worker.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f90a88630195a1b6b542b5883295d66dd6c59cef/crates%2Fra_lsp_server%2Fsrc%2Fthread_worker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90a88630195a1b6b542b5883295d66dd6c59cef/crates%2Fra_lsp_server%2Fsrc%2Fthread_worker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fthread_worker.rs?ref=f90a88630195a1b6b542b5883295d66dd6c59cef", "patch": "@@ -1,49 +0,0 @@\n-//! Small utility to correctly spawn crossbeam-channel based worker threads.\n-\n-use crossbeam_channel::{bounded, unbounded, Receiver, Sender};\n-\n-/// A wrapper around event-processing thread with automatic shutdown semantics.\n-pub struct Worker<I, O> {\n-    // XXX: field order is significant here.\n-    //\n-    // In Rust, fields are dropped in the declaration order, and we rely on this\n-    // here. We must close input first, so that the  `thread` (who holds the\n-    // opposite side of the channel) noticed shutdown. Then, we must join the\n-    // thread, but we must keep out alive so that the thread does not panic.\n-    //\n-    // Note that a potential problem here is that we might drop some messages\n-    // from receiver on the floor. This is ok for rust-analyzer: we have only a\n-    // single client, so, if we are shutting down, nobody is interested in the\n-    // unfinished work anyway!\n-    sender: Sender<I>,\n-    _thread: jod_thread::JoinHandle<()>,\n-    receiver: Receiver<O>,\n-}\n-\n-impl<I, O> Worker<I, O> {\n-    pub fn spawn<F>(name: &'static str, buf: usize, f: F) -> Worker<I, O>\n-    where\n-        F: FnOnce(Receiver<I>, Sender<O>) + Send + 'static,\n-        I: Send + 'static,\n-        O: Send + 'static,\n-    {\n-        // Set up worker channels in a deadlock-avoiding way. If one sets both input\n-        // and output buffers to a fixed size, a worker might get stuck.\n-        let (sender, input_receiver) = bounded::<I>(buf);\n-        let (output_sender, receiver) = unbounded::<O>();\n-        let _thread = jod_thread::Builder::new()\n-            .name(name.to_string())\n-            .spawn(move || f(input_receiver, output_sender))\n-            .expect(\"failed to spawn a thread\");\n-        Worker { sender, _thread, receiver }\n-    }\n-}\n-\n-impl<I, O> Worker<I, O> {\n-    pub fn sender(&self) -> &Sender<I> {\n-        &self.sender\n-    }\n-    pub fn receiver(&self) -> &Receiver<O> {\n-        &self.receiver\n-    }\n-}"}, {"sha": "e1c5c3343ffefd0cdfe6469557465da381a4d820", "filename": "crates/ra_lsp_server/src/world.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2a200c1ee8016f47b35e2e13a899fc96286a1eb/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fworld.rs?ref=f2a200c1ee8016f47b35e2e13a899fc96286a1eb", "patch": "@@ -11,13 +11,13 @@ use ra_ide_api::{\n     Analysis, AnalysisChange, AnalysisHost, CrateGraph, FeatureFlags, FileId, LibraryData,\n     SourceRootId,\n };\n+use ra_project_model::ProjectWorkspace;\n use ra_vfs::{LineEndings, RootEntry, Vfs, VfsChange, VfsFile, VfsRoot, VfsTask};\n use ra_vfs_glob::{Glob, RustPackageFilterBuilder};\n use relative_path::RelativePathBuf;\n \n use crate::{\n     main_loop::pending_requests::{CompletedRequest, LatestRequests},\n-    project_model::ProjectWorkspace,\n     LspError, Result,\n };\n \n@@ -35,6 +35,7 @@ pub struct Options {\n #[derive(Debug)]\n pub struct WorldState {\n     pub options: Options,\n+    //FIXME: this belongs to `LoopState` rather than to `WorldState`\n     pub roots_to_scan: usize,\n     pub roots: Vec<PathBuf>,\n     pub workspaces: Arc<Vec<ProjectWorkspace>>,"}]}