{"sha": "57e5cde3a2e19c8bd6616b273421c09b075b7222", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3ZTVjZGUzYTJlMTljOGJkNjYxNmIyNzM0MjFjMDliMDc1YjcyMjI=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-29T01:54:05Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-29T01:54:56Z"}, "message": "Comments and cleanup.", "tree": {"sha": "9ddf1a22ad11ecf0b5b916291f0ee14e9c05e2a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ddf1a22ad11ecf0b5b916291f0ee14e9c05e2a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57e5cde3a2e19c8bd6616b273421c09b075b7222", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57e5cde3a2e19c8bd6616b273421c09b075b7222", "html_url": "https://github.com/rust-lang/rust/commit/57e5cde3a2e19c8bd6616b273421c09b075b7222", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57e5cde3a2e19c8bd6616b273421c09b075b7222/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "684c0dc494820aa0189526278bdce7290400872e", "url": "https://api.github.com/repos/rust-lang/rust/commits/684c0dc494820aa0189526278bdce7290400872e", "html_url": "https://github.com/rust-lang/rust/commit/684c0dc494820aa0189526278bdce7290400872e"}], "stats": {"total": 129, "additions": 95, "deletions": 34}, "files": [{"sha": "d35534205baa56b26e2ab9e141c65a572fac3753", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 95, "deletions": 34, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/57e5cde3a2e19c8bd6616b273421c09b075b7222/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57e5cde3a2e19c8bd6616b273421c09b075b7222/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=57e5cde3a2e19c8bd6616b273421c09b075b7222", "patch": "@@ -166,7 +166,6 @@ type local_ctxt =\n \n // Types used for llself.\n type val_self_pair = rec(ValueRef v, ty::t t);\n-\n type ty_self_pair = tup(TypeRef, ty::t);\n \n \n@@ -719,22 +718,22 @@ fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n                    &option::t[TypeRef] obj_self, &vec[ty::arg] inputs,\n                    &ty::t output, uint ty_param_count) -> TypeRef {\n     let vec[TypeRef] atys = [];\n-    // Arg 0: Output pointer.\n \n+    // Arg 0: Output pointer.\n     if (ty::type_has_dynamic_size(cx.tcx, output)) {\n         atys += [T_typaram_ptr(cx.tn)];\n     } else { atys += [T_ptr(type_of_inner(cx, sp, output))]; }\n-    // Arg 1: task pointer.\n \n+    // Arg 1: task pointer.\n     atys += [T_taskptr(cx.tn)];\n-    // Arg 2: Env (closure-bindings / self-obj)\n \n+    // Arg 2: Env (closure-bindings / self-obj)\n     alt (obj_self) {\n         case (some(?t)) { assert (t as int != 0); atys += [t]; }\n         case (_) { atys += [T_opaque_closure_ptr(cx.tn)]; }\n     }\n-    // Args >3: ty params, if not acquired via capture...\n \n+    // Args >3: ty params, if not acquired via capture...\n     if (obj_self == none[TypeRef]) {\n         auto i = 0u;\n         while (i < ty_param_count) {\n@@ -746,16 +745,15 @@ fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n         // If it's an iter, the 'output' type of the iter is actually the\n         // *input* type of the function we're given as our iter-block\n         // argument.\n-\n         atys +=\n             [T_fn_pair(cx.tn,\n                        type_of_fn_full(cx, sp, ast::proto_fn, none[TypeRef],\n                                        [rec(mode=ty::mo_alias(false),\n                                             ty=output)], ty::mk_nil(cx.tcx),\n                                        0u))];\n     }\n-    // ... then explicit args.\n \n+    // ... then explicit args.\n     atys += type_of_explicit_args(cx, sp, inputs);\n     ret T_fn(atys, llvm::LLVMVoidType());\n }\n@@ -5102,37 +5100,79 @@ fn trans_bind_thunk(&@local_ctxt cx, &span sp, &ty::t incoming_fty,\n                     &ty::t outgoing_fty, &vec[option::t[@ast::expr]] args,\n                     &ty::t closure_ty, &vec[ty::t] bound_tys,\n                     uint ty_param_count) -> ValueRef {\n-    // Construct a thunk-call with signature incoming_fty, and that copies\n-    // args forward into a call to outgoing_fty:\n \n+    // Here we're not necessarily constructing a thunk in the sense of\n+    // \"function with no arguments\".  The result of compiling 'bind f(foo,\n+    // bar, baz)' would be a thunk that, when called, applies f to those\n+    // arguments and returns the result.  But we're stretching the meaning of\n+    // the word \"thunk\" here to also mean the result of compiling, say, 'bind\n+    // f(foo, _, baz)', or any other bind expression that binds f and leaves\n+    // some (or all) of the arguments unbound.\n+\n+    // Here, 'incoming_fty' is the type of the entire bind expression, while\n+    // 'outgoing_fty' is the type of the function that is having some of its\n+    // arguments bound.  If f is a function that takes three arguments of type\n+    // int and returns int, and we're translating, say, 'bind f(3, _, 5)',\n+    // then outgoing_fty is the type of f, which is (int, int, int) -> int,\n+    // and incoming_fty is the type of 'bind f(3, _, 5)', which is int -> int.\n+\n+    // Once translated, the entire bind expression will be the call f(foo,\n+    // bar, baz) wrapped in a (so-called) thunk that takes 'bar' as its\n+    // argument and that has bindings of 'foo' to 3 and 'baz' to 5 and a\n+    // pointer to 'f' all saved in its environment.  So, our job is to\n+    // construct and return that thunk.\n+\n+    // Give the thunk a name, type, and value.\n     let str s =\n         mangle_internal_name_by_path_and_seq(cx.ccx, cx.path, \"thunk\");\n     let TypeRef llthunk_ty =\n         get_pair_fn_ty(type_of(cx.ccx, sp, incoming_fty));\n     let ValueRef llthunk =\n         decl_internal_fastcall_fn(cx.ccx.llmod, s, llthunk_ty);\n+\n+    // Create a new function context and block context for the thunk, and hold\n+    // onto a pointer to the first block in the function for later use.\n     auto fcx = new_fn_ctxt(cx, sp, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n     auto llclosure_ptr_ty =\n         type_of(cx.ccx, sp, ty::mk_imm_box(cx.ccx.tcx, closure_ty));\n     auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n+\n+    // \"target\", in this context, means the function that's having some of its\n+    // arguments bound and that will be called inside the thunk we're\n+    // creating.  (In our running example, target is the function f.)  Pick\n+    // out the pointer to the target function from the environment.\n     auto lltarget =\n         GEP_tup_like(bcx, closure_ty, llclosure,\n                      [0, abi::box_rc_field_body, abi::closure_elt_target]);\n     bcx = lltarget.bcx;\n+\n+    // And then, pick out the target function's own environment.  That's what\n+    // we'll use as the environment the thunk gets.\n     auto lltargetclosure =\n         bcx.build.GEP(lltarget.val, [C_int(0), C_int(abi::fn_field_box)]);\n     lltargetclosure = bcx.build.Load(lltargetclosure);\n+\n+    // Get f's return type, which will also be the return type of the entire\n+    // bind expression.\n     auto outgoing_ret_ty = ty::ty_fn_ret(cx.ccx.tcx, outgoing_fty);\n+\n+    // Get the types of the arguments to f.\n     auto outgoing_args = ty::ty_fn_args(cx.ccx.tcx, outgoing_fty);\n+\n+    // The 'llretptr' that will arrive in the thunk we're creating also needs\n+    // to be the correct size.  Cast it to the size of f's return type, if\n+    // necessary.\n     auto llretptr = fcx.llretptr;\n     if (ty::type_has_dynamic_size(cx.ccx.tcx, outgoing_ret_ty)) {\n         llretptr = bcx.build.PointerCast(llretptr, T_typaram_ptr(cx.ccx.tn));\n     }\n+\n+    // Set up the three implicit arguments to the thunk.\n     let vec[ValueRef] llargs = [llretptr, fcx.lltaskptr, lltargetclosure];\n-    // Copy in the type parameters.\n \n+    // Copy in the type parameters.\n     let uint i = 0u;\n     while (i < ty_param_count) {\n         auto lltyparam_ptr =\n@@ -5145,6 +5185,7 @@ fn trans_bind_thunk(&@local_ctxt cx, &span sp, &ty::t incoming_fty,\n         fcx.lltydescs += [td];\n         i += 1u;\n     }\n+\n     let uint a = 3u; // retptr, task ptr, env come first\n \n     let int b = 0;\n@@ -5199,9 +5240,9 @@ fn trans_bind_thunk(&@local_ctxt cx, &span sp, &ty::t incoming_fty,\n \n     auto lltargetfn =\n         bcx.build.GEP(lltarget.val, [C_int(0), C_int(abi::fn_field_code)]);\n+\n     // Cast the outgoing function to the appropriate type (see the comments in\n     // trans_bind below for why this is necessary).\n-\n     auto lltargetty =\n         type_of_fn(bcx.fcx.lcx.ccx, sp,\n                    ty::ty_fn_proto(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n@@ -5227,8 +5268,8 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                 case (some(?e)) { vec::push[@ast::expr](bound, e); }\n             }\n         }\n-        // Figure out which tydescs we need to pass, if any.\n \n+        // Figure out which tydescs we need to pass, if any.\n         let ty::t outgoing_fty;\n         let vec[ValueRef] lltydescs;\n         alt (f_res.generic) {\n@@ -5244,15 +5285,15 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n         }\n         auto ty_param_count = vec::len[ValueRef](lltydescs);\n         if (vec::len[@ast::expr](bound) == 0u && ty_param_count == 0u) {\n-            // Trivial 'binding': just return the static pair-ptr.\n \n+            // Trivial 'binding': just return the static pair-ptr.\n             ret f_res.res;\n         } else {\n             auto bcx = f_res.res.bcx;\n             auto pair_t = node_type(cx.fcx.lcx.ccx, cx.sp, id);\n             auto pair_v = alloca(bcx, pair_t);\n-            // Translate the bound expressions.\n \n+            // Translate the bound expressions.\n             let vec[ty::t] bound_tys = [];\n             let vec[ValueRef] bound_vals = [];\n             auto i = 0u;\n@@ -5264,33 +5305,54 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                                  ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n                 i += 1u;\n             }\n+\n             // Synthesize a closure type.\n \n+            // First, synthesize a tuple type containing the types of all the\n+            // bound expressions.\n+            // bindings_ty = [bound_ty1, bound_ty2, ...]\n             let ty::t bindings_ty =\n                 ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, bound_tys);\n+\n             // NB: keep this in sync with T_closure_ptr; we're making\n             // a ty::t structure that has the same \"shape\" as the LLVM type\n             // it constructs.\n \n+            // Make a vector that contains ty_param_count copies of tydesc_ty.\n+            // (We'll need room for that many tydescs in the closure.)\n             let ty::t tydesc_ty = ty::mk_type(cx.fcx.lcx.ccx.tcx);\n             let vec[ty::t] captured_tys =\n                 vec::init_elt[ty::t](tydesc_ty, ty_param_count);\n+\n+            // Get all the types we've got (some of which we synthesized\n+            // ourselves) into a vector.  The whole things ends up looking\n+            // like:\n+\n+            // closure_tys = [tydesc_ty, outgoing_fty, [bound_ty1, bound_ty2,\n+            // ...], [tydesc_ty, tydesc_ty, ...]]\n             let vec[ty::t] closure_tys =\n                 [tydesc_ty, outgoing_fty, bindings_ty,\n                  ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, captured_tys)];\n+\n+            // Finally, synthesize a type for that whole vector.\n             let ty::t closure_ty =\n                 ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx, closure_tys);\n+\n+            // Allocate a box that can hold something closure-sized, including\n+            // space for a refcount.\n             auto r = trans_malloc_boxed(bcx, closure_ty);\n             auto box = r.val;\n             bcx = r.bcx;\n+\n+            // Grab onto the refcount and body parts of the box we allocated.\n             auto rc =\n                 bcx.build.GEP(box,\n                               [C_int(0), C_int(abi::box_rc_field_refcnt)]);\n             auto closure =\n                 bcx.build.GEP(box, [C_int(0), C_int(abi::box_rc_field_body)]);\n             bcx.build.Store(C_int(1), rc);\n-            // Store bindings tydesc.\n \n+            // Store bindings tydesc.\n             auto bound_tydesc =\n                 bcx.build.GEP(closure,\n                               [C_int(0), C_int(abi::closure_elt_tydesc)]);\n@@ -5300,22 +5362,22 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n             bcx = bindings_tydesc.bcx;\n             bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n+\n             // Determine the LLVM type for the outgoing function type. This\n             // may be different from the type returned by trans_malloc_boxed()\n             // since we have more information than that function does;\n             // specifically, we know how many type descriptors the outgoing\n             // function has, which type_of() doesn't, as only we know which\n             // item the function refers to.\n-\n             auto llfnty =\n                 type_of_fn(bcx.fcx.lcx.ccx, cx.sp,\n                            ty::ty_fn_proto(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n                            ty::ty_fn_args(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n                            ty::ty_fn_ret(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n                            ty_param_count);\n             auto llclosurety = T_ptr(T_fn_pair(bcx.fcx.lcx.ccx.tn, llfnty));\n-            // Store thunk-target.\n \n+            // Store thunk-target.\n             auto bound_target =\n                 bcx.build.GEP(closure,\n                               [C_int(0), C_int(abi::closure_elt_target)]);\n@@ -5334,9 +5396,9 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                 bcx = copy_val(bcx, INIT, bound, v, bound_tys.(i)).bcx;\n                 i += 1u;\n             }\n+\n             // If necessary, copy tydescs describing type parameters into the\n             // appropriate slot in the closure.\n-\n             alt (f_res.generic) {\n                 case (none) {/* nothing to do */ }\n                 case (some(?ginfo)) {\n@@ -5356,17 +5418,19 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n                     outgoing_fty = ginfo.item_type;\n                 }\n             }\n-            // Make thunk and store thunk-ptr in outer pair's code slot.\n \n+            // Make thunk and store thunk-ptr in outer pair's code slot.\n             auto pair_code =\n                 bcx.build.GEP(pair_v, [C_int(0), C_int(abi::fn_field_code)]);\n+            // The type of the entire bind expression.\n             let ty::t pair_ty = node_id_type(cx.fcx.lcx.ccx, id);\n+\n             let ValueRef llthunk =\n                 trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty,\n                                  args, closure_ty, bound_tys, ty_param_count);\n             bcx.build.Store(llthunk, pair_code);\n-            // Store box ptr in outer pair's box slot.\n \n+            // Store box ptr in outer pair's box slot.\n             auto tn = bcx.fcx.lcx.ccx.tn;\n             auto pair_box =\n                 bcx.build.GEP(pair_v, [C_int(0), C_int(abi::fn_field_box)]);\n@@ -5533,12 +5597,10 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n     alt (f_res.llobj) {\n         case (some(_)) {\n             // It's a vtbl entry.\n-\n             faddr = f_res.res.bcx.build.Load(faddr);\n         }\n         case (none) {\n             // It's a closure.\n-\n             auto bcx = f_res.res.bcx;\n             auto pair = faddr;\n             faddr =\n@@ -5553,7 +5615,6 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n     alt (f_res.method_ty) {\n         case (some(?meth)) {\n             // self-call\n-\n             fn_ty = meth;\n         }\n         case (_) { fn_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, f); }\n@@ -7452,8 +7513,8 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n             option::t[ty_self_pair] ty_self, &vec[ast::ty_param] ty_params,\n             ast::node_id id) {\n     set_uwtable(llfndecl);\n-    // Set up arguments to the function.\n \n+    // Set up arguments to the function.\n     auto fcx = new_fn_ctxt(cx, sp, llfndecl);\n     create_llargs_for_fn_args(fcx, f.proto, ty_self,\n                               ty::ret_ty_of_fn(cx.ccx.tcx, id), \n@@ -7465,18 +7526,18 @@ fn trans_fn(@local_ctxt cx, &span sp, &ast::_fn f, ValueRef llfndecl,\n     }\n     auto arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n     copy_args_to_allocas(fcx, f.decl.inputs, arg_tys);\n+\n     // Create the first basic block in the function and keep a handle on it to\n     //  pass to finish_fn later.\n-\n     auto bcx = new_top_block_ctxt(fcx);\n     add_cleanups_for_args(bcx, f.decl.inputs, arg_tys);\n     auto lltop = bcx.llbb;\n     auto block_ty = node_id_type(cx.ccx, f.body.node.id);\n+\n     // This call to trans_block is the place where we bridge between\n     // translation calls that don't have a return value (trans_crate,\n     // trans_mod, trans_item, trans_obj, et cetera) and those that do\n     // (trans_block, trans_expr, et cetera).\n-\n     auto rslt =\n         if (!ty::type_is_nil(cx.ccx.tcx, block_ty) &&\n                 !ty::type_is_bot(cx.ccx.tcx, block_ty)) {\n@@ -7564,7 +7625,6 @@ fn trans_dtor(@local_ctxt cx, TypeRef llself_ty, ty::t self_ty,\n     ret llfn;\n }\n \n-\n // trans_obj: creates an LLVM function that is the object constructor for the\n // object being translated.\n fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n@@ -7587,45 +7647,46 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n             [rec(mode=ast::alias(false), ty=f.ty, ident=f.ident, id=f.id)];\n     }\n     auto fcx = new_fn_ctxt(cx, sp, llctor_decl);\n-    // Both regular arguments and type parameters are handled here.\n \n+    // Both regular arguments and type parameters are handled here.\n     create_llargs_for_fn_args(fcx, ast::proto_fn, none[ty_self_pair],\n                               ty::ret_ty_of_fn(ccx.tcx, ctor_id),\n                               fn_args, ty_params);\n     let vec[ty::arg] arg_tys = arg_tys_of_fn(ccx, ctor_id);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n+\n     //  Create the first block context in the function and keep a handle on it\n     //  to pass to finish_fn later.\n-\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n+\n     // Pick up the type of this object by looking at our own output type, that\n     // is, the output type of the object constructor we're building.\n-\n     auto self_ty = ty::ret_ty_of_fn(ccx.tcx, ctor_id);\n     auto llself_ty = type_of(ccx, sp, self_ty);\n+\n     // Set up the two-word pair that we're going to return from the object\n     // constructor we're building.  The two elements of this pair will be a\n     // vtable pointer and a body pointer.  (llretptr already points to the\n     // place where this two-word pair should go; it was pre-allocated by the\n     // caller of the function.)\n-\n     auto pair = bcx.fcx.llretptr;\n+\n     // Grab onto the first and second elements of the pair.\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n     // of 'pair'.\n-\n     auto pair_vtbl =\n         bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_vtbl)]);\n     auto pair_box =\n         bcx.build.GEP(pair, [C_int(0), C_int(abi::obj_field_box)]);\n+\n     // Make a vtable for this object: a static array of pointers to functions.\n     // It will be located in the read-only memory of the executable we're\n     // creating and will contain ValueRefs for all of this object's methods.\n     // create_vtbl returns a pointer to the vtable, which we store.\n-\n     auto vtbl = create_vtbl(cx, llself_ty, self_ty, ob, ty_params, none);\n     bcx.build.Store(vtbl, pair_vtbl);\n+\n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n     // typarams, and fields.\n@@ -7634,10 +7695,10 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // (Pertains to issues #538/#539/#540/#543.)\n \n     let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n+\n     // FIXME: we should probably also allocate a box for empty objs that have\n     // a dtor, since otherwise they are never dropped, and the dtor never\n     // runs.\n-\n     if (vec::len[ast::ty_param](ty_params) == 0u &&\n             vec::len[ty::arg](arg_tys) == 0u) {\n         // If the object we're translating has no fields or type parameters,"}]}