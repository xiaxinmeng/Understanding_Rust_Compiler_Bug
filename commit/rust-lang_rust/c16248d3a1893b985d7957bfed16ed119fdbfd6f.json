{"sha": "c16248d3a1893b985d7957bfed16ed119fdbfd6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNjI0OGQzYTE4OTNiOTg1ZDc5NTdiZmVkMTZlZDExOWZkYmZkNmY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T02:19:16Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T17:15:21Z"}, "message": "typeck/pat.rs: extract `check_pat_ident`.", "tree": {"sha": "f787e1956baf8de33a456568b7dcab9bf4a302cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f787e1956baf8de33a456568b7dcab9bf4a302cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c16248d3a1893b985d7957bfed16ed119fdbfd6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c16248d3a1893b985d7957bfed16ed119fdbfd6f", "html_url": "https://github.com/rust-lang/rust/commit/c16248d3a1893b985d7957bfed16ed119fdbfd6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c16248d3a1893b985d7957bfed16ed119fdbfd6f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4afae943f642be2909c649997f663b384115237", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4afae943f642be2909c649997f663b384115237", "html_url": "https://github.com/rust-lang/rust/commit/d4afae943f642be2909c649997f663b384115237"}], "stats": {"total": 110, "additions": 63, "deletions": 47}, "files": [{"sha": "fda5d3a2ecd4ab0c0cf1f1a2352145068c882e25", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 63, "deletions": 47, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c16248d3a1893b985d7957bfed16ed119fdbfd6f/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c16248d3a1893b985d7957bfed16ed119fdbfd6f/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=c16248d3a1893b985d7957bfed16ed119fdbfd6f", "patch": "@@ -77,53 +77,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             PatKind::Binding(ba, var_id, _, ref sub) => {\n-                let bm = if ba == hir::BindingAnnotation::Unannotated {\n-                    def_bm\n-                } else {\n-                    ty::BindingMode::convert(ba)\n-                };\n-                self.inh\n-                    .tables\n-                    .borrow_mut()\n-                    .pat_binding_modes_mut()\n-                    .insert(pat.hir_id, bm);\n-                debug!(\"check_pat_walk: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n-                let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n-                match bm {\n-                    ty::BindByReference(mutbl) => {\n-                        // If the binding is like\n-                        //     ref x | ref const x | ref mut x\n-                        // then `x` is assigned a value of type `&M T` where M is the mutability\n-                        // and T is the expected type.\n-                        let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n-                        let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n-                        let region_ty = tcx.mk_ref(region_var, mt);\n-\n-                        // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)` is\n-                        // required. However, we use equality, which is stronger. See (*) for\n-                        // an explanation.\n-                        self.demand_eqtype_pat(pat.span, region_ty, local_ty, discrim_span);\n-                    }\n-                    // Otherwise, the type of x is the expected type `T`.\n-                    ty::BindByValue(_) => {\n-                        // As above, `T <: typeof(x)` is required, but we\n-                        // use equality, see (*) below.\n-                        self.demand_eqtype_pat(pat.span, expected, local_ty, discrim_span);\n-                    }\n-                }\n-\n-                // If there are multiple arms, make sure they all agree on\n-                // what the type of the binding `x` ought to be.\n-                if var_id != pat.hir_id {\n-                    let vt = self.local_ty(pat.span, var_id).decl_ty;\n-                    self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n-                }\n-\n-                if let Some(ref p) = *sub {\n-                    self.check_pat_walk(&p, expected, def_bm, discrim_span);\n-                }\n-\n-                local_ty\n+                let sub = sub.as_deref();\n+                self.check_pat_ident(pat, ba, var_id, sub, expected, def_bm, discrim_span)\n             }\n             PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n                 self.check_pat_tuple_struct(\n@@ -611,6 +566,67 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Some(common_type)\n     }\n \n+    fn check_pat_ident(\n+        &self,\n+        pat: &hir::Pat,\n+        ba: hir::BindingAnnotation,\n+        var_id: hir::HirId,\n+        sub: Option<&'tcx hir::Pat>,\n+        expected: Ty<'tcx>,\n+        def_bm: ty::BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        // Determine the binding mode...\n+        let bm = match ba {\n+            hir::BindingAnnotation::Unannotated => def_bm,\n+            _ => ty::BindingMode::convert(ba),\n+        };\n+        // ...and store it in a side table:\n+        self.inh\n+            .tables\n+            .borrow_mut()\n+            .pat_binding_modes_mut()\n+            .insert(pat.hir_id, bm);\n+\n+        debug!(\"check_pat_ident: pat.hir_id={:?} bm={:?}\", pat.hir_id, bm);\n+\n+        let local_ty = self.local_ty(pat.span, pat.hir_id).decl_ty;\n+        let eq_ty = match bm {\n+            ty::BindByReference(mutbl) => {\n+                // If the binding is like `ref x | ref const x | ref mut x`\n+                // then `x` is assigned a value of type `&M T` where M is the\n+                // mutability and T is the expected type.\n+                let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n+                let mt = ty::TypeAndMut { ty: expected, mutbl };\n+                let region_ty = self.tcx.mk_ref(region_var, mt);\n+\n+                // `x` is assigned a value of type `&M T`, hence `&M T <: typeof(x)`\n+                // is required. However, we use equality, which is stronger.\n+                // See (*) for an explanation.\n+                region_ty\n+            }\n+            // Otherwise, the type of x is the expected type `T`.\n+            ty::BindByValue(_) => {\n+                // As above, `T <: typeof(x)` is required, but we use equality, see (*) below.\n+                expected\n+            }\n+        };\n+        self.demand_eqtype_pat(pat.span, eq_ty, local_ty, discrim_span);\n+\n+        // If there are multiple arms, make sure they all agree on\n+        // what the type of the binding `x` ought to be.\n+        if var_id != pat.hir_id {\n+            let vt = self.local_ty(pat.span, var_id).decl_ty;\n+            self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n+        }\n+\n+        if let Some(p) = sub {\n+            self.check_pat_walk(&p, expected, def_bm, discrim_span);\n+        }\n+\n+        local_ty\n+    }\n+\n     fn borrow_pat_suggestion(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,"}]}