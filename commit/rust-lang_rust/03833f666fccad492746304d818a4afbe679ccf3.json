{"sha": "03833f666fccad492746304d818a4afbe679ccf3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzODMzZjY2NmZjY2FkNDkyNzQ2MzA0ZDgxOGE0YWZiZTY3OWNjZjM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-24T09:45:24Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-29T08:45:18Z"}, "message": "differentiate between logic bugs and optimizable expressions", "tree": {"sha": "3de6f1df294dbd843e216c96a8b8e3c896fc482c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3de6f1df294dbd843e216c96a8b8e3c896fc482c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03833f666fccad492746304d818a4afbe679ccf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03833f666fccad492746304d818a4afbe679ccf3", "html_url": "https://github.com/rust-lang/rust/commit/03833f666fccad492746304d818a4afbe679ccf3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03833f666fccad492746304d818a4afbe679ccf3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "288ea799637dee4b2250069af41b44a8facaa52f", "url": "https://api.github.com/repos/rust-lang/rust/commits/288ea799637dee4b2250069af41b44a8facaa52f", "html_url": "https://github.com/rust-lang/rust/commit/288ea799637dee4b2250069af41b44a8facaa52f"}], "stats": {"total": 81, "additions": 72, "deletions": 9}, "files": [{"sha": "49371de5c9df9a1e46ecfbd110c773cc4707b2c4", "filename": "src/booleans.rs", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/03833f666fccad492746304d818a4afbe679ccf3/src%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03833f666fccad492746304d818a4afbe679ccf3/src%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbooleans.rs?ref=03833f666fccad492746304d818a4afbe679ccf3", "patch": "@@ -10,18 +10,30 @@ use utils::{span_lint_and_then, in_macro, snippet_opt, SpanlessEq};\n ///\n /// **Known problems:** Ignores short circuting behavior, bitwise and/or and xor. Ends up suggesting things like !(a == b)\n ///\n-/// **Example:** `if a && b || a` should be `if a`\n+/// **Example:** `if a && true` should be `if a`\n declare_lint! {\n     pub NONMINIMAL_BOOL, Allow,\n     \"checks for boolean expressions that can be written more concisely\"\n }\n \n+/// **What it does:** This lint checks for boolean expressions that contain terminals that can be eliminated\n+///\n+/// **Why is this bad?** This is most likely a logic bug\n+///\n+/// **Known problems:** Ignores short circuiting behavior\n+///\n+/// **Example:** The `b` in `if a && b || a` is unnecessary because the expression is equivalent to `if a`\n+declare_lint! {\n+    pub LOGIC_BUG, Warn,\n+    \"checks for boolean expressions that contain terminals which can be eliminated\"\n+}\n+\n #[derive(Copy,Clone)]\n pub struct NonminimalBool;\n \n impl LintPass for NonminimalBool {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(NONMINIMAL_BOOL)\n+        lint_array!(NONMINIMAL_BOOL, LOGIC_BUG)\n     }\n }\n \n@@ -168,13 +180,31 @@ fn simple_negate(b: Bool) -> Bool {\n     }\n }\n \n+fn terminal_stats(b: &Bool) -> [usize; 32] {\n+    fn recurse(b: &Bool, stats: &mut [usize; 32]) {\n+        match *b {\n+            True | False => {},\n+            Not(ref inner) => recurse(inner, stats),\n+            And(ref v) | Or(ref v) => for inner in v {\n+                recurse(inner, stats)\n+            },\n+            Term(n) => stats[n as usize] += 1,\n+        }\n+    }\n+    use quine_mc_cluskey::Bool::*;\n+    let mut stats = [0; 32];\n+    recurse(b, &mut stats);\n+    stats\n+}\n+\n impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n     fn bool_expr(&self, e: &Expr) {\n         let mut h2q = Hir2Qmm {\n             terminals: Vec::new(),\n             cx: self.0,\n         };\n         if let Ok(expr) = h2q.run(e) {\n+            let stats = terminal_stats(&expr);\n             let mut simplified = expr.simplify();\n             for simple in Bool::Not(Box::new(expr.clone())).simplify() {\n                 let simple_negated = simple_negate(simple);\n@@ -184,11 +214,40 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                 simplified.push(simple_negated);\n             }\n             if !simplified.iter().any(|s| *s == expr) {\n-                span_lint_and_then(self.0, NONMINIMAL_BOOL, e.span, \"this boolean expression can be simplified\", |db| {\n-                    for suggestion in &simplified {\n-                        db.span_suggestion(e.span, \"try\", suggest(self.0, suggestion, &h2q.terminals));\n+                let mut improvements = Vec::new();\n+                'simplified: for suggestion in &simplified {\n+                    let simplified_stats = terminal_stats(&suggestion);\n+                    let mut improvement = false;\n+                    for i in 0..32 {\n+                        // ignore any \"simplifications\" that end up requiring a terminal more often than in the original expression\n+                        if stats[i] < simplified_stats[i] {\n+                            continue 'simplified;\n+                        }\n+                        // if the number of occurrences of a terminal decreases, this expression is a candidate for improvement\n+                        if stats[i] >= simplified_stats[i] {\n+                            improvement = true;\n+                        }\n+                        if stats[i] != 0 && simplified_stats[i] == 0 {\n+                            span_lint_and_then(self.0, LOGIC_BUG, e.span, \"this boolean expression contains a logic bug\", |db| {\n+                                db.span_help(h2q.terminals[i].span, \"this expression can be optimized out by applying boolean operations to the outer expression\");\n+                                db.span_suggestion(e.span, \"it would look like the following\", suggest(self.0, suggestion, &h2q.terminals));\n+                            });\n+                            // don't also lint `NONMINIMAL_BOOL`\n+                            improvements.clear();\n+                            break 'simplified;\n+                        }\n                     }\n-                });\n+                    if improvement {\n+                        improvements.push(suggestion);\n+                    }\n+                }\n+                if !improvements.is_empty() {\n+                    span_lint_and_then(self.0, NONMINIMAL_BOOL, e.span, \"this boolean expression can be simplified\", |db| {\n+                        for suggestion in &improvements {\n+                            db.span_suggestion(e.span, \"try\", suggest(self.0, suggestion, &h2q.terminals));\n+                        }\n+                    });\n+                }\n             }\n         }\n     }"}, {"sha": "31c160980fc6ace14cab1389b3d7be4ae4ec9b57", "filename": "tests/compile-fail/booleans.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/03833f666fccad492746304d818a4afbe679ccf3/tests%2Fcompile-fail%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03833f666fccad492746304d818a4afbe679ccf3/tests%2Fcompile-fail%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fbooleans.rs?ref=03833f666fccad492746304d818a4afbe679ccf3", "patch": "@@ -1,13 +1,15 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n-#![deny(nonminimal_bool)]\n+#![deny(nonminimal_bool, logic_bug)]\n \n #[allow(unused)]\n fn main() {\n     let a: bool = unimplemented!();\n     let b: bool = unimplemented!();\n-    let _ = a && b || a; //~ ERROR this boolean expression can be simplified\n+    let _ = a && b || a; //~ ERROR this boolean expression contains a logic bug\n     //|~ HELP for further information visit\n+    //|~ HELP this expression can be optimized out\n+    //|~ HELP it would look like the following\n     //|~ SUGGESTION let _ = a;\n     let _ = !(a && b); //~ ERROR this boolean expression can be simplified\n     //|~ HELP for further information visit\n@@ -22,8 +24,10 @@ fn main() {\n     //|~ HELP for further information visit\n     //|~ SUGGESTION let _ = a;\n \n-    let _ = false && a; //~ ERROR this boolean expression can be simplified\n+    let _ = false && a; //~ ERROR this boolean expression contains a logic bug\n     //|~ HELP for further information visit\n+    //|~ HELP this expression can be optimized out\n+    //|~ HELP it would look like the following\n     //|~ SUGGESTION let _ = false;\n \n     let _ = false || a; //~ ERROR this boolean expression can be simplified"}]}