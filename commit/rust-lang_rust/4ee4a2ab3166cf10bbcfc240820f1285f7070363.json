{"sha": "4ee4a2ab3166cf10bbcfc240820f1285f7070363", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlZTRhMmFiMzE2NmNmMTBiYmNmYzI0MDgyMGYxMjg1ZjcwNzAzNjM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-18T01:44:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-18T02:16:00Z"}, "message": "borrow from @[] vectors (cc #2797)", "tree": {"sha": "4502865194eace0a93ec08652d13c51a12a3e230", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4502865194eace0a93ec08652d13c51a12a3e230"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ee4a2ab3166cf10bbcfc240820f1285f7070363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ee4a2ab3166cf10bbcfc240820f1285f7070363", "html_url": "https://github.com/rust-lang/rust/commit/4ee4a2ab3166cf10bbcfc240820f1285f7070363", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ee4a2ab3166cf10bbcfc240820f1285f7070363/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb5e2ba60addba150224b0320300c0a528b69b22", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb5e2ba60addba150224b0320300c0a528b69b22", "html_url": "https://github.com/rust-lang/rust/commit/bb5e2ba60addba150224b0320300c0a528b69b22"}], "stats": {"total": 374, "additions": 224, "deletions": 150}, "files": [{"sha": "763c831265fcb515989a41f962aab49e4572473a", "filename": "src/rustc/middle/borrowck.rs", "status": "modified", "additions": 213, "deletions": 145, "changes": 358, "blob_url": "https://github.com/rust-lang/rust/blob/4ee4a2ab3166cf10bbcfc240820f1285f7070363/src%2Frustc%2Fmiddle%2Fborrowck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ee4a2ab3166cf10bbcfc240820f1285f7070363/src%2Frustc%2Fmiddle%2Fborrowck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck.rs?ref=4ee4a2ab3166cf10bbcfc240820f1285f7070363", "patch": "@@ -1,149 +1,217 @@\n /*!\n- * # Borrow check\n- *\n- * This pass is in job of enforcing *memory safety* and *purity*.  As\n- * memory safety is by far the more complex topic, I'll focus on that in\n- * this description, but purity will be covered later on. In the context\n- * of Rust, memory safety means three basic things:\n- *\n- * - no writes to immutable memory;\n- * - all pointers point to non-freed memory;\n- * - all pointers point to memory of the same type as the pointer.\n- *\n- * The last point might seem confusing: after all, for the most part,\n- * this condition is guaranteed by the type check.  However, there are\n- * two cases where the type check effectively delegates to borrow check.\n- *\n- * The first case has to do with enums.  If there is a pointer to the\n- * interior of an enum, and the enum is in a mutable location (such as a\n- * local variable or field declared to be mutable), it is possible that\n- * the user will overwrite the enum with a new value of a different\n- * variant, and thus effectively change the type of the memory that the\n- * pointer is pointing at.\n- *\n- * The second case has to do with mutability.  Basically, the type\n- * checker has only a limited understanding of mutability.  It will allow\n- * (for example) the user to get an immutable pointer with the address of\n- * a mutable local variable.  It will also allow a `@mut T` or `~mut T`\n- * pointer to be borrowed as a `&r.T` pointer.  These seeming oversights\n- * are in fact intentional; they allow the user to temporarily treat a\n- * mutable value as immutable.  It is up to the borrow check to guarantee\n- * that the value in question is not in fact mutated during the lifetime\n- * `r` of the reference.\n- *\n- * # Summary of the safety check\n- *\n- * In order to enforce mutability, the borrow check has three tricks up\n- * its sleeve.\n- *\n- * First, data which is uniquely tied to the current stack frame (that'll\n- * be defined shortly) is tracked very precisely.  This means that, for\n- * example, if an immutable pointer to a mutable local variable is\n- * created, the borrowck will simply check for assignments to that\n- * particular local variable: no other memory is affected.\n- *\n- * Second, if the data is not uniquely tied to the stack frame, it may\n- * still be possible to ensure its validity by rooting garbage collected\n- * pointers at runtime.  For example, if there is a mutable local\n- * variable `x` of type `@T`, and its contents are borrowed with an\n- * expression like `&*x`, then the value of `x` will be rooted (today,\n- * that means its ref count will be temporary increased) for the lifetime\n- * of the reference that is created.  This means that the pointer remains\n- * valid even if `x` is reassigned.\n- *\n- * Finally, if neither of these two solutions are applicable, then we\n- * require that all operations within the scope of the reference be\n- * *pure*.  A pure operation is effectively one that does not write to\n- * any aliasable memory.  This means that it is still possible to write\n- * to local variables or other data that is uniquely tied to the stack\n- * frame (there's that term again; formal definition still pending) but\n- * not to data reached via a `&T` or `@T` pointer.  Such writes could\n- * possibly have the side-effect of causing the data which must remain\n- * valid to be overwritten.\n- *\n- * # Possible future directions\n- *\n- * There are numerous ways that the `borrowck` could be strengthened, but\n- * these are the two most likely:\n- *\n- * - flow-sensitivity: we do not currently consider flow at all but only\n- *   block-scoping.  This means that innocent code like the following is\n- *   rejected:\n- *\n- *       let mut x: int;\n- *       ...\n- *       x = 5;\n- *       let y: &int = &x; // immutable ptr created\n- *       ...\n- *\n- *   The reason is that the scope of the pointer `y` is the entire\n- *   enclosing block, and the assignment `x = 5` occurs within that\n- *   block.  The analysis is not smart enough to see that `x = 5` always\n- *   happens before the immutable pointer is created.  This is relatively\n- *   easy to fix and will surely be fixed at some point.\n- *\n- * - finer-grained purity checks: currently, our fallback for\n- *   guaranteeing random references into mutable, aliasable memory is to\n- *   require *total purity*.  This is rather strong.  We could use local\n- *   type-based alias analysis to distinguish writes that could not\n- *   possibly invalid the references which must be guaranteed.  This\n- *   would only work within the function boundaries; function calls would\n- *   still require total purity.  This seems less likely to be\n- *   implemented in the short term as it would make the code\n- *   significantly more complex; there is currently no code to analyze\n- *   the types and determine the possible impacts of a write.\n- *\n- * # Terminology\n- *\n- * A **loan** is .\n- *\n- * # How the code works\n- *\n- * The borrow check code is divided into several major modules, each of\n- * which is documented in its own file.\n- *\n- * The `gather_loans` and `check_loans` are the two major passes of the\n- * analysis.  The `gather_loans` pass runs over the IR once to determine\n- * what memory must remain valid and for how long.  Its name is a bit of\n- * a misnomer; it does in fact gather up the set of loans which are\n- * granted, but it also determines when @T pointers must be rooted and\n- * for which scopes purity must be required.\n- *\n- * The `check_loans` pass walks the IR and examines the loans and purity\n- * requirements computed in `gather_loans`.  It checks to ensure that (a)\n- * the conditions of all loans are honored; (b) no contradictory loans\n- * were granted (for example, loaning out the same memory as mutable and\n- * immutable simultaneously); and (c) any purity requirements are\n- * honored.\n- *\n- * The remaining modules are helper modules used by `gather_loans` and\n- * `check_loans`:\n- *\n- * - `categorization` has the job of analyzing an expression to determine\n- *   what kind of memory is used in evaluating it (for example, where\n- *   dereferences occur and what kind of pointer is dereferenced; whether\n- *   the memory is mutable; etc)\n- * - `loan` determines when data uniquely tied to the stack frame can be\n- *   loaned out.\n- * - `preserve` determines what actions (if any) must be taken to preserve\n- *   aliasable data.  This is the code which decides when to root\n- *   an @T pointer or to require purity.\n- *\n- * # Maps that are created\n- *\n- * Borrowck results in two maps.\n- *\n- * - `root_map`: identifies those expressions or patterns whose result\n- *   needs to be rooted.  Conceptually the root_map maps from an\n- *   expression or pattern node to a `node_id` identifying the scope for\n- *   which the expression must be rooted (this `node_id` should identify\n- *   a block or call).  The actual key to the map is not an expression id,\n- *   however, but a `root_map_key`, which combines an expression id with a\n- *   deref count and is used to cope with auto-deref.\n- *\n- * - `mutbl_map`: identifies those local variables which are modified or\n- *   moved. This is used by trans to guarantee that such variables are\n- *   given a memory location and not used as immediates.\n+# Borrow check\n+\n+This pass is in job of enforcing *memory safety* and *purity*.  As\n+memory safety is by far the more complex topic, I'll focus on that in\n+this description, but purity will be covered later on. In the context\n+of Rust, memory safety means three basic things:\n+\n+- no writes to immutable memory;\n+- all pointers point to non-freed memory;\n+- all pointers point to memory of the same type as the pointer.\n+\n+The last point might seem confusing: after all, for the most part,\n+this condition is guaranteed by the type check.  However, there are\n+two cases where the type check effectively delegates to borrow check.\n+\n+The first case has to do with enums.  If there is a pointer to the\n+interior of an enum, and the enum is in a mutable location (such as a\n+local variable or field declared to be mutable), it is possible that\n+the user will overwrite the enum with a new value of a different\n+variant, and thus effectively change the type of the memory that the\n+pointer is pointing at.\n+\n+The second case has to do with mutability.  Basically, the type\n+checker has only a limited understanding of mutability.  It will allow\n+(for example) the user to get an immutable pointer with the address of\n+a mutable local variable.  It will also allow a `@mut T` or `~mut T`\n+pointer to be borrowed as a `&r.T` pointer.  These seeming oversights\n+are in fact intentional; they allow the user to temporarily treat a\n+mutable value as immutable.  It is up to the borrow check to guarantee\n+that the value in question is not in fact mutated during the lifetime\n+`r` of the reference.\n+\n+# Definition of unstable memory\n+\n+The primary danger to safety arises due to *unstable memory*.\n+Unstable memory is memory whose validity or type may change as a\n+result of an assignment, move, or a variable going out of scope.\n+There are two cases in Rust where memory is unstable: the contents of\n+unique boxes and enums.\n+\n+Unique boxes are unstable because when the variable containing the\n+unique box is re-assigned, moves, or goes out of scope, the unique box\n+is freed or---in the case of a move---potentially given to another\n+task.  In either case, if there is an extant and usable pointer into\n+the box, then safety guarantees would be compromised.\n+\n+Enum values are unstable because they are reassigned the types of\n+their contents may change if they are assigned with a different\n+variant than they had previously.\n+\n+# Safety criteria that must be enforced\n+\n+Whenever a piece of memory is borrowed for lifetime L, there are two\n+things which the borrow checker must guarantee.  First, it must\n+guarantee that the memory address will remain allocated (and owned by\n+the current task) for the entirety of the lifetime L.  Second, it must\n+guarantee that the type of the data will not change for the entirety\n+of the lifetime L.  In exchange, the region-based type system will\n+guarantee that the pointer is not used outside the lifetime L.  These\n+guarantees are to some extent independent but are also inter-related.\n+\n+In some cases, the type of a pointer cannot be invalidated but the\n+lifetime can.  For example, imagine a pointer to the interior of\n+a shared box like:\n+\n+    let mut x = @mut {f: 5, g: 6};\n+    let y = &mut x.f;\n+\n+Here, a pointer was created to the interior of a shared box which\n+contains a record.  Even if `*x` were to be mutated like so:\n+\n+    *x = {f: 6, g: 7};\n+\n+This would cause `*y` to change from 5 to 6, but the pointer pointer\n+`y` remains valid.  It still points at an integer even if that integer\n+has been overwritten.\n+\n+However, if we were to reassign `x` itself, like so:\n+\n+    x = @{f: 6, g: 7};\n+\n+This could potentially invalidate `y`, because if `x` were the final\n+reference to the shared box, then that memory would be released and\n+now `y` points at freed memory.  (We will see that to prevent this\n+scenario we will *root* shared boxes that reside in mutable memory\n+whose contents are borrowed; rooting means that we create a temporary\n+to ensure that the box is not collected).\n+\n+In other cases, like an enum on the stack, the memory cannot be freed\n+but its type can change:\n+\n+    let mut x = some(5);\n+    alt x {\n+      some(ref y) => { ... }\n+      none => { ... }\n+    }\n+\n+Here as before, the pointer `y` would be invalidated if we were to\n+reassign `x` to `none`.  (We will see that this case is prevented\n+because borrowck tracks data which resides on the stack and prevents\n+variables from reassigned if there may be pointers to their interior)\n+\n+Finally, in some cases, both dangers can arise.  For example, something\n+like the following:\n+\n+    let mut x = ~some(5);\n+    alt x {\n+      ~some(ref y) => { ... }\n+      ~none => { ... }\n+    }\n+\n+In this case, if `x` to be reassigned or `*x` were to be mutated, then\n+the pointer `y` would be invalided.  (This case is also prevented by\n+borrowck tracking data which is owned by the current stack frame)\n+\n+# Summary of the safety check\n+\n+In order to enforce mutability, the borrow check has a few tricks up\n+its sleeve:\n+\n+- When data is owned by the current stack frame, we can identify every\n+  possible assignment to a local variable and simply prevent\n+  potentially dangerous assignments directly.\n+\n+- If data is owned by a shared box, we can root the box to increase\n+  its lifetime.\n+\n+- If data is found within a borrowed pointer, we can assume that the\n+  data will remain live for the entirety of the borrowed pointer.\n+\n+- We can rely on the fact that pure actions (such as calling pure\n+  functions) do not mutate data which is not owned by the current\n+  stack frame.\n+\n+# Possible future directions\n+\n+There are numerous ways that the `borrowck` could be strengthened, but\n+these are the two most likely:\n+\n+- flow-sensitivity: we do not currently consider flow at all but only\n+  block-scoping.  This means that innocent code like the following is\n+  rejected:\n+\n+      let mut x: int;\n+      ...\n+      x = 5;\n+      let y: &int = &x; // immutable ptr created\n+      ...\n+\n+  The reason is that the scope of the pointer `y` is the entire\n+  enclosing block, and the assignment `x = 5` occurs within that\n+  block.  The analysis is not smart enough to see that `x = 5` always\n+  happens before the immutable pointer is created.  This is relatively\n+  easy to fix and will surely be fixed at some point.\n+\n+- finer-grained purity checks: currently, our fallback for\n+  guaranteeing random references into mutable, aliasable memory is to\n+  require *total purity*.  This is rather strong.  We could use local\n+  type-based alias analysis to distinguish writes that could not\n+  possibly invalid the references which must be guaranteed.  This\n+  would only work within the function boundaries; function calls would\n+  still require total purity.  This seems less likely to be\n+  implemented in the short term as it would make the code\n+  significantly more complex; there is currently no code to analyze\n+  the types and determine the possible impacts of a write.\n+\n+# How the code works\n+\n+The borrow check code is divided into several major modules, each of\n+which is documented in its own file.\n+\n+The `gather_loans` and `check_loans` are the two major passes of the\n+analysis.  The `gather_loans` pass runs over the IR once to determine\n+what memory must remain valid and for how long.  Its name is a bit of\n+a misnomer; it does in fact gather up the set of loans which are\n+granted, but it also determines when @T pointers must be rooted and\n+for which scopes purity must be required.\n+\n+The `check_loans` pass walks the IR and examines the loans and purity\n+requirements computed in `gather_loans`.  It checks to ensure that (a)\n+the conditions of all loans are honored; (b) no contradictory loans\n+were granted (for example, loaning out the same memory as mutable and\n+immutable simultaneously); and (c) any purity requirements are\n+honored.\n+\n+The remaining modules are helper modules used by `gather_loans` and\n+`check_loans`:\n+\n+- `categorization` has the job of analyzing an expression to determine\n+  what kind of memory is used in evaluating it (for example, where\n+  dereferences occur and what kind of pointer is dereferenced; whether\n+  the memory is mutable; etc)\n+- `loan` determines when data uniquely tied to the stack frame can be\n+  loaned out.\n+- `preserve` determines what actions (if any) must be taken to preserve\n+  aliasable data.  This is the code which decides when to root\n+  an @T pointer or to require purity.\n+\n+# Maps that are created\n+\n+Borrowck results in two maps.\n+\n+- `root_map`: identifies those expressions or patterns whose result\n+  needs to be rooted.  Conceptually the root_map maps from an\n+  expression or pattern node to a `node_id` identifying the scope for\n+  which the expression must be rooted (this `node_id` should identify\n+  a block or call).  The actual key to the map is not an expression id,\n+  however, but a `root_map_key`, which combines an expression id with a\n+  deref count and is used to cope with auto-deref.\n+\n+- `mutbl_map`: identifies those local variables which are modified or\n+  moved. This is used by trans to guarantee that such variables are\n+  given a memory location and not used as immediates.\n  */\n \n import syntax::ast;"}, {"sha": "524a3394e016e4f525c3b5bc94bcd5e347db2405", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4ee4a2ab3166cf10bbcfc240820f1285f7070363/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ee4a2ab3166cf10bbcfc240820f1285f7070363/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=4ee4a2ab3166cf10bbcfc240820f1285f7070363", "patch": "@@ -361,12 +361,18 @@ impl public_methods for borrowck_ctxt {\n \n         ret alt deref_kind(self.tcx, base_cmt.ty) {\n           deref_ptr(ptr) {\n-            // make deref of vectors explicit, as explained in the comment at\n-            // the head of this section\n-            let deref_lp = base_cmt.lp.map(|lp| @lp_deref(lp, ptr) );\n+            // (a) the contents are loanable if the base is loanable\n+            // and this is a *unique* vector\n+            let deref_lp = alt ptr {\n+              uniq_ptr => {base_cmt.lp.map(|lp| @lp_deref(lp, uniq_ptr))}\n+              _ => {none}\n+            };\n+\n+            // (b) the deref is explicit in the resulting cmt\n             let deref_cmt = @{id:expr.id, span:expr.span,\n-                              cat:cat_deref(base_cmt, 0u, ptr), lp:deref_lp,\n-                              mutbl:m_imm, ty:mt.ty};\n+              cat:cat_deref(base_cmt, 0u, ptr), lp:deref_lp,\n+              mutbl:m_imm, ty:mt.ty};\n+\n             comp(expr, deref_cmt, base_cmt.ty, mt)\n           }\n "}]}