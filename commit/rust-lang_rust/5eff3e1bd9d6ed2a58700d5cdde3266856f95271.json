{"sha": "5eff3e1bd9d6ed2a58700d5cdde3266856f95271", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlZmYzZTFiZDlkNmVkMmE1ODcwMGQ1Y2RkZTMyNjY4NTZmOTUyNzE=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-18T20:15:47Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-19T09:20:00Z"}, "message": "std::str: Use CharOffsetIterator in slice_chars", "tree": {"sha": "2b38e5ebddd9121358730a9be71870d7d371fa9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b38e5ebddd9121358730a9be71870d7d371fa9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5eff3e1bd9d6ed2a58700d5cdde3266856f95271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5eff3e1bd9d6ed2a58700d5cdde3266856f95271", "html_url": "https://github.com/rust-lang/rust/commit/5eff3e1bd9d6ed2a58700d5cdde3266856f95271", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5eff3e1bd9d6ed2a58700d5cdde3266856f95271/comments", "author": null, "committer": null, "parents": [{"sha": "8931ad9e52e4f23043eea9cc63039d7e5f1e1efc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8931ad9e52e4f23043eea9cc63039d7e5f1e1efc", "html_url": "https://github.com/rust-lang/rust/commit/8931ad9e52e4f23043eea9cc63039d7e5f1e1efc"}], "stats": {"total": 27, "additions": 14, "deletions": 13}, "files": [{"sha": "93ece53bd20bdce3fe0b013af42408a55ffcfd3d", "filename": "src/libstd/str.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5eff3e1bd9d6ed2a58700d5cdde3266856f95271/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5eff3e1bd9d6ed2a58700d5cdde3266856f95271/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=5eff3e1bd9d6ed2a58700d5cdde3266856f95271", "patch": "@@ -1438,23 +1438,24 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// beyond the last character of the string.\n     fn slice_chars(&self, begin: uint, end: uint) -> &'self str {\n         assert!(begin <= end);\n-        // not sure how to use the iterators for this nicely.\n-        let mut position = 0;\n         let mut count = 0;\n-        let l = self.len();\n-        while count < begin && position < l {\n-            position = self.char_range_at(position).next;\n+        let mut begin_byte = None;\n+        let mut end_byte = None;\n+\n+        // This could be even more efficient by not decoding,\n+        // only finding the char boundaries\n+        for (idx, _) in self.char_offset_iter() {\n+            if count == begin { begin_byte = Some(idx); }\n+            if count == end { end_byte = Some(idx); break; }\n             count += 1;\n         }\n-        if count < begin { fail!(\"Attempted to begin slice_chars beyond end of string\") }\n-        let start_byte = position;\n-        while count < end && position < l {\n-            position = self.char_range_at(position).next;\n-            count += 1;\n-        }\n-        if count < end { fail!(\"Attempted to end slice_chars beyond end of string\") }\n+        if end_byte.is_none() && count == end { end_byte = Some(self.len()) }\n \n-        self.slice(start_byte, position)\n+        match (begin_byte, end_byte) {\n+            (None, _) => fail!(\"slice_chars: `begin` is beyond end of string\"),\n+            (_, None) => fail!(\"slice_chars: `end` is beyond end of string\"),\n+            (Some(a), Some(b)) => unsafe { raw::slice_bytes(*self, a, b) }\n+        }\n     }\n \n     /// Returns true if `needle` is a prefix of the string."}]}