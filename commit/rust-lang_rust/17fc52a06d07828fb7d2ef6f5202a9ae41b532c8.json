{"sha": "17fc52a06d07828fb7d2ef6f5202a9ae41b532c8", "node_id": "C_kwDOAAsO6NoAKDE3ZmM1MmEwNmQwNzgyOGZiN2QyZWY2ZjUyMDJhOWFlNDFiNTMyYzg", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-08-16T02:19:00Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-18T19:01:05Z"}, "message": "Clean up diff churn a bit, adjust comments", "tree": {"sha": "307b226dcbe7aa3deaf7d9cefbb27ead414b497c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/307b226dcbe7aa3deaf7d9cefbb27ead414b497c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17fc52a06d07828fb7d2ef6f5202a9ae41b532c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17fc52a06d07828fb7d2ef6f5202a9ae41b532c8", "html_url": "https://github.com/rust-lang/rust/commit/17fc52a06d07828fb7d2ef6f5202a9ae41b532c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17fc52a06d07828fb7d2ef6f5202a9ae41b532c8/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b", "html_url": "https://github.com/rust-lang/rust/commit/14e72e7ffaef3880279e9f3d2fef7dcf8fc5cb5b"}], "stats": {"total": 36, "additions": 20, "deletions": 16}, "files": [{"sha": "be363abad2a494bfffdd37a2c8ad5198532c7088", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17fc52a06d07828fb7d2ef6f5202a9ae41b532c8/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fc52a06d07828fb7d2ef6f5202a9ae41b532c8/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=17fc52a06d07828fb7d2ef6f5202a9ae41b532c8", "patch": "@@ -370,6 +370,7 @@ impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n     }\n \n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n+    #[inline(never)] // This is only called on fatal code paths\n     pub fn grant_error(&self, perm: Permission, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Retag(op) = &self.operation else {\n             unreachable!(\"grant_error should only be called during a retag\")\n@@ -389,6 +390,7 @@ impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n     }\n \n     /// Report a descriptive error when `access` is not permitted based on `tag`.\n+    #[inline(never)] // This is only called on fatal code paths\n     pub fn access_error(&self, stack: &Stack) -> InterpError<'tcx> {\n         let Operation::Access(op) = &self.operation  else {\n             unreachable!(\"access_error should only be called during an access\")\n@@ -407,6 +409,7 @@ impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n         )\n     }\n \n+    #[inline(never)] // This is only called on fatal code paths\n     pub fn protector_error(&self, item: &Item) -> InterpError<'tcx> {\n         let call_id = self\n             .threads\n@@ -441,6 +444,7 @@ impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n         }\n     }\n \n+    #[inline(never)] // This is only called on fatal code paths\n     pub fn dealloc_error(&self) -> InterpError<'tcx> {\n         let Operation::Dealloc(op) = &self.operation else {\n             unreachable!(\"dealloc_error should only be called during a deallocation\")"}, {"sha": "9861e6fdb17bc14e98631d41cebf8e39e1853011", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/17fc52a06d07828fb7d2ef6f5202a9ae41b532c8/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17fc52a06d07828fb7d2ef6f5202a9ae41b532c8/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=17fc52a06d07828fb7d2ef6f5202a9ae41b532c8", "patch": "@@ -296,6 +296,19 @@ impl<'tcx> Stack {\n             return Ok(());\n         }\n \n+        // We store tags twice, once in global.protected_tags and once in each call frame.\n+        // We do this because consulting a single global set in this function is faster\n+        // than attempting to search all call frames in the program for the `FrameExtra`\n+        // (if any) which is protecting the popped tag.\n+        //\n+        // This duplication trades off making `end_call` slower to make this function faster. This\n+        // trade-off is profitable in practice for a combination of two reasons.\n+        // 1. A single protected tag can (and does in some programs) protect thousands of `Item`s.\n+        //    Therefore, adding overhead in function call/return is profitable even if it only\n+        //    saves a little work in this function.\n+        // 2. Most frames protect only one or two tags. So this duplicative global turns a search\n+        //    which ends up about linear in the number of protected tags in the program into a\n+        //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n         if global.protected_tags.contains(&item.tag()) {\n             return Err(dcx.protector_error(item).into());\n         }\n@@ -622,6 +635,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         protect: bool,\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n+        let current_span = this.machine.current_span(*this.tcx);\n \n         // It is crucial that this gets called on all code paths, to ensure we track tag creation.\n         let log_creation = |this: &MiriEvalContext<'mir, 'tcx>,\n@@ -674,8 +688,6 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             Ok(())\n         };\n \n-        let current_span = this.machine.current_span(*this.tcx);\n-\n         if size == Size::ZERO {\n             trace!(\n                 \"reborrow of size 0: {} reference {:?} derived from {:?} (pointee {})\",\n@@ -726,19 +738,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         );\n \n         if protect {\n-            // We store tags twice, once in global.protected_tags and once in each call frame.\n-            // We do this because consulting a single global set in this function is faster\n-            // than attempting to search all call frames in the program for the `FrameExtra`\n-            // (if any) which is protecting the popped tag.\n-            //\n-            // This duplication trades off making `end_call` slower to make this function faster. This\n-            // trade-off is profitable in practice for a combination of two reasons.\n-            // 1. A single protected tag can (and does in some programs) protect thousands of `Item`s.\n-            //    Therefore, adding overhead to in function call/return is profitable even if it only\n-            //    saves a little work in this function.\n-            // 2. Most frames protect only one or two tags. So this duplicative global turns a search\n-            //    which ends up about linear in the number of protected tags in the program into a\n-            //    constant time check (and a slow linear, because the tags in the frames aren't contiguous).\n+            // See comment in `Stack::item_popped` for why we store the tag twice.\n             this.frame_mut().extra.stacked_borrows.as_mut().unwrap().protected_tags.push(new_tag);\n             this.machine.stacked_borrows.as_mut().unwrap().get_mut().protected_tags.insert(new_tag);\n         }\n@@ -818,7 +818,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n         let dcx = DiagnosticCxBuilder::retag(\n-            machine.current_span(tcx),\n+            machine.current_span(tcx), // `get_alloc_extra_mut` invalidated our old `current_span`\n             &machine.threads,\n             retag_cause,\n             new_tag,"}]}