{"sha": "e63424db1961215f145befa6d362347fefcef9a1", "node_id": "C_kwDOAAsO6NoAKGU2MzQyNGRiMTk2MTIxNWYxNDViZWZhNmQzNjIzNDdmZWZjZWY5YTE", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-30T05:56:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-30T05:56:48Z"}, "message": "Rollup merge of #100092 - compiler-errors:issue-100075, r=oli-obk\n\nFall back when relating two opaques by substs in MIR typeck\n\nThis is certainly _one_ way to fix #100075. Not really confident it's the _best_ way to do it, though.\n\nThe root cause of this issue is that during MIR type-check, we end up trying to equate an opaque against the same opaque def-id but with different substs. Because of the way that we replace RPITs during (HIR) typeck with an inference variable, we don't end up emitting a type-checking error, so the delayed MIR bug causes an ICE.\n\nSee the `src/test/ui/impl-trait/issue-100075-2.rs` test below to make that clear -- in that example, we try to equate `{impl Sized} substs=[T]` and `{impl Sized} substs=[Option<T>]`, which causes an ICE. This new logic will instead cause us to infer `{impl Sized} substs=[Option<T>]` as the hidden type for `{impl Sized} substs=[T]`, which causes a proper error to be emitted later on when we check that an opaque isn't recursive.\n\nI'm open to closing this in favor of something else. Ideally we'd fix this in typeck, but the thing we do to ensure backwards compatibility with weird RPIT cases makes that difficult. Also open to discussing this further.", "tree": {"sha": "f59210077ab419a3c78d8559552ac5909af3878e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f59210077ab419a3c78d8559552ac5909af3878e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e63424db1961215f145befa6d362347fefcef9a1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDaagCRBK7hj4Ov3rIwAAN/oIAF/BEfJ7SUhv77zxhdsom1Gt\nAOWDNaA3/R/a6LJ3xJ1XZa4A95ZO2J84jhrUARlJHMY6JSDkLp9iD/FZDJnQRyij\nADe6bVYlQAG9vhpuMocpDSEDQ9Iu4CtPbhWdEvRcsG0GH0rrXUvvIesRzdihAsaJ\nQiByQcSaaWlVAAPdOzL8JgYjBz3BlxrByN3p2nbnBwJywmfZwWul0YXoO+43B3Tt\nmVMT0M60P7U0XE2xfr2+61AJudw+2MvhFxXZ9E7YK6rwNBszd3CFDdlN3sZXEk0c\nsxcQbo9iAgUAu6gzSft+p8JP6kdaD74Ha4mbeePUSrMTJwjVDYdu0GcUsVHYV70=\n=661Y\n-----END PGP SIGNATURE-----\n", "payload": "tree f59210077ab419a3c78d8559552ac5909af3878e\nparent c731157395f7a02138d5531041578983a66f6f42\nparent 534426d0f3d12b735b0018bcf268b08a09cc09b8\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1661839008 +0530\ncommitter GitHub <noreply@github.com> 1661839008 +0530\n\nRollup merge of #100092 - compiler-errors:issue-100075, r=oli-obk\n\nFall back when relating two opaques by substs in MIR typeck\n\nThis is certainly _one_ way to fix #100075. Not really confident it's the _best_ way to do it, though.\n\nThe root cause of this issue is that during MIR type-check, we end up trying to equate an opaque against the same opaque def-id but with different substs. Because of the way that we replace RPITs during (HIR) typeck with an inference variable, we don't end up emitting a type-checking error, so the delayed MIR bug causes an ICE.\n\nSee the `src/test/ui/impl-trait/issue-100075-2.rs` test below to make that clear -- in that example, we try to equate `{impl Sized} substs=[T]` and `{impl Sized} substs=[Option<T>]`, which causes an ICE. This new logic will instead cause us to infer `{impl Sized} substs=[Option<T>]` as the hidden type for `{impl Sized} substs=[T]`, which causes a proper error to be emitted later on when we check that an opaque isn't recursive.\n\nI'm open to closing this in favor of something else. Ideally we'd fix this in typeck, but the thing we do to ensure backwards compatibility with weird RPIT cases makes that difficult. Also open to discussing this further.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e63424db1961215f145befa6d362347fefcef9a1", "html_url": "https://github.com/rust-lang/rust/commit/e63424db1961215f145befa6d362347fefcef9a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e63424db1961215f145befa6d362347fefcef9a1/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c731157395f7a02138d5531041578983a66f6f42", "url": "https://api.github.com/repos/rust-lang/rust/commits/c731157395f7a02138d5531041578983a66f6f42", "html_url": "https://github.com/rust-lang/rust/commit/c731157395f7a02138d5531041578983a66f6f42"}, {"sha": "534426d0f3d12b735b0018bcf268b08a09cc09b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/534426d0f3d12b735b0018bcf268b08a09cc09b8", "html_url": "https://github.com/rust-lang/rust/commit/534426d0f3d12b735b0018bcf268b08a09cc09b8"}], "stats": {"total": 123, "additions": 99, "deletions": 24}, "files": [{"sha": "e7e93116a66d146c9d3b74ad4bb5cd79324cc06b", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e63424db1961215f145befa6d362347fefcef9a1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63424db1961215f145befa6d362347fefcef9a1/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=e63424db1961215f145befa6d362347fefcef9a1", "patch": "@@ -396,6 +396,32 @@ where\n \n         generalizer.relate(value, value)\n     }\n+\n+    fn relate_opaques(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n+        let mut generalize = |ty, ty_is_expected| {\n+            let var = self.infcx.next_ty_var_id_in_universe(\n+                TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::MiscVariable,\n+                    span: self.delegate.span(),\n+                },\n+                ty::UniverseIndex::ROOT,\n+            );\n+            if ty_is_expected {\n+                self.relate_ty_var((ty, var))\n+            } else {\n+                self.relate_ty_var((var, ty))\n+            }\n+        };\n+        let (a, b) = match (a.kind(), b.kind()) {\n+            (&ty::Opaque(..), _) => (a, generalize(b, false)?),\n+            (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n+            _ => unreachable!(),\n+        };\n+        self.delegate.register_opaque_type(a, b, true)?;\n+        trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n+        Ok(a)\n+    }\n }\n \n /// When we instantiate an inference variable with a value in\n@@ -572,32 +598,16 @@ where\n             (&ty::Infer(ty::TyVar(vid)), _) => self.relate_ty_var((vid, b)),\n \n             (&ty::Opaque(a_def_id, _), &ty::Opaque(b_def_id, _)) if a_def_id == b_def_id => {\n-                self.infcx.super_combine_tys(self, a, b)\n+                infcx.commit_if_ok(|_| infcx.super_combine_tys(self, a, b)).or_else(|err| {\n+                    self.tcx().sess.delay_span_bug(\n+                        self.delegate.span(),\n+                        \"failure to relate an opaque to itself should result in an error later on\",\n+                    );\n+                    if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n+                })\n             }\n             (&ty::Opaque(did, ..), _) | (_, &ty::Opaque(did, ..)) if did.is_local() => {\n-                let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n-                let mut generalize = |ty, ty_is_expected| {\n-                    let var = infcx.next_ty_var_id_in_universe(\n-                        TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::MiscVariable,\n-                            span: self.delegate.span(),\n-                        },\n-                        ty::UniverseIndex::ROOT,\n-                    );\n-                    if ty_is_expected {\n-                        self.relate_ty_var((ty, var))\n-                    } else {\n-                        self.relate_ty_var((var, ty))\n-                    }\n-                };\n-                let (a, b) = match (a.kind(), b.kind()) {\n-                    (&ty::Opaque(..), _) => (a, generalize(b, false)?),\n-                    (_, &ty::Opaque(..)) => (generalize(a, true)?, b),\n-                    _ => unreachable!(),\n-                };\n-                self.delegate.register_opaque_type(a, b, true)?;\n-                trace!(a = ?a.kind(), b = ?b.kind(), \"opaque type instantiated\");\n-                Ok(a)\n+                self.relate_opaques(a, b)\n             }\n \n             (&ty::Projection(projection_ty), _)"}, {"sha": "cf059af19251222073da1fde308739b074571543", "filename": "src/test/ui/impl-trait/issue-100075-2.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e63424db1961215f145befa6d362347fefcef9a1/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63424db1961215f145befa6d362347fefcef9a1/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075-2.rs?ref=e63424db1961215f145befa6d362347fefcef9a1", "patch": "@@ -0,0 +1,8 @@\n+fn opaque<T>(t: T) -> impl Sized {\n+    //~^ ERROR cannot resolve opaque type\n+    //~| WARNING function cannot return without recursing\n+    opaque(Some(t))\n+}\n+\n+#[allow(dead_code)]\n+fn main() {}"}, {"sha": "5a1f1a97d04e4b4f62ea35c8cfe79ee6cb671821", "filename": "src/test/ui/impl-trait/issue-100075-2.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e63424db1961215f145befa6d362347fefcef9a1/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e63424db1961215f145befa6d362347fefcef9a1/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075-2.stderr?ref=e63424db1961215f145befa6d362347fefcef9a1", "patch": "@@ -0,0 +1,24 @@\n+warning: function cannot return without recursing\n+  --> $DIR/issue-100075-2.rs:1:1\n+   |\n+LL | fn opaque<T>(t: T) -> impl Sized {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot return without recursing\n+...\n+LL |     opaque(Some(t))\n+   |     --------------- recursive call site\n+   |\n+   = note: `#[warn(unconditional_recursion)]` on by default\n+   = help: a `loop` may express intention better if this is on purpose\n+\n+error[E0720]: cannot resolve opaque type\n+  --> $DIR/issue-100075-2.rs:1:23\n+   |\n+LL | fn opaque<T>(t: T) -> impl Sized {\n+   |                       ^^^^^^^^^^ recursive opaque type\n+...\n+LL |     opaque(Some(t))\n+   |     --------------- returning here with type `impl Sized`\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0720`."}, {"sha": "ea30abb4855f319114ad8e4588a3d9412c362572", "filename": "src/test/ui/impl-trait/issue-100075.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e63424db1961215f145befa6d362347fefcef9a1/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e63424db1961215f145befa6d362347fefcef9a1/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075.rs?ref=e63424db1961215f145befa6d362347fefcef9a1", "patch": "@@ -0,0 +1,21 @@\n+trait Marker {}\n+impl<T> Marker for T {}\n+\n+fn maybe<T>(\n+    _t: T,\n+) -> Option<\n+    //removing the line below makes it compile\n+    &'static T,\n+> {\n+    None\n+}\n+\n+fn _g<T>(t: &'static T) -> &'static impl Marker {\n+    //~^ ERROR cannot resolve opaque type\n+    if let Some(t) = maybe(t) {\n+        return _g(t);\n+    }\n+    todo!()\n+}\n+\n+fn main() {}"}, {"sha": "267ecfdaed1242fc40fa1e44f8f9682d84069617", "filename": "src/test/ui/impl-trait/issue-100075.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e63424db1961215f145befa6d362347fefcef9a1/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e63424db1961215f145befa6d362347fefcef9a1/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-100075.stderr?ref=e63424db1961215f145befa6d362347fefcef9a1", "patch": "@@ -0,0 +1,12 @@\n+error[E0720]: cannot resolve opaque type\n+  --> $DIR/issue-100075.rs:13:37\n+   |\n+LL | fn _g<T>(t: &'static T) -> &'static impl Marker {\n+   |                                     ^^^^^^^^^^^ recursive opaque type\n+...\n+LL |         return _g(t);\n+   |                ----- returning here with type `&impl Marker`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0720`."}]}