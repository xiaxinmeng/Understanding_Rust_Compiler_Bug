{"sha": "936bfea94b800551c972e5689ae7da86d3d601de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNmJmZWE5NGI4MDA1NTFjOTcyZTU2ODlhZTdkYTg2ZDNkNjAxZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-20T18:24:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-20T18:24:12Z"}, "message": "Auto merge of #34113 - srinivasreddy:deriving_rustfmt, r=brson\n\nrun rustfmt on libsyntax_ext/deriving folder", "tree": {"sha": "50082d6490952d8d2b3dac6fc3ad0793817b4963", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50082d6490952d8d2b3dac6fc3ad0793817b4963"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/936bfea94b800551c972e5689ae7da86d3d601de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/936bfea94b800551c972e5689ae7da86d3d601de", "html_url": "https://github.com/rust-lang/rust/commit/936bfea94b800551c972e5689ae7da86d3d601de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/936bfea94b800551c972e5689ae7da86d3d601de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d5965a5e899b03a34a94bcecfbc58c893b238e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d5965a5e899b03a34a94bcecfbc58c893b238e7", "html_url": "https://github.com/rust-lang/rust/commit/9d5965a5e899b03a34a94bcecfbc58c893b238e7"}, {"sha": "9652fcbb6e59845904ef246b41231f5df198dd0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9652fcbb6e59845904ef246b41231f5df198dd0d", "html_url": "https://github.com/rust-lang/rust/commit/9652fcbb6e59845904ef246b41231f5df198dd0d"}], "stats": {"total": 1859, "additions": 932, "deletions": 927}, "files": [{"sha": "cfc98bf36871f5d78353ff9903ba8ee4c6ba5fdf", "filename": "src/libsyntax_ext/deriving/bounds.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -12,24 +12,22 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast::MetaItem;\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax_pos::Span;\n \n pub fn expand_deriving_unsafe_bound(cx: &mut ExtCtxt,\n                                     span: Span,\n                                     _: &MetaItem,\n                                     _: &Annotatable,\n-                                    _: &mut FnMut(Annotatable))\n-{\n+                                    _: &mut FnMut(Annotatable)) {\n     cx.span_err(span, \"this unsafe trait should be implemented explicitly\");\n }\n \n pub fn expand_deriving_copy(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n                             item: &Annotatable,\n-                            push: &mut FnMut(Annotatable))\n-{\n+                            push: &mut FnMut(Annotatable)) {\n     let mut v = cx.crate_root.map(|s| vec![s]).unwrap_or(Vec::new());\n     v.push(\"marker\");\n     v.push(\"Copy\");"}, {"sha": "ce8ce2209d8c4513038fb21f84780c7aa870537d", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -11,23 +11,25 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{Expr, ItemKind, Generics, MetaItem, VariantData};\n+use syntax::ast::{Expr, Generics, ItemKind, MetaItem, VariantData};\n use syntax::attr;\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n #[derive(PartialEq)]\n-enum Mode { Deep, Shallow }\n+enum Mode {\n+    Deep,\n+    Shallow,\n+}\n \n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n                              mitem: &MetaItem,\n                              item: &Annotatable,\n-                             push: &mut FnMut(Annotatable))\n-{\n+                             push: &mut FnMut(Annotatable)) {\n     // check if we can use a short form\n     //\n     // the short form is `fn clone(&self) -> Self { *self }`\n@@ -46,8 +48,8 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n             match annitem.node {\n                 ItemKind::Struct(_, Generics { ref ty_params, .. }) |\n                 ItemKind::Enum(_, Generics { ref ty_params, .. })\n-                    if ty_params.is_empty()\n-                        && attr::contains_name(&annitem.attrs, \"derive_Copy\") => {\n+                    if ty_params.is_empty() &&\n+                       attr::contains_name(&annitem.attrs, \"derive_Copy\") => {\n \n                     bounds = vec![Literal(path_std!(cx, core::marker::Copy))];\n                     unify_fieldless_variants = true;\n@@ -66,54 +68,53 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n             }\n         }\n \n-        _ => cx.span_bug(span, \"#[derive(Clone)] on trait item or impl item\")\n+        _ => cx.span_bug(span, \"#[derive(Clone)] on trait item or impl item\"),\n     }\n \n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n+    let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n         path: path_std!(cx, core::clone::Clone),\n         additional_bounds: bounds,\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        methods: vec!(\n-            MethodDef {\n-                name: \"clone\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: Vec::new(),\n-                ret_ty: Self_,\n-                attributes: attrs,\n-                is_unsafe: false,\n-                unify_fieldless_variants: unify_fieldless_variants,\n-                combine_substructure: substructure,\n-            }\n-        ),\n+        methods: vec![MethodDef {\n+                          name: \"clone\",\n+                          generics: LifetimeBounds::empty(),\n+                          explicit_self: borrowed_explicit_self(),\n+                          args: Vec::new(),\n+                          ret_ty: Self_,\n+                          attributes: attrs,\n+                          is_unsafe: false,\n+                          unify_fieldless_variants: unify_fieldless_variants,\n+                          combine_substructure: substructure,\n+                      }],\n         associated_types: Vec::new(),\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn cs_clone(\n-    name: &str,\n-    cx: &mut ExtCtxt, trait_span: Span,\n-    substr: &Substructure,\n-    mode: Mode) -> P<Expr> {\n+fn cs_clone(name: &str,\n+            cx: &mut ExtCtxt,\n+            trait_span: Span,\n+            substr: &Substructure,\n+            mode: Mode)\n+            -> P<Expr> {\n     let ctor_path;\n     let all_fields;\n     let fn_path = match mode {\n         Mode::Shallow => cx.std_path(&[\"clone\", \"assert_receiver_is_clone\"]),\n-        Mode::Deep  => cx.std_path(&[\"clone\", \"Clone\", \"clone\"]),\n+        Mode::Deep => cx.std_path(&[\"clone\", \"Clone\", \"clone\"]),\n     };\n     let subcall = |field: &FieldInfo| {\n         let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n \n         let span = if mode == Mode::Shallow {\n             // set the expn ID so we can call the unstable method\n-            Span { expn_id: cx.backtrace(), .. trait_span }\n+            Span { expn_id: cx.backtrace(), ..trait_span }\n         } else {\n             field.span\n         };\n@@ -131,15 +132,15 @@ fn cs_clone(\n             ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.node.name]);\n             all_fields = af;\n             vdata = &variant.node.data;\n-        },\n-        EnumNonMatchingCollapsed (..) => {\n+        }\n+        EnumNonMatchingCollapsed(..) => {\n             cx.span_bug(trait_span,\n                         &format!(\"non-matching enum variants in \\\n-                                 `derive({})`\", name))\n+                                 `derive({})`\",\n+                                 name))\n         }\n         StaticEnum(..) | StaticStruct(..) => {\n-            cx.span_bug(trait_span,\n-                        &format!(\"static method in `derive({})`\", name))\n+            cx.span_bug(trait_span, &format!(\"static method in `derive({})`\", name))\n         }\n     }\n \n@@ -153,17 +154,20 @@ fn cs_clone(\n         Mode::Deep => {\n             match *vdata {\n                 VariantData::Struct(..) => {\n-                    let fields = all_fields.iter().map(|field| {\n-                        let ident = match field.name {\n-                            Some(i) => i,\n-                            None => {\n-                                cx.span_bug(trait_span,\n-                                            &format!(\"unnamed field in normal struct in \\\n-                                                     `derive({})`\", name))\n-                            }\n-                        };\n-                        cx.field_imm(field.span, ident, subcall(field))\n-                    }).collect::<Vec<_>>();\n+                    let fields = all_fields.iter()\n+                        .map(|field| {\n+                            let ident = match field.name {\n+                                Some(i) => i,\n+                                None => {\n+                                    cx.span_bug(trait_span,\n+                                                &format!(\"unnamed field in normal struct in \\\n+                                                     `derive({})`\",\n+                                                         name))\n+                                }\n+                            };\n+                            cx.field_imm(field.span, ident, subcall(field))\n+                        })\n+                        .collect::<Vec<_>>();\n \n                     cx.expr_struct(trait_span, ctor_path, fields)\n                 }\n@@ -172,9 +176,7 @@ fn cs_clone(\n                     let path = cx.expr_path(ctor_path);\n                     cx.expr_call(trait_span, path, subcalls)\n                 }\n-                VariantData::Unit(..) => {\n-                    cx.expr_path(ctor_path)\n-                }\n+                VariantData::Unit(..) => cx.expr_path(ctor_path),\n             }\n         }\n     }"}, {"sha": "2ab0f0ff54669c40e94e3fa0cd99f734ae672fdb", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 31, "deletions": 36, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -11,8 +11,8 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr};\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ast::{Expr, MetaItem};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n@@ -22,52 +22,47 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n-                          push: &mut FnMut(Annotatable))\n-{\n+                          push: &mut FnMut(Annotatable)) {\n     fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_same_method(\n-            |cx, span, exprs| {\n-                // create `a.<method>(); b.<method>(); c.<method>(); ...`\n-                // (where method is `assert_receiver_is_total_eq`)\n-                let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n-                let block = cx.block(span, stmts);\n-                cx.expr_block(block)\n-            },\n-            Box::new(|cx, sp, _, _| {\n-                cx.span_bug(sp, \"non matching enums in derive(Eq)?\") }),\n-            cx,\n-            span,\n-            substr\n-        )\n+        cs_same_method(|cx, span, exprs| {\n+            // create `a.<method>(); b.<method>(); c.<method>(); ...`\n+            // (where method is `assert_receiver_is_total_eq`)\n+            let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n+            let block = cx.block(span, stmts);\n+            cx.expr_block(block)\n+        },\n+                       Box::new(|cx, sp, _, _| {\n+                           cx.span_bug(sp, \"non matching enums in derive(Eq)?\")\n+                       }),\n+                       cx,\n+                       span,\n+                       substr)\n     }\n \n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let hidden = cx.meta_word(span, InternedString::new(\"hidden\"));\n-    let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec!(hidden));\n-    let attrs = vec!(cx.attribute(span, inline),\n-                     cx.attribute(span, doc));\n+    let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec![hidden]);\n+    let attrs = vec![cx.attribute(span, inline), cx.attribute(span, doc)];\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n         path: path_std!(cx, core::cmp::Eq),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        methods: vec!(\n-            MethodDef {\n-                name: \"assert_receiver_is_total_eq\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec!(),\n-                ret_ty: nil_ty(),\n-                attributes: attrs,\n-                is_unsafe: false,\n-                unify_fieldless_variants: true,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    cs_total_eq_assert(a, b, c)\n-                }))\n-            }\n-        ),\n+        methods: vec![MethodDef {\n+                          name: \"assert_receiver_is_total_eq\",\n+                          generics: LifetimeBounds::empty(),\n+                          explicit_self: borrowed_explicit_self(),\n+                          args: vec![],\n+                          ret_ty: nil_ty(),\n+                          attributes: attrs,\n+                          is_unsafe: false,\n+                          unify_fieldless_variants: true,\n+                          combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                              cs_total_eq_assert(a, b, c)\n+                          })),\n+                      }],\n         associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)"}, {"sha": "8ae77e79310b2805886363bbf7c23b2b50a35d32", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 69, "deletions": 75, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -11,8 +11,8 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, self};\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ast::{self, Expr, MetaItem};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n@@ -22,32 +22,29 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n                            mitem: &MetaItem,\n                            item: &Annotatable,\n-                           push: &mut FnMut(Annotatable))\n-{\n+                           push: &mut FnMut(Annotatable)) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n+    let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n         path: path_std!(cx, core::cmp::Ord),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        methods: vec!(\n-            MethodDef {\n-                name: \"cmp\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec!(borrowed_self()),\n-                ret_ty: Literal(path_std!(cx, core::cmp::Ordering)),\n-                attributes: attrs,\n-                is_unsafe: false,\n-                unify_fieldless_variants: true,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    cs_cmp(a, b, c)\n-                })),\n-            }\n-        ),\n+        methods: vec![MethodDef {\n+                          name: \"cmp\",\n+                          generics: LifetimeBounds::empty(),\n+                          explicit_self: borrowed_explicit_self(),\n+                          args: vec![borrowed_self()],\n+                          ret_ty: Literal(path_std!(cx, core::cmp::Ordering)),\n+                          attributes: attrs,\n+                          is_unsafe: false,\n+                          unify_fieldless_variants: true,\n+                          combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                              cs_cmp(a, b, c)\n+                          })),\n+                      }],\n         associated_types: Vec::new(),\n     };\n \n@@ -57,76 +54,73 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n \n pub fn ordering_collapsed(cx: &mut ExtCtxt,\n                           span: Span,\n-                          self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n+                          self_arg_tags: &[ast::Ident])\n+                          -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n     cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n }\n \n-pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n-              substr: &Substructure) -> P<Expr> {\n+pub fn cs_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n     let test_id = cx.ident_of(\"__cmp\");\n-    let equals_path = cx.path_global(span,\n-                                     cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n+    let equals_path = cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n \n     let cmp_path = cx.std_path(&[\"cmp\", \"Ord\", \"cmp\"]);\n \n-    /*\n-    Builds:\n+    // Builds:\n+    //\n+    // match ::std::cmp::Ord::cmp(&self_field1, &other_field1) {\n+    // ::std::cmp::Ordering::Equal =>\n+    // match ::std::cmp::Ord::cmp(&self_field2, &other_field2) {\n+    // ::std::cmp::Ordering::Equal => {\n+    // ...\n+    // }\n+    // __cmp => __cmp\n+    // },\n+    // __cmp => __cmp\n+    // }\n+    //\n+    cs_fold(// foldr nests the if-elses correctly, leaving the first field\n+            // as the outermost one, and the last as the innermost.\n+            false,\n+            |cx, span, old, self_f, other_fs| {\n+        // match new {\n+        //     ::std::cmp::Ordering::Equal => old,\n+        //     __cmp => __cmp\n+        // }\n \n-    match ::std::cmp::Ord::cmp(&self_field1, &other_field1) {\n-        ::std::cmp::Ordering::Equal =>\n-            match ::std::cmp::Ord::cmp(&self_field2, &other_field2) {\n-                ::std::cmp::Ordering::Equal => {\n-                    ...\n-                }\n-                __cmp => __cmp\n-            },\n-        __cmp => __cmp\n-    }\n-    */\n-    cs_fold(\n-        // foldr nests the if-elses correctly, leaving the first field\n-        // as the outermost one, and the last as the innermost.\n-        false,\n-        |cx, span, old, self_f, other_fs| {\n-            // match new {\n-            //     ::std::cmp::Ordering::Equal => old,\n-            //     __cmp => __cmp\n-            // }\n-\n-            let new = {\n-                let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                    (1, Some(o_f)) => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n-                };\n+        let new = {\n+            let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                (1, Some(o_f)) => o_f,\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\"),\n+            };\n \n-                let args = vec![\n+            let args = vec![\n                     cx.expr_addr_of(span, self_f),\n                     cx.expr_addr_of(span, other_f.clone()),\n                 ];\n \n-                cx.expr_call_global(span, cmp_path.clone(), args)\n-            };\n+            cx.expr_call_global(span, cmp_path.clone(), args)\n+        };\n \n-            let eq_arm = cx.arm(span,\n-                                vec![cx.pat_enum(span,\n-                                                 equals_path.clone(),\n-                                                 vec![])],\n-                                old);\n-            let neq_arm = cx.arm(span,\n-                                 vec![cx.pat_ident(span, test_id)],\n-                                 cx.expr_ident(span, test_id));\n+        let eq_arm = cx.arm(span,\n+                            vec![cx.pat_enum(span, equals_path.clone(), vec![])],\n+                            old);\n+        let neq_arm = cx.arm(span,\n+                             vec![cx.pat_ident(span, test_id)],\n+                             cx.expr_ident(span, test_id));\n \n-            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-        },\n-        cx.expr_path(equals_path.clone()),\n-        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-            if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n-            } else {\n-                ordering_collapsed(cx, span, tag_tuple)\n-            }\n-        }),\n-        cx, span, substr)\n+        cx.expr_match(span, new, vec![eq_arm, neq_arm])\n+    },\n+            cx.expr_path(equals_path.clone()),\n+            Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n+        if self_args.len() != 2 {\n+            cx.span_bug(span, \"not exactly 2 arguments in `derive(Ord)`\")\n+        } else {\n+            ordering_collapsed(cx, span, tag_tuple)\n+        }\n+    }),\n+            cx,\n+            span,\n+            substr)\n }"}, {"sha": "f70e0cf4ac45768048ff1070b605372a9cd20959", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -11,8 +11,8 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, BinOpKind};\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ast::{BinOpKind, Expr, MetaItem};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n@@ -22,43 +22,44 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                                   span: Span,\n                                   mitem: &MetaItem,\n                                   item: &Annotatable,\n-                                  push: &mut FnMut(Annotatable))\n-{\n+                                  push: &mut FnMut(Annotatable)) {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n     fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_fold(\n-            true,  // use foldl\n-            |cx, span, subexpr, self_f, other_fs| {\n-                let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                    (1, Some(o_f)) => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n-                };\n+        cs_fold(true, // use foldl\n+                |cx, span, subexpr, self_f, other_fs| {\n+            let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                (1, Some(o_f)) => o_f,\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\"),\n+            };\n \n-                let eq = cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone());\n+            let eq = cx.expr_binary(span, BinOpKind::Eq, self_f, other_f.clone());\n \n-                cx.expr_binary(span, BinOpKind::And, subexpr, eq)\n-            },\n-            cx.expr_bool(span, true),\n-            Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n-            cx, span, substr)\n+            cx.expr_binary(span, BinOpKind::And, subexpr, eq)\n+        },\n+                cx.expr_bool(span, true),\n+                Box::new(|cx, span, _, _| cx.expr_bool(span, false)),\n+                cx,\n+                span,\n+                substr)\n     }\n     fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_fold(\n-            true,  // use foldl\n-            |cx, span, subexpr, self_f, other_fs| {\n-                let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                    (1, Some(o_f)) => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\")\n-                };\n+        cs_fold(true, // use foldl\n+                |cx, span, subexpr, self_f, other_fs| {\n+            let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                (1, Some(o_f)) => o_f,\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\"),\n+            };\n \n-                let eq = cx.expr_binary(span, BinOpKind::Ne, self_f, other_f.clone());\n+            let eq = cx.expr_binary(span, BinOpKind::Ne, self_f, other_f.clone());\n \n-                cx.expr_binary(span, BinOpKind::Or, subexpr, eq)\n-            },\n-            cx.expr_bool(span, false),\n-            Box::new(|cx, span, _, _| cx.expr_bool(span, true)),\n-            cx, span, substr)\n+            cx.expr_binary(span, BinOpKind::Or, subexpr, eq)\n+        },\n+                cx.expr_bool(span, false),\n+                Box::new(|cx, span, _, _| cx.expr_bool(span, true)),\n+                cx,\n+                span,\n+                substr)\n     }\n \n     macro_rules! md {"}, {"sha": "10a9738742e4486c470f6e531eee3b1c9cefd89f", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 124, "deletions": 123, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -13,8 +13,8 @@ pub use self::OrderingOp::*;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, BinOpKind, self};\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ast::{self, BinOpKind, Expr, MetaItem};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n@@ -24,8 +24,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                    span: Span,\n                                    mitem: &MetaItem,\n                                    item: &Annotatable,\n-                                   push: &mut FnMut(Annotatable))\n-{\n+                                   push: &mut FnMut(Annotatable)) {\n     macro_rules! md {\n         ($name:expr, $op:expr, $equal:expr) => { {\n             let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -53,7 +52,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                     true));\n \n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n+    let attrs = vec![cx.attribute(span, inline)];\n \n     let partial_cmp_def = MethodDef {\n         name: \"partial_cmp\",\n@@ -66,7 +65,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n         unify_fieldless_variants: true,\n         combine_substructure: combine_substructure(Box::new(|cx, span, substr| {\n             cs_partial_cmp(cx, span, substr)\n-        }))\n+        })),\n     };\n \n     // avoid defining extra methods if we can\n@@ -75,13 +74,11 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n     let methods = if is_type_without_fields(item) {\n         vec![partial_cmp_def]\n     } else {\n-        vec![\n-            partial_cmp_def,\n-            md!(\"lt\", true, false),\n-            md!(\"le\", true, true),\n-            md!(\"gt\", false, false),\n-            md!(\"ge\", false, true)\n-        ]\n+        vec![partial_cmp_def,\n+             md!(\"lt\", true, false),\n+             md!(\"le\", true, true),\n+             md!(\"gt\", false, false),\n+             md!(\"ge\", false, true)]\n     };\n \n     let trait_def = TraitDef {\n@@ -99,142 +96,146 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n \n #[derive(Copy, Clone)]\n pub enum OrderingOp {\n-    PartialCmpOp, LtOp, LeOp, GtOp, GeOp,\n+    PartialCmpOp,\n+    LtOp,\n+    LeOp,\n+    GtOp,\n+    GeOp,\n }\n \n pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n                                span: Span,\n                                op: OrderingOp,\n-                               self_arg_tags: &[ast::Ident]) -> P<ast::Expr> {\n+                               self_arg_tags: &[ast::Ident])\n+                               -> P<ast::Expr> {\n     let lft = cx.expr_ident(span, self_arg_tags[0]);\n     let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n     let op_str = match op {\n         PartialCmpOp => \"partial_cmp\",\n-        LtOp => \"lt\", LeOp => \"le\",\n-        GtOp => \"gt\", GeOp => \"ge\",\n+        LtOp => \"lt\",\n+        LeOp => \"le\",\n+        GtOp => \"gt\",\n+        GeOp => \"ge\",\n     };\n     cx.expr_method_call(span, lft, cx.ident_of(op_str), vec![rgt])\n }\n \n-pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n-              substr: &Substructure) -> P<Expr> {\n+pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n     let test_id = cx.ident_of(\"__cmp\");\n-    let ordering = cx.path_global(span,\n-                                  cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n+    let ordering = cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n     let equals_expr = cx.expr_some(span, ordering_expr);\n \n     let partial_cmp_path = cx.std_path(&[\"cmp\", \"PartialOrd\", \"partial_cmp\"]);\n \n-    /*\n-    Builds:\n-\n-    match ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1) {\n-        ::std::option::Option::Some(::std::cmp::Ordering::Equal) =>\n-            match ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2) {\n-                ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {\n-                    ...\n-                }\n-                __cmp => __cmp\n-            },\n-        __cmp => __cmp\n-    }\n-    */\n-    cs_fold(\n-        // foldr nests the if-elses correctly, leaving the first field\n-        // as the outermost one, and the last as the innermost.\n-        false,\n-        |cx, span, old, self_f, other_fs| {\n-            // match new {\n-            //     Some(::std::cmp::Ordering::Equal) => old,\n-            //     __cmp => __cmp\n-            // }\n-\n-            let new = {\n-                let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                    (1, Some(o_f)) => o_f,\n-                    _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n-                };\n-\n-                let args = vec![\n+    // Builds:\n+    //\n+    // match ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1) {\n+    // ::std::option::Option::Some(::std::cmp::Ordering::Equal) =>\n+    // match ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2) {\n+    // ::std::option::Option::Some(::std::cmp::Ordering::Equal) => {\n+    // ...\n+    // }\n+    // __cmp => __cmp\n+    // },\n+    // __cmp => __cmp\n+    // }\n+    //\n+    cs_fold(// foldr nests the if-elses correctly, leaving the first field\n+            // as the outermost one, and the last as the innermost.\n+            false,\n+            |cx, span, old, self_f, other_fs| {\n+        // match new {\n+        //     Some(::std::cmp::Ordering::Equal) => old,\n+        //     __cmp => __cmp\n+        // }\n+\n+        let new = {\n+            let other_f = match (other_fs.len(), other_fs.get(0)) {\n+                (1, Some(o_f)) => o_f,\n+                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+            };\n+\n+            let args = vec![\n                     cx.expr_addr_of(span, self_f),\n                     cx.expr_addr_of(span, other_f.clone()),\n                 ];\n \n-                cx.expr_call_global(span, partial_cmp_path.clone(), args)\n-            };\n-\n-            let eq_arm = cx.arm(span,\n-                                vec![cx.pat_some(span,\n-                                                 cx.pat_enum(span,\n-                                                             ordering.clone(),\n-                                                             vec![]))],\n-                                old);\n-            let neq_arm = cx.arm(span,\n-                                 vec![cx.pat_ident(span, test_id)],\n-                                 cx.expr_ident(span, test_id));\n-\n-            cx.expr_match(span, new, vec![eq_arm, neq_arm])\n-        },\n-        equals_expr.clone(),\n-        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-            if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-            } else {\n-                some_ordering_collapsed(cx, span, PartialCmpOp, tag_tuple)\n-            }\n-        }),\n-        cx, span, substr)\n+            cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+        };\n+\n+        let eq_arm = cx.arm(span,\n+                            vec![cx.pat_some(span, cx.pat_enum(span, ordering.clone(), vec![]))],\n+                            old);\n+        let neq_arm = cx.arm(span,\n+                             vec![cx.pat_ident(span, test_id)],\n+                             cx.expr_ident(span, test_id));\n+\n+        cx.expr_match(span, new, vec![eq_arm, neq_arm])\n+    },\n+            equals_expr.clone(),\n+            Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n+        if self_args.len() != 2 {\n+            cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+        } else {\n+            some_ordering_collapsed(cx, span, PartialCmpOp, tag_tuple)\n+        }\n+    }),\n+            cx,\n+            span,\n+            substr)\n }\n \n /// Strict inequality.\n-fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt,\n-         span: Span, substr: &Substructure) -> P<Expr> {\n+fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n     let op = if less { BinOpKind::Lt } else { BinOpKind::Gt };\n-    cs_fold(\n-        false, // need foldr,\n-        |cx, span, subexpr, self_f, other_fs| {\n-            /*\n-            build up a series of chain ||'s and &&'s from the inside\n-            out (hence foldr) to get lexical ordering, i.e. for op ==\n-            `ast::lt`\n-\n-            ```\n-            self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n-                (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n-                    (false)\n-                ))\n-            )\n-            ```\n-\n-            The optimiser should remove the redundancy. We explicitly\n-            get use the binops to avoid auto-deref dereferencing too many\n-            layers of pointers, if the type includes pointers.\n-            */\n-            let other_f = match (other_fs.len(), other_fs.get(0)) {\n-                (1, Some(o_f)) => o_f,\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+    cs_fold(false, // need foldr,\n+            |cx, span, subexpr, self_f, other_fs| {\n+        // build up a series of chain ||'s and &&'s from the inside\n+        // out (hence foldr) to get lexical ordering, i.e. for op ==\n+        // `ast::lt`\n+        //\n+        // ```\n+        // self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n+        // (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n+        // (false)\n+        // ))\n+        // )\n+        // ```\n+        //\n+        // The optimiser should remove the redundancy. We explicitly\n+        // get use the binops to avoid auto-deref dereferencing too many\n+        // layers of pointers, if the type includes pointers.\n+        //\n+        let other_f = match (other_fs.len(), other_fs.get(0)) {\n+            (1, Some(o_f)) => o_f,\n+            _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),\n+        };\n+\n+        let cmp = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n+\n+        let not_cmp = cx.expr_unary(span,\n+                                    ast::UnOp::Not,\n+                                    cx.expr_binary(span, op, other_f.clone(), self_f));\n+\n+        let and = cx.expr_binary(span, BinOpKind::And, not_cmp, subexpr);\n+        cx.expr_binary(span, BinOpKind::Or, cmp, and)\n+    },\n+            cx.expr_bool(span, equal),\n+            Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n+        if self_args.len() != 2 {\n+            cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n+        } else {\n+            let op = match (less, equal) {\n+                (true, true) => LeOp,\n+                (true, false) => LtOp,\n+                (false, true) => GeOp,\n+                (false, false) => GtOp,\n             };\n-\n-            let cmp = cx.expr_binary(span, op, self_f.clone(), other_f.clone());\n-\n-            let not_cmp = cx.expr_unary(span, ast::UnOp::Not,\n-                                        cx.expr_binary(span, op, other_f.clone(), self_f));\n-\n-            let and = cx.expr_binary(span, BinOpKind::And, not_cmp, subexpr);\n-            cx.expr_binary(span, BinOpKind::Or, cmp, and)\n-        },\n-        cx.expr_bool(span, equal),\n-        Box::new(|cx, span, (self_args, tag_tuple), _non_self_args| {\n-            if self_args.len() != 2 {\n-                cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\")\n-            } else {\n-                let op = match (less, equal) {\n-                    (true,  true) => LeOp, (true,  false) => LtOp,\n-                    (false, true) => GeOp, (false, false) => GtOp,\n-                };\n-                some_ordering_collapsed(cx, span, op, tag_tuple)\n-            }\n-        }),\n-        cx, span, substr)\n+            some_ordering_collapsed(cx, span, op, tag_tuple)\n+        }\n+    }),\n+            cx,\n+            span,\n+            substr)\n }"}, {"sha": "a31c695e360490e7e6077f4ce995c3514f028d6a", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -12,19 +12,18 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast;\n-use syntax::ast::{MetaItem, Expr};\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ast::{Expr, MetaItem};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{DUMMY_SP, Span};\n \n pub fn expand_deriving_debug(cx: &mut ExtCtxt,\n-                            span: Span,\n-                            mitem: &MetaItem,\n-                            item: &Annotatable,\n-                            push: &mut FnMut(Annotatable))\n-{\n+                             span: Span,\n+                             mitem: &MetaItem,\n+                             item: &Annotatable,\n+                             push: &mut FnMut(Annotatable)) {\n     // &mut ::std::fmt::Formatter\n     let fmtr = Ptr(Box::new(Literal(path_std!(cx, core::fmt::Formatter))),\n                    Borrowed(None, ast::Mutability::Mutable));\n@@ -36,57 +35,54 @@ pub fn expand_deriving_debug(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        methods: vec![\n-            MethodDef {\n-                name: \"fmt\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec!(fmtr),\n-                ret_ty: Literal(path_std!(cx, core::fmt::Result)),\n-                attributes: Vec::new(),\n-                is_unsafe: false,\n-                unify_fieldless_variants: false,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    show_substructure(a, b, c)\n-                }))\n-            }\n-        ],\n+        methods: vec![MethodDef {\n+                          name: \"fmt\",\n+                          generics: LifetimeBounds::empty(),\n+                          explicit_self: borrowed_explicit_self(),\n+                          args: vec![fmtr],\n+                          ret_ty: Literal(path_std!(cx, core::fmt::Result)),\n+                          attributes: Vec::new(),\n+                          is_unsafe: false,\n+                          unify_fieldless_variants: false,\n+                          combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                              show_substructure(a, b, c)\n+                          })),\n+                      }],\n         associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)\n }\n \n /// We use the debug builders to do the heavy lifting here\n-fn show_substructure(cx: &mut ExtCtxt, span: Span,\n-                     substr: &Substructure) -> P<Expr> {\n+fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n     // build fmt.debug_struct(<name>).field(<fieldname>, &<fieldval>)....build()\n     // or fmt.debug_tuple(<name>).field(&<fieldval>)....build()\n     // based on the \"shape\".\n     let (ident, is_struct) = match *substr.fields {\n         Struct(vdata, _) => (substr.type_ident, vdata.is_struct()),\n         EnumMatching(_, v, _) => (v.node.name, v.node.data.is_struct()),\n-        EnumNonMatchingCollapsed(..) | StaticStruct(..) | StaticEnum(..) => {\n-            cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\")\n-        }\n+        EnumNonMatchingCollapsed(..) |\n+        StaticStruct(..) |\n+        StaticEnum(..) => cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\"),\n     };\n \n     // We want to make sure we have the expn_id set so that we can use unstable methods\n-    let span = Span { expn_id: cx.backtrace(), .. span };\n-    let name = cx.expr_lit(span, ast::LitKind::Str(ident.name.as_str(), ast::StrStyle::Cooked));\n+    let span = Span { expn_id: cx.backtrace(), ..span };\n+    let name = cx.expr_lit(span,\n+                           ast::LitKind::Str(ident.name.as_str(), ast::StrStyle::Cooked));\n     let builder = token::str_to_ident(\"builder\");\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n     let fmt = substr.nonself_args[0].clone();\n \n     let mut stmts = match *substr.fields {\n-        Struct(_, ref fields) | EnumMatching(_, _, ref fields) => {\n+        Struct(_, ref fields) |\n+        EnumMatching(_, _, ref fields) => {\n             let mut stmts = vec![];\n             if !is_struct {\n                 // tuple struct/\"normal\" variant\n-                let expr = cx.expr_method_call(span,\n-                                               fmt,\n-                                               token::str_to_ident(\"debug_tuple\"),\n-                                               vec![name]);\n+                let expr =\n+                    cx.expr_method_call(span, fmt, token::str_to_ident(\"debug_tuple\"), vec![name]);\n                 stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n@@ -105,16 +101,14 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n                 }\n             } else {\n                 // normal struct/struct variant\n-                let expr = cx.expr_method_call(span,\n-                                               fmt,\n-                                               token::str_to_ident(\"debug_struct\"),\n-                                               vec![name]);\n+                let expr =\n+                    cx.expr_method_call(span, fmt, token::str_to_ident(\"debug_struct\"), vec![name]);\n                 stmts.push(cx.stmt_let(DUMMY_SP, true, builder, expr));\n \n                 for field in fields {\n-                    let name = cx.expr_lit(field.span, ast::LitKind::Str(\n-                            field.name.unwrap().name.as_str(),\n-                            ast::StrStyle::Cooked));\n+                    let name = cx.expr_lit(field.span,\n+                                           ast::LitKind::Str(field.name.unwrap().name.as_str(),\n+                                                             ast::StrStyle::Cooked));\n \n                     // Use double indirection to make sure this works for unsized types\n                     let field = cx.expr_addr_of(field.span, field.self_.clone());\n@@ -128,22 +122,17 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n             }\n             stmts\n         }\n-        _ => unreachable!()\n+        _ => unreachable!(),\n     };\n \n-    let expr = cx.expr_method_call(span,\n-                                   builder_expr,\n-                                   token::str_to_ident(\"finish\"),\n-                                   vec![]);\n+    let expr = cx.expr_method_call(span, builder_expr, token::str_to_ident(\"finish\"), vec![]);\n \n     stmts.push(cx.stmt_expr(expr));\n     let block = cx.block(span, stmts);\n     cx.expr_block(block)\n }\n \n-fn stmt_let_undescore(cx: &mut ExtCtxt,\n-                      sp: Span,\n-                      expr: P<ast::Expr>) -> ast::Stmt {\n+fn stmt_let_undescore(cx: &mut ExtCtxt, sp: Span, expr: P<ast::Expr>) -> ast::Stmt {\n     let local = P(ast::Local {\n         pat: cx.pat_wild(sp),\n         ty: None,"}, {"sha": "9a332227053c7bab3576145baf8b5c0eca153fe9", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 87, "deletions": 88, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -15,8 +15,8 @@ use deriving::generic::*;\n use deriving::generic::ty::*;\n \n use syntax::ast;\n-use syntax::ast::{MetaItem, Expr, Mutability};\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ast::{Expr, MetaItem, Mutability};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n@@ -27,17 +27,15 @@ pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n                                        span: Span,\n                                        mitem: &MetaItem,\n                                        item: &Annotatable,\n-                                       push: &mut FnMut(Annotatable))\n-{\n+                                       push: &mut FnMut(Annotatable)) {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n }\n \n pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n-                                 push: &mut FnMut(Annotatable))\n-{\n+                                 push: &mut FnMut(Annotatable)) {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n \n@@ -46,64 +44,64 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n                                  push: &mut FnMut(Annotatable),\n-                                 krate: &'static str)\n-{\n+                                 krate: &'static str) {\n     if cx.crate_root != Some(\"std\") {\n         // FIXME(#21880): lift this requirement.\n-        cx.span_err(span, \"this trait cannot be derived with #![no_std] \\\n+        cx.span_err(span,\n+                    \"this trait cannot be derived with #![no_std] \\\n                            or #![no_core]\");\n-        return\n+        return;\n     }\n \n     let typaram = &*deriving::hygienic_type_parameter(item, \"__D\");\n \n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec!(krate, \"Decodable\"), None, vec!(), true),\n+        path: Path::new_(vec![krate, \"Decodable\"], None, vec![], true),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        methods: vec!(\n-            MethodDef {\n-                name: \"decode\",\n-                generics: LifetimeBounds {\n-                    lifetimes: Vec::new(),\n-                    bounds: vec![(typaram,\n-                                  vec![Path::new_(vec!(krate, \"Decoder\"), None, vec!(), true)])]\n-                },\n-                explicit_self: None,\n-                args: vec!(Ptr(Box::new(Literal(Path::new_local(typaram))),\n-                           Borrowed(None, Mutability::Mutable))),\n-                ret_ty: Literal(Path::new_(\n-                    pathvec_std!(cx, core::result::Result),\n-                    None,\n-                    vec!(Box::new(Self_), Box::new(Literal(Path::new_(\n+        methods: vec![MethodDef {\n+                          name: \"decode\",\n+                          generics: LifetimeBounds {\n+                              lifetimes: Vec::new(),\n+                              bounds: vec![(typaram,\n+                                            vec![Path::new_(vec![krate, \"Decoder\"],\n+                                                            None,\n+                                                            vec![],\n+                                                            true)])],\n+                          },\n+                          explicit_self: None,\n+                          args: vec![Ptr(Box::new(Literal(Path::new_local(typaram))),\n+                                         Borrowed(None, Mutability::Mutable))],\n+                          ret_ty:\n+                              Literal(Path::new_(pathvec_std!(cx, core::result::Result),\n+                                                 None,\n+                                                 vec!(Box::new(Self_), Box::new(Literal(Path::new_(\n                         vec![typaram, \"Error\"], None, vec![], false\n                     )))),\n-                    true\n-                )),\n-                attributes: Vec::new(),\n-                is_unsafe: false,\n-                unify_fieldless_variants: false,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    decodable_substructure(a, b, c, krate)\n-                })),\n-            }\n-        ),\n+                                                 true)),\n+                          attributes: Vec::new(),\n+                          is_unsafe: false,\n+                          unify_fieldless_variants: false,\n+                          combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                              decodable_substructure(a, b, c, krate)\n+                          })),\n+                      }],\n         associated_types: Vec::new(),\n     };\n \n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n+fn decodable_substructure(cx: &mut ExtCtxt,\n+                          trait_span: Span,\n                           substr: &Substructure,\n-                          krate: &str) -> P<Expr> {\n+                          krate: &str)\n+                          -> P<Expr> {\n     let decoder = substr.nonself_args[0].clone();\n-    let recurse = vec!(cx.ident_of(krate),\n-                    cx.ident_of(\"Decodable\"),\n-                    cx.ident_of(\"decode\"));\n+    let recurse = vec![cx.ident_of(krate), cx.ident_of(\"Decodable\"), cx.ident_of(\"decode\")];\n     let exprdecode = cx.expr_path(cx.path_global(trait_span, recurse));\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_d\");\n@@ -113,31 +111,28 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n         StaticStruct(_, ref summary) => {\n             let nfields = match *summary {\n                 Unnamed(ref fields) => fields.len(),\n-                Named(ref fields) => fields.len()\n+                Named(ref fields) => fields.len(),\n             };\n             let read_struct_field = cx.ident_of(\"read_struct_field\");\n \n             let path = cx.path_ident(trait_span, substr.type_ident);\n-            let result = decode_static_fields(cx,\n-                                              trait_span,\n-                                              path,\n-                                              summary,\n-                                              |cx, span, name, field| {\n-                cx.expr_try(span,\n-                    cx.expr_method_call(span, blkdecoder.clone(), read_struct_field,\n-                                        vec!(cx.expr_str(span, name),\n-                                          cx.expr_usize(span, field),\n-                                          exprdecode.clone())))\n-            });\n+            let result =\n+                decode_static_fields(cx, trait_span, path, summary, |cx, span, name, field| {\n+                    cx.expr_try(span,\n+                                cx.expr_method_call(span,\n+                                                    blkdecoder.clone(),\n+                                                    read_struct_field,\n+                                                    vec![cx.expr_str(span, name),\n+                                                         cx.expr_usize(span, field),\n+                                                         exprdecode.clone()]))\n+                });\n             let result = cx.expr_ok(trait_span, result);\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_struct\"),\n-                                vec!(\n-                cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n-                cx.expr_usize(trait_span, nfields),\n-                cx.lambda_expr_1(trait_span, result, blkarg)\n-            ))\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                     cx.expr_usize(trait_span, nfields),\n+                                     cx.lambda_expr_1(trait_span, result, blkarg)])\n         }\n         StaticEnum(_, ref fields) => {\n             let variant = cx.ident_of(\"i\");\n@@ -150,42 +145,39 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 variants.push(cx.expr_str(v_span, ident.name.as_str()));\n \n                 let path = cx.path(trait_span, vec![substr.type_ident, ident]);\n-                let decoded = decode_static_fields(cx,\n-                                                   v_span,\n-                                                   path,\n-                                                   parts,\n-                                                   |cx, span, _, field| {\n+                let decoded = decode_static_fields(cx, v_span, path, parts, |cx, span, _, field| {\n                     let idx = cx.expr_usize(span, field);\n                     cx.expr_try(span,\n-                        cx.expr_method_call(span, blkdecoder.clone(), rvariant_arg,\n-                                            vec!(idx, exprdecode.clone())))\n+                                cx.expr_method_call(span,\n+                                                    blkdecoder.clone(),\n+                                                    rvariant_arg,\n+                                                    vec![idx, exprdecode.clone()]))\n                 });\n \n                 arms.push(cx.arm(v_span,\n-                                 vec!(cx.pat_lit(v_span, cx.expr_usize(v_span, i))),\n+                                 vec![cx.pat_lit(v_span, cx.expr_usize(v_span, i))],\n                                  decoded));\n             }\n \n             arms.push(cx.arm_unreachable(trait_span));\n \n-            let result = cx.expr_ok(trait_span,\n-                                    cx.expr_match(trait_span,\n-                                                  cx.expr_ident(trait_span, variant), arms));\n-            let lambda = cx.lambda_expr(trait_span, vec!(blkarg, variant), result);\n+            let result =\n+                cx.expr_ok(trait_span,\n+                           cx.expr_match(trait_span, cx.expr_ident(trait_span, variant), arms));\n+            let lambda = cx.lambda_expr(trait_span, vec![blkarg, variant], result);\n             let variant_vec = cx.expr_vec(trait_span, variants);\n             let variant_vec = cx.expr_addr_of(trait_span, variant_vec);\n-            let result = cx.expr_method_call(trait_span, blkdecoder,\n+            let result = cx.expr_method_call(trait_span,\n+                                             blkdecoder,\n                                              cx.ident_of(\"read_enum_variant\"),\n-                                             vec!(variant_vec, lambda));\n+                                             vec![variant_vec, lambda]);\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_enum\"),\n-                                vec!(\n-                cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n-                cx.lambda_expr_1(trait_span, result, blkarg)\n-            ))\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                     cx.lambda_expr_1(trait_span, result, blkarg)])\n         }\n-        _ => cx.bug(\"expected StaticEnum or StaticStruct in derive(Decodable)\")\n+        _ => cx.bug(\"expected StaticEnum or StaticStruct in derive(Decodable)\"),\n     };\n }\n \n@@ -197,30 +189,37 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                            outer_pat_path: ast::Path,\n                            fields: &StaticFields,\n                            mut getarg: F)\n-                           -> P<Expr> where\n-    F: FnMut(&mut ExtCtxt, Span, InternedString, usize) -> P<Expr>,\n+                           -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt, Span, InternedString, usize) -> P<Expr>\n {\n     match *fields {\n         Unnamed(ref fields) => {\n             let path_expr = cx.expr_path(outer_pat_path);\n             if fields.is_empty() {\n                 path_expr\n             } else {\n-                let fields = fields.iter().enumerate().map(|(i, &span)| {\n-                    getarg(cx, span,\n-                           token::intern_and_get_ident(&format!(\"_field{}\", i)),\n-                           i)\n-                }).collect();\n+                let fields = fields.iter()\n+                    .enumerate()\n+                    .map(|(i, &span)| {\n+                        getarg(cx,\n+                               span,\n+                               token::intern_and_get_ident(&format!(\"_field{}\", i)),\n+                               i)\n+                    })\n+                    .collect();\n \n                 cx.expr_call(trait_span, path_expr, fields)\n             }\n         }\n         Named(ref fields) => {\n             // use the field's span to get nicer error messages.\n-            let fields = fields.iter().enumerate().map(|(i, &(ident, span))| {\n-                let arg = getarg(cx, span, ident.name.as_str(), i);\n-                cx.field_imm(span, ident, arg)\n-            }).collect();\n+            let fields = fields.iter()\n+                .enumerate()\n+                .map(|(i, &(ident, span))| {\n+                    let arg = getarg(cx, span, ident.name.as_str(), i);\n+                    cx.field_imm(span, ident, arg)\n+                })\n+                .collect();\n             cx.expr_struct(trait_span, outer_pat_path, fields)\n         }\n     }"}, {"sha": "9df3db938b1f918fba8649a251f19ff34aa2511e", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -11,8 +11,8 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr};\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ast::{Expr, MetaItem};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n@@ -22,32 +22,29 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: &MetaItem,\n                                item: &Annotatable,\n-                               push: &mut FnMut(Annotatable))\n-{\n+                               push: &mut FnMut(Annotatable)) {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n-    let attrs = vec!(cx.attribute(span, inline));\n+    let attrs = vec![cx.attribute(span, inline)];\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n         path: path_std!(cx, core::default::Default),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        methods: vec!(\n-            MethodDef {\n-                name: \"default\",\n-                generics: LifetimeBounds::empty(),\n-                explicit_self: None,\n-                args: Vec::new(),\n-                ret_ty: Self_,\n-                attributes: attrs,\n-                is_unsafe: false,\n-                unify_fieldless_variants: false,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    default_substructure(a, b, c)\n-                }))\n-            }\n-        ),\n+        methods: vec![MethodDef {\n+                          name: \"default\",\n+                          generics: LifetimeBounds::empty(),\n+                          explicit_self: None,\n+                          args: Vec::new(),\n+                          ret_ty: Self_,\n+                          attributes: attrs,\n+                          is_unsafe: false,\n+                          unify_fieldless_variants: false,\n+                          combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                              default_substructure(a, b, c)\n+                          })),\n+                      }],\n         associated_types: Vec::new(),\n     };\n     trait_def.expand(cx, mitem, item, push)\n@@ -69,18 +66,19 @@ fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructur\n                     }\n                 }\n                 Named(ref fields) => {\n-                    let default_fields = fields.iter().map(|&(ident, span)| {\n-                        cx.field_imm(span, ident, default_call(span))\n-                    }).collect();\n+                    let default_fields = fields.iter()\n+                        .map(|&(ident, span)| cx.field_imm(span, ident, default_call(span)))\n+                        .collect();\n                     cx.expr_struct_ident(trait_span, substr.type_ident, default_fields)\n                 }\n             }\n         }\n         StaticEnum(..) => {\n-            cx.span_err(trait_span, \"`Default` cannot be derived for enums, only structs\");\n+            cx.span_err(trait_span,\n+                        \"`Default` cannot be derived for enums, only structs\");\n             // let compilation continue\n             cx.expr_usize(trait_span, 0)\n         }\n-        _ => cx.span_bug(trait_span, \"Non-static method in `derive(Default)`\")\n+        _ => cx.span_bug(trait_span, \"Non-static method in `derive(Default)`\"),\n     };\n }"}, {"sha": "940fdf037711ffac788171a8c8a30423744bd04e", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 43, "deletions": 49, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -92,8 +92,8 @@ use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, ExprKind, Mutability};\n-use syntax::ext::base::{ExtCtxt,Annotatable};\n+use syntax::ast::{Expr, ExprKind, MetaItem, Mutability};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n@@ -103,17 +103,15 @@ pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n                                        span: Span,\n                                        mitem: &MetaItem,\n                                        item: &Annotatable,\n-                                       push: &mut FnMut(Annotatable))\n-{\n+                                       push: &mut FnMut(Annotatable)) {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n }\n \n pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n-                                 push: &mut FnMut(Annotatable))\n-{\n+                                 push: &mut FnMut(Annotatable)) {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n \n@@ -122,11 +120,11 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n                                  push: &mut FnMut(Annotatable),\n-                                 krate: &'static str)\n-{\n+                                 krate: &'static str) {\n     if cx.crate_root != Some(\"std\") {\n         // FIXME(#21880): lift this requirement.\n-        cx.span_err(span, \"this trait cannot be derived with #![no_std] \\\n+        cx.span_err(span,\n+                    \"this trait cannot be derived with #![no_std] \\\n                            or #![no_core]\");\n         return;\n     }\n@@ -136,7 +134,7 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n-        path: Path::new_(vec!(krate, \"Encodable\"), None, vec!(), true),\n+        path: Path::new_(vec![krate, \"Encodable\"], None, vec![], true),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n@@ -173,40 +171,38 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n-                          substr: &Substructure, krate: &'static str) -> P<Expr> {\n+fn encodable_substructure(cx: &mut ExtCtxt,\n+                          trait_span: Span,\n+                          substr: &Substructure,\n+                          krate: &'static str)\n+                          -> P<Expr> {\n     let encoder = substr.nonself_args[0].clone();\n     // throw an underscore in front to suppress unused variable warnings\n     let blkarg = cx.ident_of(\"_e\");\n     let blkencoder = cx.expr_ident(trait_span, blkarg);\n-    let fn_path = cx.expr_path(cx.path_global(trait_span, vec![cx.ident_of(krate),\n-                                                               cx.ident_of(\"Encodable\"),\n-                                                               cx.ident_of(\"encode\")]));\n+    let fn_path = cx.expr_path(cx.path_global(trait_span,\n+                                              vec![cx.ident_of(krate),\n+                                                   cx.ident_of(\"Encodable\"),\n+                                                   cx.ident_of(\"encode\")]));\n \n     return match *substr.fields {\n         Struct(_, ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = Vec::new();\n-            for (i, &FieldInfo {\n-                    name,\n-                    ref self_,\n-                    span,\n-                    ..\n-                }) in fields.iter().enumerate() {\n+            for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n                     Some(id) => id.name.as_str(),\n-                    None => {\n-                        token::intern_and_get_ident(&format!(\"_field{}\", i))\n-                    }\n+                    None => token::intern_and_get_ident(&format!(\"_field{}\", i)),\n                 };\n                 let self_ref = cx.expr_addr_of(span, self_.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n-                let call = cx.expr_method_call(span, blkencoder.clone(),\n+                let call = cx.expr_method_call(span,\n+                                               blkencoder.clone(),\n                                                emit_struct_field,\n-                                               vec!(cx.expr_str(span, name),\n-                                                 cx.expr_usize(span, i),\n-                                                 lambda));\n+                                               vec![cx.expr_str(span, name),\n+                                                    cx.expr_usize(span, i),\n+                                                    lambda]);\n \n                 // last call doesn't need a try!\n                 let last = fields.len() - 1;\n@@ -229,11 +225,9 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             cx.expr_method_call(trait_span,\n                                 encoder,\n                                 cx.ident_of(\"emit_struct\"),\n-                                vec!(\n-                cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n-                cx.expr_usize(trait_span, fields.len()),\n-                blk\n-            ))\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                     cx.expr_usize(trait_span, fields.len()),\n+                                     blk])\n         }\n \n         EnumMatching(idx, variant, ref fields) => {\n@@ -248,14 +242,14 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             if !fields.is_empty() {\n                 let last = fields.len() - 1;\n                 for (i, &FieldInfo { ref self_, span, .. }) in fields.iter().enumerate() {\n-                let self_ref = cx.expr_addr_of(span, self_.clone());\n-                    let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref,\n-                                                                       blkencoder.clone()]);\n+                    let self_ref = cx.expr_addr_of(span, self_.clone());\n+                    let enc =\n+                        cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n                     let lambda = cx.lambda_expr_1(span, enc, blkarg);\n-                    let call = cx.expr_method_call(span, blkencoder.clone(),\n+                    let call = cx.expr_method_call(span,\n+                                                   blkencoder.clone(),\n                                                    emit_variant_arg,\n-                                                   vec!(cx.expr_usize(span, i),\n-                                                        lambda));\n+                                                   vec![cx.expr_usize(span, i), lambda]);\n                     let call = if i != last {\n                         cx.expr_try(span, call)\n                     } else {\n@@ -271,23 +265,23 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n             let name = cx.expr_str(trait_span, variant.node.name.name.as_str());\n-            let call = cx.expr_method_call(trait_span, blkencoder,\n+            let call = cx.expr_method_call(trait_span,\n+                                           blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n-                                           vec!(name,\n-                                             cx.expr_usize(trait_span, idx),\n-                                             cx.expr_usize(trait_span, fields.len()),\n-                                             blk));\n+                                           vec![name,\n+                                                cx.expr_usize(trait_span, idx),\n+                                                cx.expr_usize(trait_span, fields.len()),\n+                                                blk]);\n             let blk = cx.lambda_expr_1(trait_span, call, blkarg);\n             let ret = cx.expr_method_call(trait_span,\n                                           encoder,\n                                           cx.ident_of(\"emit_enum\"),\n-                                          vec!(\n-                cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n-                blk\n-            ));\n+                                          vec![cx.expr_str(trait_span,\n+                                                           substr.type_ident.name.as_str()),\n+                                               blk]);\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n         }\n \n-        _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\")\n+        _ => cx.bug(\"expected Struct or EnumMatching in derive(Encodable)\"),\n     };\n }"}, {"sha": "cd49e7ec9d2c6764ce98c42a3bd270eace612025", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 382, "deletions": 351, "changes": 733, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -192,16 +192,16 @@ use std::collections::HashSet;\n use std::vec;\n \n use syntax::abi::Abi;\n-use syntax::ast::{self, EnumDef, Expr, Ident, Generics, VariantData, BinOpKind, PatKind};\n+use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind, VariantData};\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{self, respan};\n use syntax::util::move_map::MoveMap;\n-use syntax::parse::token::{keywords, InternedString};\n+use syntax::parse::token::{InternedString, keywords};\n use syntax::ptr::P;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{DUMMY_SP, Span};\n use errors::Handler;\n \n use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n@@ -273,7 +273,7 @@ pub struct Substructure<'a> {\n     pub self_args: &'a [P<Expr>],\n     /// verbatim access to any other arguments\n     pub nonself_args: &'a [P<Expr>],\n-    pub fields: &'a SubstructureFields<'a>\n+    pub fields: &'a SubstructureFields<'a>,\n }\n \n /// Summary of the relevant parts of a struct/enum field.\n@@ -338,14 +338,17 @@ pub type EnumNonMatchCollapsedFunc<'a> =\n     Box<FnMut(&mut ExtCtxt, Span, (&[Ident], &[Ident]), &[P<Expr>]) -> P<Expr> + 'a>;\n \n pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n-    -> RefCell<CombineSubstructureFunc<'a>> {\n+                                -> RefCell<CombineSubstructureFunc<'a>> {\n     RefCell::new(f)\n }\n \n /// This method helps to extract all the type parameters referenced from a\n /// type. For a type parameter `<T>`, it looks for either a `TyPath` that\n /// is not global and starts with `T`, or a `TyQPath`.\n-fn find_type_parameters(ty: &ast::Ty, ty_param_names: &[ast::Name], span: Span, cx: &ExtCtxt)\n+fn find_type_parameters(ty: &ast::Ty,\n+                        ty_param_names: &[ast::Name],\n+                        span: Span,\n+                        cx: &ExtCtxt)\n                         -> Vec<P<ast::Ty>> {\n     use syntax::visit;\n \n@@ -395,23 +398,15 @@ impl<'a> TraitDef<'a> {\n                   cx: &mut ExtCtxt,\n                   mitem: &ast::MetaItem,\n                   item: &'a Annotatable,\n-                  push: &mut FnMut(Annotatable))\n-    {\n+                  push: &mut FnMut(Annotatable)) {\n         match *item {\n             Annotatable::Item(ref item) => {\n                 let newitem = match item.node {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => {\n-                        self.expand_struct_def(cx,\n-                                               &struct_def,\n-                                               item.ident,\n-                                               generics)\n+                        self.expand_struct_def(cx, &struct_def, item.ident, generics)\n                     }\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n-                        self.expand_enum_def(cx,\n-                                             enum_def,\n-                                             &item.attrs,\n-                                             item.ident,\n-                                             generics)\n+                        self.expand_enum_def(cx, enum_def, &item.attrs, item.ident, generics)\n                     }\n                     _ => {\n                         cx.span_err(mitem.span,\n@@ -422,19 +417,20 @@ impl<'a> TraitDef<'a> {\n                 // Keep the lint attributes of the previous item to control how the\n                 // generated implementations are linted\n                 let mut attrs = newitem.attrs.clone();\n-                attrs.extend(item.attrs.iter().filter(|a| {\n-                    match &a.name()[..] {\n-                        \"allow\" | \"warn\" | \"deny\" | \"forbid\" | \"stable\" | \"unstable\" => true,\n-                        _ => false,\n-                    }\n-                }).cloned());\n-                push(Annotatable::Item(P(ast::Item {\n-                    attrs: attrs,\n-                    ..(*newitem).clone()\n-                })))\n+                attrs.extend(item.attrs\n+                    .iter()\n+                    .filter(|a| {\n+                        match &a.name()[..] {\n+                            \"allow\" | \"warn\" | \"deny\" | \"forbid\" | \"stable\" | \"unstable\" => true,\n+                            _ => false,\n+                        }\n+                    })\n+                    .cloned());\n+                push(Annotatable::Item(P(ast::Item { attrs: attrs, ..(*newitem).clone() })))\n             }\n             _ => {\n-                cx.span_err(mitem.span, \"`derive` may only be applied to structs and enums\");\n+                cx.span_err(mitem.span,\n+                            \"`derive` may only be applied to structs and enums\");\n             }\n         }\n     }\n@@ -475,7 +471,8 @@ impl<'a> TraitDef<'a> {\n                            type_ident: Ident,\n                            generics: &Generics,\n                            field_tys: Vec<P<ast::Ty>>,\n-                           methods: Vec<ast::ImplItem>) -> P<ast::Item> {\n+                           methods: Vec<ast::ImplItem>)\n+                           -> P<ast::Item> {\n         let trait_path = self.path.to_path(cx, self.span, type_ident, generics);\n \n         // Transform associated types from `deriving::ty::Ty` into `ast::ImplItem`\n@@ -487,16 +484,12 @@ impl<'a> TraitDef<'a> {\n                 vis: ast::Visibility::Inherited,\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n-                node: ast::ImplItemKind::Type(type_def.to_ty(cx,\n-                    self.span,\n-                    type_ident,\n-                    generics\n-                )),\n+                node: ast::ImplItemKind::Type(type_def.to_ty(cx, self.span, type_ident, generics)),\n             }\n         });\n \n-        let Generics { mut lifetimes, ty_params, mut where_clause } =\n-            self.generics.to_generics(cx, self.span, type_ident, generics);\n+        let Generics { mut lifetimes, ty_params, mut where_clause } = self.generics\n+            .to_generics(cx, self.span, type_ident, generics);\n         let mut ty_params = ty_params.into_vec();\n \n         // Copy the lifetimes\n@@ -521,10 +514,7 @@ impl<'a> TraitDef<'a> {\n                 bounds.push((*declared_bound).clone());\n             }\n \n-            cx.typaram(self.span,\n-                       ty_param.ident,\n-                       P::from_vec(bounds),\n-                       None)\n+            cx.typaram(self.span, ty_param.ident, P::from_vec(bounds), None)\n         }));\n \n         // and similarly for where clauses\n@@ -542,15 +532,15 @@ impl<'a> TraitDef<'a> {\n                     ast::WherePredicate::RegionPredicate(ast::WhereRegionPredicate {\n                         span: self.span,\n                         lifetime: rb.lifetime,\n-                        bounds: rb.bounds.iter().cloned().collect()\n+                        bounds: rb.bounds.iter().cloned().collect(),\n                     })\n                 }\n                 ast::WherePredicate::EqPredicate(ref we) => {\n                     ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n                         id: ast::DUMMY_NODE_ID,\n                         span: self.span,\n                         path: we.path.clone(),\n-                        ty: we.ty.clone()\n+                        ty: we.ty.clone(),\n                     })\n                 }\n             }\n@@ -568,16 +558,17 @@ impl<'a> TraitDef<'a> {\n                 for ty in tys {\n                     // if we have already handled this type, skip it\n                     if let ast::TyKind::Path(_, ref p) = ty.node {\n-                        if p.segments.len() == 1\n-                            && ty_param_names.contains(&p.segments[0].identifier.name)\n-                            || processed_field_types.contains(&p.segments) {\n+                        if p.segments.len() == 1 &&\n+                           ty_param_names.contains(&p.segments[0].identifier.name) ||\n+                           processed_field_types.contains(&p.segments) {\n                             continue;\n                         };\n                         processed_field_types.insert(p.segments.clone());\n                     }\n-                    let mut bounds: Vec<_> = self.additional_bounds.iter().map(|p| {\n-                        cx.typarambound(p.to_path(cx, self.span, type_ident, generics))\n-                    }).collect();\n+                    let mut bounds: Vec<_> = self.additional_bounds\n+                        .iter()\n+                        .map(|p| cx.typarambound(p.to_path(cx, self.span, type_ident, generics)))\n+                        .collect();\n \n                     // require the current trait\n                     bounds.push(cx.typarambound(trait_path.clone()));\n@@ -598,40 +589,41 @@ impl<'a> TraitDef<'a> {\n         let trait_generics = Generics {\n             lifetimes: lifetimes,\n             ty_params: P::from_vec(ty_params),\n-            where_clause: where_clause\n+            where_clause: where_clause,\n         };\n \n         // Create the reference to the trait.\n         let trait_ref = cx.trait_ref(trait_path);\n \n         // Create the type parameters on the `self` path.\n-        let self_ty_params = generics.ty_params.iter().map(|ty_param| {\n-            cx.ty_ident(self.span, ty_param.ident)\n-        }).collect();\n+        let self_ty_params = generics.ty_params\n+            .iter()\n+            .map(|ty_param| cx.ty_ident(self.span, ty_param.ident))\n+            .collect();\n \n-        let self_lifetimes: Vec<ast::Lifetime> =\n-            generics.lifetimes\n+        let self_lifetimes: Vec<ast::Lifetime> = generics.lifetimes\n             .iter()\n             .map(|ld| ld.lifetime)\n             .collect();\n \n         // Create the type of `self`.\n-        let self_type = cx.ty_path(\n-            cx.path_all(self.span, false, vec!( type_ident ), self_lifetimes,\n-                        self_ty_params, Vec::new()));\n-\n-        let attr = cx.attribute(\n-            self.span,\n-            cx.meta_word(self.span,\n-                         InternedString::new(\"automatically_derived\")));\n+        let self_type = cx.ty_path(cx.path_all(self.span,\n+                                               false,\n+                                               vec![type_ident],\n+                                               self_lifetimes,\n+                                               self_ty_params,\n+                                               Vec::new()));\n+\n+        let attr = cx.attribute(self.span,\n+                                cx.meta_word(self.span,\n+                                             InternedString::new(\"automatically_derived\")));\n         // Just mark it now since we know that it'll end up used downstream\n         attr::mark_used(&attr);\n         let opt_trait_ref = Some(trait_ref);\n-        let unused_qual = cx.attribute(\n-            self.span,\n-            cx.meta_list(self.span,\n-                         InternedString::new(\"allow\"),\n-                         vec![cx.meta_word(self.span,\n+        let unused_qual = cx.attribute(self.span,\n+                                       cx.meta_list(self.span,\n+                                                    InternedString::new(\"allow\"),\n+                                                    vec![cx.meta_word(self.span,\n                                            InternedString::new(\"unused_qualifications\"))]));\n         let mut a = vec![attr, unused_qual];\n         a.extend(self.attributes.iter().cloned());\n@@ -642,58 +634,60 @@ impl<'a> TraitDef<'a> {\n             ast::Unsafety::Normal\n         };\n \n-        cx.item(\n-            self.span,\n-            keywords::Invalid.ident(),\n-            a,\n-            ast::ItemKind::Impl(unsafety,\n-                                ast::ImplPolarity::Positive,\n-                                trait_generics,\n-                                opt_trait_ref,\n-                                self_type,\n-                                methods.into_iter().chain(associated_types).collect()))\n+        cx.item(self.span,\n+                keywords::Invalid.ident(),\n+                a,\n+                ast::ItemKind::Impl(unsafety,\n+                                    ast::ImplPolarity::Positive,\n+                                    trait_generics,\n+                                    opt_trait_ref,\n+                                    self_type,\n+                                    methods.into_iter().chain(associated_types).collect()))\n     }\n \n     fn expand_struct_def(&self,\n                          cx: &mut ExtCtxt,\n                          struct_def: &'a VariantData,\n                          type_ident: Ident,\n-                         generics: &Generics) -> P<ast::Item> {\n-        let field_tys: Vec<P<ast::Ty>> = struct_def.fields().iter()\n+                         generics: &Generics)\n+                         -> P<ast::Item> {\n+        let field_tys: Vec<P<ast::Ty>> = struct_def.fields()\n+            .iter()\n             .map(|field| field.ty.clone())\n             .collect();\n \n-        let methods = self.methods.iter().map(|method_def| {\n-            let (explicit_self, self_args, nonself_args, tys) =\n-                method_def.split_self_nonself_args(\n-                    cx, self, type_ident, generics);\n-\n-            let body = if method_def.is_static() {\n-                method_def.expand_static_struct_method_body(\n-                    cx,\n-                    self,\n-                    struct_def,\n-                    type_ident,\n-                    &self_args[..],\n-                    &nonself_args[..])\n-            } else {\n-                method_def.expand_struct_method_body(cx,\n-                                                     self,\n-                                                     struct_def,\n-                                                     type_ident,\n-                                                     &self_args[..],\n-                                                     &nonself_args[..])\n-            };\n-\n-            method_def.create_method(cx,\n-                                     self,\n-                                     type_ident,\n-                                     generics,\n-                                     Abi::Rust,\n-                                     explicit_self,\n-                                     tys,\n-                                     body)\n-        }).collect();\n+        let methods = self.methods\n+            .iter()\n+            .map(|method_def| {\n+                let (explicit_self, self_args, nonself_args, tys) =\n+                    method_def.split_self_nonself_args(cx, self, type_ident, generics);\n+\n+                let body = if method_def.is_static() {\n+                    method_def.expand_static_struct_method_body(cx,\n+                                                                self,\n+                                                                struct_def,\n+                                                                type_ident,\n+                                                                &self_args[..],\n+                                                                &nonself_args[..])\n+                } else {\n+                    method_def.expand_struct_method_body(cx,\n+                                                         self,\n+                                                         struct_def,\n+                                                         type_ident,\n+                                                         &self_args[..],\n+                                                         &nonself_args[..])\n+                };\n+\n+                method_def.create_method(cx,\n+                                         self,\n+                                         type_ident,\n+                                         generics,\n+                                         Abi::Rust,\n+                                         explicit_self,\n+                                         tys,\n+                                         body)\n+            })\n+            .collect();\n \n         self.create_derived_impl(cx, type_ident, generics, field_tys, methods)\n     }\n@@ -703,53 +697,57 @@ impl<'a> TraitDef<'a> {\n                        enum_def: &'a EnumDef,\n                        type_attrs: &[ast::Attribute],\n                        type_ident: Ident,\n-                       generics: &Generics) -> P<ast::Item> {\n+                       generics: &Generics)\n+                       -> P<ast::Item> {\n         let mut field_tys = Vec::new();\n \n         for variant in &enum_def.variants {\n-            field_tys.extend(variant.node.data.fields().iter()\n+            field_tys.extend(variant.node\n+                .data\n+                .fields()\n+                .iter()\n                 .map(|field| field.ty.clone()));\n         }\n \n-        let methods = self.methods.iter().map(|method_def| {\n-            let (explicit_self, self_args, nonself_args, tys) =\n-                method_def.split_self_nonself_args(cx, self,\n-                                                   type_ident, generics);\n-\n-            let body = if method_def.is_static() {\n-                method_def.expand_static_enum_method_body(\n-                    cx,\n-                    self,\n-                    enum_def,\n-                    type_ident,\n-                    &self_args[..],\n-                    &nonself_args[..])\n-            } else {\n-                method_def.expand_enum_method_body(cx,\n-                                                   self,\n-                                                   enum_def,\n-                                                   type_attrs,\n-                                                   type_ident,\n-                                                   self_args,\n-                                                   &nonself_args[..])\n-            };\n-\n-            method_def.create_method(cx,\n-                                     self,\n-                                     type_ident,\n-                                     generics,\n-                                     Abi::Rust,\n-                                     explicit_self,\n-                                     tys,\n-                                     body)\n-        }).collect();\n+        let methods = self.methods\n+            .iter()\n+            .map(|method_def| {\n+                let (explicit_self, self_args, nonself_args, tys) =\n+                    method_def.split_self_nonself_args(cx, self, type_ident, generics);\n+\n+                let body = if method_def.is_static() {\n+                    method_def.expand_static_enum_method_body(cx,\n+                                                              self,\n+                                                              enum_def,\n+                                                              type_ident,\n+                                                              &self_args[..],\n+                                                              &nonself_args[..])\n+                } else {\n+                    method_def.expand_enum_method_body(cx,\n+                                                       self,\n+                                                       enum_def,\n+                                                       type_attrs,\n+                                                       type_ident,\n+                                                       self_args,\n+                                                       &nonself_args[..])\n+                };\n+\n+                method_def.create_method(cx,\n+                                         self,\n+                                         type_ident,\n+                                         generics,\n+                                         Abi::Rust,\n+                                         explicit_self,\n+                                         tys,\n+                                         body)\n+            })\n+            .collect();\n \n         self.create_derived_impl(cx, type_ident, generics, field_tys, methods)\n     }\n }\n \n-fn find_repr_type_name(diagnostic: &Handler,\n-                       type_attrs: &[ast::Attribute]) -> &'static str {\n+fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &'static str {\n     let mut repr_type_name = \"isize\";\n     for a in type_attrs {\n         for r in &attr::find_repr_attrs(diagnostic, a) {\n@@ -782,13 +780,13 @@ impl<'a> MethodDef<'a> {\n                                 self_args: &[P<Expr>],\n                                 nonself_args: &[P<Expr>],\n                                 fields: &SubstructureFields)\n-        -> P<Expr> {\n+                                -> P<Expr> {\n         let substructure = Substructure {\n             type_ident: type_ident,\n             method_ident: cx.ident_of(self.name),\n             self_args: self_args,\n             nonself_args: nonself_args,\n-            fields: fields\n+            fields: fields,\n         };\n         let mut f = self.combine_substructure.borrow_mut();\n         let f: &mut CombineSubstructureFunc = &mut *f;\n@@ -808,12 +806,13 @@ impl<'a> MethodDef<'a> {\n         self.explicit_self.is_none()\n     }\n \n-    fn split_self_nonself_args(&self,\n-                               cx: &mut ExtCtxt,\n-                               trait_: &TraitDef,\n-                               type_ident: Ident,\n-                               generics: &Generics)\n-        -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n+    fn split_self_nonself_args\n+        (&self,\n+         cx: &mut ExtCtxt,\n+         trait_: &TraitDef,\n+         type_ident: Ident,\n+         generics: &Generics)\n+         -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n \n         let mut self_args = Vec::new();\n         let mut nonself_args = Vec::new();\n@@ -839,7 +838,7 @@ impl<'a> MethodDef<'a> {\n             match *ty {\n                 // for static methods, just treat any Self\n                 // arguments as a normal arg\n-                Self_ if nonstatic  => {\n+                Self_ if nonstatic => {\n                     self_args.push(arg_expr);\n                 }\n                 Ptr(ref ty, _) if **ty == Self_ && nonstatic => {\n@@ -861,18 +860,20 @@ impl<'a> MethodDef<'a> {\n                      generics: &Generics,\n                      abi: Abi,\n                      explicit_self: Option<ast::ExplicitSelf>,\n-                     arg_types: Vec<(Ident, P<ast::Ty>)> ,\n-                     body: P<Expr>) -> ast::ImplItem {\n+                     arg_types: Vec<(Ident, P<ast::Ty>)>,\n+                     body: P<Expr>)\n+                     -> ast::ImplItem {\n \n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n         let args = {\n             let self_args = explicit_self.map(|explicit_self| {\n-                ast::Arg::from_self(explicit_self, respan(trait_.span, keywords::SelfValue.ident()))\n+                ast::Arg::from_self(explicit_self,\n+                                    respan(trait_.span, keywords::SelfValue.ident()))\n             });\n             let nonself_args = arg_types.into_iter()\n-                                        .map(|(name, ty)| cx.arg(trait_.span, name, ty));\n+                .map(|(name, ty)| cx.arg(trait_.span, name, ty));\n             self_args.into_iter().chain(nonself_args).collect()\n         };\n \n@@ -897,12 +898,13 @@ impl<'a> MethodDef<'a> {\n             defaultness: ast::Defaultness::Final,\n             ident: method_ident,\n             node: ast::ImplItemKind::Method(ast::MethodSig {\n-                generics: fn_generics,\n-                abi: abi,\n-                unsafety: unsafety,\n-                constness: ast::Constness::NotConst,\n-                decl: fn_decl\n-            }, body_block)\n+                                                generics: fn_generics,\n+                                                abi: abi,\n+                                                unsafety: unsafety,\n+                                                constness: ast::Constness::NotConst,\n+                                                decl: fn_decl,\n+                                            },\n+                                            body_block),\n         }\n     }\n \n@@ -926,26 +928,24 @@ impl<'a> MethodDef<'a> {\n     /// }\n     /// ```\n     fn expand_struct_method_body<'b>(&self,\n-                                 cx: &mut ExtCtxt,\n-                                 trait_: &TraitDef<'b>,\n-                                 struct_def: &'b VariantData,\n-                                 type_ident: Ident,\n-                                 self_args: &[P<Expr>],\n-                                 nonself_args: &[P<Expr>])\n-        -> P<Expr> {\n+                                     cx: &mut ExtCtxt,\n+                                     trait_: &TraitDef<'b>,\n+                                     struct_def: &'b VariantData,\n+                                     type_ident: Ident,\n+                                     self_args: &[P<Expr>],\n+                                     nonself_args: &[P<Expr>])\n+                                     -> P<Expr> {\n \n         let mut raw_fields = Vec::new(); // Vec<[fields of self],\n                                  // [fields of next Self arg], [etc]>\n         let mut patterns = Vec::new();\n         for i in 0..self_args.len() {\n-            let struct_path= cx.path(DUMMY_SP, vec!( type_ident ));\n-            let (pat, ident_expr) =\n-                trait_.create_struct_pattern(cx,\n-                                             struct_path,\n-                                             struct_def,\n-                                             &format!(\"__self_{}\",\n-                                                     i),\n-                                             ast::Mutability::Immutable);\n+            let struct_path = cx.path(DUMMY_SP, vec![type_ident]);\n+            let (pat, ident_expr) = trait_.create_struct_pattern(cx,\n+                                                                 struct_path,\n+                                                                 struct_def,\n+                                                                 &format!(\"__self_{}\", i),\n+                                                                 ast::Mutability::Immutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n         }\n@@ -954,42 +954,44 @@ impl<'a> MethodDef<'a> {\n         let fields = if !raw_fields.is_empty() {\n             let mut raw_fields = raw_fields.into_iter().map(|v| v.into_iter());\n             let first_field = raw_fields.next().unwrap();\n-            let mut other_fields: Vec<vec::IntoIter<_>>\n-                = raw_fields.collect();\n+            let mut other_fields: Vec<vec::IntoIter<_>> = raw_fields.collect();\n             first_field.map(|(span, opt_id, field, attrs)| {\n-                FieldInfo {\n-                    span: span,\n-                    name: opt_id,\n-                    self_: field,\n-                    other: other_fields.iter_mut().map(|l| {\n-                        match l.next().unwrap() {\n-                            (_, _, ex, _) => ex\n-                        }\n-                    }).collect(),\n-                    attrs: attrs,\n-                }\n-            }).collect()\n+                    FieldInfo {\n+                        span: span,\n+                        name: opt_id,\n+                        self_: field,\n+                        other: other_fields.iter_mut()\n+                            .map(|l| {\n+                                match l.next().unwrap() {\n+                                    (_, _, ex, _) => ex,\n+                                }\n+                            })\n+                            .collect(),\n+                        attrs: attrs,\n+                    }\n+                })\n+                .collect()\n         } else {\n             cx.span_bug(trait_.span,\n                         \"no self arguments to non-static method in generic \\\n                          `derive`\")\n         };\n \n         // body of the inner most destructuring match\n-        let mut body = self.call_substructure_method(\n-            cx,\n-            trait_,\n-            type_ident,\n-            self_args,\n-            nonself_args,\n-            &Struct(struct_def, fields));\n+        let mut body = self.call_substructure_method(cx,\n+                                                     trait_,\n+                                                     type_ident,\n+                                                     self_args,\n+                                                     nonself_args,\n+                                                     &Struct(struct_def, fields));\n \n         // make a series of nested matches, to destructure the\n         // structs. This is actually right-to-left, but it shouldn't\n         // matter.\n         for (arg_expr, pat) in self_args.iter().zip(patterns) {\n-            body = cx.expr_match(trait_.span, arg_expr.clone(),\n-                                     vec!( cx.arm(trait_.span, vec!(pat.clone()), body) ))\n+            body = cx.expr_match(trait_.span,\n+                                 arg_expr.clone(),\n+                                 vec![cx.arm(trait_.span, vec![pat.clone()], body)])\n         }\n \n         body\n@@ -1002,13 +1004,14 @@ impl<'a> MethodDef<'a> {\n                                         type_ident: Ident,\n                                         self_args: &[P<Expr>],\n                                         nonself_args: &[P<Expr>])\n-        -> P<Expr> {\n+                                        -> P<Expr> {\n         let summary = trait_.summarise_struct(cx, struct_def);\n \n         self.call_substructure_method(cx,\n                                       trait_,\n                                       type_ident,\n-                                      self_args, nonself_args,\n+                                      self_args,\n+                                      nonself_args,\n                                       &StaticStruct(struct_def, summary))\n     }\n \n@@ -1042,16 +1045,21 @@ impl<'a> MethodDef<'a> {\n     /// as their results are unused.  The point of `__self_vi` and\n     /// `__arg_1_vi` is for `PartialOrd`; see #15503.)\n     fn expand_enum_method_body<'b>(&self,\n-                               cx: &mut ExtCtxt,\n-                               trait_: &TraitDef<'b>,\n-                               enum_def: &'b EnumDef,\n-                               type_attrs: &[ast::Attribute],\n-                               type_ident: Ident,\n-                               self_args: Vec<P<Expr>>,\n-                               nonself_args: &[P<Expr>])\n-                               -> P<Expr> {\n-        self.build_enum_match_tuple(\n-            cx, trait_, enum_def, type_attrs, type_ident, self_args, nonself_args)\n+                                   cx: &mut ExtCtxt,\n+                                   trait_: &TraitDef<'b>,\n+                                   enum_def: &'b EnumDef,\n+                                   type_attrs: &[ast::Attribute],\n+                                   type_ident: Ident,\n+                                   self_args: Vec<P<Expr>>,\n+                                   nonself_args: &[P<Expr>])\n+                                   -> P<Expr> {\n+        self.build_enum_match_tuple(cx,\n+                                    trait_,\n+                                    enum_def,\n+                                    type_attrs,\n+                                    type_ident,\n+                                    self_args,\n+                                    nonself_args)\n     }\n \n \n@@ -1090,20 +1098,21 @@ impl<'a> MethodDef<'a> {\n     ///     ... // catch-all remainder can inspect above variant index values.\n     /// }\n     /// ```\n-    fn build_enum_match_tuple<'b>(\n-        &self,\n-        cx: &mut ExtCtxt,\n-        trait_: &TraitDef<'b>,\n-        enum_def: &'b EnumDef,\n-        type_attrs: &[ast::Attribute],\n-        type_ident: Ident,\n-        self_args: Vec<P<Expr>>,\n-        nonself_args: &[P<Expr>]) -> P<Expr> {\n+    fn build_enum_match_tuple<'b>(&self,\n+                                  cx: &mut ExtCtxt,\n+                                  trait_: &TraitDef<'b>,\n+                                  enum_def: &'b EnumDef,\n+                                  type_attrs: &[ast::Attribute],\n+                                  type_ident: Ident,\n+                                  self_args: Vec<P<Expr>>,\n+                                  nonself_args: &[P<Expr>])\n+                                  -> P<Expr> {\n \n         let sp = trait_.span;\n         let variants = &enum_def.variants;\n \n-        let self_arg_names = self_args.iter().enumerate()\n+        let self_arg_names = self_args.iter()\n+            .enumerate()\n             .map(|(arg_count, _self_arg)| {\n                 if arg_count == 0 {\n                     \"__self\".to_string()\n@@ -1114,22 +1123,24 @@ impl<'a> MethodDef<'a> {\n             .collect::<Vec<String>>();\n \n         let self_arg_idents = self_arg_names.iter()\n-            .map(|name|cx.ident_of(&name[..]))\n+            .map(|name| cx.ident_of(&name[..]))\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n         // a series of let statements mapping each self_arg to an int\n         // value corresponding to its discriminant.\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n-            .map(|name| { let vi_suffix = format!(\"{}_vi\", &name[..]);\n-                          cx.ident_of(&vi_suffix[..]) })\n+            .map(|name| {\n+                let vi_suffix = format!(\"{}_vi\", &name[..]);\n+                cx.ident_of(&vi_suffix[..])\n+            })\n             .collect::<Vec<ast::Ident>>();\n \n         // Builds, via callback to call_substructure_method, the\n         // delegated expression that handles the catch-all case,\n         // using `__variants_tuple` to drive logic if necessary.\n-        let catch_all_substructure = EnumNonMatchingCollapsed(\n-            self_arg_idents, &variants[..], &vi_idents[..]);\n+        let catch_all_substructure =\n+            EnumNonMatchingCollapsed(self_arg_idents, &variants[..], &vi_idents[..]);\n \n         let first_fieldless = variants.iter().find(|v| v.node.data.fields().is_empty());\n \n@@ -1138,15 +1149,16 @@ impl<'a> MethodDef<'a> {\n         // (Variant2, Variant2, ...) => Body2\n         // ...\n         // where each tuple has length = self_args.len()\n-        let mut match_arms: Vec<ast::Arm> = variants.iter().enumerate()\n+        let mut match_arms: Vec<ast::Arm> = variants.iter()\n+            .enumerate()\n             .filter(|&(_, v)| !(self.unify_fieldless_variants && v.node.data.fields().is_empty()))\n             .map(|(index, variant)| {\n                 let mk_self_pat = |cx: &mut ExtCtxt, self_arg_name: &str| {\n-                    let (p, idents) = trait_.create_enum_variant_pattern(\n-                        cx, type_ident,\n-                        variant,\n-                        self_arg_name,\n-                        ast::Mutability::Immutable);\n+                    let (p, idents) = trait_.create_enum_variant_pattern(cx,\n+                                                     type_ident,\n+                                                     variant,\n+                                                     self_arg_name,\n+                                                     ast::Mutability::Immutable);\n                     (cx.pat(sp, PatKind::Ref(p, ast::Mutability::Immutable)), idents)\n                 };\n \n@@ -1213,32 +1225,37 @@ impl<'a> MethodDef<'a> {\n                 // expressions for referencing every field of every\n                 // Self arg, assuming all are instances of VariantK.\n                 // Build up code associated with such a case.\n-                let substructure = EnumMatching(index,\n-                                                variant,\n-                                                field_tuples);\n-                let arm_expr = self.call_substructure_method(\n-                    cx, trait_, type_ident, &self_args[..], nonself_args,\n-                    &substructure);\n+                let substructure = EnumMatching(index, variant, field_tuples);\n+                let arm_expr = self.call_substructure_method(cx,\n+                                                             trait_,\n+                                                             type_ident,\n+                                                             &self_args[..],\n+                                                             nonself_args,\n+                                                             &substructure);\n \n                 cx.arm(sp, vec![single_pat], arm_expr)\n-            }).collect();\n+            })\n+            .collect();\n \n         let default = match first_fieldless {\n             Some(v) if self.unify_fieldless_variants => {\n                 // We need a default case that handles the fieldless variants.\n                 // The index and actual variant aren't meaningful in this case,\n                 // so just use whatever\n-                Some(self.call_substructure_method(\n-                    cx, trait_, type_ident, &self_args[..], nonself_args,\n-                    &EnumMatching(0, v, Vec::new())))\n+                Some(self.call_substructure_method(cx,\n+                                                   trait_,\n+                                                   type_ident,\n+                                                   &self_args[..],\n+                                                   nonself_args,\n+                                                   &EnumMatching(0, v, Vec::new())))\n             }\n             _ if variants.len() > 1 && self_args.len() > 1 => {\n                 // Since we know that all the arguments will match if we reach\n                 // the match expression we add the unreachable intrinsics as the\n                 // result of the catch all which should help llvm in optimizing it\n                 Some(deriving::call_intrinsic(cx, sp, \"unreachable\", vec![]))\n             }\n-            _ => None\n+            _ => None,\n         };\n         if let Some(arm) = default {\n             match_arms.push(cx.arm(sp, vec![cx.pat_wild(sp)], arm));\n@@ -1279,20 +1296,17 @@ impl<'a> MethodDef<'a> {\n             // ```\n             let mut index_let_stmts: Vec<ast::Stmt> = Vec::new();\n \n-            //We also build an expression which checks whether all discriminants are equal\n+            // We also build an expression which checks whether all discriminants are equal\n             // discriminant_test = __self0_vi == __self1_vi && __self0_vi == __self2_vi && ...\n             let mut discriminant_test = cx.expr_bool(sp, true);\n \n-            let target_type_name =\n-                find_repr_type_name(&cx.parse_sess.span_diagnostic, type_attrs);\n+            let target_type_name = find_repr_type_name(&cx.parse_sess.span_diagnostic, type_attrs);\n \n             let mut first_ident = None;\n             for (&ident, self_arg) in vi_idents.iter().zip(&self_args) {\n                 let self_addr = cx.expr_addr_of(sp, self_arg.clone());\n-                let variant_value = deriving::call_intrinsic(cx,\n-                                                             sp,\n-                                                             \"discriminant_value\",\n-                                                             vec![self_addr]);\n+                let variant_value =\n+                    deriving::call_intrinsic(cx, sp, \"discriminant_value\", vec![self_addr]);\n \n                 let target_ty = cx.ty_ident(sp, cx.ident_of(target_type_name));\n                 let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n@@ -1304,18 +1318,21 @@ impl<'a> MethodDef<'a> {\n                         let first_expr = cx.expr_ident(sp, first);\n                         let id = cx.expr_ident(sp, ident);\n                         let test = cx.expr_binary(sp, BinOpKind::Eq, first_expr, id);\n-                        discriminant_test = cx.expr_binary(sp, BinOpKind::And,\n-                                                           discriminant_test, test)\n+                        discriminant_test =\n+                            cx.expr_binary(sp, BinOpKind::And, discriminant_test, test)\n                     }\n                     None => {\n                         first_ident = Some(ident);\n                     }\n                 }\n             }\n \n-            let arm_expr = self.call_substructure_method(\n-                cx, trait_, type_ident, &self_args[..], nonself_args,\n-                &catch_all_substructure);\n+            let arm_expr = self.call_substructure_method(cx,\n+                                                         trait_,\n+                                                         type_ident,\n+                                                         &self_args[..],\n+                                                         nonself_args,\n+                                                         &catch_all_substructure);\n \n             // Final wrinkle: the self_args are expressions that deref\n             // down to desired l-values, but we cannot actually deref\n@@ -1325,7 +1342,7 @@ impl<'a> MethodDef<'a> {\n             let borrowed_self_args = self_args.move_map(|self_arg| cx.expr_addr_of(sp, self_arg));\n             let match_arg = cx.expr(sp, ast::ExprKind::Tup(borrowed_self_args));\n \n-            //Lastly we create an expression which branches on all discriminants being equal\n+            // Lastly we create an expression which branches on all discriminants being equal\n             //  if discriminant_test {\n             //      match (...) {\n             //          (Variant1, Variant1, ...) => Body1\n@@ -1392,8 +1409,7 @@ impl<'a> MethodDef<'a> {\n             // that needs the feature gate enabled.)\n \n             deriving::call_intrinsic(cx, sp, \"unreachable\", vec![])\n-        }\n-        else {\n+        } else {\n \n             // Final wrinkle: the self_args are expressions that deref\n             // down to desired l-values, but we cannot actually deref\n@@ -1413,26 +1429,30 @@ impl<'a> MethodDef<'a> {\n                                       type_ident: Ident,\n                                       self_args: &[P<Expr>],\n                                       nonself_args: &[P<Expr>])\n-        -> P<Expr> {\n-        let summary = enum_def.variants.iter().map(|v| {\n-            let ident = v.node.name;\n-            let summary = trait_.summarise_struct(cx, &v.node.data);\n-            (ident, v.span, summary)\n-        }).collect();\n-        self.call_substructure_method(cx, trait_, type_ident,\n-                                      self_args, nonself_args,\n+                                      -> P<Expr> {\n+        let summary = enum_def.variants\n+            .iter()\n+            .map(|v| {\n+                let ident = v.node.name;\n+                let summary = trait_.summarise_struct(cx, &v.node.data);\n+                (ident, v.span, summary)\n+            })\n+            .collect();\n+        self.call_substructure_method(cx,\n+                                      trait_,\n+                                      type_ident,\n+                                      self_args,\n+                                      nonself_args,\n                                       &StaticEnum(enum_def, summary))\n     }\n }\n \n // general helper methods.\n impl<'a> TraitDef<'a> {\n-    fn summarise_struct(&self,\n-                        cx: &mut ExtCtxt,\n-                        struct_def: &VariantData) -> StaticFields {\n+    fn summarise_struct(&self, cx: &mut ExtCtxt, struct_def: &VariantData) -> StaticFields {\n         let mut named_idents = Vec::new();\n         let mut just_spans = Vec::new();\n-        for field in struct_def.fields(){\n+        for field in struct_def.fields() {\n             let sp = Span { expn_id: self.span.expn_id, ..field.span };\n             match field.ident {\n                 Some(ident) => named_idents.push((ident, sp)),\n@@ -1441,9 +1461,11 @@ impl<'a> TraitDef<'a> {\n         }\n \n         match (just_spans.is_empty(), named_idents.is_empty()) {\n-            (false, false) => cx.span_bug(self.span,\n-                                          \"a struct with named and unnamed \\\n-                                          fields in generic `derive`\"),\n+            (false, false) => {\n+                cx.span_bug(self.span,\n+                            \"a struct with named and unnamed \\\n+                                          fields in generic `derive`\")\n+            }\n             // named fields\n             (_, false) => Named(named_idents),\n             // empty structs\n@@ -1454,46 +1476,57 @@ impl<'a> TraitDef<'a> {\n \n     fn create_subpatterns(&self,\n                           cx: &mut ExtCtxt,\n-                          field_paths: Vec<ast::SpannedIdent> ,\n+                          field_paths: Vec<ast::SpannedIdent>,\n                           mutbl: ast::Mutability)\n                           -> Vec<P<ast::Pat>> {\n-        field_paths.iter().map(|path| {\n-            cx.pat(path.span,\n-                        PatKind::Ident(ast::BindingMode::ByRef(mutbl), (*path).clone(), None))\n-        }).collect()\n+        field_paths.iter()\n+            .map(|path| {\n+                cx.pat(path.span,\n+                       PatKind::Ident(ast::BindingMode::ByRef(mutbl), (*path).clone(), None))\n+            })\n+            .collect()\n     }\n \n-    fn create_struct_pattern(&self,\n-                             cx: &mut ExtCtxt,\n-                             struct_path: ast::Path,\n-                             struct_def: &'a VariantData,\n-                             prefix: &str,\n-                             mutbl: ast::Mutability)\n-                             -> (P<ast::Pat>, Vec<(Span, Option<Ident>,\n-                                                   P<Expr>,\n-                                                   &'a [ast::Attribute])>) {\n+    fn create_struct_pattern\n+        (&self,\n+         cx: &mut ExtCtxt,\n+         struct_path: ast::Path,\n+         struct_def: &'a VariantData,\n+         prefix: &str,\n+         mutbl: ast::Mutability)\n+         -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n         let mut paths = Vec::new();\n         let mut ident_exprs = Vec::new();\n         for (i, struct_field) in struct_def.fields().iter().enumerate() {\n             let sp = Span { expn_id: self.span.expn_id, ..struct_field.span };\n             let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n-            paths.push(codemap::Spanned{span: sp, node: ident});\n-            let val = cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)));\n+            paths.push(codemap::Spanned {\n+                span: sp,\n+                node: ident,\n+            });\n+            let val = cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp, ident)));\n             let val = cx.expr(sp, ast::ExprKind::Paren(val));\n             ident_exprs.push((sp, struct_field.ident, val, &struct_field.attrs[..]));\n         }\n \n         let subpats = self.create_subpatterns(cx, paths, mutbl);\n         let pattern = if struct_def.is_struct() {\n-            let field_pats = subpats.into_iter().zip(&ident_exprs).map(|(pat, &(sp, ident, _, _))| {\n-                if ident.is_none() {\n-                    cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n-                }\n-                codemap::Spanned {\n-                    span: pat.span,\n-                    node: ast::FieldPat { ident: ident.unwrap(), pat: pat, is_shorthand: false },\n-                }\n-            }).collect();\n+            let field_pats = subpats.into_iter()\n+                .zip(&ident_exprs)\n+                .map(|(pat, &(sp, ident, _, _))| {\n+                    if ident.is_none() {\n+                        cx.span_bug(sp, \"a braced struct with unnamed fields in `derive`\");\n+                    }\n+                    codemap::Spanned {\n+                        span: pat.span,\n+                        node: ast::FieldPat {\n+                            ident: ident.unwrap(),\n+                            pat: pat,\n+                            is_shorthand: false,\n+                        },\n+                    }\n+                })\n+                .collect();\n             cx.pat_struct(self.span, struct_path, field_pats)\n         } else {\n             cx.pat_enum(self.span, struct_path, subpats)\n@@ -1502,20 +1535,21 @@ impl<'a> TraitDef<'a> {\n         (pattern, ident_exprs)\n     }\n \n-    fn create_enum_variant_pattern(&self,\n-                                   cx: &mut ExtCtxt,\n-                                   enum_ident: ast::Ident,\n-                                   variant: &'a ast::Variant,\n-                                   prefix: &str,\n-                                   mutbl: ast::Mutability)\n-        -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n+    fn create_enum_variant_pattern\n+        (&self,\n+         cx: &mut ExtCtxt,\n+         enum_ident: ast::Ident,\n+         variant: &'a ast::Variant,\n+         prefix: &str,\n+         mutbl: ast::Mutability)\n+         -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n         let variant_ident = variant.node.name;\n         let variant_path = cx.path(variant.span, vec![enum_ident, variant_ident]);\n         self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl)\n     }\n }\n \n-/* helpful premade recipes */\n+// helpful premade recipes\n \n /// Fold the fields. `use_foldl` controls whether this is done\n /// left-to-right (`true`) or right-to-left (`false`).\n@@ -1526,35 +1560,29 @@ pub fn cs_fold<F>(use_foldl: bool,\n                   cx: &mut ExtCtxt,\n                   trait_span: Span,\n                   substructure: &Substructure)\n-                  -> P<Expr> where\n-    F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n+                  -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>\n {\n     match *substructure.fields {\n-        EnumMatching(_, _, ref all_fields) | Struct(_, ref all_fields) => {\n+        EnumMatching(_, _, ref all_fields) |\n+        Struct(_, ref all_fields) => {\n             if use_foldl {\n                 all_fields.iter().fold(base, |old, field| {\n-                    f(cx,\n-                      field.span,\n-                      old,\n-                      field.self_.clone(),\n-                      &field.other)\n+                    f(cx, field.span, old, field.self_.clone(), &field.other)\n                 })\n             } else {\n                 all_fields.iter().rev().fold(base, |old, field| {\n-                    f(cx,\n-                      field.span,\n-                      old,\n-                      field.self_.clone(),\n-                      &field.other)\n+                    f(cx, field.span, old, field.self_.clone(), &field.other)\n                 })\n             }\n-        },\n-        EnumNonMatchingCollapsed(ref all_args, _, tuple) =>\n-            enum_nonmatch_f(cx, trait_span, (&all_args[..], tuple),\n-                            substructure.nonself_args),\n-        StaticEnum(..) | StaticStruct(..) => {\n-            cx.span_bug(trait_span, \"static function in `derive`\")\n         }\n+        EnumNonMatchingCollapsed(ref all_args, _, tuple) => {\n+            enum_nonmatch_f(cx,\n+                            trait_span,\n+                            (&all_args[..], tuple),\n+                            substructure.nonself_args)\n+        }\n+        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n     }\n }\n \n@@ -1572,29 +1600,34 @@ pub fn cs_same_method<F>(f: F,\n                          cx: &mut ExtCtxt,\n                          trait_span: Span,\n                          substructure: &Substructure)\n-                         -> P<Expr> where\n-    F: FnOnce(&mut ExtCtxt, Span, Vec<P<Expr>>) -> P<Expr>,\n+                         -> P<Expr>\n+    where F: FnOnce(&mut ExtCtxt, Span, Vec<P<Expr>>) -> P<Expr>\n {\n     match *substructure.fields {\n-        EnumMatching(_, _, ref all_fields) | Struct(_, ref all_fields) => {\n+        EnumMatching(_, _, ref all_fields) |\n+        Struct(_, ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n-            let called = all_fields.iter().map(|field| {\n-                cx.expr_method_call(field.span,\n-                                    field.self_.clone(),\n-                                    substructure.method_ident,\n-                                    field.other.iter()\n-                                               .map(|e| cx.expr_addr_of(field.span, e.clone()))\n-                                               .collect())\n-            }).collect();\n+            let called = all_fields.iter()\n+                .map(|field| {\n+                    cx.expr_method_call(field.span,\n+                                        field.self_.clone(),\n+                                        substructure.method_ident,\n+                                        field.other\n+                                            .iter()\n+                                            .map(|e| cx.expr_addr_of(field.span, e.clone()))\n+                                            .collect())\n+                })\n+                .collect();\n \n             f(cx, trait_span, called)\n-        },\n-        EnumNonMatchingCollapsed(ref all_self_args, _, tuple) =>\n-            enum_nonmatch_f(cx, trait_span, (&all_self_args[..], tuple),\n-                            substructure.nonself_args),\n-        StaticEnum(..) | StaticStruct(..) => {\n-            cx.span_bug(trait_span, \"static function in `derive`\")\n         }\n+        EnumNonMatchingCollapsed(ref all_self_args, _, tuple) => {\n+            enum_nonmatch_f(cx,\n+                            trait_span,\n+                            (&all_self_args[..], tuple),\n+                            substructure.nonself_args)\n+        }\n+        StaticEnum(..) | StaticStruct(..) => cx.span_bug(trait_span, \"static function in `derive`\"),\n     }\n }\n \n@@ -1606,10 +1639,8 @@ pub fn is_type_without_fields(item: &Annotatable) -> bool {\n             ast::ItemKind::Enum(ref enum_def, _) => {\n                 enum_def.variants.iter().all(|v| v.node.data.fields().is_empty())\n             }\n-            ast::ItemKind::Struct(ref variant_data, _) => {\n-                variant_data.fields().is_empty()\n-            }\n-            _ => false\n+            ast::ItemKind::Struct(ref variant_data, _) => variant_data.fields().is_empty(),\n+            _ => false,\n         }\n     } else {\n         false"}, {"sha": "81c8e7112dbd590d131d29dc9165e6b6a05fb45d", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -12,8 +12,8 @@ use deriving;\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{MetaItem, Expr, Mutability};\n-use syntax::ext::base::{ExtCtxt, Annotatable};\n+use syntax::ast::{Expr, MetaItem, Mutability};\n+use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax_pos::Span;\n@@ -22,11 +22,9 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n                             item: &Annotatable,\n-                            push: &mut FnMut(Annotatable))\n-{\n+                            push: &mut FnMut(Annotatable)) {\n \n-    let path = Path::new_(pathvec_std!(cx, core::hash::Hash), None,\n-                          vec!(), true);\n+    let path = Path::new_(pathvec_std!(cx, core::hash::Hash), None, vec![], true);\n \n     let typaram = &*deriving::hygienic_type_parameter(item, \"__H\");\n \n@@ -38,25 +36,23 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        methods: vec!(\n-            MethodDef {\n-                name: \"hash\",\n-                generics: LifetimeBounds {\n-                    lifetimes: Vec::new(),\n-                    bounds: vec![(typaram,\n-                                  vec![path_std!(cx, core::hash::Hasher)])],\n-                },\n-                explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(Box::new(Literal(arg)), Borrowed(None, Mutability::Mutable))),\n-                ret_ty: nil_ty(),\n-                attributes: vec![],\n-                is_unsafe: false,\n-                unify_fieldless_variants: true,\n-                combine_substructure: combine_substructure(Box::new(|a, b, c| {\n-                    hash_substructure(a, b, c)\n-                }))\n-            }\n-        ),\n+        methods: vec![MethodDef {\n+                          name: \"hash\",\n+                          generics: LifetimeBounds {\n+                              lifetimes: Vec::new(),\n+                              bounds: vec![(typaram, vec![path_std!(cx, core::hash::Hasher)])],\n+                          },\n+                          explicit_self: borrowed_explicit_self(),\n+                          args: vec![Ptr(Box::new(Literal(arg)),\n+                                         Borrowed(None, Mutability::Mutable))],\n+                          ret_ty: nil_ty(),\n+                          attributes: vec![],\n+                          is_unsafe: false,\n+                          unify_fieldless_variants: true,\n+                          combine_substructure: combine_substructure(Box::new(|a, b, c| {\n+                              hash_substructure(a, b, c)\n+                          })),\n+                      }],\n         associated_types: Vec::new(),\n     };\n \n@@ -66,7 +62,10 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n     let state_expr = match (substr.nonself_args.len(), substr.nonself_args.get(0)) {\n         (1, Some(o_f)) => o_f,\n-        _ => cx.span_bug(trait_span, \"incorrect number of arguments in `derive(Hash)`\")\n+        _ => {\n+            cx.span_bug(trait_span,\n+                        \"incorrect number of arguments in `derive(Hash)`\")\n+        }\n     };\n     let call_hash = |span, thing_expr| {\n         let hash_path = {\n@@ -75,7 +74,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n             cx.expr_path(cx.path_global(span, strs))\n         };\n         let ref_thing = cx.expr_addr_of(span, thing_expr);\n-        let expr = cx.expr_call(span, hash_path, vec!(ref_thing, state_expr.clone()));\n+        let expr = cx.expr_call(span, hash_path, vec![ref_thing, state_expr.clone()]);\n         cx.stmt_expr(expr)\n     };\n     let mut stmts = Vec::new();\n@@ -92,7 +91,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n \n             fs\n         }\n-        _ => cx.span_bug(trait_span, \"impossible substructure in `derive(Hash)`\")\n+        _ => cx.span_bug(trait_span, \"impossible substructure in `derive(Hash)`\"),\n     };\n \n     for &FieldInfo { ref self_, span, .. } in fields {"}, {"sha": "80e2a923e5569ef9693f5efd9742c17e46e1198c", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/936bfea94b800551c972e5689ae7da86d3d601de/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=936bfea94b800551c972e5689ae7da86d3d601de", "patch": "@@ -10,9 +10,9 @@\n \n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n-use syntax::ast::{MetaItem, MetaItemKind, self};\n+use syntax::ast::{self, MetaItem, MetaItemKind};\n use syntax::attr::AttrMetaMethods;\n-use syntax::ext::base::{ExtCtxt, SyntaxEnv, Annotatable};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxEnv};\n use syntax::ext::base::{MultiDecorator, MultiItemDecorator, MultiModifier};\n use syntax::ext::build::AstBuilder;\n use syntax::feature_gate;\n@@ -123,7 +123,8 @@ fn expand_derive(cx: &mut ExtCtxt,\n                             span: Some(titem.span),\n                             allow_internal_unstable: true,\n                         },\n-                    }), ..titem.span\n+                    }),\n+                    ..titem.span\n                 };\n \n                 if &tname[..] == \"Eq\" {\n@@ -133,27 +134,28 @@ fn expand_derive(cx: &mut ExtCtxt,\n                 }\n \n                 // #[derive(Foo, Bar)] expands to #[derive_Foo] #[derive_Bar]\n-                item.attrs.push(cx.attribute(span, cx.meta_word(titem.span,\n-                    intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n+                item.attrs.push(cx.attribute(span,\n+                               cx.meta_word(titem.span,\n+                                            intern_and_get_ident(&format!(\"derive_{}\", tname)))));\n             }\n \n             // RFC #1445. `#[derive(PartialEq, Eq)]` adds a (trusted)\n             // `#[structural_match]` attribute.\n             if let Some(eq_span) = eq_span {\n                 if found_partial_eq {\n                     let structural_match = intern_and_get_ident(\"structural_match\");\n-                    item.attrs.push(cx.attribute(eq_span,\n-                                                 cx.meta_word(eq_span,\n-                                                              structural_match)));\n+                    item.attrs.push(cx.attribute(eq_span, cx.meta_word(eq_span, structural_match)));\n                 }\n             }\n \n             item\n         })\n-    }, |a| {\n-        cx.span_err(span, \"`derive` can only be applied to items\");\n-        a\n-    });\n+    },\n+                                        |a| {\n+                                            cx.span_err(span,\n+                                                        \"`derive` can only be applied to items\");\n+                                            a\n+                                        });\n     debug!(\"expand_derive: annotatable output = {:?}\", annot);\n     annot\n }\n@@ -261,8 +263,10 @@ fn warn_if_deprecated(ecx: &mut ExtCtxt, sp: Span, name: &str) {\n         \"Decodable\" => Some(\"RustcDecodable\"),\n         _ => None,\n     } {\n-        ecx.span_warn(sp, &format!(\"derive({}) is deprecated in favor of derive({})\",\n-                                   name, replacement));\n+        ecx.span_warn(sp,\n+                      &format!(\"derive({}) is deprecated in favor of derive({})\",\n+                               name,\n+                               replacement));\n     }\n }\n \n@@ -275,8 +279,7 @@ fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n     if let Annotatable::Item(ref item) = *item {\n         match item.node {\n             ast::ItemKind::Struct(_, ast::Generics { ref ty_params, .. }) |\n-                ast::ItemKind::Enum(_, ast::Generics { ref ty_params, .. }) => {\n-\n+            ast::ItemKind::Enum(_, ast::Generics { ref ty_params, .. }) => {\n                 for ty in ty_params.iter() {\n                     typaram.push_str(&ty.ident.name.as_str());\n                 }\n@@ -293,14 +296,15 @@ fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n fn call_intrinsic(cx: &ExtCtxt,\n                   span: Span,\n                   intrinsic: &str,\n-                  args: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n+                  args: Vec<P<ast::Expr>>)\n+                  -> P<ast::Expr> {\n     let path = cx.std_path(&[\"intrinsics\", intrinsic]);\n     let call = cx.expr_call_global(span, path, args);\n \n     cx.expr_block(P(ast::Block {\n         stmts: vec![cx.stmt_expr(call)],\n         id: ast::DUMMY_NODE_ID,\n         rules: ast::BlockCheckMode::Unsafe(ast::CompilerGenerated),\n-        span: span }))\n+        span: span,\n+    }))\n }\n-"}]}