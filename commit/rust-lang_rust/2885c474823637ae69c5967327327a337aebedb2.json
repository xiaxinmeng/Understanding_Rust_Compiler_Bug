{"sha": "2885c474823637ae69c5967327327a337aebedb2", "node_id": "C_kwDOAAsO6NoAKDI4ODVjNDc0ODIzNjM3YWU2OWM1OTY3MzI3MzI3YTMzN2FlYmVkYjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-20T18:23:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-20T18:23:11Z"}, "message": "Auto merge of #87704 - ChrisDenton:win-resolve-exe, r=yaahc\n\nWindows: Resolve `process::Command` program without using the current directory\n\nCurrently `std::process::Command` searches many directories for the executable to run, including the current directory. This has lead to a [CVE for `ripgrep`](https://cve.circl.lu/cve/CVE-2021-3013) but presumably other command line utilities could be similarly vulnerable if they run commands. This was [discussed on the internals forum](https://internals.rust-lang.org/t/std-command-resolve-to-avoid-security-issues-on-windows/14800). Also discussed was [which directories should be searched](https://internals.rust-lang.org/t/windows-where-should-command-new-look-for-executables/15015).\n\nEDIT: This PR originally removed all implicit paths. They've now been added back as laid out in the rest of this comment.\n\n## Old Search Strategy\n\nThe old search strategy is [documented here][1]. Additionally Rust adds searching the child's paths (see also #37519). So the full list of paths that were searched was:\n\n1. The directories that are listed in the child's `PATH` environment variable.\n2. The directory from which the application loaded.\n3. The current directory for the parent process.\n4. The 32-bit Windows system directory.\n5. The 16-bit Windows system directory.\n6. The Windows directory.\n7. The directories that are listed in the PATH environment variable.\n\n## New Search Strategy\n\nThe new strategy removes the current directory from the searched paths.\n\n1. The directories that are listed in the child's PATH environment variable.\n2. The directory from which the application loaded.\n3. The 32-bit Windows system directory.\n4. The Windows directory.\n5. The directories that are listed in the parent's PATH environment variable.\n\nNote that it also removes the 16-bit system directory, mostly because there isn't a function to get it. I do not anticipate this being an issue in modern Windows.\n\n## Impact\n\nRemoving the current directory should fix CVE's like the one linked above. However, it's possible some Windows users of affected Rust CLI applications have come to expect the old behaviour.\n\nThis change could also affect small Windows-only script-like programs that assumed the current directory would be used. The user would need to use `.\\file.exe` instead of the bare application name.\n\nThis PR could break tests, especially those that test the exact output of error messages (e.g. Cargo) as this does change the error messages is some cases.\n\n[1]: https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa#parameters", "tree": {"sha": "0a0e0dd2863b0efe9e60512e1ef1933a9d41c97c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a0e0dd2863b0efe9e60512e1ef1933a9d41c97c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2885c474823637ae69c5967327327a337aebedb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2885c474823637ae69c5967327327a337aebedb2", "html_url": "https://github.com/rust-lang/rust/commit/2885c474823637ae69c5967327327a337aebedb2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2885c474823637ae69c5967327327a337aebedb2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93542a8240c5f926ac5f3f99cef99366082f9c2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/93542a8240c5f926ac5f3f99cef99366082f9c2b", "html_url": "https://github.com/rust-lang/rust/commit/93542a8240c5f926ac5f3f99cef99366082f9c2b"}, {"sha": "d9a1f9a79c853f7f4678bfe43905ccc7560974bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9a1f9a79c853f7f4678bfe43905ccc7560974bb", "html_url": "https://github.com/rust-lang/rust/commit/d9a1f9a79c853f7f4678bfe43905ccc7560974bb"}], "stats": {"total": 251, "additions": 219, "deletions": 32}, "files": [{"sha": "094d2efbdd5095c0f8be42ce7d870d93d170f553", "filename": "library/std/src/process/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2885c474823637ae69c5967327327a337aebedb2/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2885c474823637ae69c5967327327a337aebedb2/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess%2Ftests.rs?ref=2885c474823637ae69c5967327327a337aebedb2", "patch": "@@ -297,23 +297,23 @@ fn test_interior_nul_in_progname_is_error() {\n \n #[test]\n fn test_interior_nul_in_arg_is_error() {\n-    match Command::new(\"echo\").arg(\"has-some-\\0\\0s-inside\").spawn() {\n+    match Command::new(\"rustc\").arg(\"has-some-\\0\\0s-inside\").spawn() {\n         Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n         Ok(_) => panic!(),\n     }\n }\n \n #[test]\n fn test_interior_nul_in_args_is_error() {\n-    match Command::new(\"echo\").args(&[\"has-some-\\0\\0s-inside\"]).spawn() {\n+    match Command::new(\"rustc\").args(&[\"has-some-\\0\\0s-inside\"]).spawn() {\n         Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n         Ok(_) => panic!(),\n     }\n }\n \n #[test]\n fn test_interior_nul_in_current_dir_is_error() {\n-    match Command::new(\"echo\").current_dir(\"has-some-\\0\\0s-inside\").spawn() {\n+    match Command::new(\"rustc\").current_dir(\"has-some-\\0\\0s-inside\").spawn() {\n         Err(e) => assert_eq!(e.kind(), ErrorKind::InvalidInput),\n         Ok(_) => panic!(),\n     }"}, {"sha": "50c4547de85f69e46f7ff43276367d153e0128f1", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2885c474823637ae69c5967327327a337aebedb2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2885c474823637ae69c5967327327a337aebedb2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=2885c474823637ae69c5967327327a337aebedb2", "patch": "@@ -734,6 +734,7 @@ if #[cfg(not(target_vendor = \"uwp\"))] {\n             lpSecurityAttributes: LPSECURITY_ATTRIBUTES,\n         ) -> BOOL;\n         pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL;\n+        pub fn GetWindowsDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;\n     }\n }\n }\n@@ -773,6 +774,7 @@ extern \"system\" {\n     pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n     pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n \n+    pub fn GetSystemDirectoryW(lpBuffer: LPWSTR, uSize: UINT) -> UINT;\n     pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n     pub fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;\n     pub fn SetLastError(dwErrCode: DWORD);"}, {"sha": "79e0eaf6c34c6e813a80eba3c1d3491745030e48", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2885c474823637ae69c5967327327a337aebedb2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2885c474823637ae69c5967327327a337aebedb2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=2885c474823637ae69c5967327327a337aebedb2", "patch": "@@ -1,9 +1,8 @@\n use super::{c, fill_utf16_buf, to_u16s};\n-use crate::ffi::OsStr;\n+use crate::ffi::{OsStr, OsString};\n use crate::io;\n use crate::mem;\n-use crate::path::Path;\n-use crate::path::Prefix;\n+use crate::path::{Path, PathBuf, Prefix};\n use crate::ptr;\n \n #[cfg(test)]\n@@ -32,6 +31,25 @@ pub fn is_verbatim_sep(b: u8) -> bool {\n     b == b'\\\\'\n }\n \n+/// Returns true if `path` looks like a lone filename.\n+pub(crate) fn is_file_name(path: &OsStr) -> bool {\n+    !path.bytes().iter().copied().any(is_sep_byte)\n+}\n+pub(crate) fn has_trailing_slash(path: &OsStr) -> bool {\n+    let is_verbatim = path.bytes().starts_with(br\"\\\\?\\\");\n+    let is_separator = if is_verbatim { is_verbatim_sep } else { is_sep_byte };\n+    if let Some(&c) = path.bytes().last() { is_separator(c) } else { false }\n+}\n+\n+/// Appends a suffix to a path.\n+///\n+/// Can be used to append an extension without removing an existing extension.\n+pub(crate) fn append_suffix(path: PathBuf, suffix: &OsStr) -> PathBuf {\n+    let mut path = OsString::from(path);\n+    path.push(suffix);\n+    path.into()\n+}\n+\n pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n     use Prefix::{DeviceNS, Disk, Verbatim, VerbatimDisk, VerbatimUNC, UNC};\n "}, {"sha": "66b210ce1bfb3ebcfadc052330fd05cfe2fe8c3c", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 141, "deletions": 26, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/2885c474823637ae69c5967327327a337aebedb2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2885c474823637ae69c5967327327a337aebedb2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=2885c474823637ae69c5967327327a337aebedb2", "patch": "@@ -7,24 +7,24 @@ use crate::cmp;\n use crate::collections::BTreeMap;\n use crate::convert::{TryFrom, TryInto};\n use crate::env;\n-use crate::env::split_paths;\n+use crate::env::consts::{EXE_EXTENSION, EXE_SUFFIX};\n use crate::ffi::{OsStr, OsString};\n use crate::fmt;\n-use crate::fs;\n use crate::io::{self, Error, ErrorKind};\n use crate::mem;\n use crate::num::NonZeroI32;\n-use crate::os::windows::ffi::OsStrExt;\n+use crate::os::windows::ffi::{OsStrExt, OsStringExt};\n use crate::os::windows::io::{AsRawHandle, FromRawHandle, IntoRawHandle};\n-use crate::path::Path;\n+use crate::path::{Path, PathBuf};\n use crate::ptr;\n use crate::sys::c;\n use crate::sys::c::NonZeroDWORD;\n-use crate::sys::cvt;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n+use crate::sys::path;\n use crate::sys::pipe::{self, AnonPipe};\n use crate::sys::stdio;\n+use crate::sys::{cvt, to_u16s};\n use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n use crate::sys_common::{AsInner, IntoInner};\n@@ -258,31 +258,19 @@ impl Command {\n         needs_stdin: bool,\n     ) -> io::Result<(Process, StdioPipes)> {\n         let maybe_env = self.env.capture_if_changed();\n-        // To have the spawning semantics of unix/windows stay the same, we need\n-        // to read the *child's* PATH if one is provided. See #15149 for more\n-        // details.\n-        let program = maybe_env.as_ref().and_then(|env| {\n-            if let Some(v) = env.get(&EnvKey::new(\"PATH\")) {\n-                // Split the value and test each path to see if the\n-                // program exists.\n-                for path in split_paths(&v) {\n-                    let path = path\n-                        .join(self.program.to_str().unwrap())\n-                        .with_extension(env::consts::EXE_EXTENSION);\n-                    if fs::metadata(&path).is_ok() {\n-                        return Some(path.into_os_string());\n-                    }\n-                }\n-            }\n-            None\n-        });\n \n         let mut si = zeroed_startupinfo();\n         si.cb = mem::size_of::<c::STARTUPINFO>() as c::DWORD;\n         si.dwFlags = c::STARTF_USESTDHANDLES;\n \n-        let program = program.as_ref().unwrap_or(&self.program);\n-        let mut cmd_str = make_command_line(program, &self.args, self.force_quotes_enabled)?;\n+        let child_paths = if let Some(env) = maybe_env.as_ref() {\n+            env.get(&EnvKey::new(\"PATH\")).map(|s| s.as_os_str())\n+        } else {\n+            None\n+        };\n+        let program = resolve_exe(&self.program, child_paths)?;\n+        let mut cmd_str =\n+            make_command_line(program.as_os_str(), &self.args, self.force_quotes_enabled)?;\n         cmd_str.push(0); // add null terminator\n \n         // stolen from the libuv code.\n@@ -321,9 +309,10 @@ impl Command {\n         si.hStdOutput = stdout.as_raw_handle();\n         si.hStdError = stderr.as_raw_handle();\n \n+        let program = to_u16s(&program)?;\n         unsafe {\n             cvt(c::CreateProcessW(\n-                ptr::null(),\n+                program.as_ptr(),\n                 cmd_str.as_mut_ptr(),\n                 ptr::null_mut(),\n                 ptr::null_mut(),\n@@ -361,6 +350,132 @@ impl fmt::Debug for Command {\n     }\n }\n \n+// Resolve `exe_path` to the executable name.\n+//\n+// * If the path is simply a file name then use the paths given by `search_paths` to find the executable.\n+// * Otherwise use the `exe_path` as given.\n+//\n+// This function may also append `.exe` to the name. The rationale for doing so is as follows:\n+//\n+// It is a very strong convention that Windows executables have the `exe` extension.\n+// In Rust, it is common to omit this extension.\n+// Therefore this functions first assumes `.exe` was intended.\n+// It falls back to the plain file name if a full path is given and the extension is omitted\n+// or if only a file name is given and it already contains an extension.\n+fn resolve_exe<'a>(exe_path: &'a OsStr, child_paths: Option<&OsStr>) -> io::Result<PathBuf> {\n+    // Early return if there is no filename.\n+    if exe_path.is_empty() || path::has_trailing_slash(exe_path) {\n+        return Err(io::Error::new_const(\n+            io::ErrorKind::InvalidInput,\n+            &\"program path has no file name\",\n+        ));\n+    }\n+    // Test if the file name has the `exe` extension.\n+    // This does a case-insensitive `ends_with`.\n+    let has_exe_suffix = if exe_path.len() >= EXE_SUFFIX.len() {\n+        exe_path.bytes()[exe_path.len() - EXE_SUFFIX.len()..]\n+            .eq_ignore_ascii_case(EXE_SUFFIX.as_bytes())\n+    } else {\n+        false\n+    };\n+\n+    // If `exe_path` is an absolute path or a sub-path then don't search `PATH` for it.\n+    if !path::is_file_name(exe_path) {\n+        if has_exe_suffix {\n+            // The application name is a path to a `.exe` file.\n+            // Let `CreateProcessW` figure out if it exists or not.\n+            return Ok(exe_path.into());\n+        }\n+        let mut path = PathBuf::from(exe_path);\n+\n+        // Append `.exe` if not already there.\n+        path = path::append_suffix(path, EXE_SUFFIX.as_ref());\n+        if path.try_exists().unwrap_or(false) {\n+            return Ok(path);\n+        } else {\n+            // It's ok to use `set_extension` here because the intent is to\n+            // remove the extension that was just added.\n+            path.set_extension(\"\");\n+            return Ok(path);\n+        }\n+    } else {\n+        ensure_no_nuls(exe_path)?;\n+        // From the `CreateProcessW` docs:\n+        // > If the file name does not contain an extension, .exe is appended.\n+        // Note that this rule only applies when searching paths.\n+        let has_extension = exe_path.bytes().contains(&b'.');\n+\n+        // Search the directories given by `search_paths`.\n+        let result = search_paths(child_paths, |mut path| {\n+            path.push(&exe_path);\n+            if !has_extension {\n+                path.set_extension(EXE_EXTENSION);\n+            }\n+            if let Ok(true) = path.try_exists() { Some(path) } else { None }\n+        });\n+        if let Some(path) = result {\n+            return Ok(path);\n+        }\n+    }\n+    // If we get here then the executable cannot be found.\n+    Err(io::Error::new_const(io::ErrorKind::NotFound, &\"program not found\"))\n+}\n+\n+// Calls `f` for every path that should be used to find an executable.\n+// Returns once `f` returns the path to an executable or all paths have been searched.\n+fn search_paths<F>(child_paths: Option<&OsStr>, mut f: F) -> Option<PathBuf>\n+where\n+    F: FnMut(PathBuf) -> Option<PathBuf>,\n+{\n+    // 1. Child paths\n+    // This is for consistency with Rust's historic behaviour.\n+    if let Some(paths) = child_paths {\n+        for path in env::split_paths(paths).filter(|p| !p.as_os_str().is_empty()) {\n+            if let Some(path) = f(path) {\n+                return Some(path);\n+            }\n+        }\n+    }\n+\n+    // 2. Application path\n+    if let Ok(mut app_path) = env::current_exe() {\n+        app_path.pop();\n+        if let Some(path) = f(app_path) {\n+            return Some(path);\n+        }\n+    }\n+\n+    // 3 & 4. System paths\n+    // SAFETY: This uses `fill_utf16_buf` to safely call the OS functions.\n+    unsafe {\n+        if let Ok(Some(path)) = super::fill_utf16_buf(\n+            |buf, size| c::GetSystemDirectoryW(buf, size),\n+            |buf| f(PathBuf::from(OsString::from_wide(buf))),\n+        ) {\n+            return Some(path);\n+        }\n+        #[cfg(not(target_vendor = \"uwp\"))]\n+        {\n+            if let Ok(Some(path)) = super::fill_utf16_buf(\n+                |buf, size| c::GetWindowsDirectoryW(buf, size),\n+                |buf| f(PathBuf::from(OsString::from_wide(buf))),\n+            ) {\n+                return Some(path);\n+            }\n+        }\n+    }\n+\n+    // 5. Parent paths\n+    if let Some(parent_paths) = env::var_os(\"PATH\") {\n+        for path in env::split_paths(&parent_paths).filter(|p| !p.as_os_str().is_empty()) {\n+            if let Some(path) = f(path) {\n+                return Some(path);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n impl Stdio {\n     fn to_handle(&self, stdio_id: c::DWORD, pipe: &mut Option<AnonPipe>) -> io::Result<Handle> {\n         match *self {"}, {"sha": "6c862edc2370ace2a74a21780a7e6e61f51e99ec", "filename": "library/std/src/sys/windows/process/tests.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2885c474823637ae69c5967327327a337aebedb2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2885c474823637ae69c5967327327a337aebedb2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess%2Ftests.rs?ref=2885c474823637ae69c5967327327a337aebedb2", "patch": "@@ -128,3 +128,55 @@ fn windows_env_unicode_case() {\n         }\n     }\n }\n+\n+// UWP applications run in a restricted environment which means this test may not work.\n+#[cfg(not(target_vendor = \"uwp\"))]\n+#[test]\n+fn windows_exe_resolver() {\n+    use super::resolve_exe;\n+    use crate::io;\n+\n+    // Test a full path, with and without the `exe` extension.\n+    let mut current_exe = env::current_exe().unwrap();\n+    assert!(resolve_exe(current_exe.as_ref(), None).is_ok());\n+    current_exe.set_extension(\"\");\n+    assert!(resolve_exe(current_exe.as_ref(), None).is_ok());\n+\n+    // Test lone file names.\n+    assert!(resolve_exe(OsStr::new(\"cmd\"), None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"cmd.EXE\"), None).is_ok());\n+    assert!(resolve_exe(OsStr::new(\"fc\"), None).is_ok());\n+\n+    // Invalid file names should return InvalidInput.\n+    assert_eq!(resolve_exe(OsStr::new(\"\"), None).unwrap_err().kind(), io::ErrorKind::InvalidInput);\n+    assert_eq!(\n+        resolve_exe(OsStr::new(\"\\0\"), None).unwrap_err().kind(),\n+        io::ErrorKind::InvalidInput\n+    );\n+    // Trailing slash, therefore there's no file name component.\n+    assert_eq!(\n+        resolve_exe(OsStr::new(r\"C:\\Path\\to\\\"), None).unwrap_err().kind(),\n+        io::ErrorKind::InvalidInput\n+    );\n+\n+    /*\n+    Some of the following tests may need to be changed if you are deliberately\n+    changing the behaviour of `resolve_exe`.\n+    */\n+\n+    let paths = env::var_os(\"PATH\").unwrap();\n+    env::set_var(\"PATH\", \"\");\n+\n+    assert_eq!(resolve_exe(OsStr::new(\"rustc\"), None).unwrap_err().kind(), io::ErrorKind::NotFound);\n+\n+    let child_paths = Some(paths.as_os_str());\n+    assert!(resolve_exe(OsStr::new(\"rustc\"), child_paths).is_ok());\n+\n+    // The resolver looks in system directories even when `PATH` is empty.\n+    assert!(resolve_exe(OsStr::new(\"cmd.exe\"), None).is_ok());\n+\n+    // The application's directory is also searched.\n+    let current_exe = env::current_exe().unwrap();\n+    assert!(resolve_exe(current_exe.file_name().unwrap().as_ref(), None).is_ok());\n+}"}]}