{"sha": "b275e609051f217f330509da26cf74bf941cf972", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNzVlNjA5MDUxZjIxN2YzMzA1MDlkYTI2Y2Y3NGJmOTQxY2Y5NzI=", "commit": {"author": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2021-03-06T22:29:45Z"}, "committer": {"name": "Josh Mcguigan", "email": "joshmcg88@gmail.com", "date": "2021-03-08T22:38:36Z"}, "message": "generate_function assist don't render snippet if ret type inferred", "tree": {"sha": "6b090d36cb2c45ef84c984450335ca4a771008a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b090d36cb2c45ef84c984450335ca4a771008a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b275e609051f217f330509da26cf74bf941cf972", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b275e609051f217f330509da26cf74bf941cf972", "html_url": "https://github.com/rust-lang/rust/commit/b275e609051f217f330509da26cf74bf941cf972", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b275e609051f217f330509da26cf74bf941cf972/comments", "author": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JoshMcguigan", "id": 22216761, "node_id": "MDQ6VXNlcjIyMjE2NzYx", "avatar_url": "https://avatars.githubusercontent.com/u/22216761?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JoshMcguigan", "html_url": "https://github.com/JoshMcguigan", "followers_url": "https://api.github.com/users/JoshMcguigan/followers", "following_url": "https://api.github.com/users/JoshMcguigan/following{/other_user}", "gists_url": "https://api.github.com/users/JoshMcguigan/gists{/gist_id}", "starred_url": "https://api.github.com/users/JoshMcguigan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JoshMcguigan/subscriptions", "organizations_url": "https://api.github.com/users/JoshMcguigan/orgs", "repos_url": "https://api.github.com/users/JoshMcguigan/repos", "events_url": "https://api.github.com/users/JoshMcguigan/events{/privacy}", "received_events_url": "https://api.github.com/users/JoshMcguigan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d645b81b289cf5667c717371364925f582af8ab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d645b81b289cf5667c717371364925f582af8ab4", "html_url": "https://github.com/rust-lang/rust/commit/d645b81b289cf5667c717371364925f582af8ab4"}], "stats": {"total": 73, "additions": 47, "deletions": 26}, "files": [{"sha": "6f95b1a07398d016e82a8a92915e9dc035fd2f95", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 47, "deletions": 26, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b275e609051f217f330509da26cf74bf941cf972/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b275e609051f217f330509da26cf74bf941cf972/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=b275e609051f217f330509da26cf74bf941cf972", "patch": "@@ -83,17 +83,18 @@ struct FunctionTemplate {\n     leading_ws: String,\n     fn_def: ast::Fn,\n     ret_type: ast::RetType,\n+    should_render_snippet: bool,\n     trailing_ws: String,\n     file: FileId,\n }\n \n impl FunctionTemplate {\n     fn to_string(&self, cap: Option<SnippetCap>) -> String {\n-        let f = match cap {\n-            Some(cap) => {\n+        let f = match (cap, self.should_render_snippet) {\n+            (Some(cap), true) => {\n                 render_snippet(cap, self.fn_def.syntax(), Cursor::Replace(self.ret_type.syntax()))\n             }\n-            None => self.fn_def.to_string(),\n+            _ => self.fn_def.to_string(),\n         };\n         format!(\"{}{}{}\", self.leading_ws, f, self.trailing_ws)\n     }\n@@ -104,7 +105,8 @@ struct FunctionBuilder {\n     fn_name: ast::Name,\n     type_params: Option<ast::GenericParamList>,\n     params: ast::ParamList,\n-    ret_type: Option<ast::RetType>,\n+    ret_type: ast::RetType,\n+    should_render_snippet: bool,\n     file: FileId,\n     needs_pub: bool,\n }\n@@ -132,9 +134,44 @@ impl FunctionBuilder {\n         let target_module = target_module.or_else(|| ctx.sema.scope(target.syntax()).module())?;\n         let fn_name = fn_name(&path)?;\n         let (type_params, params) = fn_args(ctx, target_module, &call)?;\n-        let ret_type = fn_ret_type(ctx, target_module, &call);\n \n-        Some(Self { target, fn_name, type_params, params, ret_type, file, needs_pub })\n+        // should_render_snippet intends to express a rough level of confidence about\n+        // the correctness of the return type.\n+        //\n+        // If we are able to infer some return type, and that return type is not unit, we\n+        // don't want to render the snippet. The assumption here is in this situation the\n+        // return type is just as likely to be correct as any other part of the generated\n+        // function.\n+        //\n+        // In the case where the return type is inferred as unit it is likely that the\n+        // user does in fact intend for this generated function to return some non unit\n+        // type, but that the current state of their code doesn't allow that return type\n+        // to be accurately inferred.\n+        let (ret_ty, should_render_snippet) = {\n+            match ctx.sema.type_of_expr(&ast::Expr::CallExpr(call.clone())) {\n+                Some(ty) if ty.is_unknown() || ty.is_unit() => (make::ty_unit(), true),\n+                Some(ty) => {\n+                    let rendered = ty.display_source_code(ctx.db(), target_module.into());\n+                    match rendered {\n+                        Ok(rendered) => (make::ty(&rendered), false),\n+                        Err(_) => (make::ty_unit(), true),\n+                    }\n+                }\n+                None => (make::ty_unit(), true),\n+            }\n+        };\n+        let ret_type = make::ret_type(ret_ty);\n+\n+        Some(Self {\n+            target,\n+            fn_name,\n+            type_params,\n+            params,\n+            ret_type,\n+            should_render_snippet,\n+            file,\n+            needs_pub,\n+        })\n     }\n \n     fn render(self) -> FunctionTemplate {\n@@ -147,7 +184,7 @@ impl FunctionBuilder {\n             self.type_params,\n             self.params,\n             fn_body,\n-            Some(self.ret_type.unwrap_or_else(|| make::ret_type(make::ty_unit()))),\n+            Some(self.ret_type),\n         );\n         let leading_ws;\n         let trailing_ws;\n@@ -173,6 +210,7 @@ impl FunctionBuilder {\n             insert_offset,\n             leading_ws,\n             ret_type: fn_def.ret_type().unwrap(),\n+            should_render_snippet: self.should_render_snippet,\n             fn_def,\n             trailing_ws,\n             file: self.file,\n@@ -225,23 +263,6 @@ fn fn_args(\n     Some((None, make::param_list(None, params)))\n }\n \n-fn fn_ret_type(\n-    ctx: &AssistContext,\n-    target_module: hir::Module,\n-    call: &ast::CallExpr,\n-) -> Option<ast::RetType> {\n-    let ty = ctx.sema.type_of_expr(&ast::Expr::CallExpr(call.clone()))?;\n-    if ty.is_unknown() {\n-        return None;\n-    }\n-\n-    if let Ok(rendered) = ty.display_source_code(ctx.db(), target_module.into()) {\n-        Some(make::ret_type(make::ty(&rendered)))\n-    } else {\n-        None\n-    }\n-}\n-\n /// Makes duplicate argument names unique by appending incrementing numbers.\n ///\n /// ```\n@@ -565,7 +586,7 @@ impl Baz {\n     }\n }\n \n-fn bar(baz: Baz) ${0:-> Baz} {\n+fn bar(baz: Baz) -> Baz {\n     todo!()\n }\n \",\n@@ -1092,7 +1113,7 @@ fn main() {\n     let x: u32 = foo();\n }\n \n-fn foo() ${0:-> u32} {\n+fn foo() -> u32 {\n     todo!()\n }\n \","}]}