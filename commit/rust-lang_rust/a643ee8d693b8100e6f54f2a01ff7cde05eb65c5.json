{"sha": "a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NDNlZThkNjkzYjgxMDBlNmY1NGYyYTAxZmY3Y2RlMDVlYjY1YzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-16T22:24:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-16T22:24:54Z"}, "message": "Auto merge of #67953 - cjgillot:split_infer, r=Zoxc\n\nSplit librustc::{traits,infer} to a separate crate rustc_infer\n\nThis is still very much work in progress.\nThree functions are between dimensions (at the end of `rustc::traits`), waiting for some dependency breaking scheme.\nPlease tell me if the approach seems sound, and how you would like to split this PR up.\n\nThe formatting is deliberately off, to ease rebasing.\n\ncc #65031", "tree": {"sha": "7559e86bc309ebcd88293a4d9832b0eecd566bf6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7559e86bc309ebcd88293a4d9832b0eecd566bf6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "html_url": "https://github.com/rust-lang/rust/commit/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e7af4669f80e5f682141f050193ab679afdb4b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7af4669f80e5f682141f050193ab679afdb4b1", "html_url": "https://github.com/rust-lang/rust/commit/5e7af4669f80e5f682141f050193ab679afdb4b1"}, {"sha": "e88500b5e18bbbad2323944d3c23f8a4465eb147", "url": "https://api.github.com/repos/rust-lang/rust/commits/e88500b5e18bbbad2323944d3c23f8a4465eb147", "html_url": "https://github.com/rust-lang/rust/commit/e88500b5e18bbbad2323944d3c23f8a4465eb147"}], "stats": {"total": 16885, "additions": 8532, "deletions": 8353}, "files": [{"sha": "f13a581bc7909bd9e2a181157df4440de24d6aba", "filename": "Cargo.lock", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -3111,8 +3111,6 @@ dependencies = [\n  \"bitflags\",\n  \"byteorder\",\n  \"chalk-engine\",\n- \"fmt_macros\",\n- \"graphviz\",\n  \"jobserver\",\n  \"log\",\n  \"measureme\",\n@@ -3776,6 +3774,28 @@ dependencies = [\n  \"smallvec 1.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_infer\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"fmt_macros\",\n+ \"graphviz\",\n+ \"log\",\n+ \"rustc\",\n+ \"rustc_attr\",\n+ \"rustc_data_structures\",\n+ \"rustc_error_codes\",\n+ \"rustc_errors\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"smallvec 1.0.0\",\n+ \"syntax\",\n+]\n+\n [[package]]\n name = \"rustc_interface\"\n version = \"0.0.0\"\n@@ -3796,6 +3816,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_hir\",\n  \"rustc_incremental\",\n+ \"rustc_infer\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n  \"rustc_mir\",\n@@ -3838,6 +3859,7 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_infer\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -3907,6 +3929,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_infer\",\n  \"rustc_lexer\",\n  \"rustc_macros\",\n  \"rustc_span\",\n@@ -3929,6 +3952,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_infer\",\n  \"rustc_macros\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -3969,6 +3993,7 @@ dependencies = [\n  \"rustc_feature\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_infer\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4019,6 +4044,7 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n+ \"rustc_infer\",\n  \"rustc_metadata\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4108,6 +4134,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n+ \"rustc_infer\",\n  \"rustc_macros\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4123,6 +4150,7 @@ dependencies = [\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n+ \"rustc_infer\",\n  \"rustc_span\",\n  \"rustc_target\",\n ]\n@@ -4139,6 +4167,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n+ \"rustc_infer\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.0.0\","}, {"sha": "af2be30cc0a8611712ca9b5858ede0b704ccb0c4", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -12,8 +12,6 @@ doctest = false\n [dependencies]\n arena = { path = \"../libarena\" }\n bitflags = \"1.2.1\"\n-fmt_macros = { path = \"../libfmt_macros\" }\n-graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }"}, {"sha": "f5c83fed1fc154a6f713fbfc5eea4c4635dd0c07", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -51,19 +51,19 @@ macro_rules! arena_types {\n             [] dropck_outlives:\n                 rustc::infer::canonical::Canonical<'tcx,\n                     rustc::infer::canonical::QueryResponse<'tcx,\n-                        rustc::traits::query::dropck_outlives::DropckOutlivesResult<'tcx>\n+                        rustc::traits::query::DropckOutlivesResult<'tcx>\n                     >\n                 >,\n             [] normalize_projection_ty:\n                 rustc::infer::canonical::Canonical<'tcx,\n                     rustc::infer::canonical::QueryResponse<'tcx,\n-                        rustc::traits::query::normalize::NormalizationResult<'tcx>\n+                        rustc::traits::query::NormalizationResult<'tcx>\n                     >\n                 >,\n             [] implied_outlives_bounds:\n                 rustc::infer::canonical::Canonical<'tcx,\n                     rustc::infer::canonical::QueryResponse<'tcx,\n-                        Vec<rustc::traits::query::outlives_bounds::OutlivesBound<'tcx>>\n+                        Vec<rustc::traits::query::OutlivesBound<'tcx>>\n                     >\n                 >,\n             [] type_op_subtype:"}, {"sha": "76d0d57e233a34a1a0c22720aa4426b1efd53be0", "filename": "src/librustc/infer/canonical.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -21,7 +21,7 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use crate::infer::region_constraints::MemberConstraint;\n+use crate::infer::MemberConstraint;\n use crate::ty::subst::GenericArg;\n use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n use rustc_index::vec::IndexVec;", "previous_filename": "src/librustc/infer/types/canonical.rs"}, {"sha": "497d3811f281b0af514163f092e46969f40dabc6", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 21, "deletions": 1774, "changes": 1795, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,1785 +1,32 @@\n-//! See the Book for more information.\n-\n-pub use self::freshen::TypeFreshener;\n-pub use self::LateBoundRegionConversionTime::*;\n-pub use self::RegionVariableOrigin::*;\n-pub use self::SubregionOrigin::*;\n-pub use self::ValuePairs::*;\n-pub use crate::ty::IntVarValue;\n-\n-use crate::infer::canonical::{Canonical, CanonicalVarValues};\n-use crate::infer::unify_key::{ConstVarValue, ConstVariableValue};\n-use crate::middle::free_region::RegionRelations;\n-use crate::middle::lang_items;\n-use crate::middle::region;\n-use crate::session::config::BorrowckMode;\n-use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n-use crate::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::relate::RelateResult;\n-use crate::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n-use crate::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n-use crate::ty::{ConstVid, FloatVid, IntVid, TyVid};\n+pub mod canonical;\n+pub mod unify_key;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use crate::ty::Region;\n+use crate::ty::Ty;\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::unify as ut;\n-use rustc_errors::DiagnosticBuilder;\n-use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n-use std::cell::{Cell, Ref, RefCell};\n-use std::collections::BTreeMap;\n-use std::fmt;\n-use syntax::ast;\n-\n-use self::combine::CombineFields;\n-use self::lexical_region_resolve::LexicalRegionResolutions;\n-use self::outlives::env::OutlivesEnvironment;\n-use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n-use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n-use self::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use self::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n-\n-pub mod at;\n-pub mod canonical;\n-mod combine;\n-mod equate;\n-pub mod error_reporting;\n-mod freshen;\n-mod fudge;\n-mod glb;\n-mod higher_ranked;\n-pub mod lattice;\n-mod lexical_region_resolve;\n-mod lub;\n-pub mod nll_relate;\n-pub mod opaque_types;\n-pub mod outlives;\n-pub mod region_constraints;\n-pub mod resolve;\n-mod sub;\n-pub mod type_variable;\n-mod types;\n-pub mod unify_key;\n-\n-#[must_use]\n-#[derive(Debug)]\n-pub struct InferOk<'tcx, T> {\n-    pub value: T,\n-    pub obligations: PredicateObligations<'tcx>,\n-}\n-pub type InferResult<'tcx, T> = Result<InferOk<'tcx, T>, TypeError<'tcx>>;\n-\n-pub type Bound<T> = Option<T>;\n-pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n-pub type FixupResult<'tcx, T> = Result<T, FixupError<'tcx>>; // \"fixup result\"\n-\n-/// A flag that is used to suppress region errors. This is normally\n-/// false, but sometimes -- when we are doing region checks that the\n-/// NLL borrow checker will also do -- it might be set to true.\n-#[derive(Copy, Clone, Default, Debug)]\n-pub struct SuppressRegionErrors {\n-    suppressed: bool,\n-}\n-\n-impl SuppressRegionErrors {\n-    pub fn suppressed(self) -> bool {\n-        self.suppressed\n-    }\n-\n-    /// Indicates that the MIR borrowck will repeat these region\n-    /// checks, so we should ignore errors if NLL is (unconditionally)\n-    /// enabled.\n-    pub fn when_nll_is_enabled(tcx: TyCtxt<'_>) -> Self {\n-        // FIXME(Centril): Once we actually remove `::Migrate` also make\n-        // this always `true` and then proceed to eliminate the dead code.\n-        match tcx.borrowck_mode() {\n-            // If we're on Migrate mode, report AST region errors\n-            BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n-\n-            // If we're on MIR, don't report AST region errors as they should be reported by NLL\n-            BorrowckMode::Mir => SuppressRegionErrors { suppressed: true },\n-        }\n-    }\n-}\n-\n-/// This type contains all the things within `InferCtxt` that sit within a\n-/// `RefCell` and are involved with taking/rolling back snapshots. Snapshot\n-/// operations are hot enough that we want only one call to `borrow_mut` per\n-/// call to `start_snapshot` and `rollback_to`.\n-pub struct InferCtxtInner<'tcx> {\n-    /// Cache for projections. This cache is snapshotted along with the infcx.\n-    ///\n-    /// Public so that `traits::project` can use it.\n-    pub projection_cache: traits::ProjectionCache<'tcx>,\n-\n-    /// We instantiate `UnificationTable` with `bounds<Ty>` because the types\n-    /// that might instantiate a general type variable have an order,\n-    /// represented by its upper and lower bounds.\n-    type_variables: type_variable::TypeVariableTable<'tcx>,\n-\n-    /// Map from const parameter variable to the kind of const it represents.\n-    const_unification_table: ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>,\n-\n-    /// Map from integral variable to the kind of integer it represents.\n-    int_unification_table: ut::UnificationTable<ut::InPlace<ty::IntVid>>,\n-\n-    /// Map from floating variable to the kind of float it represents.\n-    float_unification_table: ut::UnificationTable<ut::InPlace<ty::FloatVid>>,\n-\n-    /// Tracks the set of region variables and the constraints between them.\n-    /// This is initially `Some(_)` but when\n-    /// `resolve_regions_and_report_errors` is invoked, this gets set to `None`\n-    /// -- further attempts to perform unification, etc., may fail if new\n-    /// region constraints would've been added.\n-    region_constraints: Option<RegionConstraintCollector<'tcx>>,\n-\n-    /// A set of constraints that regionck must validate. Each\n-    /// constraint has the form `T:'a`, meaning \"some type `T` must\n-    /// outlive the lifetime 'a\". These constraints derive from\n-    /// instantiated type parameters. So if you had a struct defined\n-    /// like\n-    ///\n-    ///     struct Foo<T:'static> { ... }\n-    ///\n-    /// then in some expression `let x = Foo { ... }` it will\n-    /// instantiate the type parameter `T` with a fresh type `$0`. At\n-    /// the same time, it will record a region obligation of\n-    /// `$0:'static`. This will get checked later by regionck. (We\n-    /// can't generally check these things right away because we have\n-    /// to wait until types are resolved.)\n-    ///\n-    /// These are stored in a map keyed to the id of the innermost\n-    /// enclosing fn body / static initializer expression. This is\n-    /// because the location where the obligation was incurred can be\n-    /// relevant with respect to which sublifetime assumptions are in\n-    /// place. The reason that we store under the fn-id, and not\n-    /// something more fine-grained, is so that it is easier for\n-    /// regionck to be sure that it has found *all* the region\n-    /// obligations (otherwise, it's easy to fail to walk to a\n-    /// particular node-id).\n-    ///\n-    /// Before running `resolve_regions_and_report_errors`, the creator\n-    /// of the inference context is expected to invoke\n-    /// `process_region_obligations` (defined in `self::region_obligations`)\n-    /// for each body-id in this map, which will process the\n-    /// obligations within. This is expected to be done 'late enough'\n-    /// that all type inference variables have been bound and so forth.\n-    pub region_obligations: Vec<(hir::HirId, RegionObligation<'tcx>)>,\n-}\n-\n-impl<'tcx> InferCtxtInner<'tcx> {\n-    fn new() -> InferCtxtInner<'tcx> {\n-        InferCtxtInner {\n-            projection_cache: Default::default(),\n-            type_variables: type_variable::TypeVariableTable::new(),\n-            const_unification_table: ut::UnificationTable::new(),\n-            int_unification_table: ut::UnificationTable::new(),\n-            float_unification_table: ut::UnificationTable::new(),\n-            region_constraints: Some(RegionConstraintCollector::new()),\n-            region_obligations: vec![],\n-        }\n-    }\n-\n-    pub fn unwrap_region_constraints(&mut self) -> &mut RegionConstraintCollector<'tcx> {\n-        self.region_constraints.as_mut().expect(\"region constraints already solved\")\n-    }\n-}\n-\n-pub struct InferCtxt<'a, 'tcx> {\n-    pub tcx: TyCtxt<'tcx>,\n-\n-    /// During type-checking/inference of a body, `in_progress_tables`\n-    /// contains a reference to the tables being built up, which are\n-    /// used for reading closure kinds/signatures as they are inferred,\n-    /// and for error reporting logic to read arbitrary node types.\n-    pub in_progress_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n-\n-    pub inner: RefCell<InferCtxtInner<'tcx>>,\n-\n-    /// If set, this flag causes us to skip the 'leak check' during\n-    /// higher-ranked subtyping operations. This flag is a temporary one used\n-    /// to manage the removal of the leak-check: for the time being, we still run the\n-    /// leak-check, but we issue warnings. This flag can only be set to true\n-    /// when entering a snapshot.\n-    skip_leak_check: Cell<bool>,\n-\n-    /// Once region inference is done, the values for each variable.\n-    lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n-\n-    /// Caches the results of trait selection. This cache is used\n-    /// for things that have to do with the parameters in scope.\n-    pub selection_cache: traits::SelectionCache<'tcx>,\n-\n-    /// Caches the results of trait evaluation.\n-    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n-\n-    /// the set of predicates on which errors have been reported, to\n-    /// avoid reporting the same error twice.\n-    pub reported_trait_errors: RefCell<FxHashMap<Span, Vec<ty::Predicate<'tcx>>>>,\n-\n-    pub reported_closure_mismatch: RefCell<FxHashSet<(Span, Option<Span>)>>,\n-\n-    /// When an error occurs, we want to avoid reporting \"derived\"\n-    /// errors that are due to this original failure. Normally, we\n-    /// handle this with the `err_count_on_creation` count, which\n-    /// basically just tracks how many errors were reported when we\n-    /// started type-checking a fn and checks to see if any new errors\n-    /// have been reported since then. Not great, but it works.\n-    ///\n-    /// However, when errors originated in other passes -- notably\n-    /// resolve -- this heuristic breaks down. Therefore, we have this\n-    /// auxiliary flag that one can set whenever one creates a\n-    /// type-error that is due to an error in a prior pass.\n-    ///\n-    /// Don't read this flag directly, call `is_tainted_by_errors()`\n-    /// and `set_tainted_by_errors()`.\n-    tainted_by_errors_flag: Cell<bool>,\n-\n-    /// Track how many errors were reported when this infcx is created.\n-    /// If the number of errors increases, that's also a sign (line\n-    /// `tained_by_errors`) to avoid reporting certain kinds of errors.\n-    // FIXME(matthewjasper) Merge into `tainted_by_errors_flag`\n-    err_count_on_creation: usize,\n-\n-    /// This flag is true while there is an active snapshot.\n-    in_snapshot: Cell<bool>,\n-\n-    /// What is the innermost universe we have created? Starts out as\n-    /// `UniverseIndex::root()` but grows from there as we enter\n-    /// universal quantifiers.\n-    ///\n-    /// N.B., at present, we exclude the universal quantifiers on the\n-    /// item we are type-checking, and just consider those names as\n-    /// part of the root universe. So this would only get incremented\n-    /// when we enter into a higher-ranked (`for<..>`) type or trait\n-    /// bound.\n-    universe: Cell<ty::UniverseIndex>,\n-}\n-\n-/// A map returned by `replace_bound_vars_with_placeholders()`\n-/// indicating the placeholder region that each late-bound region was\n-/// replaced with.\n-pub type PlaceholderMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n-\n-/// See the `error_reporting` module for more details.\n-#[derive(Clone, Debug, PartialEq, Eq, TypeFoldable)]\n-pub enum ValuePairs<'tcx> {\n-    Types(ExpectedFound<Ty<'tcx>>),\n-    Regions(ExpectedFound<ty::Region<'tcx>>),\n-    Consts(ExpectedFound<&'tcx ty::Const<'tcx>>),\n-    TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n-    PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n-}\n-\n-/// The trace designates the path through inference that we took to\n-/// encounter an error or subtyping constraint.\n-///\n-/// See the `error_reporting` module for more details.\n-#[derive(Clone, Debug)]\n-pub struct TypeTrace<'tcx> {\n-    cause: ObligationCause<'tcx>,\n-    values: ValuePairs<'tcx>,\n-}\n-\n-/// The origin of a `r1 <= r2` constraint.\n-///\n-/// See `error_reporting` module for more details\n-#[derive(Clone, Debug)]\n-pub enum SubregionOrigin<'tcx> {\n-    /// Arose from a subtyping relation\n-    Subtype(Box<TypeTrace<'tcx>>),\n-\n-    /// Stack-allocated closures cannot outlive innermost loop\n-    /// or function so as to ensure we only require finite stack\n-    InfStackClosure(Span),\n-\n-    /// Invocation of closure must be within its lifetime\n-    InvokeClosure(Span),\n-\n-    /// Dereference of reference must be within its lifetime\n-    DerefPointer(Span),\n-\n-    /// Closure bound must not outlive captured variables\n-    ClosureCapture(Span, hir::HirId),\n-\n-    /// Index into slice must be within its lifetime\n-    IndexSlice(Span),\n-\n-    /// When casting `&'a T` to an `&'b Trait` object,\n-    /// relating `'a` to `'b`\n-    RelateObjectBound(Span),\n-\n-    /// Some type parameter was instantiated with the given type,\n-    /// and that type must outlive some region.\n-    RelateParamBound(Span, Ty<'tcx>),\n-\n-    /// The given region parameter was instantiated with a region\n-    /// that must outlive some other region.\n-    RelateRegionParamBound(Span),\n-\n-    /// A bound placed on type parameters that states that must outlive\n-    /// the moment of their instantiation.\n-    RelateDefaultParamBound(Span, Ty<'tcx>),\n-\n-    /// Creating a pointer `b` to contents of another reference\n-    Reborrow(Span),\n-\n-    /// Creating a pointer `b` to contents of an upvar\n-    ReborrowUpvar(Span, ty::UpvarId),\n \n-    /// Data with type `Ty<'tcx>` was borrowed\n-    DataBorrowed(Ty<'tcx>, Span),\n-\n-    /// (&'a &'b T) where a >= b\n-    ReferenceOutlivesReferent(Ty<'tcx>, Span),\n-\n-    /// Type or region parameters must be in scope.\n-    ParameterInScope(ParameterOrigin, Span),\n-\n-    /// The type T of an expression E must outlive the lifetime for E.\n-    ExprTypeIsNotInScope(Ty<'tcx>, Span),\n-\n-    /// A `ref b` whose region does not enclose the decl site\n-    BindingTypeIsNotValidAtDecl(Span),\n-\n-    /// Regions appearing in a method receiver must outlive method call\n-    CallRcvr(Span),\n-\n-    /// Regions appearing in a function argument must outlive func call\n-    CallArg(Span),\n-\n-    /// Region in return type of invoked fn must enclose call\n-    CallReturn(Span),\n-\n-    /// Operands must be in scope\n-    Operand(Span),\n-\n-    /// Region resulting from a `&` expr must enclose the `&` expr\n-    AddrOf(Span),\n-\n-    /// An auto-borrow that does not enclose the expr where it occurs\n-    AutoBorrow(Span),\n-\n-    /// Region constraint arriving from destructor safety\n-    SafeDestructor(Span),\n-\n-    /// Comparing the signature and requirements of an impl method against\n-    /// the containing trait.\n-    CompareImplMethodObligation {\n-        span: Span,\n-        item_name: ast::Name,\n-        impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-    },\n-}\n-\n-// `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(SubregionOrigin<'_>, 32);\n-\n-/// Places that type/region parameters can appear.\n-#[derive(Clone, Copy, Debug)]\n-pub enum ParameterOrigin {\n-    Path,               // foo::bar\n-    MethodCall,         // foo.bar() <-- parameters on impl providing bar()\n-    OverloadedOperator, // a + b when overloaded\n-    OverloadedDeref,    // *a when overloaded\n-}\n-\n-/// Times when we replace late-bound regions with variables:\n-#[derive(Clone, Copy, Debug)]\n-pub enum LateBoundRegionConversionTime {\n-    /// when a fn is called\n-    FnCall,\n-\n-    /// when two higher-ranked types are compared\n-    HigherRankedType,\n-\n-    /// when projecting an associated type\n-    AssocTypeProjection(DefId),\n-}\n-\n-/// Reasons to create a region inference variable\n+/// Requires that `region` must be equal to one of the regions in `choice_regions`.\n+/// We often denote this using the syntax:\n ///\n-/// See `error_reporting` module for more details\n-#[derive(Copy, Clone, Debug)]\n-pub enum RegionVariableOrigin {\n-    /// Region variables created for ill-categorized reasons,\n-    /// mostly indicates places in need of refactoring\n-    MiscVariable(Span),\n-\n-    /// Regions created by a `&P` or `[...]` pattern\n-    PatternRegion(Span),\n-\n-    /// Regions created by `&` operator\n-    AddrOfRegion(Span),\n-\n-    /// Regions created as part of an autoref of a method receiver\n-    Autoref(Span),\n-\n-    /// Regions created as part of an automatic coercion\n-    Coercion(Span),\n-\n-    /// Region variables created as the values for early-bound regions\n-    EarlyBoundRegion(Span, Symbol),\n-\n-    /// Region variables created for bound regions\n-    /// in a function or method that is called\n-    LateBoundRegion(Span, ty::BoundRegion, LateBoundRegionConversionTime),\n-\n-    UpvarRegion(ty::UpvarId, Span),\n-\n-    BoundRegionInCoherence(ast::Name),\n-\n-    /// This origin is used for the inference variables that we create\n-    /// during NLL region processing.\n-    NLL(NLLRegionVariableOrigin),\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum NLLRegionVariableOrigin {\n-    /// During NLL region processing, we create variables for free\n-    /// regions that we encounter in the function signature and\n-    /// elsewhere. This origin indices we've got one of those.\n-    FreeRegion,\n-\n-    /// \"Universal\" instantiation of a higher-ranked region (e.g.,\n-    /// from a `for<'a> T` binder). Meant to represent \"any region\".\n-    Placeholder(ty::PlaceholderRegion),\n-\n-    Existential {\n-        /// If this is true, then this variable was created to represent a lifetime\n-        /// bound in a `for` binder. For example, it might have been created to\n-        /// represent the lifetime `'a` in a type like `for<'a> fn(&'a u32)`.\n-        /// Such variables are created when we are trying to figure out if there\n-        /// is any valid instantiation of `'a` that could fit into some scenario.\n-        ///\n-        /// This is used to inform error reporting: in the case that we are trying to\n-        /// determine whether there is any valid instantiation of a `'a` variable that meets\n-        /// some constraint C, we want to blame the \"source\" of that `for` type,\n-        /// rather than blaming the source of the constraint C.\n-        from_forall: bool,\n-    },\n-}\n-\n-impl NLLRegionVariableOrigin {\n-    pub fn is_universal(self) -> bool {\n-        match self {\n-            NLLRegionVariableOrigin::FreeRegion => true,\n-            NLLRegionVariableOrigin::Placeholder(..) => true,\n-            NLLRegionVariableOrigin::Existential { .. } => false,\n-        }\n-    }\n-\n-    pub fn is_existential(self) -> bool {\n-        !self.is_universal()\n-    }\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum FixupError<'tcx> {\n-    UnresolvedIntTy(IntVid),\n-    UnresolvedFloatTy(FloatVid),\n-    UnresolvedTy(TyVid),\n-    UnresolvedConst(ConstVid<'tcx>),\n-}\n-\n-/// See the `region_obligations` field for more information.\n-#[derive(Clone)]\n-pub struct RegionObligation<'tcx> {\n-    pub sub_region: ty::Region<'tcx>,\n-    pub sup_type: Ty<'tcx>,\n-    pub origin: SubregionOrigin<'tcx>,\n-}\n-\n-impl<'tcx> fmt::Display for FixupError<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use self::FixupError::*;\n-\n-        match *self {\n-            UnresolvedIntTy(_) => write!(\n-                f,\n-                \"cannot determine the type of this integer; \\\n-                 add a suffix to specify the type explicitly\"\n-            ),\n-            UnresolvedFloatTy(_) => write!(\n-                f,\n-                \"cannot determine the type of this number; \\\n-                 add a suffix to specify the type explicitly\"\n-            ),\n-            UnresolvedTy(_) => write!(f, \"unconstrained type\"),\n-            UnresolvedConst(_) => write!(f, \"unconstrained const value\"),\n-        }\n-    }\n-}\n-\n-/// Helper type of a temporary returned by `tcx.infer_ctxt()`.\n-/// Necessary because we can't write the following bound:\n-/// `F: for<'b, 'tcx> where 'tcx FnOnce(InferCtxt<'b, 'tcx>)`.\n-pub struct InferCtxtBuilder<'tcx> {\n-    global_tcx: TyCtxt<'tcx>,\n-    fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n-}\n-\n-impl TyCtxt<'tcx> {\n-    pub fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder { global_tcx: self, fresh_tables: None }\n-    }\n-}\n-\n-impl<'tcx> InferCtxtBuilder<'tcx> {\n-    /// Used only by `rustc_typeck` during body type-checking/inference,\n-    /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n-    pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n-        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty(Some(table_owner))));\n-        self\n-    }\n-\n-    /// Given a canonical value `C` as a starting point, create an\n-    /// inference context that contains each of the bound values\n-    /// within instantiated as a fresh variable. The `f` closure is\n-    /// invoked with the new infcx, along with the instantiated value\n-    /// `V` and a substitution `S`. This substitution `S` maps from\n-    /// the bound values in `C` to their instantiated values in `V`\n-    /// (in other words, `S(C) = V`).\n-    pub fn enter_with_canonical<T, R>(\n-        &mut self,\n-        span: Span,\n-        canonical: &Canonical<'tcx, T>,\n-        f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n-    ) -> R\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        self.enter(|infcx| {\n-            let (value, subst) =\n-                infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n-            f(infcx, value, subst)\n-        })\n-    }\n-\n-    pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n-        let InferCtxtBuilder { global_tcx, ref fresh_tables } = *self;\n-        let in_progress_tables = fresh_tables.as_ref();\n-        global_tcx.enter_local(|tcx| {\n-            f(InferCtxt {\n-                tcx,\n-                in_progress_tables,\n-                inner: RefCell::new(InferCtxtInner::new()),\n-                lexical_region_resolutions: RefCell::new(None),\n-                selection_cache: Default::default(),\n-                evaluation_cache: Default::default(),\n-                reported_trait_errors: Default::default(),\n-                reported_closure_mismatch: Default::default(),\n-                tainted_by_errors_flag: Cell::new(false),\n-                err_count_on_creation: tcx.sess.err_count(),\n-                in_snapshot: Cell::new(false),\n-                skip_leak_check: Cell::new(false),\n-                universe: Cell::new(ty::UniverseIndex::ROOT),\n-            })\n-        })\n-    }\n-}\n-\n-impl<'tcx, T> InferOk<'tcx, T> {\n-    pub fn unit(self) -> InferOk<'tcx, ()> {\n-        InferOk { value: (), obligations: self.obligations }\n-    }\n-\n-    /// Extracts `value`, registering any obligations into `fulfill_cx`.\n-    pub fn into_value_registering_obligations(\n-        self,\n-        infcx: &InferCtxt<'_, 'tcx>,\n-        fulfill_cx: &mut dyn TraitEngine<'tcx>,\n-    ) -> T {\n-        let InferOk { value, obligations } = self;\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(infcx, obligation);\n-        }\n-        value\n-    }\n-}\n-\n-impl<'tcx> InferOk<'tcx, ()> {\n-    pub fn into_obligations(self) -> PredicateObligations<'tcx> {\n-        self.obligations\n-    }\n-}\n-\n-#[must_use = \"once you start a snapshot, you should always consume it\"]\n-pub struct CombinedSnapshot<'a, 'tcx> {\n-    projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n-    type_snapshot: type_variable::Snapshot<'tcx>,\n-    const_snapshot: ut::Snapshot<ut::InPlace<ty::ConstVid<'tcx>>>,\n-    int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n-    float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n-    region_constraints_snapshot: RegionSnapshot,\n-    region_obligations_snapshot: usize,\n-    universe: ty::UniverseIndex,\n-    was_in_snapshot: bool,\n-    was_skip_leak_check: bool,\n-    _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n-}\n-\n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn is_in_snapshot(&self) -> bool {\n-        self.in_snapshot.get()\n-    }\n+/// ```\n+/// R0 member of [O1..On]\n+/// ```\n+#[derive(Debug, Clone, HashStable, TypeFoldable, Lift)]\n+pub struct MemberConstraint<'tcx> {\n+    /// The `DefId` of the opaque type causing this constraint: used for error reporting.\n+    pub opaque_type_def_id: DefId,\n \n-    pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n-        t.fold_with(&mut self.freshener())\n-    }\n+    /// The span where the hidden type was instantiated.\n+    pub definition_span: Span,\n \n-    pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n-        match ty.kind {\n-            ty::Infer(ty::TyVar(vid)) => self.inner.borrow().type_variables.var_diverges(vid),\n-            _ => false,\n-        }\n-    }\n+    /// The hidden type in which `member_region` appears: used for error reporting.\n+    pub hidden_ty: Ty<'tcx>,\n \n-    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n-        freshen::TypeFreshener::new(self)\n-    }\n-\n-    pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {\n-        use crate::ty::error::UnconstrainedNumeric::Neither;\n-        use crate::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n-        match ty.kind {\n-            ty::Infer(ty::IntVar(vid)) => {\n-                if self.inner.borrow_mut().int_unification_table.probe_value(vid).is_some() {\n-                    Neither\n-                } else {\n-                    UnconstrainedInt\n-                }\n-            }\n-            ty::Infer(ty::FloatVar(vid)) => {\n-                if self.inner.borrow_mut().float_unification_table.probe_value(vid).is_some() {\n-                    Neither\n-                } else {\n-                    UnconstrainedFloat\n-                }\n-            }\n-            _ => Neither,\n-        }\n-    }\n-\n-    pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n-        let mut inner = self.inner.borrow_mut();\n-        // FIXME(const_generics): should there be an equivalent function for const variables?\n-\n-        let mut vars: Vec<Ty<'_>> = inner\n-            .type_variables\n-            .unsolved_variables()\n-            .into_iter()\n-            .map(|t| self.tcx.mk_ty_var(t))\n-            .collect();\n-        vars.extend(\n-            (0..inner.int_unification_table.len())\n-                .map(|i| ty::IntVid { index: i as u32 })\n-                .filter(|&vid| inner.int_unification_table.probe_value(vid).is_none())\n-                .map(|v| self.tcx.mk_int_var(v)),\n-        );\n-        vars.extend(\n-            (0..inner.float_unification_table.len())\n-                .map(|i| ty::FloatVid { index: i as u32 })\n-                .filter(|&vid| inner.float_unification_table.probe_value(vid).is_none())\n-                .map(|v| self.tcx.mk_float_var(v)),\n-        );\n-        vars\n-    }\n-\n-    fn combine_fields(\n-        &'a self,\n-        trace: TypeTrace<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> CombineFields<'a, 'tcx> {\n-        CombineFields {\n-            infcx: self,\n-            trace,\n-            cause: None,\n-            param_env,\n-            obligations: PredicateObligations::new(),\n-        }\n-    }\n-\n-    /// Clear the \"currently in a snapshot\" flag, invoke the closure,\n-    /// then restore the flag to its original value. This flag is a\n-    /// debugging measure designed to detect cases where we start a\n-    /// snapshot, create type variables, and register obligations\n-    /// which may involve those type variables in the fulfillment cx,\n-    /// potentially leaving \"dangling type variables\" behind.\n-    /// In such cases, an assertion will fail when attempting to\n-    /// register obligations, within a snapshot. Very useful, much\n-    /// better than grovelling through megabytes of `RUSTC_LOG` output.\n-    ///\n-    /// HOWEVER, in some cases the flag is unhelpful. In particular, we\n-    /// sometimes create a \"mini-fulfilment-cx\" in which we enroll\n-    /// obligations. As long as this fulfillment cx is fully drained\n-    /// before we return, this is not a problem, as there won't be any\n-    /// escaping obligations in the main cx. In those cases, you can\n-    /// use this function.\n-    pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n-    where\n-        F: FnOnce(&Self) -> R,\n-    {\n-        let flag = self.in_snapshot.get();\n-        self.in_snapshot.set(false);\n-        let result = func(self);\n-        self.in_snapshot.set(flag);\n-        result\n-    }\n-\n-    fn start_snapshot(&self) -> CombinedSnapshot<'a, 'tcx> {\n-        debug!(\"start_snapshot()\");\n-\n-        let in_snapshot = self.in_snapshot.get();\n-        self.in_snapshot.set(true);\n-\n-        let mut inner = self.inner.borrow_mut();\n-        CombinedSnapshot {\n-            projection_cache_snapshot: inner.projection_cache.snapshot(),\n-            type_snapshot: inner.type_variables.snapshot(),\n-            const_snapshot: inner.const_unification_table.snapshot(),\n-            int_snapshot: inner.int_unification_table.snapshot(),\n-            float_snapshot: inner.float_unification_table.snapshot(),\n-            region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n-            region_obligations_snapshot: inner.region_obligations.len(),\n-            universe: self.universe(),\n-            was_in_snapshot: in_snapshot,\n-            was_skip_leak_check: self.skip_leak_check.get(),\n-            // Borrow tables \"in progress\" (i.e., during typeck)\n-            // to ban writes from within a snapshot to them.\n-            _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n-        }\n-    }\n-\n-    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n-        debug!(\"rollback_to(cause={})\", cause);\n-        let CombinedSnapshot {\n-            projection_cache_snapshot,\n-            type_snapshot,\n-            const_snapshot,\n-            int_snapshot,\n-            float_snapshot,\n-            region_constraints_snapshot,\n-            region_obligations_snapshot,\n-            universe,\n-            was_in_snapshot,\n-            was_skip_leak_check,\n-            _in_progress_tables,\n-        } = snapshot;\n-\n-        self.in_snapshot.set(was_in_snapshot);\n-        self.universe.set(universe);\n-        self.skip_leak_check.set(was_skip_leak_check);\n-\n-        let mut inner = self.inner.borrow_mut();\n-        inner.projection_cache.rollback_to(projection_cache_snapshot);\n-        inner.type_variables.rollback_to(type_snapshot);\n-        inner.const_unification_table.rollback_to(const_snapshot);\n-        inner.int_unification_table.rollback_to(int_snapshot);\n-        inner.float_unification_table.rollback_to(float_snapshot);\n-        inner.unwrap_region_constraints().rollback_to(region_constraints_snapshot);\n-        inner.region_obligations.truncate(region_obligations_snapshot);\n-    }\n-\n-    fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n-        debug!(\"commit_from()\");\n-        let CombinedSnapshot {\n-            projection_cache_snapshot,\n-            type_snapshot,\n-            const_snapshot,\n-            int_snapshot,\n-            float_snapshot,\n-            region_constraints_snapshot,\n-            region_obligations_snapshot: _,\n-            universe: _,\n-            was_in_snapshot,\n-            was_skip_leak_check,\n-            _in_progress_tables,\n-        } = snapshot;\n-\n-        self.in_snapshot.set(was_in_snapshot);\n-        self.skip_leak_check.set(was_skip_leak_check);\n-\n-        let mut inner = self.inner.borrow_mut();\n-        inner.projection_cache.commit(projection_cache_snapshot);\n-        inner.type_variables.commit(type_snapshot);\n-        inner.const_unification_table.commit(const_snapshot);\n-        inner.int_unification_table.commit(int_snapshot);\n-        inner.float_unification_table.commit(float_snapshot);\n-        inner.unwrap_region_constraints().commit(region_constraints_snapshot);\n-    }\n-\n-    /// Executes `f` and commit the bindings.\n-    pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n-    {\n-        debug!(\"commit_unconditionally()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        self.commit_from(snapshot);\n-        r\n-    }\n-\n-    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`.\n-    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n-    {\n-        debug!(\"commit_if_ok()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n-        match r {\n-            Ok(_) => {\n-                self.commit_from(snapshot);\n-            }\n-            Err(_) => {\n-                self.rollback_to(\"commit_if_ok -- error\", snapshot);\n-            }\n-        }\n-        r\n-    }\n-\n-    /// Execute `f` then unroll any bindings it creates.\n-    pub fn probe<R, F>(&self, f: F) -> R\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n-    {\n-        debug!(\"probe()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        self.rollback_to(\"probe\", snapshot);\n-        r\n-    }\n-\n-    /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.\n-    pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n-    where\n-        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n-    {\n-        debug!(\"probe()\");\n-        let snapshot = self.start_snapshot();\n-        let skip_leak_check = should_skip || self.skip_leak_check.get();\n-        self.skip_leak_check.set(skip_leak_check);\n-        let r = f(&snapshot);\n-        self.rollback_to(\"probe\", snapshot);\n-        r\n-    }\n-\n-    /// Scan the constraints produced since `snapshot` began and returns:\n-    ///\n-    /// - `None` -- if none of them involve \"region outlives\" constraints\n-    /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder\n-    /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders\n-    pub fn region_constraints_added_in_snapshot(\n-        &self,\n-        snapshot: &CombinedSnapshot<'a, 'tcx>,\n-    ) -> Option<bool> {\n-        self.inner\n-            .borrow_mut()\n-            .unwrap_region_constraints()\n-            .region_constraints_added_in_snapshot(&snapshot.region_constraints_snapshot)\n-    }\n-\n-    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n-        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n-    }\n-\n-    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n-    where\n-        T: at::ToTrace<'tcx>,\n-    {\n-        let origin = &ObligationCause::dummy();\n-        self.probe(|_| {\n-            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n-        })\n-    }\n-\n-    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n-    where\n-        T: at::ToTrace<'tcx>,\n-    {\n-        let origin = &ObligationCause::dummy();\n-        self.probe(|_| {\n-            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n-                // Ignore obligations, since we are unrolling\n-                // everything anyway.\n-            })\n-        })\n-    }\n-\n-    pub fn sub_regions(\n-        &self,\n-        origin: SubregionOrigin<'tcx>,\n-        a: ty::Region<'tcx>,\n-        b: ty::Region<'tcx>,\n-    ) {\n-        debug!(\"sub_regions({:?} <: {:?})\", a, b);\n-        self.inner.borrow_mut().unwrap_region_constraints().make_subregion(origin, a, b);\n-    }\n-\n-    /// Require that the region `r` be equal to one of the regions in\n-    /// the set `regions`.\n-    pub fn member_constraint(\n-        &self,\n-        opaque_type_def_id: DefId,\n-        definition_span: Span,\n-        hidden_ty: Ty<'tcx>,\n-        region: ty::Region<'tcx>,\n-        in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n-    ) {\n-        debug!(\"member_constraint({:?} <: {:?})\", region, in_regions);\n-        self.inner.borrow_mut().unwrap_region_constraints().member_constraint(\n-            opaque_type_def_id,\n-            definition_span,\n-            hidden_ty,\n-            region,\n-            in_regions,\n-        );\n-    }\n-\n-    pub fn subtype_predicate(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: &ty::PolySubtypePredicate<'tcx>,\n-    ) -> Option<InferResult<'tcx, ()>> {\n-        // Subtle: it's ok to skip the binder here and resolve because\n-        // `shallow_resolve` just ignores anything that is not a type\n-        // variable, and because type variable's can't (at present, at\n-        // least) capture any of the things bound by this binder.\n-        //\n-        // NOTE(nmatsakis): really, there is no *particular* reason to do this\n-        // `shallow_resolve` here except as a micro-optimization.\n-        // Naturally I could not resist.\n-        let two_unbound_type_vars = {\n-            let a = self.shallow_resolve(predicate.skip_binder().a);\n-            let b = self.shallow_resolve(predicate.skip_binder().b);\n-            a.is_ty_var() && b.is_ty_var()\n-        };\n-\n-        if two_unbound_type_vars {\n-            // Two unbound type variables? Can't make progress.\n-            return None;\n-        }\n-\n-        Some(self.commit_if_ok(|snapshot| {\n-            let (ty::SubtypePredicate { a_is_expected, a, b }, placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n-\n-            let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n-\n-            self.leak_check(false, &placeholder_map, snapshot)?;\n-\n-            Ok(ok.unit())\n-        }))\n-    }\n-\n-    pub fn region_outlives_predicate(\n-        &self,\n-        cause: &traits::ObligationCause<'tcx>,\n-        predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n-    ) -> UnitResult<'tcx> {\n-        self.commit_if_ok(|snapshot| {\n-            let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n-                self.replace_bound_vars_with_placeholders(predicate);\n-            let origin = SubregionOrigin::from_obligation_cause(cause, || {\n-                RelateRegionParamBound(cause.span)\n-            });\n-            self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, &placeholder_map, snapshot)?;\n-            Ok(())\n-        })\n-    }\n-\n-    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n-        self.inner.borrow_mut().type_variables.new_var(self.universe(), diverging, origin)\n-    }\n-\n-    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(false, origin))\n-    }\n-\n-    pub fn next_ty_var_in_universe(\n-        &self,\n-        origin: TypeVariableOrigin,\n-        universe: ty::UniverseIndex,\n-    ) -> Ty<'tcx> {\n-        let vid = self.inner.borrow_mut().type_variables.new_var(universe, false, origin);\n-        self.tcx.mk_ty_var(vid)\n-    }\n-\n-    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_ty_var(self.next_ty_var_id(true, origin))\n-    }\n-\n-    pub fn next_const_var(\n-        &self,\n-        ty: Ty<'tcx>,\n-        origin: ConstVariableOrigin,\n-    ) -> &'tcx ty::Const<'tcx> {\n-        self.tcx.mk_const_var(self.next_const_var_id(origin), ty)\n-    }\n-\n-    pub fn next_const_var_in_universe(\n-        &self,\n-        ty: Ty<'tcx>,\n-        origin: ConstVariableOrigin,\n-        universe: ty::UniverseIndex,\n-    ) -> &'tcx ty::Const<'tcx> {\n-        let vid = self\n-            .inner\n-            .borrow_mut()\n-            .const_unification_table\n-            .new_key(ConstVarValue { origin, val: ConstVariableValue::Unknown { universe } });\n-        self.tcx.mk_const_var(vid, ty)\n-    }\n-\n-    pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n-        self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n-            origin,\n-            val: ConstVariableValue::Unknown { universe: self.universe() },\n-        })\n-    }\n-\n-    fn next_int_var_id(&self) -> IntVid {\n-        self.inner.borrow_mut().int_unification_table.new_key(None)\n-    }\n-\n-    pub fn next_int_var(&self) -> Ty<'tcx> {\n-        self.tcx.mk_int_var(self.next_int_var_id())\n-    }\n-\n-    fn next_float_var_id(&self) -> FloatVid {\n-        self.inner.borrow_mut().float_unification_table.new_key(None)\n-    }\n-\n-    pub fn next_float_var(&self) -> Ty<'tcx> {\n-        self.tcx.mk_float_var(self.next_float_var_id())\n-    }\n-\n-    /// Creates a fresh region variable with the next available index.\n-    /// The variable will be created in the maximum universe created\n-    /// thus far, allowing it to name any region created thus far.\n-    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {\n-        self.next_region_var_in_universe(origin, self.universe())\n-    }\n-\n-    /// Creates a fresh region variable with the next available index\n-    /// in the given universe; typically, you can use\n-    /// `next_region_var` and just use the maximal universe.\n-    pub fn next_region_var_in_universe(\n-        &self,\n-        origin: RegionVariableOrigin,\n-        universe: ty::UniverseIndex,\n-    ) -> ty::Region<'tcx> {\n-        let region_var =\n-            self.inner.borrow_mut().unwrap_region_constraints().new_region_var(universe, origin);\n-        self.tcx.mk_region(ty::ReVar(region_var))\n-    }\n-\n-    /// Return the universe that the region `r` was created in.  For\n-    /// most regions (e.g., `'static`, named regions from the user,\n-    /// etc) this is the root universe U0. For inference variables or\n-    /// placeholders, however, it will return the universe which which\n-    /// they are associated.\n-    fn universe_of_region(&self, r: ty::Region<'tcx>) -> ty::UniverseIndex {\n-        self.inner.borrow_mut().unwrap_region_constraints().universe(r)\n-    }\n-\n-    /// Number of region variables created so far.\n-    pub fn num_region_vars(&self) -> usize {\n-        self.inner.borrow_mut().unwrap_region_constraints().num_region_vars()\n-    }\n-\n-    /// Just a convenient wrapper of `next_region_var` for using during NLL.\n-    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin) -> ty::Region<'tcx> {\n-        self.next_region_var(RegionVariableOrigin::NLL(origin))\n-    }\n-\n-    /// Just a convenient wrapper of `next_region_var` for using during NLL.\n-    pub fn next_nll_region_var_in_universe(\n-        &self,\n-        origin: NLLRegionVariableOrigin,\n-        universe: ty::UniverseIndex,\n-    ) -> ty::Region<'tcx> {\n-        self.next_region_var_in_universe(RegionVariableOrigin::NLL(origin), universe)\n-    }\n-\n-    pub fn var_for_def(&self, span: Span, param: &ty::GenericParamDef) -> GenericArg<'tcx> {\n-        match param.kind {\n-            GenericParamDefKind::Lifetime => {\n-                // Create a region inference variable for the given\n-                // region parameter definition.\n-                self.next_region_var(EarlyBoundRegion(span, param.name)).into()\n-            }\n-            GenericParamDefKind::Type { .. } => {\n-                // Create a type inference variable for the given\n-                // type parameter definition. The substitutions are\n-                // for actual parameters that may be referred to by\n-                // the default of this type parameter, if it exists.\n-                // e.g., `struct Foo<A, B, C = (A, B)>(...);` when\n-                // used in a path such as `Foo::<T, U>::new()` will\n-                // use an inference variable for `C` with `[T, U]`\n-                // as the substitutions for the default, `(T, U)`.\n-                let ty_var_id = self.inner.borrow_mut().type_variables.new_var(\n-                    self.universe(),\n-                    false,\n-                    TypeVariableOrigin {\n-                        kind: TypeVariableOriginKind::TypeParameterDefinition(\n-                            param.name,\n-                            Some(param.def_id),\n-                        ),\n-                        span,\n-                    },\n-                );\n-\n-                self.tcx.mk_ty_var(ty_var_id).into()\n-            }\n-            GenericParamDefKind::Const { .. } => {\n-                let origin = ConstVariableOrigin {\n-                    kind: ConstVariableOriginKind::ConstParameterDefinition(param.name),\n-                    span,\n-                };\n-                let const_var_id =\n-                    self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n-                        origin,\n-                        val: ConstVariableValue::Unknown { universe: self.universe() },\n-                    });\n-                self.tcx.mk_const_var(const_var_id, self.tcx.type_of(param.def_id)).into()\n-            }\n-        }\n-    }\n-\n-    /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n-    /// type/region parameter to a fresh inference variable.\n-    pub fn fresh_substs_for_item(&self, span: Span, def_id: DefId) -> SubstsRef<'tcx> {\n-        InternalSubsts::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n-    }\n-\n-    /// Returns `true` if errors have been reported since this infcx was\n-    /// created. This is sometimes used as a heuristic to skip\n-    /// reporting errors that often occur as a result of earlier\n-    /// errors, but where it's hard to be 100% sure (e.g., unresolved\n-    /// inference variables, regionck errors).\n-    pub fn is_tainted_by_errors(&self) -> bool {\n-        debug!(\n-            \"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n-             tainted_by_errors_flag={})\",\n-            self.tcx.sess.err_count(),\n-            self.err_count_on_creation,\n-            self.tainted_by_errors_flag.get()\n-        );\n-\n-        if self.tcx.sess.err_count() > self.err_count_on_creation {\n-            return true; // errors reported since this infcx was made\n-        }\n-        self.tainted_by_errors_flag.get()\n-    }\n-\n-    /// Set the \"tainted by errors\" flag to true. We call this when we\n-    /// observe an error from a prior pass.\n-    pub fn set_tainted_by_errors(&self) {\n-        debug!(\"set_tainted_by_errors()\");\n-        self.tainted_by_errors_flag.set(true)\n-    }\n-\n-    /// Process the region constraints and report any errors that\n-    /// result. After this, no more unification operations should be\n-    /// done -- or the compiler will panic -- but it is legal to use\n-    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n-    pub fn resolve_regions_and_report_errors(\n-        &self,\n-        region_context: DefId,\n-        region_map: &region::ScopeTree,\n-        outlives_env: &OutlivesEnvironment<'tcx>,\n-        suppress: SuppressRegionErrors,\n-    ) {\n-        assert!(\n-            self.is_tainted_by_errors() || self.inner.borrow().region_obligations.is_empty(),\n-            \"region_obligations not empty: {:#?}\",\n-            self.inner.borrow().region_obligations\n-        );\n-\n-        let region_rels = &RegionRelations::new(\n-            self.tcx,\n-            region_context,\n-            region_map,\n-            outlives_env.free_region_map(),\n-        );\n-        let (var_infos, data) = self\n-            .inner\n-            .borrow_mut()\n-            .region_constraints\n-            .take()\n-            .expect(\"regions already resolved\")\n-            .into_infos_and_data();\n-        let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(region_rels, var_infos, data);\n-\n-        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n-        assert!(old_value.is_none());\n-\n-        if !self.is_tainted_by_errors() {\n-            // As a heuristic, just skip reporting region errors\n-            // altogether if other errors have been reported while\n-            // this infcx was in use.  This is totally hokey but\n-            // otherwise we have a hard time separating legit region\n-            // errors from silly ones.\n-            self.report_region_errors(region_map, &errors, suppress);\n-        }\n-    }\n-\n-    /// Obtains (and clears) the current set of region\n-    /// constraints. The inference context is still usable: further\n-    /// unifications will simply add new constraints.\n-    ///\n-    /// This method is not meant to be used with normal lexical region\n-    /// resolution. Rather, it is used in the NLL mode as a kind of\n-    /// interim hack: basically we run normal type-check and generate\n-    /// region constraints as normal, but then we take them and\n-    /// translate them into the form that the NLL solver\n-    /// understands. See the NLL module for mode details.\n-    pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n-        assert!(\n-            self.inner.borrow().region_obligations.is_empty(),\n-            \"region_obligations not empty: {:#?}\",\n-            self.inner.borrow().region_obligations\n-        );\n-\n-        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n-    }\n-\n-    /// Gives temporary access to the region constraint data.\n-    #[allow(non_camel_case_types)] // bug with impl trait\n-    pub fn with_region_constraints<R>(\n-        &self,\n-        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n-    ) -> R {\n-        let mut inner = self.inner.borrow_mut();\n-        op(inner.unwrap_region_constraints().data())\n-    }\n-\n-    /// Takes ownership of the list of variable regions. This implies\n-    /// that all the region constraints have already been taken, and\n-    /// hence that `resolve_regions_and_report_errors` can never be\n-    /// called. This is used only during NLL processing to \"hand off\" ownership\n-    /// of the set of region variables into the NLL region context.\n-    pub fn take_region_var_origins(&self) -> VarInfos {\n-        let (var_infos, data) = self\n-            .inner\n-            .borrow_mut()\n-            .region_constraints\n-            .take()\n-            .expect(\"regions already resolved\")\n-            .into_infos_and_data();\n-        assert!(data.is_empty());\n-        var_infos\n-    }\n-\n-    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n-        self.resolve_vars_if_possible(&t).to_string()\n-    }\n-\n-    pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n-        let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n-        format!(\"({})\", tstrs.join(\", \"))\n-    }\n-\n-    pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n-        self.resolve_vars_if_possible(t).print_only_trait_path().to_string()\n-    }\n-\n-    /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n-    /// universe index of `TyVar(vid)`.\n-    pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n-        use self::type_variable::TypeVariableValue;\n-\n-        match self.inner.borrow_mut().type_variables.probe(vid) {\n-            TypeVariableValue::Known { value } => Ok(value),\n-            TypeVariableValue::Unknown { universe } => Err(universe),\n-        }\n-    }\n-\n-    /// Resolve any type variables found in `value` -- but only one\n-    /// level.  So, if the variable `?X` is bound to some type\n-    /// `Foo<?Y>`, then this would return `Foo<?Y>` (but `?Y` may\n-    /// itself be bound to a type).\n-    ///\n-    /// Useful when you only need to inspect the outermost level of\n-    /// the type and don't care about nested types (or perhaps you\n-    /// will be resolving them as well, e.g. in a loop).\n-    pub fn shallow_resolve<T>(&self, value: T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut r = ShallowResolver::new(self);\n-        value.fold_with(&mut r)\n-    }\n-\n-    pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n-        self.inner.borrow_mut().type_variables.root_var(var)\n-    }\n-\n-    /// Where possible, replaces type/const variables in\n-    /// `value` with their final value. Note that region variables\n-    /// are unaffected. If a type/const variable has not been unified, it\n-    /// is left as is. This is an idempotent operation that does\n-    /// not affect inference state in any way and so you can do it\n-    /// at will.\n-    pub fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        if !value.needs_infer() {\n-            return value.clone(); // Avoid duplicated subst-folding.\n-        }\n-        let mut r = resolve::OpportunisticVarResolver::new(self);\n-        value.fold_with(&mut r)\n-    }\n-\n-    /// Returns the first unresolved variable contained in `T`. In the\n-    /// process of visiting `T`, this will resolve (where possible)\n-    /// type variables in `T`, but it never constructs the final,\n-    /// resolved type, so it's more efficient than\n-    /// `resolve_vars_if_possible()`.\n-    pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let mut r = resolve::UnresolvedTypeFinder::new(self);\n-        value.visit_with(&mut r);\n-        r.first_unresolved\n-    }\n-\n-    pub fn probe_const_var(\n-        &self,\n-        vid: ty::ConstVid<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n-        match self.inner.borrow_mut().const_unification_table.probe_value(vid).val {\n-            ConstVariableValue::Known { value } => Ok(value),\n-            ConstVariableValue::Unknown { universe } => Err(universe),\n-        }\n-    }\n-\n-    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<'tcx, T> {\n-        /*!\n-         * Attempts to resolve all type/region/const variables in\n-         * `value`. Region inference must have been run already (e.g.,\n-         * by calling `resolve_regions_and_report_errors`). If some\n-         * variable was never unified, an `Err` results.\n-         *\n-         * This method is idempotent, but it not typically not invoked\n-         * except during the writeback phase.\n-         */\n-\n-        resolve::fully_resolve(self, value)\n-    }\n-\n-    // [Note-Type-error-reporting]\n-    // An invariant is that anytime the expected or actual type is Error (the special\n-    // error type, meaning that an error occurred when typechecking this expression),\n-    // this is a derived error. The error cascaded from another error (that was already\n-    // reported), so it's not useful to display it to the user.\n-    // The following methods implement this logic.\n-    // They check if either the actual or expected type is Error, and don't print the error\n-    // in this case. The typechecker should only ever report type errors involving mismatched\n-    // types using one of these methods, and should not call span_err directly for such\n-    // errors.\n-\n-    pub fn type_error_struct_with_diag<M>(\n-        &self,\n-        sp: Span,\n-        mk_diag: M,\n-        actual_ty: Ty<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx>\n-    where\n-        M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n-    {\n-        let actual_ty = self.resolve_vars_if_possible(&actual_ty);\n-        debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n-\n-        // Don't report an error if actual type is `Error`.\n-        if actual_ty.references_error() {\n-            return self.tcx.sess.diagnostic().struct_dummy();\n-        }\n-\n-        mk_diag(self.ty_to_string(actual_ty))\n-    }\n-\n-    pub fn report_mismatched_types(\n-        &self,\n-        cause: &ObligationCause<'tcx>,\n-        expected: Ty<'tcx>,\n-        actual: Ty<'tcx>,\n-        err: TypeError<'tcx>,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let trace = TypeTrace::types(cause, true, expected, actual);\n-        self.report_and_explain_type_error(trace, &err)\n-    }\n-\n-    pub fn replace_bound_vars_with_fresh_vars<T>(\n-        &self,\n-        span: Span,\n-        lbrct: LateBoundRegionConversionTime,\n-        value: &ty::Binder<T>,\n-    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        let fld_r = |br| self.next_region_var(LateBoundRegion(span, br, lbrct));\n-        let fld_t = |_| {\n-            self.next_ty_var(TypeVariableOrigin {\n-                kind: TypeVariableOriginKind::MiscVariable,\n-                span,\n-            })\n-        };\n-        let fld_c = |_, ty| {\n-            self.next_const_var(\n-                ty,\n-                ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span },\n-            )\n-        };\n-        self.tcx.replace_bound_vars(value, fld_r, fld_t, fld_c)\n-    }\n-\n-    /// See the [`region_constraints::verify_generic_bound`] method.\n-    pub fn verify_generic_bound(\n-        &self,\n-        origin: SubregionOrigin<'tcx>,\n-        kind: GenericKind<'tcx>,\n-        a: ty::Region<'tcx>,\n-        bound: VerifyBound<'tcx>,\n-    ) {\n-        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\", kind, a, bound);\n-\n-        self.inner\n-            .borrow_mut()\n-            .unwrap_region_constraints()\n-            .verify_generic_bound(origin, kind, a, bound);\n-    }\n-\n-    pub fn type_is_copy_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool {\n-        let ty = self.resolve_vars_if_possible(&ty);\n-\n-        // Even if the type may have no inference variables, during\n-        // type-checking closure types are in local tables only.\n-        if !self.in_progress_tables.is_some() || !ty.has_closure_types() {\n-            if !(param_env, ty).has_local_value() {\n-                return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n-            }\n-        }\n-\n-        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n-\n-        // This can get called from typeck (by euv), and `moves_by_default`\n-        // rightly refuses to work with inference variables, but\n-        // moves_by_default has a cache, which we want to use in other\n-        // cases.\n-        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n-    }\n-\n-    /// Obtains the latest type of the given closure; this may be a\n-    /// closure in the current function, in which case its\n-    /// `ClosureKind` may not yet be known.\n-    pub fn closure_kind(\n-        &self,\n-        closure_def_id: DefId,\n-        closure_substs: SubstsRef<'tcx>,\n-    ) -> Option<ty::ClosureKind> {\n-        let closure_kind_ty = closure_substs.as_closure().kind_ty(closure_def_id, self.tcx);\n-        let closure_kind_ty = self.shallow_resolve(closure_kind_ty);\n-        closure_kind_ty.to_opt_closure_kind()\n-    }\n-\n-    /// Obtains the signature of a closure. For closures, unlike\n-    /// `tcx.fn_sig(def_id)`, this method will work during the\n-    /// type-checking of the enclosing function and return the closure\n-    /// signature in its partially inferred state.\n-    pub fn closure_sig(&self, def_id: DefId, substs: SubstsRef<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let closure_sig_ty = substs.as_closure().sig_ty(def_id, self.tcx);\n-        let closure_sig_ty = self.shallow_resolve(closure_sig_ty);\n-        closure_sig_ty.fn_sig(self.tcx)\n-    }\n-\n-    /// Normalizes associated types in `value`, potentially returning\n-    /// new obligations that must further be processed.\n-    pub fn partially_normalize_associated_types_in<T>(\n-        &self,\n-        span: Span,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n-    ) -> InferOk<'tcx, T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let cause = ObligationCause::misc(span, body_id);\n-        let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, value);\n-        debug!(\n-            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n-            value, obligations\n-        );\n-        InferOk { value, obligations }\n-    }\n-\n-    /// Clears the selection, evaluation, and projection caches. This is useful when\n-    /// repeatedly attempting to select an `Obligation` while changing only\n-    /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing.\n-    pub fn clear_caches(&self) {\n-        self.selection_cache.clear();\n-        self.evaluation_cache.clear();\n-        self.inner.borrow_mut().projection_cache.clear();\n-    }\n-\n-    fn universe(&self) -> ty::UniverseIndex {\n-        self.universe.get()\n-    }\n-\n-    /// Creates and return a fresh universe that extends all previous\n-    /// universes. Updates `self.universe` to that new universe.\n-    pub fn create_next_universe(&self) -> ty::UniverseIndex {\n-        let u = self.universe.get().next_universe();\n-        self.universe.set(u);\n-        u\n-    }\n-}\n-\n-pub struct ShallowResolver<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-}\n-\n-impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n-    #[inline(always)]\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n-        ShallowResolver { infcx }\n-    }\n-\n-    /// If `typ` is a type variable of some kind, resolve it one level\n-    /// (but do not resolve types found in the result). If `typ` is\n-    /// not a type variable, just return it unmodified.\n-    pub fn shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match typ.kind {\n-            ty::Infer(ty::TyVar(v)) => {\n-                // Not entirely obvious: if `typ` is a type variable,\n-                // it can be resolved to an int/float variable, which\n-                // can then be recursively resolved, hence the\n-                // recursion. Note though that we prevent type\n-                // variables from unifying to other type variables\n-                // directly (though they may be embedded\n-                // structurally), and we prevent cycles in any case,\n-                // so this recursion should always be of very limited\n-                // depth.\n-                //\n-                // Note: if these two lines are combined into one we get\n-                // dynamic borrow errors on `self.infcx.inner`.\n-                let known = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n-                known.map(|t| self.fold_ty(t)).unwrap_or(typ)\n-            }\n-\n-            ty::Infer(ty::IntVar(v)) => self\n-                .infcx\n-                .inner\n-                .borrow_mut()\n-                .int_unification_table\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.infcx.tcx))\n-                .unwrap_or(typ),\n-\n-            ty::Infer(ty::FloatVar(v)) => self\n-                .infcx\n-                .inner\n-                .borrow_mut()\n-                .float_unification_table\n-                .probe_value(v)\n-                .map(|v| v.to_type(self.infcx.tcx))\n-                .unwrap_or(typ),\n-\n-            _ => typ,\n-        }\n-    }\n-\n-    // `resolver.shallow_resolve_changed(ty)` is equivalent to\n-    // `resolver.shallow_resolve(ty) != ty`, but more efficient. It's always\n-    // inlined, despite being large, because it has only two call sites that\n-    // are extremely hot.\n-    #[inline(always)]\n-    pub fn shallow_resolve_changed(&self, infer: ty::InferTy) -> bool {\n-        match infer {\n-            ty::TyVar(v) => {\n-                use self::type_variable::TypeVariableValue;\n-\n-                // If `inlined_probe` returns a `Known` value its `kind` never\n-                // matches `infer`.\n-                match self.infcx.inner.borrow_mut().type_variables.inlined_probe(v) {\n-                    TypeVariableValue::Unknown { .. } => false,\n-                    TypeVariableValue::Known { .. } => true,\n-                }\n-            }\n-\n-            ty::IntVar(v) => {\n-                // If inlined_probe_value returns a value it's always a\n-                // `ty::Int(_)` or `ty::UInt(_)`, which nevers matches a\n-                // `ty::Infer(_)`.\n-                self.infcx.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n-            }\n-\n-            ty::FloatVar(v) => {\n-                // If inlined_probe_value returns a value it's always a\n-                // `ty::Float(_)`, which nevers matches a `ty::Infer(_)`.\n-                //\n-                // Not `inlined_probe_value(v)` because this call site is colder.\n-                self.infcx.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n-            }\n-\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.shallow_resolve(ty)\n-    }\n-\n-    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n-            self.infcx\n-                .inner\n-                .borrow_mut()\n-                .const_unification_table\n-                .probe_value(*vid)\n-                .val\n-                .known()\n-                .unwrap_or(ct)\n-        } else {\n-            ct\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeTrace<'tcx> {\n-    pub fn span(&self) -> Span {\n-        self.cause.span\n-    }\n-\n-    pub fn types(\n-        cause: &ObligationCause<'tcx>,\n-        a_is_expected: bool,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-    ) -> TypeTrace<'tcx> {\n-        TypeTrace { cause: cause.clone(), values: Types(ExpectedFound::new(a_is_expected, a, b)) }\n-    }\n-\n-    pub fn dummy(tcx: TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n-        TypeTrace {\n-            cause: ObligationCause::dummy(),\n-            values: Types(ExpectedFound { expected: tcx.types.err, found: tcx.types.err }),\n-        }\n-    }\n-}\n-\n-impl<'tcx> SubregionOrigin<'tcx> {\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            Subtype(ref a) => a.span(),\n-            InfStackClosure(a) => a,\n-            InvokeClosure(a) => a,\n-            DerefPointer(a) => a,\n-            ClosureCapture(a, _) => a,\n-            IndexSlice(a) => a,\n-            RelateObjectBound(a) => a,\n-            RelateParamBound(a, _) => a,\n-            RelateRegionParamBound(a) => a,\n-            RelateDefaultParamBound(a, _) => a,\n-            Reborrow(a) => a,\n-            ReborrowUpvar(a, _) => a,\n-            DataBorrowed(_, a) => a,\n-            ReferenceOutlivesReferent(_, a) => a,\n-            ParameterInScope(_, a) => a,\n-            ExprTypeIsNotInScope(_, a) => a,\n-            BindingTypeIsNotValidAtDecl(a) => a,\n-            CallRcvr(a) => a,\n-            CallArg(a) => a,\n-            CallReturn(a) => a,\n-            Operand(a) => a,\n-            AddrOf(a) => a,\n-            AutoBorrow(a) => a,\n-            SafeDestructor(a) => a,\n-            CompareImplMethodObligation { span, .. } => span,\n-        }\n-    }\n-\n-    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>, default: F) -> Self\n-    where\n-        F: FnOnce() -> Self,\n-    {\n-        match cause.code {\n-            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) => {\n-                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span)\n-            }\n-\n-            traits::ObligationCauseCode::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } => SubregionOrigin::CompareImplMethodObligation {\n-                span: cause.span,\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            },\n-\n-            _ => default(),\n-        }\n-    }\n-}\n-\n-impl RegionVariableOrigin {\n-    pub fn span(&self) -> Span {\n-        match *self {\n-            MiscVariable(a) => a,\n-            PatternRegion(a) => a,\n-            AddrOfRegion(a) => a,\n-            Autoref(a) => a,\n-            Coercion(a) => a,\n-            EarlyBoundRegion(a, ..) => a,\n-            LateBoundRegion(a, ..) => a,\n-            BoundRegionInCoherence(_) => rustc_span::DUMMY_SP,\n-            UpvarRegion(_, a) => a,\n-            NLL(..) => bug!(\"NLL variable used with `span`\"),\n-        }\n-    }\n-}\n+    /// The region `R0`.\n+    pub member_region: Region<'tcx>,\n \n-impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n-            self.sub_region, self.sup_type\n-        )\n-    }\n+    /// The options `O1..On`.\n+    pub choice_regions: Lrc<Vec<Region<'tcx>>>,\n }"}, {"sha": "534f4cb179c4f78eb7d2e5f183b55343e69fc74e", "filename": "src/librustc/infer/types/mod.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5e7af4669f80e5f682141f050193ab679afdb4b1/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7af4669f80e5f682141f050193ab679afdb4b1/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs?ref=5e7af4669f80e5f682141f050193ab679afdb4b1", "patch": "@@ -1,31 +0,0 @@\n-pub mod canonical;\n-\n-use crate::ty::Region;\n-use crate::ty::Ty;\n-use rustc_data_structures::sync::Lrc;\n-use rustc_hir::def_id::DefId;\n-use rustc_span::Span;\n-\n-/// Requires that `region` must be equal to one of the regions in `choice_regions`.\n-/// We often denote this using the syntax:\n-///\n-/// ```\n-/// R0 member of [O1..On]\n-/// ```\n-#[derive(Debug, Clone, HashStable, TypeFoldable, Lift)]\n-pub struct MemberConstraint<'tcx> {\n-    /// The `DefId` of the opaque type causing this constraint: used for error reporting.\n-    pub opaque_type_def_id: DefId,\n-\n-    /// The span where the hidden type was instantiated.\n-    pub definition_span: Span,\n-\n-    /// The hidden type in which `member_region` appears: used for error reporting.\n-    pub hidden_ty: Ty<'tcx>,\n-\n-    /// The region `R0`.\n-    pub member_region: Region<'tcx>,\n-\n-    /// The options `O1..On`.\n-    pub choice_regions: Lrc<Vec<Region<'tcx>>>,\n-}"}, {"sha": "e1e774b853c20e26a7656899e6e06c9487d4395f", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -13,10 +13,6 @@\n //!   defined in the `ty` module. This includes the **type context**\n //!   (or `tcx`), which is the central context during most of\n //!   compilation, containing the interners and other things.\n-//! - **Traits.** Trait resolution is implemented in the `traits` module.\n-//! - **Type inference.** The type inference code can be found in the `infer` module;\n-//!   this code handles low-level equality and subtyping operations. The\n-//!   type check pass in the compiler is found in the `librustc_typeck` crate.\n //!\n //! For more information about how rustc works, see the [rustc guide].\n //!"}, {"sha": "c000aa7c25e974281826728805ce566ce958ff00", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 693, "deletions": 599, "changes": 1292, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -2,644 +2,738 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n \n-#[allow(dead_code)]\n-pub mod auto_trait;\n-mod chalk_fulfill;\n-pub mod codegen;\n-mod coherence;\n-mod engine;\n-pub mod error_reporting;\n-mod fulfill;\n-pub mod misc;\n-mod object_safety;\n-mod on_unimplemented;\n-mod project;\n pub mod query;\n-mod select;\n-mod specialize;\n+pub mod select;\n+pub mod specialization_graph;\n mod structural_impls;\n-mod structural_match;\n-mod types;\n-mod util;\n-pub mod wf;\n-\n-use crate::infer::outlives::env::OutlivesEnvironment;\n-use crate::infer::{InferCtxt, SuppressRegionErrors};\n-use crate::middle::region;\n-use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::{InternalSubsts, SubstsRef};\n-use crate::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, WithConstness};\n-use crate::util::common::ErrorReported;\n+\n+use crate::infer::canonical::Canonical;\n+use crate::mir::interpret::ErrorHandled;\n+use crate::ty::fold::{TypeFolder, TypeVisitor};\n+use crate::ty::subst::SubstsRef;\n+use crate::ty::{self, AdtKind, List, Ty, TyCtxt};\n+\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::{Span, DUMMY_SP};\n+use syntax::ast;\n \n use std::fmt::Debug;\n+use std::rc::Rc;\n+\n+pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n+\n+pub type ChalkCanonicalGoal<'tcx> = Canonical<'tcx, InEnvironment<'tcx, ty::Predicate<'tcx>>>;\n+\n+pub use self::ObligationCauseCode::*;\n+pub use self::SelectionError::*;\n+pub use self::Vtable::*;\n+\n+/// Depending on the stage of compilation, we want projection to be\n+/// more or less conservative.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n+pub enum Reveal {\n+    /// At type-checking time, we refuse to project any associated\n+    /// type that is marked `default`. Non-`default` (\"final\") types\n+    /// are always projected. This is necessary in general for\n+    /// soundness of specialization. However, we *could* allow\n+    /// projections in fully-monomorphic cases. We choose not to,\n+    /// because we prefer for `default type` to force the type\n+    /// definition to be treated abstractly by any consumers of the\n+    /// impl. Concretely, that means that the following example will\n+    /// fail to compile:\n+    ///\n+    /// ```\n+    /// trait Assoc {\n+    ///     type Output;\n+    /// }\n+    ///\n+    /// impl<T> Assoc for T {\n+    ///     default type Output = bool;\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let <() as Assoc>::Output = true;\n+    /// }\n+    /// ```\n+    UserFacing,\n+\n+    /// At codegen time, all monomorphic projections will succeed.\n+    /// Also, `impl Trait` is normalized to the concrete type,\n+    /// which has to be already collected by type-checking.\n+    ///\n+    /// NOTE: as `impl Trait`'s concrete type should *never*\n+    /// be observable directly by the user, `Reveal::All`\n+    /// should not be used by checks which may expose\n+    /// type equality or type contents to the user.\n+    /// There are some exceptions, e.g., around OIBITS and\n+    /// transmute-checking, which expose some details, but\n+    /// not the whole concrete type of the `impl Trait`.\n+    All,\n+}\n+\n+/// The reason why we incurred this obligation; used for error reporting.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct ObligationCause<'tcx> {\n+    pub span: Span,\n+\n+    /// The ID of the fn body that triggered this obligation. This is\n+    /// used for region obligations to determine the precise\n+    /// environment in which the region obligation should be evaluated\n+    /// (in particular, closures can add new assumptions). See the\n+    /// field `region_obligations` of the `FulfillmentContext` for more\n+    /// information.\n+    pub body_id: hir::HirId,\n+\n+    pub code: ObligationCauseCode<'tcx>,\n+}\n \n-pub use self::FulfillmentErrorCode::*;\n-\n-pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n-pub use self::coherence::{OrphanCheckErr, OverlapResult};\n-pub use self::engine::{TraitEngine, TraitEngineExt};\n-pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n-pub use self::object_safety::astconv_object_safety_violations;\n-pub use self::object_safety::is_vtable_safe_method;\n-pub use self::object_safety::object_safety_violations;\n-pub use self::object_safety::MethodViolationCode;\n-pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n-pub use self::project::MismatchedProjectionTypes;\n-pub use self::project::{\n-    normalize, normalize_projection_type, normalize_to, poly_project_and_unify_type,\n-};\n-pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot};\n-pub use self::select::{IntercrateAmbiguityCause, SelectionContext};\n-pub use self::specialize::find_associated_item;\n-pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n-pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n-pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n-pub use self::structural_match::search_for_structural_match_violation;\n-pub use self::structural_match::type_marked_structural;\n-pub use self::structural_match::NonStructuralMatchTy;\n-pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n-pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n-pub use self::util::{\n-    get_vtable_index_of_object_method, impl_is_default, impl_item_is_final,\n-    predicate_for_trait_def, upcast_choices,\n-};\n-pub use self::util::{\n-    supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n-};\n-\n-pub use self::chalk_fulfill::{\n-    CanonicalGoal as ChalkCanonicalGoal, FulfillmentContext as ChalkFulfillmentContext,\n-};\n-\n-pub use self::types::*;\n-\n-/// Whether to skip the leak check, as part of a future compatibility warning step.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum SkipLeakCheck {\n-    Yes,\n-    No,\n-}\n-\n-impl SkipLeakCheck {\n-    fn is_yes(self) -> bool {\n-        self == SkipLeakCheck::Yes\n+impl<'tcx> ObligationCause<'tcx> {\n+    #[inline]\n+    pub fn new(\n+        span: Span,\n+        body_id: hir::HirId,\n+        code: ObligationCauseCode<'tcx>,\n+    ) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code }\n     }\n+\n+    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code: MiscObligation }\n+    }\n+\n+    pub fn dummy() -> ObligationCause<'tcx> {\n+        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n+    }\n+\n+    pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n+        match self.code {\n+            ObligationCauseCode::CompareImplMethodObligation { .. }\n+            | ObligationCauseCode::MainFunctionType\n+            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                arm_span,\n+                ..\n+            }) => arm_span,\n+            _ => self.span,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ObligationCauseCode<'tcx> {\n+    /// Not well classified or should be obvious from the span.\n+    MiscObligation,\n+\n+    /// A slice or array is WF only if `T: Sized`.\n+    SliceOrArrayElem,\n+\n+    /// A tuple is WF only if its middle elements are `Sized`.\n+    TupleElem,\n+\n+    /// This is the trait reference from the given projection.\n+    ProjectionWf(ty::ProjectionTy<'tcx>),\n+\n+    /// In an impl of trait `X` for type `Y`, type `Y` must\n+    /// also implement all supertraits of `X`.\n+    ItemObligation(DefId),\n+\n+    /// Like `ItemObligation`, but with extra detail on the source of the obligation.\n+    BindingObligation(DefId, Span),\n+\n+    /// A type like `&'a T` is WF only if `T: 'a`.\n+    ReferenceOutlivesReferent(Ty<'tcx>),\n+\n+    /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n+    ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n+\n+    /// Obligation incurred due to an object cast.\n+    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n+\n+    /// Obligation incurred due to a coercion.\n+    Coercion {\n+        source: Ty<'tcx>,\n+        target: Ty<'tcx>,\n+    },\n+\n+    /// Various cases where expressions must be `Sized` / `Copy` / etc.\n+    /// `L = X` implies that `L` is `Sized`.\n+    AssignmentLhsSized,\n+    /// `(x1, .., xn)` must be `Sized`.\n+    TupleInitializerSized,\n+    /// `S { ... }` must be `Sized`.\n+    StructInitializerSized,\n+    /// Type of each variable must be `Sized`.\n+    VariableType(hir::HirId),\n+    /// Argument type must be `Sized`.\n+    SizedArgumentType,\n+    /// Return type must be `Sized`.\n+    SizedReturnType,\n+    /// Yield type must be `Sized`.\n+    SizedYieldType,\n+    /// `[T, ..n]` implies that `T` must be `Copy`.\n+    /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n+    RepeatVec(bool),\n+\n+    /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n+    FieldSized {\n+        adt_kind: AdtKind,\n+        last: bool,\n+    },\n+\n+    /// Constant expressions must be sized.\n+    ConstSized,\n+\n+    /// `static` items must have `Sync` type.\n+    SharedStatic,\n+\n+    BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n+\n+    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n+\n+    /// Error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplMethodObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n+\n+    /// Error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplTypeObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n+\n+    /// Checking that this expression can be assigned where it needs to be\n+    // FIXME(eddyb) #11161 is the original Expr required?\n+    ExprAssignable,\n+\n+    /// Computing common supertype in the arms of a match expression\n+    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n+\n+    /// Type error arising from type checking a pattern against an expected type.\n+    Pattern {\n+        /// The span of the scrutinee or type expression which caused the `root_ty` type.\n+        span: Option<Span>,\n+        /// The root expected type induced by a scrutinee or type expression.\n+        root_ty: Ty<'tcx>,\n+        /// Whether the `Span` came from an expression or a type expression.\n+        origin_expr: bool,\n+    },\n+\n+    /// Constants in patterns must have `Structural` type.\n+    ConstPatternStructural,\n+\n+    /// Computing common supertype in an if expression\n+    IfExpression(Box<IfExpressionCause>),\n+\n+    /// Computing common supertype of an if expression with no else counter-part\n+    IfExpressionWithNoElse,\n+\n+    /// `main` has wrong type\n+    MainFunctionType,\n+\n+    /// `start` has wrong type\n+    StartFunctionType,\n+\n+    /// Intrinsic has wrong type\n+    IntrinsicType,\n+\n+    /// Method receiver\n+    MethodReceiver,\n+\n+    /// `return` with no expression\n+    ReturnNoExpression,\n+\n+    /// `return` with an expression\n+    ReturnValue(hir::HirId),\n+\n+    /// Return type of this function\n+    ReturnType,\n+\n+    /// Block implicit return\n+    BlockTailExpression(hir::HirId),\n+\n+    /// #[feature(trivial_bounds)] is not enabled\n+    TrivialBound,\n+\n+    AssocTypeBound(Box<AssocTypeBoundData>),\n }\n \n-/// The \"default\" for skip-leak-check corresponds to the current\n-/// behavior (do not skip the leak check) -- not the behavior we are\n-/// transitioning into.\n-impl Default for SkipLeakCheck {\n-    fn default() -> Self {\n-        SkipLeakCheck::No\n+impl ObligationCauseCode<'_> {\n+    // Return the base obligation, ignoring derived obligations.\n+    pub fn peel_derives(&self) -> &Self {\n+        let mut base_cause = self;\n+        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n+            base_cause = &cause.parent_code;\n+        }\n+        base_cause\n     }\n }\n \n-/// The mode that trait queries run in.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum TraitQueryMode {\n-    // Standard/un-canonicalized queries get accurate\n-    // spans etc. passed in and hence can do reasonable\n-    // error reporting on their own.\n-    Standard,\n-    // Canonicalized queries get dummy spans and hence\n-    // must generally propagate errors to\n-    // pre-canonicalization callsites.\n-    Canonical,\n-}\n-\n-/// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n-/// which the vtable must be found. The process of finding a vtable is\n-/// called \"resolving\" the `Obligation`. This process consists of\n-/// either identifying an `impl` (e.g., `impl Eq for int`) that\n-/// provides the required vtable, or else finding a bound that is in\n-/// scope. The eventual result is usually a `Selection` (defined below).\n-#[derive(Clone, PartialEq, Eq, Hash)]\n-pub struct Obligation<'tcx, T> {\n-    /// The reason we have to prove this thing.\n-    pub cause: ObligationCause<'tcx>,\n-\n-    /// The environment in which we should prove this thing.\n-    pub param_env: ty::ParamEnv<'tcx>,\n-\n-    /// The thing we are trying to prove.\n-    pub predicate: T,\n-\n-    /// If we started proving this as a result of trying to prove\n-    /// something else, track the total depth to ensure termination.\n-    /// If this goes over a certain threshold, we abort compilation --\n-    /// in such cases, we can not say whether or not the predicate\n-    /// holds for certain. Stupid halting problem; such a drag.\n-    pub recursion_depth: usize,\n-}\n-\n-pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n-pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n-\n-// `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct AssocTypeBoundData {\n+    pub impl_span: Option<Span>,\n+    pub original: Span,\n+    pub bounds: Vec<Span>,\n+}\n+\n+// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PredicateObligation<'_>, 112);\n-\n-pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n-pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n-pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n-\n-pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n-\n-pub struct FulfillmentError<'tcx> {\n-    pub obligation: PredicateObligation<'tcx>,\n-    pub code: FulfillmentErrorCode<'tcx>,\n-    /// Diagnostics only: we opportunistically change the `code.span` when we encounter an\n-    /// obligation error caused by a call argument. When this is the case, we also signal that in\n-    /// this field to ensure accuracy of suggestions.\n-    pub points_at_arg_span: bool,\n-}\n-\n-#[derive(Clone)]\n-pub enum FulfillmentErrorCode<'tcx> {\n-    CodeSelectionError(SelectionError<'tcx>),\n-    CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n-    CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate\n-    CodeAmbiguity,\n-}\n-\n-/// Creates predicate obligations from the generic bounds.\n-pub fn predicates_for_generics<'tcx>(\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n-) -> PredicateObligations<'tcx> {\n-    util::predicates_for_generics(cause, 0, param_env, generic_bounds)\n-}\n-\n-/// Determines whether the type `ty` is known to meet `bound` and\n-/// returns true if so. Returns false if `ty` either does not meet\n-/// `bound` or is not known to meet bound (note that this is\n-/// conservative towards *no impl*, which is the opposite of the\n-/// `evaluate` methods).\n-pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-    def_id: DefId,\n-    span: Span,\n-) -> bool {\n-    debug!(\n-        \"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n-        ty,\n-        infcx.tcx.def_path_str(def_id)\n-    );\n-\n-    let trait_ref = ty::TraitRef { def_id, substs: infcx.tcx.mk_substs_trait(ty, &[]) };\n-    let obligation = Obligation {\n-        param_env,\n-        cause: ObligationCause::misc(span, hir::DUMMY_HIR_ID),\n-        recursion_depth: 0,\n-        predicate: trait_ref.without_const().to_predicate(),\n-    };\n-\n-    let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n-    debug!(\n-        \"type_known_to_meet_ty={:?} bound={} => {:?}\",\n-        ty,\n-        infcx.tcx.def_path_str(def_id),\n-        result\n-    );\n-\n-    if result && (ty.has_infer_types() || ty.has_closure_types()) {\n-        // Because of inference \"guessing\", selection can sometimes claim\n-        // to succeed while the success requires a guess. To ensure\n-        // this function's result remains infallible, we must confirm\n-        // that guess. While imperfect, I believe this is sound.\n-\n-        // The handling of regions in this area of the code is terrible,\n-        // see issue #29149. We should be able to improve on this with\n-        // NLL.\n-        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n-\n-        // We can use a dummy node-id here because we won't pay any mind\n-        // to region obligations that arise (there shouldn't really be any\n-        // anyhow).\n-        let cause = ObligationCause::misc(span, hir::DUMMY_HIR_ID);\n-\n-        fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n-\n-        // Note: we only assume something is `Copy` if we can\n-        // *definitively* show that it implements `Copy`. Otherwise,\n-        // assume it is move; linear is always ok.\n-        match fulfill_cx.select_all_or_error(infcx) {\n-            Ok(()) => {\n-                debug!(\n-                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n-                    ty,\n-                    infcx.tcx.def_path_str(def_id)\n-                );\n-                true\n-            }\n-            Err(e) => {\n-                debug!(\n-                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n-                    ty,\n-                    infcx.tcx.def_path_str(def_id),\n-                    e\n-                );\n-                false\n-            }\n+static_assert_size!(ObligationCauseCode<'_>, 32);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct MatchExpressionArmCause<'tcx> {\n+    pub arm_span: Span,\n+    pub source: hir::MatchSource,\n+    pub prior_arms: Vec<Span>,\n+    pub last_ty: Ty<'tcx>,\n+    pub scrut_hir_id: hir::HirId,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct IfExpressionCause {\n+    pub then: Span,\n+    pub outer: Option<Span>,\n+    pub semicolon: Option<Span>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DerivedObligationCause<'tcx> {\n+    /// The trait reference of the parent obligation that led to the\n+    /// current obligation. Note that only trait obligations lead to\n+    /// derived obligations, so we just store the trait reference here\n+    /// directly.\n+    pub parent_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The parent trait had this cause.\n+    pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n+}\n+\n+/// The following types:\n+/// * `WhereClause`,\n+/// * `WellFormed`,\n+/// * `FromEnv`,\n+/// * `DomainGoal`,\n+/// * `Goal`,\n+/// * `Clause`,\n+/// * `Environment`,\n+/// * `InEnvironment`,\n+/// are used for representing the trait system in the form of\n+/// logic programming clauses. They are part of the interface\n+/// for the chalk SLG solver.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum WhereClause<'tcx> {\n+    Implemented(ty::TraitPredicate<'tcx>),\n+    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n+    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n+    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum WellFormed<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum FromEnv<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum DomainGoal<'tcx> {\n+    Holds(WhereClause<'tcx>),\n+    WellFormed(WellFormed<'tcx>),\n+    FromEnv(FromEnv<'tcx>),\n+    Normalize(ty::ProjectionPredicate<'tcx>),\n+}\n+\n+pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n+pub enum QuantifierKind {\n+    Universal,\n+    Existential,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum GoalKind<'tcx> {\n+    Implies(Clauses<'tcx>, Goal<'tcx>),\n+    And(Goal<'tcx>, Goal<'tcx>),\n+    Not(Goal<'tcx>),\n+    DomainGoal(DomainGoal<'tcx>),\n+    Quantified(QuantifierKind, ty::Binder<Goal<'tcx>>),\n+    Subtype(Ty<'tcx>, Ty<'tcx>),\n+    CannotProve,\n+}\n+\n+pub type Goal<'tcx> = &'tcx GoalKind<'tcx>;\n+\n+pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n+\n+impl<'tcx> DomainGoal<'tcx> {\n+    pub fn into_goal(self) -> GoalKind<'tcx> {\n+        GoalKind::DomainGoal(self)\n+    }\n+\n+    pub fn into_program_clause(self) -> ProgramClause<'tcx> {\n+        ProgramClause {\n+            goal: self,\n+            hypotheses: ty::List::empty(),\n+            category: ProgramClauseCategory::Other,\n         }\n-    } else {\n-        result\n     }\n }\n \n-fn do_normalize_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    region_context: DefId,\n-    cause: ObligationCause<'tcx>,\n-    elaborated_env: ty::ParamEnv<'tcx>,\n-    predicates: Vec<ty::Predicate<'tcx>>,\n-) -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported> {\n-    debug!(\n-        \"do_normalize_predicates(predicates={:?}, region_context={:?}, cause={:?})\",\n-        predicates, region_context, cause,\n-    );\n-    let span = cause.span;\n-    tcx.infer_ctxt().enter(|infcx| {\n-        // FIXME. We should really... do something with these region\n-        // obligations. But this call just continues the older\n-        // behavior (i.e., doesn't cause any new bugs), and it would\n-        // take some further refactoring to actually solve them. In\n-        // particular, we would have to handle implied bounds\n-        // properly, and that code is currently largely confined to\n-        // regionck (though I made some efforts to extract it\n-        // out). -nmatsakis\n-        //\n-        // @arielby: In any case, these obligations are checked\n-        // by wfcheck anyway, so I'm not sure we have to check\n-        // them here too, and we will remove this function when\n-        // we move over to lazy normalization *anyway*.\n-        let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n-        let predicates =\n-            match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, &predicates) {\n-                Ok(predicates) => predicates,\n-                Err(errors) => {\n-                    infcx.report_fulfillment_errors(&errors, None, false);\n-                    return Err(ErrorReported);\n-                }\n-            };\n-\n-        debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n-\n-        let region_scope_tree = region::ScopeTree::default();\n-\n-        // We can use the `elaborated_env` here; the region code only\n-        // cares about declarations like `'a: 'b`.\n-        let outlives_env = OutlivesEnvironment::new(elaborated_env);\n-\n-        infcx.resolve_regions_and_report_errors(\n-            region_context,\n-            &region_scope_tree,\n-            &outlives_env,\n-            SuppressRegionErrors::default(),\n-        );\n-\n-        let predicates = match infcx.fully_resolve(&predicates) {\n-            Ok(predicates) => predicates,\n-            Err(fixup_err) => {\n-                // If we encounter a fixup error, it means that some type\n-                // variable wound up unconstrained. I actually don't know\n-                // if this can happen, and I certainly don't expect it to\n-                // happen often, but if it did happen it probably\n-                // represents a legitimate failure due to some kind of\n-                // unconstrained variable, and it seems better not to ICE,\n-                // all things considered.\n-                tcx.sess.span_err(span, &fixup_err.to_string());\n-                return Err(ErrorReported);\n-            }\n-        };\n-        if predicates.has_local_value() {\n-            // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n-            Err(ErrorReported)\n-        } else {\n-            Ok(predicates)\n-        }\n-    })\n-}\n-\n-// FIXME: this is gonna need to be removed ...\n-/// Normalizes the parameter environment, reporting errors if they occur.\n-pub fn normalize_param_env_or_error<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    region_context: DefId,\n-    unnormalized_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-) -> ty::ParamEnv<'tcx> {\n-    // I'm not wild about reporting errors here; I'd prefer to\n-    // have the errors get reported at a defined place (e.g.,\n-    // during typeck). Instead I have all parameter\n-    // environments, in effect, going through this function\n-    // and hence potentially reporting errors. This ensures of\n-    // course that we never forget to normalize (the\n-    // alternative seemed like it would involve a lot of\n-    // manual invocations of this fn -- and then we'd have to\n-    // deal with the errors at each of those sites).\n-    //\n-    // In any case, in practice, typeck constructs all the\n-    // parameter environments once for every fn as it goes,\n-    // and errors will get reported then; so after typeck we\n-    // can be sure that no errors should occur.\n-\n-    debug!(\n-        \"normalize_param_env_or_error(region_context={:?}, unnormalized_env={:?}, cause={:?})\",\n-        region_context, unnormalized_env, cause\n-    );\n-\n-    let mut predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec()).collect();\n-\n-    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n-\n-    let elaborated_env = ty::ParamEnv::new(\n-        tcx.intern_predicates(&predicates),\n-        unnormalized_env.reveal,\n-        unnormalized_env.def_id,\n-    );\n-\n-    // HACK: we are trying to normalize the param-env inside *itself*. The problem is that\n-    // normalization expects its param-env to be already normalized, which means we have\n-    // a circularity.\n-    //\n-    // The way we handle this is by normalizing the param-env inside an unnormalized version\n-    // of the param-env, which means that if the param-env contains unnormalized projections,\n-    // we'll have some normalization failures. This is unfortunate.\n-    //\n-    // Lazy normalization would basically handle this by treating just the\n-    // normalizing-a-trait-ref-requires-itself cycles as evaluation failures.\n-    //\n-    // Inferred outlives bounds can create a lot of `TypeOutlives` predicates for associated\n-    // types, so to make the situation less bad, we normalize all the predicates *but*\n-    // the `TypeOutlives` predicates first inside the unnormalized parameter environment, and\n-    // then we normalize the `TypeOutlives` bounds inside the normalized parameter environment.\n-    //\n-    // This works fairly well because trait matching  does not actually care about param-env\n-    // TypeOutlives predicates - these are normally used by regionck.\n-    let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| match predicate {\n-            ty::Predicate::TypeOutlives(..) => true,\n-            _ => false,\n-        })\n-        .collect();\n-\n-    debug!(\n-        \"normalize_param_env_or_error: predicates=(non-outlives={:?}, outlives={:?})\",\n-        predicates, outlives_predicates\n-    );\n-    let non_outlives_predicates = match do_normalize_predicates(\n-        tcx,\n-        region_context,\n-        cause.clone(),\n-        elaborated_env,\n-        predicates,\n-    ) {\n-        Ok(predicates) => predicates,\n-        // An unnormalized env is better than nothing.\n-        Err(ErrorReported) => {\n-            debug!(\"normalize_param_env_or_error: errored resolving non-outlives predicates\");\n-            return elaborated_env;\n+impl<'tcx> GoalKind<'tcx> {\n+    pub fn from_poly_domain_goal(\n+        domain_goal: PolyDomainGoal<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> GoalKind<'tcx> {\n+        match domain_goal.no_bound_vars() {\n+            Some(p) => p.into_goal(),\n+            None => GoalKind::Quantified(\n+                QuantifierKind::Universal,\n+                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal())),\n+            ),\n         }\n-    };\n-\n-    debug!(\"normalize_param_env_or_error: non-outlives predicates={:?}\", non_outlives_predicates);\n-\n-    // Not sure whether it is better to include the unnormalized TypeOutlives predicates\n-    // here. I believe they should not matter, because we are ignoring TypeOutlives param-env\n-    // predicates here anyway. Keeping them here anyway because it seems safer.\n-    let outlives_env: Vec<_> =\n-        non_outlives_predicates.iter().chain(&outlives_predicates).cloned().collect();\n-    let outlives_env =\n-        ty::ParamEnv::new(tcx.intern_predicates(&outlives_env), unnormalized_env.reveal, None);\n-    let outlives_predicates = match do_normalize_predicates(\n-        tcx,\n-        region_context,\n-        cause,\n-        outlives_env,\n-        outlives_predicates,\n-    ) {\n-        Ok(predicates) => predicates,\n-        // An unnormalized env is better than nothing.\n-        Err(ErrorReported) => {\n-            debug!(\"normalize_param_env_or_error: errored resolving outlives predicates\");\n-            return elaborated_env;\n-        }\n-    };\n-    debug!(\"normalize_param_env_or_error: outlives predicates={:?}\", outlives_predicates);\n-\n-    let mut predicates = non_outlives_predicates;\n-    predicates.extend(outlives_predicates);\n-    debug!(\"normalize_param_env_or_error: final predicates={:?}\", predicates);\n-    ty::ParamEnv::new(\n-        tcx.intern_predicates(&predicates),\n-        unnormalized_env.reveal,\n-        unnormalized_env.def_id,\n-    )\n-}\n-\n-pub fn fully_normalize<'a, 'tcx, T>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n-    mut fulfill_cx: FulfillmentContext<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    value: &T,\n-) -> Result<T, Vec<FulfillmentError<'tcx>>>\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n-    let selcx = &mut SelectionContext::new(infcx);\n-    let Normalized { value: normalized_value, obligations } =\n-        project::normalize(selcx, param_env, cause, value);\n-    debug!(\n-        \"fully_normalize: normalized_value={:?} obligations={:?}\",\n-        normalized_value, obligations\n-    );\n-    for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n     }\n+}\n \n-    debug!(\"fully_normalize: select_all_or_error start\");\n-    fulfill_cx.select_all_or_error(infcx)?;\n-    debug!(\"fully_normalize: select_all_or_error complete\");\n-    let resolved_value = infcx.resolve_vars_if_possible(&normalized_value);\n-    debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n-    Ok(resolved_value)\n-}\n-\n-/// Normalizes the predicates and checks whether they hold in an empty\n-/// environment. If this returns false, then either normalize\n-/// encountered an error or one of the predicates did not hold. Used\n-/// when creating vtables to check for unsatisfiable methods.\n-pub fn normalize_and_test_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    predicates: Vec<ty::Predicate<'tcx>>,\n-) -> bool {\n-    debug!(\"normalize_and_test_predicates(predicates={:?})\", predicates);\n-\n-    let result = tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = ty::ParamEnv::reveal_all();\n-        let mut selcx = SelectionContext::new(&infcx);\n-        let mut fulfill_cx = FulfillmentContext::new();\n-        let cause = ObligationCause::dummy();\n-        let Normalized { value: predicates, obligations } =\n-            normalize(&mut selcx, param_env, cause.clone(), &predicates);\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-        }\n-        for predicate in predicates {\n-            let obligation = Obligation::new(cause.clone(), param_env, predicate);\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+/// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n+/// Harrop Formulas\".\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub enum Clause<'tcx> {\n+    Implies(ProgramClause<'tcx>),\n+    ForAll(ty::Binder<ProgramClause<'tcx>>),\n+}\n+\n+impl Clause<'tcx> {\n+    pub fn category(self) -> ProgramClauseCategory {\n+        match self {\n+            Clause::Implies(clause) => clause.category,\n+            Clause::ForAll(clause) => clause.skip_binder().category,\n         }\n+    }\n+}\n \n-        fulfill_cx.select_all_or_error(&infcx).is_ok()\n-    });\n-    debug!(\"normalize_and_test_predicates(predicates={:?}) = {:?}\", predicates, result);\n-    result\n-}\n-\n-fn substitute_normalize_and_test_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: (DefId, SubstsRef<'tcx>),\n-) -> bool {\n-    debug!(\"substitute_normalize_and_test_predicates(key={:?})\", key);\n-\n-    let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n-    let result = normalize_and_test_predicates(tcx, predicates);\n-\n-    debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\", key, result);\n-    result\n-}\n-\n-/// Given a trait `trait_ref`, iterates the vtable entries\n-/// that come from `trait_ref`, including its supertraits.\n-#[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n-fn vtable_methods<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n-    debug!(\"vtable_methods({:?})\", trait_ref);\n-\n-    tcx.arena.alloc_from_iter(supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-        let trait_methods = tcx\n-            .associated_items(trait_ref.def_id())\n-            .iter()\n-            .filter(|item| item.kind == ty::AssocKind::Method);\n-\n-        // Now list each method's DefId and InternalSubsts (for within its trait).\n-        // If the method can never be called from this object, produce None.\n-        trait_methods.map(move |trait_method| {\n-            debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n-            let def_id = trait_method.def_id;\n-\n-            // Some methods cannot be called on an object; skip those.\n-            if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n-                debug!(\"vtable_methods: not vtable safe\");\n-                return None;\n-            }\n+/// Multiple clauses.\n+pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n+\n+/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n+/// that the domain goal `D` is true if `G1...Gn` are provable. This\n+/// is equivalent to the implication `G1..Gn => D`; we usually write\n+/// it with the reverse implication operator `:-` to emphasize the way\n+/// that programs are actually solved (via backchaining, which starts\n+/// with the goal to solve and proceeds from there).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct ProgramClause<'tcx> {\n+    /// This goal will be considered true ...\n+    pub goal: DomainGoal<'tcx>,\n+\n+    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n+    pub hypotheses: Goals<'tcx>,\n+\n+    /// Useful for filtering clauses.\n+    pub category: ProgramClauseCategory,\n+}\n \n-            // The method may have some early-bound lifetimes; add regions for those.\n-            let substs = trait_ref.map_bound(|trait_ref| {\n-                InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n-                    GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n-                        trait_ref.substs[param.index as usize]\n-                    }\n-                })\n-            });\n-\n-            // The trait type may have higher-ranked lifetimes in it;\n-            // erase them if they appear, so that we get the type\n-            // at some particular call site.\n-            let substs =\n-                tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &substs);\n-\n-            // It's possible that the method relies on where-clauses that\n-            // do not hold for this particular set of type parameters.\n-            // Note that this method could then never be called, so we\n-            // do not want to try and codegen it, in that case (see #23435).\n-            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n-                debug!(\"vtable_methods: predicates do not hold\");\n-                return None;\n-            }\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n+pub enum ProgramClauseCategory {\n+    ImpliedBound,\n+    WellFormed,\n+    Other,\n+}\n \n-            Some((def_id, substs))\n-        })\n-    }))\n+/// A set of clauses that we assume to be true.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct Environment<'tcx> {\n+    pub clauses: Clauses<'tcx>,\n }\n \n-impl<'tcx, O> Obligation<'tcx, O> {\n-    pub fn new(\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: O,\n-    ) -> Obligation<'tcx, O> {\n-        Obligation { cause, param_env, recursion_depth: 0, predicate }\n+impl Environment<'tcx> {\n+    pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n+        InEnvironment { environment: self, goal }\n     }\n+}\n \n-    fn with_depth(\n-        cause: ObligationCause<'tcx>,\n-        recursion_depth: usize,\n-        param_env: ty::ParamEnv<'tcx>,\n-        predicate: O,\n-    ) -> Obligation<'tcx, O> {\n-        Obligation { cause, param_env, recursion_depth, predicate }\n-    }\n+/// Something (usually a goal), along with an environment.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct InEnvironment<'tcx, G> {\n+    pub environment: Environment<'tcx>,\n+    pub goal: G,\n+}\n \n-    pub fn misc(\n-        span: Span,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: O,\n-    ) -> Obligation<'tcx, O> {\n-        Obligation::new(ObligationCause::misc(span, body_id), param_env, trait_ref)\n+#[derive(Clone, Debug, TypeFoldable)]\n+pub enum SelectionError<'tcx> {\n+    Unimplemented,\n+    OutputTypeParameterMismatch(\n+        ty::PolyTraitRef<'tcx>,\n+        ty::PolyTraitRef<'tcx>,\n+        ty::error::TypeError<'tcx>,\n+    ),\n+    TraitNotObjectSafe(DefId),\n+    ConstEvalFailure(ErrorHandled),\n+    Overflow,\n+}\n+\n+/// When performing resolution, it is typically the case that there\n+/// can be one of three outcomes:\n+///\n+/// - `Ok(Some(r))`: success occurred with result `r`\n+/// - `Ok(None)`: could not definitely determine anything, usually due\n+///   to inconclusive type inference.\n+/// - `Err(e)`: error `e` occurred\n+pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n+\n+/// Given the successful resolution of an obligation, the `Vtable`\n+/// indicates where the vtable comes from. Note that while we call this\n+/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n+/// runtime. `Vtable` instances just tell the compiler where to find\n+/// methods, but in generic code those methods are typically statically\n+/// dispatched -- only when an object is constructed is a `Vtable`\n+/// instance reified into an actual vtable.\n+///\n+/// For example, the vtable may be tied to a specific impl (case A),\n+/// or it may be relative to some bound that is in scope (case B).\n+///\n+/// ```\n+/// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n+/// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n+/// impl Clone for int { ... }             // Impl_3\n+///\n+/// fn foo<T:Clone>(concrete: Option<Box<int>>,\n+///                 param: T,\n+///                 mixed: Option<T>) {\n+///\n+///    // Case A: Vtable points at a specific impl. Only possible when\n+///    // type is concretely known. If the impl itself has bounded\n+///    // type parameters, Vtable will carry resolutions for those as well:\n+///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n+///\n+///    // Case B: Vtable must be provided by caller. This applies when\n+///    // type is a type parameter.\n+///    param.clone();    // VtableParam\n+///\n+///    // Case C: A mix of cases A and B.\n+///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n+/// }\n+/// ```\n+///\n+/// ### The type parameter `N`\n+///\n+/// See explanation on `VtableImplData`.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub enum Vtable<'tcx, N> {\n+    /// Vtable identifying a particular impl.\n+    VtableImpl(VtableImplData<'tcx, N>),\n+\n+    /// Vtable for auto trait implementations.\n+    /// This carries the information and nested obligations with regards\n+    /// to an auto implementation for a trait `Trait`. The nested obligations\n+    /// ensure the trait implementation holds for all the constituent types.\n+    VtableAutoImpl(VtableAutoImplData<N>),\n+\n+    /// Successful resolution to an obligation provided by the caller\n+    /// for some type parameter. The `Vec<N>` represents the\n+    /// obligations incurred from normalizing the where-clause (if\n+    /// any).\n+    VtableParam(Vec<N>),\n+\n+    /// Virtual calls through an object.\n+    VtableObject(VtableObjectData<'tcx, N>),\n+\n+    /// Successful resolution for a builtin trait.\n+    VtableBuiltin(VtableBuiltinData<N>),\n+\n+    /// Vtable automatically generated for a closure. The `DefId` is the ID\n+    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n+    /// impl is generated by the compiler and does not appear in the source.\n+    VtableClosure(VtableClosureData<'tcx, N>),\n+\n+    /// Same as above, but for a function pointer type with the given signature.\n+    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n+\n+    /// Vtable automatically generated for a generator.\n+    VtableGenerator(VtableGeneratorData<'tcx, N>),\n+\n+    /// Vtable for a trait alias.\n+    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n+}\n+\n+impl<'tcx, N> Vtable<'tcx, N> {\n+    pub fn nested_obligations(self) -> Vec<N> {\n+        match self {\n+            VtableImpl(i) => i.nested,\n+            VtableParam(n) => n,\n+            VtableBuiltin(i) => i.nested,\n+            VtableAutoImpl(d) => d.nested,\n+            VtableClosure(c) => c.nested,\n+            VtableGenerator(c) => c.nested,\n+            VtableObject(d) => d.nested,\n+            VtableFnPointer(d) => d.nested,\n+            VtableTraitAlias(d) => d.nested,\n+        }\n     }\n \n-    pub fn with<P>(&self, value: P) -> Obligation<'tcx, P> {\n-        Obligation {\n-            cause: self.cause.clone(),\n-            param_env: self.param_env,\n-            recursion_depth: self.recursion_depth,\n-            predicate: value,\n+    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n+    where\n+        F: FnMut(N) -> M,\n+    {\n+        match self {\n+            VtableImpl(i) => VtableImpl(VtableImplData {\n+                impl_def_id: i.impl_def_id,\n+                substs: i.substs,\n+                nested: i.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n+            VtableBuiltin(i) => {\n+                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n+            }\n+            VtableObject(o) => VtableObject(VtableObjectData {\n+                upcast_trait_ref: o.upcast_trait_ref,\n+                vtable_base: o.vtable_base,\n+                nested: o.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableAutoImpl(d) => VtableAutoImpl(VtableAutoImplData {\n+                trait_def_id: d.trait_def_id,\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableClosure(c) => VtableClosure(VtableClosureData {\n+                closure_def_id: c.closure_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n+                generator_def_id: c.generator_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n+                fn_ty: p.fn_ty,\n+                nested: p.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n+                alias_def_id: d.alias_def_id,\n+                substs: d.substs,\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n         }\n     }\n }\n \n-impl<'tcx> FulfillmentError<'tcx> {\n-    fn new(\n-        obligation: PredicateObligation<'tcx>,\n-        code: FulfillmentErrorCode<'tcx>,\n-    ) -> FulfillmentError<'tcx> {\n-        FulfillmentError { obligation: obligation, code: code, points_at_arg_span: false }\n-    }\n+/// Identifies a particular impl in the source, along with a set of\n+/// substitutions from the impl's type/lifetime parameters. The\n+/// `nested` vector corresponds to the nested obligations attached to\n+/// the impl's type parameters.\n+///\n+/// The type parameter `N` indicates the type used for \"nested\n+/// obligations\" that are required by the impl. During type-check, this\n+/// is `Obligation`, as one might expect. During codegen, however, this\n+/// is `()`, because codegen only requires a shallow resolution of an\n+/// impl, and nested obligations are satisfied later.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableImplData<'tcx, N> {\n+    pub impl_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub nested: Vec<N>,\n }\n \n-impl<'tcx> TraitObligation<'tcx> {\n-    fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.predicate.map_bound(|p| p.self_ty())\n-    }\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableGeneratorData<'tcx, N> {\n+    pub generator_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    /// Nested obligations. This can be non-empty if the generator\n+    /// signature contains associated types.\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableClosureData<'tcx, N> {\n+    pub closure_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    /// Nested obligations. This can be non-empty if the closure\n+    /// signature contains associated types.\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableAutoImplData<N> {\n+    pub trait_def_id: DefId,\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableBuiltinData<N> {\n+    pub nested: Vec<N>,\n+}\n+\n+/// A vtable for some object-safe trait `Foo` automatically derived\n+/// for the object type `Foo`.\n+#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableObjectData<'tcx, N> {\n+    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n+    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The vtable is formed by concatenating together the method lists of\n+    /// the base object trait and all supertraits; this is the start of\n+    /// `upcast_trait_ref`'s methods in that vtable.\n+    pub vtable_base: usize,\n+\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableFnPointerData<'tcx, N> {\n+    pub fn_ty: Ty<'tcx>,\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableTraitAliasData<'tcx, N> {\n+    pub alias_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub nested: Vec<N>,\n }\n \n-pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    *providers = ty::query::Providers {\n-        is_object_safe: object_safety::is_object_safe_provider,\n-        specialization_graph_of: specialize::specialization_graph_provider,\n-        specializes: specialize::specializes,\n-        codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n-        vtable_methods,\n-        substitute_normalize_and_test_predicates,\n-        ..*providers\n-    };\n+pub trait ExClauseFold<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        folder: &mut F,\n+    ) -> chalk_engine::ExClause<Self>;\n+\n+    fn visit_ex_clause_with<V: TypeVisitor<'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        visitor: &mut V,\n+    ) -> bool;\n+}\n+\n+pub trait ChalkContextLift<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    type LiftedExClause: Debug + 'tcx;\n+    type LiftedDelayedLiteral: Debug + 'tcx;\n+    type LiftedLiteral: Debug + 'tcx;\n+\n+    fn lift_ex_clause_to_tcx(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedExClause>;\n+\n+    fn lift_delayed_literal_to_tcx(\n+        ex_clause: &chalk_engine::DelayedLiteral<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedDelayedLiteral>;\n+\n+    fn lift_literal_to_tcx(\n+        ex_clause: &chalk_engine::Literal<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedLiteral>;\n }"}, {"sha": "c90551826202efd4300a90cde649cae91c71d8b0", "filename": "src/librustc/traits/query.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/traits/types/query.rs"}, {"sha": "ac3d0049c0c7c42908e6cff2df5b90e46ea13c50", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 234, "deletions": 3776, "changes": 4010, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5"}, {"sha": "36a84369d4a3ac6e407f0e9d2cf49fae1ec31b7e", "filename": "src/librustc/traits/specialization_graph.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialization_graph.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/traits/types/specialization_graph.rs"}, {"sha": "48ed29f2bb33841cc974147d5b81218453a2cb16", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 674, "deletions": 33, "changes": 707, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,71 +1,712 @@\n use crate::traits;\n-use crate::traits::project::Normalized;\n-use crate::ty;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::{self, Lift, Ty, TyCtxt};\n+use rustc_span::symbol::Symbol;\n+use smallvec::SmallVec;\n \n+use std::collections::{BTreeMap, BTreeSet};\n use std::fmt;\n+use std::rc::Rc;\n \n // Structural impls for the structs in `traits`.\n \n-impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"Normalized({:?}, {:?})\", self.value, self.obligations)\n+        match *self {\n+            super::VtableImpl(ref v) => write!(f, \"{:?}\", v),\n+\n+            super::VtableAutoImpl(ref t) => write!(f, \"{:?}\", t),\n+\n+            super::VtableClosure(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableGenerator(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n+\n+            super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n+\n+            super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableTraitAlias(ref d) => write!(f, \"{:?}\", d),\n+        }\n     }\n }\n \n-impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        if ty::tls::with(|tcx| tcx.sess.verbose()) {\n-            write!(\n-                f,\n-                \"Obligation(predicate={:?}, cause={:?}, param_env={:?}, depth={})\",\n-                self.predicate, self.cause, self.param_env, self.recursion_depth\n-            )\n-        } else {\n-            write!(f, \"Obligation(predicate={:?}, depth={})\", self.predicate, self.recursion_depth)\n-        }\n+        write!(\n+            f,\n+            \"VtableImplData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.impl_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.generator_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.closure_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"VtableBuiltinData(nested={:?})\", self.nested)\n+    }\n+}\n+\n+impl<N: fmt::Debug> fmt::Debug for traits::VtableAutoImplData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n+            self.trait_def_id, self.nested\n+        )\n     }\n }\n \n-impl<'tcx> fmt::Debug for traits::FulfillmentError<'tcx> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"FulfillmentError({:?},{:?})\", self.obligation, self.code)\n+        write!(\n+            f,\n+            \"VtableObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n+            self.upcast_trait_ref, self.vtable_base, self.nested\n+        )\n     }\n }\n \n-impl<'tcx> fmt::Debug for traits::FulfillmentErrorCode<'tcx> {\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"VtableFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableTraitAliasData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.alias_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::WhereClause::*;\n+\n+        // Bypass `ty::print` because it does not print out anonymous regions.\n+        // FIXME(eddyb) implement a custom `PrettyPrinter`, or move this to `ty::print`.\n+        fn write_region_name<'tcx>(\n+            r: ty::Region<'tcx>,\n+            fmt: &mut fmt::Formatter<'_>,\n+        ) -> fmt::Result {\n+            match r {\n+                ty::ReLateBound(index, br) => match br {\n+                    ty::BoundRegion::BrNamed(_, name) => write!(fmt, \"{}\", name),\n+                    ty::BoundRegion::BrAnon(var) => {\n+                        if *index == ty::INNERMOST {\n+                            write!(fmt, \"'^{}\", var)\n+                        } else {\n+                            write!(fmt, \"'^{}_{}\", index.index(), var)\n+                        }\n+                    }\n+                    _ => write!(fmt, \"'_\"),\n+                },\n+\n+                _ => write!(fmt, \"{}\", r),\n+            }\n+        }\n+\n+        match self {\n+            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n+            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n+            RegionOutlives(predicate) => {\n+                write!(fmt, \"RegionOutlives({}: \", predicate.0)?;\n+                write_region_name(predicate.1, fmt)?;\n+                write!(fmt, \")\")\n+            }\n+            TypeOutlives(predicate) => {\n+                write!(fmt, \"TypeOutlives({}: \", predicate.0)?;\n+                write_region_name(predicate.1, fmt)?;\n+                write!(fmt, \")\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::WellFormed::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::FromEnv::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::DomainGoal::*;\n+\n+        match self {\n+            Holds(wc) => write!(fmt, \"{}\", wc),\n+            WellFormed(wf) => write!(fmt, \"{}\", wf),\n+            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n+            Normalize(projection) => {\n+                write!(fmt, \"Normalize({} -> {})\", projection.projection_ty, projection.ty)\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Display for traits::QuantifierKind {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::QuantifierKind::*;\n+\n+        match self {\n+            Universal => write!(fmt, \"forall\"),\n+            Existential => write!(fmt, \"exists\"),\n+        }\n+    }\n+}\n+\n+/// Collect names for regions / types bound by a quantified goal / clause.\n+/// This collector does not try to do anything clever like in `ty::print`, it's just used\n+/// for debug output in tests anyway.\n+struct BoundNamesCollector {\n+    // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n+    regions: BTreeSet<Symbol>,\n+\n+    // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n+    // by the list of type parameters.\n+    types: BTreeMap<u32, Symbol>,\n+\n+    binder_index: ty::DebruijnIndex,\n+}\n+\n+impl BoundNamesCollector {\n+    fn new() -> Self {\n+        BoundNamesCollector {\n+            regions: BTreeSet::new(),\n+            types: BTreeMap::new(),\n+            binder_index: ty::INNERMOST,\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.regions.is_empty() && self.types.is_empty()\n+    }\n+\n+    fn write_names(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut start = true;\n+        for r in &self.regions {\n+            if !start {\n+                write!(fmt, \", \")?;\n+            }\n+            start = false;\n+            write!(fmt, \"{}\", r)?;\n+        }\n+        for (_, t) in &self.types {\n+            if !start {\n+                write!(fmt, \", \")?;\n+            }\n+            start = false;\n+            write!(fmt, \"{}\", t)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        match t.kind {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                self.types.insert(\n+                    bound_ty.var.as_u32(),\n+                    match bound_ty.kind {\n+                        ty::BoundTyKind::Param(name) => name,\n+                        ty::BoundTyKind::Anon => {\n+                            Symbol::intern(&format!(\"^{}\", bound_ty.var.as_u32()))\n+                        }\n+                    },\n+                );\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n+                ty::BoundRegion::BrNamed(_, name) => {\n+                    self.regions.insert(*name);\n+                }\n+\n+                ty::BoundRegion::BrAnon(var) => {\n+                    self.regions.insert(Symbol::intern(&format!(\"'^{}\", var)));\n+                }\n+\n+                _ => (),\n+            },\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::GoalKind::*;\n+\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                write!(fmt, \"if (\")?;\n+                for (index, hyp) in hypotheses.iter().enumerate() {\n+                    if index > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{}\", hyp)?;\n+                }\n+                write!(fmt, \") {{ {} }}\", goal)\n+            }\n+            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n+            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n+            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n+            Quantified(qkind, goal) => {\n+                let mut collector = BoundNamesCollector::new();\n+                goal.skip_binder().visit_with(&mut collector);\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \"{}<\", qkind)?;\n+                    collector.write_names(fmt)?;\n+                    write!(fmt, \"> {{ \")?;\n+                }\n+\n+                write!(fmt, \"{}\", goal.skip_binder())?;\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \" }}\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            Subtype(a, b) => write!(fmt, \"{} <: {}\", a, b),\n+            CannotProve => write!(fmt, \"CannotProve\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let traits::ProgramClause { goal, hypotheses, .. } = self;\n+        write!(fmt, \"{}\", goal)?;\n+        if !hypotheses.is_empty() {\n+            write!(fmt, \" :- \")?;\n+            for (index, condition) in hypotheses.iter().enumerate() {\n+                if index > 0 {\n+                    write!(fmt, \", \")?;\n+                }\n+                write!(fmt, \"{}\", condition)?;\n+            }\n+        }\n+        write!(fmt, \".\")\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::Clause::*;\n+\n+        match self {\n+            Implies(clause) => write!(fmt, \"{}\", clause),\n+            ForAll(clause) => {\n+                let mut collector = BoundNamesCollector::new();\n+                clause.skip_binder().visit_with(&mut collector);\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \"forall<\")?;\n+                    collector.write_names(fmt)?;\n+                    write!(fmt, \"> {{ \")?;\n+                }\n+\n+                write!(fmt, \"{}\", clause.skip_binder())?;\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \" }}\")?;\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Lift implementations\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n+    type Lifted = traits::SelectionError<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match *self {\n-            super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n-            super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n-            super::CodeSubtypeError(ref a, ref b) => {\n-                write!(f, \"CodeSubtypeError({:?}, {:?})\", a, b)\n+            super::Unimplemented => Some(super::Unimplemented),\n+            super::OutputTypeParameterMismatch(a, b, ref err) => {\n+                tcx.lift(&(a, b)).and_then(|(a, b)| {\n+                    tcx.lift(err).map(|err| super::OutputTypeParameterMismatch(a, b, err))\n+                })\n             }\n-            super::CodeAmbiguity => write!(f, \"Ambiguity\"),\n+            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n+            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n+            super::Overflow => Some(super::Overflow),\n         }\n     }\n }\n \n-impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"MismatchedProjectionTypes({:?})\", self.err)\n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n+    type Lifted = traits::ObligationCauseCode<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n+            super::MiscObligation => Some(super::MiscObligation),\n+            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n+            super::TupleElem => Some(super::TupleElem),\n+            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n+            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n+            super::BindingObligation(def_id, span) => Some(super::BindingObligation(def_id, span)),\n+            super::ReferenceOutlivesReferent(ty) => {\n+                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n+            }\n+            super::ObjectTypeBound(ty, r) => tcx\n+                .lift(&ty)\n+                .and_then(|ty| tcx.lift(&r).and_then(|r| Some(super::ObjectTypeBound(ty, r)))),\n+            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n+            super::Coercion { source, target } => {\n+                Some(super::Coercion { source: tcx.lift(&source)?, target: tcx.lift(&target)? })\n+            }\n+            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n+            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n+            super::StructInitializerSized => Some(super::StructInitializerSized),\n+            super::VariableType(id) => Some(super::VariableType(id)),\n+            super::ReturnValue(id) => Some(super::ReturnValue(id)),\n+            super::ReturnType => Some(super::ReturnType),\n+            super::SizedArgumentType => Some(super::SizedArgumentType),\n+            super::SizedReturnType => Some(super::SizedReturnType),\n+            super::SizedYieldType => Some(super::SizedYieldType),\n+            super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n+            super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n+            super::ConstSized => Some(super::ConstSized),\n+            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n+            super::SharedStatic => Some(super::SharedStatic),\n+            super::BuiltinDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n+            }\n+            super::ImplDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::ImplDerivedObligation)\n+            }\n+            super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => Some(super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            }),\n+            super::CompareImplTypeObligation { item_name, impl_item_def_id, trait_item_def_id } => {\n+                Some(super::CompareImplTypeObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                })\n+            }\n+            super::ExprAssignable => Some(super::ExprAssignable),\n+            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n+                arm_span,\n+                source,\n+                ref prior_arms,\n+                last_ty,\n+                scrut_hir_id,\n+            }) => tcx.lift(&last_ty).map(|last_ty| {\n+                super::MatchExpressionArm(box super::MatchExpressionArmCause {\n+                    arm_span,\n+                    source,\n+                    prior_arms: prior_arms.clone(),\n+                    last_ty,\n+                    scrut_hir_id,\n+                })\n+            }),\n+            super::Pattern { span, root_ty, origin_expr } => {\n+                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n+            }\n+            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n+                Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))\n+            }\n+            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n+            super::MainFunctionType => Some(super::MainFunctionType),\n+            super::StartFunctionType => Some(super::StartFunctionType),\n+            super::IntrinsicType => Some(super::IntrinsicType),\n+            super::MethodReceiver => Some(super::MethodReceiver),\n+            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n+            super::TrivialBound => Some(super::TrivialBound),\n+            super::AssocTypeBound(ref data) => Some(super::AssocTypeBound(data.clone())),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n+    type Lifted = traits::DerivedObligationCause<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n+            tcx.lift(&*self.parent_code).map(|code| traits::DerivedObligationCause {\n+                parent_trait_ref: trait_ref,\n+                parent_code: Rc::new(code),\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n+    type Lifted = traits::ObligationCause<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.code).map(|code| traits::ObligationCause {\n+            span: self.span,\n+            body_id: self.body_id,\n+            code,\n+        })\n+    }\n+}\n+\n+// For codegen only.\n+impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n+    type Lifted = traits::Vtable<'tcx, ()>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self.clone() {\n+            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested })\n+                })\n+            }\n+            traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n+            traits::VtableGenerator(traits::VtableGeneratorData {\n+                generator_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableGenerator(traits::VtableGeneratorData {\n+                    generator_def_id: generator_def_id,\n+                    substs: substs,\n+                    nested: nested,\n+                })\n+            }),\n+            traits::VtableClosure(traits::VtableClosureData { closure_def_id, substs, nested }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableClosure(traits::VtableClosureData {\n+                        closure_def_id,\n+                        substs,\n+                        nested,\n+                    })\n+                })\n+            }\n+            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n+                tcx.lift(&fn_ty).map(|fn_ty| {\n+                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n+                })\n+            }\n+            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n+            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n+            traits::VtableObject(traits::VtableObjectData {\n+                upcast_trait_ref,\n+                vtable_base,\n+                nested,\n+            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n+                traits::VtableObject(traits::VtableObjectData {\n+                    upcast_trait_ref: trait_ref,\n+                    vtable_base,\n+                    nested,\n+                })\n+            }),\n+            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                alias_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                    alias_def_id,\n+                    substs,\n+                    nested,\n+                })\n+            }),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n+    type Lifted = traits::Environment<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.clauses).map(|clauses| traits::Environment { clauses })\n+    }\n+}\n+\n+impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n+    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.environment).and_then(|environment| {\n+            tcx.lift(&self.goal).map(|goal| traits::InEnvironment { environment, goal })\n+        })\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedExClause;\n+\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::DelayedLiteral<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedDelayedLiteral;\n+\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::Literal<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedLiteral;\n+\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n \n-impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n+CloneTypeFoldableAndLiftImpls! {\n+    traits::QuantifierKind,\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        traits::Obligation {\n-            cause: self.cause.clone(),\n-            recursion_depth: self.recursion_depth,\n-            predicate: self.predicate.fold_with(folder),\n-            param_env: self.param_env.fold_with(folder),\n-        }\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+        folder.tcx().intern_goals(&v)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.predicate.visit_with(visitor)\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = (**self).fold_with(folder);\n+        folder.tcx().mk_goal(v)\n     }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        (**self).visit_with(visitor)\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    traits::ProgramClauseCategory,\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+        folder.tcx().intern_clauses(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: traits::ExClauseFold<'tcx>,\n+    C::Substitution: Clone,\n+    C::RegionConstraint: Clone,\n+{\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        <C as traits::ExClauseFold>::fold_ex_clause_with(self, folder)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        <C as traits::ExClauseFold>::visit_ex_clause_with(self, visitor)\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n+        (chalk_engine::DelayedLiteral::CannotProve)(a),\n+        (chalk_engine::DelayedLiteral::Negative)(a),\n+        (chalk_engine::DelayedLiteral::Positive)(a, b),\n+    } where\n+        C: chalk_engine::context::Context<CanonicalConstrainedSubst: TypeFoldable<'tcx>> + Clone,\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::Literal<C> {\n+        (chalk_engine::Literal::Negative)(a),\n+        (chalk_engine::Literal::Positive)(a),\n+    } where\n+        C: chalk_engine::context::Context<GoalInEnvironment: Clone + TypeFoldable<'tcx>> + Clone,\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    chalk_engine::TableIndex,\n }"}, {"sha": "571fb505779ca2408d2303a525fbc4d848df145d", "filename": "src/librustc/traits/types/mod.rs", "status": "removed", "additions": 0, "deletions": 736, "changes": 736, "blob_url": "https://github.com/rust-lang/rust/blob/5e7af4669f80e5f682141f050193ab679afdb4b1/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7af4669f80e5f682141f050193ab679afdb4b1/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs?ref=5e7af4669f80e5f682141f050193ab679afdb4b1", "patch": "@@ -1,736 +0,0 @@\n-//! Trait Resolution. See the [rustc guide] for more information on how this works.\n-//!\n-//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n-\n-pub mod query;\n-pub mod select;\n-pub mod specialization_graph;\n-mod structural_impls;\n-\n-use crate::mir::interpret::ErrorHandled;\n-use crate::ty::fold::{TypeFolder, TypeVisitor};\n-use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, AdtKind, List, Ty, TyCtxt};\n-\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_span::{Span, DUMMY_SP};\n-use syntax::ast;\n-\n-use std::fmt::Debug;\n-use std::rc::Rc;\n-\n-pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n-\n-pub use self::ObligationCauseCode::*;\n-pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n-\n-/// Depending on the stage of compilation, we want projection to be\n-/// more or less conservative.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n-pub enum Reveal {\n-    /// At type-checking time, we refuse to project any associated\n-    /// type that is marked `default`. Non-`default` (\"final\") types\n-    /// are always projected. This is necessary in general for\n-    /// soundness of specialization. However, we *could* allow\n-    /// projections in fully-monomorphic cases. We choose not to,\n-    /// because we prefer for `default type` to force the type\n-    /// definition to be treated abstractly by any consumers of the\n-    /// impl. Concretely, that means that the following example will\n-    /// fail to compile:\n-    ///\n-    /// ```\n-    /// trait Assoc {\n-    ///     type Output;\n-    /// }\n-    ///\n-    /// impl<T> Assoc for T {\n-    ///     default type Output = bool;\n-    /// }\n-    ///\n-    /// fn main() {\n-    ///     let <() as Assoc>::Output = true;\n-    /// }\n-    /// ```\n-    UserFacing,\n-\n-    /// At codegen time, all monomorphic projections will succeed.\n-    /// Also, `impl Trait` is normalized to the concrete type,\n-    /// which has to be already collected by type-checking.\n-    ///\n-    /// NOTE: as `impl Trait`'s concrete type should *never*\n-    /// be observable directly by the user, `Reveal::All`\n-    /// should not be used by checks which may expose\n-    /// type equality or type contents to the user.\n-    /// There are some exceptions, e.g., around OIBITS and\n-    /// transmute-checking, which expose some details, but\n-    /// not the whole concrete type of the `impl Trait`.\n-    All,\n-}\n-\n-/// The reason why we incurred this obligation; used for error reporting.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct ObligationCause<'tcx> {\n-    pub span: Span,\n-\n-    /// The ID of the fn body that triggered this obligation. This is\n-    /// used for region obligations to determine the precise\n-    /// environment in which the region obligation should be evaluated\n-    /// (in particular, closures can add new assumptions). See the\n-    /// field `region_obligations` of the `FulfillmentContext` for more\n-    /// information.\n-    pub body_id: hir::HirId,\n-\n-    pub code: ObligationCauseCode<'tcx>,\n-}\n-\n-impl<'tcx> ObligationCause<'tcx> {\n-    #[inline]\n-    pub fn new(\n-        span: Span,\n-        body_id: hir::HirId,\n-        code: ObligationCauseCode<'tcx>,\n-    ) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id, code }\n-    }\n-\n-    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id, code: MiscObligation }\n-    }\n-\n-    pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n-    }\n-\n-    pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n-        match self.code {\n-            ObligationCauseCode::CompareImplMethodObligation { .. }\n-            | ObligationCauseCode::MainFunctionType\n-            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n-            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                arm_span,\n-                ..\n-            }) => arm_span,\n-            _ => self.span,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ObligationCauseCode<'tcx> {\n-    /// Not well classified or should be obvious from the span.\n-    MiscObligation,\n-\n-    /// A slice or array is WF only if `T: Sized`.\n-    SliceOrArrayElem,\n-\n-    /// A tuple is WF only if its middle elements are `Sized`.\n-    TupleElem,\n-\n-    /// This is the trait reference from the given projection.\n-    ProjectionWf(ty::ProjectionTy<'tcx>),\n-\n-    /// In an impl of trait `X` for type `Y`, type `Y` must\n-    /// also implement all supertraits of `X`.\n-    ItemObligation(DefId),\n-\n-    /// Like `ItemObligation`, but with extra detail on the source of the obligation.\n-    BindingObligation(DefId, Span),\n-\n-    /// A type like `&'a T` is WF only if `T: 'a`.\n-    ReferenceOutlivesReferent(Ty<'tcx>),\n-\n-    /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n-    ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n-\n-    /// Obligation incurred due to an object cast.\n-    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n-\n-    /// Obligation incurred due to a coercion.\n-    Coercion {\n-        source: Ty<'tcx>,\n-        target: Ty<'tcx>,\n-    },\n-\n-    /// Various cases where expressions must be `Sized` / `Copy` / etc.\n-    /// `L = X` implies that `L` is `Sized`.\n-    AssignmentLhsSized,\n-    /// `(x1, .., xn)` must be `Sized`.\n-    TupleInitializerSized,\n-    /// `S { ... }` must be `Sized`.\n-    StructInitializerSized,\n-    /// Type of each variable must be `Sized`.\n-    VariableType(hir::HirId),\n-    /// Argument type must be `Sized`.\n-    SizedArgumentType,\n-    /// Return type must be `Sized`.\n-    SizedReturnType,\n-    /// Yield type must be `Sized`.\n-    SizedYieldType,\n-    /// `[T, ..n]` implies that `T` must be `Copy`.\n-    /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n-    RepeatVec(bool),\n-\n-    /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n-    FieldSized {\n-        adt_kind: AdtKind,\n-        last: bool,\n-    },\n-\n-    /// Constant expressions must be sized.\n-    ConstSized,\n-\n-    /// `static` items must have `Sync` type.\n-    SharedStatic,\n-\n-    BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n-\n-    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n-\n-    /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplMethodObligation {\n-        item_name: ast::Name,\n-        impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-    },\n-\n-    /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplTypeObligation {\n-        item_name: ast::Name,\n-        impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-    },\n-\n-    /// Checking that this expression can be assigned where it needs to be\n-    // FIXME(eddyb) #11161 is the original Expr required?\n-    ExprAssignable,\n-\n-    /// Computing common supertype in the arms of a match expression\n-    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n-\n-    /// Type error arising from type checking a pattern against an expected type.\n-    Pattern {\n-        /// The span of the scrutinee or type expression which caused the `root_ty` type.\n-        span: Option<Span>,\n-        /// The root expected type induced by a scrutinee or type expression.\n-        root_ty: Ty<'tcx>,\n-        /// Whether the `Span` came from an expression or a type expression.\n-        origin_expr: bool,\n-    },\n-\n-    /// Constants in patterns must have `Structural` type.\n-    ConstPatternStructural,\n-\n-    /// Computing common supertype in an if expression\n-    IfExpression(Box<IfExpressionCause>),\n-\n-    /// Computing common supertype of an if expression with no else counter-part\n-    IfExpressionWithNoElse,\n-\n-    /// `main` has wrong type\n-    MainFunctionType,\n-\n-    /// `start` has wrong type\n-    StartFunctionType,\n-\n-    /// Intrinsic has wrong type\n-    IntrinsicType,\n-\n-    /// Method receiver\n-    MethodReceiver,\n-\n-    /// `return` with no expression\n-    ReturnNoExpression,\n-\n-    /// `return` with an expression\n-    ReturnValue(hir::HirId),\n-\n-    /// Return type of this function\n-    ReturnType,\n-\n-    /// Block implicit return\n-    BlockTailExpression(hir::HirId),\n-\n-    /// #[feature(trivial_bounds)] is not enabled\n-    TrivialBound,\n-\n-    AssocTypeBound(Box<AssocTypeBoundData>),\n-}\n-\n-impl ObligationCauseCode<'_> {\n-    // Return the base obligation, ignoring derived obligations.\n-    pub fn peel_derives(&self) -> &Self {\n-        let mut base_cause = self;\n-        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n-            base_cause = &cause.parent_code;\n-        }\n-        base_cause\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct AssocTypeBoundData {\n-    pub impl_span: Option<Span>,\n-    pub original: Span,\n-    pub bounds: Vec<Span>,\n-}\n-\n-// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(ObligationCauseCode<'_>, 32);\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct MatchExpressionArmCause<'tcx> {\n-    pub arm_span: Span,\n-    pub source: hir::MatchSource,\n-    pub prior_arms: Vec<Span>,\n-    pub last_ty: Ty<'tcx>,\n-    pub scrut_hir_id: hir::HirId,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct IfExpressionCause {\n-    pub then: Span,\n-    pub outer: Option<Span>,\n-    pub semicolon: Option<Span>,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DerivedObligationCause<'tcx> {\n-    /// The trait reference of the parent obligation that led to the\n-    /// current obligation. Note that only trait obligations lead to\n-    /// derived obligations, so we just store the trait reference here\n-    /// directly.\n-    pub parent_trait_ref: ty::PolyTraitRef<'tcx>,\n-\n-    /// The parent trait had this cause.\n-    pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n-}\n-\n-/// The following types:\n-/// * `WhereClause`,\n-/// * `WellFormed`,\n-/// * `FromEnv`,\n-/// * `DomainGoal`,\n-/// * `Goal`,\n-/// * `Clause`,\n-/// * `Environment`,\n-/// * `InEnvironment`,\n-/// are used for representing the trait system in the form of\n-/// logic programming clauses. They are part of the interface\n-/// for the chalk SLG solver.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum WhereClause<'tcx> {\n-    Implemented(ty::TraitPredicate<'tcx>),\n-    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n-    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n-    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum WellFormed<'tcx> {\n-    Trait(ty::TraitPredicate<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum FromEnv<'tcx> {\n-    Trait(ty::TraitPredicate<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum DomainGoal<'tcx> {\n-    Holds(WhereClause<'tcx>),\n-    WellFormed(WellFormed<'tcx>),\n-    FromEnv(FromEnv<'tcx>),\n-    Normalize(ty::ProjectionPredicate<'tcx>),\n-}\n-\n-pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n-pub enum QuantifierKind {\n-    Universal,\n-    Existential,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum GoalKind<'tcx> {\n-    Implies(Clauses<'tcx>, Goal<'tcx>),\n-    And(Goal<'tcx>, Goal<'tcx>),\n-    Not(Goal<'tcx>),\n-    DomainGoal(DomainGoal<'tcx>),\n-    Quantified(QuantifierKind, ty::Binder<Goal<'tcx>>),\n-    Subtype(Ty<'tcx>, Ty<'tcx>),\n-    CannotProve,\n-}\n-\n-pub type Goal<'tcx> = &'tcx GoalKind<'tcx>;\n-\n-pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n-\n-impl<'tcx> DomainGoal<'tcx> {\n-    pub fn into_goal(self) -> GoalKind<'tcx> {\n-        GoalKind::DomainGoal(self)\n-    }\n-\n-    pub fn into_program_clause(self) -> ProgramClause<'tcx> {\n-        ProgramClause {\n-            goal: self,\n-            hypotheses: ty::List::empty(),\n-            category: ProgramClauseCategory::Other,\n-        }\n-    }\n-}\n-\n-impl<'tcx> GoalKind<'tcx> {\n-    pub fn from_poly_domain_goal(\n-        domain_goal: PolyDomainGoal<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> GoalKind<'tcx> {\n-        match domain_goal.no_bound_vars() {\n-            Some(p) => p.into_goal(),\n-            None => GoalKind::Quantified(\n-                QuantifierKind::Universal,\n-                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal())),\n-            ),\n-        }\n-    }\n-}\n-\n-/// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n-/// Harrop Formulas\".\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub enum Clause<'tcx> {\n-    Implies(ProgramClause<'tcx>),\n-    ForAll(ty::Binder<ProgramClause<'tcx>>),\n-}\n-\n-impl Clause<'tcx> {\n-    pub fn category(self) -> ProgramClauseCategory {\n-        match self {\n-            Clause::Implies(clause) => clause.category,\n-            Clause::ForAll(clause) => clause.skip_binder().category,\n-        }\n-    }\n-}\n-\n-/// Multiple clauses.\n-pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n-\n-/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n-/// that the domain goal `D` is true if `G1...Gn` are provable. This\n-/// is equivalent to the implication `G1..Gn => D`; we usually write\n-/// it with the reverse implication operator `:-` to emphasize the way\n-/// that programs are actually solved (via backchaining, which starts\n-/// with the goal to solve and proceeds from there).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct ProgramClause<'tcx> {\n-    /// This goal will be considered true ...\n-    pub goal: DomainGoal<'tcx>,\n-\n-    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n-    pub hypotheses: Goals<'tcx>,\n-\n-    /// Useful for filtering clauses.\n-    pub category: ProgramClauseCategory,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n-pub enum ProgramClauseCategory {\n-    ImpliedBound,\n-    WellFormed,\n-    Other,\n-}\n-\n-/// A set of clauses that we assume to be true.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct Environment<'tcx> {\n-    pub clauses: Clauses<'tcx>,\n-}\n-\n-impl Environment<'tcx> {\n-    pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n-        InEnvironment { environment: self, goal }\n-    }\n-}\n-\n-/// Something (usually a goal), along with an environment.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct InEnvironment<'tcx, G> {\n-    pub environment: Environment<'tcx>,\n-    pub goal: G,\n-}\n-\n-#[derive(Clone, Debug, TypeFoldable)]\n-pub enum SelectionError<'tcx> {\n-    Unimplemented,\n-    OutputTypeParameterMismatch(\n-        ty::PolyTraitRef<'tcx>,\n-        ty::PolyTraitRef<'tcx>,\n-        ty::error::TypeError<'tcx>,\n-    ),\n-    TraitNotObjectSafe(DefId),\n-    ConstEvalFailure(ErrorHandled),\n-    Overflow,\n-}\n-\n-/// When performing resolution, it is typically the case that there\n-/// can be one of three outcomes:\n-///\n-/// - `Ok(Some(r))`: success occurred with result `r`\n-/// - `Ok(None)`: could not definitely determine anything, usually due\n-///   to inconclusive type inference.\n-/// - `Err(e)`: error `e` occurred\n-pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n-\n-/// Given the successful resolution of an obligation, the `Vtable`\n-/// indicates where the vtable comes from. Note that while we call this\n-/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n-/// runtime. `Vtable` instances just tell the compiler where to find\n-/// methods, but in generic code those methods are typically statically\n-/// dispatched -- only when an object is constructed is a `Vtable`\n-/// instance reified into an actual vtable.\n-///\n-/// For example, the vtable may be tied to a specific impl (case A),\n-/// or it may be relative to some bound that is in scope (case B).\n-///\n-/// ```\n-/// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n-/// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n-/// impl Clone for int { ... }             // Impl_3\n-///\n-/// fn foo<T:Clone>(concrete: Option<Box<int>>,\n-///                 param: T,\n-///                 mixed: Option<T>) {\n-///\n-///    // Case A: Vtable points at a specific impl. Only possible when\n-///    // type is concretely known. If the impl itself has bounded\n-///    // type parameters, Vtable will carry resolutions for those as well:\n-///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n-///\n-///    // Case B: Vtable must be provided by caller. This applies when\n-///    // type is a type parameter.\n-///    param.clone();    // VtableParam\n-///\n-///    // Case C: A mix of cases A and B.\n-///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n-/// }\n-/// ```\n-///\n-/// ### The type parameter `N`\n-///\n-/// See explanation on `VtableImplData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub enum Vtable<'tcx, N> {\n-    /// Vtable identifying a particular impl.\n-    VtableImpl(VtableImplData<'tcx, N>),\n-\n-    /// Vtable for auto trait implementations.\n-    /// This carries the information and nested obligations with regards\n-    /// to an auto implementation for a trait `Trait`. The nested obligations\n-    /// ensure the trait implementation holds for all the constituent types.\n-    VtableAutoImpl(VtableAutoImplData<N>),\n-\n-    /// Successful resolution to an obligation provided by the caller\n-    /// for some type parameter. The `Vec<N>` represents the\n-    /// obligations incurred from normalizing the where-clause (if\n-    /// any).\n-    VtableParam(Vec<N>),\n-\n-    /// Virtual calls through an object.\n-    VtableObject(VtableObjectData<'tcx, N>),\n-\n-    /// Successful resolution for a builtin trait.\n-    VtableBuiltin(VtableBuiltinData<N>),\n-\n-    /// Vtable automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n-    /// impl is generated by the compiler and does not appear in the source.\n-    VtableClosure(VtableClosureData<'tcx, N>),\n-\n-    /// Same as above, but for a function pointer type with the given signature.\n-    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n-\n-    /// Vtable automatically generated for a generator.\n-    VtableGenerator(VtableGeneratorData<'tcx, N>),\n-\n-    /// Vtable for a trait alias.\n-    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n-}\n-\n-impl<'tcx, N> Vtable<'tcx, N> {\n-    pub fn nested_obligations(self) -> Vec<N> {\n-        match self {\n-            VtableImpl(i) => i.nested,\n-            VtableParam(n) => n,\n-            VtableBuiltin(i) => i.nested,\n-            VtableAutoImpl(d) => d.nested,\n-            VtableClosure(c) => c.nested,\n-            VtableGenerator(c) => c.nested,\n-            VtableObject(d) => d.nested,\n-            VtableFnPointer(d) => d.nested,\n-            VtableTraitAlias(d) => d.nested,\n-        }\n-    }\n-\n-    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n-    where\n-        F: FnMut(N) -> M,\n-    {\n-        match self {\n-            VtableImpl(i) => VtableImpl(VtableImplData {\n-                impl_def_id: i.impl_def_id,\n-                substs: i.substs,\n-                nested: i.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n-            VtableBuiltin(i) => {\n-                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n-            }\n-            VtableObject(o) => VtableObject(VtableObjectData {\n-                upcast_trait_ref: o.upcast_trait_ref,\n-                vtable_base: o.vtable_base,\n-                nested: o.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableAutoImpl(d) => VtableAutoImpl(VtableAutoImplData {\n-                trait_def_id: d.trait_def_id,\n-                nested: d.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableClosure(c) => VtableClosure(VtableClosureData {\n-                closure_def_id: c.closure_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n-                generator_def_id: c.generator_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n-                fn_ty: p.fn_ty,\n-                nested: p.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n-                alias_def_id: d.alias_def_id,\n-                substs: d.substs,\n-                nested: d.nested.into_iter().map(f).collect(),\n-            }),\n-        }\n-    }\n-}\n-\n-/// Identifies a particular impl in the source, along with a set of\n-/// substitutions from the impl's type/lifetime parameters. The\n-/// `nested` vector corresponds to the nested obligations attached to\n-/// the impl's type parameters.\n-///\n-/// The type parameter `N` indicates the type used for \"nested\n-/// obligations\" that are required by the impl. During type-check, this\n-/// is `Obligation`, as one might expect. During codegen, however, this\n-/// is `()`, because codegen only requires a shallow resolution of an\n-/// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableImplData<'tcx, N> {\n-    pub impl_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableGeneratorData<'tcx, N> {\n-    pub generator_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the generator\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableClosureData<'tcx, N> {\n-    pub closure_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the closure\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableAutoImplData<N> {\n-    pub trait_def_id: DefId,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableBuiltinData<N> {\n-    pub nested: Vec<N>,\n-}\n-\n-/// A vtable for some object-safe trait `Foo` automatically derived\n-/// for the object type `Foo`.\n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableObjectData<'tcx, N> {\n-    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n-    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-\n-    /// The vtable is formed by concatenating together the method lists of\n-    /// the base object trait and all supertraits; this is the start of\n-    /// `upcast_trait_ref`'s methods in that vtable.\n-    pub vtable_base: usize,\n-\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableFnPointerData<'tcx, N> {\n-    pub fn_ty: Ty<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableTraitAliasData<'tcx, N> {\n-    pub alias_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-pub trait ExClauseFold<'tcx>\n-where\n-    Self: chalk_engine::context::Context + Clone,\n-{\n-    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        folder: &mut F,\n-    ) -> chalk_engine::ExClause<Self>;\n-\n-    fn visit_ex_clause_with<V: TypeVisitor<'tcx>>(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        visitor: &mut V,\n-    ) -> bool;\n-}\n-\n-pub trait ChalkContextLift<'tcx>\n-where\n-    Self: chalk_engine::context::Context + Clone,\n-{\n-    type LiftedExClause: Debug + 'tcx;\n-    type LiftedDelayedLiteral: Debug + 'tcx;\n-    type LiftedLiteral: Debug + 'tcx;\n-\n-    fn lift_ex_clause_to_tcx(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedExClause>;\n-\n-    fn lift_delayed_literal_to_tcx(\n-        ex_clause: &chalk_engine::DelayedLiteral<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedDelayedLiteral>;\n-\n-    fn lift_literal_to_tcx(\n-        ex_clause: &chalk_engine::Literal<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedLiteral>;\n-}"}, {"sha": "ac3d0049c0c7c42908e6cff2df5b90e46ea13c50", "filename": "src/librustc/traits/types/select.rs", "status": "removed", "additions": 0, "deletions": 290, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/5e7af4669f80e5f682141f050193ab679afdb4b1/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7af4669f80e5f682141f050193ab679afdb4b1/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs?ref=5e7af4669f80e5f682141f050193ab679afdb4b1", "patch": "@@ -1,290 +0,0 @@\n-//! Candidate selection. See the [rustc guide] for more information on how this works.\n-//!\n-//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html#selection\n-\n-use self::EvaluationResult::*;\n-\n-use super::{SelectionError, SelectionResult};\n-\n-use crate::dep_graph::DepNodeIndex;\n-use crate::ty::{self, TyCtxt};\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::Lock;\n-use rustc_hir::def_id::DefId;\n-\n-#[derive(Clone, Default)]\n-pub struct SelectionCache<'tcx> {\n-    pub hashmap: Lock<\n-        FxHashMap<\n-            ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n-            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>,\n-        >,\n-    >,\n-}\n-\n-impl<'tcx> SelectionCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n-\n-/// The selection process begins by considering all impls, where\n-/// clauses, and so forth that might resolve an obligation. Sometimes\n-/// we'll be able to say definitively that (e.g.) an impl does not\n-/// apply to the obligation: perhaps it is defined for `usize` but the\n-/// obligation is for `int`. In that case, we drop the impl out of the\n-/// list. But the other cases are considered *candidates*.\n-///\n-/// For selection to succeed, there must be exactly one matching\n-/// candidate. If the obligation is fully known, this is guaranteed\n-/// by coherence. However, if the obligation contains type parameters\n-/// or variables, there may be multiple such impls.\n-///\n-/// It is not a real problem if multiple matching impls exist because\n-/// of type variables - it just means the obligation isn't sufficiently\n-/// elaborated. In that case we report an ambiguity, and the caller can\n-/// try again after more type information has been gathered or report a\n-/// \"type annotations needed\" error.\n-///\n-/// However, with type parameters, this can be a real problem - type\n-/// parameters don't unify with regular types, but they *can* unify\n-/// with variables from blanket impls, and (unless we know its bounds\n-/// will always be satisfied) picking the blanket impl will be wrong\n-/// for at least *some* substitutions. To make this concrete, if we have\n-///\n-///    trait AsDebug { type Out : fmt::Debug; fn debug(self) -> Self::Out; }\n-///    impl<T: fmt::Debug> AsDebug for T {\n-///        type Out = T;\n-///        fn debug(self) -> fmt::Debug { self }\n-///    }\n-///    fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n-///\n-/// we can't just use the impl to resolve the `<T as AsDebug>` obligation\n-/// -- a type from another crate (that doesn't implement `fmt::Debug`) could\n-/// implement `AsDebug`.\n-///\n-/// Because where-clauses match the type exactly, multiple clauses can\n-/// only match if there are unresolved variables, and we can mostly just\n-/// report this ambiguity in that case. This is still a problem - we can't\n-/// *do anything* with ambiguities that involve only regions. This is issue\n-/// #21974.\n-///\n-/// If a single where-clause matches and there are no inference\n-/// variables left, then it definitely matches and we can just select\n-/// it.\n-///\n-/// In fact, we even select the where-clause when the obligation contains\n-/// inference variables. The can lead to inference making \"leaps of logic\",\n-/// for example in this situation:\n-///\n-///    pub trait Foo<T> { fn foo(&self) -> T; }\n-///    impl<T> Foo<()> for T { fn foo(&self) { } }\n-///    impl Foo<bool> for bool { fn foo(&self) -> bool { *self } }\n-///\n-///    pub fn foo<T>(t: T) where T: Foo<bool> {\n-///       println!(\"{:?}\", <T as Foo<_>>::foo(&t));\n-///    }\n-///    fn main() { foo(false); }\n-///\n-/// Here the obligation `<T as Foo<$0>>` can be matched by both the blanket\n-/// impl and the where-clause. We select the where-clause and unify `$0=bool`,\n-/// so the program prints \"false\". However, if the where-clause is omitted,\n-/// the blanket impl is selected, we unify `$0=()`, and the program prints\n-/// \"()\".\n-///\n-/// Exactly the same issues apply to projection and object candidates, except\n-/// that we can have both a projection candidate and a where-clause candidate\n-/// for the same obligation. In that case either would do (except that\n-/// different \"leaps of logic\" would occur if inference variables are\n-/// present), and we just pick the where-clause. This is, for example,\n-/// required for associated types to work in default impls, as the bounds\n-/// are visible both as projection bounds and as where-clauses from the\n-/// parameter environment.\n-#[derive(PartialEq, Eq, Debug, Clone, TypeFoldable)]\n-pub enum SelectionCandidate<'tcx> {\n-    BuiltinCandidate {\n-        /// `false` if there are no *further* obligations.\n-        has_nested: bool,\n-    },\n-    ParamCandidate(ty::PolyTraitRef<'tcx>),\n-    ImplCandidate(DefId),\n-    AutoImplCandidate(DefId),\n-\n-    /// This is a trait matching with a projected type as `Self`, and\n-    /// we found an applicable bound in the trait definition.\n-    ProjectionCandidate,\n-\n-    /// Implementation of a `Fn`-family trait by one of the anonymous types\n-    /// generated for a `||` expression.\n-    ClosureCandidate,\n-\n-    /// Implementation of a `Generator` trait by one of the anonymous types\n-    /// generated for a generator.\n-    GeneratorCandidate,\n-\n-    /// Implementation of a `Fn`-family trait by one of the anonymous\n-    /// types generated for a fn pointer type (e.g., `fn(int) -> int`)\n-    FnPointerCandidate,\n-\n-    TraitAliasCandidate(DefId),\n-\n-    ObjectCandidate,\n-\n-    BuiltinObjectCandidate,\n-\n-    BuiltinUnsizeCandidate,\n-}\n-\n-/// The result of trait evaluation. The order is important\n-/// here as the evaluation of a list is the maximum of the\n-/// evaluations.\n-///\n-/// The evaluation results are ordered:\n-///     - `EvaluatedToOk` implies `EvaluatedToOkModuloRegions`\n-///       implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n-///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n-///     - the \"union\" of evaluation results is equal to their maximum -\n-///     all the \"potential success\" candidates can potentially succeed,\n-///     so they are noops when unioned with a definite error, and within\n-///     the categories it's easy to see that the unions are correct.\n-#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq, HashStable)]\n-pub enum EvaluationResult {\n-    /// Evaluation successful.\n-    EvaluatedToOk,\n-    /// Evaluation successful, but there were unevaluated region obligations.\n-    EvaluatedToOkModuloRegions,\n-    /// Evaluation is known to be ambiguous -- it *might* hold for some\n-    /// assignment of inference variables, but it might not.\n-    ///\n-    /// While this has the same meaning as `EvaluatedToUnknown` -- we can't\n-    /// know whether this obligation holds or not -- it is the result we\n-    /// would get with an empty stack, and therefore is cacheable.\n-    EvaluatedToAmbig,\n-    /// Evaluation failed because of recursion involving inference\n-    /// variables. We are somewhat imprecise there, so we don't actually\n-    /// know the real result.\n-    ///\n-    /// This can't be trivially cached for the same reason as `EvaluatedToRecur`.\n-    EvaluatedToUnknown,\n-    /// Evaluation failed because we encountered an obligation we are already\n-    /// trying to prove on this branch.\n-    ///\n-    /// We know this branch can't be a part of a minimal proof-tree for\n-    /// the \"root\" of our cycle, because then we could cut out the recursion\n-    /// and maintain a valid proof tree. However, this does not mean\n-    /// that all the obligations on this branch do not hold -- it's possible\n-    /// that we entered this branch \"speculatively\", and that there\n-    /// might be some other way to prove this obligation that does not\n-    /// go through this cycle -- so we can't cache this as a failure.\n-    ///\n-    /// For example, suppose we have this:\n-    ///\n-    /// ```rust,ignore (pseudo-Rust)\n-    /// pub trait Trait { fn xyz(); }\n-    /// // This impl is \"useless\", but we can still have\n-    /// // an `impl Trait for SomeUnsizedType` somewhere.\n-    /// impl<T: Trait + Sized> Trait for T { fn xyz() {} }\n-    ///\n-    /// pub fn foo<T: Trait + ?Sized>() {\n-    ///     <T as Trait>::xyz();\n-    /// }\n-    /// ```\n-    ///\n-    /// When checking `foo`, we have to prove `T: Trait`. This basically\n-    /// translates into this:\n-    ///\n-    /// ```plain,ignore\n-    /// (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n-    /// ```\n-    ///\n-    /// When we try to prove it, we first go the first option, which\n-    /// recurses. This shows us that the impl is \"useless\" -- it won't\n-    /// tell us that `T: Trait` unless it already implemented `Trait`\n-    /// by some other means. However, that does not prevent `T: Trait`\n-    /// does not hold, because of the bound (which can indeed be satisfied\n-    /// by `SomeUnsizedType` from another crate).\n-    //\n-    // FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n-    // ought to convert it to an `EvaluatedToErr`, because we know\n-    // there definitely isn't a proof tree for that obligation. Not\n-    // doing so is still sound -- there isn't any proof tree, so the\n-    // branch still can't be a part of a minimal one -- but does not re-enable caching.\n-    EvaluatedToRecur,\n-    /// Evaluation failed.\n-    EvaluatedToErr,\n-}\n-\n-impl EvaluationResult {\n-    /// Returns `true` if this evaluation result is known to apply, even\n-    /// considering outlives constraints.\n-    pub fn must_apply_considering_regions(self) -> bool {\n-        self == EvaluatedToOk\n-    }\n-\n-    /// Returns `true` if this evaluation result is known to apply, ignoring\n-    /// outlives constraints.\n-    pub fn must_apply_modulo_regions(self) -> bool {\n-        self <= EvaluatedToOkModuloRegions\n-    }\n-\n-    pub fn may_apply(self) -> bool {\n-        match self {\n-            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToUnknown => {\n-                true\n-            }\n-\n-            EvaluatedToErr | EvaluatedToRecur => false,\n-        }\n-    }\n-\n-    pub fn is_stack_dependent(self) -> bool {\n-        match self {\n-            EvaluatedToUnknown | EvaluatedToRecur => true,\n-\n-            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToErr => false,\n-        }\n-    }\n-}\n-\n-/// Indicates that trait evaluation caused overflow.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n-pub struct OverflowError;\n-\n-impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n-    fn from(OverflowError: OverflowError) -> SelectionError<'tcx> {\n-        SelectionError::Overflow\n-    }\n-}\n-\n-#[derive(Clone, Default)]\n-pub struct EvaluationCache<'tcx> {\n-    pub hashmap: Lock<\n-        FxHashMap<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, WithDepNode<EvaluationResult>>,\n-    >,\n-}\n-\n-impl<'tcx> EvaluationCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n-\n-#[derive(Clone, Eq, PartialEq)]\n-pub struct WithDepNode<T> {\n-    dep_node: DepNodeIndex,\n-    cached_value: T,\n-}\n-\n-impl<T: Clone> WithDepNode<T> {\n-    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n-        WithDepNode { dep_node, cached_value }\n-    }\n-\n-    pub fn get(&self, tcx: TyCtxt<'_>) -> T {\n-        tcx.dep_graph.read_index(self.dep_node);\n-        self.cached_value.clone()\n-    }\n-}"}, {"sha": "48ed29f2bb33841cc974147d5b81218453a2cb16", "filename": "src/librustc/traits/types/structural_impls.rs", "status": "removed", "additions": 0, "deletions": 712, "changes": 712, "blob_url": "https://github.com/rust-lang/rust/blob/5e7af4669f80e5f682141f050193ab679afdb4b1/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e7af4669f80e5f682141f050193ab679afdb4b1/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs?ref=5e7af4669f80e5f682141f050193ab679afdb4b1", "patch": "@@ -1,712 +0,0 @@\n-use crate::traits;\n-use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::{self, Lift, Ty, TyCtxt};\n-use rustc_span::symbol::Symbol;\n-use smallvec::SmallVec;\n-\n-use std::collections::{BTreeMap, BTreeSet};\n-use std::fmt;\n-use std::rc::Rc;\n-\n-// Structural impls for the structs in `traits`.\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            super::VtableImpl(ref v) => write!(f, \"{:?}\", v),\n-\n-            super::VtableAutoImpl(ref t) => write!(f, \"{:?}\", t),\n-\n-            super::VtableClosure(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableGenerator(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n-\n-            super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n-\n-            super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableTraitAlias(ref d) => write!(f, \"{:?}\", d),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableImplData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.impl_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.generator_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.closure_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableBuiltinData(nested={:?})\", self.nested)\n-    }\n-}\n-\n-impl<N: fmt::Debug> fmt::Debug for traits::VtableAutoImplData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n-            self.trait_def_id, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n-            self.upcast_trait_ref, self.vtable_base, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableTraitAliasData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.alias_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::WhereClause::*;\n-\n-        // Bypass `ty::print` because it does not print out anonymous regions.\n-        // FIXME(eddyb) implement a custom `PrettyPrinter`, or move this to `ty::print`.\n-        fn write_region_name<'tcx>(\n-            r: ty::Region<'tcx>,\n-            fmt: &mut fmt::Formatter<'_>,\n-        ) -> fmt::Result {\n-            match r {\n-                ty::ReLateBound(index, br) => match br {\n-                    ty::BoundRegion::BrNamed(_, name) => write!(fmt, \"{}\", name),\n-                    ty::BoundRegion::BrAnon(var) => {\n-                        if *index == ty::INNERMOST {\n-                            write!(fmt, \"'^{}\", var)\n-                        } else {\n-                            write!(fmt, \"'^{}_{}\", index.index(), var)\n-                        }\n-                    }\n-                    _ => write!(fmt, \"'_\"),\n-                },\n-\n-                _ => write!(fmt, \"{}\", r),\n-            }\n-        }\n-\n-        match self {\n-            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n-            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n-            RegionOutlives(predicate) => {\n-                write!(fmt, \"RegionOutlives({}: \", predicate.0)?;\n-                write_region_name(predicate.1, fmt)?;\n-                write!(fmt, \")\")\n-            }\n-            TypeOutlives(predicate) => {\n-                write!(fmt, \"TypeOutlives({}: \", predicate.0)?;\n-                write_region_name(predicate.1, fmt)?;\n-                write!(fmt, \")\")\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::WellFormed::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::FromEnv::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::DomainGoal::*;\n-\n-        match self {\n-            Holds(wc) => write!(fmt, \"{}\", wc),\n-            WellFormed(wf) => write!(fmt, \"{}\", wf),\n-            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n-            Normalize(projection) => {\n-                write!(fmt, \"Normalize({} -> {})\", projection.projection_ty, projection.ty)\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Display for traits::QuantifierKind {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::QuantifierKind::*;\n-\n-        match self {\n-            Universal => write!(fmt, \"forall\"),\n-            Existential => write!(fmt, \"exists\"),\n-        }\n-    }\n-}\n-\n-/// Collect names for regions / types bound by a quantified goal / clause.\n-/// This collector does not try to do anything clever like in `ty::print`, it's just used\n-/// for debug output in tests anyway.\n-struct BoundNamesCollector {\n-    // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n-    regions: BTreeSet<Symbol>,\n-\n-    // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n-    // by the list of type parameters.\n-    types: BTreeMap<u32, Symbol>,\n-\n-    binder_index: ty::DebruijnIndex,\n-}\n-\n-impl BoundNamesCollector {\n-    fn new() -> Self {\n-        BoundNamesCollector {\n-            regions: BTreeSet::new(),\n-            types: BTreeMap::new(),\n-            binder_index: ty::INNERMOST,\n-        }\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.regions.is_empty() && self.types.is_empty()\n-    }\n-\n-    fn write_names(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut start = true;\n-        for r in &self.regions {\n-            if !start {\n-                write!(fmt, \", \")?;\n-            }\n-            start = false;\n-            write!(fmt, \"{}\", r)?;\n-        }\n-        for (_, t) in &self.types {\n-            if !start {\n-                write!(fmt, \", \")?;\n-            }\n-            start = false;\n-            write!(fmt, \"{}\", t)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n-        self.binder_index.shift_in(1);\n-        let result = t.super_visit_with(self);\n-        self.binder_index.shift_out(1);\n-        result\n-    }\n-\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        match t.kind {\n-            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n-                self.types.insert(\n-                    bound_ty.var.as_u32(),\n-                    match bound_ty.kind {\n-                        ty::BoundTyKind::Param(name) => name,\n-                        ty::BoundTyKind::Anon => {\n-                            Symbol::intern(&format!(\"^{}\", bound_ty.var.as_u32()))\n-                        }\n-                    },\n-                );\n-            }\n-\n-            _ => (),\n-        };\n-\n-        t.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        match r {\n-            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n-                ty::BoundRegion::BrNamed(_, name) => {\n-                    self.regions.insert(*name);\n-                }\n-\n-                ty::BoundRegion::BrAnon(var) => {\n-                    self.regions.insert(Symbol::intern(&format!(\"'^{}\", var)));\n-                }\n-\n-                _ => (),\n-            },\n-\n-            _ => (),\n-        };\n-\n-        r.super_visit_with(self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::GoalKind::*;\n-\n-        match self {\n-            Implies(hypotheses, goal) => {\n-                write!(fmt, \"if (\")?;\n-                for (index, hyp) in hypotheses.iter().enumerate() {\n-                    if index > 0 {\n-                        write!(fmt, \", \")?;\n-                    }\n-                    write!(fmt, \"{}\", hyp)?;\n-                }\n-                write!(fmt, \") {{ {} }}\", goal)\n-            }\n-            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n-            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n-            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n-            Quantified(qkind, goal) => {\n-                let mut collector = BoundNamesCollector::new();\n-                goal.skip_binder().visit_with(&mut collector);\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \"{}<\", qkind)?;\n-                    collector.write_names(fmt)?;\n-                    write!(fmt, \"> {{ \")?;\n-                }\n-\n-                write!(fmt, \"{}\", goal.skip_binder())?;\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \" }}\")?;\n-                }\n-\n-                Ok(())\n-            }\n-            Subtype(a, b) => write!(fmt, \"{} <: {}\", a, b),\n-            CannotProve => write!(fmt, \"CannotProve\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let traits::ProgramClause { goal, hypotheses, .. } = self;\n-        write!(fmt, \"{}\", goal)?;\n-        if !hypotheses.is_empty() {\n-            write!(fmt, \" :- \")?;\n-            for (index, condition) in hypotheses.iter().enumerate() {\n-                if index > 0 {\n-                    write!(fmt, \", \")?;\n-                }\n-                write!(fmt, \"{}\", condition)?;\n-            }\n-        }\n-        write!(fmt, \".\")\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::Clause::*;\n-\n-        match self {\n-            Implies(clause) => write!(fmt, \"{}\", clause),\n-            ForAll(clause) => {\n-                let mut collector = BoundNamesCollector::new();\n-                clause.skip_binder().visit_with(&mut collector);\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \"forall<\")?;\n-                    collector.write_names(fmt)?;\n-                    write!(fmt, \"> {{ \")?;\n-                }\n-\n-                write!(fmt, \"{}\", clause.skip_binder())?;\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \" }}\")?;\n-                }\n-\n-                Ok(())\n-            }\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Lift implementations\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n-    type Lifted = traits::SelectionError<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::Unimplemented => Some(super::Unimplemented),\n-            super::OutputTypeParameterMismatch(a, b, ref err) => {\n-                tcx.lift(&(a, b)).and_then(|(a, b)| {\n-                    tcx.lift(err).map(|err| super::OutputTypeParameterMismatch(a, b, err))\n-                })\n-            }\n-            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n-            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n-            super::Overflow => Some(super::Overflow),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n-    type Lifted = traits::ObligationCauseCode<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n-            super::MiscObligation => Some(super::MiscObligation),\n-            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n-            super::TupleElem => Some(super::TupleElem),\n-            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n-            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n-            super::BindingObligation(def_id, span) => Some(super::BindingObligation(def_id, span)),\n-            super::ReferenceOutlivesReferent(ty) => {\n-                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n-            }\n-            super::ObjectTypeBound(ty, r) => tcx\n-                .lift(&ty)\n-                .and_then(|ty| tcx.lift(&r).and_then(|r| Some(super::ObjectTypeBound(ty, r)))),\n-            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n-            super::Coercion { source, target } => {\n-                Some(super::Coercion { source: tcx.lift(&source)?, target: tcx.lift(&target)? })\n-            }\n-            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n-            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n-            super::StructInitializerSized => Some(super::StructInitializerSized),\n-            super::VariableType(id) => Some(super::VariableType(id)),\n-            super::ReturnValue(id) => Some(super::ReturnValue(id)),\n-            super::ReturnType => Some(super::ReturnType),\n-            super::SizedArgumentType => Some(super::SizedArgumentType),\n-            super::SizedReturnType => Some(super::SizedReturnType),\n-            super::SizedYieldType => Some(super::SizedYieldType),\n-            super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n-            super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n-            super::ConstSized => Some(super::ConstSized),\n-            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n-            super::SharedStatic => Some(super::SharedStatic),\n-            super::BuiltinDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n-            }\n-            super::ImplDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::ImplDerivedObligation)\n-            }\n-            super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } => Some(super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            }),\n-            super::CompareImplTypeObligation { item_name, impl_item_def_id, trait_item_def_id } => {\n-                Some(super::CompareImplTypeObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                })\n-            }\n-            super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                arm_span,\n-                source,\n-                ref prior_arms,\n-                last_ty,\n-                scrut_hir_id,\n-            }) => tcx.lift(&last_ty).map(|last_ty| {\n-                super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                    arm_span,\n-                    source,\n-                    prior_arms: prior_arms.clone(),\n-                    last_ty,\n-                    scrut_hir_id,\n-                })\n-            }),\n-            super::Pattern { span, root_ty, origin_expr } => {\n-                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n-            }\n-            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n-                Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))\n-            }\n-            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n-            super::MainFunctionType => Some(super::MainFunctionType),\n-            super::StartFunctionType => Some(super::StartFunctionType),\n-            super::IntrinsicType => Some(super::IntrinsicType),\n-            super::MethodReceiver => Some(super::MethodReceiver),\n-            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n-            super::TrivialBound => Some(super::TrivialBound),\n-            super::AssocTypeBound(ref data) => Some(super::AssocTypeBound(data.clone())),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n-    type Lifted = traits::DerivedObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n-            tcx.lift(&*self.parent_code).map(|code| traits::DerivedObligationCause {\n-                parent_trait_ref: trait_ref,\n-                parent_code: Rc::new(code),\n-            })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n-    type Lifted = traits::ObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.code).map(|code| traits::ObligationCause {\n-            span: self.span,\n-            body_id: self.body_id,\n-            code,\n-        })\n-    }\n-}\n-\n-// For codegen only.\n-impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n-    type Lifted = traits::Vtable<'tcx, ()>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self.clone() {\n-            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested })\n-                })\n-            }\n-            traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n-            traits::VtableGenerator(traits::VtableGeneratorData {\n-                generator_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::VtableGenerator(traits::VtableGeneratorData {\n-                    generator_def_id: generator_def_id,\n-                    substs: substs,\n-                    nested: nested,\n-                })\n-            }),\n-            traits::VtableClosure(traits::VtableClosureData { closure_def_id, substs, nested }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableClosure(traits::VtableClosureData {\n-                        closure_def_id,\n-                        substs,\n-                        nested,\n-                    })\n-                })\n-            }\n-            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n-                tcx.lift(&fn_ty).map(|fn_ty| {\n-                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n-                })\n-            }\n-            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n-            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n-            traits::VtableObject(traits::VtableObjectData {\n-                upcast_trait_ref,\n-                vtable_base,\n-                nested,\n-            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n-                traits::VtableObject(traits::VtableObjectData {\n-                    upcast_trait_ref: trait_ref,\n-                    vtable_base,\n-                    nested,\n-                })\n-            }),\n-            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n-                alias_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n-                    alias_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n-    type Lifted = traits::Environment<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.clauses).map(|clauses| traits::Environment { clauses })\n-    }\n-}\n-\n-impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n-    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.environment).and_then(|environment| {\n-            tcx.lift(&self.goal).map(|goal| traits::InEnvironment { environment, goal })\n-        })\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedExClause;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::DelayedLiteral<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedDelayedLiteral;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::Literal<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedLiteral;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// TypeFoldable implementations.\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    traits::QuantifierKind,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_goals(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = (**self).fold_with(folder);\n-        folder.tcx().mk_goal(v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        (**self).visit_with(visitor)\n-    }\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    traits::ProgramClauseCategory,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_clauses(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: traits::ExClauseFold<'tcx>,\n-    C::Substitution: Clone,\n-    C::RegionConstraint: Clone,\n-{\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        <C as traits::ExClauseFold>::fold_ex_clause_with(self, folder)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        <C as traits::ExClauseFold>::visit_ex_clause_with(self, visitor)\n-    }\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n-        (chalk_engine::DelayedLiteral::CannotProve)(a),\n-        (chalk_engine::DelayedLiteral::Negative)(a),\n-        (chalk_engine::DelayedLiteral::Positive)(a, b),\n-    } where\n-        C: chalk_engine::context::Context<CanonicalConstrainedSubst: TypeFoldable<'tcx>> + Clone,\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::Literal<C> {\n-        (chalk_engine::Literal::Negative)(a),\n-        (chalk_engine::Literal::Positive)(a),\n-    } where\n-        C: chalk_engine::context::Context<GoalInEnvironment: Clone + TypeFoldable<'tcx>> + Clone,\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    chalk_engine::TableIndex,\n-}"}, {"sha": "125ee316ed8870ffbd5a1b96cb18af35209b9de3", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -19,15 +19,15 @@ use crate::mir::interpret::{LitToConstError, LitToConstInput};\n use crate::mir::mono::CodegenUnit;\n use crate::session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use crate::session::CrateDisambiguator;\n-use crate::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n-use crate::traits::query::method_autoderef::MethodAutoderefStepsResult;\n-use crate::traits::query::normalize::NormalizationResult;\n-use crate::traits::query::outlives_bounds::OutlivesBound;\n use crate::traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n     CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n     CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal, NoSolution,\n };\n+use crate::traits::query::{\n+    DropckOutlivesResult, DtorckConstraint, MethodAutoderefStepsResult, NormalizationResult,\n+    OutlivesBound,\n+};\n use crate::traits::specialization_graph;\n use crate::traits::Clauses;\n use crate::traits::{self, Vtable};"}, {"sha": "53970a4aaf3151a1c040e3eafc1b9770ed519283", "filename": "src/librustc_infer/Cargo.toml", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -0,0 +1,28 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_infer\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_infer\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+fmt_macros = { path = \"../libfmt_macros\" }\n+graphviz = { path = \"../libgraphviz\" }\n+log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+rustc_attr = { path = \"../librustc_attr\" }\n+rustc = { path = \"../librustc\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+rustc_error_codes = { path = \"../librustc_error_codes\" }\n+rustc_hir = { path = \"../librustc_hir\" }\n+rustc_index = { path = \"../librustc_index\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n+rustc_session = { path = \"../librustc_session\" }\n+rustc_span = { path = \"../librustc_span\" }\n+rustc_target = { path = \"../librustc_target\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+syntax = { path = \"../libsyntax\" }"}, {"sha": "156b5a8b0b50bd593e4c581c3b6175b206d1f4ee", "filename": "src/librustc_infer/infer/at.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fat.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -27,8 +27,8 @@\n \n use super::*;\n \n-use crate::ty::relate::{Relate, TypeRelation};\n-use crate::ty::Const;\n+use rustc::ty::relate::{Relate, TypeRelation};\n+use rustc::ty::Const;\n \n pub struct At<'a, 'tcx> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,", "previous_filename": "src/librustc/infer/at.rs"}, {"sha": "ecd7281351def8766ce1b15f381baae547270667", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -10,10 +10,10 @@ use crate::infer::canonical::{\n     OriginalQueryValues,\n };\n use crate::infer::InferCtxt;\n-use crate::ty::flags::FlagComputation;\n-use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::subst::GenericArg;\n-use crate::ty::{self, BoundVar, InferConst, List, Ty, TyCtxt, TypeFlags};\n+use rustc::ty::flags::FlagComputation;\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc::ty::subst::GenericArg;\n+use rustc::ty::{self, BoundVar, InferConst, List, Ty, TyCtxt, TypeFlags};\n use std::sync::atomic::Ordering;\n \n use rustc_data_structures::fx::FxHashMap;", "previous_filename": "src/librustc/infer/canonical/canonicalizer.rs"}, {"sha": "ba019a8cf0369a67e49b4c8de12559bde2193af3", "filename": "src/librustc_infer/infer/canonical/mod.rs", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -29,12 +29,11 @@ use rustc::ty::{self, BoundVar, List};\n use rustc_index::vec::IndexVec;\n use rustc_span::source_map::Span;\n \n-pub use rustc::infer::types::canonical::*;\n+pub use rustc::infer::canonical::*;\n+use substitute::CanonicalExt;\n \n mod canonicalizer;\n-\n pub mod query_response;\n-\n mod substitute;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {", "previous_filename": "src/librustc/infer/canonical/mod.rs"}, {"sha": "f4196e576054af9fc2224d71d5abb8db8d040746", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -7,8 +7,7 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use crate::arena::ArenaAllocatable;\n-use crate::infer::canonical::substitute::substitute_value;\n+use crate::infer::canonical::substitute::{substitute_value, CanonicalExt};\n use crate::infer::canonical::{\n     Canonical, CanonicalVarValues, CanonicalizedQueryResponse, Certainty, OriginalQueryValues,\n     QueryOutlivesConstraint, QueryRegionConstraints, QueryResponse,\n@@ -19,9 +18,10 @@ use crate::infer::{InferCtxt, InferOk, InferResult};\n use crate::traits::query::{Fallible, NoSolution};\n use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::{GenericArg, GenericArgKind};\n-use crate::ty::{self, BoundVar, Ty, TyCtxt};\n+use rustc::arena::ArenaAllocatable;\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::{GenericArg, GenericArgKind};\n+use rustc::ty::{self, BoundVar, Ty, TyCtxt};\n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;", "previous_filename": "src/librustc/infer/canonical/query_response.rs"}, {"sha": "99ddedfe8815ba50941c10fb3da78b4e6822835f", "filename": "src/librustc_infer/infer/canonical/substitute.rs", "status": "renamed", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -7,27 +7,42 @@\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n use crate::infer::canonical::{Canonical, CanonicalVarValues};\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::GenericArgKind;\n-use crate::ty::{self, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::GenericArgKind;\n+use rustc::ty::{self, TyCtxt};\n \n-impl<'tcx, V> Canonical<'tcx, V> {\n+pub(super) trait CanonicalExt<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n     /// with the value given in `var_values`.\n-    pub fn substitute(&self, tcx: TyCtxt<'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    fn substitute(&self, tcx: TyCtxt<'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n     where\n-        V: TypeFoldable<'tcx>,\n-    {\n-        self.substitute_projected(tcx, var_values, |value| value)\n-    }\n+        V: TypeFoldable<'tcx>;\n \n     /// Allows one to apply a substitute to some subset of\n     /// `self.value`. Invoke `projection_fn` with `self.value` to get\n     /// a value V that is expressed in terms of the same canonical\n     /// variables bound in `self` (usually this extracts from subset\n     /// of `self`). Apply the substitution `var_values` to this value\n     /// V, replacing each of the canonical variables.\n-    pub fn substitute_projected<T>(\n+    fn substitute_projected<T>(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        var_values: &CanonicalVarValues<'tcx>,\n+        projection_fn: impl FnOnce(&V) -> &T,\n+    ) -> T\n+    where\n+        T: TypeFoldable<'tcx>;\n+}\n+\n+impl<'tcx, V> CanonicalExt<'tcx, V> for Canonical<'tcx, V> {\n+    fn substitute(&self, tcx: TyCtxt<'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V\n+    where\n+        V: TypeFoldable<'tcx>,\n+    {\n+        self.substitute_projected(tcx, var_values, |value| value)\n+    }\n+\n+    fn substitute_projected<T>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n         var_values: &CanonicalVarValues<'tcx>,", "previous_filename": "src/librustc/infer/canonical/substitute.rs"}, {"sha": "a10af56a0f0a8d02eebf5386d548bb54f022a5e1", "filename": "src/librustc_infer/infer/combine.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -33,12 +33,12 @@ use super::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use super::{InferCtxt, MiscVariable, TypeTrace};\n \n use crate::traits::{Obligation, PredicateObligations};\n-use crate::ty::error::TypeError;\n-use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, InferConst, Ty, TyCtxt};\n-use crate::ty::{IntType, UintType};\n \n+use rustc::ty::error::TypeError;\n+use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc::ty::subst::SubstsRef;\n+use rustc::ty::{self, InferConst, Ty, TyCtxt};\n+use rustc::ty::{IntType, UintType};\n use rustc_hir::def_id::DefId;\n use rustc_span::{Span, DUMMY_SP};\n use syntax::ast;", "previous_filename": "src/librustc/infer/combine.rs"}, {"sha": "c1eec6832b82663593cedf1f8628979de07ebb57", "filename": "src/librustc_infer/infer/equate.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fequate.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,10 +1,10 @@\n use super::combine::{CombineFields, RelationDir};\n use super::Subtype;\n \n-use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use crate::ty::subst::SubstsRef;\n-use crate::ty::TyVar;\n-use crate::ty::{self, Ty, TyCtxt};\n+use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc::ty::subst::SubstsRef;\n+use rustc::ty::TyVar;\n+use rustc::ty::{self, Ty, TyCtxt};\n \n use rustc_hir::def_id::DefId;\n ", "previous_filename": "src/librustc/infer/equate.rs"}, {"sha": "77119b8618f173508c50aa331a61c4e75d6a6893", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "renamed", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -49,17 +49,18 @@ use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n-use crate::hir::map;\n use crate::infer::opaque_types;\n use crate::infer::{self, SuppressRegionErrors};\n-use crate::middle::region;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::object_safety_violations;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n };\n-use crate::ty::error::TypeError;\n-use crate::ty::{\n+\n+use rustc::hir::map;\n+use rustc::middle::region;\n+use rustc::ty::error::TypeError;\n+use rustc::ty::{\n     self,\n     subst::{Subst, SubstsRef},\n     Region, Ty, TyCtxt, TypeFoldable,\n@@ -2005,7 +2006,12 @@ enum FailureCode {\n     Error0644(&'static str),\n }\n \n-impl<'tcx> ObligationCause<'tcx> {\n+trait ObligationCauseExt<'tcx> {\n+    fn as_failure_code(&self, terr: &TypeError<'tcx>) -> FailureCode;\n+    fn as_requirement_str(&self) -> &'static str;\n+}\n+\n+impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n     fn as_failure_code(&self, terr: &TypeError<'tcx>) -> FailureCode {\n         use self::FailureCode::*;\n         use crate::traits::ObligationCauseCode::*;", "previous_filename": "src/librustc/infer/error_reporting/mod.rs"}, {"sha": "c8a465654b63fbeb6785e21eabf71f66ccbe0487", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,8 +1,8 @@\n-use crate::hir::map::Map;\n use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::infer::InferCtxt;\n-use crate::ty::print::Print;\n-use crate::ty::{self, DefIdTree, Infer, Ty, TyVar};\n+use rustc::hir::map::Map;\n+use rustc::ty::print::Print;\n+use rustc::ty::{self, DefIdTree, Infer, Ty, TyVar};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace};", "previous_filename": "src/librustc/infer/error_reporting/need_type_info.rs"}, {"sha": "1a09729ef6443dde38b1e979c93e79004a01f0c4", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -3,7 +3,7 @@\n \n use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::util::common::ErrorReported;\n+use rustc::util::common::ErrorReported;\n \n use rustc_errors::struct_span_err;\n ", "previous_filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs"}, {"sha": "2ae7f4cc04f981611aa6220dc7cf96d280a7fba5", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n-use crate::hir::map::Map;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::middle::resolve_lifetime as rl;\n-use crate::ty::{self, Region, TyCtxt};\n+use rustc::hir::map::Map;\n+use rustc::middle::resolve_lifetime as rl;\n+use rustc::ty::{self, Region, TyCtxt};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::Node;", "previous_filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs"}, {"sha": "d8c314a0d2f1f67867f6786498dae06d1d0a1d43", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/mod.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,8 +1,8 @@\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError::*;\n use crate::infer::InferCtxt;\n-use crate::ty::{self, TyCtxt};\n-use crate::util::common::ErrorReported;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::util::common::ErrorReported;\n use rustc_errors::DiagnosticBuilder;\n use rustc_span::source_map::Span;\n ", "previous_filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs"}, {"sha": "b31975560530537be8ce9153aab7d24a9c14c568", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n //! Error Reporting for Anonymous Region Lifetime Errors\n //! where one region is named and the other is anonymous.\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::ty;\n+use rustc::ty;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir::{FunctionRetTy, TyKind};\n ", "previous_filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs"}, {"sha": "d88e6555af93e9a1b4b8937f8dc298899407d537", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/outlives_closure.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Foutlives_closure.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -4,8 +4,8 @@\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError::SubSupConflict;\n use crate::infer::SubregionOrigin;\n-use crate::ty::RegionKind;\n-use crate::util::common::ErrorReported;\n+use rustc::ty::RegionKind;\n+use rustc::util::common::ErrorReported;\n use rustc_hir::{Expr, ExprKind::Closure, Node};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {", "previous_filename": "src/librustc/infer/error_reporting/nice_region_error/outlives_closure.rs"}, {"sha": "57313dbab420f43cdab675f5986fec0a6c209790", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -3,10 +3,10 @@ use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::ValuePairs;\n use crate::infer::{SubregionOrigin, TypeTrace};\n use crate::traits::{ObligationCause, ObligationCauseCode};\n-use crate::ty::error::ExpectedFound;\n-use crate::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n-use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, TyCtxt};\n+use rustc::ty::error::ExpectedFound;\n+use rustc::ty::print::{FmtPrinter, Print, RegionHighlightMode};\n+use rustc::ty::subst::SubstsRef;\n+use rustc::ty::{self, TyCtxt};\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;", "previous_filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs"}, {"sha": "655e28bbd3d9204b9a4948cc0959796605094246", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -3,8 +3,8 @@\n use crate::infer::error_reporting::msg_span_from_free_region;\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use crate::ty::{BoundRegion, FreeRegion, RegionKind};\n-use crate::util::common::ErrorReported;\n+use rustc::ty::{BoundRegion, FreeRegion, RegionKind};\n+use rustc::util::common::ErrorReported;\n use rustc_errors::Applicability;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {", "previous_filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs"}, {"sha": "f8cab9f84c8417c3666d0b0510446775b3549a5a", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -4,8 +4,8 @@ use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n use crate::infer::{Subtype, ValuePairs};\n use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n-use crate::ty::Ty;\n-use crate::util::common::ErrorReported;\n+use rustc::ty::Ty;\n+use rustc::util::common::ErrorReported;\n use rustc_span::Span;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {", "previous_filename": "src/librustc/infer/error_reporting/nice_region_error/trait_impl_difference.rs"}, {"sha": "4dc9096533b843f71de8835ee557f789392993a1", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -2,7 +2,7 @@\n //! anonymous regions.\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::ty::{self, DefIdTree, Region, Ty};\n+use rustc::ty::{self, DefIdTree, Region, Ty};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::Span;", "previous_filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs"}, {"sha": "7a7cfdecbaf7dce8de3e5106eb72f50611f8ebe5", "filename": "src/librustc_infer/infer/error_reporting/note.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnote.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,8 +1,8 @@\n-use crate::infer::error_reporting::note_and_explain_region;\n+use crate::infer::error_reporting::{note_and_explain_region, ObligationCauseExt};\n use crate::infer::{self, InferCtxt, SubregionOrigin};\n-use crate::middle::region;\n-use crate::ty::error::TypeError;\n-use crate::ty::{self, Region};\n+use rustc::middle::region;\n+use rustc::ty::error::TypeError;\n+use rustc::ty::{self, Region};\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {", "previous_filename": "src/librustc/infer/error_reporting/note.rs"}, {"sha": "63dded3b43d10941c933fd5222f85980ffccbaa2", "filename": "src/librustc_infer/infer/freshen.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -31,8 +31,8 @@\n //! variable only once, and it does so as soon as it can, so it is reasonable to ask what the type\n //! inferencer knows \"so far\".\n \n-use crate::ty::fold::TypeFolder;\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::fold::TypeFolder;\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc_data_structures::fx::FxHashMap;\n ", "previous_filename": "src/librustc/infer/freshen.rs"}, {"sha": "16bf0f3d1c682915e817927bc39b4eabed691a71", "filename": "src/librustc_infer/infer/fudge.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffudge.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,5 +1,5 @@\n-use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::{self, ConstVid, FloatVid, IntVid, RegionVid, Ty, TyCtxt, TyVid};\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc::ty::{self, ConstVid, FloatVid, IntVid, RegionVid, Ty, TyCtxt, TyVid};\n \n use super::type_variable::TypeVariableOrigin;\n use super::InferCtxt;", "previous_filename": "src/librustc/infer/fudge.rs"}, {"sha": "2634d9cac3e99a6bdbb27f775198aabe4b78d32d", "filename": "src/librustc_infer/infer/glb.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fglb.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -4,8 +4,8 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::traits::ObligationCause;\n-use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n-use crate::ty::{self, Ty, TyCtxt};\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc::ty::{self, Ty, TyCtxt};\n \n /// \"Greatest lower bound\" (common subtype)\n pub struct Glb<'combine, 'infcx, 'tcx> {", "previous_filename": "src/librustc/infer/glb.rs"}, {"sha": "e7afaa5beb0a75adcc35dca489ddbfe834cc0419", "filename": "src/librustc_infer/infer/higher_ranked/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2FREADME.md?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/infer/higher_ranked/README.md"}, {"sha": "33781188a95509bd4d7b81eae080fa80ed9756e6", "filename": "src/librustc_infer/infer/higher_ranked/mod.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -5,8 +5,8 @@ use super::combine::CombineFields;\n use super::{HigherRankedType, InferCtxt, PlaceholderMap};\n \n use crate::infer::CombinedSnapshot;\n-use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n-use crate::ty::{self, Binder, TypeFoldable};\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc::ty::{self, Binder, TypeFoldable};\n \n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     pub fn higher_ranked_sub<T>(", "previous_filename": "src/librustc/infer/higher_ranked/mod.rs"}, {"sha": "42f9b3ab7709eea622c07e5eea9d7c82e6e22280", "filename": "src/librustc_infer/infer/lattice.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flattice.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -23,9 +23,9 @@ use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::InferCtxt;\n \n use crate::traits::ObligationCause;\n-use crate::ty::relate::{RelateResult, TypeRelation};\n-use crate::ty::TyVar;\n-use crate::ty::{self, Ty};\n+use rustc::ty::relate::{RelateResult, TypeRelation};\n+use rustc::ty::TyVar;\n+use rustc::ty::{self, Ty};\n \n pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;", "previous_filename": "src/librustc/infer/lattice.rs"}, {"sha": "c26b5625a90b636082a3c31001c0460cd040cd11", "filename": "src/librustc_infer/infer/lexical_region_resolve/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2FREADME.md?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/infer/lexical_region_resolve/README.md"}, {"sha": "eb52f10e40893ae07ac048e897c42fa330fc3d57", "filename": "src/librustc_infer/infer/lexical_region_resolve/graphviz.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fgraphviz.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -11,9 +11,9 @@ use graphviz as dot;\n use super::Constraint;\n use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::SubregionOrigin;\n-use crate::middle::free_region::RegionRelations;\n-use crate::middle::region;\n-use crate::ty;\n+use rustc::middle::free_region::RegionRelations;\n+use rustc::middle::region;\n+use rustc::ty;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::DefIndex;\n ", "previous_filename": "src/librustc/infer/lexical_region_resolve/graphviz.rs"}, {"sha": "0b5536219e566283adea5a981667ec06dd696a96", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -8,12 +8,12 @@ use crate::infer::region_constraints::VarInfos;\n use crate::infer::region_constraints::VerifyBound;\n use crate::infer::RegionVariableOrigin;\n use crate::infer::SubregionOrigin;\n-use crate::middle::free_region::RegionRelations;\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use crate::ty::{ReLateBound, RePlaceholder, ReScope, ReVar};\n-use crate::ty::{Region, RegionVid};\n+use rustc::middle::free_region::RegionRelations;\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n+use rustc::ty::{ReLateBound, RePlaceholder, ReScope, ReVar};\n+use rustc::ty::{Region, RegionVid};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,", "previous_filename": "src/librustc/infer/lexical_region_resolve/mod.rs"}, {"sha": "b6d20ba1f3f12f3f736e8870a16fcb7ba54d916f", "filename": "src/librustc_infer/infer/lub.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flub.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -4,8 +4,8 @@ use super::InferCtxt;\n use super::Subtype;\n \n use crate::traits::ObligationCause;\n-use crate::ty::relate::{Relate, RelateResult, TypeRelation};\n-use crate::ty::{self, Ty, TyCtxt};\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc::ty::{self, Ty, TyCtxt};\n \n /// \"Least upper bound\" (common supertype)\n pub struct Lub<'combine, 'infcx, 'tcx> {", "previous_filename": "src/librustc/infer/lub.rs"}, {"sha": "c9e58c2aa734724232dcc62822fc102d8a69003b", "filename": "src/librustc_infer/infer/mod.rs", "status": "added", "additions": 1790, "deletions": 0, "changes": 1790, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -0,0 +1,1790 @@\n+//! See the Book for more information.\n+\n+pub use self::freshen::TypeFreshener;\n+pub use self::LateBoundRegionConversionTime::*;\n+pub use self::RegionVariableOrigin::*;\n+pub use self::SubregionOrigin::*;\n+pub use self::ValuePairs::*;\n+pub use rustc::ty::IntVarValue;\n+\n+use crate::traits::{self, ObligationCause, PredicateObligations, TraitEngine};\n+\n+use rustc::infer::canonical::{Canonical, CanonicalVarValues};\n+use rustc::infer::unify_key::{ConstVarValue, ConstVariableValue};\n+use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n+use rustc::middle::free_region::RegionRelations;\n+use rustc::middle::lang_items;\n+use rustc::middle::region;\n+use rustc::session::config::BorrowckMode;\n+use rustc::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc::ty::relate::RelateResult;\n+use rustc::ty::subst::{GenericArg, InternalSubsts, SubstsRef};\n+use rustc::ty::{self, GenericParamDefKind, InferConst, Ty, TyCtxt};\n+use rustc::ty::{ConstVid, FloatVid, IntVid, TyVid};\n+\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::unify as ut;\n+use rustc_errors::DiagnosticBuilder;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::Symbol;\n+use rustc_span::Span;\n+use std::cell::{Cell, Ref, RefCell};\n+use std::collections::BTreeMap;\n+use std::fmt;\n+use syntax::ast;\n+\n+use self::combine::CombineFields;\n+use self::lexical_region_resolve::LexicalRegionResolutions;\n+use self::outlives::env::OutlivesEnvironment;\n+use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n+use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n+use self::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+\n+pub mod at;\n+pub mod canonical;\n+mod combine;\n+mod equate;\n+pub mod error_reporting;\n+mod freshen;\n+mod fudge;\n+mod glb;\n+mod higher_ranked;\n+pub mod lattice;\n+mod lexical_region_resolve;\n+mod lub;\n+pub mod nll_relate;\n+pub mod opaque_types;\n+pub mod outlives;\n+pub mod region_constraints;\n+pub mod resolve;\n+mod sub;\n+pub mod type_variable;\n+\n+pub use rustc::infer::unify_key;\n+\n+#[must_use]\n+#[derive(Debug)]\n+pub struct InferOk<'tcx, T> {\n+    pub value: T,\n+    pub obligations: PredicateObligations<'tcx>,\n+}\n+pub type InferResult<'tcx, T> = Result<InferOk<'tcx, T>, TypeError<'tcx>>;\n+\n+pub type Bound<T> = Option<T>;\n+pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n+pub type FixupResult<'tcx, T> = Result<T, FixupError<'tcx>>; // \"fixup result\"\n+\n+/// A flag that is used to suppress region errors. This is normally\n+/// false, but sometimes -- when we are doing region checks that the\n+/// NLL borrow checker will also do -- it might be set to true.\n+#[derive(Copy, Clone, Default, Debug)]\n+pub struct SuppressRegionErrors {\n+    suppressed: bool,\n+}\n+\n+impl SuppressRegionErrors {\n+    pub fn suppressed(self) -> bool {\n+        self.suppressed\n+    }\n+\n+    /// Indicates that the MIR borrowck will repeat these region\n+    /// checks, so we should ignore errors if NLL is (unconditionally)\n+    /// enabled.\n+    pub fn when_nll_is_enabled(tcx: TyCtxt<'_>) -> Self {\n+        // FIXME(Centril): Once we actually remove `::Migrate` also make\n+        // this always `true` and then proceed to eliminate the dead code.\n+        match tcx.borrowck_mode() {\n+            // If we're on Migrate mode, report AST region errors\n+            BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n+\n+            // If we're on MIR, don't report AST region errors as they should be reported by NLL\n+            BorrowckMode::Mir => SuppressRegionErrors { suppressed: true },\n+        }\n+    }\n+}\n+\n+/// This type contains all the things within `InferCtxt` that sit within a\n+/// `RefCell` and are involved with taking/rolling back snapshots. Snapshot\n+/// operations are hot enough that we want only one call to `borrow_mut` per\n+/// call to `start_snapshot` and `rollback_to`.\n+pub struct InferCtxtInner<'tcx> {\n+    /// Cache for projections. This cache is snapshotted along with the infcx.\n+    ///\n+    /// Public so that `traits::project` can use it.\n+    pub projection_cache: traits::ProjectionCache<'tcx>,\n+\n+    /// We instantiate `UnificationTable` with `bounds<Ty>` because the types\n+    /// that might instantiate a general type variable have an order,\n+    /// represented by its upper and lower bounds.\n+    type_variables: type_variable::TypeVariableTable<'tcx>,\n+\n+    /// Map from const parameter variable to the kind of const it represents.\n+    const_unification_table: ut::UnificationTable<ut::InPlace<ty::ConstVid<'tcx>>>,\n+\n+    /// Map from integral variable to the kind of integer it represents.\n+    int_unification_table: ut::UnificationTable<ut::InPlace<ty::IntVid>>,\n+\n+    /// Map from floating variable to the kind of float it represents.\n+    float_unification_table: ut::UnificationTable<ut::InPlace<ty::FloatVid>>,\n+\n+    /// Tracks the set of region variables and the constraints between them.\n+    /// This is initially `Some(_)` but when\n+    /// `resolve_regions_and_report_errors` is invoked, this gets set to `None`\n+    /// -- further attempts to perform unification, etc., may fail if new\n+    /// region constraints would've been added.\n+    region_constraints: Option<RegionConstraintCollector<'tcx>>,\n+\n+    /// A set of constraints that regionck must validate. Each\n+    /// constraint has the form `T:'a`, meaning \"some type `T` must\n+    /// outlive the lifetime 'a\". These constraints derive from\n+    /// instantiated type parameters. So if you had a struct defined\n+    /// like\n+    ///\n+    ///     struct Foo<T:'static> { ... }\n+    ///\n+    /// then in some expression `let x = Foo { ... }` it will\n+    /// instantiate the type parameter `T` with a fresh type `$0`. At\n+    /// the same time, it will record a region obligation of\n+    /// `$0:'static`. This will get checked later by regionck. (We\n+    /// can't generally check these things right away because we have\n+    /// to wait until types are resolved.)\n+    ///\n+    /// These are stored in a map keyed to the id of the innermost\n+    /// enclosing fn body / static initializer expression. This is\n+    /// because the location where the obligation was incurred can be\n+    /// relevant with respect to which sublifetime assumptions are in\n+    /// place. The reason that we store under the fn-id, and not\n+    /// something more fine-grained, is so that it is easier for\n+    /// regionck to be sure that it has found *all* the region\n+    /// obligations (otherwise, it's easy to fail to walk to a\n+    /// particular node-id).\n+    ///\n+    /// Before running `resolve_regions_and_report_errors`, the creator\n+    /// of the inference context is expected to invoke\n+    /// `process_region_obligations` (defined in `self::region_obligations`)\n+    /// for each body-id in this map, which will process the\n+    /// obligations within. This is expected to be done 'late enough'\n+    /// that all type inference variables have been bound and so forth.\n+    pub region_obligations: Vec<(hir::HirId, RegionObligation<'tcx>)>,\n+}\n+\n+impl<'tcx> InferCtxtInner<'tcx> {\n+    fn new() -> InferCtxtInner<'tcx> {\n+        InferCtxtInner {\n+            projection_cache: Default::default(),\n+            type_variables: type_variable::TypeVariableTable::new(),\n+            const_unification_table: ut::UnificationTable::new(),\n+            int_unification_table: ut::UnificationTable::new(),\n+            float_unification_table: ut::UnificationTable::new(),\n+            region_constraints: Some(RegionConstraintCollector::new()),\n+            region_obligations: vec![],\n+        }\n+    }\n+\n+    pub fn unwrap_region_constraints(&mut self) -> &mut RegionConstraintCollector<'tcx> {\n+        self.region_constraints.as_mut().expect(\"region constraints already solved\")\n+    }\n+}\n+\n+pub struct InferCtxt<'a, 'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+\n+    /// During type-checking/inference of a body, `in_progress_tables`\n+    /// contains a reference to the tables being built up, which are\n+    /// used for reading closure kinds/signatures as they are inferred,\n+    /// and for error reporting logic to read arbitrary node types.\n+    pub in_progress_tables: Option<&'a RefCell<ty::TypeckTables<'tcx>>>,\n+\n+    pub inner: RefCell<InferCtxtInner<'tcx>>,\n+\n+    /// If set, this flag causes us to skip the 'leak check' during\n+    /// higher-ranked subtyping operations. This flag is a temporary one used\n+    /// to manage the removal of the leak-check: for the time being, we still run the\n+    /// leak-check, but we issue warnings. This flag can only be set to true\n+    /// when entering a snapshot.\n+    skip_leak_check: Cell<bool>,\n+\n+    /// Once region inference is done, the values for each variable.\n+    lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n+\n+    /// Caches the results of trait selection. This cache is used\n+    /// for things that have to do with the parameters in scope.\n+    pub selection_cache: traits::SelectionCache<'tcx>,\n+\n+    /// Caches the results of trait evaluation.\n+    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n+\n+    /// the set of predicates on which errors have been reported, to\n+    /// avoid reporting the same error twice.\n+    pub reported_trait_errors: RefCell<FxHashMap<Span, Vec<ty::Predicate<'tcx>>>>,\n+\n+    pub reported_closure_mismatch: RefCell<FxHashSet<(Span, Option<Span>)>>,\n+\n+    /// When an error occurs, we want to avoid reporting \"derived\"\n+    /// errors that are due to this original failure. Normally, we\n+    /// handle this with the `err_count_on_creation` count, which\n+    /// basically just tracks how many errors were reported when we\n+    /// started type-checking a fn and checks to see if any new errors\n+    /// have been reported since then. Not great, but it works.\n+    ///\n+    /// However, when errors originated in other passes -- notably\n+    /// resolve -- this heuristic breaks down. Therefore, we have this\n+    /// auxiliary flag that one can set whenever one creates a\n+    /// type-error that is due to an error in a prior pass.\n+    ///\n+    /// Don't read this flag directly, call `is_tainted_by_errors()`\n+    /// and `set_tainted_by_errors()`.\n+    tainted_by_errors_flag: Cell<bool>,\n+\n+    /// Track how many errors were reported when this infcx is created.\n+    /// If the number of errors increases, that's also a sign (line\n+    /// `tained_by_errors`) to avoid reporting certain kinds of errors.\n+    // FIXME(matthewjasper) Merge into `tainted_by_errors_flag`\n+    err_count_on_creation: usize,\n+\n+    /// This flag is true while there is an active snapshot.\n+    in_snapshot: Cell<bool>,\n+\n+    /// What is the innermost universe we have created? Starts out as\n+    /// `UniverseIndex::root()` but grows from there as we enter\n+    /// universal quantifiers.\n+    ///\n+    /// N.B., at present, we exclude the universal quantifiers on the\n+    /// item we are type-checking, and just consider those names as\n+    /// part of the root universe. So this would only get incremented\n+    /// when we enter into a higher-ranked (`for<..>`) type or trait\n+    /// bound.\n+    universe: Cell<ty::UniverseIndex>,\n+}\n+\n+/// A map returned by `replace_bound_vars_with_placeholders()`\n+/// indicating the placeholder region that each late-bound region was\n+/// replaced with.\n+pub type PlaceholderMap<'tcx> = BTreeMap<ty::BoundRegion, ty::Region<'tcx>>;\n+\n+/// See the `error_reporting` module for more details.\n+#[derive(Clone, Debug, PartialEq, Eq, TypeFoldable)]\n+pub enum ValuePairs<'tcx> {\n+    Types(ExpectedFound<Ty<'tcx>>),\n+    Regions(ExpectedFound<ty::Region<'tcx>>),\n+    Consts(ExpectedFound<&'tcx ty::Const<'tcx>>),\n+    TraitRefs(ExpectedFound<ty::TraitRef<'tcx>>),\n+    PolyTraitRefs(ExpectedFound<ty::PolyTraitRef<'tcx>>),\n+}\n+\n+/// The trace designates the path through inference that we took to\n+/// encounter an error or subtyping constraint.\n+///\n+/// See the `error_reporting` module for more details.\n+#[derive(Clone, Debug)]\n+pub struct TypeTrace<'tcx> {\n+    cause: ObligationCause<'tcx>,\n+    values: ValuePairs<'tcx>,\n+}\n+\n+/// The origin of a `r1 <= r2` constraint.\n+///\n+/// See `error_reporting` module for more details\n+#[derive(Clone, Debug)]\n+pub enum SubregionOrigin<'tcx> {\n+    /// Arose from a subtyping relation\n+    Subtype(Box<TypeTrace<'tcx>>),\n+\n+    /// Stack-allocated closures cannot outlive innermost loop\n+    /// or function so as to ensure we only require finite stack\n+    InfStackClosure(Span),\n+\n+    /// Invocation of closure must be within its lifetime\n+    InvokeClosure(Span),\n+\n+    /// Dereference of reference must be within its lifetime\n+    DerefPointer(Span),\n+\n+    /// Closure bound must not outlive captured variables\n+    ClosureCapture(Span, hir::HirId),\n+\n+    /// Index into slice must be within its lifetime\n+    IndexSlice(Span),\n+\n+    /// When casting `&'a T` to an `&'b Trait` object,\n+    /// relating `'a` to `'b`\n+    RelateObjectBound(Span),\n+\n+    /// Some type parameter was instantiated with the given type,\n+    /// and that type must outlive some region.\n+    RelateParamBound(Span, Ty<'tcx>),\n+\n+    /// The given region parameter was instantiated with a region\n+    /// that must outlive some other region.\n+    RelateRegionParamBound(Span),\n+\n+    /// A bound placed on type parameters that states that must outlive\n+    /// the moment of their instantiation.\n+    RelateDefaultParamBound(Span, Ty<'tcx>),\n+\n+    /// Creating a pointer `b` to contents of another reference\n+    Reborrow(Span),\n+\n+    /// Creating a pointer `b` to contents of an upvar\n+    ReborrowUpvar(Span, ty::UpvarId),\n+\n+    /// Data with type `Ty<'tcx>` was borrowed\n+    DataBorrowed(Ty<'tcx>, Span),\n+\n+    /// (&'a &'b T) where a >= b\n+    ReferenceOutlivesReferent(Ty<'tcx>, Span),\n+\n+    /// Type or region parameters must be in scope.\n+    ParameterInScope(ParameterOrigin, Span),\n+\n+    /// The type T of an expression E must outlive the lifetime for E.\n+    ExprTypeIsNotInScope(Ty<'tcx>, Span),\n+\n+    /// A `ref b` whose region does not enclose the decl site\n+    BindingTypeIsNotValidAtDecl(Span),\n+\n+    /// Regions appearing in a method receiver must outlive method call\n+    CallRcvr(Span),\n+\n+    /// Regions appearing in a function argument must outlive func call\n+    CallArg(Span),\n+\n+    /// Region in return type of invoked fn must enclose call\n+    CallReturn(Span),\n+\n+    /// Operands must be in scope\n+    Operand(Span),\n+\n+    /// Region resulting from a `&` expr must enclose the `&` expr\n+    AddrOf(Span),\n+\n+    /// An auto-borrow that does not enclose the expr where it occurs\n+    AutoBorrow(Span),\n+\n+    /// Region constraint arriving from destructor safety\n+    SafeDestructor(Span),\n+\n+    /// Comparing the signature and requirements of an impl method against\n+    /// the containing trait.\n+    CompareImplMethodObligation {\n+        span: Span,\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n+}\n+\n+// `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(SubregionOrigin<'_>, 32);\n+\n+/// Places that type/region parameters can appear.\n+#[derive(Clone, Copy, Debug)]\n+pub enum ParameterOrigin {\n+    Path,               // foo::bar\n+    MethodCall,         // foo.bar() <-- parameters on impl providing bar()\n+    OverloadedOperator, // a + b when overloaded\n+    OverloadedDeref,    // *a when overloaded\n+}\n+\n+/// Times when we replace late-bound regions with variables:\n+#[derive(Clone, Copy, Debug)]\n+pub enum LateBoundRegionConversionTime {\n+    /// when a fn is called\n+    FnCall,\n+\n+    /// when two higher-ranked types are compared\n+    HigherRankedType,\n+\n+    /// when projecting an associated type\n+    AssocTypeProjection(DefId),\n+}\n+\n+/// Reasons to create a region inference variable\n+///\n+/// See `error_reporting` module for more details\n+#[derive(Copy, Clone, Debug)]\n+pub enum RegionVariableOrigin {\n+    /// Region variables created for ill-categorized reasons,\n+    /// mostly indicates places in need of refactoring\n+    MiscVariable(Span),\n+\n+    /// Regions created by a `&P` or `[...]` pattern\n+    PatternRegion(Span),\n+\n+    /// Regions created by `&` operator\n+    AddrOfRegion(Span),\n+\n+    /// Regions created as part of an autoref of a method receiver\n+    Autoref(Span),\n+\n+    /// Regions created as part of an automatic coercion\n+    Coercion(Span),\n+\n+    /// Region variables created as the values for early-bound regions\n+    EarlyBoundRegion(Span, Symbol),\n+\n+    /// Region variables created for bound regions\n+    /// in a function or method that is called\n+    LateBoundRegion(Span, ty::BoundRegion, LateBoundRegionConversionTime),\n+\n+    UpvarRegion(ty::UpvarId, Span),\n+\n+    BoundRegionInCoherence(ast::Name),\n+\n+    /// This origin is used for the inference variables that we create\n+    /// during NLL region processing.\n+    NLL(NLLRegionVariableOrigin),\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum NLLRegionVariableOrigin {\n+    /// During NLL region processing, we create variables for free\n+    /// regions that we encounter in the function signature and\n+    /// elsewhere. This origin indices we've got one of those.\n+    FreeRegion,\n+\n+    /// \"Universal\" instantiation of a higher-ranked region (e.g.,\n+    /// from a `for<'a> T` binder). Meant to represent \"any region\".\n+    Placeholder(ty::PlaceholderRegion),\n+\n+    Existential {\n+        /// If this is true, then this variable was created to represent a lifetime\n+        /// bound in a `for` binder. For example, it might have been created to\n+        /// represent the lifetime `'a` in a type like `for<'a> fn(&'a u32)`.\n+        /// Such variables are created when we are trying to figure out if there\n+        /// is any valid instantiation of `'a` that could fit into some scenario.\n+        ///\n+        /// This is used to inform error reporting: in the case that we are trying to\n+        /// determine whether there is any valid instantiation of a `'a` variable that meets\n+        /// some constraint C, we want to blame the \"source\" of that `for` type,\n+        /// rather than blaming the source of the constraint C.\n+        from_forall: bool,\n+    },\n+}\n+\n+impl NLLRegionVariableOrigin {\n+    pub fn is_universal(self) -> bool {\n+        match self {\n+            NLLRegionVariableOrigin::FreeRegion => true,\n+            NLLRegionVariableOrigin::Placeholder(..) => true,\n+            NLLRegionVariableOrigin::Existential { .. } => false,\n+        }\n+    }\n+\n+    pub fn is_existential(self) -> bool {\n+        !self.is_universal()\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum FixupError<'tcx> {\n+    UnresolvedIntTy(IntVid),\n+    UnresolvedFloatTy(FloatVid),\n+    UnresolvedTy(TyVid),\n+    UnresolvedConst(ConstVid<'tcx>),\n+}\n+\n+/// See the `region_obligations` field for more information.\n+#[derive(Clone)]\n+pub struct RegionObligation<'tcx> {\n+    pub sub_region: ty::Region<'tcx>,\n+    pub sup_type: Ty<'tcx>,\n+    pub origin: SubregionOrigin<'tcx>,\n+}\n+\n+impl<'tcx> fmt::Display for FixupError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use self::FixupError::*;\n+\n+        match *self {\n+            UnresolvedIntTy(_) => write!(\n+                f,\n+                \"cannot determine the type of this integer; \\\n+                 add a suffix to specify the type explicitly\"\n+            ),\n+            UnresolvedFloatTy(_) => write!(\n+                f,\n+                \"cannot determine the type of this number; \\\n+                 add a suffix to specify the type explicitly\"\n+            ),\n+            UnresolvedTy(_) => write!(f, \"unconstrained type\"),\n+            UnresolvedConst(_) => write!(f, \"unconstrained const value\"),\n+        }\n+    }\n+}\n+\n+/// Helper type of a temporary returned by `tcx.infer_ctxt()`.\n+/// Necessary because we can't write the following bound:\n+/// `F: for<'b, 'tcx> where 'tcx FnOnce(InferCtxt<'b, 'tcx>)`.\n+pub struct InferCtxtBuilder<'tcx> {\n+    global_tcx: TyCtxt<'tcx>,\n+    fresh_tables: Option<RefCell<ty::TypeckTables<'tcx>>>,\n+}\n+\n+pub trait TyCtxtInferExt<'tcx> {\n+    fn infer_ctxt(self) -> InferCtxtBuilder<'tcx>;\n+}\n+\n+impl TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n+    fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n+        InferCtxtBuilder { global_tcx: self, fresh_tables: None }\n+    }\n+}\n+\n+impl<'tcx> InferCtxtBuilder<'tcx> {\n+    /// Used only by `rustc_typeck` during body type-checking/inference,\n+    /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n+    pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n+        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty(Some(table_owner))));\n+        self\n+    }\n+\n+    /// Given a canonical value `C` as a starting point, create an\n+    /// inference context that contains each of the bound values\n+    /// within instantiated as a fresh variable. The `f` closure is\n+    /// invoked with the new infcx, along with the instantiated value\n+    /// `V` and a substitution `S`. This substitution `S` maps from\n+    /// the bound values in `C` to their instantiated values in `V`\n+    /// (in other words, `S(C) = V`).\n+    pub fn enter_with_canonical<T, R>(\n+        &mut self,\n+        span: Span,\n+        canonical: &Canonical<'tcx, T>,\n+        f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>, T, CanonicalVarValues<'tcx>) -> R,\n+    ) -> R\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.enter(|infcx| {\n+            let (value, subst) =\n+                infcx.instantiate_canonical_with_fresh_inference_vars(span, canonical);\n+            f(infcx, value, subst)\n+        })\n+    }\n+\n+    pub fn enter<R>(&mut self, f: impl for<'a> FnOnce(InferCtxt<'a, 'tcx>) -> R) -> R {\n+        let InferCtxtBuilder { global_tcx, ref fresh_tables } = *self;\n+        let in_progress_tables = fresh_tables.as_ref();\n+        global_tcx.enter_local(|tcx| {\n+            f(InferCtxt {\n+                tcx,\n+                in_progress_tables,\n+                inner: RefCell::new(InferCtxtInner::new()),\n+                lexical_region_resolutions: RefCell::new(None),\n+                selection_cache: Default::default(),\n+                evaluation_cache: Default::default(),\n+                reported_trait_errors: Default::default(),\n+                reported_closure_mismatch: Default::default(),\n+                tainted_by_errors_flag: Cell::new(false),\n+                err_count_on_creation: tcx.sess.err_count(),\n+                in_snapshot: Cell::new(false),\n+                skip_leak_check: Cell::new(false),\n+                universe: Cell::new(ty::UniverseIndex::ROOT),\n+            })\n+        })\n+    }\n+}\n+\n+impl<'tcx, T> InferOk<'tcx, T> {\n+    pub fn unit(self) -> InferOk<'tcx, ()> {\n+        InferOk { value: (), obligations: self.obligations }\n+    }\n+\n+    /// Extracts `value`, registering any obligations into `fulfill_cx`.\n+    pub fn into_value_registering_obligations(\n+        self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        fulfill_cx: &mut dyn TraitEngine<'tcx>,\n+    ) -> T {\n+        let InferOk { value, obligations } = self;\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(infcx, obligation);\n+        }\n+        value\n+    }\n+}\n+\n+impl<'tcx> InferOk<'tcx, ()> {\n+    pub fn into_obligations(self) -> PredicateObligations<'tcx> {\n+        self.obligations\n+    }\n+}\n+\n+#[must_use = \"once you start a snapshot, you should always consume it\"]\n+pub struct CombinedSnapshot<'a, 'tcx> {\n+    projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n+    type_snapshot: type_variable::Snapshot<'tcx>,\n+    const_snapshot: ut::Snapshot<ut::InPlace<ty::ConstVid<'tcx>>>,\n+    int_snapshot: ut::Snapshot<ut::InPlace<ty::IntVid>>,\n+    float_snapshot: ut::Snapshot<ut::InPlace<ty::FloatVid>>,\n+    region_constraints_snapshot: RegionSnapshot,\n+    region_obligations_snapshot: usize,\n+    universe: ty::UniverseIndex,\n+    was_in_snapshot: bool,\n+    was_skip_leak_check: bool,\n+    _in_progress_tables: Option<Ref<'a, ty::TypeckTables<'tcx>>>,\n+}\n+\n+impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn is_in_snapshot(&self) -> bool {\n+        self.in_snapshot.get()\n+    }\n+\n+    pub fn freshen<T: TypeFoldable<'tcx>>(&self, t: T) -> T {\n+        t.fold_with(&mut self.freshener())\n+    }\n+\n+    pub fn type_var_diverges(&'a self, ty: Ty<'_>) -> bool {\n+        match ty.kind {\n+            ty::Infer(ty::TyVar(vid)) => self.inner.borrow().type_variables.var_diverges(vid),\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n+        freshen::TypeFreshener::new(self)\n+    }\n+\n+    pub fn type_is_unconstrained_numeric(&'a self, ty: Ty<'_>) -> UnconstrainedNumeric {\n+        use rustc::ty::error::UnconstrainedNumeric::Neither;\n+        use rustc::ty::error::UnconstrainedNumeric::{UnconstrainedFloat, UnconstrainedInt};\n+        match ty.kind {\n+            ty::Infer(ty::IntVar(vid)) => {\n+                if self.inner.borrow_mut().int_unification_table.probe_value(vid).is_some() {\n+                    Neither\n+                } else {\n+                    UnconstrainedInt\n+                }\n+            }\n+            ty::Infer(ty::FloatVar(vid)) => {\n+                if self.inner.borrow_mut().float_unification_table.probe_value(vid).is_some() {\n+                    Neither\n+                } else {\n+                    UnconstrainedFloat\n+                }\n+            }\n+            _ => Neither,\n+        }\n+    }\n+\n+    pub fn unsolved_variables(&self) -> Vec<Ty<'tcx>> {\n+        let mut inner = self.inner.borrow_mut();\n+        // FIXME(const_generics): should there be an equivalent function for const variables?\n+\n+        let mut vars: Vec<Ty<'_>> = inner\n+            .type_variables\n+            .unsolved_variables()\n+            .into_iter()\n+            .map(|t| self.tcx.mk_ty_var(t))\n+            .collect();\n+        vars.extend(\n+            (0..inner.int_unification_table.len())\n+                .map(|i| ty::IntVid { index: i as u32 })\n+                .filter(|&vid| inner.int_unification_table.probe_value(vid).is_none())\n+                .map(|v| self.tcx.mk_int_var(v)),\n+        );\n+        vars.extend(\n+            (0..inner.float_unification_table.len())\n+                .map(|i| ty::FloatVid { index: i as u32 })\n+                .filter(|&vid| inner.float_unification_table.probe_value(vid).is_none())\n+                .map(|v| self.tcx.mk_float_var(v)),\n+        );\n+        vars\n+    }\n+\n+    fn combine_fields(\n+        &'a self,\n+        trace: TypeTrace<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> CombineFields<'a, 'tcx> {\n+        CombineFields {\n+            infcx: self,\n+            trace,\n+            cause: None,\n+            param_env,\n+            obligations: PredicateObligations::new(),\n+        }\n+    }\n+\n+    /// Clear the \"currently in a snapshot\" flag, invoke the closure,\n+    /// then restore the flag to its original value. This flag is a\n+    /// debugging measure designed to detect cases where we start a\n+    /// snapshot, create type variables, and register obligations\n+    /// which may involve those type variables in the fulfillment cx,\n+    /// potentially leaving \"dangling type variables\" behind.\n+    /// In such cases, an assertion will fail when attempting to\n+    /// register obligations, within a snapshot. Very useful, much\n+    /// better than grovelling through megabytes of `RUSTC_LOG` output.\n+    ///\n+    /// HOWEVER, in some cases the flag is unhelpful. In particular, we\n+    /// sometimes create a \"mini-fulfilment-cx\" in which we enroll\n+    /// obligations. As long as this fulfillment cx is fully drained\n+    /// before we return, this is not a problem, as there won't be any\n+    /// escaping obligations in the main cx. In those cases, you can\n+    /// use this function.\n+    pub fn save_and_restore_in_snapshot_flag<F, R>(&self, func: F) -> R\n+    where\n+        F: FnOnce(&Self) -> R,\n+    {\n+        let flag = self.in_snapshot.get();\n+        self.in_snapshot.set(false);\n+        let result = func(self);\n+        self.in_snapshot.set(flag);\n+        result\n+    }\n+\n+    fn start_snapshot(&self) -> CombinedSnapshot<'a, 'tcx> {\n+        debug!(\"start_snapshot()\");\n+\n+        let in_snapshot = self.in_snapshot.get();\n+        self.in_snapshot.set(true);\n+\n+        let mut inner = self.inner.borrow_mut();\n+        CombinedSnapshot {\n+            projection_cache_snapshot: inner.projection_cache.snapshot(),\n+            type_snapshot: inner.type_variables.snapshot(),\n+            const_snapshot: inner.const_unification_table.snapshot(),\n+            int_snapshot: inner.int_unification_table.snapshot(),\n+            float_snapshot: inner.float_unification_table.snapshot(),\n+            region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n+            region_obligations_snapshot: inner.region_obligations.len(),\n+            universe: self.universe(),\n+            was_in_snapshot: in_snapshot,\n+            was_skip_leak_check: self.skip_leak_check.get(),\n+            // Borrow tables \"in progress\" (i.e., during typeck)\n+            // to ban writes from within a snapshot to them.\n+            _in_progress_tables: self.in_progress_tables.map(|tables| tables.borrow()),\n+        }\n+    }\n+\n+    fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n+        debug!(\"rollback_to(cause={})\", cause);\n+        let CombinedSnapshot {\n+            projection_cache_snapshot,\n+            type_snapshot,\n+            const_snapshot,\n+            int_snapshot,\n+            float_snapshot,\n+            region_constraints_snapshot,\n+            region_obligations_snapshot,\n+            universe,\n+            was_in_snapshot,\n+            was_skip_leak_check,\n+            _in_progress_tables,\n+        } = snapshot;\n+\n+        self.in_snapshot.set(was_in_snapshot);\n+        self.universe.set(universe);\n+        self.skip_leak_check.set(was_skip_leak_check);\n+\n+        let mut inner = self.inner.borrow_mut();\n+        inner.projection_cache.rollback_to(projection_cache_snapshot);\n+        inner.type_variables.rollback_to(type_snapshot);\n+        inner.const_unification_table.rollback_to(const_snapshot);\n+        inner.int_unification_table.rollback_to(int_snapshot);\n+        inner.float_unification_table.rollback_to(float_snapshot);\n+        inner.unwrap_region_constraints().rollback_to(region_constraints_snapshot);\n+        inner.region_obligations.truncate(region_obligations_snapshot);\n+    }\n+\n+    fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n+        debug!(\"commit_from()\");\n+        let CombinedSnapshot {\n+            projection_cache_snapshot,\n+            type_snapshot,\n+            const_snapshot,\n+            int_snapshot,\n+            float_snapshot,\n+            region_constraints_snapshot,\n+            region_obligations_snapshot: _,\n+            universe: _,\n+            was_in_snapshot,\n+            was_skip_leak_check,\n+            _in_progress_tables,\n+        } = snapshot;\n+\n+        self.in_snapshot.set(was_in_snapshot);\n+        self.skip_leak_check.set(was_skip_leak_check);\n+\n+        let mut inner = self.inner.borrow_mut();\n+        inner.projection_cache.commit(projection_cache_snapshot);\n+        inner.type_variables.commit(type_snapshot);\n+        inner.const_unification_table.commit(const_snapshot);\n+        inner.int_unification_table.commit(int_snapshot);\n+        inner.float_unification_table.commit(float_snapshot);\n+        inner.unwrap_region_constraints().commit(region_constraints_snapshot);\n+    }\n+\n+    /// Executes `f` and commit the bindings.\n+    pub fn commit_unconditionally<R, F>(&self, f: F) -> R\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n+    {\n+        debug!(\"commit_unconditionally()\");\n+        let snapshot = self.start_snapshot();\n+        let r = f(&snapshot);\n+        self.commit_from(snapshot);\n+        r\n+    }\n+\n+    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`.\n+    pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E>\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> Result<T, E>,\n+    {\n+        debug!(\"commit_if_ok()\");\n+        let snapshot = self.start_snapshot();\n+        let r = f(&snapshot);\n+        debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n+        match r {\n+            Ok(_) => {\n+                self.commit_from(snapshot);\n+            }\n+            Err(_) => {\n+                self.rollback_to(\"commit_if_ok -- error\", snapshot);\n+            }\n+        }\n+        r\n+    }\n+\n+    /// Execute `f` then unroll any bindings it creates.\n+    pub fn probe<R, F>(&self, f: F) -> R\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n+    {\n+        debug!(\"probe()\");\n+        let snapshot = self.start_snapshot();\n+        let r = f(&snapshot);\n+        self.rollback_to(\"probe\", snapshot);\n+        r\n+    }\n+\n+    /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.\n+    pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n+    where\n+        F: FnOnce(&CombinedSnapshot<'a, 'tcx>) -> R,\n+    {\n+        debug!(\"probe()\");\n+        let snapshot = self.start_snapshot();\n+        let skip_leak_check = should_skip || self.skip_leak_check.get();\n+        self.skip_leak_check.set(skip_leak_check);\n+        let r = f(&snapshot);\n+        self.rollback_to(\"probe\", snapshot);\n+        r\n+    }\n+\n+    /// Scan the constraints produced since `snapshot` began and returns:\n+    ///\n+    /// - `None` -- if none of them involve \"region outlives\" constraints\n+    /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder\n+    /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders\n+    pub fn region_constraints_added_in_snapshot(\n+        &self,\n+        snapshot: &CombinedSnapshot<'a, 'tcx>,\n+    ) -> Option<bool> {\n+        self.inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n+            .region_constraints_added_in_snapshot(&snapshot.region_constraints_snapshot)\n+    }\n+\n+    pub fn add_given(&self, sub: ty::Region<'tcx>, sup: ty::RegionVid) {\n+        self.inner.borrow_mut().unwrap_region_constraints().add_given(sub, sup);\n+    }\n+\n+    pub fn can_sub<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    where\n+        T: at::ToTrace<'tcx>,\n+    {\n+        let origin = &ObligationCause::dummy();\n+        self.probe(|_| {\n+            self.at(origin, param_env).sub(a, b).map(|InferOk { obligations: _, .. }| {\n+                // Ignore obligations, since we are unrolling\n+                // everything anyway.\n+            })\n+        })\n+    }\n+\n+    pub fn can_eq<T>(&self, param_env: ty::ParamEnv<'tcx>, a: T, b: T) -> UnitResult<'tcx>\n+    where\n+        T: at::ToTrace<'tcx>,\n+    {\n+        let origin = &ObligationCause::dummy();\n+        self.probe(|_| {\n+            self.at(origin, param_env).eq(a, b).map(|InferOk { obligations: _, .. }| {\n+                // Ignore obligations, since we are unrolling\n+                // everything anyway.\n+            })\n+        })\n+    }\n+\n+    pub fn sub_regions(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) {\n+        debug!(\"sub_regions({:?} <: {:?})\", a, b);\n+        self.inner.borrow_mut().unwrap_region_constraints().make_subregion(origin, a, b);\n+    }\n+\n+    /// Require that the region `r` be equal to one of the regions in\n+    /// the set `regions`.\n+    pub fn member_constraint(\n+        &self,\n+        opaque_type_def_id: DefId,\n+        definition_span: Span,\n+        hidden_ty: Ty<'tcx>,\n+        region: ty::Region<'tcx>,\n+        in_regions: &Lrc<Vec<ty::Region<'tcx>>>,\n+    ) {\n+        debug!(\"member_constraint({:?} <: {:?})\", region, in_regions);\n+        self.inner.borrow_mut().unwrap_region_constraints().member_constraint(\n+            opaque_type_def_id,\n+            definition_span,\n+            hidden_ty,\n+            region,\n+            in_regions,\n+        );\n+    }\n+\n+    pub fn subtype_predicate(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: &ty::PolySubtypePredicate<'tcx>,\n+    ) -> Option<InferResult<'tcx, ()>> {\n+        // Subtle: it's ok to skip the binder here and resolve because\n+        // `shallow_resolve` just ignores anything that is not a type\n+        // variable, and because type variable's can't (at present, at\n+        // least) capture any of the things bound by this binder.\n+        //\n+        // NOTE(nmatsakis): really, there is no *particular* reason to do this\n+        // `shallow_resolve` here except as a micro-optimization.\n+        // Naturally I could not resist.\n+        let two_unbound_type_vars = {\n+            let a = self.shallow_resolve(predicate.skip_binder().a);\n+            let b = self.shallow_resolve(predicate.skip_binder().b);\n+            a.is_ty_var() && b.is_ty_var()\n+        };\n+\n+        if two_unbound_type_vars {\n+            // Two unbound type variables? Can't make progress.\n+            return None;\n+        }\n+\n+        Some(self.commit_if_ok(|snapshot| {\n+            let (ty::SubtypePredicate { a_is_expected, a, b }, placeholder_map) =\n+                self.replace_bound_vars_with_placeholders(predicate);\n+\n+            let ok = self.at(cause, param_env).sub_exp(a_is_expected, a, b)?;\n+\n+            self.leak_check(false, &placeholder_map, snapshot)?;\n+\n+            Ok(ok.unit())\n+        }))\n+    }\n+\n+    pub fn region_outlives_predicate(\n+        &self,\n+        cause: &traits::ObligationCause<'tcx>,\n+        predicate: &ty::PolyRegionOutlivesPredicate<'tcx>,\n+    ) -> UnitResult<'tcx> {\n+        self.commit_if_ok(|snapshot| {\n+            let (ty::OutlivesPredicate(r_a, r_b), placeholder_map) =\n+                self.replace_bound_vars_with_placeholders(predicate);\n+            let origin = SubregionOrigin::from_obligation_cause(cause, || {\n+                RelateRegionParamBound(cause.span)\n+            });\n+            self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n+            self.leak_check(false, &placeholder_map, snapshot)?;\n+            Ok(())\n+        })\n+    }\n+\n+    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n+        self.inner.borrow_mut().type_variables.new_var(self.universe(), diverging, origin)\n+    }\n+\n+    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_ty_var(self.next_ty_var_id(false, origin))\n+    }\n+\n+    pub fn next_ty_var_in_universe(\n+        &self,\n+        origin: TypeVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> Ty<'tcx> {\n+        let vid = self.inner.borrow_mut().type_variables.new_var(universe, false, origin);\n+        self.tcx.mk_ty_var(vid)\n+    }\n+\n+    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_ty_var(self.next_ty_var_id(true, origin))\n+    }\n+\n+    pub fn next_const_var(\n+        &self,\n+        ty: Ty<'tcx>,\n+        origin: ConstVariableOrigin,\n+    ) -> &'tcx ty::Const<'tcx> {\n+        self.tcx.mk_const_var(self.next_const_var_id(origin), ty)\n+    }\n+\n+    pub fn next_const_var_in_universe(\n+        &self,\n+        ty: Ty<'tcx>,\n+        origin: ConstVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> &'tcx ty::Const<'tcx> {\n+        let vid = self\n+            .inner\n+            .borrow_mut()\n+            .const_unification_table\n+            .new_key(ConstVarValue { origin, val: ConstVariableValue::Unknown { universe } });\n+        self.tcx.mk_const_var(vid, ty)\n+    }\n+\n+    pub fn next_const_var_id(&self, origin: ConstVariableOrigin) -> ConstVid<'tcx> {\n+        self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n+            origin,\n+            val: ConstVariableValue::Unknown { universe: self.universe() },\n+        })\n+    }\n+\n+    fn next_int_var_id(&self) -> IntVid {\n+        self.inner.borrow_mut().int_unification_table.new_key(None)\n+    }\n+\n+    pub fn next_int_var(&self) -> Ty<'tcx> {\n+        self.tcx.mk_int_var(self.next_int_var_id())\n+    }\n+\n+    fn next_float_var_id(&self) -> FloatVid {\n+        self.inner.borrow_mut().float_unification_table.new_key(None)\n+    }\n+\n+    pub fn next_float_var(&self) -> Ty<'tcx> {\n+        self.tcx.mk_float_var(self.next_float_var_id())\n+    }\n+\n+    /// Creates a fresh region variable with the next available index.\n+    /// The variable will be created in the maximum universe created\n+    /// thus far, allowing it to name any region created thus far.\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region<'tcx> {\n+        self.next_region_var_in_universe(origin, self.universe())\n+    }\n+\n+    /// Creates a fresh region variable with the next available index\n+    /// in the given universe; typically, you can use\n+    /// `next_region_var` and just use the maximal universe.\n+    pub fn next_region_var_in_universe(\n+        &self,\n+        origin: RegionVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> ty::Region<'tcx> {\n+        let region_var =\n+            self.inner.borrow_mut().unwrap_region_constraints().new_region_var(universe, origin);\n+        self.tcx.mk_region(ty::ReVar(region_var))\n+    }\n+\n+    /// Return the universe that the region `r` was created in.  For\n+    /// most regions (e.g., `'static`, named regions from the user,\n+    /// etc) this is the root universe U0. For inference variables or\n+    /// placeholders, however, it will return the universe which which\n+    /// they are associated.\n+    fn universe_of_region(&self, r: ty::Region<'tcx>) -> ty::UniverseIndex {\n+        self.inner.borrow_mut().unwrap_region_constraints().universe(r)\n+    }\n+\n+    /// Number of region variables created so far.\n+    pub fn num_region_vars(&self) -> usize {\n+        self.inner.borrow_mut().unwrap_region_constraints().num_region_vars()\n+    }\n+\n+    /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    pub fn next_nll_region_var(&self, origin: NLLRegionVariableOrigin) -> ty::Region<'tcx> {\n+        self.next_region_var(RegionVariableOrigin::NLL(origin))\n+    }\n+\n+    /// Just a convenient wrapper of `next_region_var` for using during NLL.\n+    pub fn next_nll_region_var_in_universe(\n+        &self,\n+        origin: NLLRegionVariableOrigin,\n+        universe: ty::UniverseIndex,\n+    ) -> ty::Region<'tcx> {\n+        self.next_region_var_in_universe(RegionVariableOrigin::NLL(origin), universe)\n+    }\n+\n+    pub fn var_for_def(&self, span: Span, param: &ty::GenericParamDef) -> GenericArg<'tcx> {\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => {\n+                // Create a region inference variable for the given\n+                // region parameter definition.\n+                self.next_region_var(EarlyBoundRegion(span, param.name)).into()\n+            }\n+            GenericParamDefKind::Type { .. } => {\n+                // Create a type inference variable for the given\n+                // type parameter definition. The substitutions are\n+                // for actual parameters that may be referred to by\n+                // the default of this type parameter, if it exists.\n+                // e.g., `struct Foo<A, B, C = (A, B)>(...);` when\n+                // used in a path such as `Foo::<T, U>::new()` will\n+                // use an inference variable for `C` with `[T, U]`\n+                // as the substitutions for the default, `(T, U)`.\n+                let ty_var_id = self.inner.borrow_mut().type_variables.new_var(\n+                    self.universe(),\n+                    false,\n+                    TypeVariableOrigin {\n+                        kind: TypeVariableOriginKind::TypeParameterDefinition(\n+                            param.name,\n+                            Some(param.def_id),\n+                        ),\n+                        span,\n+                    },\n+                );\n+\n+                self.tcx.mk_ty_var(ty_var_id).into()\n+            }\n+            GenericParamDefKind::Const { .. } => {\n+                let origin = ConstVariableOrigin {\n+                    kind: ConstVariableOriginKind::ConstParameterDefinition(param.name),\n+                    span,\n+                };\n+                let const_var_id =\n+                    self.inner.borrow_mut().const_unification_table.new_key(ConstVarValue {\n+                        origin,\n+                        val: ConstVariableValue::Unknown { universe: self.universe() },\n+                    });\n+                self.tcx.mk_const_var(const_var_id, self.tcx.type_of(param.def_id)).into()\n+            }\n+        }\n+    }\n+\n+    /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n+    /// type/region parameter to a fresh inference variable.\n+    pub fn fresh_substs_for_item(&self, span: Span, def_id: DefId) -> SubstsRef<'tcx> {\n+        InternalSubsts::for_item(self.tcx, def_id, |param, _| self.var_for_def(span, param))\n+    }\n+\n+    /// Returns `true` if errors have been reported since this infcx was\n+    /// created. This is sometimes used as a heuristic to skip\n+    /// reporting errors that often occur as a result of earlier\n+    /// errors, but where it's hard to be 100% sure (e.g., unresolved\n+    /// inference variables, regionck errors).\n+    pub fn is_tainted_by_errors(&self) -> bool {\n+        debug!(\n+            \"is_tainted_by_errors(err_count={}, err_count_on_creation={}, \\\n+             tainted_by_errors_flag={})\",\n+            self.tcx.sess.err_count(),\n+            self.err_count_on_creation,\n+            self.tainted_by_errors_flag.get()\n+        );\n+\n+        if self.tcx.sess.err_count() > self.err_count_on_creation {\n+            return true; // errors reported since this infcx was made\n+        }\n+        self.tainted_by_errors_flag.get()\n+    }\n+\n+    /// Set the \"tainted by errors\" flag to true. We call this when we\n+    /// observe an error from a prior pass.\n+    pub fn set_tainted_by_errors(&self) {\n+        debug!(\"set_tainted_by_errors()\");\n+        self.tainted_by_errors_flag.set(true)\n+    }\n+\n+    /// Process the region constraints and report any errors that\n+    /// result. After this, no more unification operations should be\n+    /// done -- or the compiler will panic -- but it is legal to use\n+    /// `resolve_vars_if_possible` as well as `fully_resolve`.\n+    pub fn resolve_regions_and_report_errors(\n+        &self,\n+        region_context: DefId,\n+        region_map: &region::ScopeTree,\n+        outlives_env: &OutlivesEnvironment<'tcx>,\n+        suppress: SuppressRegionErrors,\n+    ) {\n+        assert!(\n+            self.is_tainted_by_errors() || self.inner.borrow().region_obligations.is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.inner.borrow().region_obligations\n+        );\n+\n+        let region_rels = &RegionRelations::new(\n+            self.tcx,\n+            region_context,\n+            region_map,\n+            outlives_env.free_region_map(),\n+        );\n+        let (var_infos, data) = self\n+            .inner\n+            .borrow_mut()\n+            .region_constraints\n+            .take()\n+            .expect(\"regions already resolved\")\n+            .into_infos_and_data();\n+        let (lexical_region_resolutions, errors) =\n+            lexical_region_resolve::resolve(region_rels, var_infos, data);\n+\n+        let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n+        assert!(old_value.is_none());\n+\n+        if !self.is_tainted_by_errors() {\n+            // As a heuristic, just skip reporting region errors\n+            // altogether if other errors have been reported while\n+            // this infcx was in use.  This is totally hokey but\n+            // otherwise we have a hard time separating legit region\n+            // errors from silly ones.\n+            self.report_region_errors(region_map, &errors, suppress);\n+        }\n+    }\n+\n+    /// Obtains (and clears) the current set of region\n+    /// constraints. The inference context is still usable: further\n+    /// unifications will simply add new constraints.\n+    ///\n+    /// This method is not meant to be used with normal lexical region\n+    /// resolution. Rather, it is used in the NLL mode as a kind of\n+    /// interim hack: basically we run normal type-check and generate\n+    /// region constraints as normal, but then we take them and\n+    /// translate them into the form that the NLL solver\n+    /// understands. See the NLL module for mode details.\n+    pub fn take_and_reset_region_constraints(&self) -> RegionConstraintData<'tcx> {\n+        assert!(\n+            self.inner.borrow().region_obligations.is_empty(),\n+            \"region_obligations not empty: {:#?}\",\n+            self.inner.borrow().region_obligations\n+        );\n+\n+        self.inner.borrow_mut().unwrap_region_constraints().take_and_reset_data()\n+    }\n+\n+    /// Gives temporary access to the region constraint data.\n+    #[allow(non_camel_case_types)] // bug with impl trait\n+    pub fn with_region_constraints<R>(\n+        &self,\n+        op: impl FnOnce(&RegionConstraintData<'tcx>) -> R,\n+    ) -> R {\n+        let mut inner = self.inner.borrow_mut();\n+        op(inner.unwrap_region_constraints().data())\n+    }\n+\n+    /// Takes ownership of the list of variable regions. This implies\n+    /// that all the region constraints have already been taken, and\n+    /// hence that `resolve_regions_and_report_errors` can never be\n+    /// called. This is used only during NLL processing to \"hand off\" ownership\n+    /// of the set of region variables into the NLL region context.\n+    pub fn take_region_var_origins(&self) -> VarInfos {\n+        let (var_infos, data) = self\n+            .inner\n+            .borrow_mut()\n+            .region_constraints\n+            .take()\n+            .expect(\"regions already resolved\")\n+            .into_infos_and_data();\n+        assert!(data.is_empty());\n+        var_infos\n+    }\n+\n+    pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n+        self.resolve_vars_if_possible(&t).to_string()\n+    }\n+\n+    pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n+        let tstrs: Vec<String> = ts.iter().map(|t| self.ty_to_string(*t)).collect();\n+        format!(\"({})\", tstrs.join(\", \"))\n+    }\n+\n+    pub fn trait_ref_to_string(&self, t: &ty::TraitRef<'tcx>) -> String {\n+        self.resolve_vars_if_possible(t).print_only_trait_path().to_string()\n+    }\n+\n+    /// If `TyVar(vid)` resolves to a type, return that type. Else, return the\n+    /// universe index of `TyVar(vid)`.\n+    pub fn probe_ty_var(&self, vid: TyVid) -> Result<Ty<'tcx>, ty::UniverseIndex> {\n+        use self::type_variable::TypeVariableValue;\n+\n+        match self.inner.borrow_mut().type_variables.probe(vid) {\n+            TypeVariableValue::Known { value } => Ok(value),\n+            TypeVariableValue::Unknown { universe } => Err(universe),\n+        }\n+    }\n+\n+    /// Resolve any type variables found in `value` -- but only one\n+    /// level.  So, if the variable `?X` is bound to some type\n+    /// `Foo<?Y>`, then this would return `Foo<?Y>` (but `?Y` may\n+    /// itself be bound to a type).\n+    ///\n+    /// Useful when you only need to inspect the outermost level of\n+    /// the type and don't care about nested types (or perhaps you\n+    /// will be resolving them as well, e.g. in a loop).\n+    pub fn shallow_resolve<T>(&self, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let mut r = ShallowResolver::new(self);\n+        value.fold_with(&mut r)\n+    }\n+\n+    pub fn root_var(&self, var: ty::TyVid) -> ty::TyVid {\n+        self.inner.borrow_mut().type_variables.root_var(var)\n+    }\n+\n+    /// Where possible, replaces type/const variables in\n+    /// `value` with their final value. Note that region variables\n+    /// are unaffected. If a type/const variable has not been unified, it\n+    /// is left as is. This is an idempotent operation that does\n+    /// not affect inference state in any way and so you can do it\n+    /// at will.\n+    pub fn resolve_vars_if_possible<T>(&self, value: &T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        if !value.needs_infer() {\n+            return value.clone(); // Avoid duplicated subst-folding.\n+        }\n+        let mut r = resolve::OpportunisticVarResolver::new(self);\n+        value.fold_with(&mut r)\n+    }\n+\n+    /// Returns the first unresolved variable contained in `T`. In the\n+    /// process of visiting `T`, this will resolve (where possible)\n+    /// type variables in `T`, but it never constructs the final,\n+    /// resolved type, so it's more efficient than\n+    /// `resolve_vars_if_possible()`.\n+    pub fn unresolved_type_vars<T>(&self, value: &T) -> Option<(Ty<'tcx>, Option<Span>)>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let mut r = resolve::UnresolvedTypeFinder::new(self);\n+        value.visit_with(&mut r);\n+        r.first_unresolved\n+    }\n+\n+    pub fn probe_const_var(\n+        &self,\n+        vid: ty::ConstVid<'tcx>,\n+    ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n+        match self.inner.borrow_mut().const_unification_table.probe_value(vid).val {\n+            ConstVariableValue::Known { value } => Ok(value),\n+            ConstVariableValue::Unknown { universe } => Err(universe),\n+        }\n+    }\n+\n+    pub fn fully_resolve<T: TypeFoldable<'tcx>>(&self, value: &T) -> FixupResult<'tcx, T> {\n+        /*!\n+         * Attempts to resolve all type/region/const variables in\n+         * `value`. Region inference must have been run already (e.g.,\n+         * by calling `resolve_regions_and_report_errors`). If some\n+         * variable was never unified, an `Err` results.\n+         *\n+         * This method is idempotent, but it not typically not invoked\n+         * except during the writeback phase.\n+         */\n+\n+        resolve::fully_resolve(self, value)\n+    }\n+\n+    // [Note-Type-error-reporting]\n+    // An invariant is that anytime the expected or actual type is Error (the special\n+    // error type, meaning that an error occurred when typechecking this expression),\n+    // this is a derived error. The error cascaded from another error (that was already\n+    // reported), so it's not useful to display it to the user.\n+    // The following methods implement this logic.\n+    // They check if either the actual or expected type is Error, and don't print the error\n+    // in this case. The typechecker should only ever report type errors involving mismatched\n+    // types using one of these methods, and should not call span_err directly for such\n+    // errors.\n+\n+    pub fn type_error_struct_with_diag<M>(\n+        &self,\n+        sp: Span,\n+        mk_diag: M,\n+        actual_ty: Ty<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx>\n+    where\n+        M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n+    {\n+        let actual_ty = self.resolve_vars_if_possible(&actual_ty);\n+        debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n+\n+        // Don't report an error if actual type is `Error`.\n+        if actual_ty.references_error() {\n+            return self.tcx.sess.diagnostic().struct_dummy();\n+        }\n+\n+        mk_diag(self.ty_to_string(actual_ty))\n+    }\n+\n+    pub fn report_mismatched_types(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        err: TypeError<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let trace = TypeTrace::types(cause, true, expected, actual);\n+        self.report_and_explain_type_error(trace, &err)\n+    }\n+\n+    pub fn replace_bound_vars_with_fresh_vars<T>(\n+        &self,\n+        span: Span,\n+        lbrct: LateBoundRegionConversionTime,\n+        value: &ty::Binder<T>,\n+    ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        let fld_r = |br| self.next_region_var(LateBoundRegion(span, br, lbrct));\n+        let fld_t = |_| {\n+            self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::MiscVariable,\n+                span,\n+            })\n+        };\n+        let fld_c = |_, ty| {\n+            self.next_const_var(\n+                ty,\n+                ConstVariableOrigin { kind: ConstVariableOriginKind::MiscVariable, span },\n+            )\n+        };\n+        self.tcx.replace_bound_vars(value, fld_r, fld_t, fld_c)\n+    }\n+\n+    /// See the [`region_constraints::verify_generic_bound`] method.\n+    pub fn verify_generic_bound(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        a: ty::Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    ) {\n+        debug!(\"verify_generic_bound({:?}, {:?} <: {:?})\", kind, a, bound);\n+\n+        self.inner\n+            .borrow_mut()\n+            .unwrap_region_constraints()\n+            .verify_generic_bound(origin, kind, a, bound);\n+    }\n+\n+    pub fn type_is_copy_modulo_regions(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> bool {\n+        let ty = self.resolve_vars_if_possible(&ty);\n+\n+        // Even if the type may have no inference variables, during\n+        // type-checking closure types are in local tables only.\n+        if !self.in_progress_tables.is_some() || !ty.has_closure_types() {\n+            if !(param_env, ty).has_local_value() {\n+                return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n+            }\n+        }\n+\n+        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n+\n+        // This can get called from typeck (by euv), and `moves_by_default`\n+        // rightly refuses to work with inference variables, but\n+        // moves_by_default has a cache, which we want to use in other\n+        // cases.\n+        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n+    }\n+\n+    /// Obtains the latest type of the given closure; this may be a\n+    /// closure in the current function, in which case its\n+    /// `ClosureKind` may not yet be known.\n+    pub fn closure_kind(\n+        &self,\n+        closure_def_id: DefId,\n+        closure_substs: SubstsRef<'tcx>,\n+    ) -> Option<ty::ClosureKind> {\n+        let closure_kind_ty = closure_substs.as_closure().kind_ty(closure_def_id, self.tcx);\n+        let closure_kind_ty = self.shallow_resolve(closure_kind_ty);\n+        closure_kind_ty.to_opt_closure_kind()\n+    }\n+\n+    /// Obtains the signature of a closure. For closures, unlike\n+    /// `tcx.fn_sig(def_id)`, this method will work during the\n+    /// type-checking of the enclosing function and return the closure\n+    /// signature in its partially inferred state.\n+    pub fn closure_sig(&self, def_id: DefId, substs: SubstsRef<'tcx>) -> ty::PolyFnSig<'tcx> {\n+        let closure_sig_ty = substs.as_closure().sig_ty(def_id, self.tcx);\n+        let closure_sig_ty = self.shallow_resolve(closure_sig_ty);\n+        closure_sig_ty.fn_sig(self.tcx)\n+    }\n+\n+    /// Normalizes associated types in `value`, potentially returning\n+    /// new obligations that must further be processed.\n+    pub fn partially_normalize_associated_types_in<T>(\n+        &self,\n+        span: Span,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> InferOk<'tcx, T>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = ObligationCause::misc(span, body_id);\n+        let traits::Normalized { value, obligations } =\n+            traits::normalize(&mut selcx, param_env, cause, value);\n+        debug!(\n+            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n+            value, obligations\n+        );\n+        InferOk { value, obligations }\n+    }\n+\n+    /// Clears the selection, evaluation, and projection caches. This is useful when\n+    /// repeatedly attempting to select an `Obligation` while changing only\n+    /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing.\n+    pub fn clear_caches(&self) {\n+        self.selection_cache.clear();\n+        self.evaluation_cache.clear();\n+        self.inner.borrow_mut().projection_cache.clear();\n+    }\n+\n+    fn universe(&self) -> ty::UniverseIndex {\n+        self.universe.get()\n+    }\n+\n+    /// Creates and return a fresh universe that extends all previous\n+    /// universes. Updates `self.universe` to that new universe.\n+    pub fn create_next_universe(&self) -> ty::UniverseIndex {\n+        let u = self.universe.get().next_universe();\n+        self.universe.set(u);\n+        u\n+    }\n+}\n+\n+pub struct ShallowResolver<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+}\n+\n+impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n+    #[inline(always)]\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Self {\n+        ShallowResolver { infcx }\n+    }\n+\n+    /// If `typ` is a type variable of some kind, resolve it one level\n+    /// (but do not resolve types found in the result). If `typ` is\n+    /// not a type variable, just return it unmodified.\n+    pub fn shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+        match typ.kind {\n+            ty::Infer(ty::TyVar(v)) => {\n+                // Not entirely obvious: if `typ` is a type variable,\n+                // it can be resolved to an int/float variable, which\n+                // can then be recursively resolved, hence the\n+                // recursion. Note though that we prevent type\n+                // variables from unifying to other type variables\n+                // directly (though they may be embedded\n+                // structurally), and we prevent cycles in any case,\n+                // so this recursion should always be of very limited\n+                // depth.\n+                //\n+                // Note: if these two lines are combined into one we get\n+                // dynamic borrow errors on `self.infcx.inner`.\n+                let known = self.infcx.inner.borrow_mut().type_variables.probe(v).known();\n+                known.map(|t| self.fold_ty(t)).unwrap_or(typ)\n+            }\n+\n+            ty::Infer(ty::IntVar(v)) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .int_unification_table\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.infcx.tcx))\n+                .unwrap_or(typ),\n+\n+            ty::Infer(ty::FloatVar(v)) => self\n+                .infcx\n+                .inner\n+                .borrow_mut()\n+                .float_unification_table\n+                .probe_value(v)\n+                .map(|v| v.to_type(self.infcx.tcx))\n+                .unwrap_or(typ),\n+\n+            _ => typ,\n+        }\n+    }\n+\n+    // `resolver.shallow_resolve_changed(ty)` is equivalent to\n+    // `resolver.shallow_resolve(ty) != ty`, but more efficient. It's always\n+    // inlined, despite being large, because it has only two call sites that\n+    // are extremely hot.\n+    #[inline(always)]\n+    pub fn shallow_resolve_changed(&self, infer: ty::InferTy) -> bool {\n+        match infer {\n+            ty::TyVar(v) => {\n+                use self::type_variable::TypeVariableValue;\n+\n+                // If `inlined_probe` returns a `Known` value its `kind` never\n+                // matches `infer`.\n+                match self.infcx.inner.borrow_mut().type_variables.inlined_probe(v) {\n+                    TypeVariableValue::Unknown { .. } => false,\n+                    TypeVariableValue::Known { .. } => true,\n+                }\n+            }\n+\n+            ty::IntVar(v) => {\n+                // If inlined_probe_value returns a value it's always a\n+                // `ty::Int(_)` or `ty::UInt(_)`, which nevers matches a\n+                // `ty::Infer(_)`.\n+                self.infcx.inner.borrow_mut().int_unification_table.inlined_probe_value(v).is_some()\n+            }\n+\n+            ty::FloatVar(v) => {\n+                // If inlined_probe_value returns a value it's always a\n+                // `ty::Float(_)`, which nevers matches a `ty::Infer(_)`.\n+                //\n+                // Not `inlined_probe_value(v)` because this call site is colder.\n+                self.infcx.inner.borrow_mut().float_unification_table.probe_value(v).is_some()\n+            }\n+\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        self.shallow_resolve(ty)\n+    }\n+\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const { val: ty::ConstKind::Infer(InferConst::Var(vid)), .. } = ct {\n+            self.infcx\n+                .inner\n+                .borrow_mut()\n+                .const_unification_table\n+                .probe_value(*vid)\n+                .val\n+                .known()\n+                .unwrap_or(ct)\n+        } else {\n+            ct\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeTrace<'tcx> {\n+    pub fn span(&self) -> Span {\n+        self.cause.span\n+    }\n+\n+    pub fn types(\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+    ) -> TypeTrace<'tcx> {\n+        TypeTrace { cause: cause.clone(), values: Types(ExpectedFound::new(a_is_expected, a, b)) }\n+    }\n+\n+    pub fn dummy(tcx: TyCtxt<'tcx>) -> TypeTrace<'tcx> {\n+        TypeTrace {\n+            cause: ObligationCause::dummy(),\n+            values: Types(ExpectedFound { expected: tcx.types.err, found: tcx.types.err }),\n+        }\n+    }\n+}\n+\n+impl<'tcx> SubregionOrigin<'tcx> {\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            Subtype(ref a) => a.span(),\n+            InfStackClosure(a) => a,\n+            InvokeClosure(a) => a,\n+            DerefPointer(a) => a,\n+            ClosureCapture(a, _) => a,\n+            IndexSlice(a) => a,\n+            RelateObjectBound(a) => a,\n+            RelateParamBound(a, _) => a,\n+            RelateRegionParamBound(a) => a,\n+            RelateDefaultParamBound(a, _) => a,\n+            Reborrow(a) => a,\n+            ReborrowUpvar(a, _) => a,\n+            DataBorrowed(_, a) => a,\n+            ReferenceOutlivesReferent(_, a) => a,\n+            ParameterInScope(_, a) => a,\n+            ExprTypeIsNotInScope(_, a) => a,\n+            BindingTypeIsNotValidAtDecl(a) => a,\n+            CallRcvr(a) => a,\n+            CallArg(a) => a,\n+            CallReturn(a) => a,\n+            Operand(a) => a,\n+            AddrOf(a) => a,\n+            AutoBorrow(a) => a,\n+            SafeDestructor(a) => a,\n+            CompareImplMethodObligation { span, .. } => span,\n+        }\n+    }\n+\n+    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>, default: F) -> Self\n+    where\n+        F: FnOnce() -> Self,\n+    {\n+        match cause.code {\n+            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) => {\n+                SubregionOrigin::ReferenceOutlivesReferent(ref_type, cause.span)\n+            }\n+\n+            traits::ObligationCauseCode::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => SubregionOrigin::CompareImplMethodObligation {\n+                span: cause.span,\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            },\n+\n+            _ => default(),\n+        }\n+    }\n+}\n+\n+impl RegionVariableOrigin {\n+    pub fn span(&self) -> Span {\n+        match *self {\n+            MiscVariable(a) => a,\n+            PatternRegion(a) => a,\n+            AddrOfRegion(a) => a,\n+            Autoref(a) => a,\n+            Coercion(a) => a,\n+            EarlyBoundRegion(a, ..) => a,\n+            LateBoundRegion(a, ..) => a,\n+            BoundRegionInCoherence(_) => rustc_span::DUMMY_SP,\n+            UpvarRegion(_, a) => a,\n+            NLL(..) => bug!(\"NLL variable used with `span`\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for RegionObligation<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"RegionObligation(sub_region={:?}, sup_type={:?})\",\n+            self.sub_region, self.sup_type\n+        )\n+    }\n+}"}, {"sha": "e35b8f9c8ecd41d64d198fa1ef6c60b976ab206d", "filename": "src/librustc_infer/infer/nll_relate/mod.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fnll_relate%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -24,11 +24,11 @@\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use crate::traits::DomainGoal;\n-use crate::ty::error::TypeError;\n-use crate::ty::fold::{TypeFoldable, TypeVisitor};\n-use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use crate::ty::subst::GenericArg;\n-use crate::ty::{self, InferConst, Ty, TyCtxt};\n+use rustc::ty::error::TypeError;\n+use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n+use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc::ty::subst::GenericArg;\n+use rustc::ty::{self, InferConst, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use std::fmt::Debug;\n ", "previous_filename": "src/librustc/infer/nll_relate/mod.rs"}, {"sha": "06d45690e4134245da61bb54a76f8d2726dd27e5", "filename": "src/librustc_infer/infer/opaque_types/mod.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fopaque_types%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,12 +1,12 @@\n use crate::infer::error_reporting::{note_and_explain_free_region, note_and_explain_region};\n use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::middle::region;\n use crate::traits::{self, PredicateObligation};\n-use crate::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::free_region_map::FreeRegionRelations;\n-use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n-use crate::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n+use rustc::middle::region;\n use rustc::session::config::nightly_options;\n+use rustc::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc::ty::free_region_map::FreeRegionRelations;\n+use rustc::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n+use rustc::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, DiagnosticBuilder};", "previous_filename": "src/librustc/infer/opaque_types/mod.rs"}, {"sha": "aac6c7640ca6b953cfb4152e7dc5d220b3543925", "filename": "src/librustc_infer/infer/outlives/env.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::{GenericKind, InferCtxt};\n use crate::traits::query::outlives_bounds::{self, OutlivesBound};\n-use crate::ty::free_region_map::FreeRegionMap;\n-use crate::ty::{self, Ty};\n+use rustc::ty::free_region_map::FreeRegionMap;\n+use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_span::Span;", "previous_filename": "src/librustc/infer/outlives/env.rs"}, {"sha": "6fc72470c9fb7816a822e689ee5f57557fec7451", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/infer/outlives/mod.rs"}, {"sha": "e3790b027348ecdca282679d8e2d72d518de0a78", "filename": "src/librustc_infer/infer/outlives/obligations.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fobligations.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -63,11 +63,13 @@ use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::outlives::verify::VerifyBoundCx;\n use crate::infer::{self, GenericKind, InferCtxt, RegionObligation, SubregionOrigin, VerifyBound};\n use crate::traits::ObligationCause;\n-use crate::ty::outlives::Component;\n-use crate::ty::subst::GenericArgKind;\n-use crate::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::outlives::Component;\n+use rustc::ty::subst::GenericArgKind;\n+use rustc::ty::{self, Region, Ty, TyCtxt, TypeFoldable};\n+\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n+use smallvec::smallvec;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Registers that the given region obligation must be resolved", "previous_filename": "src/librustc/infer/outlives/obligations.rs"}, {"sha": "be6f868430d4ca0213cc025c044c014f4e3289e2", "filename": "src/librustc_infer/infer/outlives/verify.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fverify.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,11 +1,13 @@\n use crate::infer::outlives::env::RegionBoundPairs;\n use crate::infer::{GenericKind, VerifyBound};\n use crate::traits;\n-use crate::ty::subst::{InternalSubsts, Subst};\n-use crate::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst::{InternalSubsts, Subst};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::captures::Captures;\n use rustc_hir::def_id::DefId;\n \n+use smallvec::smallvec;\n+\n /// The `TypeOutlives` struct has the job of \"lowering\" a `T: 'a`\n /// obligation into a series of `'a: 'b` constraints and \"verifys\", as\n /// described on the module comment. The final constraints are emitted", "previous_filename": "src/librustc/infer/outlives/verify.rs"}, {"sha": "d789fb0de109304748ef35e75039489fa54cdac1", "filename": "src/librustc_infer/infer/region_constraints/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2FREADME.md?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/infer/region_constraints/README.md"}, {"sha": "74ffdc7a4f0872c1091a37fe3a88e978615691cd", "filename": "src/librustc_infer/infer/region_constraints/leak_check.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n use super::*;\n use crate::infer::{CombinedSnapshot, PlaceholderMap};\n-use crate::ty::error::TypeError;\n-use crate::ty::relate::RelateResult;\n+use rustc::ty::error::TypeError;\n+use rustc::ty::relate::RelateResult;\n \n impl<'tcx> RegionConstraintCollector<'tcx> {\n     /// Searches region constraints created since `snapshot` that", "previous_filename": "src/librustc/infer/region_constraints/leak_check.rs"}, {"sha": "af4e199f2880495716660112ca2bab6f49aa019a", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -6,10 +6,10 @@ use self::UndoLog::*;\n use super::unify_key;\n use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n \n-use crate::ty::ReStatic;\n-use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::{ReLateBound, ReVar};\n-use crate::ty::{Region, RegionVid};\n+use rustc::ty::ReStatic;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{ReLateBound, ReVar};\n+use rustc::ty::{Region, RegionVid};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::unify as ut;\n@@ -23,7 +23,7 @@ use std::{cmp, fmt, mem};\n \n mod leak_check;\n \n-pub use rustc::infer::types::MemberConstraint;\n+pub use rustc::infer::MemberConstraint;\n \n #[derive(Default)]\n pub struct RegionConstraintCollector<'tcx> {", "previous_filename": "src/librustc/infer/region_constraints/mod.rs"}, {"sha": "3510b927d960436d265c8235e6a7f530acc84307", "filename": "src/librustc_infer/infer/resolve.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fresolve.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{FixupError, FixupResult, InferCtxt, Span};\n-use crate::ty::fold::{TypeFolder, TypeVisitor};\n-use crate::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::fold::{TypeFolder, TypeVisitor};\n+use rustc::ty::{self, Const, InferConst, Ty, TyCtxt, TypeFoldable};\n \n ///////////////////////////////////////////////////////////////////////////\n // OPPORTUNISTIC VAR RESOLVER", "previous_filename": "src/librustc/infer/resolve.rs"}, {"sha": "2b770ced42a55838f461543a4e82d0421abfa933", "filename": "src/librustc_infer/infer/sub.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fsub.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -2,10 +2,10 @@ use super::combine::{CombineFields, RelationDir};\n use super::SubregionOrigin;\n \n use crate::traits::Obligation;\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n-use crate::ty::TyVar;\n-use crate::ty::{self, Ty, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n+use rustc::ty::TyVar;\n+use rustc::ty::{self, Ty, TyCtxt};\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.", "previous_filename": "src/librustc/infer/sub.rs"}, {"sha": "b59c5606691810841d997af8d7ca8718ff6823e5", "filename": "src/librustc_infer/infer/type_variable.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ftype_variable.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,4 +1,4 @@\n-use crate::ty::{self, Ty, TyVid};\n+use rustc::ty::{self, Ty, TyVid};\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;", "previous_filename": "src/librustc/infer/type_variable.rs"}, {"sha": "6c66ef47f33f0478eeefb10f324908691188b50f", "filename": "src/librustc_infer/lib.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Flib.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -0,0 +1,38 @@\n+//! This crates defines the trait resolution method and the type inference engine.\n+//!\n+//! - **Traits.** Trait resolution is implemented in the `traits` module.\n+//! - **Type inference.** The type inference code can be found in the `infer` module;\n+//!   this code handles low-level equality and subtyping operations. The\n+//!   type check pass in the compiler is found in the `librustc_typeck` crate.\n+//!\n+//! For more information about how rustc works, see the [rustc guide].\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(bool_to_option)]\n+#![feature(box_patterns)]\n+#![feature(box_syntax)]\n+#![feature(drain_filter)]\n+#![feature(never_type)]\n+#![feature(range_is_empty)]\n+#![feature(in_band_lifetimes)]\n+#![feature(crate_visibility_modifier)]\n+#![recursion_limit = \"512\"]\n+\n+#[macro_use]\n+extern crate rustc_macros;\n+#[cfg(target_arch = \"x86_64\")]\n+#[macro_use]\n+extern crate rustc_data_structures;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate rustc;\n+\n+pub mod infer;\n+pub mod traits;"}, {"sha": "1a4f899ac859270eeb7eedc011d249758029f111", "filename": "src/librustc_infer/traits/auto_trait.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fauto_trait.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -5,8 +5,8 @@ use super::*;\n \n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::InferCtxt;\n-use crate::ty::fold::TypeFolder;\n-use crate::ty::{Region, RegionVid};\n+use rustc::ty::fold::TypeFolder;\n+use rustc::ty::{Region, RegionVid};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n ", "previous_filename": "src/librustc/traits/auto_trait.rs"}, {"sha": "82fa683a290c5d6f7b16c602996295651e86f1ce", "filename": "src/librustc_infer/traits/chalk_fulfill.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fchalk_fulfill.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,14 +1,14 @@\n-use crate::infer::canonical::{Canonical, OriginalQueryValues};\n+use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferCtxt;\n use crate::traits::query::NoSolution;\n use crate::traits::{\n     Environment, FulfillmentError, FulfillmentErrorCode, InEnvironment, ObligationCause,\n     PredicateObligation, SelectionError, TraitEngine,\n };\n-use crate::ty::{self, Ty};\n+use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n \n-pub type CanonicalGoal<'tcx> = Canonical<'tcx, InEnvironment<'tcx, ty::Predicate<'tcx>>>;\n+pub use rustc::traits::ChalkCanonicalGoal as CanonicalGoal;\n \n pub struct FulfillmentContext<'tcx> {\n     obligations: FxHashSet<InEnvironment<'tcx, PredicateObligation<'tcx>>>,", "previous_filename": "src/librustc/traits/chalk_fulfill.rs"}, {"sha": "bd4129a4de76c56184981304c672b10fba539c0f", "filename": "src/librustc_infer/traits/codegen/mod.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fcodegen%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -3,12 +3,12 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use crate::infer::InferCtxt;\n+use crate::infer::{InferCtxt, TyCtxtInferExt};\n use crate::traits::{\n     FulfillmentContext, Obligation, ObligationCause, SelectionContext, TraitEngine, Vtable,\n };\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::{self, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::{self, TyCtxt};\n \n /// Attempts to resolve an obligation to a vtable. The result is\n /// a shallow vtable resolution, meaning that we do not", "previous_filename": "src/librustc/traits/codegen/mod.rs"}, {"sha": "43c0fbc27e620f597757360c930b5ebb44dc9000", "filename": "src/librustc_infer/traits/coherence.rs", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fcoherence.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -4,13 +4,13 @@\n //! [trait-resolution]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n //! [trait-specialization]: https://rust-lang.github.io/rustc-guide/traits/specialization.html\n \n-use crate::infer::{CombinedSnapshot, InferOk};\n+use crate::infer::{CombinedSnapshot, InferOk, TyCtxtInferExt};\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::SkipLeakCheck;\n use crate::traits::{self, Normalized, Obligation, ObligationCause, SelectionContext};\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::Subst;\n-use crate::ty::{self, Ty, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::Subst;\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;", "previous_filename": "src/librustc/traits/coherence.rs"}, {"sha": "ba1443796162fdfad330ea6ef413afc7633ad328", "filename": "src/librustc_infer/traits/engine.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fengine.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::InferCtxt;\n use crate::traits::Obligation;\n-use crate::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_hir::def_id::DefId;\n \n use super::{ChalkFulfillmentContext, FulfillmentContext, FulfillmentError};", "previous_filename": "src/librustc/traits/engine.rs"}, {"sha": "4bc8ffc3d2f43be0f5a8c35b4f5c1932edd27b88", "filename": "src/librustc_infer/traits/error_reporting/mod.rs", "status": "renamed", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -11,18 +11,17 @@ use super::{\n \n use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::infer::{self, InferCtxt};\n-use crate::mir::interpret::ErrorHandled;\n-use crate::session::DiagnosticMessageId;\n+use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n use crate::traits::object_safety_violations;\n-use crate::ty::error::ExpectedFound;\n-use crate::ty::fast_reject;\n-use crate::ty::fold::TypeFolder;\n-use crate::ty::SubtypePredicate;\n-use crate::ty::{\n+use rustc::mir::interpret::ErrorHandled;\n+use rustc::session::DiagnosticMessageId;\n+use rustc::ty::error::ExpectedFound;\n+use rustc::ty::fast_reject;\n+use rustc::ty::fold::TypeFolder;\n+use rustc::ty::SubtypePredicate;\n+use rustc::ty::{\n     self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n };\n-\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;", "previous_filename": "src/librustc/traits/error_reporting/mod.rs"}, {"sha": "87c1107bd427d6eb97567ed381ca807fd2b55ecd", "filename": "src/librustc_infer/traits/error_reporting/on_unimplemented.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -2,8 +2,8 @@ use super::{\n     ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote, PredicateObligation,\n };\n use crate::infer::InferCtxt;\n-use crate::ty::subst::Subst;\n-use crate::ty::{self, GenericParamDefKind};\n+use rustc::ty::subst::Subst;\n+use rustc::ty::{self, GenericParamDefKind};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::sym;", "previous_filename": "src/librustc/traits/error_reporting/on_unimplemented.rs"}, {"sha": "4a78bcf4a8778876b75bef57584e9242ff220ce0", "filename": "src/librustc_infer/traits/error_reporting/suggestions.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -6,8 +6,9 @@ use super::{\n use crate::infer::InferCtxt;\n use crate::traits::error_reporting::suggest_constraining_type_param;\n use crate::traits::object_safety::object_safety_violations;\n-use crate::ty::TypeckTables;\n-use crate::ty::{self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n+\n+use rustc::ty::TypeckTables;\n+use rustc::ty::{self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_errors::{\n     error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, Style,\n };", "previous_filename": "src/librustc/traits/error_reporting/suggestions.rs"}, {"sha": "6055b0e74df54c8a255a32c13393bdcb9911c9c6", "filename": "src/librustc_infer/traits/fulfill.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ffulfill.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::{InferCtxt, ShallowResolver};\n-use crate::ty::error::ExpectedFound;\n-use crate::ty::{self, ToPolyTraitRef, Ty, TypeFoldable};\n+use rustc::ty::error::ExpectedFound;\n+use rustc::ty::{self, ToPolyTraitRef, Ty, TypeFoldable};\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};", "previous_filename": "src/librustc/traits/fulfill.rs"}, {"sha": "7ab918c159e1f7fb31c04e266e0e171917be4827", "filename": "src/librustc_infer/traits/misc.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmisc.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,8 +1,9 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n+use crate::infer::TyCtxtInferExt;\n use crate::traits::{self, ObligationCause};\n-use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as hir;\n \n #[derive(Clone)]", "previous_filename": "src/librustc/traits/misc.rs"}, {"sha": "06c6d6518134893e0f7c6bb51dc836862552f9e3", "filename": "src/librustc_infer/traits/mod.rs", "status": "added", "additions": 648, "deletions": 0, "changes": 648, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -0,0 +1,648 @@\n+//! Trait Resolution. See the [rustc guide] for more information on how this works.\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n+\n+#[allow(dead_code)]\n+pub mod auto_trait;\n+mod chalk_fulfill;\n+pub mod codegen;\n+mod coherence;\n+mod engine;\n+pub mod error_reporting;\n+mod fulfill;\n+pub mod misc;\n+mod object_safety;\n+mod on_unimplemented;\n+mod project;\n+pub mod query;\n+mod select;\n+mod specialize;\n+mod structural_impls;\n+mod structural_match;\n+mod util;\n+pub mod wf;\n+\n+use crate::infer::outlives::env::OutlivesEnvironment;\n+use crate::infer::{InferCtxt, SuppressRegionErrors, TyCtxtInferExt};\n+use rustc::middle::region;\n+use rustc::ty::error::{ExpectedFound, TypeError};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::{InternalSubsts, SubstsRef};\n+use rustc::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc::util::common::ErrorReported;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use std::fmt::Debug;\n+\n+pub use self::FulfillmentErrorCode::*;\n+pub use self::ObligationCauseCode::*;\n+pub use self::SelectionError::*;\n+pub use self::Vtable::*;\n+\n+pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n+pub use self::coherence::{OrphanCheckErr, OverlapResult};\n+pub use self::engine::{TraitEngine, TraitEngineExt};\n+pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n+pub use self::object_safety::astconv_object_safety_violations;\n+pub use self::object_safety::is_vtable_safe_method;\n+pub use self::object_safety::object_safety_violations;\n+pub use self::object_safety::MethodViolationCode;\n+pub use self::object_safety::ObjectSafetyViolation;\n+pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n+pub use self::project::MismatchedProjectionTypes;\n+pub use self::project::{\n+    normalize, normalize_projection_type, normalize_to, poly_project_and_unify_type,\n+};\n+pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot, Reveal};\n+pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n+pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n+pub use self::specialize::find_associated_item;\n+pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n+pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n+pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n+pub use self::structural_match::search_for_structural_match_violation;\n+pub use self::structural_match::type_marked_structural;\n+pub use self::structural_match::NonStructuralMatchTy;\n+pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n+pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n+pub use self::util::{\n+    get_vtable_index_of_object_method, impl_is_default, impl_item_is_final,\n+    predicate_for_trait_def, upcast_choices,\n+};\n+pub use self::util::{\n+    supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n+};\n+\n+pub use self::chalk_fulfill::{\n+    CanonicalGoal as ChalkCanonicalGoal, FulfillmentContext as ChalkFulfillmentContext,\n+};\n+\n+pub use rustc::traits::*;\n+\n+/// Whether to skip the leak check, as part of a future compatibility warning step.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum SkipLeakCheck {\n+    Yes,\n+    No,\n+}\n+\n+impl SkipLeakCheck {\n+    fn is_yes(self) -> bool {\n+        self == SkipLeakCheck::Yes\n+    }\n+}\n+\n+/// The \"default\" for skip-leak-check corresponds to the current\n+/// behavior (do not skip the leak check) -- not the behavior we are\n+/// transitioning into.\n+impl Default for SkipLeakCheck {\n+    fn default() -> Self {\n+        SkipLeakCheck::No\n+    }\n+}\n+\n+/// The mode that trait queries run in.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum TraitQueryMode {\n+    // Standard/un-canonicalized queries get accurate\n+    // spans etc. passed in and hence can do reasonable\n+    // error reporting on their own.\n+    Standard,\n+    // Canonicalized queries get dummy spans and hence\n+    // must generally propagate errors to\n+    // pre-canonicalization callsites.\n+    Canonical,\n+}\n+\n+/// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n+/// which the vtable must be found. The process of finding a vtable is\n+/// called \"resolving\" the `Obligation`. This process consists of\n+/// either identifying an `impl` (e.g., `impl Eq for int`) that\n+/// provides the required vtable, or else finding a bound that is in\n+/// scope. The eventual result is usually a `Selection` (defined below).\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct Obligation<'tcx, T> {\n+    /// The reason we have to prove this thing.\n+    pub cause: ObligationCause<'tcx>,\n+\n+    /// The environment in which we should prove this thing.\n+    pub param_env: ty::ParamEnv<'tcx>,\n+\n+    /// The thing we are trying to prove.\n+    pub predicate: T,\n+\n+    /// If we started proving this as a result of trying to prove\n+    /// something else, track the total depth to ensure termination.\n+    /// If this goes over a certain threshold, we abort compilation --\n+    /// in such cases, we can not say whether or not the predicate\n+    /// holds for certain. Stupid halting problem; such a drag.\n+    pub recursion_depth: usize,\n+}\n+\n+pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n+pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n+\n+// `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PredicateObligation<'_>, 112);\n+\n+pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n+pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n+pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n+\n+pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n+\n+pub struct FulfillmentError<'tcx> {\n+    pub obligation: PredicateObligation<'tcx>,\n+    pub code: FulfillmentErrorCode<'tcx>,\n+    /// Diagnostics only: we opportunistically change the `code.span` when we encounter an\n+    /// obligation error caused by a call argument. When this is the case, we also signal that in\n+    /// this field to ensure accuracy of suggestions.\n+    pub points_at_arg_span: bool,\n+}\n+\n+#[derive(Clone)]\n+pub enum FulfillmentErrorCode<'tcx> {\n+    CodeSelectionError(SelectionError<'tcx>),\n+    CodeProjectionError(MismatchedProjectionTypes<'tcx>),\n+    CodeSubtypeError(ExpectedFound<Ty<'tcx>>, TypeError<'tcx>), // always comes from a SubtypePredicate\n+    CodeAmbiguity,\n+}\n+\n+/// Creates predicate obligations from the generic bounds.\n+pub fn predicates_for_generics<'tcx>(\n+    cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n+) -> PredicateObligations<'tcx> {\n+    util::predicates_for_generics(cause, 0, param_env, generic_bounds)\n+}\n+\n+/// Determines whether the type `ty` is known to meet `bound` and\n+/// returns true if so. Returns false if `ty` either does not meet\n+/// `bound` or is not known to meet bound (note that this is\n+/// conservative towards *no impl*, which is the opposite of the\n+/// `evaluate` methods).\n+pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    def_id: DefId,\n+    span: Span,\n+) -> bool {\n+    debug!(\n+        \"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n+        ty,\n+        infcx.tcx.def_path_str(def_id)\n+    );\n+\n+    let trait_ref = ty::TraitRef { def_id, substs: infcx.tcx.mk_substs_trait(ty, &[]) };\n+    let obligation = Obligation {\n+        param_env,\n+        cause: ObligationCause::misc(span, hir::DUMMY_HIR_ID),\n+        recursion_depth: 0,\n+        predicate: trait_ref.without_const().to_predicate(),\n+    };\n+\n+    let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n+    debug!(\n+        \"type_known_to_meet_ty={:?} bound={} => {:?}\",\n+        ty,\n+        infcx.tcx.def_path_str(def_id),\n+        result\n+    );\n+\n+    if result && (ty.has_infer_types() || ty.has_closure_types()) {\n+        // Because of inference \"guessing\", selection can sometimes claim\n+        // to succeed while the success requires a guess. To ensure\n+        // this function's result remains infallible, we must confirm\n+        // that guess. While imperfect, I believe this is sound.\n+\n+        // The handling of regions in this area of the code is terrible,\n+        // see issue #29149. We should be able to improve on this with\n+        // NLL.\n+        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+\n+        // We can use a dummy node-id here because we won't pay any mind\n+        // to region obligations that arise (there shouldn't really be any\n+        // anyhow).\n+        let cause = ObligationCause::misc(span, hir::DUMMY_HIR_ID);\n+\n+        fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n+\n+        // Note: we only assume something is `Copy` if we can\n+        // *definitively* show that it implements `Copy`. Otherwise,\n+        // assume it is move; linear is always ok.\n+        match fulfill_cx.select_all_or_error(infcx) {\n+            Ok(()) => {\n+                debug!(\n+                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n+                    ty,\n+                    infcx.tcx.def_path_str(def_id)\n+                );\n+                true\n+            }\n+            Err(e) => {\n+                debug!(\n+                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n+                    ty,\n+                    infcx.tcx.def_path_str(def_id),\n+                    e\n+                );\n+                false\n+            }\n+        }\n+    } else {\n+        result\n+    }\n+}\n+\n+fn do_normalize_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    region_context: DefId,\n+    cause: ObligationCause<'tcx>,\n+    elaborated_env: ty::ParamEnv<'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n+) -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported> {\n+    debug!(\n+        \"do_normalize_predicates(predicates={:?}, region_context={:?}, cause={:?})\",\n+        predicates, region_context, cause,\n+    );\n+    let span = cause.span;\n+    tcx.infer_ctxt().enter(|infcx| {\n+        // FIXME. We should really... do something with these region\n+        // obligations. But this call just continues the older\n+        // behavior (i.e., doesn't cause any new bugs), and it would\n+        // take some further refactoring to actually solve them. In\n+        // particular, we would have to handle implied bounds\n+        // properly, and that code is currently largely confined to\n+        // regionck (though I made some efforts to extract it\n+        // out). -nmatsakis\n+        //\n+        // @arielby: In any case, these obligations are checked\n+        // by wfcheck anyway, so I'm not sure we have to check\n+        // them here too, and we will remove this function when\n+        // we move over to lazy normalization *anyway*.\n+        let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+        let predicates =\n+            match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, &predicates) {\n+                Ok(predicates) => predicates,\n+                Err(errors) => {\n+                    infcx.report_fulfillment_errors(&errors, None, false);\n+                    return Err(ErrorReported);\n+                }\n+            };\n+\n+        debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n+\n+        let region_scope_tree = region::ScopeTree::default();\n+\n+        // We can use the `elaborated_env` here; the region code only\n+        // cares about declarations like `'a: 'b`.\n+        let outlives_env = OutlivesEnvironment::new(elaborated_env);\n+\n+        infcx.resolve_regions_and_report_errors(\n+            region_context,\n+            &region_scope_tree,\n+            &outlives_env,\n+            SuppressRegionErrors::default(),\n+        );\n+\n+        let predicates = match infcx.fully_resolve(&predicates) {\n+            Ok(predicates) => predicates,\n+            Err(fixup_err) => {\n+                // If we encounter a fixup error, it means that some type\n+                // variable wound up unconstrained. I actually don't know\n+                // if this can happen, and I certainly don't expect it to\n+                // happen often, but if it did happen it probably\n+                // represents a legitimate failure due to some kind of\n+                // unconstrained variable, and it seems better not to ICE,\n+                // all things considered.\n+                tcx.sess.span_err(span, &fixup_err.to_string());\n+                return Err(ErrorReported);\n+            }\n+        };\n+        if predicates.has_local_value() {\n+            // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n+            Err(ErrorReported)\n+        } else {\n+            Ok(predicates)\n+        }\n+    })\n+}\n+\n+// FIXME: this is gonna need to be removed ...\n+/// Normalizes the parameter environment, reporting errors if they occur.\n+pub fn normalize_param_env_or_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    region_context: DefId,\n+    unnormalized_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+) -> ty::ParamEnv<'tcx> {\n+    // I'm not wild about reporting errors here; I'd prefer to\n+    // have the errors get reported at a defined place (e.g.,\n+    // during typeck). Instead I have all parameter\n+    // environments, in effect, going through this function\n+    // and hence potentially reporting errors. This ensures of\n+    // course that we never forget to normalize (the\n+    // alternative seemed like it would involve a lot of\n+    // manual invocations of this fn -- and then we'd have to\n+    // deal with the errors at each of those sites).\n+    //\n+    // In any case, in practice, typeck constructs all the\n+    // parameter environments once for every fn as it goes,\n+    // and errors will get reported then; so after typeck we\n+    // can be sure that no errors should occur.\n+\n+    debug!(\n+        \"normalize_param_env_or_error(region_context={:?}, unnormalized_env={:?}, cause={:?})\",\n+        region_context, unnormalized_env, cause\n+    );\n+\n+    let mut predicates: Vec<_> =\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec()).collect();\n+\n+    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n+\n+    let elaborated_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        unnormalized_env.reveal,\n+        unnormalized_env.def_id,\n+    );\n+\n+    // HACK: we are trying to normalize the param-env inside *itself*. The problem is that\n+    // normalization expects its param-env to be already normalized, which means we have\n+    // a circularity.\n+    //\n+    // The way we handle this is by normalizing the param-env inside an unnormalized version\n+    // of the param-env, which means that if the param-env contains unnormalized projections,\n+    // we'll have some normalization failures. This is unfortunate.\n+    //\n+    // Lazy normalization would basically handle this by treating just the\n+    // normalizing-a-trait-ref-requires-itself cycles as evaluation failures.\n+    //\n+    // Inferred outlives bounds can create a lot of `TypeOutlives` predicates for associated\n+    // types, so to make the situation less bad, we normalize all the predicates *but*\n+    // the `TypeOutlives` predicates first inside the unnormalized parameter environment, and\n+    // then we normalize the `TypeOutlives` bounds inside the normalized parameter environment.\n+    //\n+    // This works fairly well because trait matching  does not actually care about param-env\n+    // TypeOutlives predicates - these are normally used by regionck.\n+    let outlives_predicates: Vec<_> = predicates\n+        .drain_filter(|predicate| match predicate {\n+            ty::Predicate::TypeOutlives(..) => true,\n+            _ => false,\n+        })\n+        .collect();\n+\n+    debug!(\n+        \"normalize_param_env_or_error: predicates=(non-outlives={:?}, outlives={:?})\",\n+        predicates, outlives_predicates\n+    );\n+    let non_outlives_predicates = match do_normalize_predicates(\n+        tcx,\n+        region_context,\n+        cause.clone(),\n+        elaborated_env,\n+        predicates,\n+    ) {\n+        Ok(predicates) => predicates,\n+        // An unnormalized env is better than nothing.\n+        Err(ErrorReported) => {\n+            debug!(\"normalize_param_env_or_error: errored resolving non-outlives predicates\");\n+            return elaborated_env;\n+        }\n+    };\n+\n+    debug!(\"normalize_param_env_or_error: non-outlives predicates={:?}\", non_outlives_predicates);\n+\n+    // Not sure whether it is better to include the unnormalized TypeOutlives predicates\n+    // here. I believe they should not matter, because we are ignoring TypeOutlives param-env\n+    // predicates here anyway. Keeping them here anyway because it seems safer.\n+    let outlives_env: Vec<_> =\n+        non_outlives_predicates.iter().chain(&outlives_predicates).cloned().collect();\n+    let outlives_env =\n+        ty::ParamEnv::new(tcx.intern_predicates(&outlives_env), unnormalized_env.reveal, None);\n+    let outlives_predicates = match do_normalize_predicates(\n+        tcx,\n+        region_context,\n+        cause,\n+        outlives_env,\n+        outlives_predicates,\n+    ) {\n+        Ok(predicates) => predicates,\n+        // An unnormalized env is better than nothing.\n+        Err(ErrorReported) => {\n+            debug!(\"normalize_param_env_or_error: errored resolving outlives predicates\");\n+            return elaborated_env;\n+        }\n+    };\n+    debug!(\"normalize_param_env_or_error: outlives predicates={:?}\", outlives_predicates);\n+\n+    let mut predicates = non_outlives_predicates;\n+    predicates.extend(outlives_predicates);\n+    debug!(\"normalize_param_env_or_error: final predicates={:?}\", predicates);\n+    ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        unnormalized_env.reveal,\n+        unnormalized_env.def_id,\n+    )\n+}\n+\n+pub fn fully_normalize<'a, 'tcx, T>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    mut fulfill_cx: FulfillmentContext<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    value: &T,\n+) -> Result<T, Vec<FulfillmentError<'tcx>>>\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n+    let selcx = &mut SelectionContext::new(infcx);\n+    let Normalized { value: normalized_value, obligations } =\n+        project::normalize(selcx, param_env, cause, value);\n+    debug!(\n+        \"fully_normalize: normalized_value={:?} obligations={:?}\",\n+        normalized_value, obligations\n+    );\n+    for obligation in obligations {\n+        fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n+    }\n+\n+    debug!(\"fully_normalize: select_all_or_error start\");\n+    fulfill_cx.select_all_or_error(infcx)?;\n+    debug!(\"fully_normalize: select_all_or_error complete\");\n+    let resolved_value = infcx.resolve_vars_if_possible(&normalized_value);\n+    debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n+    Ok(resolved_value)\n+}\n+\n+/// Normalizes the predicates and checks whether they hold in an empty\n+/// environment. If this returns false, then either normalize\n+/// encountered an error or one of the predicates did not hold. Used\n+/// when creating vtables to check for unsatisfiable methods.\n+pub fn normalize_and_test_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n+) -> bool {\n+    debug!(\"normalize_and_test_predicates(predicates={:?})\", predicates);\n+\n+    let result = tcx.infer_ctxt().enter(|infcx| {\n+        let param_env = ty::ParamEnv::reveal_all();\n+        let mut selcx = SelectionContext::new(&infcx);\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let cause = ObligationCause::dummy();\n+        let Normalized { value: predicates, obligations } =\n+            normalize(&mut selcx, param_env, cause.clone(), &predicates);\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+        for predicate in predicates {\n+            let obligation = Obligation::new(cause.clone(), param_env, predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+\n+        fulfill_cx.select_all_or_error(&infcx).is_ok()\n+    });\n+    debug!(\"normalize_and_test_predicates(predicates={:?}) = {:?}\", predicates, result);\n+    result\n+}\n+\n+fn substitute_normalize_and_test_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (DefId, SubstsRef<'tcx>),\n+) -> bool {\n+    debug!(\"substitute_normalize_and_test_predicates(key={:?})\", key);\n+\n+    let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n+    let result = normalize_and_test_predicates(tcx, predicates);\n+\n+    debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\", key, result);\n+    result\n+}\n+\n+/// Given a trait `trait_ref`, iterates the vtable entries\n+/// that come from `trait_ref`, including its supertraits.\n+#[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n+fn vtable_methods<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n+    debug!(\"vtable_methods({:?})\", trait_ref);\n+\n+    tcx.arena.alloc_from_iter(supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n+        let trait_methods = tcx\n+            .associated_items(trait_ref.def_id())\n+            .iter()\n+            .filter(|item| item.kind == ty::AssocKind::Method);\n+\n+        // Now list each method's DefId and InternalSubsts (for within its trait).\n+        // If the method can never be called from this object, produce None.\n+        trait_methods.map(move |trait_method| {\n+            debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n+            let def_id = trait_method.def_id;\n+\n+            // Some methods cannot be called on an object; skip those.\n+            if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n+                debug!(\"vtable_methods: not vtable safe\");\n+                return None;\n+            }\n+\n+            // The method may have some early-bound lifetimes; add regions for those.\n+            let substs = trait_ref.map_bound(|trait_ref| {\n+                InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+                    GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n+                        trait_ref.substs[param.index as usize]\n+                    }\n+                })\n+            });\n+\n+            // The trait type may have higher-ranked lifetimes in it;\n+            // erase them if they appear, so that we get the type\n+            // at some particular call site.\n+            let substs =\n+                tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &substs);\n+\n+            // It's possible that the method relies on where-clauses that\n+            // do not hold for this particular set of type parameters.\n+            // Note that this method could then never be called, so we\n+            // do not want to try and codegen it, in that case (see #23435).\n+            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n+                debug!(\"vtable_methods: predicates do not hold\");\n+                return None;\n+            }\n+\n+            Some((def_id, substs))\n+        })\n+    }))\n+}\n+\n+impl<'tcx, O> Obligation<'tcx, O> {\n+    pub fn new(\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: O,\n+    ) -> Obligation<'tcx, O> {\n+        Obligation { cause, param_env, recursion_depth: 0, predicate }\n+    }\n+\n+    fn with_depth(\n+        cause: ObligationCause<'tcx>,\n+        recursion_depth: usize,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: O,\n+    ) -> Obligation<'tcx, O> {\n+        Obligation { cause, param_env, recursion_depth, predicate }\n+    }\n+\n+    pub fn misc(\n+        span: Span,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        trait_ref: O,\n+    ) -> Obligation<'tcx, O> {\n+        Obligation::new(ObligationCause::misc(span, body_id), param_env, trait_ref)\n+    }\n+\n+    pub fn with<P>(&self, value: P) -> Obligation<'tcx, P> {\n+        Obligation {\n+            cause: self.cause.clone(),\n+            param_env: self.param_env,\n+            recursion_depth: self.recursion_depth,\n+            predicate: value,\n+        }\n+    }\n+}\n+\n+impl<'tcx> FulfillmentError<'tcx> {\n+    fn new(\n+        obligation: PredicateObligation<'tcx>,\n+        code: FulfillmentErrorCode<'tcx>,\n+    ) -> FulfillmentError<'tcx> {\n+        FulfillmentError { obligation: obligation, code: code, points_at_arg_span: false }\n+    }\n+}\n+\n+impl<'tcx> TraitObligation<'tcx> {\n+    fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+        self.predicate.map_bound(|p| p.self_ty())\n+    }\n+}\n+\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n+    *providers = ty::query::Providers {\n+        is_object_safe: object_safety::is_object_safe_provider,\n+        specialization_graph_of: specialize::specialization_graph_provider,\n+        specializes: specialize::specializes,\n+        codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n+        vtable_methods,\n+        substitute_normalize_and_test_predicates,\n+        ..*providers\n+    };\n+}"}, {"sha": "d36d66e4e2555cc7940aa06bb77bc9fb982154e8", "filename": "src/librustc_infer/traits/object_safety.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fobject_safety.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -10,9 +10,10 @@\n \n use super::elaborate_predicates;\n \n+use crate::infer::TyCtxtInferExt;\n use crate::traits::{self, Obligation, ObligationCause};\n-use crate::ty::subst::{InternalSubsts, Subst};\n-use crate::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n+use rustc::ty::subst::{InternalSubsts, Subst};\n+use rustc::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -552,7 +553,7 @@ fn virtual_call_violation_for_method<'tcx>(\n         } else {\n             // Do sanity check to make sure the receiver actually has the layout of a pointer.\n \n-            use crate::ty::layout::Abi;\n+            use rustc::ty::layout::Abi;\n \n             let param_env = tcx.param_env(method.def_id);\n ", "previous_filename": "src/librustc/traits/object_safety.rs"}, {"sha": "41201c1c7ae7c4657dac2dbc0356cbfd6b0026fe", "filename": "src/librustc_infer/traits/on_unimplemented.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fon_unimplemented.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n use fmt_macros::{Parser, Piece, Position};\n \n-use crate::ty::{self, GenericParamDefKind, TyCtxt};\n-use crate::util::common::ErrorReported;\n+use rustc::ty::{self, GenericParamDefKind, TyCtxt};\n+use rustc::util::common::ErrorReported;\n \n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;", "previous_filename": "src/librustc/traits/on_unimplemented.rs"}, {"sha": "a7c3e9110abd2a3db98c406760ced6cba0f854b0", "filename": "src/librustc_infer/traits/project.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -14,9 +14,9 @@ use super::{VtableClosureData, VtableFnPointerData, VtableGeneratorData, VtableI\n \n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n-use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::subst::{InternalSubsts, Subst};\n-use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc::ty::subst::{InternalSubsts, Subst};\n+use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::sym;", "previous_filename": "src/librustc/traits/project.rs"}, {"sha": "a1d7a2836e42d3c032f5a165bea61a95e2b2c6d7", "filename": "src/librustc_infer/traits/query/dropck_outlives.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/traits/query/dropck_outlives.rs"}, {"sha": "b9ce3ccff274888190eb458edba83d6570958281", "filename": "src/librustc_infer/traits/query/evaluate_obligation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/traits/query/evaluate_obligation.rs"}, {"sha": "80748c5ef388efe15f3109b5f6990e9e6517896c", "filename": "src/librustc_infer/traits/query/method_autoderef.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/traits/query/method_autoderef.rs"}, {"sha": "77b5ec669a09977888ae76d5c232a45d9bcf0383", "filename": "src/librustc_infer/traits/query/mod.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -12,4 +12,4 @@ pub mod normalize;\n pub mod outlives_bounds;\n pub mod type_op;\n \n-pub use rustc::traits::types::query::*;\n+pub use rustc::traits::query::*;", "previous_filename": "src/librustc/traits/query/mod.rs"}, {"sha": "4577e3d2e1cf87c8af73a84415d1e26d0b68c11b", "filename": "src/librustc_infer/traits/query/normalize.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Fnormalize.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -7,9 +7,9 @@ use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::project::Normalized;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n-use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::subst::Subst;\n-use crate::ty::{self, Ty, TyCtxt};\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc::ty::subst::Subst;\n+use rustc::ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n ", "previous_filename": "src/librustc/traits/query/normalize.rs"}, {"sha": "eb32ebf5c4db4ff499c9a4a0b73b9f79b4d59906", "filename": "src/librustc_infer/traits/query/outlives_bounds.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -2,7 +2,7 @@ use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferCtxt;\n use crate::traits::query::NoSolution;\n use crate::traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n-use crate::ty::{self, Ty};\n+use rustc::ty::{self, Ty};\n use rustc_hir as hir;\n use rustc_span::source_map::Span;\n ", "previous_filename": "src/librustc/traits/query/outlives_bounds.rs"}, {"sha": "b14b79f090778fbb230369539b1e41848b92368c", "filename": "src/librustc_infer/traits/query/type_op/ascribe_user_type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs"}, {"sha": "c1c9030b8880532b1213d512f8e0a4a408b3e4dc", "filename": "src/librustc_infer/traits/query/type_op/custom.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "previous_filename": "src/librustc/traits/query/type_op/custom.rs"}, {"sha": "3b6fbc7d8dd729cb30b10d676a26c5e2ac192167", "filename": "src/librustc_infer/traits/query/type_op/eq.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use crate::ty::{ParamEnvAnd, TyCtxt};\n+use rustc::ty::{ParamEnvAnd, TyCtxt};\n \n pub use rustc::traits::query::type_op::Eq;\n ", "previous_filename": "src/librustc/traits/query/type_op/eq.rs"}, {"sha": "3dad546872e5a54569244faefbab2b2f3ce8ed01", "filename": "src/librustc_infer/traits/query/type_op/implied_outlives_bounds.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::outlives_bounds::OutlivesBound;\n use crate::traits::query::Fallible;\n-use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n+use rustc::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n pub struct ImpliedOutlivesBounds<'tcx> {", "previous_filename": "src/librustc/traits/query/type_op/implied_outlives_bounds.rs"}, {"sha": "eb4c0a029e1b9cd1feb230a4cb37f052dae955fb", "filename": "src/librustc_infer/traits/query/type_op/mod.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -4,8 +4,8 @@ use crate::infer::canonical::{\n use crate::infer::{InferCtxt, InferOk};\n use crate::traits::query::Fallible;\n use crate::traits::ObligationCause;\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::{ParamEnvAnd, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::{ParamEnvAnd, TyCtxt};\n use std::fmt;\n use std::rc::Rc;\n \n@@ -19,7 +19,7 @@ pub mod prove_predicate;\n use self::prove_predicate::ProvePredicate;\n pub mod subtype;\n \n-pub use crate::traits::types::query::type_op::*;\n+pub use rustc::traits::query::type_op::*;\n \n /// \"Type ops\" are used in NLL to perform some particular action and\n /// extract out the resulting region constraints (or an error if it", "previous_filename": "src/librustc/traits/query/type_op/mod.rs"}, {"sha": "d2eec53bf80feac0a8cc5f4ef1c46fafa9797daa", "filename": "src/librustc_infer/traits/query/type_op/normalize.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt};\n use std::fmt;\n \n pub use rustc::traits::query::type_op::Normalize;", "previous_filename": "src/librustc/traits/query/type_op/normalize.rs"}, {"sha": "b94948cffd68f657ce7c27d238f40580e69121ba", "filename": "src/librustc_infer/traits/query/type_op/outlives.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::dropck_outlives::{trivial_dropck_outlives, DropckOutlivesResult};\n use crate::traits::query::Fallible;\n-use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n+use rustc::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable, Lift)]\n pub struct DropckOutlives<'tcx> {", "previous_filename": "src/librustc/traits/query/type_op/outlives.rs"}, {"sha": "8c68f7db9e5bca0da39b5abd86f30c28a181d315", "filename": "src/librustc_infer/traits/query/type_op/prove_predicate.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use crate::ty::{ParamEnvAnd, Predicate, TyCtxt};\n+use rustc::ty::{ParamEnvAnd, Predicate, TyCtxt};\n \n pub use rustc::traits::query::type_op::ProvePredicate;\n ", "previous_filename": "src/librustc/traits/query/type_op/prove_predicate.rs"}, {"sha": "053411b0cac2e4ea0a0a14930f0482da5cda798f", "filename": "src/librustc_infer/traits/query/type_op/subtype.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use crate::ty::{ParamEnvAnd, TyCtxt};\n+use rustc::ty::{ParamEnvAnd, TyCtxt};\n \n pub use rustc::traits::query::type_op::Subtype;\n ", "previous_filename": "src/librustc/traits/query/type_op/subtype.rs"}, {"sha": "371268b5ee4710bbfed86a33ec3a900cfb8a992d", "filename": "src/librustc_infer/traits/select.rs", "status": "added", "additions": 3832, "deletions": 0, "changes": 3832, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fselect.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5"}, {"sha": "ee1c737c208f73d0dbaa5e35eda40edc8de09689", "filename": "src/librustc_infer/traits/specialize/mod.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fspecialize%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -10,13 +10,14 @@\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/specialization.html\n \n pub mod specialization_graph;\n+use specialization_graph::GraphExt;\n \n-use crate::infer::{InferCtxt, InferOk};\n+use crate::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::{self, coherence, FutureCompatOverlapErrorKind, ObligationCause, TraitEngine};\n-use crate::ty::subst::{InternalSubsts, Subst, SubstsRef};\n-use crate::ty::{self, TyCtxt, TypeFoldable};\n use rustc::lint::LintDiagnosticBuilder;\n+use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n+use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::DefId;", "previous_filename": "src/librustc/traits/specialize/mod.rs"}, {"sha": "17d4a22b9dd551fbd416548792f9daf4207850a9", "filename": "src/librustc_infer/traits/specialize/specialization_graph.rs", "status": "renamed", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -5,7 +5,7 @@ use rustc::ty::fast_reject::{self, SimplifiedType};\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc_hir::def_id::DefId;\n \n-pub use rustc::traits::types::specialization_graph::*;\n+pub use rustc::traits::specialization_graph::*;\n \n #[derive(Copy, Clone, Debug)]\n pub enum FutureCompatOverlapErrorKind {\n@@ -31,7 +31,19 @@ enum Inserted {\n     ShouldRecurseOn(DefId),\n }\n \n-impl<'tcx> Children {\n+trait ChildrenExt {\n+    fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId);\n+    fn remove_existing(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId);\n+\n+    fn insert(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        impl_def_id: DefId,\n+        simplified_self: Option<SimplifiedType>,\n+    ) -> Result<Inserted, OverlapError>;\n+}\n+\n+impl ChildrenExt for Children {\n     /// Insert an impl into this set of children without comparing to any existing impls.\n     fn insert_blindly(&mut self, tcx: TyCtxt<'tcx>, impl_def_id: DefId) {\n         let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n@@ -76,8 +88,8 @@ impl<'tcx> Children {\n         debug!(\"insert(impl_def_id={:?}, simplified_self={:?})\", impl_def_id, simplified_self,);\n \n         let possible_siblings = match simplified_self {\n-            Some(st) => PotentialSiblings::Filtered(self.filtered(st)),\n-            None => PotentialSiblings::Unfiltered(self.iter()),\n+            Some(st) => PotentialSiblings::Filtered(filtered_children(self, st)),\n+            None => PotentialSiblings::Unfiltered(iter_children(self)),\n         };\n \n         for possible_sibling in possible_siblings {\n@@ -199,16 +211,19 @@ impl<'tcx> Children {\n         self.insert_blindly(tcx, impl_def_id);\n         Ok(Inserted::BecameNewSibling(last_lint))\n     }\n+}\n \n-    fn iter(&mut self) -> impl Iterator<Item = DefId> + '_ {\n-        let nonblanket = self.nonblanket_impls.iter_mut().flat_map(|(_, v)| v.iter());\n-        self.blanket_impls.iter().chain(nonblanket).cloned()\n-    }\n+fn iter_children(children: &mut Children) -> impl Iterator<Item = DefId> + '_ {\n+    let nonblanket = children.nonblanket_impls.iter_mut().flat_map(|(_, v)| v.iter());\n+    children.blanket_impls.iter().chain(nonblanket).cloned()\n+}\n \n-    fn filtered(&mut self, st: SimplifiedType) -> impl Iterator<Item = DefId> + '_ {\n-        let nonblanket = self.nonblanket_impls.entry(st).or_default().iter();\n-        self.blanket_impls.iter().chain(nonblanket).cloned()\n-    }\n+fn filtered_children(\n+    children: &mut Children,\n+    st: SimplifiedType,\n+) -> impl Iterator<Item = DefId> + '_ {\n+    let nonblanket = children.nonblanket_impls.entry(st).or_default().iter();\n+    children.blanket_impls.iter().chain(nonblanket).cloned()\n }\n \n // A custom iterator used by Children::insert\n@@ -236,11 +251,25 @@ where\n     }\n }\n \n-impl<'tcx> Graph {\n+pub trait GraphExt {\n     /// Insert a local impl into the specialization graph. If an existing impl\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n-    pub fn insert(\n+    fn insert(\n+        &mut self,\n+        tcx: TyCtxt<'tcx>,\n+        impl_def_id: DefId,\n+    ) -> Result<Option<FutureCompatOverlapError>, OverlapError>;\n+\n+    /// Insert cached metadata mapping from a child impl back to its parent.\n+    fn record_impl_from_cstore(&mut self, tcx: TyCtxt<'tcx>, parent: DefId, child: DefId);\n+}\n+\n+impl GraphExt for Graph {\n+    /// Insert a local impl into the specialization graph. If an existing impl\n+    /// conflicts with it (has overlap, but neither specializes the other),\n+    /// information about the area of overlap is returned in the `Err`.\n+    fn insert(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n         impl_def_id: DefId,\n@@ -337,7 +366,7 @@ impl<'tcx> Graph {\n     }\n \n     /// Insert cached metadata mapping from a child impl back to its parent.\n-    pub fn record_impl_from_cstore(&mut self, tcx: TyCtxt<'tcx>, parent: DefId, child: DefId) {\n+    fn record_impl_from_cstore(&mut self, tcx: TyCtxt<'tcx>, parent: DefId, child: DefId) {\n         if self.parent.insert(child, parent).is_some() {\n             bug!(\n                 \"When recording an impl from the crate store, information about its parent \\", "previous_filename": "src/librustc/traits/specialize/specialization_graph.rs"}, {"sha": "6630f664f96e4ac9d93049e51d04f7b107003dfd", "filename": "src/librustc_infer/traits/structural_impls.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fstructural_impls.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -0,0 +1,71 @@\n+use crate::traits;\n+use crate::traits::project::Normalized;\n+use rustc::ty;\n+use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+\n+use std::fmt;\n+\n+// Structural impls for the structs in `traits`.\n+\n+impl<'tcx, T: fmt::Debug> fmt::Debug for Normalized<'tcx, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"Normalized({:?}, {:?})\", self.value, self.obligations)\n+    }\n+}\n+\n+impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if ty::tls::with(|tcx| tcx.sess.verbose()) {\n+            write!(\n+                f,\n+                \"Obligation(predicate={:?}, cause={:?}, param_env={:?}, depth={})\",\n+                self.predicate, self.cause, self.param_env, self.recursion_depth\n+            )\n+        } else {\n+            write!(f, \"Obligation(predicate={:?}, depth={})\", self.predicate, self.recursion_depth)\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::FulfillmentError<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"FulfillmentError({:?},{:?})\", self.obligation, self.code)\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::FulfillmentErrorCode<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n+            super::CodeProjectionError(ref e) => write!(f, \"{:?}\", e),\n+            super::CodeSubtypeError(ref a, ref b) => {\n+                write!(f, \"CodeSubtypeError({:?}, {:?})\", a, b)\n+            }\n+            super::CodeAmbiguity => write!(f, \"Ambiguity\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"MismatchedProjectionTypes({:?})\", self.err)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// TypeFoldable implementations.\n+\n+impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx, O> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::Obligation {\n+            cause: self.cause.clone(),\n+            recursion_depth: self.recursion_depth,\n+            predicate: self.predicate.fold_with(folder),\n+            param_env: self.param_env.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.predicate.visit_with(visitor)\n+    }\n+}"}, {"sha": "60682f5812917a4419b54e01a0916df800607976", "filename": "src/librustc_infer/traits/structural_match.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fstructural_match.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,9 +1,8 @@\n-use crate::ty::fold::{TypeFoldable, TypeVisitor};\n-use crate::ty::{self, AdtDef, Ty, TyCtxt};\n+use crate::infer::{InferCtxt, TyCtxtInferExt};\n+use crate::traits::ObligationCause;\n+use crate::traits::{self, ConstPatternStructural, TraitEngine};\n \n-use rustc::infer::InferCtxt;\n-use rustc::traits::ObligationCause;\n-use rustc::traits::{self, ConstPatternStructural, TraitEngine};\n+use rustc::ty::{self, AdtDef, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_span::Span;", "previous_filename": "src/librustc/traits/structural_match.rs"}, {"sha": "c1612a3b9a7498c713a88e56116da57179d0b4e8", "filename": "src/librustc_infer/traits/util.rs", "status": "renamed", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,10 +1,11 @@\n use rustc_errors::DiagnosticBuilder;\n use rustc_span::Span;\n+use smallvec::smallvec;\n use smallvec::SmallVec;\n \n-use crate::ty::outlives::Component;\n-use crate::ty::subst::{GenericArg, Subst, SubstsRef};\n-use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc::ty::outlives::Component;\n+use rustc::ty::subst::{GenericArg, Subst, SubstsRef};\n+use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;", "previous_filename": "src/librustc/traits/util.rs"}, {"sha": "89a271d0111af5480e456012d7e6ac65eb5ed2b6", "filename": "src/librustc_infer/traits/wf.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_infer%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fwf.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::opaque_types::required_region_bounds;\n use crate::infer::InferCtxt;\n-use crate::middle::lang_items;\n use crate::traits::{self, AssocTypeBoundData};\n-use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n+use rustc::middle::lang_items;\n+use rustc::ty::subst::SubstsRef;\n+use rustc::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::{kw, Ident};", "previous_filename": "src/librustc/traits/wf.rs"}, {"sha": "b3ac5b0fc548ae0d956b4622e55cfbc48ea54532", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -31,6 +31,7 @@ rustc_codegen_ssa = { path = \"../librustc_codegen_ssa\" }\n rustc_codegen_utils = { path = \"../librustc_codegen_utils\" }\n rustc_codegen_llvm = { path = \"../librustc_codegen_llvm\", optional = true }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_infer = { path = \"../librustc_infer\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_mir_build = { path = \"../librustc_mir_build\" }"}, {"sha": "0b4a337051f01ac440c1bf2518eff0918c580c9e", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -13,7 +13,6 @@ use rustc::session::config::{self, CrateType, Input, OutputFilenames, OutputType\n use rustc::session::config::{PpMode, PpSourceMode};\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n-use rustc::traits;\n use rustc::ty::steal::Steal;\n use rustc::ty::{self, GlobalCtxt, ResolverOutputs, TyCtxt};\n use rustc::util::common::ErrorReported;\n@@ -26,6 +25,7 @@ use rustc_errors::PResult;\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::Crate;\n+use rustc_infer::traits;\n use rustc_lint::LintStore;\n use rustc_mir as mir;\n use rustc_mir_build as mir_build;"}, {"sha": "1c2c241c000e70839776b48ec20f82798e7b05d7", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -23,3 +23,4 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_session = { path = \"../librustc_session\" }\n+rustc_infer = { path = \"../librustc_infer\" }"}, {"sha": "6039fef33e6132944a4ba686a8fa1022c616b331", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -24,7 +24,6 @@\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::hir::map::Map;\n use rustc::lint::LintDiagnosticBuilder;\n-use rustc::traits::misc::can_type_implement_copy;\n use rustc::ty::{self, layout::VariantIdx, Ty, TyCtxt};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::FxHashSet;\n@@ -36,6 +35,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{GenericParamKind, PatKind};\n use rustc_hir::{HirIdSet, Node};\n+use rustc_infer::traits::misc::can_type_implement_copy;\n use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;"}, {"sha": "3554fe54c4597d6adde4ba1a0eda8bfef4f59f53", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -23,6 +23,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_index = { path = \"../librustc_index\" }\n+rustc_infer = { path = \"../librustc_infer\" }\n rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }"}, {"sha": "46cfe0897a9ac86149a600d69681a6a76767d902", "filename": "src/librustc_mir/borrow_check/constraint_generation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,4 +1,3 @@\n-use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{\n@@ -8,6 +7,7 @@ use rustc::mir::{\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, RegionVid, Ty};\n+use rustc_infer::infer::InferCtxt;\n \n use crate::borrow_check::{\n     borrow_set::BorrowSet, facts::AllFacts, location::LocationTable, nll::ToRegionVid,"}, {"sha": "d1a03c4158068513e2a68a5fa28ad3e42cbf15ea", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -3,14 +3,14 @@ use rustc::mir::{\n     FakeReadCause, Local, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind, VarBindingForm,\n };\n-use rustc::traits::error_reporting::suggest_constraining_type_param;\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc_index::vec::Idx;\n+use rustc_infer::traits::error_reporting::suggest_constraining_type_param;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::Span;\n "}, {"sha": "6475677988fbb74efbcfb025415ebfaa1a0e292d", "filename": "src/librustc_mir/borrow_check/diagnostics/explain_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fexplain_borrow.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -2,7 +2,6 @@\n \n use std::collections::VecDeque;\n \n-use rustc::infer::NLLRegionVariableOrigin;\n use rustc::mir::{\n     Body, CastKind, ConstraintCategory, FakeReadCause, Local, Location, Operand, Place, Rvalue,\n     Statement, StatementKind, TerminatorKind,\n@@ -12,6 +11,7 @@ use rustc::ty::{self, RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_index::vec::IndexVec;\n+use rustc_infer::infer::NLLRegionVariableOrigin;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n "}, {"sha": "a3e0e51c5b64dd454dd7d8b0b05e0ec97ab5e348", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,11 +1,11 @@\n //! Error reporting machinery for lifetime errors.\n \n-use rustc::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, opaque_types, NLLRegionVariableOrigin,\n-};\n use rustc::mir::ConstraintCategory;\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n+use rustc_infer::infer::{\n+    error_reporting::nice_region_error::NiceRegionError, opaque_types, NLLRegionVariableOrigin,\n+};\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n "}, {"sha": "aeb29d2e11eb0205c04a311069e884053471e32f", "filename": "src/librustc_mir/borrow_check/member_constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmember_constraints.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,5 +1,5 @@\n use crate::rustc::ty::{self, Ty};\n-use rustc::infer::region_constraints::MemberConstraint;\n+use rustc::infer::MemberConstraint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;"}, {"sha": "a3edfb662c50ea9cbb3402e77c8f3ef97e591887", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,6 +1,5 @@\n //! This query borrow-checks the MIR to (further) ensure it is not broken.\n \n-use rustc::infer::InferCtxt;\n use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n@@ -20,6 +19,7 @@ use rustc_hir as hir;\n use rustc_hir::{def_id::DefId, HirId, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n \n use either::Either;\n use smallvec::SmallVec;"}, {"sha": "ba0f2e8a7ad764191746079883101e71885dec81", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,6 +1,5 @@\n //! The entry point of the NLL borrow checker.\n \n-use rustc::infer::InferCtxt;\n use rustc::mir::{\n     BasicBlock, Body, BodyAndCache, ClosureOutlivesSubject, ClosureRegionRequirements, LocalKind,\n     Location, Promoted, ReadOnlyBodyAndCache,\n@@ -10,6 +9,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n+use rustc_infer::infer::InferCtxt;\n use rustc_span::symbol::sym;\n use std::env;\n use std::fmt::Debug;"}, {"sha": "369e540231168f0ddbd6ce51778b9e1fab75f3b6", "filename": "src/librustc_mir/borrow_check/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fdump_mir.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -4,7 +4,7 @@\n //! context internal state.\n \n use super::{OutlivesConstraint, RegionInferenceContext};\n-use rustc::infer::NLLRegionVariableOrigin;\n+use rustc_infer::infer::NLLRegionVariableOrigin;\n use std::io::{self, Write};\n \n // Room for \"'_#NNNNr\" before things get misaligned."}, {"sha": "144f655420b36541571ab5907c65fcc585070bfc", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,9 +1,6 @@\n use std::collections::VecDeque;\n use std::rc::Rc;\n \n-use rustc::infer::canonical::QueryOutlivesConstraint;\n-use rustc::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n-use rustc::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n     ConstraintCategory, Local, Location,\n@@ -15,6 +12,9 @@ use rustc_data_structures::graph::scc::Sccs;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n+use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n+use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound};\n+use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc_span::Span;\n \n use crate::borrow_check::{"}, {"sha": "15bbc5677daddbbaa80680476c5b758bd050348f", "filename": "src/librustc_mir/borrow_check/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n-use rustc::infer::InferCtxt;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::InferCtxt;\n use rustc_span::Span;\n \n use super::RegionInferenceContext;"}, {"sha": "a63d18c27f1195a8a854fa1da3cbaa6c986d8406", "filename": "src/librustc_mir/borrow_check/renumber.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Frenumber.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,9 +1,9 @@\n-use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::mir::{BodyAndCache, Location, PlaceElem, Promoted};\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_index::vec::IndexVec;\n+use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created."}, {"sha": "576759c2a3574ba66675dcf0e211c9707b1d9c49", "filename": "src/librustc_mir/borrow_check/type_check/constraint_conversion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fconstraint_conversion.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,12 +1,12 @@\n-use rustc::infer::canonical::QueryOutlivesConstraint;\n-use rustc::infer::canonical::QueryRegionConstraints;\n-use rustc::infer::outlives::env::RegionBoundPairs;\n-use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n-use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n-use rustc::infer::{self, InferCtxt, SubregionOrigin};\n use rustc::mir::ConstraintCategory;\n use rustc::ty::subst::GenericArgKind;\n use rustc::ty::{self, TyCtxt};\n+use rustc_infer::infer::canonical::QueryOutlivesConstraint;\n+use rustc_infer::infer::canonical::QueryRegionConstraints;\n+use rustc_infer::infer::outlives::env::RegionBoundPairs;\n+use rustc_infer::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n+use rustc_infer::infer::region_constraints::{GenericKind, VerifyBound};\n+use rustc_infer::infer::{self, InferCtxt, SubregionOrigin};\n use rustc_span::DUMMY_SP;\n \n use crate::borrow_check::{"}, {"sha": "137216531a369e69b8eaaf89846bbe70edf91540", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,12 +1,12 @@\n-use rustc::infer::canonical::QueryRegionConstraints;\n-use rustc::infer::region_constraints::GenericKind;\n-use rustc::infer::InferCtxt;\n use rustc::mir::ConstraintCategory;\n-use rustc::traits::query::outlives_bounds::{self, OutlivesBound};\n-use rustc::traits::query::type_op::{self, TypeOp};\n use rustc::ty::free_region_map::FreeRegionRelations;\n use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use rustc_infer::infer::canonical::QueryRegionConstraints;\n+use rustc_infer::infer::region_constraints::GenericKind;\n+use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::query::outlives_bounds::{self, OutlivesBound};\n+use rustc_infer::traits::query::type_op::{self, TypeOp};\n use rustc_span::DUMMY_SP;\n use std::rc::Rc;\n "}, {"sha": "37cf77b7095c6c70334c8f121f52e0bfd39bdedf", "filename": "src/librustc_mir/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -7,9 +7,9 @@\n //! `RETURN_PLACE` the MIR arguments) are always fully normalized (and\n //! contain revealed `impl Trait` values).\n \n-use rustc::infer::LateBoundRegionConversionTime;\n use rustc::mir::*;\n use rustc::ty::Ty;\n+use rustc_infer::infer::LateBoundRegionConversionTime;\n \n use rustc_index::vec::Idx;\n use rustc_span::Span;"}, {"sha": "4c8deb0ecf84a547bd52d4d8c591be1b2c34d53a", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,11 +1,11 @@\n-use rustc::infer::canonical::QueryRegionConstraints;\n use rustc::mir::{BasicBlock, ConstraintCategory, Local, Location, ReadOnlyBodyAndCache};\n-use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n-use rustc::traits::query::type_op::outlives::DropckOutlives;\n-use rustc::traits::query::type_op::TypeOp;\n use rustc::ty::{Ty, TypeFoldable};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::bit_set::HybridBitSet;\n+use rustc_infer::infer::canonical::QueryRegionConstraints;\n+use rustc_infer::traits::query::dropck_outlives::DropckOutlivesResult;\n+use rustc_infer::traits::query::type_op::outlives::DropckOutlives;\n+use rustc_infer::traits::query::type_op::TypeOp;\n use std::rc::Rc;\n \n use crate::dataflow::generic::ResultsCursor;"}, {"sha": "c92486213fd3e38f3ce7e9c43f1d8c074859e9e9", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -5,19 +5,10 @@ use std::{fmt, iter, mem};\n \n use either::Either;\n \n-use rustc::infer::canonical::QueryRegionConstraints;\n-use rustc::infer::opaque_types::GenerateMemberConstraints;\n-use rustc::infer::outlives::env::RegionBoundPairs;\n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n use rustc::mir::tcx::PlaceTy;\n use rustc::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc::mir::AssertKind;\n use rustc::mir::*;\n-use rustc::traits::query::type_op;\n-use rustc::traits::query::type_op::custom::CustomTypeOp;\n-use rustc::traits::query::{Fallible, NoSolution};\n-use rustc::traits::{self, ObligationCause, PredicateObligations};\n use rustc::ty::adjustment::PointerCast;\n use rustc::ty::cast::CastTy;\n use rustc::ty::fold::TypeFoldable;\n@@ -32,6 +23,17 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_infer::infer::canonical::QueryRegionConstraints;\n+use rustc_infer::infer::opaque_types::GenerateMemberConstraints;\n+use rustc_infer::infer::outlives::env::RegionBoundPairs;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::{\n+    InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin,\n+};\n+use rustc_infer::traits::query::type_op;\n+use rustc_infer::traits::query::type_op::custom::CustomTypeOp;\n+use rustc_infer::traits::query::{Fallible, NoSolution};\n+use rustc_infer::traits::{self, ObligationCause, PredicateObligations};\n use rustc_span::{Span, DUMMY_SP};\n \n use crate::dataflow::generic::ResultsCursor;"}, {"sha": "31507a184d8f914d0898ee844adbf53ff7bf27b2", "filename": "src/librustc_mir/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,10 +1,10 @@\n-use rustc::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n-use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::mir::ConstraintCategory;\n-use rustc::traits::query::Fallible;\n-use rustc::traits::DomainGoal;\n use rustc::ty::relate::TypeRelation;\n use rustc::ty::{self, Ty};\n+use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n+use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc_infer::traits::query::Fallible;\n+use rustc_infer::traits::DomainGoal;\n \n use crate::borrow_check::constraints::OutlivesConstraint;\n use crate::borrow_check::type_check::{BorrowCheckContext, Locations};"}, {"sha": "0913de63e8ef100102fd037fe6d2b6733e200522", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -13,7 +13,6 @@\n //! just returns them for other code to use.\n \n use either::Either;\n-use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n use rustc::middle::lang_items;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n@@ -24,6 +23,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{BodyOwnerKind, HirId};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin};\n use std::iter;\n \n use crate::borrow_check::nll::ToRegionVid;"}, {"sha": "167d8145c030f2d259690cdb0c15e8b37bd52997", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -3,12 +3,13 @@\n use rustc::middle::lang_items;\n use rustc::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc::mir::*;\n-use rustc::traits::{self, TraitEngine};\n use rustc::ty::cast::CastTy;\n use rustc::ty::{self, TyCtxt};\n use rustc_errors::struct_span_err;\n use rustc_hir::{def_id::DefId, HirId};\n use rustc_index::bit_set::BitSet;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::{self, TraitEngine};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n "}, {"sha": "91d134fbb0066b296df84b56669bda5cbb302c0b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -14,7 +14,6 @@ use rustc::mir::{\n     SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n     UnOp, RETURN_PLACE,\n };\n-use rustc::traits;\n use rustc::ty::layout::{\n     HasDataLayout, HasTyCtxt, LayoutError, LayoutOf, Size, TargetDataLayout, TyLayout,\n };\n@@ -25,6 +24,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n+use rustc_infer::traits;\n use rustc_span::Span;\n use syntax::ast::Mutability;\n "}, {"sha": "fac30637dd077e52bc12df1dc8e6d85cf8c27f0c", "filename": "src/librustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -19,6 +19,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_infer = { path = \"../librustc_infer\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_session = { path = \"../librustc_session\" }"}, {"sha": "8b7d0637c0343f9823bb55dcd7025f56dfc976e9", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -12,6 +12,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{GeneratorKind, HirIdMap, Node};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;"}, {"sha": "ee62af7f8519d295b5caa4d475818104aa9bb4eb", "filename": "src/librustc_mir_build/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -5,7 +5,6 @@\n use crate::hair::util::UserAnnotatedTyHelpers;\n use crate::hair::*;\n \n-use rustc::infer::InferCtxt;\n use rustc::middle::region;\n use rustc::mir::interpret::{LitToConstError, LitToConstInput};\n use rustc::ty::layout::VariantIdx;\n@@ -16,6 +15,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n use rustc_index::vec::Idx;\n+use rustc_infer::infer::InferCtxt;\n use rustc_span::symbol::{sym, Symbol};\n use syntax::ast;\n use syntax::attr;"}, {"sha": "27d1bce76edc5f3003a1413c6c6c61f70c296ab2", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,10 +1,10 @@\n-use rustc::infer::InferCtxt;\n use rustc::lint;\n use rustc::mir::Field;\n-use rustc::traits::predicate_for_trait_def;\n-use rustc::traits::{self, ObligationCause, PredicateObligation};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::predicate_for_trait_def;\n+use rustc_infer::traits::{self, ObligationCause, PredicateObligation};\n \n use rustc_index::vec::Idx;\n "}, {"sha": "41718b21f520c45eebf1218abf3d2ec8ab72e4c4", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -17,6 +17,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_index = { path = \"../librustc_index\" }\n+rustc_infer = { path = \"../librustc_infer\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_target = { path = \"../librustc_target\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "99f005c29e875c91e5f805f9d0863808c4870fe8", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -7,7 +7,6 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability::{DeprecationEntry, Index};\n use rustc::session::parse::feature_err;\n use rustc::session::Session;\n-use rustc::traits::misc::can_type_implement_copy;\n use rustc::ty::query::Providers;\n use rustc::ty::TyCtxt;\n use rustc_attr::{self as attr, Stability};\n@@ -18,6 +17,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Generics, HirId, Item, StructField, Variant};\n+use rustc_infer::traits::misc::can_type_implement_copy;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n use syntax::ast::Attribute;"}, {"sha": "a40c3ca0f9eca6c9ca4d5cf4fbaeee6b508a77f9", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -24,6 +24,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_expand = { path = \"../librustc_expand\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_infer = { path = \"../librustc_infer\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "40ca2ea90f2f487daa1284fd90d44ee170e4345f", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -19,3 +19,4 @@ syntax = { path = \"../libsyntax\" }\n rustc_span = { path = \"../librustc_span\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+rustc_infer = { path = \"../librustc_infer\" }"}, {"sha": "240a93f0900a4605fd4cee7b6a47992a279601ba", "filename": "src/librustc_traits/chalk_context/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -5,19 +5,19 @@ mod unify;\n use chalk_engine::fallible::Fallible;\n use chalk_engine::forest::Forest;\n use chalk_engine::{context, hh::HhGoal, DelayedLiteral, ExClause, Literal};\n-use rustc::infer::canonical::{\n+use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use rustc::ty::query::Providers;\n+use rustc::ty::subst::{GenericArg, GenericArgKind};\n+use rustc::ty::{self, TyCtxt};\n+use rustc_infer::infer::canonical::{\n     Canonical, CanonicalVarValues, Certainty, OriginalQueryValues, QueryRegionConstraints,\n     QueryResponse,\n };\n-use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n-use rustc::traits::{\n+use rustc_infer::infer::{InferCtxt, LateBoundRegionConversionTime, TyCtxtInferExt};\n+use rustc_infer::traits::{\n     self, ChalkCanonicalGoal, ChalkContextLift, Clause, DomainGoal, Environment, ExClauseFold,\n     Goal, GoalKind, InEnvironment, QuantifierKind,\n };\n-use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc::ty::query::Providers;\n-use rustc::ty::subst::{GenericArg, GenericArgKind};\n-use rustc::ty::{self, TyCtxt};\n use rustc_macros::{Lift, TypeFoldable};\n use rustc_span::DUMMY_SP;\n "}, {"sha": "796ce6085fdbe25085f819e695f689ee07c483f8", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,13 +1,13 @@\n use chalk_engine::fallible::{Fallible, NoSolution};\n use chalk_engine::{context, ExClause, Literal};\n-use rustc::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc::infer::{InferCtxt, LateBoundRegionConversionTime};\n-use rustc::traits::{\n-    Clause, DomainGoal, Environment, Goal, GoalKind, InEnvironment, ProgramClause, WhereClause,\n-};\n use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc::ty::subst::GenericArg;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n+use rustc_infer::infer::{InferCtxt, LateBoundRegionConversionTime};\n+use rustc_infer::traits::{\n+    Clause, DomainGoal, Environment, Goal, GoalKind, InEnvironment, ProgramClause, WhereClause,\n+};\n use rustc_span::DUMMY_SP;\n \n use super::unify::*;"}, {"sha": "3274a301bb6694c35b53bd948808acf907c07a01", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,8 +1,8 @@\n-use rustc::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n-use rustc::infer::{InferCtxt, RegionVariableOrigin};\n-use rustc::traits::{DomainGoal, Environment, Goal, InEnvironment};\n use rustc::ty;\n use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n+use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n+use rustc_infer::infer::{InferCtxt, RegionVariableOrigin};\n+use rustc_infer::traits::{DomainGoal, Environment, Goal, InEnvironment};\n use rustc_span::DUMMY_SP;\n \n crate struct UnificationResult<'tcx> {"}, {"sha": "e14295de061e57f7946d070c125275efc75a5c0a", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,13 +1,14 @@\n-use rustc::infer::canonical::{Canonical, QueryResponse};\n-use rustc::traits::query::dropck_outlives::trivial_dropck_outlives;\n-use rustc::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n-use rustc::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc::traits::{Normalized, ObligationCause, TraitEngine, TraitEngineExt};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::query::dropck_outlives::trivial_dropck_outlives;\n+use rustc_infer::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n+use rustc_infer::traits::query::{CanonicalTyGoal, NoSolution};\n+use rustc_infer::traits::{Normalized, ObligationCause, TraitEngine, TraitEngineExt};\n use rustc_span::source_map::{Span, DUMMY_SP};\n \n crate fn provide(p: &mut Providers<'_>) {"}, {"sha": "4cf5b66b3cbeb67789331dcdea41edebc2ed11a0", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,9 +1,10 @@\n-use rustc::traits::query::CanonicalPredicateGoal;\n-use rustc::traits::{\n-    EvaluationResult, Obligation, ObligationCause, OverflowError, SelectionContext, TraitQueryMode,\n-};\n use rustc::ty::query::Providers;\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::query::CanonicalPredicateGoal;\n+use rustc_infer::traits::{\n+    EvaluationResult, Obligation, ObligationCause, OverflowError, SelectionContext, TraitQueryMode,\n+};\n use rustc_span::source_map::DUMMY_SP;\n \n crate fn provide(p: &mut Providers<'_>) {"}, {"sha": "69424e3fac77639df169998626a5089db2cff211", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,17 +1,17 @@\n //! Provider for the `implied_outlives_bounds` query.\n //! Do not call this query directory. See [`rustc::traits::query::implied_outlives_bounds`].\n \n-use rustc::infer::canonical::{self, Canonical};\n-use rustc::infer::InferCtxt;\n-use rustc::traits::query::outlives_bounds::OutlivesBound;\n-use rustc::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n-use rustc::traits::wf;\n-use rustc::traits::FulfillmentContext;\n-use rustc::traits::{TraitEngine, TraitEngineExt};\n use rustc::ty::outlives::Component;\n use rustc::ty::query::Providers;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as hir;\n+use rustc_infer::infer::canonical::{self, Canonical};\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::query::outlives_bounds::OutlivesBound;\n+use rustc_infer::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n+use rustc_infer::traits::wf;\n+use rustc_infer::traits::FulfillmentContext;\n+use rustc_infer::traits::{TraitEngine, TraitEngineExt};\n use rustc_span::source_map::DUMMY_SP;\n use smallvec::{smallvec, SmallVec};\n "}, {"sha": "4e5f20d80b0d8d0ec445212aaca7d31ba6a4c04e", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,8 @@\n use rustc::traits::query::NoSolution;\n-use rustc::traits::{Normalized, ObligationCause};\n use rustc::ty::query::Providers;\n use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::{Normalized, ObligationCause};\n use std::sync::atomic::Ordering;\n \n crate fn provide(p: &mut Providers<'_>) {"}, {"sha": "b5678956347634717a7192d046ee0a03a6233733", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,9 +1,12 @@\n-use rustc::infer::canonical::{Canonical, QueryResponse};\n-use rustc::traits::query::{normalize::NormalizationResult, CanonicalProjectionGoal, NoSolution};\n-use rustc::traits::{self, ObligationCause, SelectionContext, TraitEngineExt};\n use rustc::ty::query::Providers;\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n use rustc_hir as hir;\n+use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::query::{\n+    normalize::NormalizationResult, CanonicalProjectionGoal, NoSolution,\n+};\n+use rustc_infer::traits::{self, ObligationCause, SelectionContext, TraitEngineExt};\n use rustc_span::DUMMY_SP;\n use std::sync::atomic::Ordering;\n "}, {"sha": "411813380614114bea9c81ae99158fb9849baa12", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,20 +1,20 @@\n-use rustc::infer::at::ToTrace;\n-use rustc::infer::canonical::{Canonical, QueryResponse};\n-use rustc::infer::InferCtxt;\n-use rustc::traits::query::type_op::ascribe_user_type::AscribeUserType;\n-use rustc::traits::query::type_op::eq::Eq;\n-use rustc::traits::query::type_op::normalize::Normalize;\n-use rustc::traits::query::type_op::prove_predicate::ProvePredicate;\n-use rustc::traits::query::type_op::subtype::Subtype;\n-use rustc::traits::query::{Fallible, NoSolution};\n-use rustc::traits::{Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::{GenericArg, Subst, UserSelfTy, UserSubsts};\n use rustc::ty::{\n     FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable, Variance,\n };\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::at::ToTrace;\n+use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::query::type_op::ascribe_user_type::AscribeUserType;\n+use rustc_infer::traits::query::type_op::eq::Eq;\n+use rustc_infer::traits::query::type_op::normalize::Normalize;\n+use rustc_infer::traits::query::type_op::prove_predicate::ProvePredicate;\n+use rustc_infer::traits::query::type_op::subtype::Subtype;\n+use rustc_infer::traits::query::{Fallible, NoSolution};\n+use rustc_infer::traits::{Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt};\n use rustc_span::DUMMY_SP;\n use std::fmt;\n "}, {"sha": "6e64df3492b0fedbf1c1adf5dede034bd4f8f4a0", "filename": "src/librustc_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -13,5 +13,6 @@ log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_infer = { path = \"../librustc_infer\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_target = { path = \"../librustc_target\" }"}, {"sha": "e0ce6ad23a650928888f02c1d5f1144ee5ae7699", "filename": "src/librustc_ty/common_traits.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_ty%2Fcommon_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_ty%2Fcommon_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fcommon_traits.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,8 +1,9 @@\n //! Queries for checking whether a type implements one of a few common traits.\n \n use rustc::middle::lang_items;\n-use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits;\n use rustc_span::DUMMY_SP;\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {"}, {"sha": "484b774add462973a48e4479d8cb84f343399c31", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n-use rustc::traits;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Instance, TyCtxt, TypeFoldable};\n use rustc_hir::def_id::DefId;\n+use rustc_infer::traits;\n use rustc_target::spec::abi::Abi;\n \n use log::debug;"}, {"sha": "f9b2ee3cb8e3fadc301df6fed38412ced0f617f7", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,11 +1,11 @@\n use rustc::hir::map as hir_map;\n use rustc::session::CrateDisambiguator;\n-use rustc::traits::{self};\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_infer::traits;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n "}, {"sha": "f1890f9f4e6f12c420c1c3e0a120d84a58374cce", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -23,3 +23,4 @@ smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n syntax = { path = \"../libsyntax\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_index = { path = \"../librustc_index\" }\n+rustc_infer = { path = \"../librustc_infer\" }"}, {"sha": "c0574d6d9fdd7c198d27d24bba557b3314f4dbd3", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -14,10 +14,6 @@ use crate::require_c_abi_if_c_variadic;\n use crate::util::common::ErrorReported;\n use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n use rustc::session::parse::feature_err;\n-use rustc::traits;\n-use rustc::traits::astconv_object_safety_violations;\n-use rustc::traits::error_reporting::report_object_safety_error;\n-use rustc::traits::wf::object_region_bounds;\n use rustc::ty::subst::{self, InternalSubsts, Subst, SubstsRef};\n use rustc::ty::{self, Const, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n@@ -29,6 +25,10 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::print;\n use rustc_hir::{Constness, ExprKind, GenericArg, GenericArgs};\n+use rustc_infer::traits;\n+use rustc_infer::traits::astconv_object_safety_violations;\n+use rustc_infer::traits::error_reporting::report_object_safety_error;\n+use rustc_infer::traits::wf::object_region_bounds;\n use rustc_span::symbol::sym;\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi;"}, {"sha": "2c71fec6809f7747194ac1860449f4a9f938e0ac", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,11 +1,11 @@\n use crate::check::coercion::CoerceMany;\n use crate::check::{Diverges, Expectation, FnCtxt, Needs};\n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::traits::ObligationCauseCode;\n-use rustc::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n use rustc::ty::Ty;\n use rustc_hir as hir;\n use rustc_hir::ExprKind;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::traits::ObligationCauseCode;\n+use rustc_infer::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n use rustc_span::Span;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {"}, {"sha": "00e91decf78b83585c7b315bb8b0607e65880a6f", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,14 +1,14 @@\n use super::method::MethodCallee;\n use super::{FnCtxt, Needs, PlaceOp};\n \n-use rustc::infer::{InferCtxt, InferOk};\n use rustc::session::DiagnosticMessageId;\n-use rustc::traits::{self, TraitEngine};\n use rustc::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n use rustc::ty::{self, TraitRef, Ty, TyCtxt, WithConstness};\n use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::traits::{self, TraitEngine};\n \n use rustc_span::Span;\n use syntax::ast::Ident;"}, {"sha": "d0d07334fa515c3850c10403da58bbdc094776b3", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -3,15 +3,15 @@ use super::method::MethodCallee;\n use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n use crate::type_error_struct;\n \n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::{infer, traits};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::{infer, traits};\n use rustc_span::Span;\n use rustc_target::spec::abi;\n use syntax::ast::Ident;"}, {"sha": "18f6a78804b408b5c859137c1745c5f2d6754c17", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -36,16 +36,16 @@ use crate::type_error_struct;\n use crate::util::common::ErrorReported;\n use rustc::middle::lang_items;\n use rustc::session::Session;\n-use rustc::traits;\n-use rustc::traits::error_reporting::report_object_safety_error;\n-use rustc::traits::object_safety_violations;\n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::cast::{CastKind, CastTy};\n use rustc::ty::error::TypeError;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n+use rustc_infer::traits;\n+use rustc_infer::traits::error_reporting::report_object_safety_error;\n+use rustc_infer::traits::object_safety_violations;\n use rustc_span::Span;\n use syntax::ast;\n "}, {"sha": "ae6bed476f316b207bb73b893098d9c8639284c9", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -4,16 +4,16 @@ use super::{check_fn, Expectation, FnCtxt, GeneratorTypes};\n \n use crate::astconv::AstConv;\n use crate::middle::{lang_items, region};\n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::infer::LateBoundRegionConversionTime;\n-use rustc::infer::{InferOk, InferResult};\n-use rustc::traits::error_reporting::ArgKind;\n-use rustc::traits::Obligation;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::InternalSubsts;\n use rustc::ty::{self, GenericParamDefKind, Ty};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::LateBoundRegionConversionTime;\n+use rustc_infer::infer::{InferOk, InferResult};\n+use rustc_infer::traits::error_reporting::ArgKind;\n+use rustc_infer::traits::Obligation;\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n use std::cmp;"}, {"sha": "ce44fdab32314284bc38ce0f3e3a9f9d2bf2e537", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -52,11 +52,7 @@\n \n use crate::astconv::AstConv;\n use crate::check::{FnCtxt, Needs};\n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::infer::{Coercion, InferOk, InferResult};\n use rustc::session::parse::feature_err;\n-use rustc::traits::object_safety_violations;\n-use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n };\n@@ -68,6 +64,10 @@ use rustc::ty::{self, Ty, TypeAndMut};\n use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::{Coercion, InferOk, InferResult};\n+use rustc_infer::traits::object_safety_violations;\n+use rustc_infer::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;"}, {"sha": "8b54b5343756ad7771e30f909fb71cd4a69d8fb0", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,6 +1,4 @@\n use rustc::hir::map::Map;\n-use rustc::infer::{self, InferOk};\n-use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::util::ExplicitSelf;\n@@ -11,6 +9,8 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n+use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n+use rustc_infer::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc_span::Span;\n \n use super::{potentially_plural_count, FnCtxt, Inherited};"}, {"sha": "bf74ab696d6ca2e5174008363d29ef147539d466", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,6 +1,6 @@\n use crate::check::FnCtxt;\n-use rustc::infer::InferOk;\n-use rustc::traits::{self, ObligationCause};\n+use rustc_infer::infer::InferOk;\n+use rustc_infer::traits::{self, ObligationCause};\n \n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::{self, AssocItem, Ty};"}, {"sha": "ead7536f8c664a9a23599998a40e93332541a140", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -2,16 +2,15 @@ use crate::check::regionck::RegionCtxt;\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::util::common::ErrorReported;\n-use rustc::infer::outlives::env::OutlivesEnvironment;\n-use rustc::infer::{InferOk, SuppressRegionErrors};\n use rustc::middle::region;\n-use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc::ty::subst::{Subst, SubstsRef};\n use rustc::ty::{self, Predicate, Ty, TyCtxt};\n use rustc_errors::struct_span_err;\n-\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::{InferOk, SuppressRegionErrors, TyCtxtInferExt};\n+use rustc_infer::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n use rustc_span::Span;\n \n /// This function confirms that the `Drop` implementation identified by"}, {"sha": "d947544d182cd7db4bdd10913dc5c95d45da3693", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -17,10 +17,7 @@ use crate::check::TupleArgumentsFlag::DontTupleArguments;\n use crate::type_error_struct;\n use crate::util::common::ErrorReported;\n \n-use rustc::infer;\n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::middle::lang_items;\n-use rustc::traits::{self, ObligationCauseCode};\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::Ty;\n@@ -32,6 +29,9 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{ExprKind, QPath};\n+use rustc_infer::infer;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::traits::{self, ObligationCauseCode};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Symbol};"}, {"sha": "17842be9a43922a567093aa6e14bf0961ee05eb8", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -4,14 +4,14 @@ use crate::astconv::AstConv;\n use crate::check::{callee, FnCtxt, Needs, PlaceOp};\n use crate::hir::def_id::DefId;\n use crate::hir::GenericArg;\n-use rustc::infer::{self, InferOk};\n-use rustc::traits;\n use rustc::ty::adjustment::{Adjust, Adjustment, OverloadedDeref, PointerCast};\n use rustc::ty::adjustment::{AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, SubstsRef};\n use rustc::ty::{self, GenericParamDefKind, Ty};\n use rustc_hir as hir;\n+use rustc_infer::infer::{self, InferOk};\n+use rustc_infer::traits;\n use rustc_span::Span;\n \n use std::ops::Deref;"}, {"sha": "1856157fffb38e24a7cee4450db67f9bf152ac96", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -12,8 +12,6 @@ pub use self::MethodError::*;\n \n use crate::check::FnCtxt;\n use crate::namespace::Namespace;\n-use rustc::infer::{self, InferOk};\n-use rustc::traits;\n use rustc::ty::subst::Subst;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::GenericParamDefKind;\n@@ -23,6 +21,8 @@ use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::{self, InferOk};\n+use rustc_infer::traits;\n use rustc_span::Span;\n use syntax::ast;\n "}, {"sha": "346406fff56bff9137ab0e8efcb5a20aab07ea2f", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -9,18 +9,9 @@ use crate::hir::def::DefKind;\n use crate::hir::def_id::DefId;\n use crate::namespace::Namespace;\n \n-use rustc::infer::canonical::OriginalQueryValues;\n-use rustc::infer::canonical::{Canonical, QueryResponse};\n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc::infer::{self, InferOk};\n use rustc::lint;\n use rustc::middle::stability;\n use rustc::session::config::nightly_options;\n-use rustc::traits::query::method_autoderef::MethodAutoderefBadTy;\n-use rustc::traits::query::method_autoderef::{CandidateStep, MethodAutoderefStepsResult};\n-use rustc::traits::query::CanonicalTyGoal;\n-use rustc::traits::{self, ObligationCause};\n use rustc::ty::subst::{InternalSubsts, Subst, SubstsRef};\n use rustc::ty::GenericParamDefKind;\n use rustc::ty::{\n@@ -31,6 +22,15 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_infer::infer::canonical::OriginalQueryValues;\n+use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n+use rustc_infer::traits::query::method_autoderef::MethodAutoderefBadTy;\n+use rustc_infer::traits::query::method_autoderef::{CandidateStep, MethodAutoderefStepsResult};\n+use rustc_infer::traits::query::CanonicalTyGoal;\n+use rustc_infer::traits::{self, ObligationCause};\n use rustc_span::{symbol::Symbol, Span, DUMMY_SP};\n use std::cmp::max;\n use std::iter;"}, {"sha": "83f063acedab9ce1fe12ab6f0eb74df38630d840", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -6,8 +6,6 @@ use crate::middle::lang_items::FnOnceTraitLangItem;\n use crate::namespace::Namespace;\n use rustc::hir::map as hir_map;\n use rustc::hir::map::Map;\n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::traits::Obligation;\n use rustc::ty::print::with_crate_prefix;\n use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n use rustc_data_structures::fx::FxHashSet;\n@@ -17,6 +15,8 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit;\n use rustc_hir::{ExprKind, Node, QPath};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::traits::Obligation;\n use rustc_span::{source_map, FileName, Span};\n use syntax::ast;\n use syntax::util::lev_distance;"}, {"sha": "748a44a7297d7fe4cbe14130f9f79f6aa6effab6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -92,17 +92,9 @@ use crate::middle::lang_items;\n use crate::namespace::Namespace;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::hir::map::Map;\n-use rustc::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n-use rustc::infer::error_reporting::TypeAnnotationNeeded::E0282;\n-use rustc::infer::opaque_types::OpaqueTypeDecl;\n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc::infer::{self, InferCtxt, InferOk, InferResult};\n use rustc::middle::region;\n use rustc::mir::interpret::ConstValue;\n use rustc::session::parse::feature_err;\n-use rustc::traits::error_reporting::recursive_type_with_infinite_size_error;\n-use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability, PointerCast,\n };\n@@ -126,6 +118,14 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, QPath};\n use rustc_index::vec::Idx;\n+use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n+use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n+use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_infer::infer::{self, InferCtxt, InferOk, InferResult, TyCtxtInferExt};\n+use rustc_infer::traits::error_reporting::recursive_type_with_infinite_size_error;\n+use rustc_infer::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{original_sp, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident};"}, {"sha": "86b00c2f0d3f04fac4edc20a4a84c795feda4888", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -2,12 +2,12 @@\n \n use super::method::MethodCallee;\n use super::{FnCtxt, Needs};\n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::TyKind::{Adt, Array, Char, FnDef, Never, Ref, Str, Tuple, Uint};\n use rustc::ty::{self, Ty, TypeFoldable};\n use rustc_errors::{self, struct_span_err, Applicability};\n use rustc_hir as hir;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_span::Span;\n use syntax::ast::Ident;\n "}, {"sha": "2c7cbed6a2d36a4c44f1d3b29fcbbc4f1a8f9917", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,4 @@\n use crate::check::FnCtxt;\n-use rustc::infer;\n-use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc::traits::Pattern;\n use rustc::ty::subst::GenericArg;\n use rustc::ty::{self, BindingMode, Ty, TypeFoldable};\n use rustc_data_structures::fx::FxHashMap;\n@@ -10,6 +7,9 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::{HirId, Pat, PatKind};\n+use rustc_infer::infer;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::traits::Pattern;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::Span;\n use syntax::ast;"}, {"sha": "c0e33637fd0477577901ba29a38ff3b31874eb2a", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -77,15 +77,15 @@ use crate::check::FnCtxt;\n use crate::mem_categorization as mc;\n use crate::middle::region;\n use rustc::hir::map::Map;\n-use rustc::infer::outlives::env::OutlivesEnvironment;\n-use rustc::infer::{self, RegionObligation, SuppressRegionErrors};\n use rustc::ty::adjustment;\n use rustc::ty::subst::{GenericArgKind, SubstsRef};\n use rustc::ty::{self, Ty};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::PatKind;\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::{self, RegionObligation, SuppressRegionErrors};\n use rustc_span::Span;\n use std::mem;\n use std::ops::Deref;"}, {"sha": "f42611c63408bc018fd72052a53578cae37ab9c2", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -36,13 +36,13 @@ use crate::expr_use_visitor as euv;\n use crate::mem_categorization as mc;\n use crate::mem_categorization::PlaceBase;\n use rustc::hir::map::Map;\n-use rustc::infer::UpvarRegion;\n use rustc::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_infer::infer::UpvarRegion;\n use rustc_span::Span;\n use syntax::ast;\n "}, {"sha": "ef5188c94ff26cb5874eac65fe458995bac76d07", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,10 +1,8 @@\n use crate::check::{FnCtxt, Inherited};\n use crate::constrained_generic_params::{identify_constrained_generic_params, Parameter};\n \n-use rustc::infer::opaque_types::may_define_opaque_type;\n use rustc::middle::lang_items;\n use rustc::session::parse::feature_err;\n-use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{\n     self, AdtKind, GenericParamDefKind, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n@@ -13,6 +11,8 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir::def_id::DefId;\n use rustc_hir::ItemKind;\n+use rustc_infer::infer::opaque_types::may_define_opaque_type;\n+use rustc_infer::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use syntax::ast;\n@@ -223,7 +223,7 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n         _ => {}\n     }\n     if !trait_should_be_self.is_empty() {\n-        if rustc::traits::object_safety_violations(tcx, trait_def_id).is_empty() {\n+        if rustc_infer::traits::object_safety_violations(tcx, trait_def_id).is_empty() {\n             return;\n         }\n         let sugg = trait_should_be_self.iter().map(|span| (*span, \"Self\".to_string())).collect();"}, {"sha": "380e256c9fc9a0d15e92cf627b68a040ca8fea48", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -5,15 +5,15 @@\n use crate::check::FnCtxt;\n \n use rustc::hir::map::Map;\n-use rustc::infer::error_reporting::TypeAnnotationNeeded::E0282;\n-use rustc::infer::InferCtxt;\n use rustc::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdSet, DefIndex};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n+use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n+use rustc_infer::infer::InferCtxt;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n "}, {"sha": "aa39a191b3df6e3ee8ac3276c70c4d0e790273c1", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,21 +1,21 @@\n //! Check properties that are required by built-in traits and set\n //! up data structures required by type-checking/codegen.\n \n-use rustc::infer;\n-use rustc::infer::outlives::env::OutlivesEnvironment;\n-use rustc::infer::SuppressRegionErrors;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n use rustc::middle::region;\n-use rustc::traits::misc::{can_type_implement_copy, CopyImplementationError};\n-use rustc::traits::predicate_for_trait_def;\n-use rustc::traits::{self, ObligationCause, TraitEngine};\n use rustc::ty::adjustment::CoerceUnsizedInfo;\n use rustc::ty::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::ItemKind;\n+use rustc_infer::infer;\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::infer::{SuppressRegionErrors, TyCtxtInferExt};\n+use rustc_infer::traits::misc::{can_type_implement_copy, CopyImplementationError};\n+use rustc_infer::traits::predicate_for_trait_def;\n+use rustc_infer::traits::{self, ObligationCause, TraitEngine};\n \n pub fn check_trait(tcx: TyCtxt<'_>, trait_def_id: DefId) {\n     let lang_items = tcx.lang_items();"}, {"sha": "2a0d19b69fd936c9bc56048c7d3b06455ef795d3", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,10 +1,10 @@\n use crate::namespace::Namespace;\n-use rustc::traits::{self, SkipLeakCheck};\n use rustc::ty::{AssocItem, TyCtxt};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_infer::traits::{self, SkipLeakCheck};\n \n pub fn crate_inherent_impls_overlap_check(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);"}, {"sha": "d24ee5f156bcf2d14383e32d77e65a347e214784", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -5,11 +5,11 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n-use rustc::traits;\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_infer::traits;\n use rustc_span::Span;\n \n mod builtin;"}, {"sha": "6ce0da666a78792aa39aa4cc4216f52e2c5d2206", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,11 +1,12 @@\n //! Orphan checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n-use rustc::traits;\n use rustc::ty::{self, TyCtxt};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits;\n \n pub fn check(tcx: TyCtxt<'_>) {\n     let mut orphan = OrphanChecker { tcx };"}, {"sha": "2ba97055a680a590b3f22f2e7c0f9217e5506a69", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,6 +1,5 @@\n use rustc::hir::map::Map;\n use rustc::session::parse::feature_err;\n-use rustc::traits;\n use rustc::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n@@ -12,6 +11,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n+use rustc_infer::traits;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n "}, {"sha": "6666b1699943e71dc50f7b2da226e0ec5bd022ba", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -7,12 +7,12 @@ pub use self::ConsumeMode::*;\n // Export these here so that Clippy can use them.\n pub use mc::{Place, PlaceBase, Projection};\n \n-use rustc::infer::InferCtxt;\n use rustc::ty::{self, adjustment, TyCtxt};\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n use rustc_hir::def_id::DefId;\n use rustc_hir::PatKind;\n+use rustc_infer::infer::InferCtxt;\n \n use crate::mem_categorization as mc;\n use rustc_span::Span;"}, {"sha": "0a1c61b8aead86d50854818476fc3f54851ca2b0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -88,12 +88,10 @@ mod outlives;\n mod structured_errors;\n mod variance;\n \n-use rustc::infer::InferOk;\n use rustc::lint;\n use rustc::middle;\n use rustc::session;\n use rustc::session::config::EntryFnType;\n-use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n use rustc::ty::query::Providers;\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -103,6 +101,8 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::Node;\n+use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n+use rustc_infer::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n "}, {"sha": "a4569a147567f4635033de4c6dd858fc1cb6e2f9", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -48,15 +48,16 @@\n //! result of `*x'`, effectively, where `x'` is a `Categorization::Upvar` reference\n //! tied to `x`. The type of `x'` will be a borrowed pointer.\n \n-use rustc::infer::InferCtxt;\n use rustc::ty::adjustment;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt};\n+\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::PatKind;\n+use rustc_infer::infer::InferCtxt;\n use rustc_span::Span;\n \n #[derive(Clone, Debug)]"}, {"sha": "289923b45e64847a79d7e541e0f44a9e7cd360fb", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,7 +1,7 @@\n-use rustc::traits::auto_trait::{self, AutoTraitResult};\n use rustc::ty::{self, Region, RegionVid, TypeFoldable};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n+use rustc_infer::traits::auto_trait::{self, AutoTraitResult};\n \n use std::fmt::Debug;\n "}, {"sha": "f7968bf77226cb197811b59e8185b52f25546b5e", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -1,9 +1,9 @@\n-use rustc::infer::InferOk;\n-use rustc::traits;\n use rustc::ty::subst::Subst;\n use rustc::ty::{ToPredicate, WithConstness};\n use rustc_hir as hir;\n use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n+use rustc_infer::traits;\n use rustc_span::DUMMY_SP;\n \n use super::*;"}, {"sha": "ee432647084dacaa3a279c8c5f9c5f3afc6095ff", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -9,7 +9,6 @@ mod simplify;\n pub mod types;\n pub mod utils;\n \n-use rustc::infer::region_constraints::{Constraint, RegionConstraintData};\n use rustc::middle::lang_items;\n use rustc::middle::resolve_lifetime as rl;\n use rustc::middle::stability;\n@@ -22,6 +21,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym};"}, {"sha": "eab88b7165d6bc939a89e90d7e3e7f700ceaabfe", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a643ee8d693b8100e6f54f2a01ff7cde05eb65c5/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=a643ee8d693b8100e6f54f2a01ff7cde05eb65c5", "patch": "@@ -26,6 +26,7 @@ extern crate rustc_expand;\n extern crate rustc_feature;\n extern crate rustc_hir;\n extern crate rustc_index;\n+extern crate rustc_infer;\n extern crate rustc_interface;\n extern crate rustc_lexer;\n extern crate rustc_lint;"}]}