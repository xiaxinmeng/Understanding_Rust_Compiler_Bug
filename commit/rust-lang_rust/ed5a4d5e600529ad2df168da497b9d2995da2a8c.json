{"sha": "ed5a4d5e600529ad2df168da497b9d2995da2a8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkNWE0ZDVlNjAwNTI5YWQyZGYxNjhkYTQ5N2I5ZDI5OTVkYTJhOGM=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-05-19T22:19:29Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:09:04Z"}, "message": "Add feature gate and refactor", "tree": {"sha": "e7ded1af6f0cac2b79f853edc3498dc85be1538a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7ded1af6f0cac2b79f853edc3498dc85be1538a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed5a4d5e600529ad2df168da497b9d2995da2a8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed5a4d5e600529ad2df168da497b9d2995da2a8c", "html_url": "https://github.com/rust-lang/rust/commit/ed5a4d5e600529ad2df168da497b9d2995da2a8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed5a4d5e600529ad2df168da497b9d2995da2a8c/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "384db4f0cff4e7a01707a23be0fad697467c8b1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/384db4f0cff4e7a01707a23be0fad697467c8b1b", "html_url": "https://github.com/rust-lang/rust/commit/384db4f0cff4e7a01707a23be0fad697467c8b1b"}], "stats": {"total": 346, "additions": 164, "deletions": 182}, "files": [{"sha": "5941e71cfa2ba285c86f0c232c421009c4ddec95", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 161, "deletions": 182, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/ed5a4d5e600529ad2df168da497b9d2995da2a8c/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed5a4d5e600529ad2df168da497b9d2995da2a8c/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=ed5a4d5e600529ad2df168da497b9d2995da2a8c", "patch": "@@ -428,7 +428,9 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                                   -> (Vec<Constructor<'tcx>>, bool)\n {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n-    (match pcx.ty.sty {\n+    let exhaustive_integer_patterns = cx.tcx.features().exhaustive_integer_patterns;\n+    let mut value_constructors = false;\n+    let ctors = match pcx.ty.sty {\n         ty::TyBool => {\n             [true, false].iter().map(|&b| {\n                 ConstantValue(ty::Const::from_bool(cx.tcx, b))\n@@ -457,15 +459,14 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 .map(|v| Variant(v.did))\n                 .collect()\n         }\n-        ty::TyChar => {\n+        ty::TyChar if exhaustive_integer_patterns => {\n             let (min, max) = (0u128, char::MAX as u128);\n-            return (vec![\n-                ConstantRange(ty::Const::from_bits(cx.tcx, min, cx.tcx.types.char),\n-                              ty::Const::from_bits(cx.tcx, max, cx.tcx.types.char),\n-                              RangeEnd::Included),\n-            ], true)\n+            value_constructors = true;\n+            vec![ConstantRange(ty::Const::from_bits(cx.tcx, min, cx.tcx.types.char),\n+                               ty::Const::from_bits(cx.tcx, max, cx.tcx.types.char),\n+                               RangeEnd::Included)]\n         }\n-        ty::TyInt(int_ty) => {\n+        ty::TyInt(int_ty) if exhaustive_integer_patterns => {\n             use syntax::ast::IntTy::*;\n             let (min, max, ty) = match int_ty {\n                 Isize => (isize::MIN as i128, isize::MAX as i128, cx.tcx.types.isize),\n@@ -475,19 +476,16 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 I64   => (  i64::MIN as i128,   i64::MAX as i128, cx.tcx.types.i64),\n                 I128  => ( i128::MIN as i128,  i128::MAX as i128, cx.tcx.types.i128),\n             };\n-            return (vec![\n-                ConstantRange(\n-                    ty::Const::from_bits(cx.tcx, unsafe {\n-                        transmute::<i128, u128>(min)\n-                    }, ty),\n-                    ty::Const::from_bits(cx.tcx, unsafe {\n-                        transmute::<i128, u128>(max)\n-                    }, ty),\n-                    RangeEnd::Included\n-                ),\n-            ], true);\n+            value_constructors = true;\n+            vec![ConstantRange(ty::Const::from_bits(cx.tcx, unsafe {\n+                                   transmute::<i128, u128>(min)\n+                               }, ty),\n+                               ty::Const::from_bits(cx.tcx, unsafe {\n+                                   transmute::<i128, u128>(max)\n+                               }, ty),\n+                               RangeEnd::Included)]\n         }\n-        ty::TyUint(uint_ty) => {\n+        ty::TyUint(uint_ty) if exhaustive_integer_patterns => {\n             use syntax::ast::UintTy::*;\n             let (min, (max, ty)) = (0u128, match uint_ty {\n                 Usize => (usize::MAX as u128, cx.tcx.types.usize),\n@@ -497,11 +495,10 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 U64   => (  u64::MAX as u128, cx.tcx.types.u64),\n                 U128  => ( u128::MAX as u128, cx.tcx.types.u128),\n             });\n-            return (vec![\n-                ConstantRange(ty::Const::from_bits(cx.tcx, min, ty),\n-                              ty::Const::from_bits(cx.tcx, max, ty),\n-                              RangeEnd::Included),\n-            ], true);\n+            value_constructors = true;\n+            vec![ConstantRange(ty::Const::from_bits(cx.tcx, min, ty),\n+                               ty::Const::from_bits(cx.tcx, max, ty),\n+                               RangeEnd::Included)]\n         }\n         _ => {\n             if cx.is_uninhabited(pcx.ty) {\n@@ -510,7 +507,8 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                 vec![Single]\n             }\n         }\n-    }, false)\n+    };\n+    (ctors, value_constructors)\n }\n \n fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n@@ -615,6 +613,94 @@ fn max_slice_length<'p, 'a: 'p, 'tcx: 'a, I>(\n     cmp::max(max_fixed_len + 1, max_prefix_len + max_suffix_len)\n }\n \n+/// An inclusive interval, used for precise integer exhaustiveness checking.\n+struct Interval<'tcx> {\n+    pub lo: u128,\n+    pub hi: u128,\n+    pub ty: Ty<'tcx>,\n+}\n+\n+impl<'tcx> Interval<'tcx> {\n+    fn from_ctor(ctor: &Constructor<'tcx>) -> Option<Interval<'tcx>> {\n+        match ctor {\n+            ConstantRange(lo, hi, end) => {\n+                assert_eq!(lo.ty, hi.ty);\n+                let ty = lo.ty;\n+                if let Some(lo) = lo.assert_bits(ty) {\n+                    if let Some(hi) = hi.assert_bits(ty) {\n+                        // Make sure the interval is well-formed.\n+                        return if lo > hi || lo == hi && *end == RangeEnd::Excluded {\n+                            None\n+                        } else {\n+                            let offset = (*end == RangeEnd::Excluded) as u128;\n+                            Some(Interval { lo, hi: hi - offset, ty })\n+                        };\n+                    }\n+                }\n+                None\n+            }\n+            ConstantValue(val) => {\n+                let ty = val.ty;\n+                val.assert_bits(ty).map(|val| Interval { lo: val, hi: val, ty })\n+            }\n+            Single | Variant(_) | Slice(_) => {\n+                None\n+            }\n+        }\n+    }\n+\n+    fn into_inner(self) -> (u128, u128) {\n+        (self.lo, self.hi)\n+    }\n+}\n+\n+/// Given a pattern in a `match` and a collection of ranges corresponding to the\n+/// domain of values of a type (say, an integer), return a new collection of ranges\n+/// corresponding to those ranges minus the ranges covered by the pattern.\n+fn ranges_subtract_pattern<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n+                                     pat_ctor: &Constructor<'tcx>,\n+                                     ranges: Vec<Constructor<'tcx>>)\n+                                     -> Vec<Constructor<'tcx>> {\n+    if let Some(pat_interval) = Interval::from_ctor(pat_ctor) {\n+        let mut remaining_ranges = vec![];\n+        let mut ranges: Vec<_> = ranges.into_iter().filter_map(|r| {\n+            Interval::from_ctor(&r).map(|i| i.into_inner())\n+        }).collect();\n+        for (subrange_lo, subrange_hi) in ranges {\n+            if pat_interval.lo > subrange_hi || pat_interval.hi < subrange_lo {\n+                // The pattern doesn't intersect with the subrange at all,\n+                // so the subrange remains untouched.\n+                remaining_ranges.push((subrange_lo, subrange_hi));\n+            } else if pat_interval.lo <= subrange_lo && pat_interval.hi >= subrange_hi {\n+                // The pattern entirely covers the subrange of values,\n+                // so we no longer have to consider this subrange_\n+            } else if pat_interval.lo <= subrange_lo {\n+                // The pattern intersects a lower section of the subrange,\n+                // so only the upper section will remain.\n+                remaining_ranges.push((pat_interval.hi + 1, subrange_hi));\n+            } else if pat_interval.hi >= subrange_hi {\n+                // The pattern intersects an upper section of the subrange,\n+                // so only the lower section will remain.\n+                remaining_ranges.push((subrange_lo, pat_interval.lo - 1));\n+            } else {\n+                // The pattern intersects the middle of the subrange,\n+                // so we create two ranges either side of the intersection.)\n+                remaining_ranges.push((subrange_lo, pat_interval.lo));\n+                remaining_ranges.push((pat_interval.hi, subrange_hi));\n+            }\n+        }\n+        // Convert the remaining ranges from pairs to inclusive `ConstantRange`s.\n+        let ty = pat_interval.ty;\n+        remaining_ranges.into_iter().map(|(lo, hi)| {\n+            ConstantRange(ty::Const::from_bits(cx.tcx, lo, ty),\n+                          ty::Const::from_bits(cx.tcx, hi, ty),\n+                          RangeEnd::Included)\n+        }).collect()\n+    } else {\n+        ranges\n+    }\n+}\n+\n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n /// The algorithm from the paper has been modified to correctly handle empty\n /// types. The changes are:\n@@ -702,163 +788,50 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             pat_constructors(cx, row[0], pcx).unwrap_or(vec![])\n         }).collect();\n         debug!(\"used_ctors = {:#?}\", used_ctors);\n-        let (all_ctors, _ranged) = all_constructors(cx, pcx);\n+        // `all_ctors` are all the constructors for the given type, which\n+        // should all be represented (or caught with the wild pattern `_`).\n+        // `value_constructors` is true if we may exhaustively consider all\n+        // the possible values (e.g. integers) of a type as its constructors.\n+        let (all_ctors, value_constructors) = all_constructors(cx, pcx);\n         debug!(\"all_ctors = {:#?}\", all_ctors);\n \n-        fn to_inc_range_pair<'tcx>(_tcx: TyCtxt<'_, '_, '_>, ctor: &Constructor<'tcx>) -> Option<(u128, u128, Ty<'tcx>)> {\n-            match ctor {\n-                Single | Variant(_) | Slice(_) => {\n-                    None\n-                }\n-                ConstantValue(const_) => {\n-                    if let Some(val) = const_.assert_bits(const_.ty) {\n-                        return Some((val, val, const_.ty));\n-                    }\n-                    None\n-                }\n-                ConstantRange(lo, hi, end) => {\n-                    let ty = lo.ty;\n-                    if let Some(lo) = lo.assert_bits(lo.ty) {\n-                        if let Some(hi) = hi.assert_bits(hi.ty) {\n-                            if lo > hi || lo == hi && end == &RangeEnd::Excluded {\n-                                return None;\n-                            } else if end == &RangeEnd::Included {\n-                                return Some((lo, hi, ty));\n-                            } else {\n-                                return Some((lo, hi - 1, ty));\n-                            }\n-                        }\n-                    }\n-                    None\n-                }\n-            }\n-        }\n-\n-        fn intersect<'a, 'tcx>(\n-                    _deb: bool,\n-                    cx: &mut MatchCheckCtxt<'a, 'tcx>,\n-                    ranges: Vec<Constructor<'tcx>>,\n-                     ctor: &Constructor<'tcx>)\n-                     -> (Vec<Constructor<'tcx>>, bool) {\n-            if let Some((lo1, hi1, ty)) = to_inc_range_pair(cx.tcx, ctor) {\n-                let mut ctor_was_useful = false;\n-                // values only consists of ranges\n-                let mut new_ranges = vec![];\n-                let mut ranges: Vec<_> =\n-                    ranges.into_iter().filter_map(|r| {\n-                        to_inc_range_pair(cx.tcx, &r).map(|(lo, hi, _)| (lo, hi))\n-                    }).collect();\n-                while let Some((lo2, hi2)) = ranges.pop() {\n-                    // eprintln!(\"{:?} {:?}\", (lo2, hi2), (lo1, hi1));\n-                    if lo1 <= lo2 && hi1 >= hi2 {\n-                        if _deb { eprintln!(\"case 1\"); }\n-                        ctor_was_useful = true;\n-                        continue;\n-                    }\n-                    if lo1 > hi2 || hi1 < lo2 {\n-                        if _deb { eprintln!(\"case 2\"); }\n-                        new_ranges.push((lo2, hi2));\n-                        continue;\n-                    }\n-                    if lo1 <= lo2 {\n-                        if _deb { eprintln!(\"case 3\"); }\n-                        ctor_was_useful = true;\n-                        if (hi1 + 1, hi2) == (lo2, hi2) {\n-                            new_ranges.push((hi1 + 1, hi2));\n-                        } else {\n-                            ranges.push((hi1 + 1, hi2));\n-                        }\n-                        continue;\n-                    }\n-                    if hi1 >= hi2 {\n-                        if _deb { eprintln!(\"case 4\"); }\n-                        ctor_was_useful = true;\n-                        if (lo2, lo1 - 1) == (lo2, hi2) {\n-                            new_ranges.push((lo2, lo1 - 1));\n-                        } else {\n-                            ranges.push((lo2, lo1 - 1));\n-                        }\n-                        continue;\n-                    }\n-                    ctor_was_useful = true;\n-                    ranges.push((lo2, lo1));\n-                    ranges.push((hi1, hi2));\n-                    if _deb { eprintln!(\"case 5\"); }\n-                }\n-                // transform ranges to proper format\n-                (new_ranges.into_iter().map(|(lo, hi)| {\n-                    ConstantRange(ty::Const::from_bits(cx.tcx, lo, ty),\n-                                  ty::Const::from_bits(cx.tcx, hi, ty),\n-                                  RangeEnd::Included)\n-                }).collect(), ctor_was_useful)\n-            } else {\n-                (ranges, false)\n-            }\n-        }\n-\n-        // `used_ctors` are all the constructors that appear in patterns (must check if guards)\n-        // `all_ctors` are all the necessary constructors\n+        // `missing_ctors` are those that should have appeared\n+        // as patterns in the `match` expression, but did not.\n         let mut missing_ctors = vec![];\n-        let mut all_actual_ctors = vec![];\n         'req: for req_ctor in all_ctors.clone() {\n-            if _deb {\n-                eprintln!(\"req_ctor before {:?}\", req_ctor);\n-            }\n-            let mut cur = vec![req_ctor.clone()];\n+            let mut sub_ctors = vec![req_ctor.clone()];\n+            // The only constructor patterns for which it is valid to\n+            // treat the values as constructors are ranges (see\n+            // `all_constructors` for details).\n+            let consider_value_constructors = value_constructors && match req_ctor {\n+                ConstantRange(..) => true,\n+                _ => false,\n+            };\n             for used_ctor in &used_ctors {\n-                if _deb {\n-                    eprintln!(\"cut {:?}\", used_ctor);\n-                }\n-                if cur.iter().all(|ctor| {\n-                    match ctor {\n-                        ConstantRange(..) => true,\n-                        _ => false,\n-                    }\n-                }) {\n-                    let (cur2, ctor_was_useful) = intersect(_deb, cx, cur, used_ctor);\n-                    cur = cur2;\n-                    if ctor_was_useful {\n-                        all_actual_ctors.push(used_ctor.clone());\n-                    }\n-                    if cur.is_empty() {\n+                if consider_value_constructors {\n+                    sub_ctors = ranges_subtract_pattern(cx, used_ctor, sub_ctors);\n+                    // If the constructor patterns that have been considered so far\n+                    // already cover the entire range of values, then we the\n+                    // constructor is not missing, and we can move on to the next one.\n+                    if sub_ctors.is_empty() {\n                         continue 'req;\n                     }\n                 } else {\n-                    if used_ctor == &req_ctor {\n+                    // If the pattern for the required constructor\n+                    // appears in the `match`, then it is not missing,\n+                    // and we can move on to the next one.\n+                    if *used_ctor == req_ctor {\n                         continue 'req;\n                     }\n                 }\n             }\n-            if _deb {\n-                eprintln!(\"req_ctor after {:?}\", cur);\n-            }\n-            missing_ctors.extend(cur);\n+            // If a constructor has not been matched, then it is missing.\n+            // We add `sub_ctors` instead of `req_ctor`, because then we can\n+            // provide more detailed error information about precisely which\n+            // ranges have been omitted.\n+            missing_ctors.extend(sub_ctors);\n         }\n \n-        // if _ranged {\n-        //     missing_ctors = missing_ctors.into_iter().map(|ctor| {\n-        //         match ctor {\n-        //             ConstantRange(lo, hi, RangeEnd::Included) if lo == hi => {\n-        //                 ConstantValue(lo)\n-        //             }\n-        //             _ => ctor,\n-        //         }\n-        //     }).collect();\n-        // }\n-\n-        // let missing_ctors: Vec<Constructor> = all_ctors.iter().filter(|c| {\n-        //     !used_ctors.contains(*c)\n-        // }).cloned().collect();\n-\n-        if _deb {\n-            eprintln!(\"used_ctors {:?}\", used_ctors);\n-            eprintln!(\"missing_ctors {:?}\", missing_ctors);\n-        }\n-\n-        // if !all_actual_ctors.is_empty() {\n-        //     all_ctors = all_actual_ctors;\n-        // }\n-\n         // `missing_ctors` is the set of constructors from the same type as the\n         // first column of `matrix` that are matched only by wildcard patterns\n         // from the first column.\n@@ -890,16 +863,16 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive;\n \n         if missing_ctors.is_empty() && !is_non_exhaustive {\n-            if _ranged && _deb {\n-                return NotUseful;\n+            if value_constructors {\n+                // If we've successfully matched every value\n+                // of the type, then we're done.\n+                NotUseful\n+            } else {\n+                all_ctors.into_iter().map(|c| {\n+                    is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n+                }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n             }\n-            let z = all_ctors.into_iter().map(|c| {\n-                is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n-            }).find(|result| result.is_useful()).unwrap_or(NotUseful);\n-            if _deb { eprintln!(\"ABC 1 {:?}\", z); }\n-            z\n         } else {\n-            if _deb { eprintln!(\"ABC 2\"); }\n             let matrix = rows.iter().filter_map(|r| {\n                 if r[0].is_wildcard() {\n                     Some(r[1..].to_vec())\n@@ -909,7 +882,6 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             }).collect();\n             match is_useful(cx, &matrix, &v[1..], witness) {\n                 UsefulWithWitness(pats) => {\n-                    if _deb { eprintln!(\"ABC 3\"); }\n                     let cx = &*cx;\n                     // In this case, there's at least one \"free\"\n                     // constructor that is only matched against by\n@@ -956,7 +928,6 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     // satisfied with `(_, _, true)`. In this case,\n                     // `used_ctors` is empty.\n                     let new_witnesses = if is_non_exhaustive || used_ctors.is_empty() {\n-                        if _deb { eprintln!(\"ABC 4\"); }\n                         // All constructors are unused. Add wild patterns\n                         // rather than each individual constructor\n                         pats.into_iter().map(|mut witness| {\n@@ -968,25 +939,33 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                             witness\n                         }).collect()\n                     } else {\n-                        if _deb { eprintln!(\"ABC 5\"); }\n-                        if _ranged {\n+                        if value_constructors {\n+                            // If we've been trying to exhaustively match\n+                            // over the domain of values for a type,\n+                            // then we can provide better diagnostics\n+                            // regarding which values were missing.\n                             missing_ctors.into_iter().map(|ctor| {\n                                 match ctor {\n+                                    // A constant range of length 1 is simply\n+                                    // a constant value.\n                                     ConstantRange(lo, hi, _) if lo == hi => {\n                                         Witness(vec![Pattern {\n                                             ty: pcx.ty,\n                                             span: DUMMY_SP,\n                                             kind: box PatternKind::Constant { value: lo },\n                                         }])\n                                     }\n+                                    // We always report missing intervals\n+                                    // in terms of inclusive ranges.\n                                     ConstantRange(lo, hi, end) => {\n                                         Witness(vec![Pattern {\n                                             ty: pcx.ty,\n                                             span: DUMMY_SP,\n                                             kind: box PatternKind::Range { lo, hi, end },\n                                         }])\n                                     },\n-                                    _ => bug!(\"this shouldn't be happening\"),\n+                                    _ => bug!(\"`ranges_subtract_pattern` should only produce \\\n+                                               `ConstantRange`s\"),\n                                 }\n                             }).collect()\n                         } else {"}, {"sha": "6109e5ecb61c09dabcce8531619149038fd9c82c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ed5a4d5e600529ad2df168da497b9d2995da2a8c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed5a4d5e600529ad2df168da497b9d2995da2a8c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ed5a4d5e600529ad2df168da497b9d2995da2a8c", "patch": "@@ -487,6 +487,9 @@ declare_features! (\n     // 'a: { break 'a; }\n     (active, label_break_value, \"1.28.0\", Some(48594), None),\n \n+    // Integer match exhaustiveness checking\n+    (active, exhaustive_integer_patterns, \"1.28.0\", Some(50907), None),\n+\n     // #[panic_implementation]\n     (active, panic_implementation, \"1.28.0\", Some(44489), None),\n "}]}