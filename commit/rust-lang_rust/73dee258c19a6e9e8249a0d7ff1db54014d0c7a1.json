{"sha": "73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczZGVlMjU4YzE5YTZlOWU4MjQ5YTBkN2ZmMWRiNTQwMTRkMGM3YTE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-11T00:00:05Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-15T17:39:27Z"}, "message": "hygiene: Remove `Option`s from functions returning `ExpnInfo`\n\nThe expansion info is not optional and should always exist", "tree": {"sha": "c8d742151c2b460235059195250a8fb27ef170d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8d742151c2b460235059195250a8fb27ef170d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "html_url": "https://github.com/rust-lang/rust/commit/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cb28b6617e25b74389f1cee2ec0335c2ccfb865", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb28b6617e25b74389f1cee2ec0335c2ccfb865", "html_url": "https://github.com/rust-lang/rust/commit/6cb28b6617e25b74389f1cee2ec0335c2ccfb865"}], "stats": {"total": 253, "additions": 98, "deletions": 155}, "files": [{"sha": "29106fe000bb62986a3e4258fd662338d0b16f56", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -9,7 +9,6 @@ use errors::Applicability;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast::{Ident, Item, ItemKind};\n use syntax::symbol::{sym, Symbol};\n-use syntax_pos::ExpnInfo;\n \n declare_tool_lint! {\n     pub rustc::DEFAULT_HASH_TYPES,\n@@ -228,30 +227,20 @@ impl EarlyLintPass for LintPassImpl {\n         if let ItemKind::Impl(_, _, _, _, Some(lint_pass), _, _) = &item.node {\n             if let Some(last) = lint_pass.path.segments.last() {\n                 if last.ident.name == sym::LintPass {\n-                    match &lint_pass.path.span.ctxt().outer_expn_info() {\n-                        Some(info) if is_lint_pass_expansion(info) => {}\n-                        _ => {\n-                            cx.struct_span_lint(\n-                                LINT_PASS_IMPL_WITHOUT_MACRO,\n-                                lint_pass.path.span,\n-                                \"implementing `LintPass` by hand\",\n-                            )\n-                            .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n-                            .emit();\n-                        }\n+                    let expn_info = lint_pass.path.span.ctxt().outer_expn_info();\n+                    let call_site = expn_info.call_site;\n+                    if expn_info.kind.descr() != sym::impl_lint_pass &&\n+                       call_site.ctxt().outer_expn_info().kind.descr() != sym::declare_lint_pass {\n+                        cx.struct_span_lint(\n+                            LINT_PASS_IMPL_WITHOUT_MACRO,\n+                            lint_pass.path.span,\n+                            \"implementing `LintPass` by hand\",\n+                        )\n+                        .help(\"try using `declare_lint_pass!` or `impl_lint_pass!` instead\")\n+                        .emit();\n                     }\n                 }\n             }\n         }\n     }\n }\n-\n-fn is_lint_pass_expansion(expn_info: &ExpnInfo) -> bool {\n-    if expn_info.kind.descr() == sym::impl_lint_pass {\n-        true\n-    } else if let Some(info) = expn_info.call_site.ctxt().outer_expn_info() {\n-        info.kind.descr() == sym::declare_lint_pass\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "3729ee81f5c6524103e5ea32d6f894a62c70e948", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -885,21 +885,16 @@ pub fn provide(providers: &mut Providers<'_>) {\n /// This is used to test whether a lint should not even begin to figure out whether it should\n /// be reported on the current node.\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n-    let info = match span.ctxt().outer_expn_info() {\n-        Some(info) => info,\n-        // no ExpnInfo means this span doesn't come from a macro\n-        None => return false,\n-    };\n-\n-    match info.kind {\n+    let expn_info = span.ctxt().outer_expn_info();\n+    match expn_info.kind {\n         ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n         ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n-            if info.def_site.is_dummy() {\n+            if expn_info.def_site.is_dummy() {\n                 // dummy span for the def_site means it's an external macro\n                 return true;\n             }\n-            match sess.source_map().span_to_snippet(info.def_site) {\n+            match sess.source_map().span_to_snippet(expn_info.def_site) {\n                 Ok(code) => !code.starts_with(\"macro_rules\"),\n                 // no snippet = external macro or compiler-builtin expansion\n                 Err(_) => true,\n@@ -911,10 +906,8 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n \n /// Returns whether `span` originates in a derive macro's expansion\n pub fn in_derive_expansion(span: Span) -> bool {\n-    if let Some(info) = span.ctxt().outer_expn_info() {\n-        if let ExpnKind::Macro(MacroKind::Derive, _) = info.kind {\n-            return true;\n-        }\n+    if let ExpnKind::Macro(MacroKind::Derive, _) = span.ctxt().outer_expn_info().kind {\n+        return true;\n     }\n     false\n }"}, {"sha": "20568d4709b64b2e6faf726b1cc80284058c93a9", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -36,7 +36,7 @@ use errors::{Applicability, DiagnosticBuilder};\n use std::fmt;\n use syntax::ast;\n use syntax::symbol::sym;\n-use syntax_pos::{DUMMY_SP, Span, ExpnInfo, ExpnKind};\n+use syntax_pos::{DUMMY_SP, Span, ExpnKind};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_fulfillment_errors(&self,\n@@ -61,9 +61,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // We want to ignore desugarings here: spans are equivalent even\n             // if one is the result of a desugaring and the other is not.\n             let mut span = error.obligation.cause.span;\n-            if let Some(ExpnInfo { kind: ExpnKind::Desugaring(_), def_site, .. })\n-                    = span.ctxt().outer_expn_info() {\n-                span = def_site;\n+            let expn_info = span.ctxt().outer_expn_info();\n+            if let ExpnKind::Desugaring(_) = expn_info.kind {\n+                span = expn_info.call_site;\n             }\n \n             error_map.entry(span).or_default().push("}, {"sha": "2286271b9eb4f4e487b63aa86ddcf08c793b3a74", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -820,18 +820,14 @@ where\n             TAG_NO_EXPANSION_INFO.encode(self)\n         } else {\n             let (expn_id, expn_info) = span_data.ctxt.outer_expn_with_info();\n-            if let Some(expn_info) = expn_info {\n-                if let Some(pos) = self.expn_info_shorthands.get(&expn_id).cloned() {\n-                    TAG_EXPANSION_INFO_SHORTHAND.encode(self)?;\n-                    pos.encode(self)\n-                } else {\n-                    TAG_EXPANSION_INFO_INLINE.encode(self)?;\n-                    let pos = AbsoluteBytePos::new(self.position());\n-                    self.expn_info_shorthands.insert(expn_id, pos);\n-                    expn_info.encode(self)\n-                }\n+            if let Some(pos) = self.expn_info_shorthands.get(&expn_id).cloned() {\n+                TAG_EXPANSION_INFO_SHORTHAND.encode(self)?;\n+                pos.encode(self)\n             } else {\n-                TAG_NO_EXPANSION_INFO.encode(self)\n+                TAG_EXPANSION_INFO_INLINE.encode(self)?;\n+                let pos = AbsoluteBytePos::new(self.position());\n+                self.expn_info_shorthands.insert(expn_id, pos);\n+                expn_info.encode(self)\n             }\n         }\n     }"}, {"sha": "240264a98220d85e267e1a1db26e3fd19fab990a", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -1775,10 +1775,7 @@ impl SharedEmitterMain {\n                     }\n                 }\n                 Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n-                    match ExpnId::from_u32(cookie).expn_info() {\n-                        Some(ei) => sess.span_err(ei.call_site, &msg),\n-                        None     => sess.err(&msg),\n-                    }\n+                    sess.span_err(ExpnId::from_u32(cookie).expn_info().call_site, &msg)\n                 }\n                 Ok(SharedEmitterMessage::AbortIfErrors) => {\n                     sess.abort_if_errors();"}, {"sha": "1bb05bda69f5b09f3d75265f5fad7da05af710fb", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -517,9 +517,8 @@ impl EarlyLintPass for UnusedParens {\n                 // trigger in situations that macro authors shouldn't have to care about, e.g.,\n                 // when a parenthesized token tree matched in one macro expansion is matched as\n                 // an expression in another and used as a fn/method argument (Issue #47775)\n-                if e.span.ctxt().outer_expn_info()\n-                    .map_or(false, |info| info.call_site.from_expansion()) {\n-                        return;\n+                if e.span.ctxt().outer_expn_info().call_site.from_expansion() {\n+                    return;\n                 }\n                 let msg = format!(\"{} argument\", call_kind);\n                 for arg in args_to_check {"}, {"sha": "97b0f825ee94e8832708fafc20cbdd10fa4ab6df", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -346,8 +346,7 @@ impl<'a> Resolver<'a> {\n \n         // Possibly apply the macro helper hack\n         if kind == Some(MacroKind::Bang) && path.len() == 1 &&\n-           path[0].ident.span.ctxt().outer_expn_info()\n-               .map_or(false, |info| info.local_inner_macros) {\n+           path[0].ident.span.ctxt().outer_expn_info().local_inner_macros {\n             let root = Ident::new(kw::DollarCrate, path[0].ident.span);\n             path.insert(0, Segment::from_ident(root));\n         }"}, {"sha": "8eacb96e3ff966fc70212bff57ed9c160b3a2899", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -756,10 +756,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }\n     pub fn cfg(&self) -> &ast::CrateConfig { &self.parse_sess.config }\n     pub fn call_site(&self) -> Span {\n-        match self.current_expansion.id.expn_info() {\n-            Some(expn_info) => expn_info.call_site,\n-            None => DUMMY_SP,\n-        }\n+        self.current_expansion.id.expn_info().call_site\n     }\n     pub fn backtrace(&self) -> SyntaxContext {\n         SyntaxContext::root().apply_mark(self.current_expansion.id)\n@@ -772,17 +769,13 @@ impl<'a> ExtCtxt<'a> {\n         let mut ctxt = self.backtrace();\n         let mut last_macro = None;\n         loop {\n-            if ctxt.outer_expn_info().map_or(None, |info| {\n-                if info.kind.descr() == sym::include {\n-                    // Stop going up the backtrace once include! is encountered\n-                    return None;\n-                }\n-                ctxt = info.call_site.ctxt();\n-                last_macro = Some(info.call_site);\n-                Some(())\n-            }).is_none() {\n-                break\n+            let expn_info = ctxt.outer_expn_info();\n+            // Stop going up the backtrace once include! is encountered\n+            if expn_info.is_root() || expn_info.kind.descr() == sym::include {\n+                break;\n             }\n+            ctxt = expn_info.call_site.ctxt();\n+            last_macro = Some(expn_info.call_site);\n         }\n         last_macro\n     }"}, {"sha": "6f3e8f14b0b22f4611217ea6a91cfa7f2d5316e9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -475,7 +475,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n \n         if self.cx.current_expansion.depth > self.cx.ecfg.recursion_limit {\n-            let info = self.cx.current_expansion.id.expn_info().unwrap();\n+            let info = self.cx.current_expansion.id.expn_info();\n             let suggested_limit = self.cx.ecfg.recursion_limit * 2;\n             let mut err = self.cx.struct_span_err(info.call_site,\n                 &format!(\"recursion limit reached while expanding the macro `{}`\","}, {"sha": "d370431a5daef2f86d98af9e64134c6966d7ddf7", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -362,7 +362,7 @@ pub(crate) struct Rustc<'a> {\n impl<'a> Rustc<'a> {\n     pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         // No way to determine def location for a proc macro right now, so use call location.\n-        let location = cx.current_expansion.id.expn_info().unwrap().call_site;\n+        let location = cx.current_expansion.id.expn_info().call_site;\n         let to_span = |transparency| {\n             location.with_ctxt(\n                 SyntaxContext::root()\n@@ -677,7 +677,7 @@ impl server::Span for Rustc<'_> {\n         self.sess.source_map().lookup_char_pos(span.lo()).file\n     }\n     fn parent(&mut self, span: Self::Span) -> Option<Self::Span> {\n-        span.ctxt().outer_expn_info().map(|i| i.call_site)\n+        span.parent()\n     }\n     fn source(&mut self, span: Self::Span) -> Self::Span {\n         span.source_callsite()"}, {"sha": "89725d8b3395c8ab5dde64f80a705a0bac695c6c", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -13,7 +13,6 @@ mod generics;\n use crate::ast::{self, AttrStyle, Attribute, Arg, BindingMode, StrStyle, SelfKind};\n use crate::ast::{FnDecl, Ident, IsAsync, MacDelimiter, Mutability, TyKind};\n use crate::ast::{Visibility, VisibilityKind, Unsafety, CrateSugar};\n-use crate::ext::hygiene::SyntaxContext;\n use crate::source_map::{self, respan};\n use crate::parse::{SeqSep, literal, token};\n use crate::parse::lexer::UnmatchedBrace;"}, {"sha": "da7eb6add41a9927f5a77f06946434045492a1ad", "filename": "src/libsyntax/source_map.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsource_map.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -31,12 +31,13 @@ mod tests;\n /// otherwise return the call site span up to the `enclosing_sp` by\n /// following the `expn_info` chain.\n pub fn original_sp(sp: Span, enclosing_sp: Span) -> Span {\n-    let call_site1 = sp.ctxt().outer_expn_info().map(|ei| ei.call_site);\n-    let call_site2 = enclosing_sp.ctxt().outer_expn_info().map(|ei| ei.call_site);\n-    match (call_site1, call_site2) {\n-        (None, _) => sp,\n-        (Some(call_site1), Some(call_site2)) if call_site1 == call_site2 => sp,\n-        (Some(call_site1), _) => original_sp(call_site1, enclosing_sp),\n+    let expn_info1 = sp.ctxt().outer_expn_info();\n+    let expn_info2 = enclosing_sp.ctxt().outer_expn_info();\n+    if expn_info1.is_root() ||\n+       !expn_info2.is_root() && expn_info1.call_site == expn_info2.call_site {\n+        sp\n+    } else {\n+        original_sp(expn_info1.call_site, enclosing_sp)\n     }\n }\n "}, {"sha": "743bd437ee5b698e31bf789b3ddfd4000902df5d", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 22, "deletions": 36, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -112,8 +112,8 @@ impl ExpnId {\n     }\n \n     #[inline]\n-    pub fn expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(self).cloned())\n+    pub fn expn_info(self) -> ExpnInfo {\n+        HygieneData::with(|data| data.expn_info(self).clone())\n     }\n \n     #[inline]\n@@ -139,12 +139,9 @@ impl ExpnId {\n     #[inline]\n     pub fn looks_like_proc_macro_derive(self) -> bool {\n         HygieneData::with(|data| {\n-            if data.default_transparency(self) == Transparency::Opaque {\n-                if let Some(expn_info) = data.expn_info(self) {\n-                    if let ExpnKind::Macro(MacroKind::Derive, _) = expn_info.kind {\n-                        return true;\n-                    }\n-                }\n+            let expn_info = data.expn_info(self);\n+            if let ExpnKind::Macro(MacroKind::Derive, _) = expn_info.kind {\n+                return expn_info.default_transparency == Transparency::Opaque;\n             }\n             false\n         })\n@@ -190,16 +187,9 @@ impl HygieneData {\n         self.expn_data[expn_id.0 as usize].parent\n     }\n \n-    fn expn_info(&self, expn_id: ExpnId) -> Option<&ExpnInfo> {\n-        if expn_id != ExpnId::root() {\n-            Some(self.expn_data[expn_id.0 as usize].expn_info.as_ref()\n-                     .expect(\"no expansion info for an expansion ID\"))\n-        } else {\n-            // FIXME: Some code relies on `expn_info().is_none()` meaning \"no expansion\".\n-            // Introduce a method for checking for \"no expansion\" instead and always return\n-            // `ExpnInfo` from this function instead of the `Option`.\n-            None\n-        }\n+    fn expn_info(&self, expn_id: ExpnId) -> &ExpnInfo {\n+        self.expn_data[expn_id.0 as usize].expn_info.as_ref()\n+            .expect(\"no expansion info for an expansion ID\")\n     }\n \n     fn is_descendant_of(&self, mut expn_id: ExpnId, ancestor: ExpnId) -> bool {\n@@ -212,12 +202,6 @@ impl HygieneData {\n         true\n     }\n \n-    fn default_transparency(&self, expn_id: ExpnId) -> Transparency {\n-        self.expn_info(expn_id).map_or(\n-            Transparency::SemiTransparent, |einfo| einfo.default_transparency\n-        )\n-    }\n-\n     fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].opaque\n     }\n@@ -256,11 +240,7 @@ impl HygieneData {\n \n     fn walk_chain(&self, mut span: Span, to: SyntaxContext) -> Span {\n         while span.from_expansion() && span.ctxt() != to {\n-            if let Some(info) = self.expn_info(self.outer_expn(span.ctxt())) {\n-                span = info.call_site;\n-            } else {\n-                break;\n-            }\n+            span = self.expn_info(self.outer_expn(span.ctxt())).call_site;\n         }\n         span\n     }\n@@ -275,7 +255,9 @@ impl HygieneData {\n \n     fn apply_mark(&mut self, ctxt: SyntaxContext, expn_id: ExpnId) -> SyntaxContext {\n         assert_ne!(expn_id, ExpnId::root());\n-        self.apply_mark_with_transparency(ctxt, expn_id, self.default_transparency(expn_id))\n+        self.apply_mark_with_transparency(\n+            ctxt, expn_id, self.expn_info(expn_id).default_transparency\n+        )\n     }\n \n     fn apply_mark_with_transparency(&mut self, ctxt: SyntaxContext, expn_id: ExpnId,\n@@ -285,8 +267,7 @@ impl HygieneData {\n             return self.apply_mark_internal(ctxt, expn_id, transparency);\n         }\n \n-        let call_site_ctxt =\n-            self.expn_info(expn_id).map_or(SyntaxContext::root(), |info| info.call_site.ctxt());\n+        let call_site_ctxt = self.expn_info(expn_id).call_site.ctxt();\n         let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n             self.modern(call_site_ctxt)\n         } else {\n@@ -581,17 +562,17 @@ impl SyntaxContext {\n     /// `ctxt.outer_expn_info()` is equivalent to but faster than\n     /// `ctxt.outer_expn().expn_info()`.\n     #[inline]\n-    pub fn outer_expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(data.outer_expn(self)).cloned())\n+    pub fn outer_expn_info(self) -> ExpnInfo {\n+        HygieneData::with(|data| data.expn_info(data.outer_expn(self)).clone())\n     }\n \n     /// `ctxt.outer_expn_with_info()` is equivalent to but faster than\n     /// `{ let outer = ctxt.outer_expn(); (outer, outer.expn_info()) }`.\n     #[inline]\n-    pub fn outer_expn_with_info(self) -> (ExpnId, Option<ExpnInfo>) {\n+    pub fn outer_expn_with_info(self) -> (ExpnId, ExpnInfo) {\n         HygieneData::with(|data| {\n             let outer = data.outer_expn(self);\n-            (outer, data.expn_info(outer).cloned())\n+            (outer, data.expn_info(outer).clone())\n         })\n     }\n \n@@ -681,6 +662,11 @@ impl ExpnInfo {\n             ..ExpnInfo::default(kind, call_site, edition)\n         }\n     }\n+\n+    #[inline]\n+    pub fn is_root(&self) -> bool {\n+        if let ExpnKind::Root = self.kind { true } else { false }\n+    }\n }\n \n /// Expansion kind."}, {"sha": "7af426eaa13f73449deff0eefa04e0308f8bf80f", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 27, "deletions": 36, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73dee258c19a6e9e8249a0d7ff1db54014d0c7a1/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=73dee258c19a6e9e8249a0d7ff1db54014d0c7a1", "patch": "@@ -355,20 +355,20 @@ impl Span {\n     /// Returns the source span -- this is either the supplied span, or the span for\n     /// the macro callsite that expanded to it.\n     pub fn source_callsite(self) -> Span {\n-        self.ctxt().outer_expn_info().map(|info| info.call_site.source_callsite()).unwrap_or(self)\n+        let expn_info = self.ctxt().outer_expn_info();\n+        if !expn_info.is_root() { expn_info.call_site.source_callsite() } else { self }\n     }\n \n     /// The `Span` for the tokens in the previous macro expansion from which `self` was generated,\n     /// if any.\n     pub fn parent(self) -> Option<Span> {\n-        self.ctxt().outer_expn_info().map(|i| i.call_site)\n+        let expn_info = self.ctxt().outer_expn_info();\n+        if !expn_info.is_root() { Some(expn_info.call_site) } else { None }\n     }\n \n     /// Edition of the crate from which this span came.\n     pub fn edition(self) -> edition::Edition {\n-        self.ctxt().outer_expn_info().map_or_else(|| {\n-            Edition::from_session()\n-        }, |einfo| einfo.edition)\n+        self.ctxt().outer_expn_info().edition\n     }\n \n     #[inline]\n@@ -387,66 +387,57 @@ impl Span {\n     /// else returns the `ExpnInfo` for the macro definition\n     /// corresponding to the source callsite.\n     pub fn source_callee(self) -> Option<ExpnInfo> {\n-        fn source_callee(info: ExpnInfo) -> ExpnInfo {\n-            match info.call_site.ctxt().outer_expn_info() {\n-                Some(info) => source_callee(info),\n-                None => info,\n-            }\n+        fn source_callee(expn_info: ExpnInfo) -> ExpnInfo {\n+            let next_expn_info = expn_info.call_site.ctxt().outer_expn_info();\n+            if !next_expn_info.is_root() { source_callee(next_expn_info) } else { expn_info }\n         }\n-        self.ctxt().outer_expn_info().map(source_callee)\n+        let expn_info = self.ctxt().outer_expn_info();\n+        if !expn_info.is_root() { Some(source_callee(expn_info)) } else { None }\n     }\n \n     /// Checks if a span is \"internal\" to a macro in which `#[unstable]`\n     /// items can be used (that is, a macro marked with\n     /// `#[allow_internal_unstable]`).\n     pub fn allows_unstable(&self, feature: Symbol) -> bool {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => info\n-                .allow_internal_unstable\n-                .map_or(false, |features| features.iter().any(|&f|\n-                    f == feature || f == sym::allow_internal_unstable_backcompat_hack\n-                )),\n-            None => false,\n-        }\n+        self.ctxt().outer_expn_info().allow_internal_unstable.map_or(false, |features| {\n+            features.iter().any(|&f| {\n+                f == feature || f == sym::allow_internal_unstable_backcompat_hack\n+            })\n+        })\n     }\n \n     /// Checks if this span arises from a compiler desugaring of kind `kind`.\n     pub fn is_desugaring(&self, kind: DesugaringKind) -> bool {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => match info.kind {\n-                ExpnKind::Desugaring(k) => k == kind,\n-                _ => false,\n-            },\n-            None => false,\n+        match self.ctxt().outer_expn_info().kind {\n+            ExpnKind::Desugaring(k) => k == kind,\n+            _ => false,\n         }\n     }\n \n     /// Returns the compiler desugaring that created this span, or `None`\n     /// if this span is not from a desugaring.\n     pub fn desugaring_kind(&self) -> Option<DesugaringKind> {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => match info.kind {\n-                ExpnKind::Desugaring(k) => Some(k),\n-                _ => None\n-            },\n-            None => None\n+        match self.ctxt().outer_expn_info().kind {\n+            ExpnKind::Desugaring(k) => Some(k),\n+            _ => None\n         }\n     }\n \n     /// Checks if a span is \"internal\" to a macro in which `unsafe`\n     /// can be used without triggering the `unsafe_code` lint\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n     pub fn allows_unsafe(&self) -> bool {\n-        match self.ctxt().outer_expn_info() {\n-            Some(info) => info.allow_internal_unsafe,\n-            None => false,\n-        }\n+        self.ctxt().outer_expn_info().allow_internal_unsafe\n     }\n \n     pub fn macro_backtrace(mut self) -> Vec<MacroBacktrace> {\n         let mut prev_span = DUMMY_SP;\n         let mut result = vec![];\n-        while let Some(info) = self.ctxt().outer_expn_info() {\n+        loop {\n+            let info = self.ctxt().outer_expn_info();\n+            if info.is_root() {\n+                break;\n+            }\n             // Don't print recursive invocations.\n             if !info.call_site.source_equal(&prev_span) {\n                 let (pre, post) = match info.kind {"}]}