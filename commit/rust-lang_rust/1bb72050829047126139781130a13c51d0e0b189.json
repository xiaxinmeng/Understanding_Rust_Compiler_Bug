{"sha": "1bb72050829047126139781130a13c51d0e0b189", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiYjcyMDUwODI5MDQ3MTI2MTM5NzgxMTMwYTEzYzUxZDBlMGIxODk=", "commit": {"author": {"name": "Corentin Henry", "email": "corentinhenry@gmail.com", "date": "2015-10-25T10:19:14Z"}, "committer": {"name": "corentih", "email": "corentin.henry@alcatel-lucent.com", "date": "2015-10-26T16:57:53Z"}, "message": "rustfmt librustc_unicode", "tree": {"sha": "0715ddb19cd261271e81491b6c5052e714e24294", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0715ddb19cd261271e81491b6c5052e714e24294"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1bb72050829047126139781130a13c51d0e0b189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1bb72050829047126139781130a13c51d0e0b189", "html_url": "https://github.com/rust-lang/rust/commit/1bb72050829047126139781130a13c51d0e0b189", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1bb72050829047126139781130a13c51d0e0b189/comments", "author": {"login": "little-dude", "id": 6646324, "node_id": "MDQ6VXNlcjY2NDYzMjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6646324?v=4", "gravatar_id": "", "url": "https://api.github.com/users/little-dude", "html_url": "https://github.com/little-dude", "followers_url": "https://api.github.com/users/little-dude/followers", "following_url": "https://api.github.com/users/little-dude/following{/other_user}", "gists_url": "https://api.github.com/users/little-dude/gists{/gist_id}", "starred_url": "https://api.github.com/users/little-dude/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/little-dude/subscriptions", "organizations_url": "https://api.github.com/users/little-dude/orgs", "repos_url": "https://api.github.com/users/little-dude/repos", "events_url": "https://api.github.com/users/little-dude/events{/privacy}", "received_events_url": "https://api.github.com/users/little-dude/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0b9edc77c57c86c49cf8413b1022f1279e7f3f38", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b9edc77c57c86c49cf8413b1022f1279e7f3f38", "html_url": "https://github.com/rust-lang/rust/commit/0b9edc77c57c86c49cf8413b1022f1279e7f3f38"}], "stats": {"total": 159, "additions": 105, "deletions": 54}, "files": [{"sha": "3eeb1ac4723dbc975dfa21631c70ad8adc91eb4f", "filename": "src/etc/unicode.py", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1bb72050829047126139781130a13c51d0e0b189/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/1bb72050829047126139781130a13c51d0e0b189/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=1bb72050829047126139781130a13c51d0e0b189", "patch": "@@ -313,14 +313,19 @@ def escape_char(c):\n \n def emit_bsearch_range_table(f):\n     f.write(\"\"\"\n-fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n+fn bsearch_range_table(c: char, r: &'static [(char, char)]) -> bool {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n     use core::slice::SliceExt;\n-    r.binary_search_by(|&(lo,hi)| {\n-        if lo <= c && c <= hi { Equal }\n-        else if hi < c { Less }\n-        else { Greater }\n-    }).is_ok()\n+    r.binary_search_by(|&(lo, hi)| {\n+         if lo <= c && c <= hi {\n+             Equal\n+         } else if hi < c {\n+             Less\n+         } else {\n+             Greater\n+         }\n+     })\n+     .is_ok()\n }\\n\n \"\"\")\n "}, {"sha": "2fb15ff2ac7fe419b38fe42313b194e42a72174b", "filename": "src/librustc_unicode/char.rs", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1bb72050829047126139781130a13c51d0e0b189/src%2Flibrustc_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb72050829047126139781130a13c51d0e0b189/src%2Flibrustc_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fchar.rs?ref=1bb72050829047126139781130a13c51d0e0b189", "patch": "@@ -49,7 +49,9 @@ pub struct ToLowercase(CaseMappingIter);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ToLowercase {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> { self.0.next() }\n+    fn next(&mut self) -> Option<char> {\n+        self.0.next()\n+    }\n }\n \n /// An iterator over the uppercase mapping of a given character, returned from\n@@ -61,15 +63,17 @@ pub struct ToUppercase(CaseMappingIter);\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ToUppercase {\n     type Item = char;\n-    fn next(&mut self) -> Option<char> { self.0.next() }\n+    fn next(&mut self) -> Option<char> {\n+        self.0.next()\n+    }\n }\n \n \n enum CaseMappingIter {\n     Three(char, char, char),\n     Two(char, char),\n     One(char),\n-    Zero\n+    Zero,\n }\n \n impl CaseMappingIter {\n@@ -165,7 +169,9 @@ impl char {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n+    pub fn is_digit(self, radix: u32) -> bool {\n+        C::is_digit(self, radix)\n+    }\n \n     /// Converts a `char` to a digit in the given radix.\n     ///\n@@ -229,7 +235,9 @@ impl char {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn to_digit(self, radix: u32) -> Option<u32> { C::to_digit(self, radix) }\n+    pub fn to_digit(self, radix: u32) -> Option<u32> {\n+        C::to_digit(self, radix)\n+    }\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a\n     /// character, as `char`s.\n@@ -262,7 +270,9 @@ impl char {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn escape_unicode(self) -> EscapeUnicode { C::escape_unicode(self) }\n+    pub fn escape_unicode(self) -> EscapeUnicode {\n+        C::escape_unicode(self)\n+    }\n \n     /// Returns an iterator that yields the literal escape code of a `char`.\n     ///\n@@ -309,7 +319,9 @@ impl char {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn escape_default(self) -> EscapeDefault { C::escape_default(self) }\n+    pub fn escape_default(self) -> EscapeDefault {\n+        C::escape_default(self)\n+    }\n \n     /// Returns the number of bytes this `char` would need if encoded in UTF-8.\n     ///\n@@ -358,7 +370,9 @@ impl char {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn len_utf8(self) -> usize { C::len_utf8(self) }\n+    pub fn len_utf8(self) -> usize {\n+        C::len_utf8(self)\n+    }\n \n     /// Returns the number of 16-bit code units this `char` would need if\n     /// encoded in UTF-16.\n@@ -378,7 +392,9 @@ impl char {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn len_utf16(self) -> usize { C::len_utf16(self) }\n+    pub fn len_utf16(self) -> usize {\n+        C::len_utf16(self)\n+    }\n \n     /// Encodes this character as UTF-8 into the provided byte buffer, and then\n     /// returns the number of bytes written.\n@@ -482,9 +498,9 @@ impl char {\n     #[inline]\n     pub fn is_alphabetic(self) -> bool {\n         match self {\n-            'a' ... 'z' | 'A' ... 'Z' => true,\n+            'a'...'z' | 'A'...'Z' => true,\n             c if c > '\\x7f' => derived_property::Alphabetic(c),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -498,7 +514,9 @@ impl char {\n                reason = \"mainly needed for compiler internals\",\n                issue = \"0\")]\n     #[inline]\n-    pub fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n+    pub fn is_xid_start(self) -> bool {\n+        derived_property::XID_Start(self)\n+    }\n \n     /// Returns true if this `char` satisfies the 'XID_Continue' Unicode property, and false\n     /// otherwise.\n@@ -510,7 +528,9 @@ impl char {\n                reason = \"mainly needed for compiler internals\",\n                issue = \"0\")]\n     #[inline]\n-    pub fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n+    pub fn is_xid_continue(self) -> bool {\n+        derived_property::XID_Continue(self)\n+    }\n \n     /// Returns true if this `char` is lowercase, and false otherwise.\n     ///\n@@ -542,9 +562,9 @@ impl char {\n     #[inline]\n     pub fn is_lowercase(self) -> bool {\n         match self {\n-            'a' ... 'z' => true,\n+            'a'...'z' => true,\n             c if c > '\\x7f' => derived_property::Lowercase(c),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -578,9 +598,9 @@ impl char {\n     #[inline]\n     pub fn is_uppercase(self) -> bool {\n         match self {\n-            'A' ... 'Z' => true,\n+            'A'...'Z' => true,\n             c if c > '\\x7f' => derived_property::Uppercase(c),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -608,9 +628,9 @@ impl char {\n     #[inline]\n     pub fn is_whitespace(self) -> bool {\n         match self {\n-            ' ' | '\\x09' ... '\\x0d' => true,\n+            ' ' | '\\x09'...'\\x0d' => true,\n             c if c > '\\x7f' => property::White_Space(c),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -673,7 +693,9 @@ impl char {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_control(self) -> bool { general_category::Cc(self) }\n+    pub fn is_control(self) -> bool {\n+        general_category::Cc(self)\n+    }\n \n     /// Returns true if this `char` is numeric, and false otherwise.\n     ///\n@@ -713,9 +735,9 @@ impl char {\n     #[inline]\n     pub fn is_numeric(self) -> bool {\n         match self {\n-            '0' ... '9' => true,\n+            '0'...'9' => true,\n             c if c > '\\x7f' => general_category::N(c),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -823,7 +845,9 @@ impl char {\n /// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n #[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n #[derive(Clone)]\n-pub struct DecodeUtf16<I> where I: Iterator<Item=u16> {\n+pub struct DecodeUtf16<I>\n+    where I: Iterator<Item = u16>\n+{\n     iter: I,\n     buf: Option<u16>,\n }\n@@ -874,7 +898,7 @@ pub struct DecodeUtf16<I> where I: Iterator<Item=u16> {\n /// ```\n #[unstable(feature = \"decode_utf16\", reason = \"recently exposed\", issue = \"27830\")]\n #[inline]\n-pub fn decode_utf16<I: IntoIterator<Item=u16>>(iterable: I) -> DecodeUtf16<I::IntoIter> {\n+pub fn decode_utf16<I: IntoIterator<Item = u16>>(iterable: I) -> DecodeUtf16<I::IntoIter> {\n     DecodeUtf16 {\n         iter: iterable.into_iter(),\n         buf: None,\n@@ -890,8 +914,8 @@ impl<I: Iterator<Item=u16>> Iterator for DecodeUtf16<I> {\n             Some(buf) => buf,\n             None => match self.iter.next() {\n                 Some(u) => u,\n-                None => return None\n-            }\n+                None => return None,\n+            },\n         };\n \n         if u < 0xD800 || 0xDFFF < u {\n@@ -904,13 +928,13 @@ impl<I: Iterator<Item=u16>> Iterator for DecodeUtf16<I> {\n             let u2 = match self.iter.next() {\n                 Some(u2) => u2,\n                 // eof\n-                None => return Some(Err(u))\n+                None => return Some(Err(u)),\n             };\n             if u2 < 0xDC00 || u2 > 0xDFFF {\n                 // not a trailing surrogate so we're not a valid\n                 // surrogate pair, so rewind to redecode u2 next time.\n                 self.buf = Some(u2);\n-                return Some(Err(u))\n+                return Some(Err(u));\n             }\n \n             // all ok, so lets decode it."}, {"sha": "2347cdebf2292e60ed550ccc33614c5dced79fb8", "filename": "src/librustc_unicode/u_str.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1bb72050829047126139781130a13c51d0e0b189/src%2Flibrustc_unicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1bb72050829047126139781130a13c51d0e0b189/src%2Flibrustc_unicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_unicode%2Fu_str.rs?ref=1bb72050829047126139781130a13c51d0e0b189", "patch": "@@ -10,8 +10,8 @@\n \n //! Unicode-intensive string manipulations.\n //!\n-//! This module provides functionality to `str` that requires the Unicode methods provided by the\n-//! unicode parts of the CharExt trait.\n+//! This module provides functionality to `str` that requires the Unicode\n+//! methods provided by the unicode parts of the CharExt trait.\n \n use char::{DecodeUtf16, decode_utf16};\n use core::char;\n@@ -40,20 +40,28 @@ pub trait UnicodeStr {\n impl UnicodeStr for str {\n     #[inline]\n     fn split_whitespace(&self) -> SplitWhitespace {\n-        fn is_not_empty(s: &&str) -> bool { !s.is_empty() }\n+        fn is_not_empty(s: &&str) -> bool {\n+            !s.is_empty()\n+        }\n         let is_not_empty: fn(&&str) -> bool = is_not_empty; // coerce to fn pointer\n \n-        fn is_whitespace(c: char) -> bool { c.is_whitespace() }\n+        fn is_whitespace(c: char) -> bool {\n+            c.is_whitespace()\n+        }\n         let is_whitespace: fn(char) -> bool = is_whitespace; // coerce to fn pointer\n \n         SplitWhitespace { inner: self.split(is_whitespace).filter(is_not_empty) }\n     }\n \n     #[inline]\n-    fn is_whitespace(&self) -> bool { self.chars().all(|c| c.is_whitespace()) }\n+    fn is_whitespace(&self) -> bool {\n+        self.chars().all(|c| c.is_whitespace())\n+    }\n \n     #[inline]\n-    fn is_alphanumeric(&self) -> bool { self.chars().all(|c| c.is_alphanumeric()) }\n+    fn is_alphanumeric(&self) -> bool {\n+        self.chars().all(|c| c.is_alphanumeric())\n+    }\n \n     #[inline]\n     fn trim(&self) -> &str {\n@@ -111,8 +119,9 @@ pub fn is_utf16(v: &[u16]) -> bool {\n             Some(_) => {}\n             None => {\n                 let u2 = next!(false);\n-                if u < 0xD7FF || u > 0xDBFF ||\n-                    u2 < 0xDC00 || u2 > 0xDFFF { return false; }\n+                if u < 0xD7FF || u > 0xDBFF || u2 < 0xDC00 || u2 > 0xDFFF {\n+                    return false;\n+                }\n             }\n         }\n     }\n@@ -125,7 +134,7 @@ pub fn is_utf16(v: &[u16]) -> bool {\n #[allow(deprecated)]\n #[derive(Clone)]\n pub struct Utf16Items<'a> {\n-    decoder: DecodeUtf16<Cloned<slice::Iter<'a, u16>>>\n+    decoder: DecodeUtf16<Cloned<slice::Iter<'a, u16>>>,\n }\n \n /// The possibilities for values decoded from a `u16` stream.\n@@ -137,7 +146,7 @@ pub enum Utf16Item {\n     /// A valid codepoint.\n     ScalarValue(char),\n     /// An invalid surrogate without its pair.\n-    LoneSurrogate(u16)\n+    LoneSurrogate(u16),\n }\n \n #[allow(deprecated)]\n@@ -148,7 +157,7 @@ impl Utf16Item {\n     pub fn to_char_lossy(&self) -> char {\n         match *self {\n             Utf16Item::ScalarValue(c) => c,\n-            Utf16Item::LoneSurrogate(_) => '\\u{FFFD}'\n+            Utf16Item::LoneSurrogate(_) => '\\u{FFFD}',\n         }\n     }\n }\n@@ -160,9 +169,11 @@ impl<'a> Iterator for Utf16Items<'a> {\n     type Item = Utf16Item;\n \n     fn next(&mut self) -> Option<Utf16Item> {\n-        self.decoder.next().map(|result| match result {\n-            Ok(c) => Utf16Item::ScalarValue(c),\n-            Err(s) => Utf16Item::LoneSurrogate(s),\n+        self.decoder.next().map(|result| {\n+            match result {\n+                Ok(c) => Utf16Item::ScalarValue(c),\n+                Err(s) => Utf16Item::LoneSurrogate(s),\n+            }\n         })\n     }\n \n@@ -209,13 +220,18 @@ pub fn utf16_items<'a>(v: &'a [u16]) -> Utf16Items<'a> {\n #[derive(Clone)]\n pub struct Utf16Encoder<I> {\n     chars: I,\n-    extra: u16\n+    extra: u16,\n }\n \n impl<I> Utf16Encoder<I> {\n     /// Create a UTF-16 encoder from any `char` iterator.\n-    pub fn new(chars: I) -> Utf16Encoder<I> where I: Iterator<Item=char> {\n-        Utf16Encoder { chars: chars, extra: 0 }\n+    pub fn new(chars: I) -> Utf16Encoder<I>\n+        where I: Iterator<Item = char>\n+    {\n+        Utf16Encoder {\n+            chars: chars,\n+            extra: 0,\n+        }\n     }\n }\n \n@@ -233,7 +249,9 @@ impl<I> Iterator for Utf16Encoder<I> where I: Iterator<Item=char> {\n         let mut buf = [0; 2];\n         self.chars.next().map(|ch| {\n             let n = CharExt::encode_utf16(ch, &mut buf).unwrap_or(0);\n-            if n == 2 { self.extra = buf[1]; }\n+            if n == 2 {\n+                self.extra = buf[1];\n+            }\n             buf[0]\n         })\n     }\n@@ -251,8 +269,12 @@ impl<I> Iterator for Utf16Encoder<I> where I: Iterator<Item=char> {\n impl<'a> Iterator for SplitWhitespace<'a> {\n     type Item = &'a str;\n \n-    fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.inner.next()\n+    }\n }\n impl<'a> DoubleEndedIterator for SplitWhitespace<'a> {\n-    fn next_back(&mut self) -> Option<&'a str> { self.inner.next_back() }\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.inner.next_back()\n+    }\n }"}]}