{"sha": "131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzMTc3MmM1ZTBiYTQwY2Q2NTZkZWRiNWUxOTkwZDM2ZTNlYTMxY2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-14T16:43:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-14T16:43:20Z"}, "message": "Auto merge of #69076 - cjgillot:split_trait, r=matthewjasper\n\nSplit librustc::{traits,infer} to their respective crates\n\nFollowup on #67953.\n\nI tried to follow the existing module structures.\n\ncc @eddyb\nr? @Zoxc", "tree": {"sha": "2aeebd637cffea4c62428a27d3f3da0accbaf0fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2aeebd637cffea4c62428a27d3f3da0accbaf0fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "html_url": "https://github.com/rust-lang/rust/commit/131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f1e814c119afe08abff199895f3279ee0376d70", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f1e814c119afe08abff199895f3279ee0376d70", "html_url": "https://github.com/rust-lang/rust/commit/0f1e814c119afe08abff199895f3279ee0376d70"}, {"sha": "0144a979464744261d1d9b74234a4376a084e9b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/0144a979464744261d1d9b74234a4376a084e9b2", "html_url": "https://github.com/rust-lang/rust/commit/0144a979464744261d1d9b74234a4376a084e9b2"}], "stats": {"total": 10283, "additions": 5588, "deletions": 4695}, "files": [{"sha": "42049da8e6add727f668e729f608ae969c09f557", "filename": "Cargo.lock", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -3783,19 +3783,15 @@ dependencies = [\n name = \"rustc_infer\"\n version = \"0.0.0\"\n dependencies = [\n- \"fmt_macros\",\n  \"graphviz\",\n  \"log\",\n  \"rustc\",\n  \"rustc_ast\",\n- \"rustc_attr\",\n  \"rustc_data_structures\",\n- \"rustc_error_codes\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n- \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n  \"smallvec 1.0.0\",\n@@ -3835,6 +3831,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n  \"rustc_traits\",\n  \"rustc_ty\",\n  \"rustc_typeck\",\n@@ -3869,6 +3866,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n  \"unicode-security\",\n ]\n \n@@ -3938,6 +3936,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n ]\n@@ -3961,6 +3960,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n  \"serialize\",\n  \"smallvec 1.0.0\",\n ]\n@@ -4001,6 +4001,7 @@ dependencies = [\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n ]\n \n [[package]]\n@@ -4048,7 +4049,6 @@ dependencies = [\n  \"rustc_expand\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n- \"rustc_infer\",\n  \"rustc_metadata\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4128,6 +4128,27 @@ version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"b725dadae9fabc488df69a287f5a99c5eaf5d10853842a8a3dfac52476f544ee\"\n \n+[[package]]\n+name = \"rustc_trait_selection\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"fmt_macros\",\n+ \"log\",\n+ \"rustc\",\n+ \"rustc_ast\",\n+ \"rustc_attr\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_infer\",\n+ \"rustc_macros\",\n+ \"rustc_session\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+ \"smallvec 1.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_traits\"\n version = \"0.0.0\"\n@@ -4141,6 +4162,7 @@ dependencies = [\n  \"rustc_macros\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n  \"smallvec 1.0.0\",\n ]\n \n@@ -4155,6 +4177,7 @@ dependencies = [\n  \"rustc_infer\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n ]\n \n [[package]]\n@@ -4173,6 +4196,7 @@ dependencies = [\n  \"rustc_infer\",\n  \"rustc_span\",\n  \"rustc_target\",\n+ \"rustc_trait_selection\",\n  \"smallvec 1.0.0\",\n ]\n "}, {"sha": "d316d7659e222b1ef4c3fdb22a2ef92d4d796409", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -288,3 +288,44 @@ impl<T: Clone> WithDepNode<T> {\n         self.cached_value.clone()\n     }\n }\n+\n+#[derive(Clone, Debug)]\n+pub enum IntercrateAmbiguityCause {\n+    DownstreamCrate { trait_desc: String, self_desc: Option<String> },\n+    UpstreamCrateUpdate { trait_desc: String, self_desc: Option<String> },\n+    ReservationImpl { message: String },\n+}\n+\n+impl IntercrateAmbiguityCause {\n+    /// Emits notes when the overlap is caused by complex intercrate ambiguities.\n+    /// See #23980 for details.\n+    pub fn add_intercrate_ambiguity_hint(&self, err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n+        err.note(&self.intercrate_ambiguity_hint());\n+    }\n+\n+    pub fn intercrate_ambiguity_hint(&self) -> String {\n+        match self {\n+            &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n+                let self_desc = if let &Some(ref ty) = self_desc {\n+                    format!(\" for type `{}`\", ty)\n+                } else {\n+                    String::new()\n+                };\n+                format!(\"downstream crates may implement trait `{}`{}\", trait_desc, self_desc)\n+            }\n+            &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n+                let self_desc = if let &Some(ref ty) = self_desc {\n+                    format!(\" for type `{}`\", ty)\n+                } else {\n+                    String::new()\n+                };\n+                format!(\n+                    \"upstream crates may add a new impl of trait `{}`{} \\\n+                     in future versions\",\n+                    trait_desc, self_desc\n+                )\n+            }\n+            &IntercrateAmbiguityCause::ReservationImpl { ref message } => message.clone(),\n+        }\n+    }\n+}"}, {"sha": "4f97fd82874ffeae308fbbfc4cf128987ba9a476", "filename": "src/librustc_infer/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -10,18 +10,14 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n-rustc_attr = { path = \"../librustc_attr\" }\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n-rustc_error_codes = { path = \"../librustc_error_codes\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_macros = { path = \"../librustc_macros\" }\n-rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "9322df48235113a0ff1aa039ce3adc17cf2ebc1c", "filename": "src/librustc_infer/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 45, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fquery_response.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -14,7 +14,7 @@ use crate::infer::canonical::{\n };\n use crate::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n-use crate::infer::{InferCtxt, InferCtxtBuilder, InferOk, InferResult, NLLRegionVariableOrigin};\n+use crate::infer::{InferCtxt, InferOk, InferResult, NLLRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n use crate::traits::{DomainGoal, TraitEngine};\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n@@ -26,52 +26,8 @@ use rustc::ty::{self, BoundVar, Ty, TyCtxt};\n use rustc_data_structures::captures::Captures;\n use rustc_index::vec::Idx;\n use rustc_index::vec::IndexVec;\n-use rustc_span::DUMMY_SP;\n use std::fmt::Debug;\n \n-impl<'tcx> InferCtxtBuilder<'tcx> {\n-    /// The \"main method\" for a canonicalized trait query. Given the\n-    /// canonical key `canonical_key`, this method will create a new\n-    /// inference context, instantiate the key, and run your operation\n-    /// `op`. The operation should yield up a result (of type `R`) as\n-    /// well as a set of trait obligations that must be fully\n-    /// satisfied. These obligations will be processed and the\n-    /// canonical result created.\n-    ///\n-    /// Returns `NoSolution` in the event of any error.\n-    ///\n-    /// (It might be mildly nicer to implement this on `TyCtxt`, and\n-    /// not `InferCtxtBuilder`, but that is a bit tricky right now.\n-    /// In part because we would need a `for<'tcx>` sort of\n-    /// bound for the closure and in part because it is convenient to\n-    /// have `'tcx` be free on this function so that we can talk about\n-    /// `K: TypeFoldable<'tcx>`.)\n-    pub fn enter_canonical_trait_query<K, R>(\n-        &mut self,\n-        canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n-    ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n-    where\n-        K: TypeFoldable<'tcx>,\n-        R: Debug + TypeFoldable<'tcx>,\n-        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable,\n-    {\n-        self.enter_with_canonical(\n-            DUMMY_SP,\n-            canonical_key,\n-            |ref infcx, key, canonical_inference_vars| {\n-                let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n-                let value = operation(infcx, &mut *fulfill_cx, key)?;\n-                infcx.make_canonicalized_query_response(\n-                    canonical_inference_vars,\n-                    value,\n-                    &mut *fulfill_cx,\n-                )\n-            },\n-        )\n-    }\n-}\n-\n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// This method is meant to be invoked as the final step of a canonical query\n     /// implementation. It is given:"}, {"sha": "4a39403f211cc437948864a6e966fc3bed943f32", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -49,7 +49,6 @@ use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n-use crate::infer::opaque_types;\n use crate::infer::{self, SuppressRegionErrors};\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n@@ -288,6 +287,86 @@ fn explain_span(tcx: TyCtxt<'tcx>, heading: &str, span: Span) -> (String, Option\n     (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize() + 1), Some(span))\n }\n \n+pub fn unexpected_hidden_region_diagnostic(\n+    tcx: TyCtxt<'tcx>,\n+    region_scope_tree: Option<&region::ScopeTree>,\n+    span: Span,\n+    hidden_ty: Ty<'tcx>,\n+    hidden_region: ty::Region<'tcx>,\n+) -> DiagnosticBuilder<'tcx> {\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0700,\n+        \"hidden type for `impl Trait` captures lifetime that does not appear in bounds\",\n+    );\n+\n+    // Explain the region we are capturing.\n+    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) = hidden_region {\n+        // Assuming regionck succeeded (*), we ought to always be\n+        // capturing *some* region from the fn header, and hence it\n+        // ought to be free. So under normal circumstances, we will go\n+        // down this path which gives a decent human readable\n+        // explanation.\n+        //\n+        // (*) if not, the `tainted_by_errors` flag would be set to\n+        // true in any case, so we wouldn't be here at all.\n+        note_and_explain_free_region(\n+            tcx,\n+            &mut err,\n+            &format!(\"hidden type `{}` captures \", hidden_ty),\n+            hidden_region,\n+            \"\",\n+        );\n+    } else {\n+        // Ugh. This is a painful case: the hidden region is not one\n+        // that we can easily summarize or explain. This can happen\n+        // in a case like\n+        // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n+        //\n+        // ```\n+        // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n+        //   if condition() { a } else { b }\n+        // }\n+        // ```\n+        //\n+        // Here the captured lifetime is the intersection of `'a` and\n+        // `'b`, which we can't quite express.\n+\n+        if let Some(region_scope_tree) = region_scope_tree {\n+            // If the `region_scope_tree` is available, this is being\n+            // invoked from the \"region inferencer error\". We can at\n+            // least report a really cryptic error for now.\n+            note_and_explain_region(\n+                tcx,\n+                region_scope_tree,\n+                &mut err,\n+                &format!(\"hidden type `{}` captures \", hidden_ty),\n+                hidden_region,\n+                \"\",\n+            );\n+        } else {\n+            // If the `region_scope_tree` is *unavailable*, this is\n+            // being invoked by the code that comes *after* region\n+            // inferencing. This is a bug, as the region inferencer\n+            // ought to have noticed the failed constraint and invoked\n+            // error reporting, which in turn should have prevented us\n+            // from getting trying to infer the hidden type\n+            // completely.\n+            tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\n+                    \"hidden type captures unexpected lifetime `{:?}` \\\n+                     but no region inference failure\",\n+                    hidden_region,\n+                ),\n+            );\n+        }\n+    }\n+\n+    err\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_region_errors(\n         &self,\n@@ -410,7 +489,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         span,\n                     } => {\n                         let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n-                        opaque_types::unexpected_hidden_region_diagnostic(\n+                        unexpected_hidden_region_diagnostic(\n                             self.tcx,\n                             Some(region_scope_tree),\n                             span,\n@@ -2077,7 +2156,7 @@ impl<'tcx> ObligationCauseExt<'tcx> for ObligationCause<'tcx> {\n /// This is a bare signal of what kind of type we're dealing with. `ty::TyKind` tracks\n /// extra information about each type, but we only care about the category.\n #[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-crate enum TyCategory {\n+pub enum TyCategory {\n     Closure,\n     Opaque,\n     Generator,"}, {"sha": "9ae131c568d0dcf16a2da5e39ee74515d54d1b35", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 49, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -13,11 +13,11 @@ use rustc::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc::middle::free_region::RegionRelations;\n-use rustc::middle::lang_items;\n use rustc::middle::region;\n use rustc::mir;\n use rustc::mir::interpret::ConstEvalResult;\n use rustc::session::config::BorrowckMode;\n+use rustc::traits::select;\n use rustc::ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::relate::RelateResult;\n@@ -58,7 +58,6 @@ pub mod lattice;\n mod lexical_region_resolve;\n mod lub;\n pub mod nll_relate;\n-pub mod opaque_types;\n pub mod outlives;\n pub mod region_constraints;\n pub mod resolve;\n@@ -215,10 +214,10 @@ pub struct InferCtxt<'a, 'tcx> {\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that have to do with the parameters in scope.\n-    pub selection_cache: traits::SelectionCache<'tcx>,\n+    pub selection_cache: select::SelectionCache<'tcx>,\n \n     /// Caches the results of trait evaluation.\n-    pub evaluation_cache: traits::EvaluationCache<'tcx>,\n+    pub evaluation_cache: select::EvaluationCache<'tcx>,\n \n     /// the set of predicates on which errors have been reported, to\n     /// avoid reporting the same error twice.\n@@ -1474,27 +1473,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .verify_generic_bound(origin, kind, a, bound);\n     }\n \n-    pub fn type_is_copy_modulo_regions(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> bool {\n-        let ty = self.resolve_vars_if_possible(&ty);\n-\n-        if !(param_env, ty).has_local_value() {\n-            return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n-        }\n-\n-        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n-\n-        // This can get called from typeck (by euv), and `moves_by_default`\n-        // rightly refuses to work with inference variables, but\n-        // moves_by_default has a cache, which we want to use in other\n-        // cases.\n-        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n-    }\n-\n     /// Obtains the latest type of the given closure; this may be a\n     /// closure in the current function, in which case its\n     /// `ClosureKind` may not yet be known.\n@@ -1518,30 +1496,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         closure_sig_ty.fn_sig(self.tcx)\n     }\n \n-    /// Normalizes associated types in `value`, potentially returning\n-    /// new obligations that must further be processed.\n-    pub fn partially_normalize_associated_types_in<T>(\n-        &self,\n-        span: Span,\n-        body_id: hir::HirId,\n-        param_env: ty::ParamEnv<'tcx>,\n-        value: &T,\n-    ) -> InferOk<'tcx, T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n-        let mut selcx = traits::SelectionContext::new(self);\n-        let cause = ObligationCause::misc(span, body_id);\n-        let traits::Normalized { value, obligations } =\n-            traits::normalize(&mut selcx, param_env, cause, value);\n-        debug!(\n-            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n-            value, obligations\n-        );\n-        InferOk { value, obligations }\n-    }\n-\n     /// Clears the selection, evaluation, and projection caches. This is useful when\n     /// repeatedly attempting to select an `Obligation` while changing only\n     /// its `ParamEnv`, since `FulfillmentContext` doesn't use probing."}, {"sha": "6c1e86bf408b0d97422e4f3512e4610c92466572", "filename": "src/librustc_infer/infer/outlives/env.rs", "status": "modified", "additions": 10, "deletions": 39, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fenv.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,10 +1,11 @@\n use crate::infer::{GenericKind, InferCtxt};\n-use crate::traits::query::outlives_bounds::{self, OutlivesBound};\n+use crate::traits::query::OutlivesBound;\n+use rustc::ty;\n use rustc::ty::free_region_map::FreeRegionMap;\n-use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n-use rustc_span::Span;\n+\n+use super::explicit_outlives_bounds;\n \n /// The `OutlivesEnvironment` collects information about what outlives\n /// what in a given type-checking setting. For example, if we have a\n@@ -76,7 +77,7 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n             region_bound_pairs_accum: vec![],\n         };\n \n-        env.add_outlives_bounds(None, outlives_bounds::explicit_outlives_bounds(param_env));\n+        env.add_outlives_bounds(None, explicit_outlives_bounds(param_env));\n \n         env\n     }\n@@ -142,39 +143,6 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n         self.region_bound_pairs_accum.truncate(len);\n     }\n \n-    /// This method adds \"implied bounds\" into the outlives environment.\n-    /// Implied bounds are outlives relationships that we can deduce\n-    /// on the basis that certain types must be well-formed -- these are\n-    /// either the types that appear in the function signature or else\n-    /// the input types to an impl. For example, if you have a function\n-    /// like\n-    ///\n-    /// ```\n-    /// fn foo<'a, 'b, T>(x: &'a &'b [T]) { }\n-    /// ```\n-    ///\n-    /// we can assume in the caller's body that `'b: 'a` and that `T:\n-    /// 'b` (and hence, transitively, that `T: 'a`). This method would\n-    /// add those assumptions into the outlives-environment.\n-    ///\n-    /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n-    pub fn add_implied_bounds(\n-        &mut self,\n-        infcx: &InferCtxt<'a, 'tcx>,\n-        fn_sig_tys: &[Ty<'tcx>],\n-        body_id: hir::HirId,\n-        span: Span,\n-    ) {\n-        debug!(\"add_implied_bounds()\");\n-\n-        for &ty in fn_sig_tys {\n-            let ty = infcx.resolve_vars_if_possible(&ty);\n-            debug!(\"add_implied_bounds: ty = {}\", ty);\n-            let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n-            self.add_outlives_bounds(Some(infcx), implied_bounds)\n-        }\n-    }\n-\n     /// Save the current set of region-bound pairs under the given `body_id`.\n     pub fn save_implied_bounds(&mut self, body_id: hir::HirId) {\n         let old =\n@@ -188,8 +156,11 @@ impl<'a, 'tcx> OutlivesEnvironment<'tcx> {\n     /// contain inference variables, it must be supplied, in which\n     /// case we will register \"givens\" on the inference context. (See\n     /// `RegionConstraintData`.)\n-    fn add_outlives_bounds<I>(&mut self, infcx: Option<&InferCtxt<'a, 'tcx>>, outlives_bounds: I)\n-    where\n+    pub fn add_outlives_bounds<I>(\n+        &mut self,\n+        infcx: Option<&InferCtxt<'a, 'tcx>>,\n+        outlives_bounds: I,\n+    ) where\n         I: IntoIterator<Item = OutlivesBound<'tcx>>,\n     {\n         // Record relationships such as `T:'x` that don't go into the"}, {"sha": "75cf742de31a7a5f01f6e186dd22aef176219724", "filename": "src/librustc_infer/infer/outlives/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Foutlives%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -3,3 +3,25 @@\n pub mod env;\n pub mod obligations;\n pub mod verify;\n+\n+use rustc::traits::query::OutlivesBound;\n+use rustc::ty;\n+\n+pub fn explicit_outlives_bounds<'tcx>(\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n+    debug!(\"explicit_outlives_bounds()\");\n+    param_env.caller_bounds.into_iter().filter_map(move |predicate| match predicate {\n+        ty::Predicate::Projection(..)\n+        | ty::Predicate::Trait(..)\n+        | ty::Predicate::Subtype(..)\n+        | ty::Predicate::WellFormed(..)\n+        | ty::Predicate::ObjectSafe(..)\n+        | ty::Predicate::ClosureKind(..)\n+        | ty::Predicate::TypeOutlives(..)\n+        | ty::Predicate::ConstEvaluatable(..) => None,\n+        ty::Predicate::RegionOutlives(ref data) => data\n+            .no_bound_vars()\n+            .map(|ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a)),\n+    })\n+}"}, {"sha": "cb8ae8c592b228bdeef1f3b3255ed7bddc1c3b84", "filename": "src/librustc_infer/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Flib.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,6 +1,5 @@\n-//! This crates defines the trait resolution method and the type inference engine.\n+//! This crates defines the type inference engine.\n //!\n-//! - **Traits.** Trait resolution is implemented in the `traits` module.\n //! - **Type inference.** The type inference code can be found in the `infer` module;\n //!   this code handles low-level equality and subtyping operations. The\n //!   type check pass in the compiler is found in the `librustc_typeck` crate.\n@@ -17,12 +16,11 @@\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(drain_filter)]\n #![feature(never_type)]\n #![feature(range_is_empty)]\n #![feature(in_band_lifetimes)]\n #![feature(crate_visibility_modifier)]\n-#![recursion_limit = \"512\"]\n+#![recursion_limit = \"512\"] // For rustdoc\n \n #[macro_use]\n extern crate rustc_macros;"}, {"sha": "9ad722342a19ebad877383914d9fb97fdedbd8bb", "filename": "src/librustc_infer/traits/engine.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fengine.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,9 +1,9 @@\n use crate::infer::InferCtxt;\n use crate::traits::Obligation;\n-use rustc::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc::ty::{self, ToPredicate, Ty, WithConstness};\n use rustc_hir::def_id::DefId;\n \n-use super::{FulfillmentContext, FulfillmentError};\n+use super::FulfillmentError;\n use super::{ObligationCause, PredicateObligation};\n \n pub trait TraitEngine<'tcx>: 'tcx {\n@@ -76,9 +76,3 @@ impl<T: ?Sized + TraitEngine<'tcx>> TraitEngineExt<'tcx> for T {\n         }\n     }\n }\n-\n-impl dyn TraitEngine<'tcx> {\n-    pub fn new(_tcx: TyCtxt<'tcx>) -> Box<Self> {\n-        Box::new(FulfillmentContext::new())\n-    }\n-}"}, {"sha": "8943ce4e6c505c5f9d0abcef7f4ea8c19638d583", "filename": "src/librustc_infer/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 1543, "changes": 1549, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,452 +1,16 @@\n-pub mod on_unimplemented;\n-pub mod suggestions;\n+use super::ObjectSafetyViolation;\n \n-use super::{\n-    ConstEvalFailure, EvaluationResult, FulfillmentError, FulfillmentErrorCode,\n-    MismatchedProjectionTypes, ObjectSafetyViolation, Obligation, ObligationCause,\n-    ObligationCauseCode, OnUnimplementedDirective, OnUnimplementedNote,\n-    OutputTypeParameterMismatch, Overflow, PredicateObligation, SelectionContext, SelectionError,\n-    TraitNotObjectSafe,\n-};\n-\n-use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n-use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n-use rustc::mir::interpret::ErrorHandled;\n-use rustc::session::DiagnosticMessageId;\n-use rustc::ty::error::ExpectedFound;\n-use rustc::ty::fast_reject;\n-use rustc::ty::fold::TypeFolder;\n-use rustc::ty::SubtypePredicate;\n-use rustc::ty::{\n-    self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n-};\n+use crate::infer::InferCtxt;\n+use rustc::ty::TyCtxt;\n use rustc_ast::ast;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n-use rustc_span::source_map::SourceMap;\n-use rustc_span::{ExpnKind, Span, DUMMY_SP};\n+use rustc_hir::def_id::DefId;\n+use rustc_span::Span;\n use std::fmt;\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn report_fulfillment_errors(\n-        &self,\n-        errors: &[FulfillmentError<'tcx>],\n-        body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n-    ) {\n-        #[derive(Debug)]\n-        struct ErrorDescriptor<'tcx> {\n-            predicate: ty::Predicate<'tcx>,\n-            index: Option<usize>, // None if this is an old error\n-        }\n-\n-        let mut error_map: FxHashMap<_, Vec<_>> = self\n-            .reported_trait_errors\n-            .borrow()\n-            .iter()\n-            .map(|(&span, predicates)| {\n-                (\n-                    span,\n-                    predicates\n-                        .iter()\n-                        .map(|&predicate| ErrorDescriptor { predicate, index: None })\n-                        .collect(),\n-                )\n-            })\n-            .collect();\n-\n-        for (index, error) in errors.iter().enumerate() {\n-            // We want to ignore desugarings here: spans are equivalent even\n-            // if one is the result of a desugaring and the other is not.\n-            let mut span = error.obligation.cause.span;\n-            let expn_data = span.ctxt().outer_expn_data();\n-            if let ExpnKind::Desugaring(_) = expn_data.kind {\n-                span = expn_data.call_site;\n-            }\n-\n-            error_map.entry(span).or_default().push(ErrorDescriptor {\n-                predicate: error.obligation.predicate,\n-                index: Some(index),\n-            });\n-\n-            self.reported_trait_errors\n-                .borrow_mut()\n-                .entry(span)\n-                .or_default()\n-                .push(error.obligation.predicate.clone());\n-        }\n-\n-        // We do this in 2 passes because we want to display errors in order, though\n-        // maybe it *is* better to sort errors by span or something.\n-        let mut is_suppressed = vec![false; errors.len()];\n-        for (_, error_set) in error_map.iter() {\n-            // We want to suppress \"duplicate\" errors with the same span.\n-            for error in error_set {\n-                if let Some(index) = error.index {\n-                    // Suppress errors that are either:\n-                    // 1) strictly implied by another error.\n-                    // 2) implied by an error with a smaller index.\n-                    for error2 in error_set {\n-                        if error2.index.map_or(false, |index2| is_suppressed[index2]) {\n-                            // Avoid errors being suppressed by already-suppressed\n-                            // errors, to prevent all errors from being suppressed\n-                            // at once.\n-                            continue;\n-                        }\n-\n-                        if self.error_implies(&error2.predicate, &error.predicate)\n-                            && !(error2.index >= error.index\n-                                && self.error_implies(&error.predicate, &error2.predicate))\n-                        {\n-                            info!(\"skipping {:?} (implied by {:?})\", error, error2);\n-                            is_suppressed[index] = true;\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        for (error, suppressed) in errors.iter().zip(is_suppressed) {\n-            if !suppressed {\n-                self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n-            }\n-        }\n-    }\n-\n-    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n-    // `error` occurring implies that `cond` occurs.\n-    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n-        if cond == error {\n-            return true;\n-        }\n-\n-        let (cond, error) = match (cond, error) {\n-            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error, _)) => (cond, error),\n-            _ => {\n-                // FIXME: make this work in other cases too.\n-                return false;\n-            }\n-        };\n-\n-        for implication in super::elaborate_predicates(self.tcx, vec![*cond]) {\n-            if let ty::Predicate::Trait(implication, _) = implication {\n-                let error = error.to_poly_trait_ref();\n-                let implication = implication.to_poly_trait_ref();\n-                // FIXME: I'm just not taking associated types at all here.\n-                // Eventually I'll need to implement param-env-aware\n-                // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n-                let param_env = ty::ParamEnv::empty();\n-                if self.can_sub(param_env, error, implication).is_ok() {\n-                    debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n-                    return true;\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n-\n-    fn report_fulfillment_error(\n-        &self,\n-        error: &FulfillmentError<'tcx>,\n-        body_id: Option<hir::BodyId>,\n-        fallback_has_occurred: bool,\n-    ) {\n-        debug!(\"report_fulfillment_error({:?})\", error);\n-        match error.code {\n-            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n-                self.report_selection_error(\n-                    &error.obligation,\n-                    selection_error,\n-                    fallback_has_occurred,\n-                    error.points_at_arg_span,\n-                );\n-            }\n-            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n-                self.report_projection_error(&error.obligation, e);\n-            }\n-            FulfillmentErrorCode::CodeAmbiguity => {\n-                self.maybe_report_ambiguity(&error.obligation, body_id);\n-            }\n-            FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n-                self.report_mismatched_types(\n-                    &error.obligation.cause,\n-                    expected_found.expected,\n-                    expected_found.found,\n-                    err.clone(),\n-                )\n-                .emit();\n-            }\n-        }\n-    }\n-\n-    fn report_projection_error(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-        error: &MismatchedProjectionTypes<'tcx>,\n-    ) {\n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n-\n-        if predicate.references_error() {\n-            return;\n-        }\n-\n-        self.probe(|_| {\n-            let err_buf;\n-            let mut err = &error.err;\n-            let mut values = None;\n-\n-            // try to find the mismatched types to report the error with.\n-            //\n-            // this can fail if the problem was higher-ranked, in which\n-            // cause I have no idea for a good error message.\n-            if let ty::Predicate::Projection(ref data) = predicate {\n-                let mut selcx = SelectionContext::new(self);\n-                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n-                    obligation.cause.span,\n-                    infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    data,\n-                );\n-                let mut obligations = vec![];\n-                let normalized_ty = super::normalize_projection_type(\n-                    &mut selcx,\n-                    obligation.param_env,\n-                    data.projection_ty,\n-                    obligation.cause.clone(),\n-                    0,\n-                    &mut obligations,\n-                );\n-\n-                debug!(\n-                    \"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n-                    obligation.cause, obligation.param_env\n-                );\n-\n-                debug!(\n-                    \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n-                    normalized_ty, data.ty\n-                );\n-\n-                let is_normalized_ty_expected = match &obligation.cause.code {\n-                    ObligationCauseCode::ItemObligation(_)\n-                    | ObligationCauseCode::BindingObligation(_, _)\n-                    | ObligationCauseCode::ObjectCastObligation(_) => false,\n-                    _ => true,\n-                };\n-\n-                if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n-                    is_normalized_ty_expected,\n-                    normalized_ty,\n-                    data.ty,\n-                ) {\n-                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n-                        is_normalized_ty_expected,\n-                        normalized_ty,\n-                        data.ty,\n-                    )));\n-\n-                    err_buf = error;\n-                    err = &err_buf;\n-                }\n-            }\n-\n-            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n-            let error_id = (DiagnosticMessageId::ErrorId(271), Some(obligation.cause.span), msg);\n-            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-            if fresh {\n-                let mut diag = struct_span_err!(\n-                    self.tcx.sess,\n-                    obligation.cause.span,\n-                    E0271,\n-                    \"type mismatch resolving `{}`\",\n-                    predicate\n-                );\n-                self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n-                self.note_obligation_cause(&mut diag, obligation);\n-                diag.emit();\n-            }\n-        });\n-    }\n-\n-    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-        /// returns the fuzzy category of a given type, or None\n-        /// if the type can be equated to any type.\n-        fn type_category(t: Ty<'_>) -> Option<u32> {\n-            match t.kind {\n-                ty::Bool => Some(0),\n-                ty::Char => Some(1),\n-                ty::Str => Some(2),\n-                ty::Int(..) | ty::Uint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n-                ty::Float(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n-                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n-                ty::Array(..) | ty::Slice(..) => Some(6),\n-                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n-                ty::Dynamic(..) => Some(8),\n-                ty::Closure(..) => Some(9),\n-                ty::Tuple(..) => Some(10),\n-                ty::Projection(..) => Some(11),\n-                ty::Param(..) => Some(12),\n-                ty::Opaque(..) => Some(13),\n-                ty::Never => Some(14),\n-                ty::Adt(adt, ..) => match adt.adt_kind() {\n-                    AdtKind::Struct => Some(15),\n-                    AdtKind::Union => Some(16),\n-                    AdtKind::Enum => Some(17),\n-                },\n-                ty::Generator(..) => Some(18),\n-                ty::Foreign(..) => Some(19),\n-                ty::GeneratorWitness(..) => Some(20),\n-                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n-                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n-            }\n-        }\n-\n-        match (type_category(a), type_category(b)) {\n-            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n-                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n-                _ => cat_a == cat_b,\n-            },\n-            // infer and error can be equated to all types\n-            _ => true,\n-        }\n-    }\n-\n-    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n-        self.tcx.hir().body(body_id).generator_kind.map(|gen_kind| match gen_kind {\n-            hir::GeneratorKind::Gen => \"a generator\",\n-            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"an async block\",\n-            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"an async function\",\n-            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"an async closure\",\n-        })\n-    }\n-\n-    fn find_similar_impl_candidates(\n-        &self,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n-    ) -> Vec<ty::TraitRef<'tcx>> {\n-        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n-        let all_impls = self.tcx.all_impls(trait_ref.def_id());\n-\n-        match simp {\n-            Some(simp) => all_impls\n-                .iter()\n-                .filter_map(|&def_id| {\n-                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                    let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n-                    if let Some(imp_simp) = imp_simp {\n-                        if simp != imp_simp {\n-                            return None;\n-                        }\n-                    }\n-\n-                    Some(imp)\n-                })\n-                .collect(),\n-            None => {\n-                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n-            }\n-        }\n-    }\n-\n-    fn report_similar_impl_candidates(\n-        &self,\n-        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n-        err: &mut DiagnosticBuilder<'_>,\n-    ) {\n-        if impl_candidates.is_empty() {\n-            return;\n-        }\n-\n-        let len = impl_candidates.len();\n-        let end = if impl_candidates.len() <= 5 { impl_candidates.len() } else { 4 };\n-\n-        let normalize = |candidate| {\n-            self.tcx.infer_ctxt().enter(|ref infcx| {\n-                let normalized = infcx\n-                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n-                    .normalize(candidate)\n-                    .ok();\n-                match normalized {\n-                    Some(normalized) => format!(\"\\n  {:?}\", normalized.value),\n-                    None => format!(\"\\n  {:?}\", candidate),\n-                }\n-            })\n-        };\n-\n-        // Sort impl candidates so that ordering is consistent for UI tests.\n-        let mut normalized_impl_candidates =\n-            impl_candidates.iter().map(normalize).collect::<Vec<String>>();\n-\n-        // Sort before taking the `..end` range,\n-        // because the ordering of `impl_candidates` may not be deterministic:\n-        // https://github.com/rust-lang/rust/pull/57475#issuecomment-455519507\n-        normalized_impl_candidates.sort();\n-\n-        err.help(&format!(\n-            \"the following implementations were found:{}{}\",\n-            normalized_impl_candidates[..end].join(\"\"),\n-            if len > 5 { format!(\"\\nand {} others\", len - 4) } else { String::new() }\n-        ));\n-    }\n-\n-    /// Reports that an overflow has occurred and halts compilation. We\n-    /// halt compilation unconditionally because it is important that\n-    /// overflows never be masked -- they basically represent computations\n-    /// whose result could not be truly determined and thus we can't say\n-    /// if the program type checks or not -- and they are unusual\n-    /// occurrences in any case.\n-    pub fn report_overflow_error<T>(\n-        &self,\n-        obligation: &Obligation<'tcx, T>,\n-        suggest_increasing_limit: bool,\n-    ) -> !\n-    where\n-        T: fmt::Display + TypeFoldable<'tcx>,\n-    {\n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            obligation.cause.span,\n-            E0275,\n-            \"overflow evaluating the requirement `{}`\",\n-            predicate\n-        );\n-\n-        if suggest_increasing_limit {\n-            self.suggest_new_overflow_limit(&mut err);\n-        }\n-\n-        self.note_obligation_cause_code(\n-            &mut err,\n-            &obligation.predicate,\n-            &obligation.cause.code,\n-            &mut vec![],\n-        );\n-\n-        err.emit();\n-        self.tcx.sess.abort_if_errors();\n-        bug!();\n-    }\n-\n-    /// Reports that a cycle was detected which led to overflow and halts\n-    /// compilation. This is equivalent to `report_overflow_error` except\n-    /// that we can give a more helpful error message (and, in particular,\n-    /// we do not suggest increasing the overflow limit, which is not\n-    /// going to help).\n-    pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n-        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n-        assert!(!cycle.is_empty());\n-\n-        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n-\n-        self.report_overflow_error(&cycle[0], false);\n-    }\n-\n     pub fn report_extra_impl_obligation(\n         &self,\n         error_span: Span,\n@@ -469,550 +33,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         err\n     }\n-\n-    /// Gets the parent trait chain start\n-    fn get_parent_trait_ref(\n-        &self,\n-        code: &ObligationCauseCode<'tcx>,\n-    ) -> Option<(String, Option<Span>)> {\n-        match code {\n-            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n-                match self.get_parent_trait_ref(&data.parent_code) {\n-                    Some(t) => Some(t),\n-                    None => {\n-                        let ty = parent_trait_ref.skip_binder().self_ty();\n-                        let span =\n-                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n-                        Some((ty.to_string(), span))\n-                    }\n-                }\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn report_selection_error(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-        error: &SelectionError<'tcx>,\n-        fallback_has_occurred: bool,\n-        points_at_arg: bool,\n-    ) {\n-        let tcx = self.tcx;\n-        let span = obligation.cause.span;\n-\n-        let mut err = match *error {\n-            SelectionError::Unimplemented => {\n-                if let ObligationCauseCode::CompareImplMethodObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                }\n-                | ObligationCauseCode::CompareImplTypeObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                } = obligation.cause.code\n-                {\n-                    self.report_extra_impl_obligation(\n-                        span,\n-                        item_name,\n-                        impl_item_def_id,\n-                        trait_item_def_id,\n-                        &format!(\"`{}`\", obligation.predicate),\n-                    )\n-                    .emit();\n-                    return;\n-                }\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(ref trait_predicate, _) => {\n-                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n-\n-                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n-                            return;\n-                        }\n-                        let trait_ref = trait_predicate.to_poly_trait_ref();\n-                        let (post_message, pre_message, type_def) = self\n-                            .get_parent_trait_ref(&obligation.cause.code)\n-                            .map(|(t, s)| {\n-                                (\n-                                    format!(\" in `{}`\", t),\n-                                    format!(\"within `{}`, \", t),\n-                                    s.map(|s| (format!(\"within this `{}`\", t), s)),\n-                                )\n-                            })\n-                            .unwrap_or_default();\n-\n-                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n-                            self.on_unimplemented_note(trait_ref, obligation);\n-                        let have_alt_message = message.is_some() || label.is_some();\n-                        let is_try = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_to_snippet(span)\n-                            .map(|s| &s == \"?\")\n-                            .unwrap_or(false);\n-                        let is_from = format!(\"{}\", trait_ref.print_only_trait_path())\n-                            .starts_with(\"std::convert::From<\");\n-                        let (message, note) = if is_try && is_from {\n-                            (\n-                                Some(format!(\n-                                    \"`?` couldn't convert the error to `{}`\",\n-                                    trait_ref.self_ty(),\n-                                )),\n-                                Some(\n-                                    \"the question mark operation (`?`) implicitly performs a \\\n-                                     conversion on the error value using the `From` trait\"\n-                                        .to_owned(),\n-                                ),\n-                            )\n-                        } else {\n-                            (message, note)\n-                        };\n-\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0277,\n-                            \"{}\",\n-                            message.unwrap_or_else(|| format!(\n-                                \"the trait bound `{}` is not satisfied{}\",\n-                                trait_ref.without_const().to_predicate(),\n-                                post_message,\n-                            ))\n-                        );\n-\n-                        let explanation =\n-                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n-                                \"consider using `()`, or a `Result`\".to_owned()\n-                            } else {\n-                                format!(\n-                                    \"{}the trait `{}` is not implemented for `{}`\",\n-                                    pre_message,\n-                                    trait_ref.print_only_trait_path(),\n-                                    trait_ref.self_ty(),\n-                                )\n-                            };\n-\n-                        if self.suggest_add_reference_to_arg(\n-                            &obligation,\n-                            &mut err,\n-                            &trait_ref,\n-                            points_at_arg,\n-                            have_alt_message,\n-                        ) {\n-                            self.note_obligation_cause(&mut err, obligation);\n-                            err.emit();\n-                            return;\n-                        }\n-                        if let Some(ref s) = label {\n-                            // If it has a custom `#[rustc_on_unimplemented]`\n-                            // error message, let's display it as the label!\n-                            err.span_label(span, s.as_str());\n-                            err.help(&explanation);\n-                        } else {\n-                            err.span_label(span, explanation);\n-                        }\n-                        if let Some((msg, span)) = type_def {\n-                            err.span_label(span, &msg);\n-                        }\n-                        if let Some(ref s) = note {\n-                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n-                            err.note(s.as_str());\n-                        }\n-                        if let Some(ref s) = enclosing_scope {\n-                            let enclosing_scope_span = tcx.def_span(\n-                                tcx.hir()\n-                                    .opt_local_def_id(obligation.cause.body_id)\n-                                    .unwrap_or_else(|| {\n-                                        tcx.hir().body_owner_def_id(hir::BodyId {\n-                                            hir_id: obligation.cause.body_id,\n-                                        })\n-                                    }),\n-                            );\n-\n-                            err.span_label(enclosing_scope_span, s.as_str());\n-                        }\n-\n-                        self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n-                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n-                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n-                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n-                        self.note_version_mismatch(&mut err, &trait_ref);\n-                        if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n-                            err.emit();\n-                            return;\n-                        }\n-\n-                        // Try to report a help message\n-                        if !trait_ref.has_infer_types_or_consts()\n-                            && self.predicate_can_apply(obligation.param_env, trait_ref)\n-                        {\n-                            // If a where-clause may be useful, remind the\n-                            // user that they can add it.\n-                            //\n-                            // don't display an on-unimplemented note, as\n-                            // these notes will often be of the form\n-                            //     \"the type `T` can't be frobnicated\"\n-                            // which is somewhat confusing.\n-                            self.suggest_restricting_param_bound(\n-                                &mut err,\n-                                &trait_ref,\n-                                obligation.cause.body_id,\n-                            );\n-                        } else {\n-                            if !have_alt_message {\n-                                // Can't show anything else useful, try to find similar impls.\n-                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n-                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n-                            }\n-                            self.suggest_change_mut(\n-                                &obligation,\n-                                &mut err,\n-                                &trait_ref,\n-                                points_at_arg,\n-                            );\n-                        }\n-\n-                        // If this error is due to `!: Trait` not implemented but `(): Trait` is\n-                        // implemented, and fallback has occurred, then it could be due to a\n-                        // variable that used to fallback to `()` now falling back to `!`. Issue a\n-                        // note informing about the change in behaviour.\n-                        if trait_predicate.skip_binder().self_ty().is_never()\n-                            && fallback_has_occurred\n-                        {\n-                            let predicate = trait_predicate.map_bound(|mut trait_pred| {\n-                                trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n-                                    self.tcx.mk_unit(),\n-                                    &trait_pred.trait_ref.substs[1..],\n-                                );\n-                                trait_pred\n-                            });\n-                            let unit_obligation = Obligation {\n-                                predicate: ty::Predicate::Trait(\n-                                    predicate,\n-                                    hir::Constness::NotConst,\n-                                ),\n-                                ..obligation.clone()\n-                            };\n-                            if self.predicate_may_hold(&unit_obligation) {\n-                                err.note(\n-                                    \"the trait is implemented for `()`. \\\n-                                     Possibly this error has been caused by changes to \\\n-                                     Rust's type-inference algorithm (see issue #48950 \\\n-                                     <https://github.com/rust-lang/rust/issues/48950> \\\n-                                     for more information). Consider whether you meant to use \\\n-                                     the type `()` here instead.\",\n-                                );\n-                            }\n-                        }\n-\n-                        err\n-                    }\n-\n-                    ty::Predicate::Subtype(ref predicate) => {\n-                        // Errors for Subtype predicates show up as\n-                        // `FulfillmentErrorCode::CodeSubtypeError`,\n-                        // not selection error.\n-                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n-                    }\n-\n-                    ty::Predicate::RegionOutlives(ref predicate) => {\n-                        let predicate = self.resolve_vars_if_possible(predicate);\n-                        let err = self\n-                            .region_outlives_predicate(&obligation.cause, &predicate)\n-                            .err()\n-                            .unwrap();\n-                        struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0279,\n-                            \"the requirement `{}` is not satisfied (`{}`)\",\n-                            predicate,\n-                            err,\n-                        )\n-                    }\n-\n-                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n-                        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n-                        struct_span_err!(\n-                            self.tcx.sess,\n-                            span,\n-                            E0280,\n-                            \"the requirement `{}` is not satisfied\",\n-                            predicate\n-                        )\n-                    }\n-\n-                    ty::Predicate::ObjectSafe(trait_def_id) => {\n-                        let violations = self.tcx.object_safety_violations(trait_def_id);\n-                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n-                    }\n-\n-                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n-                        let closure_span = self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n-                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n-                        let mut err = struct_span_err!(\n-                            self.tcx.sess,\n-                            closure_span,\n-                            E0525,\n-                            \"expected a closure that implements the `{}` trait, \\\n-                             but this closure only implements `{}`\",\n-                            kind,\n-                            found_kind\n-                        );\n-\n-                        err.span_label(\n-                            closure_span,\n-                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n-                        );\n-                        err.span_label(\n-                            obligation.cause.span,\n-                            format!(\"the requirement to implement `{}` derives from here\", kind),\n-                        );\n-\n-                        // Additional context information explaining why the closure only implements\n-                        // a particular trait.\n-                        if let Some(tables) = self.in_progress_tables {\n-                            let tables = tables.borrow();\n-                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n-                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n-                                    err.span_label(\n-                                        *span,\n-                                        format!(\n-                                            \"closure is `FnOnce` because it moves the \\\n-                                         variable `{}` out of its environment\",\n-                                            name\n-                                        ),\n-                                    );\n-                                }\n-                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n-                                    err.span_label(\n-                                        *span,\n-                                        format!(\n-                                            \"closure is `FnMut` because it mutates the \\\n-                                         variable `{}` here\",\n-                                            name\n-                                        ),\n-                                    );\n-                                }\n-                                _ => {}\n-                            }\n-                        }\n-\n-                        err.emit();\n-                        return;\n-                    }\n-\n-                    ty::Predicate::WellFormed(ty) => {\n-                        // WF predicates cannot themselves make\n-                        // errors. They can only block due to\n-                        // ambiguity; otherwise, they always\n-                        // degenerate into other obligations\n-                        // (which may fail).\n-                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                    }\n-\n-                    ty::Predicate::ConstEvaluatable(..) => {\n-                        // Errors for `ConstEvaluatable` predicates show up as\n-                        // `SelectionError::ConstEvalFailure`,\n-                        // not `Unimplemented`.\n-                        span_bug!(\n-                            span,\n-                            \"const-evaluatable requirement gave wrong error: `{:?}`\",\n-                            obligation\n-                        )\n-                    }\n-                }\n-            }\n-\n-            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n-                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n-                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n-\n-                if expected_trait_ref.self_ty().references_error() {\n-                    return;\n-                }\n-\n-                let found_trait_ty = found_trait_ref.self_ty();\n-\n-                let found_did = match found_trait_ty.kind {\n-                    ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n-                    ty::Adt(def, _) => Some(def.did),\n-                    _ => None,\n-                };\n-\n-                let found_span = found_did\n-                    .and_then(|did| self.tcx.hir().span_if_local(did))\n-                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n-\n-                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n-                    // We check closures twice, with obligations flowing in different directions,\n-                    // but we want to complain about them only once.\n-                    return;\n-                }\n-\n-                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n-\n-                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n-                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n-                    _ => vec![ArgKind::empty()],\n-                };\n-\n-                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n-                let expected = match expected_ty.kind {\n-                    ty::Tuple(ref tys) => tys\n-                        .iter()\n-                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n-                        .collect(),\n-                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n-                };\n-\n-                if found.len() == expected.len() {\n-                    self.report_closure_arg_mismatch(\n-                        span,\n-                        found_span,\n-                        found_trait_ref,\n-                        expected_trait_ref,\n-                    )\n-                } else {\n-                    let (closure_span, found) = found_did\n-                        .and_then(|did| self.tcx.hir().get_if_local(did))\n-                        .map(|node| {\n-                            let (found_span, found) = self.get_fn_like_arguments(node);\n-                            (Some(found_span), found)\n-                        })\n-                        .unwrap_or((found_span, found));\n-\n-                    self.report_arg_count_mismatch(\n-                        span,\n-                        closure_span,\n-                        expected,\n-                        found,\n-                        found_trait_ty.is_closure(),\n-                    )\n-                }\n-            }\n-\n-            TraitNotObjectSafe(did) => {\n-                let violations = self.tcx.object_safety_violations(did);\n-                report_object_safety_error(self.tcx, span, did, violations)\n-            }\n-\n-            ConstEvalFailure(ErrorHandled::TooGeneric) => {\n-                // In this instance, we have a const expression containing an unevaluated\n-                // generic parameter. We have no idea whether this expression is valid or\n-                // not (e.g. it might result in an error), but we don't want to just assume\n-                // that it's okay, because that might result in post-monomorphisation time\n-                // errors. The onus is really on the caller to provide values that it can\n-                // prove are well-formed.\n-                let mut err = self\n-                    .tcx\n-                    .sess\n-                    .struct_span_err(span, \"constant expression depends on a generic parameter\");\n-                // FIXME(const_generics): we should suggest to the user how they can resolve this\n-                // issue. However, this is currently not actually possible\n-                // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n-                err.note(\"this may fail depending on what value the parameter takes\");\n-                err\n-            }\n-\n-            // Already reported in the query.\n-            ConstEvalFailure(ErrorHandled::Reported) => {\n-                self.tcx.sess.delay_span_bug(span, \"constant in type had an ignored error\");\n-                return;\n-            }\n-\n-            Overflow => {\n-                bug!(\"overflow should be handled before the `report_selection_error` path\");\n-            }\n-        };\n-\n-        self.note_obligation_cause(&mut err, obligation);\n-        self.point_at_returns_when_relevant(&mut err, &obligation);\n-\n-        err.emit();\n-    }\n-\n-    /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n-    /// with the same path as `trait_ref`, a help message about\n-    /// a probable version mismatch is added to `err`\n-    fn note_version_mismatch(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::PolyTraitRef<'tcx>,\n-    ) {\n-        let get_trait_impl = |trait_def_id| {\n-            let mut trait_impl = None;\n-            self.tcx.for_each_relevant_impl(trait_def_id, trait_ref.self_ty(), |impl_def_id| {\n-                if trait_impl.is_none() {\n-                    trait_impl = Some(impl_def_id);\n-                }\n-            });\n-            trait_impl\n-        };\n-        let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n-        let all_traits = self.tcx.all_traits(LOCAL_CRATE);\n-        let traits_with_same_path: std::collections::BTreeSet<_> = all_traits\n-            .iter()\n-            .filter(|trait_def_id| **trait_def_id != trait_ref.def_id())\n-            .filter(|trait_def_id| self.tcx.def_path_str(**trait_def_id) == required_trait_path)\n-            .collect();\n-        for trait_with_same_path in traits_with_same_path {\n-            if let Some(impl_def_id) = get_trait_impl(*trait_with_same_path) {\n-                let impl_span = self.tcx.def_span(impl_def_id);\n-                err.span_help(impl_span, \"trait impl with same name found\");\n-                let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n-                let crate_msg = format!(\n-                    \"perhaps two different versions of crate `{}` are being used?\",\n-                    trait_crate\n-                );\n-                err.note(&crate_msg);\n-            }\n-        }\n-    }\n-\n-    fn mk_obligation_for_def_id(\n-        &self,\n-        def_id: DefId,\n-        output_ty: Ty<'tcx>,\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> PredicateObligation<'tcx> {\n-        let new_trait_ref =\n-            ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n-        Obligation::new(cause, param_env, new_trait_ref.without_const().to_predicate())\n-    }\n-}\n-\n-pub fn recursive_type_with_infinite_size_error(\n-    tcx: TyCtxt<'tcx>,\n-    type_def_id: DefId,\n-) -> DiagnosticBuilder<'tcx> {\n-    assert!(type_def_id.is_local());\n-    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n-    let span = tcx.sess.source_map().def_span(span);\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0072,\n-        \"recursive type `{}` has infinite size\",\n-        tcx.def_path_str(type_def_id)\n-    );\n-    err.span_label(span, \"recursive type has infinite size\");\n-    err.help(&format!(\n-        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n-                           at some point to make `{}` representable\",\n-        tcx.def_path_str(type_def_id)\n-    ));\n-    err\n }\n \n pub fn report_object_safety_error(\n@@ -1084,560 +104,3 @@ pub fn report_object_safety_error(\n \n     err\n }\n-\n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    fn maybe_report_ambiguity(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-        body_id: Option<hir::BodyId>,\n-    ) {\n-        // Unable to successfully determine, probably means\n-        // insufficient type information, but could mean\n-        // ambiguous impls. The latter *ought* to be a\n-        // coherence violation, so we don't report it here.\n-\n-        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n-        let span = obligation.cause.span;\n-\n-        debug!(\n-            \"maybe_report_ambiguity(predicate={:?}, obligation={:?} body_id={:?}, code={:?})\",\n-            predicate, obligation, body_id, obligation.cause.code,\n-        );\n-\n-        // Ambiguity errors are often caused as fallout from earlier\n-        // errors. So just ignore them if this infcx is tainted.\n-        if self.is_tainted_by_errors() {\n-            return;\n-        }\n-\n-        let mut err = match predicate {\n-            ty::Predicate::Trait(ref data, _) => {\n-                let trait_ref = data.to_poly_trait_ref();\n-                let self_ty = trait_ref.self_ty();\n-                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n-\n-                if predicate.references_error() {\n-                    return;\n-                }\n-                // Typically, this ambiguity should only happen if\n-                // there are unresolved type inference variables\n-                // (otherwise it would suggest a coherence\n-                // failure). But given #21974 that is not necessarily\n-                // the case -- we can have multiple where clauses that\n-                // are only distinguished by a region, which results\n-                // in an ambiguity even when all types are fully\n-                // known, since we don't dispatch based on region\n-                // relationships.\n-\n-                // This is kind of a hack: it frequently happens that some earlier\n-                // error prevents types from being fully inferred, and then we get\n-                // a bunch of uninteresting errors saying something like \"<generic\n-                // #0> doesn't implement Sized\".  It may even be true that we\n-                // could just skip over all checks where the self-ty is an\n-                // inference variable, but I was afraid that there might be an\n-                // inference variable created, registered as an obligation, and\n-                // then never forced by writeback, and hence by skipping here we'd\n-                // be ignoring the fact that we don't KNOW the type works\n-                // out. Though even that would probably be harmless, given that\n-                // we're only talking about builtin traits, which are known to be\n-                // inhabited. We used to check for `self.tcx.sess.has_errors()` to\n-                // avoid inundating the user with unnecessary errors, but we now\n-                // check upstream for type errors and don't add the obligations to\n-                // begin with in those cases.\n-                if self\n-                    .tcx\n-                    .lang_items()\n-                    .sized_trait()\n-                    .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n-                {\n-                    self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n-                    return;\n-                }\n-                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0283);\n-                err.note(&format!(\"cannot resolve `{}`\", predicate));\n-                if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n-                    self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n-                } else if let (\n-                    Ok(ref snippet),\n-                    ObligationCauseCode::BindingObligation(ref def_id, _),\n-                ) =\n-                    (self.tcx.sess.source_map().span_to_snippet(span), &obligation.cause.code)\n-                {\n-                    let generics = self.tcx.generics_of(*def_id);\n-                    if !generics.params.is_empty() && !snippet.ends_with('>') {\n-                        // FIXME: To avoid spurious suggestions in functions where type arguments\n-                        // where already supplied, we check the snippet to make sure it doesn't\n-                        // end with a turbofish. Ideally we would have access to a `PathSegment`\n-                        // instead. Otherwise we would produce the following output:\n-                        //\n-                        // error[E0283]: type annotations needed\n-                        //   --> $DIR/issue-54954.rs:3:24\n-                        //    |\n-                        // LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n-                        //    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-                        //    |                        |\n-                        //    |                        cannot infer type\n-                        //    |                        help: consider specifying the type argument\n-                        //    |                        in the function call:\n-                        //    |                        `Tt::const_val::<[i8; 123]>::<T>`\n-                        // ...\n-                        // LL |     const fn const_val<T: Sized>() -> usize {\n-                        //    |              --------- - required by this bound in `Tt::const_val`\n-                        //    |\n-                        //    = note: cannot resolve `_: Tt`\n-\n-                        err.span_suggestion(\n-                            span,\n-                            &format!(\n-                                \"consider specifying the type argument{} in the function call\",\n-                                if generics.params.len() > 1 { \"s\" } else { \"\" },\n-                            ),\n-                            format!(\n-                                \"{}::<{}>\",\n-                                snippet,\n-                                generics\n-                                    .params\n-                                    .iter()\n-                                    .map(|p| p.name.to_string())\n-                                    .collect::<Vec<String>>()\n-                                    .join(\", \")\n-                            ),\n-                            Applicability::HasPlaceholders,\n-                        );\n-                    }\n-                }\n-                err\n-            }\n-\n-            ty::Predicate::WellFormed(ty) => {\n-                // Same hacky approach as above to avoid deluging user\n-                // with error messages.\n-                if ty.references_error() || self.tcx.sess.has_errors() {\n-                    return;\n-                }\n-                self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n-            }\n-\n-            ty::Predicate::Subtype(ref data) => {\n-                if data.references_error() || self.tcx.sess.has_errors() {\n-                    // no need to overload user in such cases\n-                    return;\n-                }\n-                let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n-                // both must be type variables, or the other would've been instantiated\n-                assert!(a.is_ty_var() && b.is_ty_var());\n-                self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n-            }\n-            ty::Predicate::Projection(ref data) => {\n-                let trait_ref = data.to_poly_trait_ref(self.tcx);\n-                let self_ty = trait_ref.self_ty();\n-                if predicate.references_error() {\n-                    return;\n-                }\n-                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0284);\n-                err.note(&format!(\"cannot resolve `{}`\", predicate));\n-                err\n-            }\n-\n-            _ => {\n-                if self.tcx.sess.has_errors() {\n-                    return;\n-                }\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess,\n-                    span,\n-                    E0284,\n-                    \"type annotations needed: cannot resolve `{}`\",\n-                    predicate,\n-                );\n-                err.span_label(span, &format!(\"cannot resolve `{}`\", predicate));\n-                err\n-            }\n-        };\n-        self.note_obligation_cause(&mut err, obligation);\n-        err.emit();\n-    }\n-\n-    /// Returns `true` if the trait predicate may apply for *some* assignment\n-    /// to the type parameters.\n-    fn predicate_can_apply(\n-        &self,\n-        param_env: ty::ParamEnv<'tcx>,\n-        pred: ty::PolyTraitRef<'tcx>,\n-    ) -> bool {\n-        struct ParamToVarFolder<'a, 'tcx> {\n-            infcx: &'a InferCtxt<'a, 'tcx>,\n-            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n-        }\n-\n-        impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx> {\n-            fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n-                self.infcx.tcx\n-            }\n-\n-            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                if let ty::Param(ty::ParamTy { name, .. }) = ty.kind {\n-                    let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(|| {\n-                        infcx.next_ty_var(TypeVariableOrigin {\n-                            kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n-                            span: DUMMY_SP,\n-                        })\n-                    })\n-                } else {\n-                    ty.super_fold_with(self)\n-                }\n-            }\n-        }\n-\n-        self.probe(|_| {\n-            let mut selcx = SelectionContext::new(self);\n-\n-            let cleaned_pred =\n-                pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n-\n-            let cleaned_pred = super::project::normalize(\n-                &mut selcx,\n-                param_env,\n-                ObligationCause::dummy(),\n-                &cleaned_pred,\n-            )\n-            .value;\n-\n-            let obligation = Obligation::new(\n-                ObligationCause::dummy(),\n-                param_env,\n-                cleaned_pred.without_const().to_predicate(),\n-            );\n-\n-            self.predicate_may_hold(&obligation)\n-        })\n-    }\n-\n-    fn note_obligation_cause(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        obligation: &PredicateObligation<'tcx>,\n-    ) {\n-        // First, attempt to add note to this error with an async-await-specific\n-        // message, and fall back to regular note otherwise.\n-        if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n-            self.note_obligation_cause_code(\n-                err,\n-                &obligation.predicate,\n-                &obligation.cause.code,\n-                &mut vec![],\n-            );\n-            self.suggest_unsized_bound_if_applicable(err, obligation);\n-        }\n-    }\n-\n-    fn suggest_unsized_bound_if_applicable(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        obligation: &PredicateObligation<'tcx>,\n-    ) {\n-        if let (\n-            ty::Predicate::Trait(pred, _),\n-            ObligationCauseCode::BindingObligation(item_def_id, span),\n-        ) = (&obligation.predicate, &obligation.cause.code)\n-        {\n-            if let (Some(generics), true) = (\n-                self.tcx.hir().get_if_local(*item_def_id).as_ref().and_then(|n| n.generics()),\n-                Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n-            ) {\n-                for param in generics.params {\n-                    if param.span == *span\n-                        && !param.bounds.iter().any(|bound| {\n-                            bound.trait_def_id() == self.tcx.lang_items().sized_trait()\n-                        })\n-                    {\n-                        let (span, separator) = match param.bounds {\n-                            [] => (span.shrink_to_hi(), \":\"),\n-                            [.., bound] => (bound.span().shrink_to_hi(), \" + \"),\n-                        };\n-                        err.span_suggestion(\n-                            span,\n-                            \"consider relaxing the implicit `Sized` restriction\",\n-                            format!(\"{} ?Sized\", separator),\n-                            Applicability::MachineApplicable,\n-                        );\n-                        return;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn is_recursive_obligation(\n-        &self,\n-        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n-        cause_code: &ObligationCauseCode<'tcx>,\n-    ) -> bool {\n-        if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n-            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n-\n-            if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-}\n-\n-/// Summarizes information\n-#[derive(Clone)]\n-pub enum ArgKind {\n-    /// An argument of non-tuple type. Parameters are (name, ty)\n-    Arg(String, String),\n-\n-    /// An argument of tuple type. For a \"found\" argument, the span is\n-    /// the locationo in the source of the pattern. For a \"expected\"\n-    /// argument, it will be None. The vector is a list of (name, ty)\n-    /// strings for the components of the tuple.\n-    Tuple(Option<Span>, Vec<(String, String)>),\n-}\n-\n-impl ArgKind {\n-    fn empty() -> ArgKind {\n-        ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n-    }\n-\n-    /// Creates an `ArgKind` from the expected type of an\n-    /// argument. It has no name (`_`) and an optional source span.\n-    pub fn from_expected_ty(t: Ty<'_>, span: Option<Span>) -> ArgKind {\n-        match t.kind {\n-            ty::Tuple(ref tys) => ArgKind::Tuple(\n-                span,\n-                tys.iter().map(|ty| (\"_\".to_owned(), ty.to_string())).collect::<Vec<_>>(),\n-            ),\n-            _ => ArgKind::Arg(\"_\".to_owned(), t.to_string()),\n-        }\n-    }\n-}\n-\n-/// Suggest restricting a type param with a new bound.\n-pub fn suggest_constraining_type_param(\n-    tcx: TyCtxt<'_>,\n-    generics: &hir::Generics<'_>,\n-    err: &mut DiagnosticBuilder<'_>,\n-    param_name: &str,\n-    constraint: &str,\n-    source_map: &SourceMap,\n-    span: Span,\n-    def_id: Option<DefId>,\n-) -> bool {\n-    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound with\";\n-    const MSG_RESTRICT_TYPE: &str = \"consider restricting this type parameter with\";\n-    const MSG_RESTRICT_TYPE_FURTHER: &str = \"consider further restricting this type parameter with\";\n-\n-    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n-\n-    let param = if let Some(param) = param {\n-        param\n-    } else {\n-        return false;\n-    };\n-\n-    if def_id == tcx.lang_items().sized_trait() {\n-        // Type parameters are already `Sized` by default.\n-        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n-        return true;\n-    }\n-\n-    if param_name.starts_with(\"impl \") {\n-        // If there's an `impl Trait` used in argument position, suggest\n-        // restricting it:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             help: consider further restricting this bound with `+ Bar`\n-        //\n-        // Suggestion for tools in this case is:\n-        //\n-        //   fn foo(t: impl Foo) { ... }\n-        //             --------\n-        //             |\n-        //             replace with: `impl Foo + Bar`\n-\n-        err.span_help(param.span, &format!(\"{} `+ {}`\", MSG_RESTRICT_BOUND_FURTHER, constraint));\n-\n-        err.tool_only_span_suggestion(\n-            param.span,\n-            MSG_RESTRICT_BOUND_FURTHER,\n-            format!(\"{} + {}\", param_name, constraint),\n-            Applicability::MachineApplicable,\n-        );\n-\n-        return true;\n-    }\n-\n-    if generics.where_clause.predicates.is_empty() {\n-        if let Some(bounds_span) = param.bounds_span() {\n-            // If user has provided some bounds, suggest restricting them:\n-            //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //             ---\n-            //             |\n-            //             help: consider further restricting this bound with `+ Bar`\n-            //\n-            // Suggestion for tools in this case is:\n-            //\n-            //   fn foo<T: Foo>(t: T) { ... }\n-            //          --\n-            //          |\n-            //          replace with: `T: Bar +`\n-\n-            err.span_help(\n-                bounds_span,\n-                &format!(\"{} `+ {}`\", MSG_RESTRICT_BOUND_FURTHER, constraint),\n-            );\n-\n-            let span_hi = param.span.with_hi(span.hi());\n-            let span_with_colon = source_map.span_through_char(span_hi, ':');\n-\n-            if span_hi != param.span && span_with_colon != span_hi {\n-                err.tool_only_span_suggestion(\n-                    span_with_colon,\n-                    MSG_RESTRICT_BOUND_FURTHER,\n-                    format!(\"{}: {} + \", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        } else {\n-            // If user hasn't provided any bounds, suggest adding a new one:\n-            //\n-            //   fn foo<T>(t: T) { ... }\n-            //          - help: consider restricting this type parameter with `T: Foo`\n-\n-            err.span_help(\n-                param.span,\n-                &format!(\"{} `{}: {}`\", MSG_RESTRICT_TYPE, param_name, constraint),\n-            );\n-\n-            err.tool_only_span_suggestion(\n-                param.span,\n-                MSG_RESTRICT_TYPE,\n-                format!(\"{}: {}\", param_name, constraint),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-\n-        true\n-    } else {\n-        // This part is a bit tricky, because using the `where` clause user can\n-        // provide zero, one or many bounds for the same type parameter, so we\n-        // have following cases to consider:\n-        //\n-        // 1) When the type parameter has been provided zero bounds\n-        //\n-        //    Message:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //             - help: consider restricting this type parameter with `where X: Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n-        //                                           - insert: `, X: Bar`\n-        //\n-        //\n-        // 2) When the type parameter has been provided one bound\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^^^^^\n-        //                            |\n-        //                            help: consider further restricting this bound with `+ Bar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo { ... }\n-        //                            ^^\n-        //                            |\n-        //                            replace with: `T: Bar +`\n-        //\n-        //\n-        // 3) When the type parameter has been provided many bounds\n-        //\n-        //    Message:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //             - help: consider further restricting this type parameter with `where T: Zar`\n-        //\n-        //    Suggestion:\n-        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-        //                                          - insert: `, T: Zar`\n-\n-        let mut param_spans = Vec::new();\n-\n-        for predicate in generics.where_clause.predicates {\n-            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                span, bounded_ty, ..\n-            }) = predicate\n-            {\n-                if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                    if let Some(segment) = path.segments.first() {\n-                        if segment.ident.to_string() == param_name {\n-                            param_spans.push(span);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        let where_clause_span =\n-            generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi();\n-\n-        match &param_spans[..] {\n-            &[] => {\n-                err.span_help(\n-                    param.span,\n-                    &format!(\"{} `where {}: {}`\", MSG_RESTRICT_TYPE, param_name, constraint),\n-                );\n-\n-                err.tool_only_span_suggestion(\n-                    where_clause_span,\n-                    MSG_RESTRICT_TYPE,\n-                    format!(\", {}: {}\", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-\n-            &[&param_span] => {\n-                err.span_help(\n-                    param_span,\n-                    &format!(\"{} `+ {}`\", MSG_RESTRICT_BOUND_FURTHER, constraint),\n-                );\n-\n-                let span_hi = param_span.with_hi(span.hi());\n-                let span_with_colon = source_map.span_through_char(span_hi, ':');\n-\n-                if span_hi != param_span && span_with_colon != span_hi {\n-                    err.tool_only_span_suggestion(\n-                        span_with_colon,\n-                        MSG_RESTRICT_BOUND_FURTHER,\n-                        format!(\"{}: {} +\", param_name, constraint),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-\n-            _ => {\n-                err.span_help(\n-                    param.span,\n-                    &format!(\n-                        \"{} `where {}: {}`\",\n-                        MSG_RESTRICT_TYPE_FURTHER, param_name, constraint,\n-                    ),\n-                );\n-\n-                err.tool_only_span_suggestion(\n-                    where_clause_span,\n-                    MSG_RESTRICT_BOUND_FURTHER,\n-                    format!(\", {}: {}\", param_name, constraint),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-\n-        true\n-    }\n-}"}, {"sha": "1c0785497be221501de17896961466a5558ffbb1", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 516, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,115 +1,33 @@\n-//! Trait Resolution. See the [rustc dev guide] for more information on how this works.\n+//! Trait Resolution. See the [rustc guide] for more information on how this works.\n //!\n-//! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/resolution.html\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n \n-#[allow(dead_code)]\n-pub mod auto_trait;\n-pub mod codegen;\n-mod coherence;\n mod engine;\n pub mod error_reporting;\n-mod fulfill;\n-pub mod misc;\n-mod object_safety;\n-mod on_unimplemented;\n mod project;\n-pub mod query;\n-mod select;\n-mod specialize;\n mod structural_impls;\n-mod structural_match;\n mod util;\n-pub mod wf;\n \n-use crate::infer::outlives::env::OutlivesEnvironment;\n-use crate::infer::{InferCtxt, SuppressRegionErrors, TyCtxtInferExt};\n-use rustc::middle::region;\n use rustc::ty::error::{ExpectedFound, TypeError};\n-use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, WithConstness};\n-use rustc::util::common::ErrorReported;\n+use rustc::ty::{self, Ty};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_span::{Span, DUMMY_SP};\n-\n-use std::fmt::Debug;\n+use rustc_span::Span;\n \n pub use self::FulfillmentErrorCode::*;\n pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n pub use self::Vtable::*;\n \n-pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n-pub use self::coherence::{OrphanCheckErr, OverlapResult};\n pub use self::engine::{TraitEngine, TraitEngineExt};\n-pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n-pub use self::object_safety::astconv_object_safety_violations;\n-pub use self::object_safety::is_vtable_safe_method;\n-pub use self::object_safety::MethodViolationCode;\n-pub use self::object_safety::ObjectSafetyViolation;\n-pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{\n-    normalize, normalize_projection_type, normalize_to, poly_project_and_unify_type,\n-};\n-pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot, Reveal};\n-pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n-pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n-pub use self::specialize::find_associated_item;\n-pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n-pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n-pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n-pub use self::structural_match::search_for_structural_match_violation;\n-pub use self::structural_match::type_marked_structural;\n-pub use self::structural_match::NonStructuralMatchTy;\n-pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n-pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n-pub use self::util::{\n-    get_vtable_index_of_object_method, impl_is_default, impl_item_is_final,\n-    predicate_for_trait_def, upcast_choices,\n-};\n-pub use self::util::{\n-    supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n+    Normalized, NormalizedTy, ProjectionCache, ProjectionCacheEntry, ProjectionCacheKey,\n+    ProjectionCacheSnapshot, Reveal,\n };\n+crate use self::util::elaborate_predicates;\n \n pub use rustc::traits::*;\n \n-/// Whether to skip the leak check, as part of a future compatibility warning step.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum SkipLeakCheck {\n-    Yes,\n-    No,\n-}\n-\n-impl SkipLeakCheck {\n-    fn is_yes(self) -> bool {\n-        self == SkipLeakCheck::Yes\n-    }\n-}\n-\n-/// The \"default\" for skip-leak-check corresponds to the current\n-/// behavior (do not skip the leak check) -- not the behavior we are\n-/// transitioning into.\n-impl Default for SkipLeakCheck {\n-    fn default() -> Self {\n-        SkipLeakCheck::No\n-    }\n-}\n-\n-/// The mode that trait queries run in.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub enum TraitQueryMode {\n-    // Standard/un-canonicalized queries get accurate\n-    // spans etc. passed in and hence can do reasonable\n-    // error reporting on their own.\n-    Standard,\n-    // Canonicalized queries get dummy spans and hence\n-    // must generally propagate errors to\n-    // pre-canonicalization callsites.\n-    Canonical,\n-}\n-\n /// An `Obligation` represents some trait reference (e.g., `int: Eq`) for\n /// which the vtable must be found. The process of finding a vtable is\n /// called \"resolving\" the `Obligation`. This process consists of\n@@ -165,418 +83,6 @@ pub enum FulfillmentErrorCode<'tcx> {\n     CodeAmbiguity,\n }\n \n-/// Creates predicate obligations from the generic bounds.\n-pub fn predicates_for_generics<'tcx>(\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n-) -> PredicateObligations<'tcx> {\n-    util::predicates_for_generics(cause, 0, param_env, generic_bounds)\n-}\n-\n-/// Determines whether the type `ty` is known to meet `bound` and\n-/// returns true if so. Returns false if `ty` either does not meet\n-/// `bound` or is not known to meet bound (note that this is\n-/// conservative towards *no impl*, which is the opposite of the\n-/// `evaluate` methods).\n-pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ty: Ty<'tcx>,\n-    def_id: DefId,\n-    span: Span,\n-) -> bool {\n-    debug!(\n-        \"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n-        ty,\n-        infcx.tcx.def_path_str(def_id)\n-    );\n-\n-    let trait_ref = ty::TraitRef { def_id, substs: infcx.tcx.mk_substs_trait(ty, &[]) };\n-    let obligation = Obligation {\n-        param_env,\n-        cause: ObligationCause::misc(span, hir::DUMMY_HIR_ID),\n-        recursion_depth: 0,\n-        predicate: trait_ref.without_const().to_predicate(),\n-    };\n-\n-    let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n-    debug!(\n-        \"type_known_to_meet_ty={:?} bound={} => {:?}\",\n-        ty,\n-        infcx.tcx.def_path_str(def_id),\n-        result\n-    );\n-\n-    if result && ty.has_infer_types_or_consts() {\n-        // Because of inference \"guessing\", selection can sometimes claim\n-        // to succeed while the success requires a guess. To ensure\n-        // this function's result remains infallible, we must confirm\n-        // that guess. While imperfect, I believe this is sound.\n-\n-        // The handling of regions in this area of the code is terrible,\n-        // see issue #29149. We should be able to improve on this with\n-        // NLL.\n-        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n-\n-        // We can use a dummy node-id here because we won't pay any mind\n-        // to region obligations that arise (there shouldn't really be any\n-        // anyhow).\n-        let cause = ObligationCause::misc(span, hir::DUMMY_HIR_ID);\n-\n-        fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n-\n-        // Note: we only assume something is `Copy` if we can\n-        // *definitively* show that it implements `Copy`. Otherwise,\n-        // assume it is move; linear is always ok.\n-        match fulfill_cx.select_all_or_error(infcx) {\n-            Ok(()) => {\n-                debug!(\n-                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n-                    ty,\n-                    infcx.tcx.def_path_str(def_id)\n-                );\n-                true\n-            }\n-            Err(e) => {\n-                debug!(\n-                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n-                    ty,\n-                    infcx.tcx.def_path_str(def_id),\n-                    e\n-                );\n-                false\n-            }\n-        }\n-    } else {\n-        result\n-    }\n-}\n-\n-fn do_normalize_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    region_context: DefId,\n-    cause: ObligationCause<'tcx>,\n-    elaborated_env: ty::ParamEnv<'tcx>,\n-    predicates: Vec<ty::Predicate<'tcx>>,\n-) -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported> {\n-    debug!(\n-        \"do_normalize_predicates(predicates={:?}, region_context={:?}, cause={:?})\",\n-        predicates, region_context, cause,\n-    );\n-    let span = cause.span;\n-    tcx.infer_ctxt().enter(|infcx| {\n-        // FIXME. We should really... do something with these region\n-        // obligations. But this call just continues the older\n-        // behavior (i.e., doesn't cause any new bugs), and it would\n-        // take some further refactoring to actually solve them. In\n-        // particular, we would have to handle implied bounds\n-        // properly, and that code is currently largely confined to\n-        // regionck (though I made some efforts to extract it\n-        // out). -nmatsakis\n-        //\n-        // @arielby: In any case, these obligations are checked\n-        // by wfcheck anyway, so I'm not sure we have to check\n-        // them here too, and we will remove this function when\n-        // we move over to lazy normalization *anyway*.\n-        let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n-        let predicates =\n-            match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, &predicates) {\n-                Ok(predicates) => predicates,\n-                Err(errors) => {\n-                    infcx.report_fulfillment_errors(&errors, None, false);\n-                    return Err(ErrorReported);\n-                }\n-            };\n-\n-        debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n-\n-        let region_scope_tree = region::ScopeTree::default();\n-\n-        // We can use the `elaborated_env` here; the region code only\n-        // cares about declarations like `'a: 'b`.\n-        let outlives_env = OutlivesEnvironment::new(elaborated_env);\n-\n-        infcx.resolve_regions_and_report_errors(\n-            region_context,\n-            &region_scope_tree,\n-            &outlives_env,\n-            SuppressRegionErrors::default(),\n-        );\n-\n-        let predicates = match infcx.fully_resolve(&predicates) {\n-            Ok(predicates) => predicates,\n-            Err(fixup_err) => {\n-                // If we encounter a fixup error, it means that some type\n-                // variable wound up unconstrained. I actually don't know\n-                // if this can happen, and I certainly don't expect it to\n-                // happen often, but if it did happen it probably\n-                // represents a legitimate failure due to some kind of\n-                // unconstrained variable, and it seems better not to ICE,\n-                // all things considered.\n-                tcx.sess.span_err(span, &fixup_err.to_string());\n-                return Err(ErrorReported);\n-            }\n-        };\n-        if predicates.has_local_value() {\n-            // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n-            Err(ErrorReported)\n-        } else {\n-            Ok(predicates)\n-        }\n-    })\n-}\n-\n-// FIXME: this is gonna need to be removed ...\n-/// Normalizes the parameter environment, reporting errors if they occur.\n-pub fn normalize_param_env_or_error<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    region_context: DefId,\n-    unnormalized_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-) -> ty::ParamEnv<'tcx> {\n-    // I'm not wild about reporting errors here; I'd prefer to\n-    // have the errors get reported at a defined place (e.g.,\n-    // during typeck). Instead I have all parameter\n-    // environments, in effect, going through this function\n-    // and hence potentially reporting errors. This ensures of\n-    // course that we never forget to normalize (the\n-    // alternative seemed like it would involve a lot of\n-    // manual invocations of this fn -- and then we'd have to\n-    // deal with the errors at each of those sites).\n-    //\n-    // In any case, in practice, typeck constructs all the\n-    // parameter environments once for every fn as it goes,\n-    // and errors will get reported then; so after typeck we\n-    // can be sure that no errors should occur.\n-\n-    debug!(\n-        \"normalize_param_env_or_error(region_context={:?}, unnormalized_env={:?}, cause={:?})\",\n-        region_context, unnormalized_env, cause\n-    );\n-\n-    let mut predicates: Vec<_> =\n-        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec()).collect();\n-\n-    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n-\n-    let elaborated_env = ty::ParamEnv::new(\n-        tcx.intern_predicates(&predicates),\n-        unnormalized_env.reveal,\n-        unnormalized_env.def_id,\n-    );\n-\n-    // HACK: we are trying to normalize the param-env inside *itself*. The problem is that\n-    // normalization expects its param-env to be already normalized, which means we have\n-    // a circularity.\n-    //\n-    // The way we handle this is by normalizing the param-env inside an unnormalized version\n-    // of the param-env, which means that if the param-env contains unnormalized projections,\n-    // we'll have some normalization failures. This is unfortunate.\n-    //\n-    // Lazy normalization would basically handle this by treating just the\n-    // normalizing-a-trait-ref-requires-itself cycles as evaluation failures.\n-    //\n-    // Inferred outlives bounds can create a lot of `TypeOutlives` predicates for associated\n-    // types, so to make the situation less bad, we normalize all the predicates *but*\n-    // the `TypeOutlives` predicates first inside the unnormalized parameter environment, and\n-    // then we normalize the `TypeOutlives` bounds inside the normalized parameter environment.\n-    //\n-    // This works fairly well because trait matching  does not actually care about param-env\n-    // TypeOutlives predicates - these are normally used by regionck.\n-    let outlives_predicates: Vec<_> = predicates\n-        .drain_filter(|predicate| match predicate {\n-            ty::Predicate::TypeOutlives(..) => true,\n-            _ => false,\n-        })\n-        .collect();\n-\n-    debug!(\n-        \"normalize_param_env_or_error: predicates=(non-outlives={:?}, outlives={:?})\",\n-        predicates, outlives_predicates\n-    );\n-    let non_outlives_predicates = match do_normalize_predicates(\n-        tcx,\n-        region_context,\n-        cause.clone(),\n-        elaborated_env,\n-        predicates,\n-    ) {\n-        Ok(predicates) => predicates,\n-        // An unnormalized env is better than nothing.\n-        Err(ErrorReported) => {\n-            debug!(\"normalize_param_env_or_error: errored resolving non-outlives predicates\");\n-            return elaborated_env;\n-        }\n-    };\n-\n-    debug!(\"normalize_param_env_or_error: non-outlives predicates={:?}\", non_outlives_predicates);\n-\n-    // Not sure whether it is better to include the unnormalized TypeOutlives predicates\n-    // here. I believe they should not matter, because we are ignoring TypeOutlives param-env\n-    // predicates here anyway. Keeping them here anyway because it seems safer.\n-    let outlives_env: Vec<_> =\n-        non_outlives_predicates.iter().chain(&outlives_predicates).cloned().collect();\n-    let outlives_env =\n-        ty::ParamEnv::new(tcx.intern_predicates(&outlives_env), unnormalized_env.reveal, None);\n-    let outlives_predicates = match do_normalize_predicates(\n-        tcx,\n-        region_context,\n-        cause,\n-        outlives_env,\n-        outlives_predicates,\n-    ) {\n-        Ok(predicates) => predicates,\n-        // An unnormalized env is better than nothing.\n-        Err(ErrorReported) => {\n-            debug!(\"normalize_param_env_or_error: errored resolving outlives predicates\");\n-            return elaborated_env;\n-        }\n-    };\n-    debug!(\"normalize_param_env_or_error: outlives predicates={:?}\", outlives_predicates);\n-\n-    let mut predicates = non_outlives_predicates;\n-    predicates.extend(outlives_predicates);\n-    debug!(\"normalize_param_env_or_error: final predicates={:?}\", predicates);\n-    ty::ParamEnv::new(\n-        tcx.intern_predicates(&predicates),\n-        unnormalized_env.reveal,\n-        unnormalized_env.def_id,\n-    )\n-}\n-\n-pub fn fully_normalize<'a, 'tcx, T>(\n-    infcx: &InferCtxt<'a, 'tcx>,\n-    mut fulfill_cx: FulfillmentContext<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    value: &T,\n-) -> Result<T, Vec<FulfillmentError<'tcx>>>\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n-    let selcx = &mut SelectionContext::new(infcx);\n-    let Normalized { value: normalized_value, obligations } =\n-        project::normalize(selcx, param_env, cause, value);\n-    debug!(\n-        \"fully_normalize: normalized_value={:?} obligations={:?}\",\n-        normalized_value, obligations\n-    );\n-    for obligation in obligations {\n-        fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n-    }\n-\n-    debug!(\"fully_normalize: select_all_or_error start\");\n-    fulfill_cx.select_all_or_error(infcx)?;\n-    debug!(\"fully_normalize: select_all_or_error complete\");\n-    let resolved_value = infcx.resolve_vars_if_possible(&normalized_value);\n-    debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n-    Ok(resolved_value)\n-}\n-\n-/// Normalizes the predicates and checks whether they hold in an empty\n-/// environment. If this returns false, then either normalize\n-/// encountered an error or one of the predicates did not hold. Used\n-/// when creating vtables to check for unsatisfiable methods.\n-pub fn normalize_and_test_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    predicates: Vec<ty::Predicate<'tcx>>,\n-) -> bool {\n-    debug!(\"normalize_and_test_predicates(predicates={:?})\", predicates);\n-\n-    let result = tcx.infer_ctxt().enter(|infcx| {\n-        let param_env = ty::ParamEnv::reveal_all();\n-        let mut selcx = SelectionContext::new(&infcx);\n-        let mut fulfill_cx = FulfillmentContext::new();\n-        let cause = ObligationCause::dummy();\n-        let Normalized { value: predicates, obligations } =\n-            normalize(&mut selcx, param_env, cause.clone(), &predicates);\n-        for obligation in obligations {\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-        }\n-        for predicate in predicates {\n-            let obligation = Obligation::new(cause.clone(), param_env, predicate);\n-            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n-        }\n-\n-        fulfill_cx.select_all_or_error(&infcx).is_ok()\n-    });\n-    debug!(\"normalize_and_test_predicates(predicates={:?}) = {:?}\", predicates, result);\n-    result\n-}\n-\n-fn substitute_normalize_and_test_predicates<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    key: (DefId, SubstsRef<'tcx>),\n-) -> bool {\n-    debug!(\"substitute_normalize_and_test_predicates(key={:?})\", key);\n-\n-    let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n-    let result = normalize_and_test_predicates(tcx, predicates);\n-\n-    debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\", key, result);\n-    result\n-}\n-\n-/// Given a trait `trait_ref`, iterates the vtable entries\n-/// that come from `trait_ref`, including its supertraits.\n-#[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n-fn vtable_methods<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n-    debug!(\"vtable_methods({:?})\", trait_ref);\n-\n-    tcx.arena.alloc_from_iter(supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-        let trait_methods = tcx\n-            .associated_items(trait_ref.def_id())\n-            .in_definition_order()\n-            .filter(|item| item.kind == ty::AssocKind::Method);\n-\n-        // Now list each method's DefId and InternalSubsts (for within its trait).\n-        // If the method can never be called from this object, produce None.\n-        trait_methods.map(move |trait_method| {\n-            debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n-            let def_id = trait_method.def_id;\n-\n-            // Some methods cannot be called on an object; skip those.\n-            if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n-                debug!(\"vtable_methods: not vtable safe\");\n-                return None;\n-            }\n-\n-            // The method may have some early-bound lifetimes; add regions for those.\n-            let substs = trait_ref.map_bound(|trait_ref| {\n-                InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n-                    GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n-                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n-                        trait_ref.substs[param.index as usize]\n-                    }\n-                })\n-            });\n-\n-            // The trait type may have higher-ranked lifetimes in it;\n-            // erase them if they appear, so that we get the type\n-            // at some particular call site.\n-            let substs =\n-                tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &substs);\n-\n-            // It's possible that the method relies on where-clauses that\n-            // do not hold for this particular set of type parameters.\n-            // Note that this method could then never be called, so we\n-            // do not want to try and codegen it, in that case (see #23435).\n-            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n-                debug!(\"vtable_methods: predicates do not hold\");\n-                return None;\n-            }\n-\n-            Some((def_id, substs))\n-        })\n-    }))\n-}\n-\n impl<'tcx, O> Obligation<'tcx, O> {\n     pub fn new(\n         cause: ObligationCause<'tcx>,\n@@ -586,7 +92,7 @@ impl<'tcx, O> Obligation<'tcx, O> {\n         Obligation { cause, param_env, recursion_depth: 0, predicate }\n     }\n \n-    fn with_depth(\n+    pub fn with_depth(\n         cause: ObligationCause<'tcx>,\n         recursion_depth: usize,\n         param_env: ty::ParamEnv<'tcx>,\n@@ -615,7 +121,7 @@ impl<'tcx, O> Obligation<'tcx, O> {\n }\n \n impl<'tcx> FulfillmentError<'tcx> {\n-    fn new(\n+    pub fn new(\n         obligation: PredicateObligation<'tcx>,\n         code: FulfillmentErrorCode<'tcx>,\n     ) -> FulfillmentError<'tcx> {\n@@ -624,19 +130,7 @@ impl<'tcx> FulfillmentError<'tcx> {\n }\n \n impl<'tcx> TraitObligation<'tcx> {\n-    fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+    pub fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n         self.predicate.map_bound(|p| p.self_ty())\n     }\n }\n-\n-pub fn provide(providers: &mut ty::query::Providers<'_>) {\n-    object_safety::provide(providers);\n-    *providers = ty::query::Providers {\n-        specialization_graph_of: specialize::specialization_graph_provider,\n-        specializes: specialize::specializes,\n-        codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n-        vtable_methods,\n-        substitute_normalize_and_test_predicates,\n-        ..*providers\n-    };\n-}"}, {"sha": "183e4be189022df4e6a6b7ab89b869e30bd50ca6", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 11, "deletions": 1496, "changes": 1507, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,398 +1,18 @@\n //! Code for projecting associated types out of trait references.\n \n-use super::elaborate_predicates;\n-use super::specialization_graph;\n-use super::translate_substs;\n-use super::util;\n-use super::Obligation;\n-use super::ObligationCause;\n use super::PredicateObligation;\n-use super::Selection;\n-use super::SelectionContext;\n-use super::SelectionError;\n-use super::{VtableClosureData, VtableFnPointerData, VtableGeneratorData, VtableImplData};\n \n-use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n-use rustc::ty::fold::{TypeFoldable, TypeFolder};\n-use rustc::ty::subst::{InternalSubsts, Subst};\n-use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n-use rustc_ast::ast::Ident;\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::{self, Ty};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n-use rustc_hir::def_id::DefId;\n-use rustc_span::symbol::sym;\n-use rustc_span::DUMMY_SP;\n \n pub use rustc::traits::Reveal;\n \n-pub type PolyProjectionObligation<'tcx> = Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n-\n-pub type ProjectionObligation<'tcx> = Obligation<'tcx, ty::ProjectionPredicate<'tcx>>;\n-\n-pub type ProjectionTyObligation<'tcx> = Obligation<'tcx, ty::ProjectionTy<'tcx>>;\n-\n-/// When attempting to resolve `<T as TraitRef>::Name` ...\n-#[derive(Debug)]\n-pub enum ProjectionTyError<'tcx> {\n-    /// ...we found multiple sources of information and couldn't resolve the ambiguity.\n-    TooManyCandidates,\n-\n-    /// ...an error occurred matching `T : TraitRef`\n-    TraitSelectionError(SelectionError<'tcx>),\n-}\n-\n #[derive(Clone)]\n pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::error::TypeError<'tcx>,\n }\n \n-#[derive(PartialEq, Eq, Debug)]\n-enum ProjectionTyCandidate<'tcx> {\n-    // from a where-clause in the env or object type\n-    ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n-\n-    // from the definition of `Trait` when you have something like <<A as Trait>::B as Trait2>::C\n-    TraitDef(ty::PolyProjectionPredicate<'tcx>),\n-\n-    // from a \"impl\" (or a \"pseudo-impl\" returned by select)\n-    Select(Selection<'tcx>),\n-}\n-\n-enum ProjectionTyCandidateSet<'tcx> {\n-    None,\n-    Single(ProjectionTyCandidate<'tcx>),\n-    Ambiguous,\n-    Error(SelectionError<'tcx>),\n-}\n-\n-impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n-    fn mark_ambiguous(&mut self) {\n-        *self = ProjectionTyCandidateSet::Ambiguous;\n-    }\n-\n-    fn mark_error(&mut self, err: SelectionError<'tcx>) {\n-        *self = ProjectionTyCandidateSet::Error(err);\n-    }\n-\n-    // Returns true if the push was successful, or false if the candidate\n-    // was discarded -- this could be because of ambiguity, or because\n-    // a higher-priority candidate is already there.\n-    fn push_candidate(&mut self, candidate: ProjectionTyCandidate<'tcx>) -> bool {\n-        use self::ProjectionTyCandidate::*;\n-        use self::ProjectionTyCandidateSet::*;\n-\n-        // This wacky variable is just used to try and\n-        // make code readable and avoid confusing paths.\n-        // It is assigned a \"value\" of `()` only on those\n-        // paths in which we wish to convert `*self` to\n-        // ambiguous (and return false, because the candidate\n-        // was not used). On other paths, it is not assigned,\n-        // and hence if those paths *could* reach the code that\n-        // comes after the match, this fn would not compile.\n-        let convert_to_ambiguous;\n-\n-        match self {\n-            None => {\n-                *self = Single(candidate);\n-                return true;\n-            }\n-\n-            Single(current) => {\n-                // Duplicates can happen inside ParamEnv. In the case, we\n-                // perform a lazy deduplication.\n-                if current == &candidate {\n-                    return false;\n-                }\n-\n-                // Prefer where-clauses. As in select, if there are multiple\n-                // candidates, we prefer where-clause candidates over impls.  This\n-                // may seem a bit surprising, since impls are the source of\n-                // \"truth\" in some sense, but in fact some of the impls that SEEM\n-                // applicable are not, because of nested obligations. Where\n-                // clauses are the safer choice. See the comment on\n-                // `select::SelectionCandidate` and #21974 for more details.\n-                match (current, candidate) {\n-                    (ParamEnv(..), ParamEnv(..)) => convert_to_ambiguous = (),\n-                    (ParamEnv(..), _) => return false,\n-                    (_, ParamEnv(..)) => unreachable!(),\n-                    (_, _) => convert_to_ambiguous = (),\n-                }\n-            }\n-\n-            Ambiguous | Error(..) => {\n-                return false;\n-            }\n-        }\n-\n-        // We only ever get here when we moved from a single candidate\n-        // to ambiguous.\n-        let () = convert_to_ambiguous;\n-        *self = Ambiguous;\n-        false\n-    }\n-}\n-\n-/// Evaluates constraints of the form:\n-///\n-///     for<...> <T as Trait>::U == V\n-///\n-/// If successful, this may result in additional obligations. Also returns\n-/// the projection cache key used to track these additional obligations.\n-pub fn poly_project_and_unify_type<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &PolyProjectionObligation<'tcx>,\n-) -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>> {\n-    debug!(\"poly_project_and_unify_type(obligation={:?})\", obligation);\n-\n-    let infcx = selcx.infcx();\n-    infcx.commit_if_ok(|snapshot| {\n-        let (placeholder_predicate, placeholder_map) =\n-            infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n-\n-        let placeholder_obligation = obligation.with(placeholder_predicate);\n-        let result = project_and_unify_type(selcx, &placeholder_obligation)?;\n-        infcx\n-            .leak_check(false, &placeholder_map, snapshot)\n-            .map_err(|err| MismatchedProjectionTypes { err })?;\n-        Ok(result)\n-    })\n-}\n-\n-/// Evaluates constraints of the form:\n-///\n-///     <T as Trait>::U == V\n-///\n-/// If successful, this may result in additional obligations.\n-fn project_and_unify_type<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionObligation<'tcx>,\n-) -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>> {\n-    debug!(\"project_and_unify_type(obligation={:?})\", obligation);\n-\n-    let mut obligations = vec![];\n-    let normalized_ty = match opt_normalize_projection_type(\n-        selcx,\n-        obligation.param_env,\n-        obligation.predicate.projection_ty,\n-        obligation.cause.clone(),\n-        obligation.recursion_depth,\n-        &mut obligations,\n-    ) {\n-        Some(n) => n,\n-        None => return Ok(None),\n-    };\n-\n-    debug!(\n-        \"project_and_unify_type: normalized_ty={:?} obligations={:?}\",\n-        normalized_ty, obligations\n-    );\n-\n-    let infcx = selcx.infcx();\n-    match infcx\n-        .at(&obligation.cause, obligation.param_env)\n-        .eq(normalized_ty, obligation.predicate.ty)\n-    {\n-        Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n-            obligations.extend(inferred_obligations);\n-            Ok(Some(obligations))\n-        }\n-        Err(err) => {\n-            debug!(\"project_and_unify_type: equating types encountered error {:?}\", err);\n-            Err(MismatchedProjectionTypes { err })\n-        }\n-    }\n-}\n-\n-/// Normalizes any associated type projections in `value`, replacing\n-/// them with a fully resolved type where possible. The return value\n-/// combines the normalized result and any additional obligations that\n-/// were incurred as result.\n-pub fn normalize<'a, 'b, 'tcx, T>(\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    value: &T,\n-) -> Normalized<'tcx, T>\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    let mut obligations = Vec::new();\n-    let value = normalize_to(selcx, param_env, cause, value, &mut obligations);\n-    Normalized { value, obligations }\n-}\n-\n-pub fn normalize_to<'a, 'b, 'tcx, T>(\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    value: &T,\n-    obligations: &mut Vec<PredicateObligation<'tcx>>,\n-) -> T\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    normalize_with_depth_to(selcx, param_env, cause, 0, value, obligations)\n-}\n-\n-/// As `normalize`, but with a custom depth.\n-pub fn normalize_with_depth<'a, 'b, 'tcx, T>(\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    depth: usize,\n-    value: &T,\n-) -> Normalized<'tcx, T>\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    let mut obligations = Vec::new();\n-    let value = normalize_with_depth_to(selcx, param_env, cause, depth, value, &mut obligations);\n-    Normalized { value, obligations }\n-}\n-\n-pub fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    depth: usize,\n-    value: &T,\n-    obligations: &mut Vec<PredicateObligation<'tcx>>,\n-) -> T\n-where\n-    T: TypeFoldable<'tcx>,\n-{\n-    debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n-    let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth, obligations);\n-    let result = normalizer.fold(value);\n-    debug!(\n-        \"normalize_with_depth: depth={} result={:?} with {} obligations\",\n-        depth,\n-        result,\n-        normalizer.obligations.len()\n-    );\n-    debug!(\"normalize_with_depth: depth={} obligations={:?}\", depth, normalizer.obligations);\n-    result\n-}\n-\n-struct AssocTypeNormalizer<'a, 'b, 'tcx> {\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n-    depth: usize,\n-}\n-\n-impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n-    fn new(\n-        selcx: &'a mut SelectionContext<'b, 'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        cause: ObligationCause<'tcx>,\n-        depth: usize,\n-        obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n-    ) -> AssocTypeNormalizer<'a, 'b, 'tcx> {\n-        AssocTypeNormalizer { selcx, param_env, cause, obligations, depth }\n-    }\n-\n-    fn fold<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n-        let value = self.selcx.infcx().resolve_vars_if_possible(value);\n-\n-        if !value.has_projections() { value } else { value.fold_with(self) }\n-    }\n-}\n-\n-impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n-    fn tcx<'c>(&'c self) -> TyCtxt<'tcx> {\n-        self.selcx.tcx()\n-    }\n-\n-    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty.has_projections() {\n-            return ty;\n-        }\n-        // We don't want to normalize associated types that occur inside of region\n-        // binders, because they may contain bound regions, and we can't cope with that.\n-        //\n-        // Example:\n-        //\n-        //     for<'a> fn(<T as Foo<&'a>>::A)\n-        //\n-        // Instead of normalizing `<T as Foo<&'a>>::A` here, we'll\n-        // normalize it when we instantiate those bound regions (which\n-        // should occur eventually).\n-\n-        let ty = ty.super_fold_with(self);\n-        match ty.kind {\n-            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n-                // (*)\n-                // Only normalize `impl Trait` after type-checking, usually in codegen.\n-                match self.param_env.reveal {\n-                    Reveal::UserFacing => ty,\n-\n-                    Reveal::All => {\n-                        let recursion_limit = *self.tcx().sess.recursion_limit.get();\n-                        if self.depth >= recursion_limit {\n-                            let obligation = Obligation::with_depth(\n-                                self.cause.clone(),\n-                                recursion_limit,\n-                                self.param_env,\n-                                ty,\n-                            );\n-                            self.selcx.infcx().report_overflow_error(&obligation, true);\n-                        }\n-\n-                        let generic_ty = self.tcx().type_of(def_id);\n-                        let concrete_ty = generic_ty.subst(self.tcx(), substs);\n-                        self.depth += 1;\n-                        let folded_ty = self.fold_ty(concrete_ty);\n-                        self.depth -= 1;\n-                        folded_ty\n-                    }\n-                }\n-            }\n-\n-            ty::Projection(ref data) if !data.has_escaping_bound_vars() => {\n-                // (*)\n-\n-                // (*) This is kind of hacky -- we need to be able to\n-                // handle normalization within binders because\n-                // otherwise we wind up a need to normalize when doing\n-                // trait matching (since you can have a trait\n-                // obligation like `for<'a> T::B : Fn(&'a int)`), but\n-                // we can't normalize with bound regions in scope. So\n-                // far now we just ignore binders but only normalize\n-                // if all bound regions are gone (and then we still\n-                // have to renormalize whenever we instantiate a\n-                // binder). It would be better to normalize in a\n-                // binding-aware fashion.\n-\n-                let normalized_ty = normalize_projection_type(\n-                    self.selcx,\n-                    self.param_env,\n-                    *data,\n-                    self.cause.clone(),\n-                    self.depth,\n-                    &mut self.obligations,\n-                );\n-                debug!(\n-                    \"AssocTypeNormalizer: depth={} normalized {:?} to {:?}, \\\n-                     now with {} obligations\",\n-                    self.depth,\n-                    ty,\n-                    normalized_ty,\n-                    self.obligations.len()\n-                );\n-                normalized_ty\n-            }\n-\n-            _ => ty,\n-        }\n-    }\n-\n-    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        constant.eval(self.selcx.tcx(), self.param_env)\n-    }\n-}\n-\n #[derive(Clone, TypeFoldable)]\n pub struct Normalized<'tcx, T> {\n     pub value: T,\n@@ -403,1100 +23,7 @@ pub type NormalizedTy<'tcx> = Normalized<'tcx, Ty<'tcx>>;\n \n impl<'tcx, T> Normalized<'tcx, T> {\n     pub fn with<U>(self, value: U) -> Normalized<'tcx, U> {\n-        Normalized { value, obligations: self.obligations }\n-    }\n-}\n-\n-/// The guts of `normalize`: normalize a specific projection like `<T\n-/// as Trait>::Item`. The result is always a type (and possibly\n-/// additional obligations). If ambiguity arises, which implies that\n-/// there are unresolved type variables in the projection, we will\n-/// substitute a fresh type variable `$X` and generate a new\n-/// obligation `<T as Trait>::Item == $X` for later.\n-pub fn normalize_projection_type<'a, 'b, 'tcx>(\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    projection_ty: ty::ProjectionTy<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    depth: usize,\n-    obligations: &mut Vec<PredicateObligation<'tcx>>,\n-) -> Ty<'tcx> {\n-    opt_normalize_projection_type(\n-        selcx,\n-        param_env,\n-        projection_ty,\n-        cause.clone(),\n-        depth,\n-        obligations,\n-    )\n-    .unwrap_or_else(move || {\n-        // if we bottom out in ambiguity, create a type variable\n-        // and a deferred predicate to resolve this when more type\n-        // information is available.\n-\n-        let tcx = selcx.infcx().tcx;\n-        let def_id = projection_ty.item_def_id;\n-        let ty_var = selcx.infcx().next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::NormalizeProjectionType,\n-            span: tcx.def_span(def_id),\n-        });\n-        let projection = ty::Binder::dummy(ty::ProjectionPredicate { projection_ty, ty: ty_var });\n-        let obligation =\n-            Obligation::with_depth(cause, depth + 1, param_env, projection.to_predicate());\n-        obligations.push(obligation);\n-        ty_var\n-    })\n-}\n-\n-/// The guts of `normalize`: normalize a specific projection like `<T\n-/// as Trait>::Item`. The result is always a type (and possibly\n-/// additional obligations). Returns `None` in the case of ambiguity,\n-/// which indicates that there are unbound type variables.\n-///\n-/// This function used to return `Option<NormalizedTy<'tcx>>`, which contains a\n-/// `Ty<'tcx>` and an obligations vector. But that obligation vector was very\n-/// often immediately appended to another obligations vector. So now this\n-/// function takes an obligations vector and appends to it directly, which is\n-/// slightly uglier but avoids the need for an extra short-lived allocation.\n-fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n-    selcx: &'a mut SelectionContext<'b, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    projection_ty: ty::ProjectionTy<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    depth: usize,\n-    obligations: &mut Vec<PredicateObligation<'tcx>>,\n-) -> Option<Ty<'tcx>> {\n-    let infcx = selcx.infcx();\n-\n-    let projection_ty = infcx.resolve_vars_if_possible(&projection_ty);\n-    let cache_key = ProjectionCacheKey { ty: projection_ty };\n-\n-    debug!(\n-        \"opt_normalize_projection_type(\\\n-         projection_ty={:?}, \\\n-         depth={})\",\n-        projection_ty, depth\n-    );\n-\n-    // FIXME(#20304) For now, I am caching here, which is good, but it\n-    // means we don't capture the type variables that are created in\n-    // the case of ambiguity. Which means we may create a large stream\n-    // of such variables. OTOH, if we move the caching up a level, we\n-    // would not benefit from caching when proving `T: Trait<U=Foo>`\n-    // bounds. It might be the case that we want two distinct caches,\n-    // or else another kind of cache entry.\n-\n-    let cache_result = infcx.inner.borrow_mut().projection_cache.try_start(cache_key);\n-    match cache_result {\n-        Ok(()) => {}\n-        Err(ProjectionCacheEntry::Ambiguous) => {\n-            // If we found ambiguity the last time, that means we will continue\n-            // to do so until some type in the key changes (and we know it\n-            // hasn't, because we just fully resolved it).\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 found cache entry: ambiguous\"\n-            );\n-            return None;\n-        }\n-        Err(ProjectionCacheEntry::InProgress) => {\n-            // If while normalized A::B, we are asked to normalize\n-            // A::B, just return A::B itself. This is a conservative\n-            // answer, in the sense that A::B *is* clearly equivalent\n-            // to A::B, though there may be a better value we can\n-            // find.\n-\n-            // Under lazy normalization, this can arise when\n-            // bootstrapping.  That is, imagine an environment with a\n-            // where-clause like `A::B == u32`. Now, if we are asked\n-            // to normalize `A::B`, we will want to check the\n-            // where-clauses in scope. So we will try to unify `A::B`\n-            // with `A::B`, which can trigger a recursive\n-            // normalization. In that case, I think we will want this code:\n-            //\n-            // ```\n-            // let ty = selcx.tcx().mk_projection(projection_ty.item_def_id,\n-            //                                    projection_ty.substs;\n-            // return Some(NormalizedTy { value: v, obligations: vec![] });\n-            // ```\n-\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 found cache entry: in-progress\"\n-            );\n-\n-            // But for now, let's classify this as an overflow:\n-            let recursion_limit = *selcx.tcx().sess.recursion_limit.get();\n-            let obligation =\n-                Obligation::with_depth(cause, recursion_limit, param_env, projection_ty);\n-            selcx.infcx().report_overflow_error(&obligation, false);\n-        }\n-        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n-            // This is the hottest path in this function.\n-            //\n-            // If we find the value in the cache, then return it along\n-            // with the obligations that went along with it. Note\n-            // that, when using a fulfillment context, these\n-            // obligations could in principle be ignored: they have\n-            // already been registered when the cache entry was\n-            // created (and hence the new ones will quickly be\n-            // discarded as duplicated). But when doing trait\n-            // evaluation this is not the case, and dropping the trait\n-            // evaluations can causes ICEs (e.g., #43132).\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 found normalized ty `{:?}`\",\n-                ty\n-            );\n-\n-            // Once we have inferred everything we need to know, we\n-            // can ignore the `obligations` from that point on.\n-            if infcx.unresolved_type_vars(&ty.value).is_none() {\n-                infcx.inner.borrow_mut().projection_cache.complete_normalized(cache_key, &ty);\n-            // No need to extend `obligations`.\n-            } else {\n-                obligations.extend(ty.obligations);\n-            }\n-\n-            obligations.push(get_paranoid_cache_value_obligation(\n-                infcx,\n-                param_env,\n-                projection_ty,\n-                cause,\n-                depth,\n-            ));\n-            return Some(ty.value);\n-        }\n-        Err(ProjectionCacheEntry::Error) => {\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 found error\"\n-            );\n-            let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n-            obligations.extend(result.obligations);\n-            return Some(result.value);\n-        }\n-    }\n-\n-    let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n-    match project_type(selcx, &obligation) {\n-        Ok(ProjectedTy::Progress(Progress {\n-            ty: projected_ty,\n-            obligations: mut projected_obligations,\n-        })) => {\n-            // if projection succeeded, then what we get out of this\n-            // is also non-normalized (consider: it was derived from\n-            // an impl, where-clause etc) and hence we must\n-            // re-normalize it\n-\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 projected_ty={:?} \\\n-                 depth={} \\\n-                 projected_obligations={:?}\",\n-                projected_ty, depth, projected_obligations\n-            );\n-\n-            let result = if projected_ty.has_projections() {\n-                let mut normalizer = AssocTypeNormalizer::new(\n-                    selcx,\n-                    param_env,\n-                    cause,\n-                    depth + 1,\n-                    &mut projected_obligations,\n-                );\n-                let normalized_ty = normalizer.fold(&projected_ty);\n-\n-                debug!(\n-                    \"opt_normalize_projection_type: \\\n-                     normalized_ty={:?} depth={}\",\n-                    normalized_ty, depth\n-                );\n-\n-                Normalized { value: normalized_ty, obligations: projected_obligations }\n-            } else {\n-                Normalized { value: projected_ty, obligations: projected_obligations }\n-            };\n-\n-            let cache_value = prune_cache_value_obligations(infcx, &result);\n-            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, cache_value);\n-            obligations.extend(result.obligations);\n-            Some(result.value)\n-        }\n-        Ok(ProjectedTy::NoProgress(projected_ty)) => {\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 projected_ty={:?} no progress\",\n-                projected_ty\n-            );\n-            let result = Normalized { value: projected_ty, obligations: vec![] };\n-            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, result.clone());\n-            // No need to extend `obligations`.\n-            Some(result.value)\n-        }\n-        Err(ProjectionTyError::TooManyCandidates) => {\n-            debug!(\n-                \"opt_normalize_projection_type: \\\n-                 too many candidates\"\n-            );\n-            infcx.inner.borrow_mut().projection_cache.ambiguous(cache_key);\n-            None\n-        }\n-        Err(ProjectionTyError::TraitSelectionError(_)) => {\n-            debug!(\"opt_normalize_projection_type: ERROR\");\n-            // if we got an error processing the `T as Trait` part,\n-            // just return `ty::err` but add the obligation `T :\n-            // Trait`, which when processed will cause the error to be\n-            // reported later\n-\n-            infcx.inner.borrow_mut().projection_cache.error(cache_key);\n-            let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n-            obligations.extend(result.obligations);\n-            Some(result.value)\n-        }\n-    }\n-}\n-\n-/// If there are unresolved type variables, then we need to include\n-/// any subobligations that bind them, at least until those type\n-/// variables are fully resolved.\n-fn prune_cache_value_obligations<'a, 'tcx>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    result: &NormalizedTy<'tcx>,\n-) -> NormalizedTy<'tcx> {\n-    if infcx.unresolved_type_vars(&result.value).is_none() {\n-        return NormalizedTy { value: result.value, obligations: vec![] };\n-    }\n-\n-    let mut obligations: Vec<_> = result\n-        .obligations\n-        .iter()\n-        .filter(|obligation| match obligation.predicate {\n-            // We found a `T: Foo<X = U>` predicate, let's check\n-            // if `U` references any unresolved type\n-            // variables. In principle, we only care if this\n-            // projection can help resolve any of the type\n-            // variables found in `result.value` -- but we just\n-            // check for any type variables here, for fear of\n-            // indirect obligations (e.g., we project to `?0`,\n-            // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n-            // ?0>`).\n-            ty::Predicate::Projection(ref data) => infcx.unresolved_type_vars(&data.ty()).is_some(),\n-\n-            // We are only interested in `T: Foo<X = U>` predicates, whre\n-            // `U` references one of `unresolved_type_vars`. =)\n-            _ => false,\n-        })\n-        .cloned()\n-        .collect();\n-\n-    obligations.shrink_to_fit();\n-\n-    NormalizedTy { value: result.value, obligations }\n-}\n-\n-/// Whenever we give back a cache result for a projection like `<T as\n-/// Trait>::Item ==> X`, we *always* include the obligation to prove\n-/// that `T: Trait` (we may also include some other obligations). This\n-/// may or may not be necessary -- in principle, all the obligations\n-/// that must be proven to show that `T: Trait` were also returned\n-/// when the cache was first populated. But there are some vague concerns,\n-/// and so we take the precautionary measure of including `T: Trait` in\n-/// the result:\n-///\n-/// Concern #1. The current setup is fragile. Perhaps someone could\n-/// have failed to prove the concerns from when the cache was\n-/// populated, but also not have used a snapshot, in which case the\n-/// cache could remain populated even though `T: Trait` has not been\n-/// shown. In this case, the \"other code\" is at fault -- when you\n-/// project something, you are supposed to either have a snapshot or\n-/// else prove all the resulting obligations -- but it's still easy to\n-/// get wrong.\n-///\n-/// Concern #2. Even within the snapshot, if those original\n-/// obligations are not yet proven, then we are able to do projections\n-/// that may yet turn out to be wrong. This *may* lead to some sort\n-/// of trouble, though we don't have a concrete example of how that\n-/// can occur yet. But it seems risky at best.\n-fn get_paranoid_cache_value_obligation<'a, 'tcx>(\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    projection_ty: ty::ProjectionTy<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    depth: usize,\n-) -> PredicateObligation<'tcx> {\n-    let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n-    Obligation {\n-        cause,\n-        recursion_depth: depth,\n-        param_env,\n-        predicate: trait_ref.without_const().to_predicate(),\n-    }\n-}\n-\n-/// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n-/// hold. In various error cases, we cannot generate a valid\n-/// normalized projection. Therefore, we create an inference variable\n-/// return an associated obligation that, when fulfilled, will lead to\n-/// an error.\n-///\n-/// Note that we used to return `Error` here, but that was quite\n-/// dubious -- the premise was that an error would *eventually* be\n-/// reported, when the obligation was processed. But in general once\n-/// you see a `Error` you are supposed to be able to assume that an\n-/// error *has been* reported, so that you can take whatever heuristic\n-/// paths you want to take. To make things worse, it was possible for\n-/// cycles to arise, where you basically had a setup like `<MyType<$0>\n-/// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0> as\n-/// Trait>::Foo> to `[type error]` would lead to an obligation of\n-/// `<MyType<[type error]> as Trait>::Foo`. We are supposed to report\n-/// an error for this obligation, but we legitimately should not,\n-/// because it contains `[type error]`. Yuck! (See issue #29857 for\n-/// one case where this arose.)\n-fn normalize_to_error<'a, 'tcx>(\n-    selcx: &mut SelectionContext<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    projection_ty: ty::ProjectionTy<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    depth: usize,\n-) -> NormalizedTy<'tcx> {\n-    let trait_ref = projection_ty.trait_ref(selcx.tcx()).to_poly_trait_ref();\n-    let trait_obligation = Obligation {\n-        cause,\n-        recursion_depth: depth,\n-        param_env,\n-        predicate: trait_ref.without_const().to_predicate(),\n-    };\n-    let tcx = selcx.infcx().tcx;\n-    let def_id = projection_ty.item_def_id;\n-    let new_value = selcx.infcx().next_ty_var(TypeVariableOrigin {\n-        kind: TypeVariableOriginKind::NormalizeProjectionType,\n-        span: tcx.def_span(def_id),\n-    });\n-    Normalized { value: new_value, obligations: vec![trait_obligation] }\n-}\n-\n-enum ProjectedTy<'tcx> {\n-    Progress(Progress<'tcx>),\n-    NoProgress(Ty<'tcx>),\n-}\n-\n-struct Progress<'tcx> {\n-    ty: Ty<'tcx>,\n-    obligations: Vec<PredicateObligation<'tcx>>,\n-}\n-\n-impl<'tcx> Progress<'tcx> {\n-    fn error(tcx: TyCtxt<'tcx>) -> Self {\n-        Progress { ty: tcx.types.err, obligations: vec![] }\n-    }\n-\n-    fn with_addl_obligations(mut self, mut obligations: Vec<PredicateObligation<'tcx>>) -> Self {\n-        debug!(\n-            \"with_addl_obligations: self.obligations.len={} obligations.len={}\",\n-            self.obligations.len(),\n-            obligations.len()\n-        );\n-\n-        debug!(\n-            \"with_addl_obligations: self.obligations={:?} obligations={:?}\",\n-            self.obligations, obligations\n-        );\n-\n-        self.obligations.append(&mut obligations);\n-        self\n-    }\n-}\n-\n-/// Computes the result of a projection type (if we can).\n-///\n-/// IMPORTANT:\n-/// - `obligation` must be fully normalized\n-fn project_type<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-) -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>> {\n-    debug!(\"project(obligation={:?})\", obligation);\n-\n-    let recursion_limit = *selcx.tcx().sess.recursion_limit.get();\n-    if obligation.recursion_depth >= recursion_limit {\n-        debug!(\"project: overflow!\");\n-        return Err(ProjectionTyError::TraitSelectionError(SelectionError::Overflow));\n-    }\n-\n-    let obligation_trait_ref = &obligation.predicate.trait_ref(selcx.tcx());\n-\n-    debug!(\"project: obligation_trait_ref={:?}\", obligation_trait_ref);\n-\n-    if obligation_trait_ref.references_error() {\n-        return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n-    }\n-\n-    let mut candidates = ProjectionTyCandidateSet::None;\n-\n-    // Make sure that the following procedures are kept in order. ParamEnv\n-    // needs to be first because it has highest priority, and Select checks\n-    // the return value of push_candidate which assumes it's ran at last.\n-    assemble_candidates_from_param_env(selcx, obligation, &obligation_trait_ref, &mut candidates);\n-\n-    assemble_candidates_from_trait_def(selcx, obligation, &obligation_trait_ref, &mut candidates);\n-\n-    assemble_candidates_from_impls(selcx, obligation, &obligation_trait_ref, &mut candidates);\n-\n-    match candidates {\n-        ProjectionTyCandidateSet::Single(candidate) => Ok(ProjectedTy::Progress(\n-            confirm_candidate(selcx, obligation, &obligation_trait_ref, candidate),\n-        )),\n-        ProjectionTyCandidateSet::None => Ok(ProjectedTy::NoProgress(\n-            selcx\n-                .tcx()\n-                .mk_projection(obligation.predicate.item_def_id, obligation.predicate.substs),\n-        )),\n-        // Error occurred while trying to processing impls.\n-        ProjectionTyCandidateSet::Error(e) => Err(ProjectionTyError::TraitSelectionError(e)),\n-        // Inherent ambiguity that prevents us from even enumerating the\n-        // candidates.\n-        ProjectionTyCandidateSet::Ambiguous => Err(ProjectionTyError::TooManyCandidates),\n-    }\n-}\n-\n-/// The first thing we have to do is scan through the parameter\n-/// environment to see whether there are any projection predicates\n-/// there that can answer this question.\n-fn assemble_candidates_from_param_env<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n-) {\n-    debug!(\"assemble_candidates_from_param_env(..)\");\n-    assemble_candidates_from_predicates(\n-        selcx,\n-        obligation,\n-        obligation_trait_ref,\n-        candidate_set,\n-        ProjectionTyCandidate::ParamEnv,\n-        obligation.param_env.caller_bounds.iter().cloned(),\n-    );\n-}\n-\n-/// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n-/// that the definition of `Foo` has some clues:\n-///\n-/// ```\n-/// trait Foo {\n-///     type FooT : Bar<BarT=i32>\n-/// }\n-/// ```\n-///\n-/// Here, for example, we could conclude that the result is `i32`.\n-fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n-) {\n-    debug!(\"assemble_candidates_from_trait_def(..)\");\n-\n-    let tcx = selcx.tcx();\n-    // Check whether the self-type is itself a projection.\n-    let (def_id, substs) = match obligation_trait_ref.self_ty().kind {\n-        ty::Projection(ref data) => (data.trait_ref(tcx).def_id, data.substs),\n-        ty::Opaque(def_id, substs) => (def_id, substs),\n-        ty::Infer(ty::TyVar(_)) => {\n-            // If the self-type is an inference variable, then it MAY wind up\n-            // being a projected type, so induce an ambiguity.\n-            candidate_set.mark_ambiguous();\n-            return;\n-        }\n-        _ => return,\n-    };\n-\n-    // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = tcx.predicates_of(def_id);\n-    let bounds = trait_predicates.instantiate(tcx, substs);\n-    let bounds = elaborate_predicates(tcx, bounds.predicates);\n-    assemble_candidates_from_predicates(\n-        selcx,\n-        obligation,\n-        obligation_trait_ref,\n-        candidate_set,\n-        ProjectionTyCandidate::TraitDef,\n-        bounds,\n-    )\n-}\n-\n-fn assemble_candidates_from_predicates<'cx, 'tcx, I>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n-    ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n-    env_predicates: I,\n-) where\n-    I: IntoIterator<Item = ty::Predicate<'tcx>>,\n-{\n-    debug!(\"assemble_candidates_from_predicates(obligation={:?})\", obligation);\n-    let infcx = selcx.infcx();\n-    for predicate in env_predicates {\n-        debug!(\"assemble_candidates_from_predicates: predicate={:?}\", predicate);\n-        if let ty::Predicate::Projection(data) = predicate {\n-            let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n-\n-            let is_match = same_def_id\n-                && infcx.probe(|_| {\n-                    let data_poly_trait_ref = data.to_poly_trait_ref(infcx.tcx);\n-                    let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-                    infcx\n-                        .at(&obligation.cause, obligation.param_env)\n-                        .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n-                        .map(|InferOk { obligations: _, value: () }| {\n-                            // FIXME(#32730) -- do we need to take obligations\n-                            // into account in any way? At the moment, no.\n-                        })\n-                        .is_ok()\n-                });\n-\n-            debug!(\n-                \"assemble_candidates_from_predicates: candidate={:?} \\\n-                 is_match={} same_def_id={}\",\n-                data, is_match, same_def_id\n-            );\n-\n-            if is_match {\n-                candidate_set.push_candidate(ctor(data));\n-            }\n-        }\n-    }\n-}\n-\n-fn assemble_candidates_from_impls<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n-) {\n-    // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n-    // start out by selecting the predicate `T as TraitRef<...>`:\n-    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-    let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n-    let _ = selcx.infcx().commit_if_ok(|_| {\n-        let vtable = match selcx.select(&trait_obligation) {\n-            Ok(Some(vtable)) => vtable,\n-            Ok(None) => {\n-                candidate_set.mark_ambiguous();\n-                return Err(());\n-            }\n-            Err(e) => {\n-                debug!(\"assemble_candidates_from_impls: selection error {:?}\", e);\n-                candidate_set.mark_error(e);\n-                return Err(());\n-            }\n-        };\n-\n-        let eligible = match &vtable {\n-            super::VtableClosure(_)\n-            | super::VtableGenerator(_)\n-            | super::VtableFnPointer(_)\n-            | super::VtableObject(_)\n-            | super::VtableTraitAlias(_) => {\n-                debug!(\"assemble_candidates_from_impls: vtable={:?}\", vtable);\n-                true\n-            }\n-            super::VtableImpl(impl_data) => {\n-                // We have to be careful when projecting out of an\n-                // impl because of specialization. If we are not in\n-                // codegen (i.e., projection mode is not \"any\"), and the\n-                // impl's type is declared as default, then we disable\n-                // projection (even if the trait ref is fully\n-                // monomorphic). In the case where trait ref is not\n-                // fully monomorphic (i.e., includes type parameters),\n-                // this is because those type parameters may\n-                // ultimately be bound to types from other crates that\n-                // may have specialized impls we can't see. In the\n-                // case where the trait ref IS fully monomorphic, this\n-                // is a policy decision that we made in the RFC in\n-                // order to preserve flexibility for the crate that\n-                // defined the specializable impl to specialize later\n-                // for existing types.\n-                //\n-                // In either case, we handle this by not adding a\n-                // candidate for an impl if it contains a `default`\n-                // type.\n-                //\n-                // NOTE: This should be kept in sync with the similar code in\n-                // `rustc::ty::instance::resolve_associated_item()`.\n-                let node_item =\n-                    assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id);\n-\n-                let is_default = if node_item.node.is_from_trait() {\n-                    // If true, the impl inherited a `type Foo = Bar`\n-                    // given in the trait, which is implicitly default.\n-                    // Otherwise, the impl did not specify `type` and\n-                    // neither did the trait:\n-                    //\n-                    // ```rust\n-                    // trait Foo { type T; }\n-                    // impl Foo for Bar { }\n-                    // ```\n-                    //\n-                    // This is an error, but it will be\n-                    // reported in `check_impl_items_against_trait`.\n-                    // We accept it here but will flag it as\n-                    // an error when we confirm the candidate\n-                    // (which will ultimately lead to `normalize_to_error`\n-                    // being invoked).\n-                    false\n-                } else {\n-                    // If we're looking at a trait *impl*, the item is\n-                    // specializable if the impl or the item are marked\n-                    // `default`.\n-                    node_item.item.defaultness.is_default()\n-                        || super::util::impl_is_default(selcx.tcx(), node_item.node.def_id())\n-                };\n-\n-                match is_default {\n-                    // Non-specializable items are always projectable\n-                    false => true,\n-\n-                    // Only reveal a specializable default if we're past type-checking\n-                    // and the obligation is monomorphic, otherwise passes such as\n-                    // transmute checking and polymorphic MIR optimizations could\n-                    // get a result which isn't correct for all monomorphizations.\n-                    true if obligation.param_env.reveal == Reveal::All => {\n-                        // NOTE(eddyb) inference variables can resolve to parameters, so\n-                        // assume `poly_trait_ref` isn't monomorphic, if it contains any.\n-                        let poly_trait_ref =\n-                            selcx.infcx().resolve_vars_if_possible(&poly_trait_ref);\n-                        !poly_trait_ref.needs_infer() && !poly_trait_ref.needs_subst()\n-                    }\n-\n-                    true => {\n-                        debug!(\n-                            \"assemble_candidates_from_impls: not eligible due to default: \\\n-                             assoc_ty={} predicate={}\",\n-                            selcx.tcx().def_path_str(node_item.item.def_id),\n-                            obligation.predicate,\n-                        );\n-                        false\n-                    }\n-                }\n-            }\n-            super::VtableParam(..) => {\n-                // This case tell us nothing about the value of an\n-                // associated type. Consider:\n-                //\n-                // ```\n-                // trait SomeTrait { type Foo; }\n-                // fn foo<T:SomeTrait>(...) { }\n-                // ```\n-                //\n-                // If the user writes `<T as SomeTrait>::Foo`, then the `T\n-                // : SomeTrait` binding does not help us decide what the\n-                // type `Foo` is (at least, not more specifically than\n-                // what we already knew).\n-                //\n-                // But wait, you say! What about an example like this:\n-                //\n-                // ```\n-                // fn bar<T:SomeTrait<Foo=usize>>(...) { ... }\n-                // ```\n-                //\n-                // Doesn't the `T : Sometrait<Foo=usize>` predicate help\n-                // resolve `T::Foo`? And of course it does, but in fact\n-                // that single predicate is desugared into two predicates\n-                // in the compiler: a trait predicate (`T : SomeTrait`) and a\n-                // projection. And the projection where clause is handled\n-                // in `assemble_candidates_from_param_env`.\n-                false\n-            }\n-            super::VtableAutoImpl(..) | super::VtableBuiltin(..) => {\n-                // These traits have no associated types.\n-                span_bug!(\n-                    obligation.cause.span,\n-                    \"Cannot project an associated type from `{:?}`\",\n-                    vtable\n-                );\n-            }\n-        };\n-\n-        if eligible {\n-            if candidate_set.push_candidate(ProjectionTyCandidate::Select(vtable)) {\n-                Ok(())\n-            } else {\n-                Err(())\n-            }\n-        } else {\n-            Err(())\n-        }\n-    });\n-}\n-\n-fn confirm_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    candidate: ProjectionTyCandidate<'tcx>,\n-) -> Progress<'tcx> {\n-    debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\", candidate, obligation);\n-\n-    match candidate {\n-        ProjectionTyCandidate::ParamEnv(poly_projection)\n-        | ProjectionTyCandidate::TraitDef(poly_projection) => {\n-            confirm_param_env_candidate(selcx, obligation, poly_projection)\n-        }\n-\n-        ProjectionTyCandidate::Select(vtable) => {\n-            confirm_select_candidate(selcx, obligation, obligation_trait_ref, vtable)\n-        }\n-    }\n-}\n-\n-fn confirm_select_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-    vtable: Selection<'tcx>,\n-) -> Progress<'tcx> {\n-    match vtable {\n-        super::VtableImpl(data) => confirm_impl_candidate(selcx, obligation, data),\n-        super::VtableGenerator(data) => confirm_generator_candidate(selcx, obligation, data),\n-        super::VtableClosure(data) => confirm_closure_candidate(selcx, obligation, data),\n-        super::VtableFnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n-        super::VtableObject(_) => confirm_object_candidate(selcx, obligation, obligation_trait_ref),\n-        super::VtableAutoImpl(..)\n-        | super::VtableParam(..)\n-        | super::VtableBuiltin(..)\n-        | super::VtableTraitAlias(..) =>\n-        // we don't create Select candidates with this kind of resolution\n-        {\n-            span_bug!(\n-                obligation.cause.span,\n-                \"Cannot project an associated type from `{:?}`\",\n-                vtable\n-            )\n-        }\n-    }\n-}\n-\n-fn confirm_object_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    obligation_trait_ref: &ty::TraitRef<'tcx>,\n-) -> Progress<'tcx> {\n-    let self_ty = obligation_trait_ref.self_ty();\n-    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n-    debug!(\"confirm_object_candidate(object_ty={:?})\", object_ty);\n-    let data = match object_ty.kind {\n-        ty::Dynamic(ref data, ..) => data,\n-        _ => span_bug!(\n-            obligation.cause.span,\n-            \"confirm_object_candidate called with non-object: {:?}\",\n-            object_ty\n-        ),\n-    };\n-    let env_predicates = data\n-        .projection_bounds()\n-        .map(|p| p.with_self_ty(selcx.tcx(), object_ty).to_predicate())\n-        .collect();\n-    let env_predicate = {\n-        let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n-\n-        // select only those projections that are actually projecting an\n-        // item with the correct name\n-        let env_predicates = env_predicates.filter_map(|p| match p {\n-            ty::Predicate::Projection(data) => {\n-                if data.projection_def_id() == obligation.predicate.item_def_id {\n-                    Some(data)\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        });\n-\n-        // select those with a relevant trait-ref\n-        let mut env_predicates = env_predicates.filter(|data| {\n-            let data_poly_trait_ref = data.to_poly_trait_ref(selcx.tcx());\n-            let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n-            selcx.infcx().probe(|_| {\n-                selcx\n-                    .infcx()\n-                    .at(&obligation.cause, obligation.param_env)\n-                    .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n-                    .is_ok()\n-            })\n-        });\n-\n-        // select the first matching one; there really ought to be one or\n-        // else the object type is not WF, since an object type should\n-        // include all of its projections explicitly\n-        match env_predicates.next() {\n-            Some(env_predicate) => env_predicate,\n-            None => {\n-                debug!(\n-                    \"confirm_object_candidate: no env-predicate \\\n-                     found in object type `{:?}`; ill-formed\",\n-                    object_ty\n-                );\n-                return Progress::error(selcx.tcx());\n-            }\n-        }\n-    };\n-\n-    confirm_param_env_candidate(selcx, obligation, env_predicate)\n-}\n-\n-fn confirm_generator_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx> {\n-    let gen_sig = vtable.substs.as_generator().poly_sig(vtable.generator_def_id, selcx.tcx());\n-    let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n-        selcx,\n-        obligation.param_env,\n-        obligation.cause.clone(),\n-        obligation.recursion_depth + 1,\n-        &gen_sig,\n-    );\n-\n-    debug!(\n-        \"confirm_generator_candidate: obligation={:?},gen_sig={:?},obligations={:?}\",\n-        obligation, gen_sig, obligations\n-    );\n-\n-    let tcx = selcx.tcx();\n-\n-    let gen_def_id = tcx.lang_items().gen_trait().unwrap();\n-\n-    let predicate = super::util::generator_trait_ref_and_outputs(\n-        tcx,\n-        gen_def_id,\n-        obligation.predicate.self_ty(),\n-        gen_sig,\n-    )\n-    .map_bound(|(trait_ref, yield_ty, return_ty)| {\n-        let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n-        let ty = if name == sym::Return {\n-            return_ty\n-        } else if name == sym::Yield {\n-            yield_ty\n-        } else {\n-            bug!()\n-        };\n-\n-        ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy {\n-                substs: trait_ref.substs,\n-                item_def_id: obligation.predicate.item_def_id,\n-            },\n-            ty,\n-        }\n-    });\n-\n-    confirm_param_env_candidate(selcx, obligation, predicate)\n-        .with_addl_obligations(vtable.nested)\n-        .with_addl_obligations(obligations)\n-}\n-\n-fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx> {\n-    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n-    let sig = fn_type.fn_sig(selcx.tcx());\n-    let Normalized { value: sig, obligations } = normalize_with_depth(\n-        selcx,\n-        obligation.param_env,\n-        obligation.cause.clone(),\n-        obligation.recursion_depth + 1,\n-        &sig,\n-    );\n-\n-    confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n-        .with_addl_obligations(fn_pointer_vtable.nested)\n-        .with_addl_obligations(obligations)\n-}\n-\n-fn confirm_closure_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx> {\n-    let tcx = selcx.tcx();\n-    let infcx = selcx.infcx();\n-    let closure_sig_ty = vtable.substs.as_closure().sig_ty(vtable.closure_def_id, tcx);\n-    let closure_sig = infcx.shallow_resolve(closure_sig_ty).fn_sig(tcx);\n-    let Normalized { value: closure_sig, obligations } = normalize_with_depth(\n-        selcx,\n-        obligation.param_env,\n-        obligation.cause.clone(),\n-        obligation.recursion_depth + 1,\n-        &closure_sig,\n-    );\n-\n-    debug!(\n-        \"confirm_closure_candidate: obligation={:?},closure_sig={:?},obligations={:?}\",\n-        obligation, closure_sig, obligations\n-    );\n-\n-    confirm_callable_candidate(selcx, obligation, closure_sig, util::TupleArgumentsFlag::No)\n-        .with_addl_obligations(vtable.nested)\n-        .with_addl_obligations(obligations)\n-}\n-\n-fn confirm_callable_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    fn_sig: ty::PolyFnSig<'tcx>,\n-    flag: util::TupleArgumentsFlag,\n-) -> Progress<'tcx> {\n-    let tcx = selcx.tcx();\n-\n-    debug!(\"confirm_callable_candidate({:?},{:?})\", obligation, fn_sig);\n-\n-    // the `Output` associated type is declared on `FnOnce`\n-    let fn_once_def_id = tcx.lang_items().fn_once_trait().unwrap();\n-\n-    let predicate = super::util::closure_trait_ref_and_return_type(\n-        tcx,\n-        fn_once_def_id,\n-        obligation.predicate.self_ty(),\n-        fn_sig,\n-        flag,\n-    )\n-    .map_bound(|(trait_ref, ret_type)| ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy::from_ref_and_name(\n-            tcx,\n-            trait_ref,\n-            Ident::with_dummy_span(rustc_hir::FN_OUTPUT_NAME),\n-        ),\n-        ty: ret_type,\n-    });\n-\n-    confirm_param_env_candidate(selcx, obligation, predicate)\n-}\n-\n-fn confirm_param_env_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n-) -> Progress<'tcx> {\n-    let infcx = selcx.infcx();\n-    let cause = &obligation.cause;\n-    let param_env = obligation.param_env;\n-\n-    let (cache_entry, _) = infcx.replace_bound_vars_with_fresh_vars(\n-        cause.span,\n-        LateBoundRegionConversionTime::HigherRankedType,\n-        &poly_cache_entry,\n-    );\n-\n-    let cache_trait_ref = cache_entry.projection_ty.trait_ref(infcx.tcx);\n-    let obligation_trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n-    match infcx.at(cause, param_env).eq(cache_trait_ref, obligation_trait_ref) {\n-        Ok(InferOk { value: _, obligations }) => Progress { ty: cache_entry.ty, obligations },\n-        Err(e) => {\n-            let msg = format!(\n-                \"Failed to unify obligation `{:?}` with poly_projection `{:?}`: {:?}\",\n-                obligation, poly_cache_entry, e,\n-            );\n-            debug!(\"confirm_param_env_candidate: {}\", msg);\n-            infcx.tcx.sess.delay_span_bug(obligation.cause.span, &msg);\n-            Progress { ty: infcx.tcx.types.err, obligations: vec![] }\n-        }\n-    }\n-}\n-\n-fn confirm_impl_candidate<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    obligation: &ProjectionTyObligation<'tcx>,\n-    impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>,\n-) -> Progress<'tcx> {\n-    let tcx = selcx.tcx();\n-\n-    let VtableImplData { impl_def_id, substs, nested } = impl_vtable;\n-    let assoc_item_id = obligation.predicate.item_def_id;\n-    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n-\n-    let param_env = obligation.param_env;\n-    let assoc_ty = assoc_ty_def(selcx, impl_def_id, assoc_item_id);\n-\n-    if !assoc_ty.item.defaultness.has_value() {\n-        // This means that the impl is missing a definition for the\n-        // associated type. This error will be reported by the type\n-        // checker method `check_impl_items_against_trait`, so here we\n-        // just return Error.\n-        debug!(\n-            \"confirm_impl_candidate: no associated type {:?} for {:?}\",\n-            assoc_ty.item.ident, obligation.predicate\n-        );\n-        return Progress { ty: tcx.types.err, obligations: nested };\n-    }\n-    let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n-    let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n-    let ty = if let ty::AssocKind::OpaqueTy = assoc_ty.item.kind {\n-        let item_substs = InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n-        tcx.mk_opaque(assoc_ty.item.def_id, item_substs)\n-    } else {\n-        tcx.type_of(assoc_ty.item.def_id)\n-    };\n-    if substs.len() != tcx.generics_of(assoc_ty.item.def_id).count() {\n-        tcx.sess\n-            .delay_span_bug(DUMMY_SP, \"impl item and trait item have different parameter counts\");\n-        Progress { ty: tcx.types.err, obligations: nested }\n-    } else {\n-        Progress { ty: ty.subst(tcx, substs), obligations: nested }\n-    }\n-}\n-\n-/// Locate the definition of an associated type in the specialization hierarchy,\n-/// starting from the given impl.\n-///\n-/// Based on the \"projection mode\", this lookup may in fact only examine the\n-/// topmost impl. See the comments for `Reveal` for more details.\n-fn assoc_ty_def(\n-    selcx: &SelectionContext<'_, '_>,\n-    impl_def_id: DefId,\n-    assoc_ty_def_id: DefId,\n-) -> specialization_graph::NodeItem<ty::AssocItem> {\n-    let tcx = selcx.tcx();\n-    let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n-    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n-    let trait_def = tcx.trait_def(trait_def_id);\n-\n-    // This function may be called while we are still building the\n-    // specialization graph that is queried below (via TraidDef::ancestors()),\n-    // so, in order to avoid unnecessary infinite recursion, we manually look\n-    // for the associated item at the given impl.\n-    // If there is no such item in that impl, this function will fail with a\n-    // cycle error if the specialization graph is currently being built.\n-    let impl_node = specialization_graph::Node::Impl(impl_def_id);\n-    for item in impl_node.items(tcx) {\n-        if matches!(item.kind, ty::AssocKind::Type | ty::AssocKind::OpaqueTy)\n-            && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n-        {\n-            return specialization_graph::NodeItem {\n-                node: specialization_graph::Node::Impl(impl_def_id),\n-                item: *item,\n-            };\n-        }\n-    }\n-\n-    if let Some(assoc_item) =\n-        trait_def.ancestors(tcx, impl_def_id).leaf_def(tcx, assoc_ty_name, ty::AssocKind::Type)\n-    {\n-        assoc_item\n-    } else {\n-        // This is saying that neither the trait nor\n-        // the impl contain a definition for this\n-        // associated type.  Normally this situation\n-        // could only arise through a compiler bug --\n-        // if the user wrote a bad item name, it\n-        // should have failed in astconv.\n-        bug!(\"No associated type `{}` for {}\", assoc_ty_name, tcx.def_path_str(impl_def_id))\n+        Normalized { value: value, obligations: self.obligations }\n     }\n }\n \n@@ -1541,26 +68,14 @@ pub struct ProjectionCacheKey<'tcx> {\n     ty: ty::ProjectionTy<'tcx>,\n }\n \n-impl<'cx, 'tcx> ProjectionCacheKey<'tcx> {\n-    pub fn from_poly_projection_predicate(\n-        selcx: &mut SelectionContext<'cx, 'tcx>,\n-        predicate: &ty::PolyProjectionPredicate<'tcx>,\n-    ) -> Option<Self> {\n-        let infcx = selcx.infcx();\n-        // We don't do cross-snapshot caching of obligations with escaping regions,\n-        // so there's no cache key to use\n-        predicate.no_bound_vars().map(|predicate| ProjectionCacheKey {\n-            // We don't attempt to match up with a specific type-variable state\n-            // from a specific call to `opt_normalize_projection_type` - if\n-            // there's no precise match, the original cache entry is \"stranded\"\n-            // anyway.\n-            ty: infcx.resolve_vars_if_possible(&predicate.projection_ty),\n-        })\n+impl ProjectionCacheKey<'tcx> {\n+    pub fn new(ty: ty::ProjectionTy<'tcx>) -> Self {\n+        Self { ty }\n     }\n }\n \n #[derive(Clone, Debug)]\n-enum ProjectionCacheEntry<'tcx> {\n+pub enum ProjectionCacheEntry<'tcx> {\n     InProgress,\n     Ambiguous,\n     Error,\n@@ -1596,7 +111,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n     /// Try to start normalize `key`; returns an error if\n     /// normalization already occurred (this error corresponds to a\n     /// cache hit, so it's actually a good thing).\n-    fn try_start(\n+    pub fn try_start(\n         &mut self,\n         key: ProjectionCacheKey<'tcx>,\n     ) -> Result<(), ProjectionCacheEntry<'tcx>> {\n@@ -1609,7 +124,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n     }\n \n     /// Indicates that `key` was normalized to `value`.\n-    fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: NormalizedTy<'tcx>) {\n+    pub fn insert_ty(&mut self, key: ProjectionCacheKey<'tcx>, value: NormalizedTy<'tcx>) {\n         debug!(\n             \"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n             key, value\n@@ -1662,14 +177,14 @@ impl<'tcx> ProjectionCache<'tcx> {\n     /// ambiguity. No point in trying it again then until we gain more\n     /// type information (in which case, the \"fully resolved\" key will\n     /// be different).\n-    fn ambiguous(&mut self, key: ProjectionCacheKey<'tcx>) {\n+    pub fn ambiguous(&mut self, key: ProjectionCacheKey<'tcx>) {\n         let fresh = self.map.insert(key, ProjectionCacheEntry::Ambiguous);\n         assert!(!fresh, \"never started projecting `{:?}`\", key);\n     }\n \n     /// Indicates that trying to normalize `key` resulted in\n     /// error.\n-    fn error(&mut self, key: ProjectionCacheKey<'tcx>) {\n+    pub fn error(&mut self, key: ProjectionCacheKey<'tcx>) {\n         let fresh = self.map.insert(key, ProjectionCacheEntry::Error);\n         assert!(!fresh, \"never started projecting `{:?}`\", key);\n     }"}, {"sha": "a7c0267111522eee1f7cee40e439c24cce5833c4", "filename": "src/librustc_infer/traits/util.rs", "status": "modified", "additions": 2, "deletions": 452, "changes": 454, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_infer%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Futil.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,16 +1,8 @@\n-use rustc_errors::DiagnosticBuilder;\n-use rustc_span::Span;\n use smallvec::smallvec;\n-use smallvec::SmallVec;\n \n use rustc::ty::outlives::Component;\n-use rustc::ty::subst::{GenericArg, Subst, SubstsRef};\n-use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc::ty::{self, ToPolyTraitRef, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-\n-use super::{Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext};\n \n fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n     match *pred {\n@@ -55,7 +47,7 @@ struct PredicateSet<'tcx> {\n \n impl PredicateSet<'tcx> {\n     fn new(tcx: TyCtxt<'tcx>) -> Self {\n-        Self { tcx, set: Default::default() }\n+        Self { tcx: tcx, set: Default::default() }\n     }\n \n     fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n@@ -96,21 +88,6 @@ pub struct Elaborator<'tcx> {\n     visited: PredicateSet<'tcx>,\n }\n \n-pub fn elaborate_trait_ref<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Elaborator<'tcx> {\n-    elaborate_predicates(tcx, vec![trait_ref.without_const().to_predicate()])\n-}\n-\n-pub fn elaborate_trait_refs<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Elaborator<'tcx> {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate()).collect();\n-    elaborate_predicates(tcx, predicates)\n-}\n-\n pub fn elaborate_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     mut predicates: Vec<ty::Predicate<'tcx>>,\n@@ -121,10 +98,6 @@ pub fn elaborate_predicates<'tcx>(\n }\n \n impl Elaborator<'tcx> {\n-    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n-        FilterToTraits::new(self)\n-    }\n-\n     fn elaborate(&mut self, predicate: &ty::Predicate<'tcx>) {\n         let tcx = self.visited.tcx;\n         match *predicate {\n@@ -250,426 +223,3 @@ impl Iterator for Elaborator<'tcx> {\n         }\n     }\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Supertrait iterator\n-///////////////////////////////////////////////////////////////////////////\n-\n-pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n-\n-pub fn supertraits<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n-}\n-\n-pub fn transitive_bounds<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n-) -> Supertraits<'tcx> {\n-    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// `TraitAliasExpander` iterator\n-///////////////////////////////////////////////////////////////////////////\n-\n-/// \"Trait alias expansion\" is the process of expanding a sequence of trait\n-/// references into another sequence by transitively following all trait\n-/// aliases. e.g. If you have bounds like `Foo + Send`, a trait alias\n-/// `trait Foo = Bar + Sync;`, and another trait alias\n-/// `trait Bar = Read + Write`, then the bounds would expand to\n-/// `Read + Write + Sync + Send`.\n-/// Expansion is done via a DFS (depth-first search), and the `visited` field\n-/// is used to avoid cycles.\n-pub struct TraitAliasExpander<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    stack: Vec<TraitAliasExpansionInfo<'tcx>>,\n-}\n-\n-/// Stores information about the expansion of a trait via a path of zero or more trait aliases.\n-#[derive(Debug, Clone)]\n-pub struct TraitAliasExpansionInfo<'tcx> {\n-    pub path: SmallVec<[(ty::PolyTraitRef<'tcx>, Span); 4]>,\n-}\n-\n-impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n-    fn new(trait_ref: ty::PolyTraitRef<'tcx>, span: Span) -> Self {\n-        Self { path: smallvec![(trait_ref, span)] }\n-    }\n-\n-    /// Adds diagnostic labels to `diag` for the expansion path of a trait through all intermediate\n-    /// trait aliases.\n-    pub fn label_with_exp_info(\n-        &self,\n-        diag: &mut DiagnosticBuilder<'_>,\n-        top_label: &str,\n-        use_desc: &str,\n-    ) {\n-        diag.span_label(self.top().1, top_label);\n-        if self.path.len() > 1 {\n-            for (_, sp) in self.path.iter().rev().skip(1).take(self.path.len() - 2) {\n-                diag.span_label(*sp, format!(\"referenced here ({})\", use_desc));\n-            }\n-        }\n-        diag.span_label(\n-            self.bottom().1,\n-            format!(\"trait alias used in trait object type ({})\", use_desc),\n-        );\n-    }\n-\n-    pub fn trait_ref(&self) -> &ty::PolyTraitRef<'tcx> {\n-        &self.top().0\n-    }\n-\n-    pub fn top(&self) -> &(ty::PolyTraitRef<'tcx>, Span) {\n-        self.path.last().unwrap()\n-    }\n-\n-    pub fn bottom(&self) -> &(ty::PolyTraitRef<'tcx>, Span) {\n-        self.path.first().unwrap()\n-    }\n-\n-    fn clone_and_push(&self, trait_ref: ty::PolyTraitRef<'tcx>, span: Span) -> Self {\n-        let mut path = self.path.clone();\n-        path.push((trait_ref, span));\n-\n-        Self { path }\n-    }\n-}\n-\n-pub fn expand_trait_aliases<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>,\n-) -> TraitAliasExpander<'tcx> {\n-    let items: Vec<_> = trait_refs\n-        .into_iter()\n-        .map(|(trait_ref, span)| TraitAliasExpansionInfo::new(trait_ref, span))\n-        .collect();\n-    TraitAliasExpander { tcx, stack: items }\n-}\n-\n-impl<'tcx> TraitAliasExpander<'tcx> {\n-    /// If `item` is a trait alias and its predicate has not yet been visited, then expands `item`\n-    /// to the definition, pushes the resulting expansion onto `self.stack`, and returns `false`.\n-    /// Otherwise, immediately returns `true` if `item` is a regular trait, or `false` if it is a\n-    /// trait alias.\n-    /// The return value indicates whether `item` should be yielded to the user.\n-    fn expand(&mut self, item: &TraitAliasExpansionInfo<'tcx>) -> bool {\n-        let tcx = self.tcx;\n-        let trait_ref = item.trait_ref();\n-        let pred = trait_ref.without_const().to_predicate();\n-\n-        debug!(\"expand_trait_aliases: trait_ref={:?}\", trait_ref);\n-\n-        // Don't recurse if this bound is not a trait alias.\n-        let is_alias = tcx.is_trait_alias(trait_ref.def_id());\n-        if !is_alias {\n-            return true;\n-        }\n-\n-        // Don't recurse if this trait alias is already on the stack for the DFS search.\n-        let anon_pred = anonymize_predicate(tcx, &pred);\n-        if item.path.iter().rev().skip(1).any(|(tr, _)| {\n-            anonymize_predicate(tcx, &tr.without_const().to_predicate()) == anon_pred\n-        }) {\n-            return false;\n-        }\n-\n-        // Get components of trait alias.\n-        let predicates = tcx.super_predicates_of(trait_ref.def_id());\n-\n-        let items = predicates.predicates.iter().rev().filter_map(|(pred, span)| {\n-            pred.subst_supertrait(tcx, &trait_ref)\n-                .to_opt_poly_trait_ref()\n-                .map(|trait_ref| item.clone_and_push(trait_ref, *span))\n-        });\n-        debug!(\"expand_trait_aliases: items={:?}\", items.clone());\n-\n-        self.stack.extend(items);\n-\n-        false\n-    }\n-}\n-\n-impl<'tcx> Iterator for TraitAliasExpander<'tcx> {\n-    type Item = TraitAliasExpansionInfo<'tcx>;\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (self.stack.len(), None)\n-    }\n-\n-    fn next(&mut self) -> Option<TraitAliasExpansionInfo<'tcx>> {\n-        while let Some(item) = self.stack.pop() {\n-            if self.expand(&item) {\n-                return Some(item);\n-            }\n-        }\n-        None\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Iterator over def-IDs of supertraits\n-///////////////////////////////////////////////////////////////////////////\n-\n-pub struct SupertraitDefIds<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    stack: Vec<DefId>,\n-    visited: FxHashSet<DefId>,\n-}\n-\n-pub fn supertrait_def_ids(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SupertraitDefIds<'_> {\n-    SupertraitDefIds {\n-        tcx,\n-        stack: vec![trait_def_id],\n-        visited: Some(trait_def_id).into_iter().collect(),\n-    }\n-}\n-\n-impl Iterator for SupertraitDefIds<'tcx> {\n-    type Item = DefId;\n-\n-    fn next(&mut self) -> Option<DefId> {\n-        let def_id = self.stack.pop()?;\n-        let predicates = self.tcx.super_predicates_of(def_id);\n-        let visited = &mut self.visited;\n-        self.stack.extend(\n-            predicates\n-                .predicates\n-                .iter()\n-                .filter_map(|(pred, _)| pred.to_opt_poly_trait_ref())\n-                .map(|trait_ref| trait_ref.def_id())\n-                .filter(|&super_def_id| visited.insert(super_def_id)),\n-        );\n-        Some(def_id)\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Other\n-///////////////////////////////////////////////////////////////////////////\n-\n-/// A filter around an iterator of predicates that makes it yield up\n-/// just trait references.\n-pub struct FilterToTraits<I> {\n-    base_iterator: I,\n-}\n-\n-impl<I> FilterToTraits<I> {\n-    fn new(base: I) -> FilterToTraits<I> {\n-        FilterToTraits { base_iterator: base }\n-    }\n-}\n-\n-impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n-    type Item = ty::PolyTraitRef<'tcx>;\n-\n-    fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n-        while let Some(pred) = self.base_iterator.next() {\n-            if let ty::Predicate::Trait(data, _) = pred {\n-                return Some(data.to_poly_trait_ref());\n-            }\n-        }\n-        None\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (_, upper) = self.base_iterator.size_hint();\n-        (0, upper)\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Other\n-///////////////////////////////////////////////////////////////////////////\n-\n-/// Instantiate all bound parameters of the impl with the given substs,\n-/// returning the resulting trait ref and all obligations that arise.\n-/// The obligations are closed under normalization.\n-pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n-    selcx: &mut SelectionContext<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    impl_def_id: DefId,\n-    impl_substs: SubstsRef<'tcx>,\n-) -> (ty::TraitRef<'tcx>, Vec<PredicateObligation<'tcx>>) {\n-    let impl_trait_ref = selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n-    let impl_trait_ref = impl_trait_ref.subst(selcx.tcx(), impl_substs);\n-    let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n-        super::normalize(selcx, param_env, ObligationCause::dummy(), &impl_trait_ref);\n-\n-    let predicates = selcx.tcx().predicates_of(impl_def_id);\n-    let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n-    let Normalized { value: predicates, obligations: normalization_obligations2 } =\n-        super::normalize(selcx, param_env, ObligationCause::dummy(), &predicates);\n-    let impl_obligations =\n-        predicates_for_generics(ObligationCause::dummy(), 0, param_env, &predicates);\n-\n-    let impl_obligations: Vec<_> = impl_obligations\n-        .into_iter()\n-        .chain(normalization_obligations1)\n-        .chain(normalization_obligations2)\n-        .collect();\n-\n-    (impl_trait_ref, impl_obligations)\n-}\n-\n-/// See [`super::obligations_for_generics`].\n-pub fn predicates_for_generics<'tcx>(\n-    cause: ObligationCause<'tcx>,\n-    recursion_depth: usize,\n-    param_env: ty::ParamEnv<'tcx>,\n-    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n-) -> Vec<PredicateObligation<'tcx>> {\n-    debug!(\"predicates_for_generics(generic_bounds={:?})\", generic_bounds);\n-\n-    generic_bounds\n-        .predicates\n-        .iter()\n-        .map(|&predicate| Obligation {\n-            cause: cause.clone(),\n-            recursion_depth,\n-            param_env,\n-            predicate,\n-        })\n-        .collect()\n-}\n-\n-pub fn predicate_for_trait_ref<'tcx>(\n-    cause: ObligationCause<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    trait_ref: ty::TraitRef<'tcx>,\n-    recursion_depth: usize,\n-) -> PredicateObligation<'tcx> {\n-    Obligation {\n-        cause,\n-        param_env,\n-        recursion_depth,\n-        predicate: trait_ref.without_const().to_predicate(),\n-    }\n-}\n-\n-pub fn predicate_for_trait_def(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    cause: ObligationCause<'tcx>,\n-    trait_def_id: DefId,\n-    recursion_depth: usize,\n-    self_ty: Ty<'tcx>,\n-    params: &[GenericArg<'tcx>],\n-) -> PredicateObligation<'tcx> {\n-    let trait_ref =\n-        ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(self_ty, params) };\n-    predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n-}\n-\n-/// Casts a trait reference into a reference to one of its super\n-/// traits; returns `None` if `target_trait_def_id` is not a\n-/// supertrait.\n-pub fn upcast_choices(\n-    tcx: TyCtxt<'tcx>,\n-    source_trait_ref: ty::PolyTraitRef<'tcx>,\n-    target_trait_def_id: DefId,\n-) -> Vec<ty::PolyTraitRef<'tcx>> {\n-    if source_trait_ref.def_id() == target_trait_def_id {\n-        return vec![source_trait_ref]; // Shortcut the most common case.\n-    }\n-\n-    supertraits(tcx, source_trait_ref).filter(|r| r.def_id() == target_trait_def_id).collect()\n-}\n-\n-/// Given a trait `trait_ref`, returns the number of vtable entries\n-/// that come from `trait_ref`, excluding its supertraits. Used in\n-/// computing the vtable base for an upcast trait of a trait object.\n-pub fn count_own_vtable_entries(tcx: TyCtxt<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n-    let mut entries = 0;\n-    // Count number of methods and add them to the total offset.\n-    // Skip over associated types and constants.\n-    for trait_item in tcx.associated_items(trait_ref.def_id()).in_definition_order() {\n-        if trait_item.kind == ty::AssocKind::Method {\n-            entries += 1;\n-        }\n-    }\n-    entries\n-}\n-\n-/// Given an upcast trait object described by `object`, returns the\n-/// index of the method `method_def_id` (which should be part of\n-/// `object.upcast_trait_ref`) within the vtable for `object`.\n-pub fn get_vtable_index_of_object_method<N>(\n-    tcx: TyCtxt<'tcx>,\n-    object: &super::VtableObjectData<'tcx, N>,\n-    method_def_id: DefId,\n-) -> usize {\n-    // Count number of methods preceding the one we are selecting and\n-    // add them to the total offset.\n-    // Skip over associated types and constants.\n-    let mut entries = object.vtable_base;\n-    for trait_item in tcx.associated_items(object.upcast_trait_ref.def_id()).in_definition_order() {\n-        if trait_item.def_id == method_def_id {\n-            // The item with the ID we were given really ought to be a method.\n-            assert_eq!(trait_item.kind, ty::AssocKind::Method);\n-            return entries;\n-        }\n-        if trait_item.kind == ty::AssocKind::Method {\n-            entries += 1;\n-        }\n-    }\n-\n-    bug!(\"get_vtable_index_of_object_method: {:?} was not found\", method_def_id);\n-}\n-\n-pub fn closure_trait_ref_and_return_type(\n-    tcx: TyCtxt<'tcx>,\n-    fn_trait_def_id: DefId,\n-    self_ty: Ty<'tcx>,\n-    sig: ty::PolyFnSig<'tcx>,\n-    tuple_arguments: TupleArgumentsFlag,\n-) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)> {\n-    let arguments_tuple = match tuple_arguments {\n-        TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n-        TupleArgumentsFlag::Yes => tcx.intern_tup(sig.skip_binder().inputs()),\n-    };\n-    let trait_ref = ty::TraitRef {\n-        def_id: fn_trait_def_id,\n-        substs: tcx.mk_substs_trait(self_ty, &[arguments_tuple.into()]),\n-    };\n-    ty::Binder::bind((trait_ref, sig.skip_binder().output()))\n-}\n-\n-pub fn generator_trait_ref_and_outputs(\n-    tcx: TyCtxt<'tcx>,\n-    fn_trait_def_id: DefId,\n-    self_ty: Ty<'tcx>,\n-    sig: ty::PolyGenSig<'tcx>,\n-) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)> {\n-    let trait_ref = ty::TraitRef {\n-        def_id: fn_trait_def_id,\n-        substs: tcx.mk_substs_trait(self_ty, &[sig.skip_binder().resume_ty.into()]),\n-    };\n-    ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n-}\n-\n-pub fn impl_is_default(tcx: TyCtxt<'_>, node_item_def_id: DefId) -> bool {\n-    match tcx.hir().as_local_hir_id(node_item_def_id) {\n-        Some(hir_id) => {\n-            let item = tcx.hir().expect_item(hir_id);\n-            if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n-                defaultness.is_default()\n-            } else {\n-                false\n-            }\n-        }\n-        None => tcx.impl_defaultness(node_item_def_id).is_default(),\n-    }\n-}\n-\n-pub fn impl_item_is_final(tcx: TyCtxt<'_>, assoc_item: &ty::AssocItem) -> bool {\n-    assoc_item.defaultness.is_final() && !impl_is_default(tcx, assoc_item.container.id())\n-}\n-\n-pub enum TupleArgumentsFlag {\n-    Yes,\n-    No,\n-}"}, {"sha": "e84181f1d75e7238512b6b544ab3c40afaeabe03", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -42,6 +42,7 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_plugin_impl = { path = \"../librustc_plugin_impl\" }\n rustc_privacy = { path = \"../librustc_privacy\" }\n rustc_resolve = { path = \"../librustc_resolve\" }\n+rustc_trait_selection = { path = \"../librustc_trait_selection\" }\n rustc_ty = { path = \"../librustc_ty\" }\n tempfile = \"3.0.5\"\n once_cell = \"1\""}, {"sha": "bffbcd3366991c0db603f95f6d404d89b36a4c5c", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -27,7 +27,6 @@ use rustc_errors::PResult;\n use rustc_expand::base::ExtCtxt;\n use rustc_hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc_hir::Crate;\n-use rustc_infer::traits;\n use rustc_lint::LintStore;\n use rustc_mir as mir;\n use rustc_mir_build as mir_build;\n@@ -37,6 +36,7 @@ use rustc_plugin_impl as plugin;\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_span::symbol::Symbol;\n use rustc_span::FileName;\n+use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n \n use rustc_serialize::json;"}, {"sha": "9785af5eab2fd1e91d104357281a00b451691d6f", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -24,3 +24,4 @@ rustc_feature = { path = \"../librustc_feature\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_infer = { path = \"../librustc_infer\" }\n+rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "50c2c6f95522890db46ab6677588a5379c45ae81", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -39,12 +39,12 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{GenericParamKind, PatKind};\n use rustc_hir::{HirIdSet, Node};\n-use rustc_infer::traits::misc::can_type_implement_copy;\n use rustc_session::lint::FutureIncompatibleInfo;\n use rustc_span::edition::Edition;\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{BytePos, Span};\n+use rustc_trait_selection::traits::misc::can_type_implement_copy;\n \n use crate::nonstandard_style::{method_context, MethodLateContext};\n "}, {"sha": "cad50d50f3ceca60dd99d4b37bf33499719bd36d", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -28,6 +28,7 @@ rustc_lexer = { path = \"../librustc_lexer\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_target = { path = \"../librustc_target\" }\n+rustc_trait_selection = { path = \"../librustc_trait_selection\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_apfloat = { path = \"../librustc_apfloat\" }"}, {"sha": "e895eec5d52af45752284c2cfccab48391defe94", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -10,9 +10,9 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc_index::vec::Idx;\n-use rustc_infer::traits::error_reporting::suggest_constraining_type_param;\n use rustc_span::source_map::DesugaringKind;\n use rustc_span::Span;\n+use rustc_trait_selection::traits::error_reporting::suggest_constraining_type_param;\n \n use crate::dataflow::drop_flag_effects;\n use crate::dataflow::indexes::{MoveOutIndex, MovePathIndex};"}, {"sha": "f751a16cfce7c7c53aabe95a9eb076c359d827b7", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -4,7 +4,8 @@ use rustc::mir::ConstraintCategory;\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_infer::infer::{\n-    error_reporting::nice_region_error::NiceRegionError, opaque_types, NLLRegionVariableOrigin,\n+    error_reporting::nice_region_error::NiceRegionError,\n+    error_reporting::unexpected_hidden_region_diagnostic, NLLRegionVariableOrigin,\n };\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n@@ -197,7 +198,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n                     let named_ty = self.regioncx.name_regions(self.infcx.tcx, hidden_ty);\n                     let named_region = self.regioncx.name_regions(self.infcx.tcx, member_region);\n-                    opaque_types::unexpected_hidden_region_diagnostic(\n+                    unexpected_hidden_region_diagnostic(\n                         self.infcx.tcx,\n                         Some(region_scope_tree),\n                         span,"}, {"sha": "49b494373284712802a2c0e5e1f13654dba553b2", "filename": "src/librustc_mir/borrow_check/region_infer/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -3,6 +3,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferCtxt;\n use rustc_span::Span;\n+use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n use super::RegionInferenceContext;\n "}, {"sha": "c17db926946cdc67091ff7adf0081cc93649047d", "filename": "src/librustc_mir/borrow_check/type_check/free_region_relations.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Ffree_region_relations.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,13 +1,14 @@\n use rustc::mir::ConstraintCategory;\n+use rustc::traits::query::OutlivesBound;\n use rustc::ty::free_region_map::FreeRegionRelations;\n use rustc::ty::{self, RegionVid, Ty, TyCtxt};\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n+use rustc_infer::infer::outlives;\n use rustc_infer::infer::region_constraints::GenericKind;\n use rustc_infer::infer::InferCtxt;\n-use rustc_infer::traits::query::outlives_bounds::{self, OutlivesBound};\n-use rustc_infer::traits::query::type_op::{self, TypeOp};\n use rustc_span::DUMMY_SP;\n+use rustc_trait_selection::traits::query::type_op::{self, TypeOp};\n use std::rc::Rc;\n \n use crate::borrow_check::{\n@@ -266,7 +267,7 @@ impl UniversalRegionRelationsBuilder<'cx, 'tcx> {\n \n         // Insert the facts we know from the predicates. Why? Why not.\n         let param_env = self.param_env;\n-        self.add_outlives_bounds(outlives_bounds::explicit_outlives_bounds(param_env));\n+        self.add_outlives_bounds(outlives::explicit_outlives_bounds(param_env));\n \n         // Finally:\n         // - outlives is reflexive, so `'r: 'r` for every region `'r`"}, {"sha": "0c49ee44f9a5025ad6f63f779d74f62e1245f672", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -3,9 +3,9 @@ use rustc::ty::{Ty, TypeFoldable};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::bit_set::HybridBitSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n-use rustc_infer::traits::query::dropck_outlives::DropckOutlivesResult;\n-use rustc_infer::traits::query::type_op::outlives::DropckOutlives;\n-use rustc_infer::traits::query::type_op::TypeOp;\n+use rustc_trait_selection::traits::query::dropck_outlives::DropckOutlivesResult;\n+use rustc_trait_selection::traits::query::type_op::outlives::DropckOutlives;\n+use rustc_trait_selection::traits::query::type_op::TypeOp;\n use std::rc::Rc;\n \n use crate::dataflow::generic::ResultsCursor;"}, {"sha": "351b30bab614cd82ca790d0114b59deb97e4f782", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -24,17 +24,19 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n-use rustc_infer::infer::opaque_types::GenerateMemberConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n     InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin,\n };\n-use rustc_infer::traits::query::type_op;\n-use rustc_infer::traits::query::type_op::custom::CustomTypeOp;\n-use rustc_infer::traits::query::{Fallible, NoSolution};\n-use rustc_infer::traits::{self, ObligationCause, PredicateObligations};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::opaque_types::{GenerateMemberConstraints, InferCtxtExt};\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::query::type_op;\n+use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n+use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n+use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations};\n \n use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::MoveData;"}, {"sha": "ebaafd40262705a00a8a088503c575919ab0bdc6", "filename": "src/librustc_mir/borrow_check/type_check/relate_tys.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Frelate_tys.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -3,8 +3,8 @@ use rustc::ty::relate::TypeRelation;\n use rustc::ty::{self, Ty};\n use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin};\n-use rustc_infer::traits::query::Fallible;\n-use rustc_infer::traits::DomainGoal;\n+use rustc_trait_selection::traits::query::Fallible;\n+use rustc_trait_selection::traits::DomainGoal;\n \n use crate::borrow_check::constraints::OutlivesConstraint;\n use crate::borrow_check::type_check::{BorrowCheckContext, Locations};"}, {"sha": "adffd444eb68b1e000ca1a5a3519c8077d3a5433", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -9,9 +9,10 @@ use rustc_errors::struct_span_err;\n use rustc_hir::{def_id::DefId, HirId};\n use rustc_index::bit_set::BitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::{self, TraitEngine};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, TraitEngine};\n \n use std::borrow::Cow;\n use std::ops::Deref;"}, {"sha": "289b198d2c949a909fed3bae50fcfe73d84b1831", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -25,8 +25,8 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::traits;\n use rustc_span::Span;\n+use rustc_trait_selection::traits;\n \n use crate::const_eval::error_to_const_error;\n use crate::interpret::{"}, {"sha": "96716dbd604d50801ed11f0f945e7d5e34ed004e", "filename": "src/librustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -25,5 +25,6 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_target = { path = \"../librustc_target\" }\n+rustc_trait_selection = { path = \"../librustc_trait_selection\" }\n rustc_ast = { path = \"../librustc_ast\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "99caa6a0f95b48b3d475ae145090ea3e73359b32", "filename": "src/librustc_mir_build/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -19,6 +19,7 @@ use rustc_hir::Node;\n use rustc_index::vec::Idx;\n use rustc_infer::infer::InferCtxt;\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_trait_selection::infer::InferCtxtExt;\n \n #[derive(Clone)]\n crate struct Cx<'a, 'tcx> {"}, {"sha": "214e75fbdde43108676b90950611e0ed95afa7b1", "filename": "src/librustc_mir_build/hair/pattern/const_to_pat.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -3,8 +3,9 @@ use rustc::mir::Field;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::predicate_for_trait_def;\n-use rustc_infer::traits::{self, ObligationCause, PredicateObligation};\n+use rustc_trait_selection::traits::predicate_for_trait_def;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligation};\n \n use rustc_index::vec::Idx;\n "}, {"sha": "8acb88f58d379cad6b3dfe99190e0b67e5afecc4", "filename": "src/librustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -22,3 +22,4 @@ rustc_session = { path = \"../librustc_session\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n+rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "d056d9f0562a323e834b617ff62147fc4871f063", "filename": "src/librustc_passes/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_passes%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_passes%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstability.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -18,9 +18,9 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{Generics, HirId, Item, StructField, Variant};\n-use rustc_infer::traits::misc::can_type_implement_copy;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n+use rustc_trait_selection::traits::misc::can_type_implement_copy;\n \n use std::cmp::Ordering;\n use std::mem::replace;"}, {"sha": "49f079ad2707071acaeb0e359c91ac5853456b7a", "filename": "src/librustc_resolve/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -24,7 +24,6 @@ rustc_errors = { path = \"../librustc_errors\" }\n rustc_expand = { path = \"../librustc_expand\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_hir = { path = \"../librustc_hir\" }\n-rustc_infer = { path = \"../librustc_infer\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "5b2da41d06672c3e3e511fa2f00ad19ccc09857a", "filename": "src/librustc_trait_selection/Cargo.toml", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -0,0 +1,27 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_trait_selection\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_trait_selection\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+fmt_macros = { path = \"../libfmt_macros\" }\n+log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+rustc_attr = { path = \"../librustc_attr\" }\n+rustc = { path = \"../librustc\" }\n+rustc_ast = { path = \"../librustc_ast\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+rustc_hir = { path = \"../librustc_hir\" }\n+rustc_index = { path = \"../librustc_index\" }\n+rustc_infer = { path = \"../librustc_infer\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n+rustc_session = { path = \"../librustc_session\" }\n+rustc_span = { path = \"../librustc_span\" }\n+rustc_target = { path = \"../librustc_target\" }\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "7abcbf45277fba9ed4cc4783a86f802d9b675b35", "filename": "src/librustc_trait_selection/infer.rs", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Finfer.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -0,0 +1,182 @@\n+use crate::traits::query::outlives_bounds::InferCtxtExt as _;\n+use crate::traits::{self, TraitEngine, TraitEngineExt};\n+\n+use rustc::arena::ArenaAllocatable;\n+use rustc::infer::canonical::{Canonical, CanonicalizedQueryResponse, QueryResponse};\n+use rustc::middle::lang_items;\n+use rustc::traits::query::Fallible;\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc_hir as hir;\n+use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use std::fmt::Debug;\n+\n+pub use rustc_infer::infer::*;\n+\n+pub trait InferCtxtExt<'tcx> {\n+    fn type_is_copy_modulo_regions(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> bool;\n+\n+    fn partially_normalize_associated_types_in<T>(\n+        &self,\n+        span: Span,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> InferOk<'tcx, T>\n+    where\n+        T: TypeFoldable<'tcx>;\n+}\n+\n+impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n+    fn type_is_copy_modulo_regions(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> bool {\n+        let ty = self.resolve_vars_if_possible(&ty);\n+\n+        if !(param_env, ty).has_local_value() {\n+            return ty.is_copy_modulo_regions(self.tcx, param_env, span);\n+        }\n+\n+        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n+\n+        // This can get called from typeck (by euv), and `moves_by_default`\n+        // rightly refuses to work with inference variables, but\n+        // moves_by_default has a cache, which we want to use in other\n+        // cases.\n+        traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n+    }\n+\n+    /// Normalizes associated types in `value`, potentially returning\n+    /// new obligations that must further be processed.\n+    fn partially_normalize_associated_types_in<T>(\n+        &self,\n+        span: Span,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+    ) -> InferOk<'tcx, T>\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\"partially_normalize_associated_types_in(value={:?})\", value);\n+        let mut selcx = traits::SelectionContext::new(self);\n+        let cause = ObligationCause::misc(span, body_id);\n+        let traits::Normalized { value, obligations } =\n+            traits::normalize(&mut selcx, param_env, cause, value);\n+        debug!(\n+            \"partially_normalize_associated_types_in: result={:?} predicates={:?}\",\n+            value, obligations\n+        );\n+        InferOk { value, obligations }\n+    }\n+}\n+\n+pub trait InferCtxtBuilderExt<'tcx> {\n+    fn enter_canonical_trait_query<K, R>(\n+        &mut self,\n+        canonical_key: &Canonical<'tcx, K>,\n+        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n+    where\n+        K: TypeFoldable<'tcx>,\n+        R: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable;\n+}\n+\n+impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n+    /// The \"main method\" for a canonicalized trait query. Given the\n+    /// canonical key `canonical_key`, this method will create a new\n+    /// inference context, instantiate the key, and run your operation\n+    /// `op`. The operation should yield up a result (of type `R`) as\n+    /// well as a set of trait obligations that must be fully\n+    /// satisfied. These obligations will be processed and the\n+    /// canonical result created.\n+    ///\n+    /// Returns `NoSolution` in the event of any error.\n+    ///\n+    /// (It might be mildly nicer to implement this on `TyCtxt`, and\n+    /// not `InferCtxtBuilder`, but that is a bit tricky right now.\n+    /// In part because we would need a `for<'tcx>` sort of\n+    /// bound for the closure and in part because it is convenient to\n+    /// have `'tcx` be free on this function so that we can talk about\n+    /// `K: TypeFoldable<'tcx>`.)\n+    fn enter_canonical_trait_query<K, R>(\n+        &mut self,\n+        canonical_key: &Canonical<'tcx, K>,\n+        operation: impl FnOnce(&InferCtxt<'_, 'tcx>, &mut dyn TraitEngine<'tcx>, K) -> Fallible<R>,\n+    ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n+    where\n+        K: TypeFoldable<'tcx>,\n+        R: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable,\n+    {\n+        self.enter_with_canonical(\n+            DUMMY_SP,\n+            canonical_key,\n+            |ref infcx, key, canonical_inference_vars| {\n+                let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n+                let value = operation(infcx, &mut *fulfill_cx, key)?;\n+                infcx.make_canonicalized_query_response(\n+                    canonical_inference_vars,\n+                    value,\n+                    &mut *fulfill_cx,\n+                )\n+            },\n+        )\n+    }\n+}\n+\n+pub trait OutlivesEnvironmentExt<'tcx> {\n+    fn add_implied_bounds(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'tcx>,\n+        fn_sig_tys: &[Ty<'tcx>],\n+        body_id: hir::HirId,\n+        span: Span,\n+    );\n+}\n+\n+impl<'tcx> OutlivesEnvironmentExt<'tcx> for OutlivesEnvironment<'tcx> {\n+    /// This method adds \"implied bounds\" into the outlives environment.\n+    /// Implied bounds are outlives relationships that we can deduce\n+    /// on the basis that certain types must be well-formed -- these are\n+    /// either the types that appear in the function signature or else\n+    /// the input types to an impl. For example, if you have a function\n+    /// like\n+    ///\n+    /// ```\n+    /// fn foo<'a, 'b, T>(x: &'a &'b [T]) { }\n+    /// ```\n+    ///\n+    /// we can assume in the caller's body that `'b: 'a` and that `T:\n+    /// 'b` (and hence, transitively, that `T: 'a`). This method would\n+    /// add those assumptions into the outlives-environment.\n+    ///\n+    /// Tests: `src/test/compile-fail/regions-free-region-ordering-*.rs`\n+    fn add_implied_bounds(\n+        &mut self,\n+        infcx: &InferCtxt<'a, 'tcx>,\n+        fn_sig_tys: &[Ty<'tcx>],\n+        body_id: hir::HirId,\n+        span: Span,\n+    ) {\n+        debug!(\"add_implied_bounds()\");\n+\n+        for &ty in fn_sig_tys {\n+            let ty = infcx.resolve_vars_if_possible(&ty);\n+            debug!(\"add_implied_bounds: ty = {}\", ty);\n+            let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n+            self.add_outlives_bounds(Some(infcx), implied_bounds)\n+        }\n+    }\n+}"}, {"sha": "739aff4fb94c9445ac216b40cee02cf818fabbba", "filename": "src/librustc_trait_selection/lib.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Flib.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -0,0 +1,32 @@\n+//! This crates defines the trait resolution method.\n+//!\n+//! - **Traits.** Trait resolution is implemented in the `traits` module.\n+//!\n+//! For more information about how rustc works, see the [rustc guide].\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![feature(bool_to_option)]\n+#![feature(drain_filter)]\n+#![feature(in_band_lifetimes)]\n+#![feature(crate_visibility_modifier)]\n+#![recursion_limit = \"512\"] // For rustdoc\n+\n+#[macro_use]\n+extern crate rustc_macros;\n+#[cfg(target_arch = \"x86_64\")]\n+#[macro_use]\n+extern crate rustc_data_structures;\n+#[macro_use]\n+extern crate log;\n+#[macro_use]\n+extern crate rustc;\n+\n+pub mod infer;\n+pub mod opaque_types;\n+pub mod traits;"}, {"sha": "6cf1302783c0b9cf313987ba7d77a1fb3e1f2785", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "renamed", "additions": 60, "deletions": 89, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,18 +1,18 @@\n-use crate::infer::error_reporting::{note_and_explain_free_region, note_and_explain_region};\n-use crate::infer::{self, InferCtxt, InferOk, TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, PredicateObligation};\n-use rustc::middle::region;\n use rustc::session::config::nightly_options;\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::free_region_map::FreeRegionRelations;\n use rustc::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc::ty::{self, GenericParamDefKind, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdMap};\n use rustc_hir::Node;\n+use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::{self, InferCtxt, InferOk};\n use rustc_span::Span;\n \n pub type OpaqueTypeMap<'tcx> = DefIdMap<OpaqueTypeDecl<'tcx>>;\n@@ -105,7 +105,58 @@ pub enum GenerateMemberConstraints {\n     IfNoStaticBound,\n }\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+pub trait InferCtxtExt<'tcx> {\n+    fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n+        &self,\n+        parent_def_id: DefId,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        value: &T,\n+        value_span: Span,\n+    ) -> InferOk<'tcx, (T, OpaqueTypeMap<'tcx>)>;\n+\n+    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n+        &self,\n+        opaque_types: &OpaqueTypeMap<'tcx>,\n+        free_region_relations: &FRR,\n+    );\n+\n+    fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n+        &self,\n+        def_id: DefId,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        mode: GenerateMemberConstraints,\n+        free_region_relations: &FRR,\n+    );\n+\n+    /*private*/\n+    fn generate_member_constraint(\n+        &self,\n+        concrete_ty: Ty<'tcx>,\n+        opaque_type_generics: &ty::Generics,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        opaque_type_def_id: DefId,\n+    );\n+\n+    /*private*/\n+    fn member_constraint_feature_gate(\n+        &self,\n+        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        opaque_type_def_id: DefId,\n+        conflict1: ty::Region<'tcx>,\n+        conflict2: ty::Region<'tcx>,\n+    ) -> bool;\n+\n+    fn infer_opaque_definition_from_instantiation(\n+        &self,\n+        def_id: DefId,\n+        substs: SubstsRef<'tcx>,\n+        instantiated_ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Ty<'tcx>;\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     /// Replaces all opaque types in `value` with fresh inference variables\n     /// and creates appropriate obligations. For example, given the input:\n     ///\n@@ -131,7 +182,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ///   obligations\n     /// - `value` -- the value within which we are instantiating opaque types\n     /// - `value_span` -- the span where the value came from, used in error reporting\n-    pub fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n+    fn instantiate_opaque_types<T: TypeFoldable<'tcx>>(\n         &self,\n         parent_def_id: DefId,\n         body_id: hir::HirId,\n@@ -319,7 +370,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// - `opaque_types` -- the map produced by `instantiate_opaque_types`\n     /// - `free_region_relations` -- something that can be used to relate\n     ///   the free regions (`'a`) that appear in the impl trait.\n-    pub fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n+    fn constrain_opaque_types<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n         opaque_types: &OpaqueTypeMap<'tcx>,\n         free_region_relations: &FRR,\n@@ -337,7 +388,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     /// See `constrain_opaque_types` for documentation.\n-    pub fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n+    fn constrain_opaque_type<FRR: FreeRegionRelations<'tcx>>(\n         &self,\n         def_id: DefId,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n@@ -579,7 +630,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// - `substs`, the substs  used to instantiate this opaque type\n     /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n     ///   `opaque_defn.concrete_ty`\n-    pub fn infer_opaque_definition_from_instantiation(\n+    fn infer_opaque_definition_from_instantiation(\n         &self,\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n@@ -618,86 +669,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn unexpected_hidden_region_diagnostic(\n-    tcx: TyCtxt<'tcx>,\n-    region_scope_tree: Option<&region::ScopeTree>,\n-    span: Span,\n-    hidden_ty: Ty<'tcx>,\n-    hidden_region: ty::Region<'tcx>,\n-) -> DiagnosticBuilder<'tcx> {\n-    let mut err = struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0700,\n-        \"hidden type for `impl Trait` captures lifetime that does not appear in bounds\",\n-    );\n-\n-    // Explain the region we are capturing.\n-    if let ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReStatic | ty::ReEmpty(_) = hidden_region {\n-        // Assuming regionck succeeded (*), we ought to always be\n-        // capturing *some* region from the fn header, and hence it\n-        // ought to be free. So under normal circumstances, we will go\n-        // down this path which gives a decent human readable\n-        // explanation.\n-        //\n-        // (*) if not, the `tainted_by_errors` flag would be set to\n-        // true in any case, so we wouldn't be here at all.\n-        note_and_explain_free_region(\n-            tcx,\n-            &mut err,\n-            &format!(\"hidden type `{}` captures \", hidden_ty),\n-            hidden_region,\n-            \"\",\n-        );\n-    } else {\n-        // Ugh. This is a painful case: the hidden region is not one\n-        // that we can easily summarize or explain. This can happen\n-        // in a case like\n-        // `src/test/ui/multiple-lifetimes/ordinary-bounds-unsuited.rs`:\n-        //\n-        // ```\n-        // fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> {\n-        //   if condition() { a } else { b }\n-        // }\n-        // ```\n-        //\n-        // Here the captured lifetime is the intersection of `'a` and\n-        // `'b`, which we can't quite express.\n-\n-        if let Some(region_scope_tree) = region_scope_tree {\n-            // If the `region_scope_tree` is available, this is being\n-            // invoked from the \"region inferencer error\". We can at\n-            // least report a really cryptic error for now.\n-            note_and_explain_region(\n-                tcx,\n-                region_scope_tree,\n-                &mut err,\n-                &format!(\"hidden type `{}` captures \", hidden_ty),\n-                hidden_region,\n-                \"\",\n-            );\n-        } else {\n-            // If the `region_scope_tree` is *unavailable*, this is\n-            // being invoked by the code that comes *after* region\n-            // inferencing. This is a bug, as the region inferencer\n-            // ought to have noticed the failed constraint and invoked\n-            // error reporting, which in turn should have prevented us\n-            // from getting trying to infer the hidden type\n-            // completely.\n-            tcx.sess.delay_span_bug(\n-                span,\n-                &format!(\n-                    \"hidden type captures unexpected lifetime `{:?}` \\\n-                     but no region inference failure\",\n-                    hidden_region,\n-                ),\n-            );\n-        }\n-    }\n-\n-    err\n-}\n-\n // Visitor that requires that (almost) all regions in the type visited outlive\n // `least_region`. We cannot use `push_outlives_components` because regions in\n // closure signatures are not included in their outlives components. We need to", "previous_filename": "src/librustc_infer/infer/opaque_types/mod.rs"}, {"sha": "d221d6886e9fbd6edf8f21d50590fef73f78091a", "filename": "src/librustc_trait_selection/traits/auto_trait.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fauto_trait.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/auto_trait.rs"}, {"sha": "5c2fc3f305c1f9e2f276bfe2ac49ca4495a99fde", "filename": "src/librustc_trait_selection/traits/codegen/mod.rs", "status": "renamed", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcodegen%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -72,7 +72,7 @@ pub fn codegen_fulfill_obligation<'tcx>(\n             debug!(\"fulfill_obligation: register_predicate_obligation {:?}\", predicate);\n             fulfill_cx.register_predicate_obligation(&infcx, predicate);\n         });\n-        let vtable = infcx.drain_fulfillment_cx_or_panic(&mut fulfill_cx, &vtable);\n+        let vtable = drain_fulfillment_cx_or_panic(&infcx, &mut fulfill_cx, &vtable);\n \n         info!(\"Cache miss: {:?} => {:?}\", trait_ref, vtable);\n         Some(vtable)\n@@ -81,34 +81,32 @@ pub fn codegen_fulfill_obligation<'tcx>(\n \n // # Global Cache\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    /// Finishes processes any obligations that remain in the\n-    /// fulfillment context, and then returns the result with all type\n-    /// variables removed and regions erased. Because this is intended\n-    /// for use after type-check has completed, if any errors occur,\n-    /// it will panic. It is used during normalization and other cases\n-    /// where processing the obligations in `fulfill_cx` may cause\n-    /// type inference variables that appear in `result` to be\n-    /// unified, and hence we need to process those obligations to get\n-    /// the complete picture of the type.\n-    fn drain_fulfillment_cx_or_panic<T>(\n-        &self,\n-        fulfill_cx: &mut FulfillmentContext<'tcx>,\n-        result: &T,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\"drain_fulfillment_cx_or_panic()\");\n+/// Finishes processes any obligations that remain in the\n+/// fulfillment context, and then returns the result with all type\n+/// variables removed and regions erased. Because this is intended\n+/// for use after type-check has completed, if any errors occur,\n+/// it will panic. It is used during normalization and other cases\n+/// where processing the obligations in `fulfill_cx` may cause\n+/// type inference variables that appear in `result` to be\n+/// unified, and hence we need to process those obligations to get\n+/// the complete picture of the type.\n+fn drain_fulfillment_cx_or_panic<T>(\n+    infcx: &InferCtxt<'_, 'tcx>,\n+    fulfill_cx: &mut FulfillmentContext<'tcx>,\n+    result: &T,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    debug!(\"drain_fulfillment_cx_or_panic()\");\n \n-        // In principle, we only need to do this so long as `result`\n-        // contains unbound type parameters. It could be a slight\n-        // optimization to stop iterating early.\n-        if let Err(errors) = fulfill_cx.select_all_or_error(self) {\n-            bug!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors);\n-        }\n-\n-        let result = self.resolve_vars_if_possible(result);\n-        self.tcx.erase_regions(&result)\n+    // In principle, we only need to do this so long as `result`\n+    // contains unbound type parameters. It could be a slight\n+    // optimization to stop iterating early.\n+    if let Err(errors) = fulfill_cx.select_all_or_error(infcx) {\n+        bug!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors);\n     }\n+\n+    let result = infcx.resolve_vars_if_possible(result);\n+    infcx.tcx.erase_regions(&result)\n }", "previous_filename": "src/librustc_infer/traits/codegen/mod.rs"}, {"sha": "5f542e7e13be5affad47c7deb52169371017ff53", "filename": "src/librustc_trait_selection/traits/coherence.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fcoherence.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/coherence.rs"}, {"sha": "ee4715e0c20f6b54ebda56f7414cd0f58375389b", "filename": "src/librustc_trait_selection/traits/engine.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fengine.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -0,0 +1,14 @@\n+use rustc::ty::TyCtxt;\n+\n+use super::FulfillmentContext;\n+use super::TraitEngine;\n+\n+pub trait TraitEngineExt<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Box<Self>;\n+}\n+\n+impl<'tcx> TraitEngineExt<'tcx> for dyn TraitEngine<'tcx> {\n+    fn new(_tcx: TyCtxt<'tcx>) -> Box<Self> {\n+        Box::new(FulfillmentContext::new())\n+    }\n+}"}, {"sha": "abd9638bfa78b2e4585afe5e8b15af1a8e381ed3", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "added", "additions": 1900, "deletions": 0, "changes": 1900, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -0,0 +1,1900 @@\n+pub mod on_unimplemented;\n+pub mod suggestions;\n+\n+use super::{\n+    ConstEvalFailure, EvaluationResult, FulfillmentError, FulfillmentErrorCode,\n+    MismatchedProjectionTypes, Obligation, ObligationCause, ObligationCauseCode,\n+    OnUnimplementedDirective, OnUnimplementedNote, OutputTypeParameterMismatch, Overflow,\n+    PredicateObligation, SelectionContext, SelectionError, TraitNotObjectSafe,\n+};\n+\n+use crate::infer::error_reporting::{TyCategory, TypeAnnotationNeeded as ErrorCode};\n+use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::{self, InferCtxt, TyCtxtInferExt};\n+use rustc::mir::interpret::ErrorHandled;\n+use rustc::session::DiagnosticMessageId;\n+use rustc::ty::error::ExpectedFound;\n+use rustc::ty::fast_reject;\n+use rustc::ty::fold::TypeFolder;\n+use rustc::ty::SubtypePredicate;\n+use rustc::ty::{\n+    self, AdtKind, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness,\n+};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::{Node, QPath, TyKind, WhereBoundPredicate, WherePredicate};\n+use rustc_span::source_map::SourceMap;\n+use rustc_span::{ExpnKind, Span, DUMMY_SP};\n+use std::fmt;\n+\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n+use crate::traits::query::normalize::AtExt as _;\n+use on_unimplemented::InferCtxtExt as _;\n+use suggestions::InferCtxtExt as _;\n+\n+pub use rustc_infer::traits::error_reporting::*;\n+\n+pub trait InferCtxtExt<'tcx> {\n+    fn report_fulfillment_errors(\n+        &self,\n+        errors: &[FulfillmentError<'tcx>],\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    );\n+\n+    fn report_overflow_error<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n+    where\n+        T: fmt::Display + TypeFoldable<'tcx>;\n+\n+    fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> !;\n+\n+    fn report_selection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &SelectionError<'tcx>,\n+        fallback_has_occurred: bool,\n+        points_at_arg: bool,\n+    );\n+\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>);\n+\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n+    ) -> DiagnosticBuilder<'tcx>;\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+    fn report_fulfillment_errors(\n+        &self,\n+        errors: &[FulfillmentError<'tcx>],\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        #[derive(Debug)]\n+        struct ErrorDescriptor<'tcx> {\n+            predicate: ty::Predicate<'tcx>,\n+            index: Option<usize>, // None if this is an old error\n+        }\n+\n+        let mut error_map: FxHashMap<_, Vec<_>> = self\n+            .reported_trait_errors\n+            .borrow()\n+            .iter()\n+            .map(|(&span, predicates)| {\n+                (\n+                    span,\n+                    predicates\n+                        .iter()\n+                        .map(|&predicate| ErrorDescriptor { predicate, index: None })\n+                        .collect(),\n+                )\n+            })\n+            .collect();\n+\n+        for (index, error) in errors.iter().enumerate() {\n+            // We want to ignore desugarings here: spans are equivalent even\n+            // if one is the result of a desugaring and the other is not.\n+            let mut span = error.obligation.cause.span;\n+            let expn_data = span.ctxt().outer_expn_data();\n+            if let ExpnKind::Desugaring(_) = expn_data.kind {\n+                span = expn_data.call_site;\n+            }\n+\n+            error_map.entry(span).or_default().push(ErrorDescriptor {\n+                predicate: error.obligation.predicate,\n+                index: Some(index),\n+            });\n+\n+            self.reported_trait_errors\n+                .borrow_mut()\n+                .entry(span)\n+                .or_default()\n+                .push(error.obligation.predicate.clone());\n+        }\n+\n+        // We do this in 2 passes because we want to display errors in order, though\n+        // maybe it *is* better to sort errors by span or something.\n+        let mut is_suppressed = vec![false; errors.len()];\n+        for (_, error_set) in error_map.iter() {\n+            // We want to suppress \"duplicate\" errors with the same span.\n+            for error in error_set {\n+                if let Some(index) = error.index {\n+                    // Suppress errors that are either:\n+                    // 1) strictly implied by another error.\n+                    // 2) implied by an error with a smaller index.\n+                    for error2 in error_set {\n+                        if error2.index.map_or(false, |index2| is_suppressed[index2]) {\n+                            // Avoid errors being suppressed by already-suppressed\n+                            // errors, to prevent all errors from being suppressed\n+                            // at once.\n+                            continue;\n+                        }\n+\n+                        if self.error_implies(&error2.predicate, &error.predicate)\n+                            && !(error2.index >= error.index\n+                                && self.error_implies(&error.predicate, &error2.predicate))\n+                        {\n+                            info!(\"skipping {:?} (implied by {:?})\", error, error2);\n+                            is_suppressed[index] = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (error, suppressed) in errors.iter().zip(is_suppressed) {\n+            if !suppressed {\n+                self.report_fulfillment_error(error, body_id, fallback_has_occurred);\n+            }\n+        }\n+    }\n+\n+    /// Reports that an overflow has occurred and halts compilation. We\n+    /// halt compilation unconditionally because it is important that\n+    /// overflows never be masked -- they basically represent computations\n+    /// whose result could not be truly determined and thus we can't say\n+    /// if the program type checks or not -- and they are unusual\n+    /// occurrences in any case.\n+    fn report_overflow_error<T>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        suggest_increasing_limit: bool,\n+    ) -> !\n+    where\n+        T: fmt::Display + TypeFoldable<'tcx>,\n+    {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            obligation.cause.span,\n+            E0275,\n+            \"overflow evaluating the requirement `{}`\",\n+            predicate\n+        );\n+\n+        if suggest_increasing_limit {\n+            self.suggest_new_overflow_limit(&mut err);\n+        }\n+\n+        self.note_obligation_cause_code(\n+            &mut err,\n+            &obligation.predicate,\n+            &obligation.cause.code,\n+            &mut vec![],\n+        );\n+\n+        err.emit();\n+        self.tcx.sess.abort_if_errors();\n+        bug!();\n+    }\n+\n+    /// Reports that a cycle was detected which led to overflow and halts\n+    /// compilation. This is equivalent to `report_overflow_error` except\n+    /// that we can give a more helpful error message (and, in particular,\n+    /// we do not suggest increasing the overflow limit, which is not\n+    /// going to help).\n+    fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n+        let cycle = self.resolve_vars_if_possible(&cycle.to_owned());\n+        assert!(!cycle.is_empty());\n+\n+        debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n+\n+        self.report_overflow_error(&cycle[0], false);\n+    }\n+\n+    fn report_selection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &SelectionError<'tcx>,\n+        fallback_has_occurred: bool,\n+        points_at_arg: bool,\n+    ) {\n+        let tcx = self.tcx;\n+        let span = obligation.cause.span;\n+\n+        let mut err = match *error {\n+            SelectionError::Unimplemented => {\n+                if let ObligationCauseCode::CompareImplMethodObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                }\n+                | ObligationCauseCode::CompareImplTypeObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                } = obligation.cause.code\n+                {\n+                    self.report_extra_impl_obligation(\n+                        span,\n+                        item_name,\n+                        impl_item_def_id,\n+                        trait_item_def_id,\n+                        &format!(\"`{}`\", obligation.predicate),\n+                    )\n+                    .emit();\n+                    return;\n+                }\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate, _) => {\n+                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+\n+                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n+                            return;\n+                        }\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n+                        let (post_message, pre_message, type_def) = self\n+                            .get_parent_trait_ref(&obligation.cause.code)\n+                            .map(|(t, s)| {\n+                                (\n+                                    format!(\" in `{}`\", t),\n+                                    format!(\"within `{}`, \", t),\n+                                    s.map(|s| (format!(\"within this `{}`\", t), s)),\n+                                )\n+                            })\n+                            .unwrap_or_default();\n+\n+                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n+                            self.on_unimplemented_note(trait_ref, obligation);\n+                        let have_alt_message = message.is_some() || label.is_some();\n+                        let is_try = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_to_snippet(span)\n+                            .map(|s| &s == \"?\")\n+                            .unwrap_or(false);\n+                        let is_from = format!(\"{}\", trait_ref.print_only_trait_path())\n+                            .starts_with(\"std::convert::From<\");\n+                        let (message, note) = if is_try && is_from {\n+                            (\n+                                Some(format!(\n+                                    \"`?` couldn't convert the error to `{}`\",\n+                                    trait_ref.self_ty(),\n+                                )),\n+                                Some(\n+                                    \"the question mark operation (`?`) implicitly performs a \\\n+                                     conversion on the error value using the `From` trait\"\n+                                        .to_owned(),\n+                                ),\n+                            )\n+                        } else {\n+                            (message, note)\n+                        };\n+\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0277,\n+                            \"{}\",\n+                            message.unwrap_or_else(|| format!(\n+                                \"the trait bound `{}` is not satisfied{}\",\n+                                trait_ref.without_const().to_predicate(),\n+                                post_message,\n+                            ))\n+                        );\n+\n+                        let explanation =\n+                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n+                                \"consider using `()`, or a `Result`\".to_owned()\n+                            } else {\n+                                format!(\n+                                    \"{}the trait `{}` is not implemented for `{}`\",\n+                                    pre_message,\n+                                    trait_ref.print_only_trait_path(),\n+                                    trait_ref.self_ty(),\n+                                )\n+                            };\n+\n+                        if self.suggest_add_reference_to_arg(\n+                            &obligation,\n+                            &mut err,\n+                            &trait_ref,\n+                            points_at_arg,\n+                            have_alt_message,\n+                        ) {\n+                            self.note_obligation_cause(&mut err, obligation);\n+                            err.emit();\n+                            return;\n+                        }\n+                        if let Some(ref s) = label {\n+                            // If it has a custom `#[rustc_on_unimplemented]`\n+                            // error message, let's display it as the label!\n+                            err.span_label(span, s.as_str());\n+                            err.help(&explanation);\n+                        } else {\n+                            err.span_label(span, explanation);\n+                        }\n+                        if let Some((msg, span)) = type_def {\n+                            err.span_label(span, &msg);\n+                        }\n+                        if let Some(ref s) = note {\n+                            // If it has a custom `#[rustc_on_unimplemented]` note, let's display it\n+                            err.note(s.as_str());\n+                        }\n+                        if let Some(ref s) = enclosing_scope {\n+                            let enclosing_scope_span = tcx.def_span(\n+                                tcx.hir()\n+                                    .opt_local_def_id(obligation.cause.body_id)\n+                                    .unwrap_or_else(|| {\n+                                        tcx.hir().body_owner_def_id(hir::BodyId {\n+                                            hir_id: obligation.cause.body_id,\n+                                        })\n+                                    }),\n+                            );\n+\n+                            err.span_label(enclosing_scope_span, s.as_str());\n+                        }\n+\n+                        self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n+                        self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n+                        self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n+                        self.note_version_mismatch(&mut err, &trait_ref);\n+                        if self.suggest_impl_trait(&mut err, span, &obligation, &trait_ref) {\n+                            err.emit();\n+                            return;\n+                        }\n+\n+                        // Try to report a help message\n+                        if !trait_ref.has_infer_types_or_consts()\n+                            && self.predicate_can_apply(obligation.param_env, trait_ref)\n+                        {\n+                            // If a where-clause may be useful, remind the\n+                            // user that they can add it.\n+                            //\n+                            // don't display an on-unimplemented note, as\n+                            // these notes will often be of the form\n+                            //     \"the type `T` can't be frobnicated\"\n+                            // which is somewhat confusing.\n+                            self.suggest_restricting_param_bound(\n+                                &mut err,\n+                                &trait_ref,\n+                                obligation.cause.body_id,\n+                            );\n+                        } else {\n+                            if !have_alt_message {\n+                                // Can't show anything else useful, try to find similar impls.\n+                                let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                                self.report_similar_impl_candidates(impl_candidates, &mut err);\n+                            }\n+                            self.suggest_change_mut(\n+                                &obligation,\n+                                &mut err,\n+                                &trait_ref,\n+                                points_at_arg,\n+                            );\n+                        }\n+\n+                        // If this error is due to `!: Trait` not implemented but `(): Trait` is\n+                        // implemented, and fallback has occurred, then it could be due to a\n+                        // variable that used to fallback to `()` now falling back to `!`. Issue a\n+                        // note informing about the change in behaviour.\n+                        if trait_predicate.skip_binder().self_ty().is_never()\n+                            && fallback_has_occurred\n+                        {\n+                            let predicate = trait_predicate.map_bound(|mut trait_pred| {\n+                                trait_pred.trait_ref.substs = self.tcx.mk_substs_trait(\n+                                    self.tcx.mk_unit(),\n+                                    &trait_pred.trait_ref.substs[1..],\n+                                );\n+                                trait_pred\n+                            });\n+                            let unit_obligation = Obligation {\n+                                predicate: ty::Predicate::Trait(\n+                                    predicate,\n+                                    hir::Constness::NotConst,\n+                                ),\n+                                ..obligation.clone()\n+                            };\n+                            if self.predicate_may_hold(&unit_obligation) {\n+                                err.note(\n+                                    \"the trait is implemented for `()`. \\\n+                                     Possibly this error has been caused by changes to \\\n+                                     Rust's type-inference algorithm (see issue #48950 \\\n+                                     <https://github.com/rust-lang/rust/issues/48950> \\\n+                                     for more information). Consider whether you meant to use \\\n+                                     the type `()` here instead.\",\n+                                );\n+                            }\n+                        }\n+\n+                        err\n+                    }\n+\n+                    ty::Predicate::Subtype(ref predicate) => {\n+                        // Errors for Subtype predicates show up as\n+                        // `FulfillmentErrorCode::CodeSubtypeError`,\n+                        // not selection error.\n+                        span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = self.resolve_vars_if_possible(predicate);\n+                        let err = self\n+                            .region_outlives_predicate(&obligation.cause, &predicate)\n+                            .err()\n+                            .unwrap();\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate,\n+                            err,\n+                        )\n+                    }\n+\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+                        struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate\n+                        )\n+                    }\n+\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        let violations = self.tcx.object_safety_violations(trait_def_id);\n+                        report_object_safety_error(self.tcx, span, trait_def_id, violations)\n+                    }\n+\n+                    ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                        let found_kind = self.closure_kind(closure_def_id, closure_substs).unwrap();\n+                        let closure_span = self\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .def_span(self.tcx.hir().span_if_local(closure_def_id).unwrap());\n+                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id).unwrap();\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            closure_span,\n+                            E0525,\n+                            \"expected a closure that implements the `{}` trait, \\\n+                             but this closure only implements `{}`\",\n+                            kind,\n+                            found_kind\n+                        );\n+\n+                        err.span_label(\n+                            closure_span,\n+                            format!(\"this closure implements `{}`, not `{}`\", found_kind, kind),\n+                        );\n+                        err.span_label(\n+                            obligation.cause.span,\n+                            format!(\"the requirement to implement `{}` derives from here\", kind),\n+                        );\n+\n+                        // Additional context information explaining why the closure only implements\n+                        // a particular trait.\n+                        if let Some(tables) = self.in_progress_tables {\n+                            let tables = tables.borrow();\n+                            match (found_kind, tables.closure_kind_origins().get(hir_id)) {\n+                                (ty::ClosureKind::FnOnce, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnOnce` because it moves the \\\n+                                         variable `{}` out of its environment\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                (ty::ClosureKind::FnMut, Some((span, name))) => {\n+                                    err.span_label(\n+                                        *span,\n+                                        format!(\n+                                            \"closure is `FnMut` because it mutates the \\\n+                                         variable `{}` here\",\n+                                            name\n+                                        ),\n+                                    );\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+\n+                        err.emit();\n+                        return;\n+                    }\n+\n+                    ty::Predicate::WellFormed(ty) => {\n+                        // WF predicates cannot themselves make\n+                        // errors. They can only block due to\n+                        // ambiguity; otherwise, they always\n+                        // degenerate into other obligations\n+                        // (which may fail).\n+                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                    }\n+\n+                    ty::Predicate::ConstEvaluatable(..) => {\n+                        // Errors for `ConstEvaluatable` predicates show up as\n+                        // `SelectionError::ConstEvalFailure`,\n+                        // not `Unimplemented`.\n+                        span_bug!(\n+                            span,\n+                            \"const-evaluatable requirement gave wrong error: `{:?}`\",\n+                            obligation\n+                        )\n+                    }\n+                }\n+            }\n+\n+            OutputTypeParameterMismatch(ref found_trait_ref, ref expected_trait_ref, _) => {\n+                let found_trait_ref = self.resolve_vars_if_possible(&*found_trait_ref);\n+                let expected_trait_ref = self.resolve_vars_if_possible(&*expected_trait_ref);\n+\n+                if expected_trait_ref.self_ty().references_error() {\n+                    return;\n+                }\n+\n+                let found_trait_ty = found_trait_ref.self_ty();\n+\n+                let found_did = match found_trait_ty.kind {\n+                    ty::Closure(did, _) | ty::Foreign(did) | ty::FnDef(did, _) => Some(did),\n+                    ty::Adt(def, _) => Some(def.did),\n+                    _ => None,\n+                };\n+\n+                let found_span = found_did\n+                    .and_then(|did| self.tcx.hir().span_if_local(did))\n+                    .map(|sp| self.tcx.sess.source_map().def_span(sp)); // the sp could be an fn def\n+\n+                if self.reported_closure_mismatch.borrow().contains(&(span, found_span)) {\n+                    // We check closures twice, with obligations flowing in different directions,\n+                    // but we want to complain about them only once.\n+                    return;\n+                }\n+\n+                self.reported_closure_mismatch.borrow_mut().insert((span, found_span));\n+\n+                let found = match found_trait_ref.skip_binder().substs.type_at(1).kind {\n+                    ty::Tuple(ref tys) => vec![ArgKind::empty(); tys.len()],\n+                    _ => vec![ArgKind::empty()],\n+                };\n+\n+                let expected_ty = expected_trait_ref.skip_binder().substs.type_at(1);\n+                let expected = match expected_ty.kind {\n+                    ty::Tuple(ref tys) => tys\n+                        .iter()\n+                        .map(|t| ArgKind::from_expected_ty(t.expect_ty(), Some(span)))\n+                        .collect(),\n+                    _ => vec![ArgKind::Arg(\"_\".to_owned(), expected_ty.to_string())],\n+                };\n+\n+                if found.len() == expected.len() {\n+                    self.report_closure_arg_mismatch(\n+                        span,\n+                        found_span,\n+                        found_trait_ref,\n+                        expected_trait_ref,\n+                    )\n+                } else {\n+                    let (closure_span, found) = found_did\n+                        .and_then(|did| self.tcx.hir().get_if_local(did))\n+                        .map(|node| {\n+                            let (found_span, found) = self.get_fn_like_arguments(node);\n+                            (Some(found_span), found)\n+                        })\n+                        .unwrap_or((found_span, found));\n+\n+                    self.report_arg_count_mismatch(\n+                        span,\n+                        closure_span,\n+                        expected,\n+                        found,\n+                        found_trait_ty.is_closure(),\n+                    )\n+                }\n+            }\n+\n+            TraitNotObjectSafe(did) => {\n+                let violations = self.tcx.object_safety_violations(did);\n+                report_object_safety_error(self.tcx, span, did, violations)\n+            }\n+\n+            ConstEvalFailure(ErrorHandled::TooGeneric) => {\n+                // In this instance, we have a const expression containing an unevaluated\n+                // generic parameter. We have no idea whether this expression is valid or\n+                // not (e.g. it might result in an error), but we don't want to just assume\n+                // that it's okay, because that might result in post-monomorphisation time\n+                // errors. The onus is really on the caller to provide values that it can\n+                // prove are well-formed.\n+                let mut err = self\n+                    .tcx\n+                    .sess\n+                    .struct_span_err(span, \"constant expression depends on a generic parameter\");\n+                // FIXME(const_generics): we should suggest to the user how they can resolve this\n+                // issue. However, this is currently not actually possible\n+                // (see https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083).\n+                err.note(\"this may fail depending on what value the parameter takes\");\n+                err\n+            }\n+\n+            // Already reported in the query.\n+            ConstEvalFailure(ErrorHandled::Reported) => {\n+                self.tcx.sess.delay_span_bug(span, \"constant in type had an ignored error\");\n+                return;\n+            }\n+\n+            Overflow => {\n+                bug!(\"overflow should be handled before the `report_selection_error` path\");\n+            }\n+        };\n+\n+        self.note_obligation_cause(&mut err, obligation);\n+        self.point_at_returns_when_relevant(&mut err, &obligation);\n+\n+        err.emit();\n+    }\n+\n+    /// Given some node representing a fn-like thing in the HIR map,\n+    /// returns a span and `ArgKind` information that describes the\n+    /// arguments it expects. This can be supplied to\n+    /// `report_arg_count_mismatch`.\n+    fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n+        match node {\n+            Node::Expr(&hir::Expr {\n+                kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n+                ..\n+            }) => (\n+                self.tcx.sess.source_map().def_span(span),\n+                self.tcx\n+                    .hir()\n+                    .body(id)\n+                    .params\n+                    .iter()\n+                    .map(|arg| {\n+                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n+                            *arg.pat\n+                        {\n+                            ArgKind::Tuple(\n+                                Some(span),\n+                                args.iter()\n+                                    .map(|pat| {\n+                                        let snippet = self\n+                                            .tcx\n+                                            .sess\n+                                            .source_map()\n+                                            .span_to_snippet(pat.span)\n+                                            .unwrap();\n+                                        (snippet, \"_\".to_owned())\n+                                    })\n+                                    .collect::<Vec<_>>(),\n+                            )\n+                        } else {\n+                            let name =\n+                                self.tcx.sess.source_map().span_to_snippet(arg.pat.span).unwrap();\n+                            ArgKind::Arg(name, \"_\".to_owned())\n+                        }\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n+            | Node::ImplItem(&hir::ImplItem {\n+                span,\n+                kind: hir::ImplItemKind::Method(ref sig, _),\n+                ..\n+            })\n+            | Node::TraitItem(&hir::TraitItem {\n+                span,\n+                kind: hir::TraitItemKind::Fn(ref sig, _),\n+                ..\n+            }) => (\n+                self.tcx.sess.source_map().def_span(span),\n+                sig.decl\n+                    .inputs\n+                    .iter()\n+                    .map(|arg| match arg.clone().kind {\n+                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n+                            Some(arg.span),\n+                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n+                        ),\n+                        _ => ArgKind::empty(),\n+                    })\n+                    .collect::<Vec<ArgKind>>(),\n+            ),\n+            Node::Ctor(ref variant_data) => {\n+                let span = variant_data\n+                    .ctor_hir_id()\n+                    .map(|hir_id| self.tcx.hir().span(hir_id))\n+                    .unwrap_or(DUMMY_SP);\n+                let span = self.tcx.sess.source_map().def_span(span);\n+\n+                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n+            }\n+            _ => panic!(\"non-FnLike node found: {:?}\", node),\n+        }\n+    }\n+\n+    /// Reports an error when the number of arguments needed by a\n+    /// trait match doesn't match the number that the expression\n+    /// provides.\n+    fn report_arg_count_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_args: Vec<ArgKind>,\n+        found_args: Vec<ArgKind>,\n+        is_closure: bool,\n+    ) -> DiagnosticBuilder<'tcx> {\n+        let kind = if is_closure { \"closure\" } else { \"function\" };\n+\n+        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n+            let arg_length = arguments.len();\n+            let distinct = match &other[..] {\n+                &[ArgKind::Tuple(..)] => true,\n+                _ => false,\n+            };\n+            match (arg_length, arguments.get(0)) {\n+                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n+                    format!(\"a single {}-tuple as argument\", fields.len())\n+                }\n+                _ => format!(\n+                    \"{} {}argument{}\",\n+                    arg_length,\n+                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n+                    pluralize!(arg_length)\n+                ),\n+            }\n+        };\n+\n+        let expected_str = args_str(&expected_args, &found_args);\n+        let found_str = args_str(&found_args, &expected_args);\n+\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            span,\n+            E0593,\n+            \"{} is expected to take {}, but it takes {}\",\n+            kind,\n+            expected_str,\n+            found_str,\n+        );\n+\n+        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n+\n+        if let Some(found_span) = found_span {\n+            err.span_label(found_span, format!(\"takes {}\", found_str));\n+\n+            // move |_| { ... }\n+            // ^^^^^^^^-- def_span\n+            //\n+            // move |_| { ... }\n+            // ^^^^^-- prefix\n+            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n+            // move |_| { ... }\n+            //      ^^^-- pipe_span\n+            let pipe_span =\n+                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n+\n+            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n+            // found arguments is empty (assume the user just wants to ignore args in this case).\n+            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n+            if found_args.is_empty() && is_closure {\n+                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n+                err.span_suggestion(\n+                    pipe_span,\n+                    &format!(\n+                        \"consider changing the closure to take and ignore the expected argument{}\",\n+                        if expected_args.len() < 2 { \"\" } else { \"s\" }\n+                    ),\n+                    format!(\"|{}|\", underscores),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+\n+            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n+                if fields.len() == expected_args.len() {\n+                    let sugg = fields\n+                        .iter()\n+                        .map(|(name, _)| name.to_owned())\n+                        .collect::<Vec<String>>()\n+                        .join(\", \");\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to take multiple arguments instead of a single tuple\",\n+                        format!(\"|{}|\", sugg),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n+                if fields.len() == found_args.len() && is_closure {\n+                    let sugg = format!(\n+                        \"|({}){}|\",\n+                        found_args\n+                            .iter()\n+                            .map(|arg| match arg {\n+                                ArgKind::Arg(name, _) => name.to_owned(),\n+                                _ => \"_\".to_owned(),\n+                            })\n+                            .collect::<Vec<String>>()\n+                            .join(\", \"),\n+                        // add type annotations if available\n+                        if found_args.iter().any(|arg| match arg {\n+                            ArgKind::Arg(_, ty) => ty != \"_\",\n+                            _ => false,\n+                        }) {\n+                            format!(\n+                                \": ({})\",\n+                                fields\n+                                    .iter()\n+                                    .map(|(_, ty)| ty.to_owned())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \")\n+                            )\n+                        } else {\n+                            String::new()\n+                        },\n+                    );\n+                    err.span_suggestion(\n+                        found_span,\n+                        \"change the closure to accept a tuple instead of individual arguments\",\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+\n+        err\n+    }\n+}\n+\n+trait InferCtxtPrivExt<'tcx> {\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n+    // `error` occurring implies that `cond` occurs.\n+    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool;\n+\n+    fn report_fulfillment_error(\n+        &self,\n+        error: &FulfillmentError<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    );\n+\n+    fn report_projection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &MismatchedProjectionTypes<'tcx>,\n+    );\n+\n+    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool;\n+\n+    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str>;\n+\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>>;\n+\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    );\n+\n+    /// Gets the parent trait chain start\n+    fn get_parent_trait_ref(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+    ) -> Option<(String, Option<Span>)>;\n+\n+    /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n+    /// with the same path as `trait_ref`, a help message about\n+    /// a probable version mismatch is added to `err`\n+    fn note_version_mismatch(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    );\n+\n+    fn mk_obligation_for_def_id(\n+        &self,\n+        def_id: DefId,\n+        output_ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> PredicateObligation<'tcx>;\n+\n+    fn maybe_report_ambiguity(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+    );\n+\n+    fn predicate_can_apply(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        pred: ty::PolyTraitRef<'tcx>,\n+    ) -> bool;\n+\n+    fn note_obligation_cause(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    );\n+\n+    fn suggest_unsized_bound_if_applicable(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    );\n+\n+    fn is_recursive_obligation(\n+        &self,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+    ) -> bool;\n+}\n+\n+impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n+    // `error` occurring implies that `cond` occurs.\n+    fn error_implies(&self, cond: &ty::Predicate<'tcx>, error: &ty::Predicate<'tcx>) -> bool {\n+        if cond == error {\n+            return true;\n+        }\n+\n+        let (cond, error) = match (cond, error) {\n+            (&ty::Predicate::Trait(..), &ty::Predicate::Trait(ref error, _)) => (cond, error),\n+            _ => {\n+                // FIXME: make this work in other cases too.\n+                return false;\n+            }\n+        };\n+\n+        for implication in super::elaborate_predicates(self.tcx, vec![*cond]) {\n+            if let ty::Predicate::Trait(implication, _) = implication {\n+                let error = error.to_poly_trait_ref();\n+                let implication = implication.to_poly_trait_ref();\n+                // FIXME: I'm just not taking associated types at all here.\n+                // Eventually I'll need to implement param-env-aware\n+                // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n+                let param_env = ty::ParamEnv::empty();\n+                if self.can_sub(param_env, error, implication).is_ok() {\n+                    debug!(\"error_implies: {:?} -> {:?} -> {:?}\", cond, error, implication);\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    fn report_fulfillment_error(\n+        &self,\n+        error: &FulfillmentError<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n+        debug!(\"report_fulfillment_error({:?})\", error);\n+        match error.code {\n+            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n+                self.report_selection_error(\n+                    &error.obligation,\n+                    selection_error,\n+                    fallback_has_occurred,\n+                    error.points_at_arg_span,\n+                );\n+            }\n+            FulfillmentErrorCode::CodeProjectionError(ref e) => {\n+                self.report_projection_error(&error.obligation, e);\n+            }\n+            FulfillmentErrorCode::CodeAmbiguity => {\n+                self.maybe_report_ambiguity(&error.obligation, body_id);\n+            }\n+            FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n+                self.report_mismatched_types(\n+                    &error.obligation.cause,\n+                    expected_found.expected,\n+                    expected_found.found,\n+                    err.clone(),\n+                )\n+                .emit();\n+            }\n+        }\n+    }\n+\n+    fn report_projection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &MismatchedProjectionTypes<'tcx>,\n+    ) {\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+\n+        if predicate.references_error() {\n+            return;\n+        }\n+\n+        self.probe(|_| {\n+            let err_buf;\n+            let mut err = &error.err;\n+            let mut values = None;\n+\n+            // try to find the mismatched types to report the error with.\n+            //\n+            // this can fail if the problem was higher-ranked, in which\n+            // cause I have no idea for a good error message.\n+            if let ty::Predicate::Projection(ref data) = predicate {\n+                let mut selcx = SelectionContext::new(self);\n+                let (data, _) = self.replace_bound_vars_with_fresh_vars(\n+                    obligation.cause.span,\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    data,\n+                );\n+                let mut obligations = vec![];\n+                let normalized_ty = super::normalize_projection_type(\n+                    &mut selcx,\n+                    obligation.param_env,\n+                    data.projection_ty,\n+                    obligation.cause.clone(),\n+                    0,\n+                    &mut obligations,\n+                );\n+\n+                debug!(\n+                    \"report_projection_error obligation.cause={:?} obligation.param_env={:?}\",\n+                    obligation.cause, obligation.param_env\n+                );\n+\n+                debug!(\n+                    \"report_projection_error normalized_ty={:?} data.ty={:?}\",\n+                    normalized_ty, data.ty\n+                );\n+\n+                let is_normalized_ty_expected = match &obligation.cause.code {\n+                    ObligationCauseCode::ItemObligation(_)\n+                    | ObligationCauseCode::BindingObligation(_, _)\n+                    | ObligationCauseCode::ObjectCastObligation(_) => false,\n+                    _ => true,\n+                };\n+\n+                if let Err(error) = self.at(&obligation.cause, obligation.param_env).eq_exp(\n+                    is_normalized_ty_expected,\n+                    normalized_ty,\n+                    data.ty,\n+                ) {\n+                    values = Some(infer::ValuePairs::Types(ExpectedFound::new(\n+                        is_normalized_ty_expected,\n+                        normalized_ty,\n+                        data.ty,\n+                    )));\n+\n+                    err_buf = error;\n+                    err = &err_buf;\n+                }\n+            }\n+\n+            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n+            let error_id = (DiagnosticMessageId::ErrorId(271), Some(obligation.cause.span), msg);\n+            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n+            if fresh {\n+                let mut diag = struct_span_err!(\n+                    self.tcx.sess,\n+                    obligation.cause.span,\n+                    E0271,\n+                    \"type mismatch resolving `{}`\",\n+                    predicate\n+                );\n+                self.note_type_err(&mut diag, &obligation.cause, None, values, err);\n+                self.note_obligation_cause(&mut diag, obligation);\n+                diag.emit();\n+            }\n+        });\n+    }\n+\n+    fn fuzzy_match_tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+        /// returns the fuzzy category of a given type, or None\n+        /// if the type can be equated to any type.\n+        fn type_category(t: Ty<'_>) -> Option<u32> {\n+            match t.kind {\n+                ty::Bool => Some(0),\n+                ty::Char => Some(1),\n+                ty::Str => Some(2),\n+                ty::Int(..) | ty::Uint(..) | ty::Infer(ty::IntVar(..)) => Some(3),\n+                ty::Float(..) | ty::Infer(ty::FloatVar(..)) => Some(4),\n+                ty::Ref(..) | ty::RawPtr(..) => Some(5),\n+                ty::Array(..) | ty::Slice(..) => Some(6),\n+                ty::FnDef(..) | ty::FnPtr(..) => Some(7),\n+                ty::Dynamic(..) => Some(8),\n+                ty::Closure(..) => Some(9),\n+                ty::Tuple(..) => Some(10),\n+                ty::Projection(..) => Some(11),\n+                ty::Param(..) => Some(12),\n+                ty::Opaque(..) => Some(13),\n+                ty::Never => Some(14),\n+                ty::Adt(adt, ..) => match adt.adt_kind() {\n+                    AdtKind::Struct => Some(15),\n+                    AdtKind::Union => Some(16),\n+                    AdtKind::Enum => Some(17),\n+                },\n+                ty::Generator(..) => Some(18),\n+                ty::Foreign(..) => Some(19),\n+                ty::GeneratorWitness(..) => Some(20),\n+                ty::Placeholder(..) | ty::Bound(..) | ty::Infer(..) | ty::Error => None,\n+                ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+            }\n+        }\n+\n+        match (type_category(a), type_category(b)) {\n+            (Some(cat_a), Some(cat_b)) => match (&a.kind, &b.kind) {\n+                (&ty::Adt(def_a, _), &ty::Adt(def_b, _)) => def_a == def_b,\n+                _ => cat_a == cat_b,\n+            },\n+            // infer and error can be equated to all types\n+            _ => true,\n+        }\n+    }\n+\n+    fn describe_generator(&self, body_id: hir::BodyId) -> Option<&'static str> {\n+        self.tcx.hir().body(body_id).generator_kind.map(|gen_kind| match gen_kind {\n+            hir::GeneratorKind::Gen => \"a generator\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) => \"an async block\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Fn) => \"an async function\",\n+            hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Closure) => \"an async closure\",\n+        })\n+    }\n+\n+    fn find_similar_impl_candidates(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+    ) -> Vec<ty::TraitRef<'tcx>> {\n+        let simp = fast_reject::simplify_type(self.tcx, trait_ref.skip_binder().self_ty(), true);\n+        let all_impls = self.tcx.all_impls(trait_ref.def_id());\n+\n+        match simp {\n+            Some(simp) => all_impls\n+                .iter()\n+                .filter_map(|&def_id| {\n+                    let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n+                    let imp_simp = fast_reject::simplify_type(self.tcx, imp.self_ty(), true);\n+                    if let Some(imp_simp) = imp_simp {\n+                        if simp != imp_simp {\n+                            return None;\n+                        }\n+                    }\n+\n+                    Some(imp)\n+                })\n+                .collect(),\n+            None => {\n+                all_impls.iter().map(|&def_id| self.tcx.impl_trait_ref(def_id).unwrap()).collect()\n+            }\n+        }\n+    }\n+\n+    fn report_similar_impl_candidates(\n+        &self,\n+        impl_candidates: Vec<ty::TraitRef<'tcx>>,\n+        err: &mut DiagnosticBuilder<'_>,\n+    ) {\n+        if impl_candidates.is_empty() {\n+            return;\n+        }\n+\n+        let len = impl_candidates.len();\n+        let end = if impl_candidates.len() <= 5 { impl_candidates.len() } else { 4 };\n+\n+        let normalize = |candidate| {\n+            self.tcx.infer_ctxt().enter(|ref infcx| {\n+                let normalized = infcx\n+                    .at(&ObligationCause::dummy(), ty::ParamEnv::empty())\n+                    .normalize(candidate)\n+                    .ok();\n+                match normalized {\n+                    Some(normalized) => format!(\"\\n  {:?}\", normalized.value),\n+                    None => format!(\"\\n  {:?}\", candidate),\n+                }\n+            })\n+        };\n+\n+        // Sort impl candidates so that ordering is consistent for UI tests.\n+        let mut normalized_impl_candidates =\n+            impl_candidates.iter().map(normalize).collect::<Vec<String>>();\n+\n+        // Sort before taking the `..end` range,\n+        // because the ordering of `impl_candidates` may not be deterministic:\n+        // https://github.com/rust-lang/rust/pull/57475#issuecomment-455519507\n+        normalized_impl_candidates.sort();\n+\n+        err.help(&format!(\n+            \"the following implementations were found:{}{}\",\n+            normalized_impl_candidates[..end].join(\"\"),\n+            if len > 5 { format!(\"\\nand {} others\", len - 4) } else { String::new() }\n+        ));\n+    }\n+\n+    /// Gets the parent trait chain start\n+    fn get_parent_trait_ref(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+    ) -> Option<(String, Option<Span>)> {\n+        match code {\n+            &ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n+                let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+                match self.get_parent_trait_ref(&data.parent_code) {\n+                    Some(t) => Some(t),\n+                    None => {\n+                        let ty = parent_trait_ref.skip_binder().self_ty();\n+                        let span =\n+                            TyCategory::from_ty(ty).map(|(_, def_id)| self.tcx.def_span(def_id));\n+                        Some((ty.to_string(), span))\n+                    }\n+                }\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// If the `Self` type of the unsatisfied trait `trait_ref` implements a trait\n+    /// with the same path as `trait_ref`, a help message about\n+    /// a probable version mismatch is added to `err`\n+    fn note_version_mismatch(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'tcx>,\n+    ) {\n+        let get_trait_impl = |trait_def_id| {\n+            let mut trait_impl = None;\n+            self.tcx.for_each_relevant_impl(trait_def_id, trait_ref.self_ty(), |impl_def_id| {\n+                if trait_impl.is_none() {\n+                    trait_impl = Some(impl_def_id);\n+                }\n+            });\n+            trait_impl\n+        };\n+        let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n+        let all_traits = self.tcx.all_traits(LOCAL_CRATE);\n+        let traits_with_same_path: std::collections::BTreeSet<_> = all_traits\n+            .iter()\n+            .filter(|trait_def_id| **trait_def_id != trait_ref.def_id())\n+            .filter(|trait_def_id| self.tcx.def_path_str(**trait_def_id) == required_trait_path)\n+            .collect();\n+        for trait_with_same_path in traits_with_same_path {\n+            if let Some(impl_def_id) = get_trait_impl(*trait_with_same_path) {\n+                let impl_span = self.tcx.def_span(impl_def_id);\n+                err.span_help(impl_span, \"trait impl with same name found\");\n+                let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n+                let crate_msg = format!(\n+                    \"perhaps two different versions of crate `{}` are being used?\",\n+                    trait_crate\n+                );\n+                err.note(&crate_msg);\n+            }\n+        }\n+    }\n+\n+    fn mk_obligation_for_def_id(\n+        &self,\n+        def_id: DefId,\n+        output_ty: Ty<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> PredicateObligation<'tcx> {\n+        let new_trait_ref =\n+            ty::TraitRef { def_id, substs: self.tcx.mk_substs_trait(output_ty, &[]) };\n+        Obligation::new(cause, param_env, new_trait_ref.without_const().to_predicate())\n+    }\n+\n+    fn maybe_report_ambiguity(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+    ) {\n+        // Unable to successfully determine, probably means\n+        // insufficient type information, but could mean\n+        // ambiguous impls. The latter *ought* to be a\n+        // coherence violation, so we don't report it here.\n+\n+        let predicate = self.resolve_vars_if_possible(&obligation.predicate);\n+        let span = obligation.cause.span;\n+\n+        debug!(\n+            \"maybe_report_ambiguity(predicate={:?}, obligation={:?} body_id={:?}, code={:?})\",\n+            predicate, obligation, body_id, obligation.cause.code,\n+        );\n+\n+        // Ambiguity errors are often caused as fallout from earlier\n+        // errors. So just ignore them if this infcx is tainted.\n+        if self.is_tainted_by_errors() {\n+            return;\n+        }\n+\n+        let mut err = match predicate {\n+            ty::Predicate::Trait(ref data, _) => {\n+                let trait_ref = data.to_poly_trait_ref();\n+                let self_ty = trait_ref.self_ty();\n+                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind, trait_ref);\n+\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                // Typically, this ambiguity should only happen if\n+                // there are unresolved type inference variables\n+                // (otherwise it would suggest a coherence\n+                // failure). But given #21974 that is not necessarily\n+                // the case -- we can have multiple where clauses that\n+                // are only distinguished by a region, which results\n+                // in an ambiguity even when all types are fully\n+                // known, since we don't dispatch based on region\n+                // relationships.\n+\n+                // This is kind of a hack: it frequently happens that some earlier\n+                // error prevents types from being fully inferred, and then we get\n+                // a bunch of uninteresting errors saying something like \"<generic\n+                // #0> doesn't implement Sized\".  It may even be true that we\n+                // could just skip over all checks where the self-ty is an\n+                // inference variable, but I was afraid that there might be an\n+                // inference variable created, registered as an obligation, and\n+                // then never forced by writeback, and hence by skipping here we'd\n+                // be ignoring the fact that we don't KNOW the type works\n+                // out. Though even that would probably be harmless, given that\n+                // we're only talking about builtin traits, which are known to be\n+                // inhabited. We used to check for `self.tcx.sess.has_errors()` to\n+                // avoid inundating the user with unnecessary errors, but we now\n+                // check upstream for type errors and don't add the obligations to\n+                // begin with in those cases.\n+                if self\n+                    .tcx\n+                    .lang_items()\n+                    .sized_trait()\n+                    .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                {\n+                    self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0282).emit();\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0283);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n+                    self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n+                } else if let (\n+                    Ok(ref snippet),\n+                    ObligationCauseCode::BindingObligation(ref def_id, _),\n+                ) =\n+                    (self.tcx.sess.source_map().span_to_snippet(span), &obligation.cause.code)\n+                {\n+                    let generics = self.tcx.generics_of(*def_id);\n+                    if !generics.params.is_empty() && !snippet.ends_with('>') {\n+                        // FIXME: To avoid spurious suggestions in functions where type arguments\n+                        // where already supplied, we check the snippet to make sure it doesn't\n+                        // end with a turbofish. Ideally we would have access to a `PathSegment`\n+                        // instead. Otherwise we would produce the following output:\n+                        //\n+                        // error[E0283]: type annotations needed\n+                        //   --> $DIR/issue-54954.rs:3:24\n+                        //    |\n+                        // LL | const ARR_LEN: usize = Tt::const_val::<[i8; 123]>();\n+                        //    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+                        //    |                        |\n+                        //    |                        cannot infer type\n+                        //    |                        help: consider specifying the type argument\n+                        //    |                        in the function call:\n+                        //    |                        `Tt::const_val::<[i8; 123]>::<T>`\n+                        // ...\n+                        // LL |     const fn const_val<T: Sized>() -> usize {\n+                        //    |              --------- - required by this bound in `Tt::const_val`\n+                        //    |\n+                        //    = note: cannot resolve `_: Tt`\n+\n+                        err.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"consider specifying the type argument{} in the function call\",\n+                                if generics.params.len() > 1 { \"s\" } else { \"\" },\n+                            ),\n+                            format!(\n+                                \"{}::<{}>\",\n+                                snippet,\n+                                generics\n+                                    .params\n+                                    .iter()\n+                                    .map(|p| p.name.to_string())\n+                                    .collect::<Vec<String>>()\n+                                    .join(\", \")\n+                            ),\n+                            Applicability::HasPlaceholders,\n+                        );\n+                    }\n+                }\n+                err\n+            }\n+\n+            ty::Predicate::WellFormed(ty) => {\n+                // Same hacky approach as above to avoid deluging user\n+                // with error messages.\n+                if ty.references_error() || self.tcx.sess.has_errors() {\n+                    return;\n+                }\n+                self.need_type_info_err(body_id, span, ty, ErrorCode::E0282)\n+            }\n+\n+            ty::Predicate::Subtype(ref data) => {\n+                if data.references_error() || self.tcx.sess.has_errors() {\n+                    // no need to overload user in such cases\n+                    return;\n+                }\n+                let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n+                // both must be type variables, or the other would've been instantiated\n+                assert!(a.is_ty_var() && b.is_ty_var());\n+                self.need_type_info_err(body_id, span, a, ErrorCode::E0282)\n+            }\n+            ty::Predicate::Projection(ref data) => {\n+                let trait_ref = data.to_poly_trait_ref(self.tcx);\n+                let self_ty = trait_ref.self_ty();\n+                if predicate.references_error() {\n+                    return;\n+                }\n+                let mut err = self.need_type_info_err(body_id, span, self_ty, ErrorCode::E0284);\n+                err.note(&format!(\"cannot resolve `{}`\", predicate));\n+                err\n+            }\n+\n+            _ => {\n+                if self.tcx.sess.has_errors() {\n+                    return;\n+                }\n+                let mut err = struct_span_err!(\n+                    self.tcx.sess,\n+                    span,\n+                    E0284,\n+                    \"type annotations needed: cannot resolve `{}`\",\n+                    predicate,\n+                );\n+                err.span_label(span, &format!(\"cannot resolve `{}`\", predicate));\n+                err\n+            }\n+        };\n+        self.note_obligation_cause(&mut err, obligation);\n+        err.emit();\n+    }\n+\n+    /// Returns `true` if the trait predicate may apply for *some* assignment\n+    /// to the type parameters.\n+    fn predicate_can_apply(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        pred: ty::PolyTraitRef<'tcx>,\n+    ) -> bool {\n+        struct ParamToVarFolder<'a, 'tcx> {\n+            infcx: &'a InferCtxt<'a, 'tcx>,\n+            var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>,\n+        }\n+\n+        impl<'a, 'tcx> TypeFolder<'tcx> for ParamToVarFolder<'a, 'tcx> {\n+            fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+                self.infcx.tcx\n+            }\n+\n+            fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+                if let ty::Param(ty::ParamTy { name, .. }) = ty.kind {\n+                    let infcx = self.infcx;\n+                    self.var_map.entry(ty).or_insert_with(|| {\n+                        infcx.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeParameterDefinition(name, None),\n+                            span: DUMMY_SP,\n+                        })\n+                    })\n+                } else {\n+                    ty.super_fold_with(self)\n+                }\n+            }\n+        }\n+\n+        self.probe(|_| {\n+            let mut selcx = SelectionContext::new(self);\n+\n+            let cleaned_pred =\n+                pred.fold_with(&mut ParamToVarFolder { infcx: self, var_map: Default::default() });\n+\n+            let cleaned_pred = super::project::normalize(\n+                &mut selcx,\n+                param_env,\n+                ObligationCause::dummy(),\n+                &cleaned_pred,\n+            )\n+            .value;\n+\n+            let obligation = Obligation::new(\n+                ObligationCause::dummy(),\n+                param_env,\n+                cleaned_pred.without_const().to_predicate(),\n+            );\n+\n+            self.predicate_may_hold(&obligation)\n+        })\n+    }\n+\n+    fn note_obligation_cause(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        // First, attempt to add note to this error with an async-await-specific\n+        // message, and fall back to regular note otherwise.\n+        if !self.maybe_note_obligation_cause_for_async_await(err, obligation) {\n+            self.note_obligation_cause_code(\n+                err,\n+                &obligation.predicate,\n+                &obligation.cause.code,\n+                &mut vec![],\n+            );\n+            self.suggest_unsized_bound_if_applicable(err, obligation);\n+        }\n+    }\n+\n+    fn suggest_unsized_bound_if_applicable(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) {\n+        if let (\n+            ty::Predicate::Trait(pred, _),\n+            ObligationCauseCode::BindingObligation(item_def_id, span),\n+        ) = (&obligation.predicate, &obligation.cause.code)\n+        {\n+            if let (Some(generics), true) = (\n+                self.tcx.hir().get_if_local(*item_def_id).as_ref().and_then(|n| n.generics()),\n+                Some(pred.def_id()) == self.tcx.lang_items().sized_trait(),\n+            ) {\n+                for param in generics.params {\n+                    if param.span == *span\n+                        && !param.bounds.iter().any(|bound| {\n+                            bound.trait_def_id() == self.tcx.lang_items().sized_trait()\n+                        })\n+                    {\n+                        let (span, separator) = match param.bounds {\n+                            [] => (span.shrink_to_hi(), \":\"),\n+                            [.., bound] => (bound.span().shrink_to_hi(), \" + \"),\n+                        };\n+                        err.span_suggestion(\n+                            span,\n+                            \"consider relaxing the implicit `Sized` restriction\",\n+                            format!(\"{} ?Sized\", separator),\n+                            Applicability::MachineApplicable,\n+                        );\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn is_recursive_obligation(\n+        &self,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+    ) -> bool {\n+        if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n+            let parent_trait_ref = self.resolve_vars_if_possible(&data.parent_trait_ref);\n+\n+            if obligated_types.iter().any(|ot| ot == &parent_trait_ref.skip_binder().self_ty()) {\n+                return true;\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+pub fn recursive_type_with_infinite_size_error(\n+    tcx: TyCtxt<'tcx>,\n+    type_def_id: DefId,\n+) -> DiagnosticBuilder<'tcx> {\n+    assert!(type_def_id.is_local());\n+    let span = tcx.hir().span_if_local(type_def_id).unwrap();\n+    let span = tcx.sess.source_map().def_span(span);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0072,\n+        \"recursive type `{}` has infinite size\",\n+        tcx.def_path_str(type_def_id)\n+    );\n+    err.span_label(span, \"recursive type has infinite size\");\n+    err.help(&format!(\n+        \"insert indirection (e.g., a `Box`, `Rc`, or `&`) \\\n+                           at some point to make `{}` representable\",\n+        tcx.def_path_str(type_def_id)\n+    ));\n+    err\n+}\n+\n+/// Summarizes information\n+#[derive(Clone)]\n+pub enum ArgKind {\n+    /// An argument of non-tuple type. Parameters are (name, ty)\n+    Arg(String, String),\n+\n+    /// An argument of tuple type. For a \"found\" argument, the span is\n+    /// the locationo in the source of the pattern. For a \"expected\"\n+    /// argument, it will be None. The vector is a list of (name, ty)\n+    /// strings for the components of the tuple.\n+    Tuple(Option<Span>, Vec<(String, String)>),\n+}\n+\n+impl ArgKind {\n+    fn empty() -> ArgKind {\n+        ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n+    }\n+\n+    /// Creates an `ArgKind` from the expected type of an\n+    /// argument. It has no name (`_`) and an optional source span.\n+    pub fn from_expected_ty(t: Ty<'_>, span: Option<Span>) -> ArgKind {\n+        match t.kind {\n+            ty::Tuple(ref tys) => ArgKind::Tuple(\n+                span,\n+                tys.iter().map(|ty| (\"_\".to_owned(), ty.to_string())).collect::<Vec<_>>(),\n+            ),\n+            _ => ArgKind::Arg(\"_\".to_owned(), t.to_string()),\n+        }\n+    }\n+}\n+\n+/// Suggest restricting a type param with a new bound.\n+pub fn suggest_constraining_type_param(\n+    tcx: TyCtxt<'_>,\n+    generics: &hir::Generics<'_>,\n+    err: &mut DiagnosticBuilder<'_>,\n+    param_name: &str,\n+    constraint: &str,\n+    source_map: &SourceMap,\n+    span: Span,\n+    def_id: Option<DefId>,\n+) -> bool {\n+    const MSG_RESTRICT_BOUND_FURTHER: &str = \"consider further restricting this bound with\";\n+    const MSG_RESTRICT_TYPE: &str = \"consider restricting this type parameter with\";\n+    const MSG_RESTRICT_TYPE_FURTHER: &str = \"consider further restricting this type parameter with\";\n+\n+    let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n+\n+    let param = if let Some(param) = param {\n+        param\n+    } else {\n+        return false;\n+    };\n+\n+    if def_id == tcx.lang_items().sized_trait() {\n+        // Type parameters are already `Sized` by default.\n+        err.span_label(param.span, &format!(\"this type parameter needs to be `{}`\", constraint));\n+        return true;\n+    }\n+\n+    if param_name.starts_with(\"impl \") {\n+        // If there's an `impl Trait` used in argument position, suggest\n+        // restricting it:\n+        //\n+        //   fn foo(t: impl Foo) { ... }\n+        //             --------\n+        //             |\n+        //             help: consider further restricting this bound with `+ Bar`\n+        //\n+        // Suggestion for tools in this case is:\n+        //\n+        //   fn foo(t: impl Foo) { ... }\n+        //             --------\n+        //             |\n+        //             replace with: `impl Foo + Bar`\n+\n+        err.span_help(param.span, &format!(\"{} `+ {}`\", MSG_RESTRICT_BOUND_FURTHER, constraint));\n+\n+        err.tool_only_span_suggestion(\n+            param.span,\n+            MSG_RESTRICT_BOUND_FURTHER,\n+            format!(\"{} + {}\", param_name, constraint),\n+            Applicability::MachineApplicable,\n+        );\n+\n+        return true;\n+    }\n+\n+    if generics.where_clause.predicates.is_empty() {\n+        if let Some(bounds_span) = param.bounds_span() {\n+            // If user has provided some bounds, suggest restricting them:\n+            //\n+            //   fn foo<T: Foo>(t: T) { ... }\n+            //             ---\n+            //             |\n+            //             help: consider further restricting this bound with `+ Bar`\n+            //\n+            // Suggestion for tools in this case is:\n+            //\n+            //   fn foo<T: Foo>(t: T) { ... }\n+            //          --\n+            //          |\n+            //          replace with: `T: Bar +`\n+\n+            err.span_help(\n+                bounds_span,\n+                &format!(\"{} `+ {}`\", MSG_RESTRICT_BOUND_FURTHER, constraint),\n+            );\n+\n+            let span_hi = param.span.with_hi(span.hi());\n+            let span_with_colon = source_map.span_through_char(span_hi, ':');\n+\n+            if span_hi != param.span && span_with_colon != span_hi {\n+                err.tool_only_span_suggestion(\n+                    span_with_colon,\n+                    MSG_RESTRICT_BOUND_FURTHER,\n+                    format!(\"{}: {} + \", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        } else {\n+            // If user hasn't provided any bounds, suggest adding a new one:\n+            //\n+            //   fn foo<T>(t: T) { ... }\n+            //          - help: consider restricting this type parameter with `T: Foo`\n+\n+            err.span_help(\n+                param.span,\n+                &format!(\"{} `{}: {}`\", MSG_RESTRICT_TYPE, param_name, constraint),\n+            );\n+\n+            err.tool_only_span_suggestion(\n+                param.span,\n+                MSG_RESTRICT_TYPE,\n+                format!(\"{}: {}\", param_name, constraint),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+\n+        true\n+    } else {\n+        // This part is a bit tricky, because using the `where` clause user can\n+        // provide zero, one or many bounds for the same type parameter, so we\n+        // have following cases to consider:\n+        //\n+        // 1) When the type parameter has been provided zero bounds\n+        //\n+        //    Message:\n+        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+        //             - help: consider restricting this type parameter with `where X: Bar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n+        //                                           - insert: `, X: Bar`\n+        //\n+        //\n+        // 2) When the type parameter has been provided one bound\n+        //\n+        //    Message:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                            ^^^^^^\n+        //                            |\n+        //                            help: consider further restricting this bound with `+ Bar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                            ^^\n+        //                            |\n+        //                            replace with: `T: Bar +`\n+        //\n+        //\n+        // 3) When the type parameter has been provided many bounds\n+        //\n+        //    Message:\n+        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+        //             - help: consider further restricting this type parameter with `where T: Zar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n+        //                                          - insert: `, T: Zar`\n+\n+        let mut param_spans = Vec::new();\n+\n+        for predicate in generics.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n+                span, bounded_ty, ..\n+            }) = predicate\n+            {\n+                if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n+                    if let Some(segment) = path.segments.first() {\n+                        if segment.ident.to_string() == param_name {\n+                            param_spans.push(span);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        let where_clause_span =\n+            generics.where_clause.span_for_predicates_or_empty_place().shrink_to_hi();\n+\n+        match &param_spans[..] {\n+            &[] => {\n+                err.span_help(\n+                    param.span,\n+                    &format!(\"{} `where {}: {}`\", MSG_RESTRICT_TYPE, param_name, constraint),\n+                );\n+\n+                err.tool_only_span_suggestion(\n+                    where_clause_span,\n+                    MSG_RESTRICT_TYPE,\n+                    format!(\", {}: {}\", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+\n+            &[&param_span] => {\n+                err.span_help(\n+                    param_span,\n+                    &format!(\"{} `+ {}`\", MSG_RESTRICT_BOUND_FURTHER, constraint),\n+                );\n+\n+                let span_hi = param_span.with_hi(span.hi());\n+                let span_with_colon = source_map.span_through_char(span_hi, ':');\n+\n+                if span_hi != param_span && span_with_colon != span_hi {\n+                    err.tool_only_span_suggestion(\n+                        span_with_colon,\n+                        MSG_RESTRICT_BOUND_FURTHER,\n+                        format!(\"{}: {} +\", param_name, constraint),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+\n+            _ => {\n+                err.span_help(\n+                    param.span,\n+                    &format!(\n+                        \"{} `where {}: {}`\",\n+                        MSG_RESTRICT_TYPE_FURTHER, param_name, constraint,\n+                    ),\n+                );\n+\n+                err.tool_only_span_suggestion(\n+                    where_clause_span,\n+                    MSG_RESTRICT_BOUND_FURTHER,\n+                    format!(\", {}: {}\", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+\n+        true\n+    }\n+}"}, {"sha": "6e3074cd3ca98afc021efa001bc7f84a324c990e", "filename": "src/librustc_trait_selection/traits/error_reporting/on_unimplemented.rs", "status": "renamed", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -8,7 +8,27 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::sym;\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+use super::InferCtxtPrivExt;\n+\n+crate trait InferCtxtExt<'tcx> {\n+    /*private*/\n+    fn impl_similar_to(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> Option<DefId>;\n+\n+    /*private*/\n+    fn describe_enclosure(&self, hir_id: hir::HirId) -> Option<&'static str>;\n+\n+    fn on_unimplemented_note(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> OnUnimplementedNote;\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn impl_similar_to(\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n@@ -101,7 +121,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn on_unimplemented_note(\n+    fn on_unimplemented_note(\n         &self,\n         trait_ref: ty::PolyTraitRef<'tcx>,\n         obligation: &PredicateObligation<'tcx>,", "previous_filename": "src/librustc_infer/traits/error_reporting/on_unimplemented.rs"}, {"sha": "351e557d40b302d1f804c7305393429e3278c111", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "renamed", "additions": 147, "deletions": 237, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,16 +1,13 @@\n use super::{\n-    ArgKind, EvaluationResult, Obligation, ObligationCause, ObligationCauseCode,\n-    PredicateObligation,\n+    EvaluationResult, Obligation, ObligationCause, ObligationCauseCode, PredicateObligation,\n };\n \n use crate::infer::InferCtxt;\n use crate::traits::error_reporting::suggest_constraining_type_param;\n \n use rustc::ty::TypeckTables;\n use rustc::ty::{self, AdtKind, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n-use rustc_errors::{\n-    error_code, pluralize, struct_span_err, Applicability, DiagnosticBuilder, Style,\n-};\n+use rustc_errors::{error_code, struct_span_err, Applicability, DiagnosticBuilder, Style};\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n@@ -20,8 +17,136 @@ use rustc_span::symbol::{kw, sym};\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    crate fn suggest_restricting_param_bound(\n+use super::InferCtxtPrivExt;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n+\n+crate trait InferCtxtExt<'tcx> {\n+    fn suggest_restricting_param_bound(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::PolyTraitRef<'_>,\n+        body_id: hir::HirId,\n+    );\n+\n+    fn suggest_borrow_on_unsized_slice(\n+        &self,\n+        code: &ObligationCauseCode<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+    );\n+\n+    fn get_closure_name(\n+        &self,\n+        def_id: DefId,\n+        err: &mut DiagnosticBuilder<'_>,\n+        msg: &str,\n+    ) -> Option<String>;\n+\n+    fn suggest_fn_call(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'_>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    );\n+\n+    fn suggest_add_reference_to_arg(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+        has_custom_message: bool,\n+    ) -> bool;\n+\n+    fn suggest_remove_reference(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    );\n+\n+    fn suggest_change_mut(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    );\n+\n+    fn suggest_semicolon_removal(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    );\n+\n+    fn suggest_impl_trait(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        span: Span,\n+        obligation: &PredicateObligation<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+    ) -> bool;\n+\n+    fn point_at_returns_when_relevant(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        obligation: &PredicateObligation<'tcx>,\n+    );\n+\n+    fn report_closure_arg_mismatch(\n+        &self,\n+        span: Span,\n+        found_span: Option<Span>,\n+        expected_ref: ty::PolyTraitRef<'tcx>,\n+        found: ty::PolyTraitRef<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx>;\n+\n+    fn suggest_fully_qualified_path(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        def_id: DefId,\n+        span: Span,\n+        trait_ref: DefId,\n+    );\n+\n+    fn maybe_note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool;\n+\n+    fn note_obligation_cause_for_async_await(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        target_span: Span,\n+        scope_span: &Option<Span>,\n+        expr: Option<hir::HirId>,\n+        snippet: String,\n+        first_generator: DefId,\n+        last_generator: Option<DefId>,\n+        trait_ref: ty::TraitRef<'_>,\n+        target_ty: Ty<'tcx>,\n+        tables: &ty::TypeckTables<'_>,\n+        obligation: &PredicateObligation<'tcx>,\n+        next_code: Option<&ObligationCauseCode<'tcx>>,\n+    );\n+\n+    fn note_obligation_cause_code<T>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        predicate: &T,\n+        cause_code: &ObligationCauseCode<'tcx>,\n+        obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n+    ) where\n+        T: fmt::Display;\n+\n+    fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>);\n+}\n+\n+impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n+    fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::PolyTraitRef<'_>,\n@@ -168,7 +293,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// When encountering an assignment of an unsized trait, like `let x = \"\"[..];`, provide a\n     /// suggestion to borrow the initializer in order to use have a slice instead.\n-    crate fn suggest_borrow_on_unsized_slice(\n+    fn suggest_borrow_on_unsized_slice(\n         &self,\n         code: &ObligationCauseCode<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -195,7 +320,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Given a closure's `DefId`, return the given name of the closure.\n     ///\n     /// This doesn't account for reassignments, but it's only used for suggestions.\n-    crate fn get_closure_name(\n+    fn get_closure_name(\n         &self,\n         def_id: DefId,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -233,7 +358,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// We tried to apply the bound to an `fn` or closure. Check whether calling it would\n     /// evaluate to a type that *would* satisfy the trait binding. If it would, suggest calling\n     /// it: `bar(foo)` \u2192 `bar(foo())`. This case is *very* likely to be hit if `foo` is `async`.\n-    crate fn suggest_fn_call(\n+    fn suggest_fn_call(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n@@ -317,7 +442,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn suggest_add_reference_to_arg(\n+    fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -389,7 +514,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n     /// suggest removing these references until we reach a type that implements the trait.\n-    crate fn suggest_remove_reference(\n+    fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -451,7 +576,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Check if the trait bound is implemented for a different mutability and note it in the\n     /// final error.\n-    crate fn suggest_change_mut(\n+    fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -513,7 +638,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn suggest_semicolon_removal(\n+    fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n@@ -549,7 +674,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// If all conditions are met to identify a returned `dyn Trait`, suggest using `impl Trait` if\n     /// applicable and signal that the error has been expanded appropriately and needs to be\n     /// emitted.\n-    crate fn suggest_impl_trait(\n+    fn suggest_impl_trait(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n         span: Span,\n@@ -723,7 +848,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         true\n     }\n \n-    crate fn point_at_returns_when_relevant(\n+    fn point_at_returns_when_relevant(\n         &self,\n         err: &mut DiagnosticBuilder<'tcx>,\n         obligation: &PredicateObligation<'tcx>,\n@@ -753,220 +878,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Given some node representing a fn-like thing in the HIR map,\n-    /// returns a span and `ArgKind` information that describes the\n-    /// arguments it expects. This can be supplied to\n-    /// `report_arg_count_mismatch`.\n-    pub fn get_fn_like_arguments(&self, node: Node<'_>) -> (Span, Vec<ArgKind>) {\n-        match node {\n-            Node::Expr(&hir::Expr {\n-                kind: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n-                ..\n-            }) => (\n-                self.tcx.sess.source_map().def_span(span),\n-                self.tcx\n-                    .hir()\n-                    .body(id)\n-                    .params\n-                    .iter()\n-                    .map(|arg| {\n-                        if let hir::Pat { kind: hir::PatKind::Tuple(ref args, _), span, .. } =\n-                            *arg.pat\n-                        {\n-                            ArgKind::Tuple(\n-                                Some(span),\n-                                args.iter()\n-                                    .map(|pat| {\n-                                        let snippet = self\n-                                            .tcx\n-                                            .sess\n-                                            .source_map()\n-                                            .span_to_snippet(pat.span)\n-                                            .unwrap();\n-                                        (snippet, \"_\".to_owned())\n-                                    })\n-                                    .collect::<Vec<_>>(),\n-                            )\n-                        } else {\n-                            let name =\n-                                self.tcx.sess.source_map().span_to_snippet(arg.pat.span).unwrap();\n-                            ArgKind::Arg(name, \"_\".to_owned())\n-                        }\n-                    })\n-                    .collect::<Vec<ArgKind>>(),\n-            ),\n-            Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n-            | Node::ImplItem(&hir::ImplItem {\n-                span,\n-                kind: hir::ImplItemKind::Method(ref sig, _),\n-                ..\n-            })\n-            | Node::TraitItem(&hir::TraitItem {\n-                span,\n-                kind: hir::TraitItemKind::Fn(ref sig, _),\n-                ..\n-            }) => (\n-                self.tcx.sess.source_map().def_span(span),\n-                sig.decl\n-                    .inputs\n-                    .iter()\n-                    .map(|arg| match arg.clone().kind {\n-                        hir::TyKind::Tup(ref tys) => ArgKind::Tuple(\n-                            Some(arg.span),\n-                            vec![(\"_\".to_owned(), \"_\".to_owned()); tys.len()],\n-                        ),\n-                        _ => ArgKind::empty(),\n-                    })\n-                    .collect::<Vec<ArgKind>>(),\n-            ),\n-            Node::Ctor(ref variant_data) => {\n-                let span = variant_data\n-                    .ctor_hir_id()\n-                    .map(|hir_id| self.tcx.hir().span(hir_id))\n-                    .unwrap_or(DUMMY_SP);\n-                let span = self.tcx.sess.source_map().def_span(span);\n-\n-                (span, vec![ArgKind::empty(); variant_data.fields().len()])\n-            }\n-            _ => panic!(\"non-FnLike node found: {:?}\", node),\n-        }\n-    }\n-\n-    /// Reports an error when the number of arguments needed by a\n-    /// trait match doesn't match the number that the expression\n-    /// provides.\n-    pub fn report_arg_count_mismatch(\n-        &self,\n-        span: Span,\n-        found_span: Option<Span>,\n-        expected_args: Vec<ArgKind>,\n-        found_args: Vec<ArgKind>,\n-        is_closure: bool,\n-    ) -> DiagnosticBuilder<'tcx> {\n-        let kind = if is_closure { \"closure\" } else { \"function\" };\n-\n-        let args_str = |arguments: &[ArgKind], other: &[ArgKind]| {\n-            let arg_length = arguments.len();\n-            let distinct = match &other[..] {\n-                &[ArgKind::Tuple(..)] => true,\n-                _ => false,\n-            };\n-            match (arg_length, arguments.get(0)) {\n-                (1, Some(&ArgKind::Tuple(_, ref fields))) => {\n-                    format!(\"a single {}-tuple as argument\", fields.len())\n-                }\n-                _ => format!(\n-                    \"{} {}argument{}\",\n-                    arg_length,\n-                    if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n-                    pluralize!(arg_length)\n-                ),\n-            }\n-        };\n-\n-        let expected_str = args_str(&expected_args, &found_args);\n-        let found_str = args_str(&found_args, &expected_args);\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            span,\n-            E0593,\n-            \"{} is expected to take {}, but it takes {}\",\n-            kind,\n-            expected_str,\n-            found_str,\n-        );\n-\n-        err.span_label(span, format!(\"expected {} that takes {}\", kind, expected_str));\n-\n-        if let Some(found_span) = found_span {\n-            err.span_label(found_span, format!(\"takes {}\", found_str));\n-\n-            // move |_| { ... }\n-            // ^^^^^^^^-- def_span\n-            //\n-            // move |_| { ... }\n-            // ^^^^^-- prefix\n-            let prefix_span = self.tcx.sess.source_map().span_until_non_whitespace(found_span);\n-            // move |_| { ... }\n-            //      ^^^-- pipe_span\n-            let pipe_span =\n-                if let Some(span) = found_span.trim_start(prefix_span) { span } else { found_span };\n-\n-            // Suggest to take and ignore the arguments with expected_args_length `_`s if\n-            // found arguments is empty (assume the user just wants to ignore args in this case).\n-            // For example, if `expected_args_length` is 2, suggest `|_, _|`.\n-            if found_args.is_empty() && is_closure {\n-                let underscores = vec![\"_\"; expected_args.len()].join(\", \");\n-                err.span_suggestion(\n-                    pipe_span,\n-                    &format!(\n-                        \"consider changing the closure to take and ignore the expected argument{}\",\n-                        if expected_args.len() < 2 { \"\" } else { \"s\" }\n-                    ),\n-                    format!(\"|{}|\", underscores),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-\n-            if let &[ArgKind::Tuple(_, ref fields)] = &found_args[..] {\n-                if fields.len() == expected_args.len() {\n-                    let sugg = fields\n-                        .iter()\n-                        .map(|(name, _)| name.to_owned())\n-                        .collect::<Vec<String>>()\n-                        .join(\", \");\n-                    err.span_suggestion(\n-                        found_span,\n-                        \"change the closure to take multiple arguments instead of a single tuple\",\n-                        format!(\"|{}|\", sugg),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            if let &[ArgKind::Tuple(_, ref fields)] = &expected_args[..] {\n-                if fields.len() == found_args.len() && is_closure {\n-                    let sugg = format!(\n-                        \"|({}){}|\",\n-                        found_args\n-                            .iter()\n-                            .map(|arg| match arg {\n-                                ArgKind::Arg(name, _) => name.to_owned(),\n-                                _ => \"_\".to_owned(),\n-                            })\n-                            .collect::<Vec<String>>()\n-                            .join(\", \"),\n-                        // add type annotations if available\n-                        if found_args.iter().any(|arg| match arg {\n-                            ArgKind::Arg(_, ty) => ty != \"_\",\n-                            _ => false,\n-                        }) {\n-                            format!(\n-                                \": ({})\",\n-                                fields\n-                                    .iter()\n-                                    .map(|(_, ty)| ty.to_owned())\n-                                    .collect::<Vec<String>>()\n-                                    .join(\", \")\n-                            )\n-                        } else {\n-                            String::new()\n-                        },\n-                    );\n-                    err.span_suggestion(\n-                        found_span,\n-                        \"change the closure to accept a tuple instead of individual arguments\",\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-        }\n-\n-        err\n-    }\n-\n-    crate fn report_closure_arg_mismatch(\n+    fn report_closure_arg_mismatch(\n         &self,\n         span: Span,\n         found_span: Option<Span>,\n@@ -1022,10 +934,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         err\n     }\n-}\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    crate fn suggest_fully_qualified_path(\n+    fn suggest_fully_qualified_path(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         def_id: DefId,\n@@ -1091,7 +1001,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// ```\n     ///\n     /// Returns `true` if an async-await specific note was added to the diagnostic.\n-    crate fn maybe_note_obligation_cause_for_async_await(\n+    fn maybe_note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1271,7 +1181,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Unconditionally adds the diagnostic note described in\n     /// `maybe_note_obligation_cause_for_async_await`'s documentation comment.\n-    crate fn note_obligation_cause_for_async_await(\n+    fn note_obligation_cause_for_async_await(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         target_span: Span,\n@@ -1423,7 +1333,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         );\n     }\n \n-    crate fn note_obligation_cause_code<T>(\n+    fn note_obligation_cause_code<T>(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         predicate: &T,\n@@ -1638,7 +1548,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    crate fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n+    fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder<'_>) {\n         let current_limit = self.tcx.sess.recursion_limit.get();\n         let suggested_limit = current_limit * 2;\n         err.help(&format!(", "previous_filename": "src/librustc_infer/traits/error_reporting/suggestions.rs"}, {"sha": "5def77ce7324cba1f1b5f48024874cbf9212e073", "filename": "src/librustc_trait_selection/traits/fulfill.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ffulfill.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -4,9 +4,9 @@ use rustc::ty::{self, ToPolyTraitRef, Ty, TypeFoldable};\n use rustc_data_structures::obligation_forest::ProcessResult;\n use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n+use rustc_infer::traits::{TraitEngine, TraitEngineExt as _};\n use std::marker::PhantomData;\n \n-use super::engine::{TraitEngine, TraitEngineExt};\n use super::project;\n use super::select::SelectionContext;\n use super::wf;\n@@ -17,6 +17,9 @@ use super::{ConstEvalFailure, Unimplemented};\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n \n+use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n+\n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     /// Note that we include both the `ParamEnv` and the `Predicate`,\n     /// as the `ParamEnv` can influence whether fulfillment succeeds", "previous_filename": "src/librustc_infer/traits/fulfill.rs"}, {"sha": "d500cff67c64b01b0f862266a2c4e55bb7b43ca0", "filename": "src/librustc_trait_selection/traits/misc.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmisc.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,10 +1,13 @@\n //! Miscellaneous type-system utilities that are too small to deserve their own modules.\n \n-use crate::infer::TyCtxtInferExt;\n+use crate::infer::InferCtxtExt as _;\n use crate::traits::{self, ObligationCause};\n \n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as hir;\n+use rustc_infer::infer::TyCtxtInferExt;\n+\n+use crate::traits::error_reporting::InferCtxtExt;\n \n #[derive(Clone)]\n pub enum CopyImplementationError<'tcx> {", "previous_filename": "src/librustc_infer/traits/misc.rs"}, {"sha": "7b93982db974b94c4bf757708e67092eb4e39a71", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "added", "additions": 533, "deletions": 0, "changes": 533, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -0,0 +1,533 @@\n+//! Trait Resolution. See the [rustc dev guide] for more information on how this works.\n+//!\n+//! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/resolution.html\n+\n+#[allow(dead_code)]\n+pub mod auto_trait;\n+pub mod codegen;\n+mod coherence;\n+mod engine;\n+pub mod error_reporting;\n+mod fulfill;\n+pub mod misc;\n+mod object_safety;\n+mod on_unimplemented;\n+mod project;\n+pub mod query;\n+mod select;\n+mod specialize;\n+mod structural_match;\n+mod util;\n+pub mod wf;\n+\n+use crate::infer::outlives::env::OutlivesEnvironment;\n+use crate::infer::{InferCtxt, SuppressRegionErrors, TyCtxtInferExt};\n+use crate::traits::error_reporting::InferCtxtExt as _;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n+use rustc::middle::region;\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::{InternalSubsts, SubstsRef};\n+use rustc::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc::util::common::ErrorReported;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use std::fmt::Debug;\n+\n+pub use self::FulfillmentErrorCode::*;\n+pub use self::ObligationCauseCode::*;\n+pub use self::SelectionError::*;\n+pub use self::Vtable::*;\n+\n+pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n+pub use self::coherence::{OrphanCheckErr, OverlapResult};\n+pub use self::engine::TraitEngineExt;\n+pub use self::fulfill::{FulfillmentContext, PendingPredicateObligation};\n+pub use self::object_safety::astconv_object_safety_violations;\n+pub use self::object_safety::is_vtable_safe_method;\n+pub use self::object_safety::MethodViolationCode;\n+pub use self::object_safety::ObjectSafetyViolation;\n+pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n+pub use self::project::{\n+    normalize, normalize_projection_type, normalize_to, poly_project_and_unify_type,\n+};\n+pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n+pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n+pub use self::specialize::find_associated_item;\n+pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n+pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n+pub use self::specialize::{specialization_graph, translate_substs, OverlapError};\n+pub use self::structural_match::search_for_structural_match_violation;\n+pub use self::structural_match::type_marked_structural;\n+pub use self::structural_match::NonStructuralMatchTy;\n+pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n+pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n+pub use self::util::{\n+    get_vtable_index_of_object_method, impl_is_default, impl_item_is_final,\n+    predicate_for_trait_def, upcast_choices,\n+};\n+pub use self::util::{\n+    supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n+};\n+\n+pub use rustc_infer::traits::*;\n+\n+/// Whether to skip the leak check, as part of a future compatibility warning step.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum SkipLeakCheck {\n+    Yes,\n+    No,\n+}\n+\n+impl SkipLeakCheck {\n+    fn is_yes(self) -> bool {\n+        self == SkipLeakCheck::Yes\n+    }\n+}\n+\n+/// The \"default\" for skip-leak-check corresponds to the current\n+/// behavior (do not skip the leak check) -- not the behavior we are\n+/// transitioning into.\n+impl Default for SkipLeakCheck {\n+    fn default() -> Self {\n+        SkipLeakCheck::No\n+    }\n+}\n+\n+/// The mode that trait queries run in.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum TraitQueryMode {\n+    // Standard/un-canonicalized queries get accurate\n+    // spans etc. passed in and hence can do reasonable\n+    // error reporting on their own.\n+    Standard,\n+    // Canonicalized queries get dummy spans and hence\n+    // must generally propagate errors to\n+    // pre-canonicalization callsites.\n+    Canonical,\n+}\n+\n+/// Creates predicate obligations from the generic bounds.\n+pub fn predicates_for_generics<'tcx>(\n+    cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n+) -> PredicateObligations<'tcx> {\n+    util::predicates_for_generics(cause, 0, param_env, generic_bounds)\n+}\n+\n+/// Determines whether the type `ty` is known to meet `bound` and\n+/// returns true if so. Returns false if `ty` either does not meet\n+/// `bound` or is not known to meet bound (note that this is\n+/// conservative towards *no impl*, which is the opposite of the\n+/// `evaluate` methods).\n+pub fn type_known_to_meet_bound_modulo_regions<'a, 'tcx>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    def_id: DefId,\n+    span: Span,\n+) -> bool {\n+    debug!(\n+        \"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n+        ty,\n+        infcx.tcx.def_path_str(def_id)\n+    );\n+\n+    let trait_ref = ty::TraitRef { def_id, substs: infcx.tcx.mk_substs_trait(ty, &[]) };\n+    let obligation = Obligation {\n+        param_env,\n+        cause: ObligationCause::misc(span, hir::DUMMY_HIR_ID),\n+        recursion_depth: 0,\n+        predicate: trait_ref.without_const().to_predicate(),\n+    };\n+\n+    let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n+    debug!(\n+        \"type_known_to_meet_ty={:?} bound={} => {:?}\",\n+        ty,\n+        infcx.tcx.def_path_str(def_id),\n+        result\n+    );\n+\n+    if result && ty.has_infer_types_or_consts() {\n+        // Because of inference \"guessing\", selection can sometimes claim\n+        // to succeed while the success requires a guess. To ensure\n+        // this function's result remains infallible, we must confirm\n+        // that guess. While imperfect, I believe this is sound.\n+\n+        // The handling of regions in this area of the code is terrible,\n+        // see issue #29149. We should be able to improve on this with\n+        // NLL.\n+        let mut fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+\n+        // We can use a dummy node-id here because we won't pay any mind\n+        // to region obligations that arise (there shouldn't really be any\n+        // anyhow).\n+        let cause = ObligationCause::misc(span, hir::DUMMY_HIR_ID);\n+\n+        fulfill_cx.register_bound(infcx, param_env, ty, def_id, cause);\n+\n+        // Note: we only assume something is `Copy` if we can\n+        // *definitively* show that it implements `Copy`. Otherwise,\n+        // assume it is move; linear is always ok.\n+        match fulfill_cx.select_all_or_error(infcx) {\n+            Ok(()) => {\n+                debug!(\n+                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n+                    ty,\n+                    infcx.tcx.def_path_str(def_id)\n+                );\n+                true\n+            }\n+            Err(e) => {\n+                debug!(\n+                    \"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n+                    ty,\n+                    infcx.tcx.def_path_str(def_id),\n+                    e\n+                );\n+                false\n+            }\n+        }\n+    } else {\n+        result\n+    }\n+}\n+\n+fn do_normalize_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    region_context: DefId,\n+    cause: ObligationCause<'tcx>,\n+    elaborated_env: ty::ParamEnv<'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n+) -> Result<Vec<ty::Predicate<'tcx>>, ErrorReported> {\n+    debug!(\n+        \"do_normalize_predicates(predicates={:?}, region_context={:?}, cause={:?})\",\n+        predicates, region_context, cause,\n+    );\n+    let span = cause.span;\n+    tcx.infer_ctxt().enter(|infcx| {\n+        // FIXME. We should really... do something with these region\n+        // obligations. But this call just continues the older\n+        // behavior (i.e., doesn't cause any new bugs), and it would\n+        // take some further refactoring to actually solve them. In\n+        // particular, we would have to handle implied bounds\n+        // properly, and that code is currently largely confined to\n+        // regionck (though I made some efforts to extract it\n+        // out). -nmatsakis\n+        //\n+        // @arielby: In any case, these obligations are checked\n+        // by wfcheck anyway, so I'm not sure we have to check\n+        // them here too, and we will remove this function when\n+        // we move over to lazy normalization *anyway*.\n+        let fulfill_cx = FulfillmentContext::new_ignoring_regions();\n+        let predicates =\n+            match fully_normalize(&infcx, fulfill_cx, cause, elaborated_env, &predicates) {\n+                Ok(predicates) => predicates,\n+                Err(errors) => {\n+                    infcx.report_fulfillment_errors(&errors, None, false);\n+                    return Err(ErrorReported);\n+                }\n+            };\n+\n+        debug!(\"do_normalize_predictes: normalized predicates = {:?}\", predicates);\n+\n+        let region_scope_tree = region::ScopeTree::default();\n+\n+        // We can use the `elaborated_env` here; the region code only\n+        // cares about declarations like `'a: 'b`.\n+        let outlives_env = OutlivesEnvironment::new(elaborated_env);\n+\n+        infcx.resolve_regions_and_report_errors(\n+            region_context,\n+            &region_scope_tree,\n+            &outlives_env,\n+            SuppressRegionErrors::default(),\n+        );\n+\n+        let predicates = match infcx.fully_resolve(&predicates) {\n+            Ok(predicates) => predicates,\n+            Err(fixup_err) => {\n+                // If we encounter a fixup error, it means that some type\n+                // variable wound up unconstrained. I actually don't know\n+                // if this can happen, and I certainly don't expect it to\n+                // happen often, but if it did happen it probably\n+                // represents a legitimate failure due to some kind of\n+                // unconstrained variable, and it seems better not to ICE,\n+                // all things considered.\n+                tcx.sess.span_err(span, &fixup_err.to_string());\n+                return Err(ErrorReported);\n+            }\n+        };\n+        if predicates.has_local_value() {\n+            // FIXME: shouldn't we, you know, actually report an error here? or an ICE?\n+            Err(ErrorReported)\n+        } else {\n+            Ok(predicates)\n+        }\n+    })\n+}\n+\n+// FIXME: this is gonna need to be removed ...\n+/// Normalizes the parameter environment, reporting errors if they occur.\n+pub fn normalize_param_env_or_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    region_context: DefId,\n+    unnormalized_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+) -> ty::ParamEnv<'tcx> {\n+    // I'm not wild about reporting errors here; I'd prefer to\n+    // have the errors get reported at a defined place (e.g.,\n+    // during typeck). Instead I have all parameter\n+    // environments, in effect, going through this function\n+    // and hence potentially reporting errors. This ensures of\n+    // course that we never forget to normalize (the\n+    // alternative seemed like it would involve a lot of\n+    // manual invocations of this fn -- and then we'd have to\n+    // deal with the errors at each of those sites).\n+    //\n+    // In any case, in practice, typeck constructs all the\n+    // parameter environments once for every fn as it goes,\n+    // and errors will get reported then; so after typeck we\n+    // can be sure that no errors should occur.\n+\n+    debug!(\n+        \"normalize_param_env_or_error(region_context={:?}, unnormalized_env={:?}, cause={:?})\",\n+        region_context, unnormalized_env, cause\n+    );\n+\n+    let mut predicates: Vec<_> =\n+        util::elaborate_predicates(tcx, unnormalized_env.caller_bounds.to_vec()).collect();\n+\n+    debug!(\"normalize_param_env_or_error: elaborated-predicates={:?}\", predicates);\n+\n+    let elaborated_env = ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        unnormalized_env.reveal,\n+        unnormalized_env.def_id,\n+    );\n+\n+    // HACK: we are trying to normalize the param-env inside *itself*. The problem is that\n+    // normalization expects its param-env to be already normalized, which means we have\n+    // a circularity.\n+    //\n+    // The way we handle this is by normalizing the param-env inside an unnormalized version\n+    // of the param-env, which means that if the param-env contains unnormalized projections,\n+    // we'll have some normalization failures. This is unfortunate.\n+    //\n+    // Lazy normalization would basically handle this by treating just the\n+    // normalizing-a-trait-ref-requires-itself cycles as evaluation failures.\n+    //\n+    // Inferred outlives bounds can create a lot of `TypeOutlives` predicates for associated\n+    // types, so to make the situation less bad, we normalize all the predicates *but*\n+    // the `TypeOutlives` predicates first inside the unnormalized parameter environment, and\n+    // then we normalize the `TypeOutlives` bounds inside the normalized parameter environment.\n+    //\n+    // This works fairly well because trait matching  does not actually care about param-env\n+    // TypeOutlives predicates - these are normally used by regionck.\n+    let outlives_predicates: Vec<_> = predicates\n+        .drain_filter(|predicate| match predicate {\n+            ty::Predicate::TypeOutlives(..) => true,\n+            _ => false,\n+        })\n+        .collect();\n+\n+    debug!(\n+        \"normalize_param_env_or_error: predicates=(non-outlives={:?}, outlives={:?})\",\n+        predicates, outlives_predicates\n+    );\n+    let non_outlives_predicates = match do_normalize_predicates(\n+        tcx,\n+        region_context,\n+        cause.clone(),\n+        elaborated_env,\n+        predicates,\n+    ) {\n+        Ok(predicates) => predicates,\n+        // An unnormalized env is better than nothing.\n+        Err(ErrorReported) => {\n+            debug!(\"normalize_param_env_or_error: errored resolving non-outlives predicates\");\n+            return elaborated_env;\n+        }\n+    };\n+\n+    debug!(\"normalize_param_env_or_error: non-outlives predicates={:?}\", non_outlives_predicates);\n+\n+    // Not sure whether it is better to include the unnormalized TypeOutlives predicates\n+    // here. I believe they should not matter, because we are ignoring TypeOutlives param-env\n+    // predicates here anyway. Keeping them here anyway because it seems safer.\n+    let outlives_env: Vec<_> =\n+        non_outlives_predicates.iter().chain(&outlives_predicates).cloned().collect();\n+    let outlives_env =\n+        ty::ParamEnv::new(tcx.intern_predicates(&outlives_env), unnormalized_env.reveal, None);\n+    let outlives_predicates = match do_normalize_predicates(\n+        tcx,\n+        region_context,\n+        cause,\n+        outlives_env,\n+        outlives_predicates,\n+    ) {\n+        Ok(predicates) => predicates,\n+        // An unnormalized env is better than nothing.\n+        Err(ErrorReported) => {\n+            debug!(\"normalize_param_env_or_error: errored resolving outlives predicates\");\n+            return elaborated_env;\n+        }\n+    };\n+    debug!(\"normalize_param_env_or_error: outlives predicates={:?}\", outlives_predicates);\n+\n+    let mut predicates = non_outlives_predicates;\n+    predicates.extend(outlives_predicates);\n+    debug!(\"normalize_param_env_or_error: final predicates={:?}\", predicates);\n+    ty::ParamEnv::new(\n+        tcx.intern_predicates(&predicates),\n+        unnormalized_env.reveal,\n+        unnormalized_env.def_id,\n+    )\n+}\n+\n+pub fn fully_normalize<'a, 'tcx, T>(\n+    infcx: &InferCtxt<'a, 'tcx>,\n+    mut fulfill_cx: FulfillmentContext<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    value: &T,\n+) -> Result<T, Vec<FulfillmentError<'tcx>>>\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    debug!(\"fully_normalize_with_fulfillcx(value={:?})\", value);\n+    let selcx = &mut SelectionContext::new(infcx);\n+    let Normalized { value: normalized_value, obligations } =\n+        project::normalize(selcx, param_env, cause, value);\n+    debug!(\n+        \"fully_normalize: normalized_value={:?} obligations={:?}\",\n+        normalized_value, obligations\n+    );\n+    for obligation in obligations {\n+        fulfill_cx.register_predicate_obligation(selcx.infcx(), obligation);\n+    }\n+\n+    debug!(\"fully_normalize: select_all_or_error start\");\n+    fulfill_cx.select_all_or_error(infcx)?;\n+    debug!(\"fully_normalize: select_all_or_error complete\");\n+    let resolved_value = infcx.resolve_vars_if_possible(&normalized_value);\n+    debug!(\"fully_normalize: resolved_value={:?}\", resolved_value);\n+    Ok(resolved_value)\n+}\n+\n+/// Normalizes the predicates and checks whether they hold in an empty\n+/// environment. If this returns false, then either normalize\n+/// encountered an error or one of the predicates did not hold. Used\n+/// when creating vtables to check for unsatisfiable methods.\n+pub fn normalize_and_test_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n+) -> bool {\n+    debug!(\"normalize_and_test_predicates(predicates={:?})\", predicates);\n+\n+    let result = tcx.infer_ctxt().enter(|infcx| {\n+        let param_env = ty::ParamEnv::reveal_all();\n+        let mut selcx = SelectionContext::new(&infcx);\n+        let mut fulfill_cx = FulfillmentContext::new();\n+        let cause = ObligationCause::dummy();\n+        let Normalized { value: predicates, obligations } =\n+            normalize(&mut selcx, param_env, cause.clone(), &predicates);\n+        for obligation in obligations {\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+        for predicate in predicates {\n+            let obligation = Obligation::new(cause.clone(), param_env, predicate);\n+            fulfill_cx.register_predicate_obligation(&infcx, obligation);\n+        }\n+\n+        fulfill_cx.select_all_or_error(&infcx).is_ok()\n+    });\n+    debug!(\"normalize_and_test_predicates(predicates={:?}) = {:?}\", predicates, result);\n+    result\n+}\n+\n+fn substitute_normalize_and_test_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (DefId, SubstsRef<'tcx>),\n+) -> bool {\n+    debug!(\"substitute_normalize_and_test_predicates(key={:?})\", key);\n+\n+    let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n+    let result = normalize_and_test_predicates(tcx, predicates);\n+\n+    debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\", key, result);\n+    result\n+}\n+\n+/// Given a trait `trait_ref`, iterates the vtable entries\n+/// that come from `trait_ref`, including its supertraits.\n+#[inline] // FIXME(#35870): avoid closures being unexported due to `impl Trait`.\n+fn vtable_methods<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n+    debug!(\"vtable_methods({:?})\", trait_ref);\n+\n+    tcx.arena.alloc_from_iter(supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n+        let trait_methods = tcx\n+            .associated_items(trait_ref.def_id())\n+            .in_definition_order()\n+            .filter(|item| item.kind == ty::AssocKind::Method);\n+\n+        // Now list each method's DefId and InternalSubsts (for within its trait).\n+        // If the method can never be called from this object, produce None.\n+        trait_methods.map(move |trait_method| {\n+            debug!(\"vtable_methods: trait_method={:?}\", trait_method);\n+            let def_id = trait_method.def_id;\n+\n+            // Some methods cannot be called on an object; skip those.\n+            if !is_vtable_safe_method(tcx, trait_ref.def_id(), &trait_method) {\n+                debug!(\"vtable_methods: not vtable safe\");\n+                return None;\n+            }\n+\n+            // The method may have some early-bound lifetimes; add regions for those.\n+            let substs = trait_ref.map_bound(|trait_ref| {\n+                InternalSubsts::for_item(tcx, def_id, |param, _| match param.kind {\n+                    GenericParamDefKind::Lifetime => tcx.lifetimes.re_erased.into(),\n+                    GenericParamDefKind::Type { .. } | GenericParamDefKind::Const => {\n+                        trait_ref.substs[param.index as usize]\n+                    }\n+                })\n+            });\n+\n+            // The trait type may have higher-ranked lifetimes in it;\n+            // erase them if they appear, so that we get the type\n+            // at some particular call site.\n+            let substs =\n+                tcx.normalize_erasing_late_bound_regions(ty::ParamEnv::reveal_all(), &substs);\n+\n+            // It's possible that the method relies on where-clauses that\n+            // do not hold for this particular set of type parameters.\n+            // Note that this method could then never be called, so we\n+            // do not want to try and codegen it, in that case (see #23435).\n+            let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n+            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n+                debug!(\"vtable_methods: predicates do not hold\");\n+                return None;\n+            }\n+\n+            Some((def_id, substs))\n+        })\n+    }))\n+}\n+\n+pub fn provide(providers: &mut ty::query::Providers<'_>) {\n+    object_safety::provide(providers);\n+    *providers = ty::query::Providers {\n+        specialization_graph_of: specialize::specialization_graph_provider,\n+        specializes: specialize::specializes,\n+        codegen_fulfill_obligation: codegen::codegen_fulfill_obligation,\n+        vtable_methods,\n+        substitute_normalize_and_test_predicates,\n+        ..*providers\n+    };\n+}"}, {"sha": "d0d41f3ae32ad33d117635b5d756d106d0465883", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -11,6 +11,7 @@\n use super::elaborate_predicates;\n \n use crate::infer::TyCtxtInferExt;\n+use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};", "previous_filename": "src/librustc_infer/traits/object_safety.rs"}, {"sha": "19260293ee627cec53f6b1b20c657d45c18494cb", "filename": "src/librustc_trait_selection/traits/on_unimplemented.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fon_unimplemented.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/on_unimplemented.rs"}, {"sha": "dde78aa4357e9d0240ab5ead86d52d490b9917f4", "filename": "src/librustc_trait_selection/traits/project.rs", "status": "added", "additions": 1511, "deletions": 0, "changes": 1511, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fproject.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -0,0 +1,1511 @@\n+//! Code for projecting associated types out of trait references.\n+\n+use super::elaborate_predicates;\n+use super::specialization_graph;\n+use super::translate_substs;\n+use super::util;\n+use super::MismatchedProjectionTypes;\n+use super::Obligation;\n+use super::ObligationCause;\n+use super::PredicateObligation;\n+use super::Selection;\n+use super::SelectionContext;\n+use super::SelectionError;\n+use super::{Normalized, NormalizedTy, ProjectionCacheEntry, ProjectionCacheKey};\n+use super::{VtableClosureData, VtableFnPointerData, VtableGeneratorData, VtableImplData};\n+\n+use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n+use crate::traits::error_reporting::InferCtxtExt;\n+use rustc::ty::fold::{TypeFoldable, TypeFolder};\n+use rustc::ty::subst::{InternalSubsts, Subst};\n+use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc_ast::ast::Ident;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::sym;\n+use rustc_span::DUMMY_SP;\n+\n+pub use rustc::traits::Reveal;\n+\n+pub type PolyProjectionObligation<'tcx> = Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n+\n+pub type ProjectionObligation<'tcx> = Obligation<'tcx, ty::ProjectionPredicate<'tcx>>;\n+\n+pub type ProjectionTyObligation<'tcx> = Obligation<'tcx, ty::ProjectionTy<'tcx>>;\n+\n+/// When attempting to resolve `<T as TraitRef>::Name` ...\n+#[derive(Debug)]\n+pub enum ProjectionTyError<'tcx> {\n+    /// ...we found multiple sources of information and couldn't resolve the ambiguity.\n+    TooManyCandidates,\n+\n+    /// ...an error occurred matching `T : TraitRef`\n+    TraitSelectionError(SelectionError<'tcx>),\n+}\n+\n+#[derive(PartialEq, Eq, Debug)]\n+enum ProjectionTyCandidate<'tcx> {\n+    // from a where-clause in the env or object type\n+    ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n+\n+    // from the definition of `Trait` when you have something like <<A as Trait>::B as Trait2>::C\n+    TraitDef(ty::PolyProjectionPredicate<'tcx>),\n+\n+    // from a \"impl\" (or a \"pseudo-impl\" returned by select)\n+    Select(Selection<'tcx>),\n+}\n+\n+enum ProjectionTyCandidateSet<'tcx> {\n+    None,\n+    Single(ProjectionTyCandidate<'tcx>),\n+    Ambiguous,\n+    Error(SelectionError<'tcx>),\n+}\n+\n+impl<'tcx> ProjectionTyCandidateSet<'tcx> {\n+    fn mark_ambiguous(&mut self) {\n+        *self = ProjectionTyCandidateSet::Ambiguous;\n+    }\n+\n+    fn mark_error(&mut self, err: SelectionError<'tcx>) {\n+        *self = ProjectionTyCandidateSet::Error(err);\n+    }\n+\n+    // Returns true if the push was successful, or false if the candidate\n+    // was discarded -- this could be because of ambiguity, or because\n+    // a higher-priority candidate is already there.\n+    fn push_candidate(&mut self, candidate: ProjectionTyCandidate<'tcx>) -> bool {\n+        use self::ProjectionTyCandidate::*;\n+        use self::ProjectionTyCandidateSet::*;\n+\n+        // This wacky variable is just used to try and\n+        // make code readable and avoid confusing paths.\n+        // It is assigned a \"value\" of `()` only on those\n+        // paths in which we wish to convert `*self` to\n+        // ambiguous (and return false, because the candidate\n+        // was not used). On other paths, it is not assigned,\n+        // and hence if those paths *could* reach the code that\n+        // comes after the match, this fn would not compile.\n+        let convert_to_ambiguous;\n+\n+        match self {\n+            None => {\n+                *self = Single(candidate);\n+                return true;\n+            }\n+\n+            Single(current) => {\n+                // Duplicates can happen inside ParamEnv. In the case, we\n+                // perform a lazy deduplication.\n+                if current == &candidate {\n+                    return false;\n+                }\n+\n+                // Prefer where-clauses. As in select, if there are multiple\n+                // candidates, we prefer where-clause candidates over impls.  This\n+                // may seem a bit surprising, since impls are the source of\n+                // \"truth\" in some sense, but in fact some of the impls that SEEM\n+                // applicable are not, because of nested obligations. Where\n+                // clauses are the safer choice. See the comment on\n+                // `select::SelectionCandidate` and #21974 for more details.\n+                match (current, candidate) {\n+                    (ParamEnv(..), ParamEnv(..)) => convert_to_ambiguous = (),\n+                    (ParamEnv(..), _) => return false,\n+                    (_, ParamEnv(..)) => unreachable!(),\n+                    (_, _) => convert_to_ambiguous = (),\n+                }\n+            }\n+\n+            Ambiguous | Error(..) => {\n+                return false;\n+            }\n+        }\n+\n+        // We only ever get here when we moved from a single candidate\n+        // to ambiguous.\n+        let () = convert_to_ambiguous;\n+        *self = Ambiguous;\n+        false\n+    }\n+}\n+\n+/// Evaluates constraints of the form:\n+///\n+///     for<...> <T as Trait>::U == V\n+///\n+/// If successful, this may result in additional obligations. Also returns\n+/// the projection cache key used to track these additional obligations.\n+pub fn poly_project_and_unify_type<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &PolyProjectionObligation<'tcx>,\n+) -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>> {\n+    debug!(\"poly_project_and_unify_type(obligation={:?})\", obligation);\n+\n+    let infcx = selcx.infcx();\n+    infcx.commit_if_ok(|snapshot| {\n+        let (placeholder_predicate, placeholder_map) =\n+            infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n+\n+        let placeholder_obligation = obligation.with(placeholder_predicate);\n+        let result = project_and_unify_type(selcx, &placeholder_obligation)?;\n+        infcx\n+            .leak_check(false, &placeholder_map, snapshot)\n+            .map_err(|err| MismatchedProjectionTypes { err })?;\n+        Ok(result)\n+    })\n+}\n+\n+/// Evaluates constraints of the form:\n+///\n+///     <T as Trait>::U == V\n+///\n+/// If successful, this may result in additional obligations.\n+fn project_and_unify_type<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionObligation<'tcx>,\n+) -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>> {\n+    debug!(\"project_and_unify_type(obligation={:?})\", obligation);\n+\n+    let mut obligations = vec![];\n+    let normalized_ty = match opt_normalize_projection_type(\n+        selcx,\n+        obligation.param_env,\n+        obligation.predicate.projection_ty,\n+        obligation.cause.clone(),\n+        obligation.recursion_depth,\n+        &mut obligations,\n+    ) {\n+        Some(n) => n,\n+        None => return Ok(None),\n+    };\n+\n+    debug!(\n+        \"project_and_unify_type: normalized_ty={:?} obligations={:?}\",\n+        normalized_ty, obligations\n+    );\n+\n+    let infcx = selcx.infcx();\n+    match infcx\n+        .at(&obligation.cause, obligation.param_env)\n+        .eq(normalized_ty, obligation.predicate.ty)\n+    {\n+        Ok(InferOk { obligations: inferred_obligations, value: () }) => {\n+            obligations.extend(inferred_obligations);\n+            Ok(Some(obligations))\n+        }\n+        Err(err) => {\n+            debug!(\"project_and_unify_type: equating types encountered error {:?}\", err);\n+            Err(MismatchedProjectionTypes { err })\n+        }\n+    }\n+}\n+\n+/// Normalizes any associated type projections in `value`, replacing\n+/// them with a fully resolved type where possible. The return value\n+/// combines the normalized result and any additional obligations that\n+/// were incurred as result.\n+pub fn normalize<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    value: &T,\n+) -> Normalized<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    let mut obligations = Vec::new();\n+    let value = normalize_to(selcx, param_env, cause, value, &mut obligations);\n+    Normalized { value, obligations }\n+}\n+\n+pub fn normalize_to<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    value: &T,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    normalize_with_depth_to(selcx, param_env, cause, 0, value, obligations)\n+}\n+\n+/// As `normalize`, but with a custom depth.\n+pub fn normalize_with_depth<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    value: &T,\n+) -> Normalized<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    let mut obligations = Vec::new();\n+    let value = normalize_with_depth_to(selcx, param_env, cause, depth, value, &mut obligations);\n+    Normalized { value, obligations }\n+}\n+\n+pub fn normalize_with_depth_to<'a, 'b, 'tcx, T>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    value: &T,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> T\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n+    debug!(\"normalize_with_depth(depth={}, value={:?})\", depth, value);\n+    let mut normalizer = AssocTypeNormalizer::new(selcx, param_env, cause, depth, obligations);\n+    let result = normalizer.fold(value);\n+    debug!(\n+        \"normalize_with_depth: depth={} result={:?} with {} obligations\",\n+        depth,\n+        result,\n+        normalizer.obligations.len()\n+    );\n+    debug!(\"normalize_with_depth: depth={} obligations={:?}\", depth, normalizer.obligations);\n+    result\n+}\n+\n+struct AssocTypeNormalizer<'a, 'b, 'tcx> {\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n+    depth: usize,\n+}\n+\n+impl<'a, 'b, 'tcx> AssocTypeNormalizer<'a, 'b, 'tcx> {\n+    fn new(\n+        selcx: &'a mut SelectionContext<'b, 'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        depth: usize,\n+        obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n+    ) -> AssocTypeNormalizer<'a, 'b, 'tcx> {\n+        AssocTypeNormalizer { selcx, param_env, cause, obligations, depth }\n+    }\n+\n+    fn fold<T: TypeFoldable<'tcx>>(&mut self, value: &T) -> T {\n+        let value = self.selcx.infcx().resolve_vars_if_possible(value);\n+\n+        if !value.has_projections() { value } else { value.fold_with(self) }\n+    }\n+}\n+\n+impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n+    fn tcx<'c>(&'c self) -> TyCtxt<'tcx> {\n+        self.selcx.tcx()\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if !ty.has_projections() {\n+            return ty;\n+        }\n+        // We don't want to normalize associated types that occur inside of region\n+        // binders, because they may contain bound regions, and we can't cope with that.\n+        //\n+        // Example:\n+        //\n+        //     for<'a> fn(<T as Foo<&'a>>::A)\n+        //\n+        // Instead of normalizing `<T as Foo<&'a>>::A` here, we'll\n+        // normalize it when we instantiate those bound regions (which\n+        // should occur eventually).\n+\n+        let ty = ty.super_fold_with(self);\n+        match ty.kind {\n+            ty::Opaque(def_id, substs) if !substs.has_escaping_bound_vars() => {\n+                // (*)\n+                // Only normalize `impl Trait` after type-checking, usually in codegen.\n+                match self.param_env.reveal {\n+                    Reveal::UserFacing => ty,\n+\n+                    Reveal::All => {\n+                        let recursion_limit = *self.tcx().sess.recursion_limit.get();\n+                        if self.depth >= recursion_limit {\n+                            let obligation = Obligation::with_depth(\n+                                self.cause.clone(),\n+                                recursion_limit,\n+                                self.param_env,\n+                                ty,\n+                            );\n+                            self.selcx.infcx().report_overflow_error(&obligation, true);\n+                        }\n+\n+                        let generic_ty = self.tcx().type_of(def_id);\n+                        let concrete_ty = generic_ty.subst(self.tcx(), substs);\n+                        self.depth += 1;\n+                        let folded_ty = self.fold_ty(concrete_ty);\n+                        self.depth -= 1;\n+                        folded_ty\n+                    }\n+                }\n+            }\n+\n+            ty::Projection(ref data) if !data.has_escaping_bound_vars() => {\n+                // (*)\n+\n+                // (*) This is kind of hacky -- we need to be able to\n+                // handle normalization within binders because\n+                // otherwise we wind up a need to normalize when doing\n+                // trait matching (since you can have a trait\n+                // obligation like `for<'a> T::B : Fn(&'a int)`), but\n+                // we can't normalize with bound regions in scope. So\n+                // far now we just ignore binders but only normalize\n+                // if all bound regions are gone (and then we still\n+                // have to renormalize whenever we instantiate a\n+                // binder). It would be better to normalize in a\n+                // binding-aware fashion.\n+\n+                let normalized_ty = normalize_projection_type(\n+                    self.selcx,\n+                    self.param_env,\n+                    *data,\n+                    self.cause.clone(),\n+                    self.depth,\n+                    &mut self.obligations,\n+                );\n+                debug!(\n+                    \"AssocTypeNormalizer: depth={} normalized {:?} to {:?}, \\\n+                     now with {} obligations\",\n+                    self.depth,\n+                    ty,\n+                    normalized_ty,\n+                    self.obligations.len()\n+                );\n+                normalized_ty\n+            }\n+\n+            _ => ty,\n+        }\n+    }\n+\n+    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        constant.eval(self.selcx.tcx(), self.param_env)\n+    }\n+}\n+\n+/// The guts of `normalize`: normalize a specific projection like `<T\n+/// as Trait>::Item`. The result is always a type (and possibly\n+/// additional obligations). If ambiguity arises, which implies that\n+/// there are unresolved type variables in the projection, we will\n+/// substitute a fresh type variable `$X` and generate a new\n+/// obligation `<T as Trait>::Item == $X` for later.\n+pub fn normalize_projection_type<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Ty<'tcx> {\n+    opt_normalize_projection_type(\n+        selcx,\n+        param_env,\n+        projection_ty,\n+        cause.clone(),\n+        depth,\n+        obligations,\n+    )\n+    .unwrap_or_else(move || {\n+        // if we bottom out in ambiguity, create a type variable\n+        // and a deferred predicate to resolve this when more type\n+        // information is available.\n+\n+        let tcx = selcx.infcx().tcx;\n+        let def_id = projection_ty.item_def_id;\n+        let ty_var = selcx.infcx().next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::NormalizeProjectionType,\n+            span: tcx.def_span(def_id),\n+        });\n+        let projection = ty::Binder::dummy(ty::ProjectionPredicate { projection_ty, ty: ty_var });\n+        let obligation =\n+            Obligation::with_depth(cause, depth + 1, param_env, projection.to_predicate());\n+        obligations.push(obligation);\n+        ty_var\n+    })\n+}\n+\n+/// The guts of `normalize`: normalize a specific projection like `<T\n+/// as Trait>::Item`. The result is always a type (and possibly\n+/// additional obligations). Returns `None` in the case of ambiguity,\n+/// which indicates that there are unbound type variables.\n+///\n+/// This function used to return `Option<NormalizedTy<'tcx>>`, which contains a\n+/// `Ty<'tcx>` and an obligations vector. But that obligation vector was very\n+/// often immediately appended to another obligations vector. So now this\n+/// function takes an obligations vector and appends to it directly, which is\n+/// slightly uglier but avoids the need for an extra short-lived allocation.\n+fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n+    selcx: &'a mut SelectionContext<'b, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+    obligations: &mut Vec<PredicateObligation<'tcx>>,\n+) -> Option<Ty<'tcx>> {\n+    let infcx = selcx.infcx();\n+\n+    let projection_ty = infcx.resolve_vars_if_possible(&projection_ty);\n+    let cache_key = ProjectionCacheKey::new(projection_ty);\n+\n+    debug!(\n+        \"opt_normalize_projection_type(\\\n+         projection_ty={:?}, \\\n+         depth={})\",\n+        projection_ty, depth\n+    );\n+\n+    // FIXME(#20304) For now, I am caching here, which is good, but it\n+    // means we don't capture the type variables that are created in\n+    // the case of ambiguity. Which means we may create a large stream\n+    // of such variables. OTOH, if we move the caching up a level, we\n+    // would not benefit from caching when proving `T: Trait<U=Foo>`\n+    // bounds. It might be the case that we want two distinct caches,\n+    // or else another kind of cache entry.\n+\n+    let cache_result = infcx.inner.borrow_mut().projection_cache.try_start(cache_key);\n+    match cache_result {\n+        Ok(()) => {}\n+        Err(ProjectionCacheEntry::Ambiguous) => {\n+            // If we found ambiguity the last time, that means we will continue\n+            // to do so until some type in the key changes (and we know it\n+            // hasn't, because we just fully resolved it).\n+            debug!(\n+                \"opt_normalize_projection_type: \\\n+                 found cache entry: ambiguous\"\n+            );\n+            return None;\n+        }\n+        Err(ProjectionCacheEntry::InProgress) => {\n+            // If while normalized A::B, we are asked to normalize\n+            // A::B, just return A::B itself. This is a conservative\n+            // answer, in the sense that A::B *is* clearly equivalent\n+            // to A::B, though there may be a better value we can\n+            // find.\n+\n+            // Under lazy normalization, this can arise when\n+            // bootstrapping.  That is, imagine an environment with a\n+            // where-clause like `A::B == u32`. Now, if we are asked\n+            // to normalize `A::B`, we will want to check the\n+            // where-clauses in scope. So we will try to unify `A::B`\n+            // with `A::B`, which can trigger a recursive\n+            // normalization. In that case, I think we will want this code:\n+            //\n+            // ```\n+            // let ty = selcx.tcx().mk_projection(projection_ty.item_def_id,\n+            //                                    projection_ty.substs;\n+            // return Some(NormalizedTy { value: v, obligations: vec![] });\n+            // ```\n+\n+            debug!(\n+                \"opt_normalize_projection_type: \\\n+                 found cache entry: in-progress\"\n+            );\n+\n+            // But for now, let's classify this as an overflow:\n+            let recursion_limit = *selcx.tcx().sess.recursion_limit.get();\n+            let obligation =\n+                Obligation::with_depth(cause, recursion_limit, param_env, projection_ty);\n+            selcx.infcx().report_overflow_error(&obligation, false);\n+        }\n+        Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n+            // This is the hottest path in this function.\n+            //\n+            // If we find the value in the cache, then return it along\n+            // with the obligations that went along with it. Note\n+            // that, when using a fulfillment context, these\n+            // obligations could in principle be ignored: they have\n+            // already been registered when the cache entry was\n+            // created (and hence the new ones will quickly be\n+            // discarded as duplicated). But when doing trait\n+            // evaluation this is not the case, and dropping the trait\n+            // evaluations can causes ICEs (e.g., #43132).\n+            debug!(\n+                \"opt_normalize_projection_type: \\\n+                 found normalized ty `{:?}`\",\n+                ty\n+            );\n+\n+            // Once we have inferred everything we need to know, we\n+            // can ignore the `obligations` from that point on.\n+            if infcx.unresolved_type_vars(&ty.value).is_none() {\n+                infcx.inner.borrow_mut().projection_cache.complete_normalized(cache_key, &ty);\n+            // No need to extend `obligations`.\n+            } else {\n+                obligations.extend(ty.obligations);\n+            }\n+\n+            obligations.push(get_paranoid_cache_value_obligation(\n+                infcx,\n+                param_env,\n+                projection_ty,\n+                cause,\n+                depth,\n+            ));\n+            return Some(ty.value);\n+        }\n+        Err(ProjectionCacheEntry::Error) => {\n+            debug!(\n+                \"opt_normalize_projection_type: \\\n+                 found error\"\n+            );\n+            let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n+            obligations.extend(result.obligations);\n+            return Some(result.value);\n+        }\n+    }\n+\n+    let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n+    match project_type(selcx, &obligation) {\n+        Ok(ProjectedTy::Progress(Progress {\n+            ty: projected_ty,\n+            obligations: mut projected_obligations,\n+        })) => {\n+            // if projection succeeded, then what we get out of this\n+            // is also non-normalized (consider: it was derived from\n+            // an impl, where-clause etc) and hence we must\n+            // re-normalize it\n+\n+            debug!(\n+                \"opt_normalize_projection_type: \\\n+                 projected_ty={:?} \\\n+                 depth={} \\\n+                 projected_obligations={:?}\",\n+                projected_ty, depth, projected_obligations\n+            );\n+\n+            let result = if projected_ty.has_projections() {\n+                let mut normalizer = AssocTypeNormalizer::new(\n+                    selcx,\n+                    param_env,\n+                    cause,\n+                    depth + 1,\n+                    &mut projected_obligations,\n+                );\n+                let normalized_ty = normalizer.fold(&projected_ty);\n+\n+                debug!(\n+                    \"opt_normalize_projection_type: \\\n+                     normalized_ty={:?} depth={}\",\n+                    normalized_ty, depth\n+                );\n+\n+                Normalized { value: normalized_ty, obligations: projected_obligations }\n+            } else {\n+                Normalized { value: projected_ty, obligations: projected_obligations }\n+            };\n+\n+            let cache_value = prune_cache_value_obligations(infcx, &result);\n+            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, cache_value);\n+            obligations.extend(result.obligations);\n+            Some(result.value)\n+        }\n+        Ok(ProjectedTy::NoProgress(projected_ty)) => {\n+            debug!(\n+                \"opt_normalize_projection_type: \\\n+                 projected_ty={:?} no progress\",\n+                projected_ty\n+            );\n+            let result = Normalized { value: projected_ty, obligations: vec![] };\n+            infcx.inner.borrow_mut().projection_cache.insert_ty(cache_key, result.clone());\n+            // No need to extend `obligations`.\n+            Some(result.value)\n+        }\n+        Err(ProjectionTyError::TooManyCandidates) => {\n+            debug!(\n+                \"opt_normalize_projection_type: \\\n+                 too many candidates\"\n+            );\n+            infcx.inner.borrow_mut().projection_cache.ambiguous(cache_key);\n+            None\n+        }\n+        Err(ProjectionTyError::TraitSelectionError(_)) => {\n+            debug!(\"opt_normalize_projection_type: ERROR\");\n+            // if we got an error processing the `T as Trait` part,\n+            // just return `ty::err` but add the obligation `T :\n+            // Trait`, which when processed will cause the error to be\n+            // reported later\n+\n+            infcx.inner.borrow_mut().projection_cache.error(cache_key);\n+            let result = normalize_to_error(selcx, param_env, projection_ty, cause, depth);\n+            obligations.extend(result.obligations);\n+            Some(result.value)\n+        }\n+    }\n+}\n+\n+/// If there are unresolved type variables, then we need to include\n+/// any subobligations that bind them, at least until those type\n+/// variables are fully resolved.\n+fn prune_cache_value_obligations<'a, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    result: &NormalizedTy<'tcx>,\n+) -> NormalizedTy<'tcx> {\n+    if infcx.unresolved_type_vars(&result.value).is_none() {\n+        return NormalizedTy { value: result.value, obligations: vec![] };\n+    }\n+\n+    let mut obligations: Vec<_> = result\n+        .obligations\n+        .iter()\n+        .filter(|obligation| match obligation.predicate {\n+            // We found a `T: Foo<X = U>` predicate, let's check\n+            // if `U` references any unresolved type\n+            // variables. In principle, we only care if this\n+            // projection can help resolve any of the type\n+            // variables found in `result.value` -- but we just\n+            // check for any type variables here, for fear of\n+            // indirect obligations (e.g., we project to `?0`,\n+            // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n+            // ?0>`).\n+            ty::Predicate::Projection(ref data) => infcx.unresolved_type_vars(&data.ty()).is_some(),\n+\n+            // We are only interested in `T: Foo<X = U>` predicates, whre\n+            // `U` references one of `unresolved_type_vars`. =)\n+            _ => false,\n+        })\n+        .cloned()\n+        .collect();\n+\n+    obligations.shrink_to_fit();\n+\n+    NormalizedTy { value: result.value, obligations }\n+}\n+\n+/// Whenever we give back a cache result for a projection like `<T as\n+/// Trait>::Item ==> X`, we *always* include the obligation to prove\n+/// that `T: Trait` (we may also include some other obligations). This\n+/// may or may not be necessary -- in principle, all the obligations\n+/// that must be proven to show that `T: Trait` were also returned\n+/// when the cache was first populated. But there are some vague concerns,\n+/// and so we take the precautionary measure of including `T: Trait` in\n+/// the result:\n+///\n+/// Concern #1. The current setup is fragile. Perhaps someone could\n+/// have failed to prove the concerns from when the cache was\n+/// populated, but also not have used a snapshot, in which case the\n+/// cache could remain populated even though `T: Trait` has not been\n+/// shown. In this case, the \"other code\" is at fault -- when you\n+/// project something, you are supposed to either have a snapshot or\n+/// else prove all the resulting obligations -- but it's still easy to\n+/// get wrong.\n+///\n+/// Concern #2. Even within the snapshot, if those original\n+/// obligations are not yet proven, then we are able to do projections\n+/// that may yet turn out to be wrong. This *may* lead to some sort\n+/// of trouble, though we don't have a concrete example of how that\n+/// can occur yet. But it seems risky at best.\n+fn get_paranoid_cache_value_obligation<'a, 'tcx>(\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+) -> PredicateObligation<'tcx> {\n+    let trait_ref = projection_ty.trait_ref(infcx.tcx).to_poly_trait_ref();\n+    Obligation {\n+        cause,\n+        recursion_depth: depth,\n+        param_env,\n+        predicate: trait_ref.without_const().to_predicate(),\n+    }\n+}\n+\n+/// If we are projecting `<T as Trait>::Item`, but `T: Trait` does not\n+/// hold. In various error cases, we cannot generate a valid\n+/// normalized projection. Therefore, we create an inference variable\n+/// return an associated obligation that, when fulfilled, will lead to\n+/// an error.\n+///\n+/// Note that we used to return `Error` here, but that was quite\n+/// dubious -- the premise was that an error would *eventually* be\n+/// reported, when the obligation was processed. But in general once\n+/// you see a `Error` you are supposed to be able to assume that an\n+/// error *has been* reported, so that you can take whatever heuristic\n+/// paths you want to take. To make things worse, it was possible for\n+/// cycles to arise, where you basically had a setup like `<MyType<$0>\n+/// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0> as\n+/// Trait>::Foo> to `[type error]` would lead to an obligation of\n+/// `<MyType<[type error]> as Trait>::Foo`. We are supposed to report\n+/// an error for this obligation, but we legitimately should not,\n+/// because it contains `[type error]`. Yuck! (See issue #29857 for\n+/// one case where this arose.)\n+fn normalize_to_error<'a, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    projection_ty: ty::ProjectionTy<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    depth: usize,\n+) -> NormalizedTy<'tcx> {\n+    let trait_ref = projection_ty.trait_ref(selcx.tcx()).to_poly_trait_ref();\n+    let trait_obligation = Obligation {\n+        cause,\n+        recursion_depth: depth,\n+        param_env,\n+        predicate: trait_ref.without_const().to_predicate(),\n+    };\n+    let tcx = selcx.infcx().tcx;\n+    let def_id = projection_ty.item_def_id;\n+    let new_value = selcx.infcx().next_ty_var(TypeVariableOrigin {\n+        kind: TypeVariableOriginKind::NormalizeProjectionType,\n+        span: tcx.def_span(def_id),\n+    });\n+    Normalized { value: new_value, obligations: vec![trait_obligation] }\n+}\n+\n+enum ProjectedTy<'tcx> {\n+    Progress(Progress<'tcx>),\n+    NoProgress(Ty<'tcx>),\n+}\n+\n+struct Progress<'tcx> {\n+    ty: Ty<'tcx>,\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+}\n+\n+impl<'tcx> Progress<'tcx> {\n+    fn error(tcx: TyCtxt<'tcx>) -> Self {\n+        Progress { ty: tcx.types.err, obligations: vec![] }\n+    }\n+\n+    fn with_addl_obligations(mut self, mut obligations: Vec<PredicateObligation<'tcx>>) -> Self {\n+        debug!(\n+            \"with_addl_obligations: self.obligations.len={} obligations.len={}\",\n+            self.obligations.len(),\n+            obligations.len()\n+        );\n+\n+        debug!(\n+            \"with_addl_obligations: self.obligations={:?} obligations={:?}\",\n+            self.obligations, obligations\n+        );\n+\n+        self.obligations.append(&mut obligations);\n+        self\n+    }\n+}\n+\n+/// Computes the result of a projection type (if we can).\n+///\n+/// IMPORTANT:\n+/// - `obligation` must be fully normalized\n+fn project_type<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+) -> Result<ProjectedTy<'tcx>, ProjectionTyError<'tcx>> {\n+    debug!(\"project(obligation={:?})\", obligation);\n+\n+    let recursion_limit = *selcx.tcx().sess.recursion_limit.get();\n+    if obligation.recursion_depth >= recursion_limit {\n+        debug!(\"project: overflow!\");\n+        return Err(ProjectionTyError::TraitSelectionError(SelectionError::Overflow));\n+    }\n+\n+    let obligation_trait_ref = &obligation.predicate.trait_ref(selcx.tcx());\n+\n+    debug!(\"project: obligation_trait_ref={:?}\", obligation_trait_ref);\n+\n+    if obligation_trait_ref.references_error() {\n+        return Ok(ProjectedTy::Progress(Progress::error(selcx.tcx())));\n+    }\n+\n+    let mut candidates = ProjectionTyCandidateSet::None;\n+\n+    // Make sure that the following procedures are kept in order. ParamEnv\n+    // needs to be first because it has highest priority, and Select checks\n+    // the return value of push_candidate which assumes it's ran at last.\n+    assemble_candidates_from_param_env(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+\n+    assemble_candidates_from_trait_def(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+\n+    assemble_candidates_from_impls(selcx, obligation, &obligation_trait_ref, &mut candidates);\n+\n+    match candidates {\n+        ProjectionTyCandidateSet::Single(candidate) => Ok(ProjectedTy::Progress(\n+            confirm_candidate(selcx, obligation, &obligation_trait_ref, candidate),\n+        )),\n+        ProjectionTyCandidateSet::None => Ok(ProjectedTy::NoProgress(\n+            selcx\n+                .tcx()\n+                .mk_projection(obligation.predicate.item_def_id, obligation.predicate.substs),\n+        )),\n+        // Error occurred while trying to processing impls.\n+        ProjectionTyCandidateSet::Error(e) => Err(ProjectionTyError::TraitSelectionError(e)),\n+        // Inherent ambiguity that prevents us from even enumerating the\n+        // candidates.\n+        ProjectionTyCandidateSet::Ambiguous => Err(ProjectionTyError::TooManyCandidates),\n+    }\n+}\n+\n+/// The first thing we have to do is scan through the parameter\n+/// environment to see whether there are any projection predicates\n+/// there that can answer this question.\n+fn assemble_candidates_from_param_env<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n+    debug!(\"assemble_candidates_from_param_env(..)\");\n+    assemble_candidates_from_predicates(\n+        selcx,\n+        obligation,\n+        obligation_trait_ref,\n+        candidate_set,\n+        ProjectionTyCandidate::ParamEnv,\n+        obligation.param_env.caller_bounds.iter().cloned(),\n+    );\n+}\n+\n+/// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n+/// that the definition of `Foo` has some clues:\n+///\n+/// ```\n+/// trait Foo {\n+///     type FooT : Bar<BarT=i32>\n+/// }\n+/// ```\n+///\n+/// Here, for example, we could conclude that the result is `i32`.\n+fn assemble_candidates_from_trait_def<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n+    debug!(\"assemble_candidates_from_trait_def(..)\");\n+\n+    let tcx = selcx.tcx();\n+    // Check whether the self-type is itself a projection.\n+    let (def_id, substs) = match obligation_trait_ref.self_ty().kind {\n+        ty::Projection(ref data) => (data.trait_ref(tcx).def_id, data.substs),\n+        ty::Opaque(def_id, substs) => (def_id, substs),\n+        ty::Infer(ty::TyVar(_)) => {\n+            // If the self-type is an inference variable, then it MAY wind up\n+            // being a projected type, so induce an ambiguity.\n+            candidate_set.mark_ambiguous();\n+            return;\n+        }\n+        _ => return,\n+    };\n+\n+    // If so, extract what we know from the trait and try to come up with a good answer.\n+    let trait_predicates = tcx.predicates_of(def_id);\n+    let bounds = trait_predicates.instantiate(tcx, substs);\n+    let bounds = elaborate_predicates(tcx, bounds.predicates);\n+    assemble_candidates_from_predicates(\n+        selcx,\n+        obligation,\n+        obligation_trait_ref,\n+        candidate_set,\n+        ProjectionTyCandidate::TraitDef,\n+        bounds,\n+    )\n+}\n+\n+fn assemble_candidates_from_predicates<'cx, 'tcx, I>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n+    env_predicates: I,\n+) where\n+    I: IntoIterator<Item = ty::Predicate<'tcx>>,\n+{\n+    debug!(\"assemble_candidates_from_predicates(obligation={:?})\", obligation);\n+    let infcx = selcx.infcx();\n+    for predicate in env_predicates {\n+        debug!(\"assemble_candidates_from_predicates: predicate={:?}\", predicate);\n+        if let ty::Predicate::Projection(data) = predicate {\n+            let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n+\n+            let is_match = same_def_id\n+                && infcx.probe(|_| {\n+                    let data_poly_trait_ref = data.to_poly_trait_ref(infcx.tcx);\n+                    let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+                    infcx\n+                        .at(&obligation.cause, obligation.param_env)\n+                        .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+                        .map(|InferOk { obligations: _, value: () }| {\n+                            // FIXME(#32730) -- do we need to take obligations\n+                            // into account in any way? At the moment, no.\n+                        })\n+                        .is_ok()\n+                });\n+\n+            debug!(\n+                \"assemble_candidates_from_predicates: candidate={:?} \\\n+                 is_match={} same_def_id={}\",\n+                data, is_match, same_def_id\n+            );\n+\n+            if is_match {\n+                candidate_set.push_candidate(ctor(data));\n+            }\n+        }\n+    }\n+}\n+\n+fn assemble_candidates_from_impls<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+) {\n+    // If we are resolving `<T as TraitRef<...>>::Item == Type`,\n+    // start out by selecting the predicate `T as TraitRef<...>`:\n+    let poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+    let trait_obligation = obligation.with(poly_trait_ref.to_poly_trait_predicate());\n+    let _ = selcx.infcx().commit_if_ok(|_| {\n+        let vtable = match selcx.select(&trait_obligation) {\n+            Ok(Some(vtable)) => vtable,\n+            Ok(None) => {\n+                candidate_set.mark_ambiguous();\n+                return Err(());\n+            }\n+            Err(e) => {\n+                debug!(\"assemble_candidates_from_impls: selection error {:?}\", e);\n+                candidate_set.mark_error(e);\n+                return Err(());\n+            }\n+        };\n+\n+        let eligible = match &vtable {\n+            super::VtableClosure(_)\n+            | super::VtableGenerator(_)\n+            | super::VtableFnPointer(_)\n+            | super::VtableObject(_)\n+            | super::VtableTraitAlias(_) => {\n+                debug!(\"assemble_candidates_from_impls: vtable={:?}\", vtable);\n+                true\n+            }\n+            super::VtableImpl(impl_data) => {\n+                // We have to be careful when projecting out of an\n+                // impl because of specialization. If we are not in\n+                // codegen (i.e., projection mode is not \"any\"), and the\n+                // impl's type is declared as default, then we disable\n+                // projection (even if the trait ref is fully\n+                // monomorphic). In the case where trait ref is not\n+                // fully monomorphic (i.e., includes type parameters),\n+                // this is because those type parameters may\n+                // ultimately be bound to types from other crates that\n+                // may have specialized impls we can't see. In the\n+                // case where the trait ref IS fully monomorphic, this\n+                // is a policy decision that we made in the RFC in\n+                // order to preserve flexibility for the crate that\n+                // defined the specializable impl to specialize later\n+                // for existing types.\n+                //\n+                // In either case, we handle this by not adding a\n+                // candidate for an impl if it contains a `default`\n+                // type.\n+                //\n+                // NOTE: This should be kept in sync with the similar code in\n+                // `rustc::ty::instance::resolve_associated_item()`.\n+                let node_item =\n+                    assoc_ty_def(selcx, impl_data.impl_def_id, obligation.predicate.item_def_id);\n+\n+                let is_default = if node_item.node.is_from_trait() {\n+                    // If true, the impl inherited a `type Foo = Bar`\n+                    // given in the trait, which is implicitly default.\n+                    // Otherwise, the impl did not specify `type` and\n+                    // neither did the trait:\n+                    //\n+                    // ```rust\n+                    // trait Foo { type T; }\n+                    // impl Foo for Bar { }\n+                    // ```\n+                    //\n+                    // This is an error, but it will be\n+                    // reported in `check_impl_items_against_trait`.\n+                    // We accept it here but will flag it as\n+                    // an error when we confirm the candidate\n+                    // (which will ultimately lead to `normalize_to_error`\n+                    // being invoked).\n+                    false\n+                } else {\n+                    // If we're looking at a trait *impl*, the item is\n+                    // specializable if the impl or the item are marked\n+                    // `default`.\n+                    node_item.item.defaultness.is_default()\n+                        || super::util::impl_is_default(selcx.tcx(), node_item.node.def_id())\n+                };\n+\n+                match is_default {\n+                    // Non-specializable items are always projectable\n+                    false => true,\n+\n+                    // Only reveal a specializable default if we're past type-checking\n+                    // and the obligation is monomorphic, otherwise passes such as\n+                    // transmute checking and polymorphic MIR optimizations could\n+                    // get a result which isn't correct for all monomorphizations.\n+                    true if obligation.param_env.reveal == Reveal::All => {\n+                        // NOTE(eddyb) inference variables can resolve to parameters, so\n+                        // assume `poly_trait_ref` isn't monomorphic, if it contains any.\n+                        let poly_trait_ref =\n+                            selcx.infcx().resolve_vars_if_possible(&poly_trait_ref);\n+                        !poly_trait_ref.needs_infer() && !poly_trait_ref.needs_subst()\n+                    }\n+\n+                    true => {\n+                        debug!(\n+                            \"assemble_candidates_from_impls: not eligible due to default: \\\n+                             assoc_ty={} predicate={}\",\n+                            selcx.tcx().def_path_str(node_item.item.def_id),\n+                            obligation.predicate,\n+                        );\n+                        false\n+                    }\n+                }\n+            }\n+            super::VtableParam(..) => {\n+                // This case tell us nothing about the value of an\n+                // associated type. Consider:\n+                //\n+                // ```\n+                // trait SomeTrait { type Foo; }\n+                // fn foo<T:SomeTrait>(...) { }\n+                // ```\n+                //\n+                // If the user writes `<T as SomeTrait>::Foo`, then the `T\n+                // : SomeTrait` binding does not help us decide what the\n+                // type `Foo` is (at least, not more specifically than\n+                // what we already knew).\n+                //\n+                // But wait, you say! What about an example like this:\n+                //\n+                // ```\n+                // fn bar<T:SomeTrait<Foo=usize>>(...) { ... }\n+                // ```\n+                //\n+                // Doesn't the `T : Sometrait<Foo=usize>` predicate help\n+                // resolve `T::Foo`? And of course it does, but in fact\n+                // that single predicate is desugared into two predicates\n+                // in the compiler: a trait predicate (`T : SomeTrait`) and a\n+                // projection. And the projection where clause is handled\n+                // in `assemble_candidates_from_param_env`.\n+                false\n+            }\n+            super::VtableAutoImpl(..) | super::VtableBuiltin(..) => {\n+                // These traits have no associated types.\n+                span_bug!(\n+                    obligation.cause.span,\n+                    \"Cannot project an associated type from `{:?}`\",\n+                    vtable\n+                );\n+            }\n+        };\n+\n+        if eligible {\n+            if candidate_set.push_candidate(ProjectionTyCandidate::Select(vtable)) {\n+                Ok(())\n+            } else {\n+                Err(())\n+            }\n+        } else {\n+            Err(())\n+        }\n+    });\n+}\n+\n+fn confirm_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    candidate: ProjectionTyCandidate<'tcx>,\n+) -> Progress<'tcx> {\n+    debug!(\"confirm_candidate(candidate={:?}, obligation={:?})\", candidate, obligation);\n+\n+    match candidate {\n+        ProjectionTyCandidate::ParamEnv(poly_projection)\n+        | ProjectionTyCandidate::TraitDef(poly_projection) => {\n+            confirm_param_env_candidate(selcx, obligation, poly_projection)\n+        }\n+\n+        ProjectionTyCandidate::Select(vtable) => {\n+            confirm_select_candidate(selcx, obligation, obligation_trait_ref, vtable)\n+        }\n+    }\n+}\n+\n+fn confirm_select_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+    vtable: Selection<'tcx>,\n+) -> Progress<'tcx> {\n+    match vtable {\n+        super::VtableImpl(data) => confirm_impl_candidate(selcx, obligation, data),\n+        super::VtableGenerator(data) => confirm_generator_candidate(selcx, obligation, data),\n+        super::VtableClosure(data) => confirm_closure_candidate(selcx, obligation, data),\n+        super::VtableFnPointer(data) => confirm_fn_pointer_candidate(selcx, obligation, data),\n+        super::VtableObject(_) => confirm_object_candidate(selcx, obligation, obligation_trait_ref),\n+        super::VtableAutoImpl(..)\n+        | super::VtableParam(..)\n+        | super::VtableBuiltin(..)\n+        | super::VtableTraitAlias(..) =>\n+        // we don't create Select candidates with this kind of resolution\n+        {\n+            span_bug!(\n+                obligation.cause.span,\n+                \"Cannot project an associated type from `{:?}`\",\n+                vtable\n+            )\n+        }\n+    }\n+}\n+\n+fn confirm_object_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    obligation_trait_ref: &ty::TraitRef<'tcx>,\n+) -> Progress<'tcx> {\n+    let self_ty = obligation_trait_ref.self_ty();\n+    let object_ty = selcx.infcx().shallow_resolve(self_ty);\n+    debug!(\"confirm_object_candidate(object_ty={:?})\", object_ty);\n+    let data = match object_ty.kind {\n+        ty::Dynamic(ref data, ..) => data,\n+        _ => span_bug!(\n+            obligation.cause.span,\n+            \"confirm_object_candidate called with non-object: {:?}\",\n+            object_ty\n+        ),\n+    };\n+    let env_predicates = data\n+        .projection_bounds()\n+        .map(|p| p.with_self_ty(selcx.tcx(), object_ty).to_predicate())\n+        .collect();\n+    let env_predicate = {\n+        let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n+\n+        // select only those projections that are actually projecting an\n+        // item with the correct name\n+        let env_predicates = env_predicates.filter_map(|p| match p {\n+            ty::Predicate::Projection(data) => {\n+                if data.projection_def_id() == obligation.predicate.item_def_id {\n+                    Some(data)\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        });\n+\n+        // select those with a relevant trait-ref\n+        let mut env_predicates = env_predicates.filter(|data| {\n+            let data_poly_trait_ref = data.to_poly_trait_ref(selcx.tcx());\n+            let obligation_poly_trait_ref = obligation_trait_ref.to_poly_trait_ref();\n+            selcx.infcx().probe(|_| {\n+                selcx\n+                    .infcx()\n+                    .at(&obligation.cause, obligation.param_env)\n+                    .sup(obligation_poly_trait_ref, data_poly_trait_ref)\n+                    .is_ok()\n+            })\n+        });\n+\n+        // select the first matching one; there really ought to be one or\n+        // else the object type is not WF, since an object type should\n+        // include all of its projections explicitly\n+        match env_predicates.next() {\n+            Some(env_predicate) => env_predicate,\n+            None => {\n+                debug!(\n+                    \"confirm_object_candidate: no env-predicate \\\n+                     found in object type `{:?}`; ill-formed\",\n+                    object_ty\n+                );\n+                return Progress::error(selcx.tcx());\n+            }\n+        }\n+    };\n+\n+    confirm_param_env_candidate(selcx, obligation, env_predicate)\n+}\n+\n+fn confirm_generator_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    vtable: VtableGeneratorData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n+    let gen_sig = vtable.substs.as_generator().poly_sig(vtable.generator_def_id, selcx.tcx());\n+    let Normalized { value: gen_sig, obligations } = normalize_with_depth(\n+        selcx,\n+        obligation.param_env,\n+        obligation.cause.clone(),\n+        obligation.recursion_depth + 1,\n+        &gen_sig,\n+    );\n+\n+    debug!(\n+        \"confirm_generator_candidate: obligation={:?},gen_sig={:?},obligations={:?}\",\n+        obligation, gen_sig, obligations\n+    );\n+\n+    let tcx = selcx.tcx();\n+\n+    let gen_def_id = tcx.lang_items().gen_trait().unwrap();\n+\n+    let predicate = super::util::generator_trait_ref_and_outputs(\n+        tcx,\n+        gen_def_id,\n+        obligation.predicate.self_ty(),\n+        gen_sig,\n+    )\n+    .map_bound(|(trait_ref, yield_ty, return_ty)| {\n+        let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n+        let ty = if name == sym::Return {\n+            return_ty\n+        } else if name == sym::Yield {\n+            yield_ty\n+        } else {\n+            bug!()\n+        };\n+\n+        ty::ProjectionPredicate {\n+            projection_ty: ty::ProjectionTy {\n+                substs: trait_ref.substs,\n+                item_def_id: obligation.predicate.item_def_id,\n+            },\n+            ty,\n+        }\n+    });\n+\n+    confirm_param_env_candidate(selcx, obligation, predicate)\n+        .with_addl_obligations(vtable.nested)\n+        .with_addl_obligations(obligations)\n+}\n+\n+fn confirm_fn_pointer_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n+    let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n+    let sig = fn_type.fn_sig(selcx.tcx());\n+    let Normalized { value: sig, obligations } = normalize_with_depth(\n+        selcx,\n+        obligation.param_env,\n+        obligation.cause.clone(),\n+        obligation.recursion_depth + 1,\n+        &sig,\n+    );\n+\n+    confirm_callable_candidate(selcx, obligation, sig, util::TupleArgumentsFlag::Yes)\n+        .with_addl_obligations(fn_pointer_vtable.nested)\n+        .with_addl_obligations(obligations)\n+}\n+\n+fn confirm_closure_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n+    let tcx = selcx.tcx();\n+    let infcx = selcx.infcx();\n+    let closure_sig_ty = vtable.substs.as_closure().sig_ty(vtable.closure_def_id, tcx);\n+    let closure_sig = infcx.shallow_resolve(closure_sig_ty).fn_sig(tcx);\n+    let Normalized { value: closure_sig, obligations } = normalize_with_depth(\n+        selcx,\n+        obligation.param_env,\n+        obligation.cause.clone(),\n+        obligation.recursion_depth + 1,\n+        &closure_sig,\n+    );\n+\n+    debug!(\n+        \"confirm_closure_candidate: obligation={:?},closure_sig={:?},obligations={:?}\",\n+        obligation, closure_sig, obligations\n+    );\n+\n+    confirm_callable_candidate(selcx, obligation, closure_sig, util::TupleArgumentsFlag::No)\n+        .with_addl_obligations(vtable.nested)\n+        .with_addl_obligations(obligations)\n+}\n+\n+fn confirm_callable_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    fn_sig: ty::PolyFnSig<'tcx>,\n+    flag: util::TupleArgumentsFlag,\n+) -> Progress<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    debug!(\"confirm_callable_candidate({:?},{:?})\", obligation, fn_sig);\n+\n+    // the `Output` associated type is declared on `FnOnce`\n+    let fn_once_def_id = tcx.lang_items().fn_once_trait().unwrap();\n+\n+    let predicate = super::util::closure_trait_ref_and_return_type(\n+        tcx,\n+        fn_once_def_id,\n+        obligation.predicate.self_ty(),\n+        fn_sig,\n+        flag,\n+    )\n+    .map_bound(|(trait_ref, ret_type)| ty::ProjectionPredicate {\n+        projection_ty: ty::ProjectionTy::from_ref_and_name(\n+            tcx,\n+            trait_ref,\n+            Ident::with_dummy_span(rustc_hir::FN_OUTPUT_NAME),\n+        ),\n+        ty: ret_type,\n+    });\n+\n+    confirm_param_env_candidate(selcx, obligation, predicate)\n+}\n+\n+fn confirm_param_env_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    poly_cache_entry: ty::PolyProjectionPredicate<'tcx>,\n+) -> Progress<'tcx> {\n+    let infcx = selcx.infcx();\n+    let cause = &obligation.cause;\n+    let param_env = obligation.param_env;\n+\n+    let (cache_entry, _) = infcx.replace_bound_vars_with_fresh_vars(\n+        cause.span,\n+        LateBoundRegionConversionTime::HigherRankedType,\n+        &poly_cache_entry,\n+    );\n+\n+    let cache_trait_ref = cache_entry.projection_ty.trait_ref(infcx.tcx);\n+    let obligation_trait_ref = obligation.predicate.trait_ref(infcx.tcx);\n+    match infcx.at(cause, param_env).eq(cache_trait_ref, obligation_trait_ref) {\n+        Ok(InferOk { value: _, obligations }) => Progress { ty: cache_entry.ty, obligations },\n+        Err(e) => {\n+            let msg = format!(\n+                \"Failed to unify obligation `{:?}` with poly_projection `{:?}`: {:?}\",\n+                obligation, poly_cache_entry, e,\n+            );\n+            debug!(\"confirm_param_env_candidate: {}\", msg);\n+            infcx.tcx.sess.delay_span_bug(obligation.cause.span, &msg);\n+            Progress { ty: infcx.tcx.types.err, obligations: vec![] }\n+        }\n+    }\n+}\n+\n+fn confirm_impl_candidate<'cx, 'tcx>(\n+    selcx: &mut SelectionContext<'cx, 'tcx>,\n+    obligation: &ProjectionTyObligation<'tcx>,\n+    impl_vtable: VtableImplData<'tcx, PredicateObligation<'tcx>>,\n+) -> Progress<'tcx> {\n+    let tcx = selcx.tcx();\n+\n+    let VtableImplData { impl_def_id, substs, nested } = impl_vtable;\n+    let assoc_item_id = obligation.predicate.item_def_id;\n+    let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n+\n+    let param_env = obligation.param_env;\n+    let assoc_ty = assoc_ty_def(selcx, impl_def_id, assoc_item_id);\n+\n+    if !assoc_ty.item.defaultness.has_value() {\n+        // This means that the impl is missing a definition for the\n+        // associated type. This error will be reported by the type\n+        // checker method `check_impl_items_against_trait`, so here we\n+        // just return Error.\n+        debug!(\n+            \"confirm_impl_candidate: no associated type {:?} for {:?}\",\n+            assoc_ty.item.ident, obligation.predicate\n+        );\n+        return Progress { ty: tcx.types.err, obligations: nested };\n+    }\n+    let substs = obligation.predicate.substs.rebase_onto(tcx, trait_def_id, substs);\n+    let substs = translate_substs(selcx.infcx(), param_env, impl_def_id, substs, assoc_ty.node);\n+    let ty = if let ty::AssocKind::OpaqueTy = assoc_ty.item.kind {\n+        let item_substs = InternalSubsts::identity_for_item(tcx, assoc_ty.item.def_id);\n+        tcx.mk_opaque(assoc_ty.item.def_id, item_substs)\n+    } else {\n+        tcx.type_of(assoc_ty.item.def_id)\n+    };\n+    if substs.len() != tcx.generics_of(assoc_ty.item.def_id).count() {\n+        tcx.sess\n+            .delay_span_bug(DUMMY_SP, \"impl item and trait item have different parameter counts\");\n+        Progress { ty: tcx.types.err, obligations: nested }\n+    } else {\n+        Progress { ty: ty.subst(tcx, substs), obligations: nested }\n+    }\n+}\n+\n+/// Locate the definition of an associated type in the specialization hierarchy,\n+/// starting from the given impl.\n+///\n+/// Based on the \"projection mode\", this lookup may in fact only examine the\n+/// topmost impl. See the comments for `Reveal` for more details.\n+fn assoc_ty_def(\n+    selcx: &SelectionContext<'_, '_>,\n+    impl_def_id: DefId,\n+    assoc_ty_def_id: DefId,\n+) -> specialization_graph::NodeItem<ty::AssocItem> {\n+    let tcx = selcx.tcx();\n+    let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n+    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n+    let trait_def = tcx.trait_def(trait_def_id);\n+\n+    // This function may be called while we are still building the\n+    // specialization graph that is queried below (via TraidDef::ancestors()),\n+    // so, in order to avoid unnecessary infinite recursion, we manually look\n+    // for the associated item at the given impl.\n+    // If there is no such item in that impl, this function will fail with a\n+    // cycle error if the specialization graph is currently being built.\n+    let impl_node = specialization_graph::Node::Impl(impl_def_id);\n+    for item in impl_node.items(tcx) {\n+        if matches!(item.kind, ty::AssocKind::Type | ty::AssocKind::OpaqueTy)\n+            && tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id)\n+        {\n+            return specialization_graph::NodeItem {\n+                node: specialization_graph::Node::Impl(impl_def_id),\n+                item: *item,\n+            };\n+        }\n+    }\n+\n+    if let Some(assoc_item) =\n+        trait_def.ancestors(tcx, impl_def_id).leaf_def(tcx, assoc_ty_name, ty::AssocKind::Type)\n+    {\n+        assoc_item\n+    } else {\n+        // This is saying that neither the trait nor\n+        // the impl contain a definition for this\n+        // associated type.  Normally this situation\n+        // could only arise through a compiler bug --\n+        // if the user wrote a bad item name, it\n+        // should have failed in astconv.\n+        bug!(\"No associated type `{}` for {}\", assoc_ty_name, tcx.def_path_str(impl_def_id))\n+    }\n+}\n+\n+crate trait ProjectionCacheKeyExt<'tcx>: Sized {\n+    fn from_poly_projection_predicate(\n+        selcx: &mut SelectionContext<'cx, 'tcx>,\n+        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+    ) -> Option<Self>;\n+}\n+\n+impl<'tcx> ProjectionCacheKeyExt<'tcx> for ProjectionCacheKey<'tcx> {\n+    fn from_poly_projection_predicate(\n+        selcx: &mut SelectionContext<'cx, 'tcx>,\n+        predicate: &ty::PolyProjectionPredicate<'tcx>,\n+    ) -> Option<Self> {\n+        let infcx = selcx.infcx();\n+        // We don't do cross-snapshot caching of obligations with escaping regions,\n+        // so there's no cache key to use\n+        predicate.no_bound_vars().map(|predicate| {\n+            ProjectionCacheKey::new(\n+                // We don't attempt to match up with a specific type-variable state\n+                // from a specific call to `opt_normalize_projection_type` - if\n+                // there's no precise match, the original cache entry is \"stranded\"\n+                // anyway.\n+                infcx.resolve_vars_if_possible(&predicate.projection_ty),\n+            )\n+        })\n+    }\n+}"}, {"sha": "40a21b5a6ed4aa53cd45c9af5645d1677accfe64", "filename": "src/librustc_trait_selection/traits/query/dropck_outlives.rs", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -7,7 +7,11 @@ use rustc::ty::{self, Ty, TyCtxt};\n \n pub use rustc::traits::query::{DropckOutlivesResult, DtorckConstraint};\n \n-impl<'cx, 'tcx> At<'cx, 'tcx> {\n+pub trait AtExt<'tcx> {\n+    fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>>;\n+}\n+\n+impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n     /// of \"kinds\" (types, regions) that must be outlive the execution\n     /// of the destructor. These basically correspond to data that the\n@@ -25,7 +29,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     ///\n     /// [#1238]: https://github.com/rust-lang/rfcs/blob/master/text/1238-nonparametric-dropck.md\n     /// [#1327]: https://github.com/rust-lang/rfcs/blob/master/text/1327-dropck-param-eyepatch.md\n-    pub fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>> {\n+    fn dropck_outlives(&self, ty: Ty<'tcx>) -> InferOk<'tcx, Vec<GenericArg<'tcx>>> {\n         debug!(\"dropck_outlives(ty={:?}, param_env={:?})\", ty, self.param_env,);\n \n         // Quick check: there are a number of cases that we know do not require", "previous_filename": "src/librustc_infer/traits/query/dropck_outlives.rs"}, {"sha": "0569f6217da653c38c9c6bbeb6af332974fadd3a", "filename": "src/librustc_trait_selection/traits/query/evaluate_obligation.rs", "status": "renamed", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -4,10 +4,35 @@ use crate::traits::{\n     EvaluationResult, OverflowError, PredicateObligation, SelectionContext, TraitQueryMode,\n };\n \n-impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n+pub trait InferCtxtExt<'tcx> {\n+    fn predicate_may_hold(&self, obligation: &PredicateObligation<'tcx>) -> bool;\n+\n+    fn predicate_must_hold_considering_regions(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool;\n+\n+    fn predicate_must_hold_modulo_regions(&self, obligation: &PredicateObligation<'tcx>) -> bool;\n+\n+    fn evaluate_obligation(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> Result<EvaluationResult, OverflowError>;\n+\n+    // Helper function that canonicalizes and runs the query. If an\n+    // overflow results, we re-run it in the local context so we can\n+    // report a nice error.\n+    /*crate*/\n+    fn evaluate_obligation_no_overflow(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> EvaluationResult;\n+}\n+\n+impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// Evaluates whether the predicate can be satisfied (by any means)\n     /// in the given `ParamEnv`.\n-    pub fn predicate_may_hold(&self, obligation: &PredicateObligation<'tcx>) -> bool {\n+    fn predicate_may_hold(&self, obligation: &PredicateObligation<'tcx>) -> bool {\n         self.evaluate_obligation_no_overflow(obligation).may_apply()\n     }\n \n@@ -17,7 +42,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     ///\n     /// This version may conservatively fail when outlives obligations\n     /// are required.\n-    pub fn predicate_must_hold_considering_regions(\n+    fn predicate_must_hold_considering_regions(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> bool {\n@@ -29,15 +54,12 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// not entirely accurate if inference variables are involved.\n     ///\n     /// This version ignores all outlives constraints.\n-    pub fn predicate_must_hold_modulo_regions(\n-        &self,\n-        obligation: &PredicateObligation<'tcx>,\n-    ) -> bool {\n+    fn predicate_must_hold_modulo_regions(&self, obligation: &PredicateObligation<'tcx>) -> bool {\n         self.evaluate_obligation_no_overflow(obligation).must_apply_modulo_regions()\n     }\n \n     /// Evaluate a given predicate, capturing overflow and propagating it back.\n-    pub fn evaluate_obligation(\n+    fn evaluate_obligation(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n@@ -53,7 +75,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     // Helper function that canonicalizes and runs the query. If an\n     // overflow results, we re-run it in the local context so we can\n     // report a nice error.\n-    crate fn evaluate_obligation_no_overflow(\n+    fn evaluate_obligation_no_overflow(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> EvaluationResult {", "previous_filename": "src/librustc_infer/traits/query/evaluate_obligation.rs"}, {"sha": "80748c5ef388efe15f3109b5f6990e9e6517896c", "filename": "src/librustc_trait_selection/traits/query/method_autoderef.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/query/method_autoderef.rs"}, {"sha": "77b5ec669a09977888ae76d5c232a45d9bcf0383", "filename": "src/librustc_trait_selection/traits/query/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/query/mod.rs"}, {"sha": "adec2ddb25322c7f2987e7351ba82ff55acfa097", "filename": "src/librustc_trait_selection/traits/query/normalize.rs", "status": "renamed", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Fnormalize.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -5,17 +5,24 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::project::Normalized;\n+use crate::traits::error_reporting::InferCtxtExt;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc_infer::traits::Normalized;\n \n use super::NoSolution;\n \n pub use rustc::traits::query::NormalizationResult;\n \n-impl<'cx, 'tcx> At<'cx, 'tcx> {\n+pub trait AtExt<'tcx> {\n+    fn normalize<T>(&self, value: &T) -> Result<Normalized<'tcx, T>, NoSolution>\n+    where\n+        T: TypeFoldable<'tcx>;\n+}\n+\n+impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n     /// Normalize `value` in the context of the inference context,\n     /// yielding a resulting type, or an error if `value` cannot be\n     /// normalized. If you don't care about regions, you should prefer\n@@ -29,7 +36,7 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// normalizing, but for now should be used only when we actually\n     /// know that normalization will succeed, since error reporting\n     /// and other details are still \"under development\".\n-    pub fn normalize<T>(&self, value: &T) -> Result<Normalized<'tcx, T>, NoSolution>\n+    fn normalize<T>(&self, value: &T) -> Result<Normalized<'tcx, T>, NoSolution>\n     where\n         T: TypeFoldable<'tcx>,\n     {", "previous_filename": "src/librustc_infer/traits/query/normalize.rs"}, {"sha": "05c96dd520ab732b5c182181ea6afd5ba5c4b245", "filename": "src/librustc_trait_selection/traits/query/outlives_bounds.rs", "status": "renamed", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,14 +1,25 @@\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferCtxt;\n use crate::traits::query::NoSolution;\n-use crate::traits::{FulfillmentContext, ObligationCause, TraitEngine, TraitEngineExt};\n+use crate::traits::{FulfillmentContext, ObligationCause, TraitEngine};\n use rustc::ty::{self, Ty};\n use rustc_hir as hir;\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::Span;\n \n pub use rustc::traits::query::OutlivesBound;\n \n-impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n+pub trait InferCtxtExt<'tcx> {\n+    fn implied_outlives_bounds(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: hir::HirId,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Vec<OutlivesBound<'tcx>>;\n+}\n+\n+impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n     /// Implied bounds are region relationships that we deduce\n     /// automatically. The idea is that (e.g.) a caller must check that a\n     /// function's argument types are well-formed immediately before\n@@ -30,7 +41,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// - `ty`, the type that we are supposed to assume is WF.\n     /// - `span`, a span to use when normalizing, hopefully not important,\n     ///   might be useful if a `bug!` occurs.\n-    pub fn implied_outlives_bounds(\n+    fn implied_outlives_bounds(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n         body_id: hir::HirId,\n@@ -82,22 +93,3 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         result.value\n     }\n }\n-\n-pub fn explicit_outlives_bounds<'tcx>(\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n-    debug!(\"explicit_outlives_bounds()\");\n-    param_env.caller_bounds.into_iter().filter_map(move |predicate| match predicate {\n-        ty::Predicate::Projection(..)\n-        | ty::Predicate::Trait(..)\n-        | ty::Predicate::Subtype(..)\n-        | ty::Predicate::WellFormed(..)\n-        | ty::Predicate::ObjectSafe(..)\n-        | ty::Predicate::ClosureKind(..)\n-        | ty::Predicate::TypeOutlives(..)\n-        | ty::Predicate::ConstEvaluatable(..) => None,\n-        ty::Predicate::RegionOutlives(ref data) => data\n-            .no_bound_vars()\n-            .map(|ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a)),\n-    })\n-}", "previous_filename": "src/librustc_infer/traits/query/outlives_bounds.rs"}, {"sha": "b14b79f090778fbb230369539b1e41848b92368c", "filename": "src/librustc_trait_selection/traits/query/type_op/ascribe_user_type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/query/type_op/ascribe_user_type.rs"}, {"sha": "915e8ae4a7ad6bbd1b57bf66d4f6442934ee70cb", "filename": "src/librustc_trait_selection/traits/query/type_op/custom.rs", "status": "renamed", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -4,7 +4,9 @@ use std::fmt;\n \n use crate::infer::canonical::query_response;\n use crate::infer::canonical::QueryRegionConstraints;\n-use crate::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+use crate::traits::engine::TraitEngineExt as _;\n+use crate::traits::{ObligationCause, TraitEngine};\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n use std::rc::Rc;\n ", "previous_filename": "src/librustc_infer/traits/query/type_op/custom.rs"}, {"sha": "3b6fbc7d8dd729cb30b10d676a26c5e2ac192167", "filename": "src/librustc_trait_selection/traits/query/type_op/eq.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/query/type_op/eq.rs"}, {"sha": "3dad546872e5a54569244faefbab2b2f3ce8ed01", "filename": "src/librustc_trait_selection/traits/query/type_op/implied_outlives_bounds.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/query/type_op/implied_outlives_bounds.rs"}, {"sha": "1644746c16eb1c2e991cf7eb8ca61d3034800e7e", "filename": "src/librustc_trait_selection/traits/query/type_op/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/query/type_op/mod.rs"}, {"sha": "d2eec53bf80feac0a8cc5f4ef1c46fafa9797daa", "filename": "src/librustc_trait_selection/traits/query/type_op/normalize.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/query/type_op/normalize.rs"}, {"sha": "b94948cffd68f657ce7c27d238f40580e69121ba", "filename": "src/librustc_trait_selection/traits/query/type_op/outlives.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/query/type_op/outlives.rs"}, {"sha": "8c68f7db9e5bca0da39b5abd86f30c28a181d315", "filename": "src/librustc_trait_selection/traits/query/type_op/prove_predicate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/query/type_op/prove_predicate.rs"}, {"sha": "053411b0cac2e4ea0a0a14930f0482da5cda798f", "filename": "src/librustc_trait_selection/traits/query/type_op/subtype.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/query/type_op/subtype.rs"}, {"sha": "ab3214d8d2d234b09922c687e8dec4296b0fb061", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "renamed", "additions": 13, "deletions": 46, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -9,9 +9,7 @@ use self::SelectionCandidate::*;\n \n use super::coherence::{self, Conflict};\n use super::project;\n-use super::project::{\n-    normalize_with_depth, normalize_with_depth_to, Normalized, ProjectionCacheKey,\n-};\n+use super::project::{normalize_with_depth, normalize_with_depth_to};\n use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n@@ -21,6 +19,7 @@ use super::SelectionResult;\n use super::TraitNotObjectSafe;\n use super::TraitQueryMode;\n use super::{BuiltinDerivedObligation, ImplDerivedObligation, ObligationCauseCode};\n+use super::{Normalized, ProjectionCacheKey};\n use super::{ObjectCastObligation, Obligation};\n use super::{ObligationCause, PredicateObligation, TraitObligation};\n use super::{OutputTypeParameterMismatch, Overflow, SelectionError, Unimplemented};\n@@ -34,6 +33,8 @@ use super::{\n };\n \n use crate::infer::{CombinedSnapshot, InferCtxt, InferOk, PlaceholderMap, TypeFreshener};\n+use crate::traits::error_reporting::InferCtxtExt;\n+use crate::traits::project::ProjectionCacheKeyExt;\n use rustc::dep_graph::{DepKind, DepNodeIndex};\n use rustc::middle::lang_items;\n use rustc::ty::fast_reject;\n@@ -95,47 +96,6 @@ pub struct SelectionContext<'cx, 'tcx> {\n     query_mode: TraitQueryMode,\n }\n \n-#[derive(Clone, Debug)]\n-pub enum IntercrateAmbiguityCause {\n-    DownstreamCrate { trait_desc: String, self_desc: Option<String> },\n-    UpstreamCrateUpdate { trait_desc: String, self_desc: Option<String> },\n-    ReservationImpl { message: String },\n-}\n-\n-impl IntercrateAmbiguityCause {\n-    /// Emits notes when the overlap is caused by complex intercrate ambiguities.\n-    /// See #23980 for details.\n-    pub fn add_intercrate_ambiguity_hint(&self, err: &mut rustc_errors::DiagnosticBuilder<'_>) {\n-        err.note(&self.intercrate_ambiguity_hint());\n-    }\n-\n-    pub fn intercrate_ambiguity_hint(&self) -> String {\n-        match self {\n-            &IntercrateAmbiguityCause::DownstreamCrate { ref trait_desc, ref self_desc } => {\n-                let self_desc = if let &Some(ref ty) = self_desc {\n-                    format!(\" for type `{}`\", ty)\n-                } else {\n-                    String::new()\n-                };\n-                format!(\"downstream crates may implement trait `{}`{}\", trait_desc, self_desc)\n-            }\n-            &IntercrateAmbiguityCause::UpstreamCrateUpdate { ref trait_desc, ref self_desc } => {\n-                let self_desc = if let &Some(ref ty) = self_desc {\n-                    format!(\" for type `{}`\", ty)\n-                } else {\n-                    String::new()\n-                };\n-                format!(\n-                    \"upstream crates may add a new impl of trait `{}`{} \\\n-                     in future versions\",\n-                    trait_desc, self_desc\n-                )\n-            }\n-            &IntercrateAmbiguityCause::ReservationImpl { ref message } => message.clone(),\n-        }\n-    }\n-}\n-\n // A stack that walks back up the stack frame.\n struct TraitObligationStack<'prev, 'tcx> {\n     obligation: &'prev TraitObligation<'tcx>,\n@@ -3506,9 +3466,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n }\n \n-impl<'tcx> TraitObligation<'tcx> {\n+trait TraitObligationExt<'tcx> {\n+    fn derived_cause(\n+        &self,\n+        variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>,\n+    ) -> ObligationCause<'tcx>;\n+}\n+\n+impl<'tcx> TraitObligationExt<'tcx> for TraitObligation<'tcx> {\n     #[allow(unused_comparisons)]\n-    pub fn derived_cause(\n+    fn derived_cause(\n         &self,\n         variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>,\n     ) -> ObligationCause<'tcx> {", "previous_filename": "src/librustc_infer/traits/select.rs"}, {"sha": "d1d4a58fdf297369f1b580c2b8bdacadff8f64d9", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/specialize/mod.rs"}, {"sha": "17d4a22b9dd551fbd416548792f9daf4207850a9", "filename": "src/librustc_trait_selection/traits/specialize/specialization_graph.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/specialize/specialization_graph.rs"}, {"sha": "60682f5812917a4419b54e01a0916df800607976", "filename": "src/librustc_trait_selection/traits/structural_match.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fstructural_match.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "previous_filename": "src/librustc_infer/traits/structural_match.rs"}, {"sha": "cd4595e76ccec05290006ac934da5f3887e197ef", "filename": "src/librustc_trait_selection/traits/util.rs", "status": "added", "additions": 675, "deletions": 0, "changes": 675, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Futil.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -0,0 +1,675 @@\n+use rustc_errors::DiagnosticBuilder;\n+use rustc_span::Span;\n+use smallvec::smallvec;\n+use smallvec::SmallVec;\n+\n+use rustc::ty::outlives::Component;\n+use rustc::ty::subst::{GenericArg, Subst, SubstsRef};\n+use rustc::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+\n+use super::{Normalized, Obligation, ObligationCause, PredicateObligation, SelectionContext};\n+\n+fn anonymize_predicate<'tcx>(tcx: TyCtxt<'tcx>, pred: &ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+    match *pred {\n+        ty::Predicate::Trait(ref data, constness) => {\n+            ty::Predicate::Trait(tcx.anonymize_late_bound_regions(data), constness)\n+        }\n+\n+        ty::Predicate::RegionOutlives(ref data) => {\n+            ty::Predicate::RegionOutlives(tcx.anonymize_late_bound_regions(data))\n+        }\n+\n+        ty::Predicate::TypeOutlives(ref data) => {\n+            ty::Predicate::TypeOutlives(tcx.anonymize_late_bound_regions(data))\n+        }\n+\n+        ty::Predicate::Projection(ref data) => {\n+            ty::Predicate::Projection(tcx.anonymize_late_bound_regions(data))\n+        }\n+\n+        ty::Predicate::WellFormed(data) => ty::Predicate::WellFormed(data),\n+\n+        ty::Predicate::ObjectSafe(data) => ty::Predicate::ObjectSafe(data),\n+\n+        ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::Predicate::ClosureKind(closure_def_id, closure_substs, kind)\n+        }\n+\n+        ty::Predicate::Subtype(ref data) => {\n+            ty::Predicate::Subtype(tcx.anonymize_late_bound_regions(data))\n+        }\n+\n+        ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+            ty::Predicate::ConstEvaluatable(def_id, substs)\n+        }\n+    }\n+}\n+\n+struct PredicateSet<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    set: FxHashSet<ty::Predicate<'tcx>>,\n+}\n+\n+impl PredicateSet<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> Self {\n+        Self { tcx, set: Default::default() }\n+    }\n+\n+    fn insert(&mut self, pred: &ty::Predicate<'tcx>) -> bool {\n+        // We have to be careful here because we want\n+        //\n+        //    for<'a> Foo<&'a int>\n+        //\n+        // and\n+        //\n+        //    for<'b> Foo<&'b int>\n+        //\n+        // to be considered equivalent. So normalize all late-bound\n+        // regions before we throw things into the underlying set.\n+        self.set.insert(anonymize_predicate(self.tcx, pred))\n+    }\n+}\n+\n+impl<T: AsRef<ty::Predicate<'tcx>>> Extend<T> for PredicateSet<'tcx> {\n+    fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {\n+        for pred in iter {\n+            self.insert(pred.as_ref());\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// `Elaboration` iterator\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// \"Elaboration\" is the process of identifying all the predicates that\n+/// are implied by a source predicate. Currently, this basically means\n+/// walking the \"supertraits\" and other similar assumptions. For example,\n+/// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n+/// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n+/// `T: Foo`, then we know that `T: 'static`.\n+pub struct Elaborator<'tcx> {\n+    stack: Vec<ty::Predicate<'tcx>>,\n+    visited: PredicateSet<'tcx>,\n+}\n+\n+pub fn elaborate_trait_ref<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Elaborator<'tcx> {\n+    elaborate_predicates(tcx, vec![trait_ref.without_const().to_predicate()])\n+}\n+\n+pub fn elaborate_trait_refs<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Elaborator<'tcx> {\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.without_const().to_predicate()).collect();\n+    elaborate_predicates(tcx, predicates)\n+}\n+\n+pub fn elaborate_predicates<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    mut predicates: Vec<ty::Predicate<'tcx>>,\n+) -> Elaborator<'tcx> {\n+    let mut visited = PredicateSet::new(tcx);\n+    predicates.retain(|pred| visited.insert(pred));\n+    Elaborator { stack: predicates, visited }\n+}\n+\n+impl Elaborator<'tcx> {\n+    pub fn filter_to_traits(self) -> FilterToTraits<Self> {\n+        FilterToTraits::new(self)\n+    }\n+\n+    fn elaborate(&mut self, predicate: &ty::Predicate<'tcx>) {\n+        let tcx = self.visited.tcx;\n+        match *predicate {\n+            ty::Predicate::Trait(ref data, _) => {\n+                // Get predicates declared on the trait.\n+                let predicates = tcx.super_predicates_of(data.def_id());\n+\n+                let predicates = predicates\n+                    .predicates\n+                    .iter()\n+                    .map(|(pred, _)| pred.subst_supertrait(tcx, &data.to_poly_trait_ref()));\n+                debug!(\"super_predicates: data={:?} predicates={:?}\", data, predicates.clone());\n+\n+                // Only keep those bounds that we haven't already seen.\n+                // This is necessary to prevent infinite recursion in some\n+                // cases. One common case is when people define\n+                // `trait Sized: Sized { }` rather than `trait Sized { }`.\n+                let visited = &mut self.visited;\n+                let predicates = predicates.filter(|pred| visited.insert(pred));\n+\n+                self.stack.extend(predicates);\n+            }\n+            ty::Predicate::WellFormed(..) => {\n+                // Currently, we do not elaborate WF predicates,\n+                // although we easily could.\n+            }\n+            ty::Predicate::ObjectSafe(..) => {\n+                // Currently, we do not elaborate object-safe\n+                // predicates.\n+            }\n+            ty::Predicate::Subtype(..) => {\n+                // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n+                // though conceivably we might.\n+            }\n+            ty::Predicate::Projection(..) => {\n+                // Nothing to elaborate in a projection predicate.\n+            }\n+            ty::Predicate::ClosureKind(..) => {\n+                // Nothing to elaborate when waiting for a closure's kind to be inferred.\n+            }\n+            ty::Predicate::ConstEvaluatable(..) => {\n+                // Currently, we do not elaborate const-evaluatable\n+                // predicates.\n+            }\n+            ty::Predicate::RegionOutlives(..) => {\n+                // Nothing to elaborate from `'a: 'b`.\n+            }\n+            ty::Predicate::TypeOutlives(ref data) => {\n+                // We know that `T: 'a` for some type `T`. We can\n+                // often elaborate this. For example, if we know that\n+                // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n+                // we know `&'a U: 'b`, then we know that `'a: 'b` and\n+                // `U: 'b`.\n+                //\n+                // We can basically ignore bound regions here. So for\n+                // example `for<'c> Foo<'a,'c>: 'b` can be elaborated to\n+                // `'a: 'b`.\n+\n+                // Ignore `for<'a> T: 'a` -- we might in the future\n+                // consider this as evidence that `T: 'static`, but\n+                // I'm a bit wary of such constructions and so for now\n+                // I want to be conservative. --nmatsakis\n+                let ty_max = data.skip_binder().0;\n+                let r_min = data.skip_binder().1;\n+                if r_min.is_late_bound() {\n+                    return;\n+                }\n+\n+                let visited = &mut self.visited;\n+                let mut components = smallvec![];\n+                tcx.push_outlives_components(ty_max, &mut components);\n+                self.stack.extend(\n+                    components\n+                        .into_iter()\n+                        .filter_map(|component| match component {\n+                            Component::Region(r) => {\n+                                if r.is_late_bound() {\n+                                    None\n+                                } else {\n+                                    Some(ty::Predicate::RegionOutlives(ty::Binder::dummy(\n+                                        ty::OutlivesPredicate(r, r_min),\n+                                    )))\n+                                }\n+                            }\n+\n+                            Component::Param(p) => {\n+                                let ty = tcx.mk_ty_param(p.index, p.name);\n+                                Some(ty::Predicate::TypeOutlives(ty::Binder::dummy(\n+                                    ty::OutlivesPredicate(ty, r_min),\n+                                )))\n+                            }\n+\n+                            Component::UnresolvedInferenceVariable(_) => None,\n+\n+                            Component::Projection(_) | Component::EscapingProjection(_) => {\n+                                // We can probably do more here. This\n+                                // corresponds to a case like `<T as\n+                                // Foo<'a>>::U: 'b`.\n+                                None\n+                            }\n+                        })\n+                        .filter(|p| visited.insert(p)),\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+impl Iterator for Elaborator<'tcx> {\n+    type Item = ty::Predicate<'tcx>;\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.stack.len(), None)\n+    }\n+\n+    fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n+        // Extract next item from top-most stack frame, if any.\n+        if let Some(pred) = self.stack.pop() {\n+            self.elaborate(&pred);\n+            Some(pred)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Supertrait iterator\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub type Supertraits<'tcx> = FilterToTraits<Elaborator<'tcx>>;\n+\n+pub fn supertraits<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_ref: ty::PolyTraitRef<'tcx>,\n+) -> Supertraits<'tcx> {\n+    elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n+}\n+\n+pub fn transitive_bounds<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+) -> Supertraits<'tcx> {\n+    elaborate_trait_refs(tcx, bounds).filter_to_traits()\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// `TraitAliasExpander` iterator\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// \"Trait alias expansion\" is the process of expanding a sequence of trait\n+/// references into another sequence by transitively following all trait\n+/// aliases. e.g. If you have bounds like `Foo + Send`, a trait alias\n+/// `trait Foo = Bar + Sync;`, and another trait alias\n+/// `trait Bar = Read + Write`, then the bounds would expand to\n+/// `Read + Write + Sync + Send`.\n+/// Expansion is done via a DFS (depth-first search), and the `visited` field\n+/// is used to avoid cycles.\n+pub struct TraitAliasExpander<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    stack: Vec<TraitAliasExpansionInfo<'tcx>>,\n+}\n+\n+/// Stores information about the expansion of a trait via a path of zero or more trait aliases.\n+#[derive(Debug, Clone)]\n+pub struct TraitAliasExpansionInfo<'tcx> {\n+    pub path: SmallVec<[(ty::PolyTraitRef<'tcx>, Span); 4]>,\n+}\n+\n+impl<'tcx> TraitAliasExpansionInfo<'tcx> {\n+    fn new(trait_ref: ty::PolyTraitRef<'tcx>, span: Span) -> Self {\n+        Self { path: smallvec![(trait_ref, span)] }\n+    }\n+\n+    /// Adds diagnostic labels to `diag` for the expansion path of a trait through all intermediate\n+    /// trait aliases.\n+    pub fn label_with_exp_info(\n+        &self,\n+        diag: &mut DiagnosticBuilder<'_>,\n+        top_label: &str,\n+        use_desc: &str,\n+    ) {\n+        diag.span_label(self.top().1, top_label);\n+        if self.path.len() > 1 {\n+            for (_, sp) in self.path.iter().rev().skip(1).take(self.path.len() - 2) {\n+                diag.span_label(*sp, format!(\"referenced here ({})\", use_desc));\n+            }\n+        }\n+        diag.span_label(\n+            self.bottom().1,\n+            format!(\"trait alias used in trait object type ({})\", use_desc),\n+        );\n+    }\n+\n+    pub fn trait_ref(&self) -> &ty::PolyTraitRef<'tcx> {\n+        &self.top().0\n+    }\n+\n+    pub fn top(&self) -> &(ty::PolyTraitRef<'tcx>, Span) {\n+        self.path.last().unwrap()\n+    }\n+\n+    pub fn bottom(&self) -> &(ty::PolyTraitRef<'tcx>, Span) {\n+        self.path.first().unwrap()\n+    }\n+\n+    fn clone_and_push(&self, trait_ref: ty::PolyTraitRef<'tcx>, span: Span) -> Self {\n+        let mut path = self.path.clone();\n+        path.push((trait_ref, span));\n+\n+        Self { path }\n+    }\n+}\n+\n+pub fn expand_trait_aliases<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>,\n+) -> TraitAliasExpander<'tcx> {\n+    let items: Vec<_> = trait_refs\n+        .into_iter()\n+        .map(|(trait_ref, span)| TraitAliasExpansionInfo::new(trait_ref, span))\n+        .collect();\n+    TraitAliasExpander { tcx, stack: items }\n+}\n+\n+impl<'tcx> TraitAliasExpander<'tcx> {\n+    /// If `item` is a trait alias and its predicate has not yet been visited, then expands `item`\n+    /// to the definition, pushes the resulting expansion onto `self.stack`, and returns `false`.\n+    /// Otherwise, immediately returns `true` if `item` is a regular trait, or `false` if it is a\n+    /// trait alias.\n+    /// The return value indicates whether `item` should be yielded to the user.\n+    fn expand(&mut self, item: &TraitAliasExpansionInfo<'tcx>) -> bool {\n+        let tcx = self.tcx;\n+        let trait_ref = item.trait_ref();\n+        let pred = trait_ref.without_const().to_predicate();\n+\n+        debug!(\"expand_trait_aliases: trait_ref={:?}\", trait_ref);\n+\n+        // Don't recurse if this bound is not a trait alias.\n+        let is_alias = tcx.is_trait_alias(trait_ref.def_id());\n+        if !is_alias {\n+            return true;\n+        }\n+\n+        // Don't recurse if this trait alias is already on the stack for the DFS search.\n+        let anon_pred = anonymize_predicate(tcx, &pred);\n+        if item.path.iter().rev().skip(1).any(|(tr, _)| {\n+            anonymize_predicate(tcx, &tr.without_const().to_predicate()) == anon_pred\n+        }) {\n+            return false;\n+        }\n+\n+        // Get components of trait alias.\n+        let predicates = tcx.super_predicates_of(trait_ref.def_id());\n+\n+        let items = predicates.predicates.iter().rev().filter_map(|(pred, span)| {\n+            pred.subst_supertrait(tcx, &trait_ref)\n+                .to_opt_poly_trait_ref()\n+                .map(|trait_ref| item.clone_and_push(trait_ref, *span))\n+        });\n+        debug!(\"expand_trait_aliases: items={:?}\", items.clone());\n+\n+        self.stack.extend(items);\n+\n+        false\n+    }\n+}\n+\n+impl<'tcx> Iterator for TraitAliasExpander<'tcx> {\n+    type Item = TraitAliasExpansionInfo<'tcx>;\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.stack.len(), None)\n+    }\n+\n+    fn next(&mut self) -> Option<TraitAliasExpansionInfo<'tcx>> {\n+        while let Some(item) = self.stack.pop() {\n+            if self.expand(&item) {\n+                return Some(item);\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Iterator over def-IDs of supertraits\n+///////////////////////////////////////////////////////////////////////////\n+\n+pub struct SupertraitDefIds<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    stack: Vec<DefId>,\n+    visited: FxHashSet<DefId>,\n+}\n+\n+pub fn supertrait_def_ids(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SupertraitDefIds<'_> {\n+    SupertraitDefIds {\n+        tcx,\n+        stack: vec![trait_def_id],\n+        visited: Some(trait_def_id).into_iter().collect(),\n+    }\n+}\n+\n+impl Iterator for SupertraitDefIds<'tcx> {\n+    type Item = DefId;\n+\n+    fn next(&mut self) -> Option<DefId> {\n+        let def_id = self.stack.pop()?;\n+        let predicates = self.tcx.super_predicates_of(def_id);\n+        let visited = &mut self.visited;\n+        self.stack.extend(\n+            predicates\n+                .predicates\n+                .iter()\n+                .filter_map(|(pred, _)| pred.to_opt_poly_trait_ref())\n+                .map(|trait_ref| trait_ref.def_id())\n+                .filter(|&super_def_id| visited.insert(super_def_id)),\n+        );\n+        Some(def_id)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Other\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// A filter around an iterator of predicates that makes it yield up\n+/// just trait references.\n+pub struct FilterToTraits<I> {\n+    base_iterator: I,\n+}\n+\n+impl<I> FilterToTraits<I> {\n+    fn new(base: I) -> FilterToTraits<I> {\n+        FilterToTraits { base_iterator: base }\n+    }\n+}\n+\n+impl<'tcx, I: Iterator<Item = ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n+    type Item = ty::PolyTraitRef<'tcx>;\n+\n+    fn next(&mut self) -> Option<ty::PolyTraitRef<'tcx>> {\n+        while let Some(pred) = self.base_iterator.next() {\n+            if let ty::Predicate::Trait(data, _) = pred {\n+                return Some(data.to_poly_trait_ref());\n+            }\n+        }\n+        None\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (_, upper) = self.base_iterator.size_hint();\n+        (0, upper)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Other\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// Instantiate all bound parameters of the impl with the given substs,\n+/// returning the resulting trait ref and all obligations that arise.\n+/// The obligations are closed under normalization.\n+pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n+    selcx: &mut SelectionContext<'a, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    impl_def_id: DefId,\n+    impl_substs: SubstsRef<'tcx>,\n+) -> (ty::TraitRef<'tcx>, Vec<PredicateObligation<'tcx>>) {\n+    let impl_trait_ref = selcx.tcx().impl_trait_ref(impl_def_id).unwrap();\n+    let impl_trait_ref = impl_trait_ref.subst(selcx.tcx(), impl_substs);\n+    let Normalized { value: impl_trait_ref, obligations: normalization_obligations1 } =\n+        super::normalize(selcx, param_env, ObligationCause::dummy(), &impl_trait_ref);\n+\n+    let predicates = selcx.tcx().predicates_of(impl_def_id);\n+    let predicates = predicates.instantiate(selcx.tcx(), impl_substs);\n+    let Normalized { value: predicates, obligations: normalization_obligations2 } =\n+        super::normalize(selcx, param_env, ObligationCause::dummy(), &predicates);\n+    let impl_obligations =\n+        predicates_for_generics(ObligationCause::dummy(), 0, param_env, &predicates);\n+\n+    let impl_obligations: Vec<_> = impl_obligations\n+        .into_iter()\n+        .chain(normalization_obligations1)\n+        .chain(normalization_obligations2)\n+        .collect();\n+\n+    (impl_trait_ref, impl_obligations)\n+}\n+\n+/// See [`super::obligations_for_generics`].\n+pub fn predicates_for_generics<'tcx>(\n+    cause: ObligationCause<'tcx>,\n+    recursion_depth: usize,\n+    param_env: ty::ParamEnv<'tcx>,\n+    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n+) -> Vec<PredicateObligation<'tcx>> {\n+    debug!(\"predicates_for_generics(generic_bounds={:?})\", generic_bounds);\n+\n+    generic_bounds\n+        .predicates\n+        .iter()\n+        .map(|&predicate| Obligation {\n+            cause: cause.clone(),\n+            recursion_depth,\n+            param_env,\n+            predicate,\n+        })\n+        .collect()\n+}\n+\n+pub fn predicate_for_trait_ref<'tcx>(\n+    cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    trait_ref: ty::TraitRef<'tcx>,\n+    recursion_depth: usize,\n+) -> PredicateObligation<'tcx> {\n+    Obligation {\n+        cause,\n+        param_env,\n+        recursion_depth,\n+        predicate: trait_ref.without_const().to_predicate(),\n+    }\n+}\n+\n+pub fn predicate_for_trait_def(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    cause: ObligationCause<'tcx>,\n+    trait_def_id: DefId,\n+    recursion_depth: usize,\n+    self_ty: Ty<'tcx>,\n+    params: &[GenericArg<'tcx>],\n+) -> PredicateObligation<'tcx> {\n+    let trait_ref =\n+        ty::TraitRef { def_id: trait_def_id, substs: tcx.mk_substs_trait(self_ty, params) };\n+    predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n+}\n+\n+/// Casts a trait reference into a reference to one of its super\n+/// traits; returns `None` if `target_trait_def_id` is not a\n+/// supertrait.\n+pub fn upcast_choices(\n+    tcx: TyCtxt<'tcx>,\n+    source_trait_ref: ty::PolyTraitRef<'tcx>,\n+    target_trait_def_id: DefId,\n+) -> Vec<ty::PolyTraitRef<'tcx>> {\n+    if source_trait_ref.def_id() == target_trait_def_id {\n+        return vec![source_trait_ref]; // Shortcut the most common case.\n+    }\n+\n+    supertraits(tcx, source_trait_ref).filter(|r| r.def_id() == target_trait_def_id).collect()\n+}\n+\n+/// Given a trait `trait_ref`, returns the number of vtable entries\n+/// that come from `trait_ref`, excluding its supertraits. Used in\n+/// computing the vtable base for an upcast trait of a trait object.\n+pub fn count_own_vtable_entries(tcx: TyCtxt<'tcx>, trait_ref: ty::PolyTraitRef<'tcx>) -> usize {\n+    let mut entries = 0;\n+    // Count number of methods and add them to the total offset.\n+    // Skip over associated types and constants.\n+    for trait_item in tcx.associated_items(trait_ref.def_id()).in_definition_order() {\n+        if trait_item.kind == ty::AssocKind::Method {\n+            entries += 1;\n+        }\n+    }\n+    entries\n+}\n+\n+/// Given an upcast trait object described by `object`, returns the\n+/// index of the method `method_def_id` (which should be part of\n+/// `object.upcast_trait_ref`) within the vtable for `object`.\n+pub fn get_vtable_index_of_object_method<N>(\n+    tcx: TyCtxt<'tcx>,\n+    object: &super::VtableObjectData<'tcx, N>,\n+    method_def_id: DefId,\n+) -> usize {\n+    // Count number of methods preceding the one we are selecting and\n+    // add them to the total offset.\n+    // Skip over associated types and constants.\n+    let mut entries = object.vtable_base;\n+    for trait_item in tcx.associated_items(object.upcast_trait_ref.def_id()).in_definition_order() {\n+        if trait_item.def_id == method_def_id {\n+            // The item with the ID we were given really ought to be a method.\n+            assert_eq!(trait_item.kind, ty::AssocKind::Method);\n+            return entries;\n+        }\n+        if trait_item.kind == ty::AssocKind::Method {\n+            entries += 1;\n+        }\n+    }\n+\n+    bug!(\"get_vtable_index_of_object_method: {:?} was not found\", method_def_id);\n+}\n+\n+pub fn closure_trait_ref_and_return_type(\n+    tcx: TyCtxt<'tcx>,\n+    fn_trait_def_id: DefId,\n+    self_ty: Ty<'tcx>,\n+    sig: ty::PolyFnSig<'tcx>,\n+    tuple_arguments: TupleArgumentsFlag,\n+) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)> {\n+    let arguments_tuple = match tuple_arguments {\n+        TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n+        TupleArgumentsFlag::Yes => tcx.intern_tup(sig.skip_binder().inputs()),\n+    };\n+    let trait_ref = ty::TraitRef {\n+        def_id: fn_trait_def_id,\n+        substs: tcx.mk_substs_trait(self_ty, &[arguments_tuple.into()]),\n+    };\n+    ty::Binder::bind((trait_ref, sig.skip_binder().output()))\n+}\n+\n+pub fn generator_trait_ref_and_outputs(\n+    tcx: TyCtxt<'tcx>,\n+    fn_trait_def_id: DefId,\n+    self_ty: Ty<'tcx>,\n+    sig: ty::PolyGenSig<'tcx>,\n+) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)> {\n+    let trait_ref = ty::TraitRef {\n+        def_id: fn_trait_def_id,\n+        substs: tcx.mk_substs_trait(self_ty, &[sig.skip_binder().resume_ty.into()]),\n+    };\n+    ty::Binder::bind((trait_ref, sig.skip_binder().yield_ty, sig.skip_binder().return_ty))\n+}\n+\n+pub fn impl_is_default(tcx: TyCtxt<'_>, node_item_def_id: DefId) -> bool {\n+    match tcx.hir().as_local_hir_id(node_item_def_id) {\n+        Some(hir_id) => {\n+            let item = tcx.hir().expect_item(hir_id);\n+            if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n+                defaultness.is_default()\n+            } else {\n+                false\n+            }\n+        }\n+        None => tcx.impl_defaultness(node_item_def_id).is_default(),\n+    }\n+}\n+\n+pub fn impl_item_is_final(tcx: TyCtxt<'_>, assoc_item: &ty::AssocItem) -> bool {\n+    assoc_item.defaultness.is_final() && !impl_is_default(tcx, assoc_item.container.id())\n+}\n+\n+pub enum TupleArgumentsFlag {\n+    Yes,\n+    No,\n+}"}, {"sha": "b69c5bdce2abc713b7a8ced083cf4e8d1643563f", "filename": "src/librustc_trait_selection/traits/wf.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fwf.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,5 +1,5 @@\n-use crate::infer::opaque_types::required_region_bounds;\n use crate::infer::InferCtxt;\n+use crate::opaque_types::required_region_bounds;\n use crate::traits::{self, AssocTypeBoundData};\n use rustc::middle::lang_items;\n use rustc::ty::subst::SubstsRef;", "previous_filename": "src/librustc_infer/traits/wf.rs"}, {"sha": "5e33efb1cf9b56a9cf234ee2082cc1de8c385dbe", "filename": "src/librustc_traits/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -19,3 +19,4 @@ rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../librustc_infer\" }\n+rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "b13a7a3acb16509458d57ca38a6bfa822b151f68", "filename": "src/librustc_traits/dropck_outlives.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fdropck_outlives.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -5,11 +5,17 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::query::dropck_outlives::trivial_dropck_outlives;\n-use rustc_infer::traits::query::dropck_outlives::{DropckOutlivesResult, DtorckConstraint};\n-use rustc_infer::traits::query::{CanonicalTyGoal, NoSolution};\n-use rustc_infer::traits::{Normalized, ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::{Span, DUMMY_SP};\n+use rustc_trait_selection::traits::query::dropck_outlives::trivial_dropck_outlives;\n+use rustc_trait_selection::traits::query::dropck_outlives::{\n+    DropckOutlivesResult, DtorckConstraint,\n+};\n+use rustc_trait_selection::traits::query::normalize::AtExt;\n+use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n+use rustc_trait_selection::traits::{\n+    Normalized, ObligationCause, TraitEngine, TraitEngineExt as _,\n+};\n \n crate fn provide(p: &mut Providers<'_>) {\n     *p = Providers { dropck_outlives, adt_dtorck_constraint, ..*p };"}, {"sha": "87895d8e384da484681c621beaeb8c6bd657ffa1", "filename": "src/librustc_traits/evaluate_obligation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fevaluate_obligation.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,11 +1,11 @@\n use rustc::ty::query::Providers;\n use rustc::ty::{ParamEnvAnd, TyCtxt};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::query::CanonicalPredicateGoal;\n-use rustc_infer::traits::{\n+use rustc_span::source_map::DUMMY_SP;\n+use rustc_trait_selection::traits::query::CanonicalPredicateGoal;\n+use rustc_trait_selection::traits::{\n     EvaluationResult, Obligation, ObligationCause, OverflowError, SelectionContext, TraitQueryMode,\n };\n-use rustc_span::source_map::DUMMY_SP;\n \n crate fn provide(p: &mut Providers<'_>) {\n     *p = Providers { evaluate_obligation, ..*p };"}, {"sha": "4505a1e59d9ba936d3a17a8cfc81948b0bc3b551", "filename": "src/librustc_traits/implied_outlives_bounds.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fimplied_outlives_bounds.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -7,12 +7,14 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc_hir as hir;\n use rustc_infer::infer::canonical::{self, Canonical};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::query::outlives_bounds::OutlivesBound;\n-use rustc_infer::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n-use rustc_infer::traits::wf;\n-use rustc_infer::traits::FulfillmentContext;\n-use rustc_infer::traits::{TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::source_map::DUMMY_SP;\n+use rustc_trait_selection::infer::InferCtxtBuilderExt;\n+use rustc_trait_selection::traits::query::outlives_bounds::OutlivesBound;\n+use rustc_trait_selection::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n+use rustc_trait_selection::traits::wf;\n+use rustc_trait_selection::traits::FulfillmentContext;\n+use rustc_trait_selection::traits::TraitEngine;\n use smallvec::{smallvec, SmallVec};\n \n crate fn provide(p: &mut Providers<'_>) {"}, {"sha": "c2fb237a05b5476783e59a5222aac5b728ceeadb", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -2,7 +2,8 @@ use rustc::traits::query::NoSolution;\n use rustc::ty::query::Providers;\n use rustc::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::{Normalized, ObligationCause};\n+use rustc_trait_selection::traits::query::normalize::AtExt;\n+use rustc_trait_selection::traits::{Normalized, ObligationCause};\n use std::sync::atomic::Ordering;\n \n crate fn provide(p: &mut Providers<'_>) {"}, {"sha": "57abff769de9b67e9407a63b9c1d8997c88d7c3f", "filename": "src/librustc_traits/normalize_projection_ty.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_projection_ty.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -3,11 +3,13 @@ use rustc::ty::{ParamEnvAnd, TyCtxt};\n use rustc_hir as hir;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits::query::{\n+use rustc_infer::traits::TraitEngineExt as _;\n+use rustc_span::DUMMY_SP;\n+use rustc_trait_selection::infer::InferCtxtBuilderExt;\n+use rustc_trait_selection::traits::query::{\n     normalize::NormalizationResult, CanonicalProjectionGoal, NoSolution,\n };\n-use rustc_infer::traits::{self, ObligationCause, SelectionContext, TraitEngineExt};\n-use rustc_span::DUMMY_SP;\n+use rustc_trait_selection::traits::{self, ObligationCause, SelectionContext};\n use std::sync::atomic::Ordering;\n \n crate fn provide(p: &mut Providers<'_>) {"}, {"sha": "e174c040e0da15b4da29298e853f080e42acff0c", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -8,14 +8,18 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n-use rustc_infer::traits::query::type_op::ascribe_user_type::AscribeUserType;\n-use rustc_infer::traits::query::type_op::eq::Eq;\n-use rustc_infer::traits::query::type_op::normalize::Normalize;\n-use rustc_infer::traits::query::type_op::prove_predicate::ProvePredicate;\n-use rustc_infer::traits::query::type_op::subtype::Subtype;\n-use rustc_infer::traits::query::{Fallible, NoSolution};\n-use rustc_infer::traits::{Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::DUMMY_SP;\n+use rustc_trait_selection::infer::InferCtxtBuilderExt;\n+use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::query::normalize::AtExt;\n+use rustc_trait_selection::traits::query::type_op::ascribe_user_type::AscribeUserType;\n+use rustc_trait_selection::traits::query::type_op::eq::Eq;\n+use rustc_trait_selection::traits::query::type_op::normalize::Normalize;\n+use rustc_trait_selection::traits::query::type_op::prove_predicate::ProvePredicate;\n+use rustc_trait_selection::traits::query::type_op::subtype::Subtype;\n+use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n+use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, TraitEngine};\n use std::fmt;\n \n crate fn provide(p: &mut Providers<'_>) {"}, {"sha": "3c790bc4cb13d160c09e893c9098f18b3c3b8f69", "filename": "src/librustc_ty/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_ty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_ty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -16,3 +16,4 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_infer = { path = \"../librustc_infer\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_target = { path = \"../librustc_target\" }\n+rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "311ba383f3055fbe3a819f3c81fc5138e7f943fa", "filename": "src/librustc_ty/common_traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_ty%2Fcommon_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_ty%2Fcommon_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fcommon_traits.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -3,8 +3,8 @@\n use rustc::middle::lang_items;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits;\n use rustc_span::DUMMY_SP;\n+use rustc_trait_selection::traits;\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     is_item_raw(tcx, query, lang_items::CopyTraitLangItem)"}, {"sha": "10cc2c0e3033c2f7477d7bc70c93a3b8057810d2", "filename": "src/librustc_ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_ty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_ty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Finstance.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,8 +1,8 @@\n use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Instance, TyCtxt, TypeFoldable};\n use rustc_hir::def_id::DefId;\n-use rustc_infer::traits;\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits;\n \n use log::debug;\n "}, {"sha": "4c0903b6b9dfa22fa7a625959b35efcbc153a8f1", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -5,9 +5,9 @@ use rustc::ty::{self, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use rustc_infer::traits;\n use rustc_span::symbol::Symbol;\n use rustc_span::Span;\n+use rustc_trait_selection::traits;\n \n fn sized_constraint_for_ty<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "83a48ee3995ac06163ca9023786ae071fdb06ade", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -24,3 +24,4 @@ rustc_ast = { path = \"../librustc_ast\" }\n rustc_span = { path = \"../librustc_span\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_infer = { path = \"../librustc_infer\" }\n+rustc_trait_selection = { path = \"../librustc_trait_selection\" }"}, {"sha": "be8090cf21b9c8617672962605100b9de1cfd28b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -26,13 +26,13 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::print;\n use rustc_hir::{Constness, ExprKind, GenericArg, GenericArgs};\n-use rustc_infer::traits;\n-use rustc_infer::traits::astconv_object_safety_violations;\n-use rustc_infer::traits::error_reporting::report_object_safety_error;\n-use rustc_infer::traits::wf::object_region_bounds;\n use rustc_span::symbol::sym;\n use rustc_span::{MultiSpan, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n+use rustc_trait_selection::traits;\n+use rustc_trait_selection::traits::astconv_object_safety_violations;\n+use rustc_trait_selection::traits::error_reporting::report_object_safety_error;\n+use rustc_trait_selection::traits::wf::object_region_bounds;\n use smallvec::SmallVec;\n \n use std::collections::BTreeSet;"}, {"sha": "20737b44e7c17574ecb14729d1c7349116f579e6", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -4,9 +4,9 @@ use rustc::ty::Ty;\n use rustc_hir as hir;\n use rustc_hir::ExprKind;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::traits::ObligationCauseCode;\n-use rustc_infer::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n use rustc_span::Span;\n+use rustc_trait_selection::traits::ObligationCauseCode;\n+use rustc_trait_selection::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_match("}, {"sha": "991347714e841c20f5fd0095511f34a2fde105ca", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -8,7 +8,8 @@ use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_infer::infer::{InferCtxt, InferOk};\n-use rustc_infer::traits::{self, TraitEngine};\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, TraitEngine};\n \n use rustc_ast::ast::Ident;\n use rustc_span::Span;"}, {"sha": "d52b6c39ab58db837c25a8321ce266125ef76af2", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -44,9 +44,9 @@ use rustc::ty::{self, Ty, TypeAndMut, TypeFoldable};\n use rustc_ast::ast;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_infer::traits;\n-use rustc_infer::traits::error_reporting::report_object_safety_error;\n use rustc_span::Span;\n+use rustc_trait_selection::traits;\n+use rustc_trait_selection::traits::error_reporting::report_object_safety_error;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context."}, {"sha": "49b7a997311044f80ffba4a850c8a32990c94d0c", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -12,10 +12,11 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::LateBoundRegionConversionTime;\n use rustc_infer::infer::{InferOk, InferResult};\n-use rustc_infer::traits::error_reporting::ArgKind;\n-use rustc_infer::traits::Obligation;\n use rustc_span::source_map::Span;\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits::error_reporting::ArgKind;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::Obligation;\n use std::cmp;\n use std::iter;\n "}, {"sha": "d74623a063f8f066965179cf99bc013add5e188f", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -66,10 +66,11 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{Coercion, InferOk, InferResult};\n-use rustc_infer::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc_span::symbol::sym;\n use rustc_span::{self, Span};\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n use smallvec::{smallvec, SmallVec};\n use std::ops::Deref;\n "}, {"sha": "ff79d10273c84d8a3906c584aa675e4c90fcb374", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -10,8 +10,9 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit;\n use rustc_hir::{GenericParamKind, ImplItemKind, TraitItemKind};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n-use rustc_infer::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc_span::Span;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n \n use super::{potentially_plural_count, FnCtxt, Inherited};\n "}, {"sha": "0556c80e4f70775fa17b4e010f9f95cbfec3aeab", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,6 +1,8 @@\n use crate::check::FnCtxt;\n use rustc_infer::infer::InferOk;\n-use rustc_infer::traits::{self, ObligationCause};\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{self, ObligationCause};\n \n use rustc::ty::adjustment::AllowTwoPhase;\n use rustc::ty::{self, AssocItem, Ty};"}, {"sha": "dca4f9e7cbe08105cb4dd81d1f9dedf801d88080", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -10,8 +10,11 @@ use rustc::ty::{self, Predicate, Ty, TyCtxt};\n use rustc_errors::struct_span_err;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{InferOk, SuppressRegionErrors, TyCtxtInferExt};\n-use rustc_infer::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::Span;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::query::dropck_outlives::AtExt;\n+use rustc_trait_selection::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n \n /// This function confirms that the `Drop` implementation identified by\n /// `drop_impl_did` is not any more specialized than the type it is"}, {"sha": "93f9050b26eb96bc59e99d6c34db5a3757168919", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -34,10 +34,10 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{ExprKind, QPath};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::traits::{self, ObligationCauseCode};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n use std::fmt::Display;\n "}, {"sha": "48c72567b5c31ae8a15d454491e0b3aaf8947a8d", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -11,8 +11,8 @@ use rustc::ty::subst::{Subst, SubstsRef};\n use rustc::ty::{self, GenericParamDefKind, Ty};\n use rustc_hir as hir;\n use rustc_infer::infer::{self, InferOk};\n-use rustc_infer::traits;\n use rustc_span::Span;\n+use rustc_trait_selection::traits;\n \n use std::ops::Deref;\n "}, {"sha": "3cf7b65e30f2f377688d4a08ac238cb51e07ea9d", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -22,8 +22,9 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n-use rustc_infer::traits;\n use rustc_span::Span;\n+use rustc_trait_selection::traits;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n \n use self::probe::{IsSuggestion, ProbeScope};\n "}, {"sha": "16bab09feeef0266ecb376e7702607a09e4a642e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -28,11 +28,14 @@ use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n-use rustc_infer::traits::query::method_autoderef::MethodAutoderefBadTy;\n-use rustc_infer::traits::query::method_autoderef::{CandidateStep, MethodAutoderefStepsResult};\n-use rustc_infer::traits::query::CanonicalTyGoal;\n-use rustc_infer::traits::{self, ObligationCause};\n use rustc_span::{symbol::Symbol, Span, DUMMY_SP};\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::query::method_autoderef::MethodAutoderefBadTy;\n+use rustc_trait_selection::traits::query::method_autoderef::{\n+    CandidateStep, MethodAutoderefStepsResult,\n+};\n+use rustc_trait_selection::traits::query::CanonicalTyGoal;\n+use rustc_trait_selection::traits::{self, ObligationCause};\n use std::cmp::max;\n use std::iter;\n use std::mem;"}, {"sha": "bfbad1a0ea961d9b13585419eb5c8327d05fe949", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -17,9 +17,10 @@ use rustc_hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit;\n use rustc_hir::{ExprKind, Node, QPath};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::traits::Obligation;\n use rustc_span::symbol::kw;\n use rustc_span::{source_map, FileName, Span};\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::Obligation;\n \n use std::cmp::Ordering;\n "}, {"sha": "1975b2489996023196a957fe937b0b4b7ef4dc2f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -121,17 +121,22 @@ use rustc_hir::{ExprKind, GenericArg, HirIdMap, Item, ItemKind, Node, PatKind, Q\n use rustc_index::vec::Idx;\n use rustc_infer::infer::canonical::{Canonical, OriginalQueryValues, QueryResponse};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n-use rustc_infer::infer::opaque_types::OpaqueTypeDecl;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_infer::infer::{self, InferCtxt, InferOk, InferResult, TyCtxtInferExt};\n-use rustc_infer::traits::error_reporting::recursive_type_with_infinite_size_error;\n-use rustc_infer::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{original_sp, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{self, BytePos, MultiSpan, Span};\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::opaque_types::{InferCtxtExt as _, OpaqueTypeDecl};\n+use rustc_trait_selection::traits::error_reporting::recursive_type_with_infinite_size_error;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{\n+    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n+};\n \n use std::cell::{Cell, Ref, RefCell, RefMut};\n use std::cmp;"}, {"sha": "f589805e1e2610ce0a7d1404a19467e9fca14e4a", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -10,6 +10,7 @@ use rustc_errors::{self, struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_span::Span;\n+use rustc_trait_selection::infer::InferCtxtExt;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a `a <op>= b`"}, {"sha": "60132dde9caec09c02aa24d44d022c2dafaf4ae3", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -11,9 +11,9 @@ use rustc_hir::pat_util::EnumerateAndAdjustIterator;\n use rustc_hir::{HirId, Pat, PatKind};\n use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::traits::{ObligationCause, Pattern};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{Span, Spanned};\n+use rustc_trait_selection::traits::{ObligationCause, Pattern};\n \n use std::cmp;\n use std::collections::hash_map::Entry::{Occupied, Vacant};"}, {"sha": "bfa3d75b6b0f024e57278d294c5a6094db17ff91", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -87,6 +87,8 @@ use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{self, RegionObligation, SuppressRegionErrors};\n use rustc_span::Span;\n+use rustc_trait_selection::infer::OutlivesEnvironmentExt;\n+use rustc_trait_selection::opaque_types::InferCtxtExt;\n use std::mem;\n use std::ops::Deref;\n "}, {"sha": "026e68e10e04d2fc743c76c59be4544e60ee007a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -12,10 +12,11 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir::def_id::DefId;\n use rustc_hir::ItemKind;\n-use rustc_infer::infer::opaque_types::may_define_opaque_type;\n-use rustc_infer::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use rustc_trait_selection::opaque_types::may_define_opaque_type;\n+use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n+use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ParItemLikeVisitor;"}, {"sha": "f4c166b943d6ce20444b71a0691ba20367e52d31", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -16,6 +16,7 @@ use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::InferCtxt;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n+use rustc_trait_selection::opaque_types::InferCtxtExt;\n \n use std::mem;\n "}, {"sha": "2ea7601ae65380c88719b7bade867563b4eb835a", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -13,9 +13,10 @@ use rustc_hir::ItemKind;\n use rustc_infer::infer;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{SuppressRegionErrors, TyCtxtInferExt};\n-use rustc_infer::traits::misc::{can_type_implement_copy, CopyImplementationError};\n-use rustc_infer::traits::predicate_for_trait_def;\n-use rustc_infer::traits::{self, ObligationCause, TraitEngine};\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::traits::misc::{can_type_implement_copy, CopyImplementationError};\n+use rustc_trait_selection::traits::predicate_for_trait_def;\n+use rustc_trait_selection::traits::{self, ObligationCause, TraitEngine, TraitEngineExt};\n \n pub fn check_trait(tcx: TyCtxt<'_>, trait_def_id: DefId) {\n     let lang_items = tcx.lang_items();"}, {"sha": "1eae9d3b7fa6c100376909111a80b6f7c3048a38", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -3,7 +3,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_infer::traits::{self, SkipLeakCheck};\n+use rustc_trait_selection::traits::{self, SkipLeakCheck};\n \n pub fn crate_inherent_impls_overlap_check(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     assert_eq!(crate_num, LOCAL_CRATE);"}, {"sha": "0d0149f9673586aa90e029cca6e160318debcc83", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -9,8 +9,8 @@ use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc_errors::struct_span_err;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_infer::traits;\n use rustc_span::Span;\n+use rustc_trait_selection::traits;\n \n mod builtin;\n mod inherent_impls;"}, {"sha": "fc77aad8688c69e3c44147db45af5e2f7b4d9e58", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -6,7 +6,7 @@ use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_infer::traits;\n+use rustc_trait_selection::traits;\n \n pub fn check(tcx: TyCtxt<'_>) {\n     let mut orphan = OrphanChecker { tcx };"}, {"sha": "43cf65d81516cb15575e0f4d602e6aa1aee53555", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -11,9 +11,9 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n-use rustc_infer::traits;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_trait_selection::traits;\n \n use super::ItemCtxt;\n use super::{bad_placeholder_type, is_suggestable_infer_ty};"}, {"sha": "4e7985dd98812145006941e19fa91c7182230d86", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -101,9 +101,13 @@ use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::Node;\n use rustc_infer::infer::{InferOk, TyCtxtInferExt};\n-use rustc_infer::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n+use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n+use rustc_trait_selection::traits::{\n+    ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt as _,\n+};\n \n use std::iter;\n "}, {"sha": "4350b3dda97cef13ea5c603b0b16b6ca1e0bfe97", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -59,6 +59,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::PatKind;\n use rustc_infer::infer::InferCtxt;\n use rustc_span::Span;\n+use rustc_trait_selection::infer::InferCtxtExt;\n \n #[derive(Clone, Debug)]\n pub enum PlaceBase {"}, {"sha": "c85b21a55007f1e0a72444cd9c39f5e8d1de44e0", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,7 +1,7 @@\n use rustc::ty::{self, Region, RegionVid, TypeFoldable};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_infer::traits::auto_trait::{self, AutoTraitResult};\n+use rustc_trait_selection::traits::auto_trait::{self, AutoTraitResult};\n \n use std::fmt::Debug;\n "}, {"sha": "e66f8697717940aaed8cd5d7811c7d8d603b2ad3", "filename": "src/librustdoc/clean/blanket_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fblanket_impl.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -1,3 +1,4 @@\n+use crate::rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{ToPredicate, WithConstness};\n use rustc_hir as hir;"}, {"sha": "2e90d6082bac92fedaec512dbaa5a5ccfbe48864", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/131772c5e0ba40cd656dedb5e1990d36e3ea31cf/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=131772c5e0ba40cd656dedb5e1990d36e3ea31cf", "patch": "@@ -38,6 +38,7 @@ extern crate rustc_resolve;\n extern crate rustc_session;\n extern crate rustc_span as rustc_span;\n extern crate rustc_target;\n+extern crate rustc_trait_selection;\n extern crate rustc_typeck;\n extern crate test as testing;\n #[macro_use]"}]}