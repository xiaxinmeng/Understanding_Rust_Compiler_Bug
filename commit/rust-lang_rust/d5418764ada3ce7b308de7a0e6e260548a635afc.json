{"sha": "d5418764ada3ce7b308de7a0e6e260548a635afc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1NDE4NzY0YWRhM2NlN2IzMDhkZTdhMGU2ZTI2MDU0OGE2MzVhZmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-20T22:23:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-20T22:23:36Z"}, "message": "Auto merge of #55230 - Manishearth:rollup, r=Manishearth\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #55156 (Fixed: Multiple errors on single typo in match pattern)\n - #55189 (update books for the next release)\n - #55193 (make asm diagnostic instruction optional)\n - #55203 (Write an initial version of the `program_clauses` callback)\n - #55213 (ignore target folders)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "b3fa56e507a8d1a894e35e9a00a70c5ce73e0f67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3fa56e507a8d1a894e35e9a00a70c5ce73e0f67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5418764ada3ce7b308de7a0e6e260548a635afc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5418764ada3ce7b308de7a0e6e260548a635afc", "html_url": "https://github.com/rust-lang/rust/commit/d5418764ada3ce7b308de7a0e6e260548a635afc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5418764ada3ce7b308de7a0e6e260548a635afc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "155510e377ae2a8d8ee0dad1a5f809c9062a5526", "url": "https://api.github.com/repos/rust-lang/rust/commits/155510e377ae2a8d8ee0dad1a5f809c9062a5526", "html_url": "https://github.com/rust-lang/rust/commit/155510e377ae2a8d8ee0dad1a5f809c9062a5526"}, {"sha": "f2848a010adf22d43fd713975b4945402d585554", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2848a010adf22d43fd713975b4945402d585554", "html_url": "https://github.com/rust-lang/rust/commit/f2848a010adf22d43fd713975b4945402d585554"}], "stats": {"total": 589, "additions": 551, "deletions": 38}, "files": [{"sha": "e871c4598925594421d63e929fee292e6e071f97", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -1 +1 @@\n-Subproject commit fa91738b66367b6f70b078251868a071f1991ace\n+Subproject commit e871c4598925594421d63e929fee292e6e071f97"}, {"sha": "7f7a597b47ed6c35c2a0f0ee6a69050fe2d5e013", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -1 +1 @@\n-Subproject commit 7fd493465b7dd6cf3476f0b834884059bbdd1d93\n+Subproject commit 7f7a597b47ed6c35c2a0f0ee6a69050fe2d5e013"}, {"sha": "b9fb838054b8441223c22eeae5b6d8e498071cd0", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -1 +1 @@\n-Subproject commit 821355a6fd642b71988a2f88a3162fb358732012\n+Subproject commit b9fb838054b8441223c22eeae5b6d8e498071cd0"}, {"sha": "bc342a475c09b6df8004d518382e6d5b6bcb49f7", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -1 +1 @@\n-Subproject commit e459fb3f07f2b930ccd25d348671b8eae233fd64\n+Subproject commit bc342a475c09b6df8004d518382e6d5b6bcb49f7"}, {"sha": "a3704d1154e0800bf004bf894b10e6142a9eb5b4", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -80,9 +80,7 @@ impl LtoModuleCodegen {\n                 let module = module.take().unwrap();\n                 {\n                     let config = cgcx.config(module.kind);\n-                    let llmod = module.module_llvm.llmod();\n-                    let tm = &*module.module_llvm.tm;\n-                    run_pass_manager(cgcx, tm, llmod, config, false);\n+                    run_pass_manager(cgcx, &module, config, false);\n                     timeline.record(\"fat-done\");\n                 }\n                 Ok(module)\n@@ -557,8 +555,7 @@ fn thin_lto(cgcx: &CodegenContext,\n }\n \n fn run_pass_manager(cgcx: &CodegenContext,\n-                    tm: &llvm::TargetMachine,\n-                    llmod: &llvm::Module,\n+                    module: &ModuleCodegen,\n                     config: &ModuleConfig,\n                     thin: bool) {\n     // Now we have one massive module inside of llmod. Time to run the\n@@ -569,7 +566,8 @@ fn run_pass_manager(cgcx: &CodegenContext,\n     debug!(\"running the pass manager\");\n     unsafe {\n         let pm = llvm::LLVMCreatePassManager();\n-        llvm::LLVMRustAddAnalysisPasses(tm, pm, llmod);\n+        let llmod = module.module_llvm.llmod();\n+        llvm::LLVMRustAddAnalysisPasses(module.module_llvm.tm, pm, llmod);\n \n         if config.verify_llvm_ir {\n             let pass = llvm::LLVMRustFindAndCreatePass(\"verify\\0\".as_ptr() as *const _);\n@@ -864,7 +862,7 @@ impl ThinModule {\n             // little differently.\n             info!(\"running thin lto passes over {}\", module.name);\n             let config = cgcx.config(module.kind);\n-            run_pass_manager(cgcx, module.module_llvm.tm, llmod, config, true);\n+            run_pass_manager(cgcx, &module, config, true);\n             cgcx.save_temp_bitcode(&module, \"thin-lto-after-pm\");\n             timeline.record(\"thin-done\");\n         }"}, {"sha": "ba1315956fb2caa859cb156a49031f42566f4578", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -633,7 +633,7 @@ unsafe fn optimize(cgcx: &CodegenContext,\n                  None,\n                  &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n                  || {\n-            llvm::LLVMRunPassManager(mpm, llmod)\n+            llvm::LLVMRunPassManager(mpm, llmod);\n         });\n \n         // Deallocate managers that we're now done with\n@@ -691,6 +691,38 @@ unsafe fn codegen(cgcx: &CodegenContext,\n             create_msvc_imps(cgcx, llcx, llmod);\n         }\n \n+        // Ok now this one's a super interesting invocations. SIMD in rustc is\n+        // difficult where we want some parts of the program to be able to use\n+        // some SIMD features while other parts of the program don't. The real\n+        // tough part is that we want this to actually work correctly!\n+        //\n+        // We go to great lengths to make sure this works, and one crucial\n+        // aspect is that vector arguments (simd types) are never passed by\n+        // value in the ABI of functions. It turns out, however, that LLVM will\n+        // undo our \"clever work\" of passing vector types by reference. Its\n+        // argument promotion pass will promote these by-ref arguments to\n+        // by-val. That, however, introduces codegen errors!\n+        //\n+        // The upstream LLVM bug [1] has unfortunatey not really seen a lot of\n+        // activity. The Rust bug [2], however, has seen quite a lot of reports\n+        // of this in the wild. As a result, this is worked around locally here.\n+        // We have a custom transformation, `LLVMRustDemoteSimdArguments`, which\n+        // does the opposite of argument promotion by demoting any by-value SIMD\n+        // arguments in function signatures to pointers intead of being\n+        // by-value.\n+        //\n+        // This operates at the LLVM IR layer because LLVM is thwarting our\n+        // codegen and this is the only chance we get to make sure it's correct\n+        // before we hit codegen.\n+        //\n+        // Hopefully one day the upstream LLVM bug will be fixed and we'll no\n+        // longer need this!\n+        //\n+        // [1]: https://bugs.llvm.org/show_bug.cgi?id=37358\n+        // [2]: https://github.com/rust-lang/rust/issues/50154\n+        llvm::LLVMRustDemoteSimdArguments(llmod);\n+        cgcx.save_temp_bitcode(&module, \"simd-demoted\");\n+\n         // A codegen-specific pass manager is used to generate object\n         // files for an LLVM module.\n         //"}, {"sha": "e2b0142490933cbbc912d1bef2e2604382033179", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -1138,6 +1138,8 @@ extern \"C\" {\n     /// Runs a pass manager on a module.\n     pub fn LLVMRunPassManager(PM: &PassManager<'a>, M: &'a Module) -> Bool;\n \n+    pub fn LLVMRustDemoteSimdArguments(M: &'a Module);\n+\n     pub fn LLVMInitializePasses();\n \n     pub fn LLVMPassManagerBuilderCreate() -> &'static mut PassManagerBuilder;"}, {"sha": "ad5db19839ef0234476e43c1ef9b3859bd13f552", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -162,7 +162,9 @@ fn main() {\n     }\n \n     build_helper::rerun_if_changed_anything_in_dir(Path::new(\"../rustllvm\"));\n-    cfg.file(\"../rustllvm/PassWrapper.cpp\")\n+    cfg\n+       .file(\"../rustllvm/DemoteSimd.cpp\")\n+       .file(\"../rustllvm/PassWrapper.cpp\")\n        .file(\"../rustllvm/RustWrapper.cpp\")\n        .file(\"../rustllvm/ArchiveWrapper.cpp\")\n        .file(\"../rustllvm/Linker.cpp\")"}, {"sha": "5d6badf120286c42d5be864cae36f6efb33cc71c", "filename": "src/librustc_traits/chalk_context.rs", "status": "modified", "additions": 207, "deletions": 21, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_traits%2Fchalk_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_traits%2Fchalk_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -23,13 +23,15 @@ use rustc::traits::{\n     Goal,\n     GoalKind,\n     Clause,\n+    ProgramClauseCategory,\n     QuantifierKind,\n     Environment,\n     InEnvironment,\n };\n use rustc::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use rustc::ty::subst::Kind;\n use rustc::ty::{self, TyCtxt};\n+use rustc::hir::def_id::DefId;\n \n use std::fmt::{self, Debug};\n use std::marker::PhantomData;\n@@ -330,46 +332,230 @@ impl context::UnificationOps<ChalkArenas<'gcx>, ChalkArenas<'tcx>>\n {\n     fn program_clauses(\n         &self,\n-        _environment: &Environment<'tcx>,\n+        environment: &Environment<'tcx>,\n         goal: &DomainGoal<'tcx>,\n     ) -> Vec<Clause<'tcx>> {\n         use rustc::traits::WhereClause::*;\n \n-        match goal {\n-            DomainGoal::Holds(Implemented(_trait_predicate)) => {\n+        fn assemble_clauses_from_impls<'tcx>(\n+            tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+            trait_def_id: DefId,\n+            clauses: &mut Vec<Clause<'tcx>>\n+        ) {\n+            tcx.for_each_impl(trait_def_id, |impl_def_id| {\n+                clauses.extend(\n+                    tcx.program_clauses_for(impl_def_id)\n+                        .into_iter()\n+                        .cloned()\n+                );\n+            });\n+        }\n+\n+        fn assemble_clauses_from_assoc_ty_values<'tcx>(\n+            tcx: ty::TyCtxt<'_, '_, 'tcx>,\n+            trait_def_id: DefId,\n+            clauses: &mut Vec<Clause<'tcx>>\n+        ) {\n+            tcx.for_each_impl(trait_def_id, |impl_def_id| {\n+                for def_id in tcx.associated_item_def_ids(impl_def_id).iter() {\n+                    clauses.extend(\n+                        tcx.program_clauses_for(*def_id)\n+                            .into_iter()\n+                            .cloned()\n+                    );\n+                }\n+            });\n+        }\n+\n+        let mut clauses = match goal {\n+            DomainGoal::Holds(Implemented(trait_predicate)) => {\n+                // These come from:\n+                // * implementations of the trait itself (rule `Implemented-From-Impl`)\n+                // * the trait decl (rule `Implemented-From-Env`)\n+\n+                let mut clauses = vec![];\n+                assemble_clauses_from_impls(\n+                    self.infcx.tcx,\n+                    trait_predicate.def_id(),\n+                    &mut clauses\n+                );\n+\n+                // FIXME: we need to add special rules for builtin impls:\n+                // * `Copy` / `Clone`\n+                // * `Sized`\n+                // * `Unsize`\n+                // * `Generator`\n+                // * `FnOnce` / `FnMut` / `Fn`\n+                // * trait objects\n+                // * auto traits\n+\n+                // Rule `Implemented-From-Env` will be computed from the environment.\n+                clauses\n+            }\n+\n+            DomainGoal::Holds(ProjectionEq(projection_predicate)) => {\n+                // These come from:\n+                // * the assoc type definition (rule `ProjectionEq-Placeholder`)\n+                // * normalization of the assoc ty values (rule `ProjectionEq-Normalize`)\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                let clauses = self.infcx.tcx.program_clauses_for(\n+                    projection_predicate.projection_ty.item_def_id\n+                ).into_iter()\n+\n+                    // only select `ProjectionEq-Placeholder` and `ProjectionEq-Normalize`\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::Other)\n+\n+                    .cloned()\n+                    .collect::<Vec<_>>();\n+\n+                // Rules `Implied-Bound-From-Trait` and `Implied-Bound-From-Type` will be computed\n+                // from the environment.\n+                clauses\n+            }\n+\n+            DomainGoal::Holds(RegionOutlives(..)) => {\n                 // These come from:\n-                //\n-                // - Trait definitions (implied bounds)\n-                // - Implementations of the trait itself\n-                panic!()\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n             }\n \n-            DomainGoal::Holds(ProjectionEq(_projection_predicate)) => {\n+            DomainGoal::Holds(TypeOutlives(..)) => {\n                 // These come from:\n-                panic!()\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n             }\n \n-            DomainGoal::Holds(RegionOutlives(_region_outlives)) => {\n-                panic!()\n+            DomainGoal::WellFormed(WellFormed::Trait(trait_predicate)) => {\n+                // These come from -- the trait decl (rule `WellFormed-TraitRef`).\n+                self.infcx.tcx.program_clauses_for(trait_predicate.def_id())\n+                    .into_iter()\n+\n+                    // only select `WellFormed-TraitRef`\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n+\n+                    .cloned()\n+                    .collect()\n             }\n \n-            DomainGoal::Holds(TypeOutlives(_type_outlives)) => {\n-                panic!()\n+            DomainGoal::WellFormed(WellFormed::Ty(ty)) => {\n+                // These come from:\n+                // * the associated type definition if `ty` refers to an unnormalized\n+                //   associated type (rule `WellFormed-AssocTy`)\n+                // * custom rules for built-in types\n+                // * the type definition otherwise (rule `WellFormed-Type`)\n+                let clauses = match ty.sty {\n+                    ty::Projection(data) => {\n+                        self.infcx.tcx.program_clauses_for(data.item_def_id)\n+                    }\n+\n+                    // These types are always WF (recall that we do not check\n+                    // for parameters to be WF)\n+                    ty::Bool |\n+                    ty::Char |\n+                    ty::Int(..) |\n+                    ty::Uint(..) |\n+                    ty::Float(..) |\n+                    ty::Str |\n+                    ty::RawPtr(..) |\n+                    ty::FnPtr(..) |\n+                    ty::Param(..) |\n+                    ty::Never => {\n+                        ty::List::empty()\n+                    }\n+\n+                    // WF if inner type is `Sized`\n+                    ty::Slice(..) |\n+                    ty::Array(..) => {\n+                        ty::List::empty()\n+                    }\n+\n+                    ty::Tuple(..) => {\n+                        ty::List::empty()\n+                    }\n+\n+                    // WF if `sub_ty` outlives `region`\n+                    ty::Ref(..) => {\n+                        ty::List::empty()\n+                    }\n+\n+                    ty::Dynamic(..) => {\n+                        // FIXME: no rules yet for trait objects\n+                        ty::List::empty()\n+                    }\n+\n+                    ty::Adt(def, ..) => {\n+                        self.infcx.tcx.program_clauses_for(def.did)\n+                    }\n+\n+                    ty::Foreign(def_id) |\n+                    ty::FnDef(def_id, ..) |\n+                    ty::Closure(def_id, ..) |\n+                    ty::Generator(def_id, ..) |\n+                    ty::Opaque(def_id, ..) => {\n+                        self.infcx.tcx.program_clauses_for(def_id)\n+                    }\n+\n+                    ty::GeneratorWitness(..) |\n+                    ty::UnnormalizedProjection(..) |\n+                    ty::Infer(..) |\n+                    ty::Error => {\n+                        bug!(\"unexpected type {:?}\", ty)\n+                    }\n+                };\n+\n+                clauses.into_iter()\n+                    .filter(|clause| clause.category() == ProgramClauseCategory::WellFormed)\n+                    .cloned()\n+                    .collect()\n             }\n \n-            DomainGoal::WellFormed(WellFormed::Trait(_trait_predicate)) => {\n-                // These come from -- the trait decl.\n-                panic!()\n+            DomainGoal::FromEnv(FromEnv::Trait(..)) => {\n+                // These come from:\n+                // * implied bounds from trait definitions (rule `Implied-Bound-From-Trait`)\n+                // * implied bounds from type definitions (rule `Implied-Bound-From-Type`)\n+                // * implied bounds from assoc type defs (rules `Implied-Trait-From-AssocTy`,\n+                //   `Implied-Bound-From-AssocTy` and `Implied-WC-From-AssocTy`)\n+\n+                // All of these rules are computed in the environment.\n+                vec![]\n             }\n \n-            DomainGoal::WellFormed(WellFormed::Ty(_ty)) => panic!(),\n+            DomainGoal::FromEnv(FromEnv::Ty(..)) => {\n+                // There are no `FromEnv::Ty(..) :- ...` rules (this predicate only\n+                // comes from the environment).\n+                vec![]\n+            }\n \n-            DomainGoal::FromEnv(FromEnv::Trait(_trait_predicate)) => panic!(),\n+            DomainGoal::Normalize(projection_predicate) => {\n+                // These come from -- assoc ty values (rule `Normalize-From-Impl`).\n+                let mut clauses = vec![];\n \n-            DomainGoal::FromEnv(FromEnv::Ty(_ty)) => panic!(),\n+                assemble_clauses_from_assoc_ty_values(\n+                    self.infcx.tcx,\n+                    projection_predicate.projection_ty.trait_ref(self.infcx.tcx).def_id,\n+                    &mut clauses\n+                );\n \n-            DomainGoal::Normalize(_) => panic!(),\n-        }\n+                clauses\n+            }\n+        };\n+\n+        let environment = self.infcx.tcx.lift_to_global(environment)\n+            .expect(\"environment is not global\");\n+        clauses.extend(\n+            self.infcx.tcx.program_clauses_for_env(environment)\n+                .into_iter()\n+                .cloned()\n+        );\n+        clauses\n     }\n \n     fn instantiate_binders_universally("}, {"sha": "c71898f73ecad69267aa9f0b395ba479d47f411a", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -86,13 +86,16 @@ impl ClauseVisitor<'set, 'a, 'tcx> {\n             ty::Slice(..) |\n             ty::RawPtr(..) |\n             ty::FnPtr(..) |\n-            ty::Never |\n             ty::Tuple(..) |\n+            ty::Never |\n+            ty::Param(..) => (),\n+\n             ty::GeneratorWitness(..) |\n             ty::UnnormalizedProjection(..) |\n-            ty::Param(..) |\n             ty::Infer(..) |\n-            ty::Error => (),\n+            ty::Error => {\n+                bug!(\"unexpected type {:?}\", ty);\n+            }\n         }\n     }\n "}, {"sha": "46581397aee2db08f6fe2d21d8b93020f291ffad", "filename": "src/librustc_traits/lowering/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Flibrustc_traits%2Flowering%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fmod.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -433,7 +433,7 @@ pub fn program_clauses_for_associated_type_def<'a, 'tcx>(\n     let wf_clause = ProgramClause {\n         goal: DomainGoal::WellFormed(WellFormed::Ty(placeholder_ty)),\n         hypotheses: tcx.mk_goals(iter::once(hypothesis)),\n-        category: ProgramClauseCategory::Other,\n+        category: ProgramClauseCategory::WellFormed,\n     };\n \n     // Rule Implied-Trait-From-AssocTy"}, {"sha": "e9203baa0d7b13e899584609efcaaa2e62d99ccc", "filename": "src/rustllvm/DemoteSimd.cpp", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Frustllvm%2FDemoteSimd.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Frustllvm%2FDemoteSimd.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FDemoteSimd.cpp?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -0,0 +1,189 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <vector>\n+#include <set>\n+\n+#include \"rustllvm.h\"\n+\n+#if LLVM_VERSION_GE(5, 0)\n+\n+#include \"llvm/IR/CallSite.h\"\n+#include \"llvm/IR/Module.h\"\n+#include \"llvm/ADT/STLExtras.h\"\n+\n+using namespace llvm;\n+\n+static std::vector<Function*>\n+GetFunctionsWithSimdArgs(Module *M) {\n+  std::vector<Function*> Ret;\n+\n+  for (auto &F : M->functions()) {\n+    // Skip all intrinsic calls as these are always tightly controlled to \"work\n+    // correctly\", so no need to fixup any of these.\n+    if (F.isIntrinsic())\n+      continue;\n+\n+    // We're only interested in rustc-defined functions, not unstably-defined\n+    // imported SIMD ffi functions.\n+    if (F.isDeclaration())\n+      continue;\n+\n+    // Argument promotion only happens on internal functions, so skip demoting\n+    // arguments in external functions like FFI shims and such.\n+    if (!F.hasLocalLinkage())\n+      continue;\n+\n+    // If any argument to this function is a by-value vector type, then that's\n+    // bad! The compiler didn't generate any functions that looked like this,\n+    // and we try to rely on LLVM to not do this! Argument promotion may,\n+    // however, promote arguments from behind references. In any case, figure\n+    // out if we're interested in demoting this argument.\n+    if (any_of(F.args(), [](Argument &arg) { return arg.getType()->isVectorTy(); }))\n+      Ret.push_back(&F);\n+  }\n+\n+  return Ret;\n+}\n+\n+extern \"C\" void\n+LLVMRustDemoteSimdArguments(LLVMModuleRef Mod) {\n+  Module *M = unwrap(Mod);\n+\n+  auto Functions = GetFunctionsWithSimdArgs(M);\n+\n+  for (auto F : Functions) {\n+    // Build up our list of new parameters and new argument attributes.\n+    // We're only changing those arguments which are vector types.\n+    SmallVector<Type*, 8> Params;\n+    SmallVector<AttributeSet, 8> ArgAttrVec;\n+    auto PAL = F->getAttributes();\n+    for (auto &Arg : F->args()) {\n+      auto *Ty = Arg.getType();\n+      if (Ty->isVectorTy()) {\n+        Params.push_back(PointerType::get(Ty, 0));\n+        ArgAttrVec.push_back(AttributeSet());\n+      } else {\n+        Params.push_back(Ty);\n+        ArgAttrVec.push_back(PAL.getParamAttributes(Arg.getArgNo()));\n+      }\n+    }\n+\n+    // Replace `F` with a new function with our new signature. I'm... not really\n+    // sure how this works, but this is all the steps `ArgumentPromotion` does\n+    // to replace a signature as well.\n+    assert(!F->isVarArg()); // ArgumentPromotion should skip these fns\n+    FunctionType *NFTy = FunctionType::get(F->getReturnType(), Params, false);\n+    Function *NF = Function::Create(NFTy, F->getLinkage(), F->getName());\n+    NF->copyAttributesFrom(F);\n+    NF->setSubprogram(F->getSubprogram());\n+    F->setSubprogram(nullptr);\n+    NF->setAttributes(AttributeList::get(F->getContext(),\n+                                         PAL.getFnAttributes(),\n+                                         PAL.getRetAttributes(),\n+                                         ArgAttrVec));\n+    ArgAttrVec.clear();\n+    F->getParent()->getFunctionList().insert(F->getIterator(), NF);\n+    NF->takeName(F);\n+\n+    // Iterate over all invocations of `F`, updating all `call` instructions to\n+    // store immediate vector types in a local `alloc` instead of a by-value\n+    // vector.\n+    //\n+    // Like before, much of this is copied from the `ArgumentPromotion` pass in\n+    // LLVM.\n+    SmallVector<Value*, 16> Args;\n+    while (!F->use_empty()) {\n+      CallSite CS(F->user_back());\n+      assert(CS.getCalledFunction() == F);\n+      Instruction *Call = CS.getInstruction();\n+      const AttributeList &CallPAL = CS.getAttributes();\n+\n+      // Loop over the operands, inserting an `alloca` and a store for any\n+      // argument we're demoting to be by reference\n+      //\n+      // FIXME: we probably want to figure out an LLVM pass to run and clean up\n+      // this function and instructions we're generating, we should in theory\n+      // only generate a maximum number of `alloca` instructions rather than\n+      // one-per-variable unconditionally.\n+      CallSite::arg_iterator AI = CS.arg_begin();\n+      size_t ArgNo = 0;\n+      for (Function::arg_iterator I = F->arg_begin(), E = F->arg_end(); I != E;\n+           ++I, ++AI, ++ArgNo) {\n+        if (I->getType()->isVectorTy()) {\n+          AllocaInst *AllocA = new AllocaInst(I->getType(), 0, nullptr, \"\", Call);\n+          new StoreInst(*AI, AllocA, Call);\n+          Args.push_back(AllocA);\n+          ArgAttrVec.push_back(AttributeSet());\n+        } else {\n+          Args.push_back(*AI);\n+          ArgAttrVec.push_back(CallPAL.getParamAttributes(ArgNo));\n+        }\n+      }\n+      assert(AI == CS.arg_end());\n+\n+      // Create a new call instructions which we'll use to replace the old call\n+      // instruction, copying over as many attributes and such as possible.\n+      SmallVector<OperandBundleDef, 1> OpBundles;\n+      CS.getOperandBundlesAsDefs(OpBundles);\n+\n+      CallSite NewCS;\n+      if (InvokeInst *II = dyn_cast<InvokeInst>(Call)) {\n+        InvokeInst::Create(NF, II->getNormalDest(), II->getUnwindDest(),\n+                           Args, OpBundles, \"\", Call);\n+      } else {\n+        auto *NewCall = CallInst::Create(NF, Args, OpBundles, \"\", Call);\n+        NewCall->setTailCallKind(cast<CallInst>(Call)->getTailCallKind());\n+        NewCS = NewCall;\n+      }\n+      NewCS.setCallingConv(CS.getCallingConv());\n+      NewCS.setAttributes(\n+          AttributeList::get(F->getContext(), CallPAL.getFnAttributes(),\n+                             CallPAL.getRetAttributes(), ArgAttrVec));\n+      NewCS->setDebugLoc(Call->getDebugLoc());\n+      Args.clear();\n+      ArgAttrVec.clear();\n+      Call->replaceAllUsesWith(NewCS.getInstruction());\n+      NewCS->takeName(Call);\n+      Call->eraseFromParent();\n+    }\n+\n+    // Splice the body of the old function right into the new function.\n+    NF->getBasicBlockList().splice(NF->begin(), F->getBasicBlockList());\n+\n+    // Update our new function to replace all uses of the by-value argument with\n+    // loads of the pointer argument we've generated.\n+    //\n+    // FIXME: we probably want to only generate one load instruction per\n+    // function? Or maybe run an LLVM pass to clean up this function?\n+    for (Function::arg_iterator I = F->arg_begin(),\n+                                E = F->arg_end(),\n+                                I2 = NF->arg_begin();\n+         I != E;\n+         ++I, ++I2) {\n+      if (I->getType()->isVectorTy()) {\n+        I->replaceAllUsesWith(new LoadInst(&*I2, \"\", &NF->begin()->front()));\n+      } else {\n+        I->replaceAllUsesWith(&*I2);\n+      }\n+      I2->takeName(&*I);\n+    }\n+\n+    // Delete all references to the old function, it should be entirely dead\n+    // now.\n+    M->getFunctionList().remove(F);\n+  }\n+}\n+\n+#else // LLVM_VERSION_GE(8, 0)\n+extern \"C\" void\n+LLVMRustDemoteSimdArguments(LLVMModuleRef Mod) {\n+}\n+#endif // LLVM_VERSION_GE(8, 0)"}, {"sha": "3095432d0fe6965cc88171e506a9fd0021f0f8e3", "filename": "src/test/run-make/simd-argument-promotion-thwarted/Makefile", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2FMakefile?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -0,0 +1,13 @@\n+-include ../../run-make-fulldeps/tools.mk\n+\n+ifeq ($(TARGET),x86_64-unknown-linux-gnu)\n+all:\n+\t$(RUSTC) t1.rs -C opt-level=3\n+\t$(TMPDIR)/t1\n+\t$(RUSTC) t2.rs -C opt-level=3\n+\t$(TMPDIR)/t2\n+\t$(RUSTC) t3.rs -C opt-level=3\n+\t$(TMPDIR)/t3\n+else\n+all:\n+endif"}, {"sha": "cb4a3dd7d4a7cb978380cce0bafd0cfc9e2499cf", "filename": "src/test/run-make/simd-argument-promotion-thwarted/t1.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft1.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -0,0 +1,21 @@\n+use std::arch::x86_64;\n+\n+fn main() {\n+    if !is_x86_feature_detected!(\"avx2\") {\n+        return println!(\"AVX2 is not supported on this machine/build.\");\n+    }\n+    let load_bytes: [u8; 32] = [0x0f; 32];\n+    let lb_ptr = load_bytes.as_ptr();\n+    let reg_load = unsafe {\n+        x86_64::_mm256_loadu_si256(\n+            lb_ptr as *const x86_64::__m256i\n+        )\n+    };\n+    println!(\"{:?}\", reg_load);\n+    let mut store_bytes: [u8; 32] = [0; 32];\n+    let sb_ptr = store_bytes.as_mut_ptr();\n+    unsafe {\n+        x86_64::_mm256_storeu_si256(sb_ptr as *mut x86_64::__m256i, reg_load);\n+    }\n+    assert_eq!(load_bytes, store_bytes);\n+}"}, {"sha": "0e42b82a223d0aeab89c1880ab387c9f62dc9145", "filename": "src/test/run-make/simd-argument-promotion-thwarted/t2.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft2.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -0,0 +1,14 @@\n+use std::arch::x86_64::*;\n+\n+fn main() {\n+    if !is_x86_feature_detected!(\"avx\") {\n+        return println!(\"AVX is not supported on this machine/build.\");\n+    }\n+    unsafe {\n+        let f = _mm256_set_pd(2.0, 2.0, 2.0, 2.0);\n+        let r = _mm256_mul_pd(f, f);\n+\n+        union A { a: __m256d, b: [f64; 4] }\n+        assert_eq!(A { a: r }.b, [4.0, 4.0, 4.0, 4.0]);\n+    }\n+}"}, {"sha": "10062ab3e46438ce341da4dfc696f711eadf0aa8", "filename": "src/test/run-make/simd-argument-promotion-thwarted/t3.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsimd-argument-promotion-thwarted%2Ft3.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -0,0 +1,52 @@\n+use std::arch::x86_64::*;\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn avx_mul(a: __m256, b: __m256) -> __m256 {\n+    _mm256_mul_ps(a, b)\n+}\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn avx_store(p: *mut f32, a: __m256) {\n+    _mm256_storeu_ps(p, a)\n+}\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn avx_setr(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> __m256 {\n+    _mm256_setr_ps(a, b, c, d, e, f, g, h)\n+}\n+\n+#[target_feature(enable = \"avx\")]\n+unsafe fn avx_set1(a: f32) -> __m256 {\n+    _mm256_set1_ps(a)\n+}\n+\n+struct Avx(__m256);\n+\n+fn mul(a: Avx, b: Avx) -> Avx {\n+    unsafe { Avx(avx_mul(a.0, b.0)) }\n+}\n+\n+fn set1(a: f32) -> Avx {\n+    unsafe { Avx(avx_set1(a)) }\n+}\n+\n+fn setr(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32, h: f32) -> Avx {\n+    unsafe { Avx(avx_setr(a, b, c, d, e, f, g, h)) }\n+}\n+\n+unsafe fn store(p: *mut f32, a: Avx) {\n+    avx_store(p, a.0);\n+}\n+\n+fn main() {\n+    if !is_x86_feature_detected!(\"avx\") {\n+        return println!(\"AVX is not supported on this machine/build.\");\n+    }\n+    let mut result = [0.0f32; 8];\n+    let a = mul(setr(0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0), set1(0.25));\n+    unsafe {\n+        store(result.as_mut_ptr(), a);\n+    }\n+\n+    assert_eq!(result, [0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.50, 1.75]);\n+}"}, {"sha": "c5f5896d286c32480689b704ec9e27274b1121e5", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5418764ada3ce7b308de7a0e6e260548a635afc/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=d5418764ada3ce7b308de7a0e6e260548a635afc", "patch": "@@ -78,6 +78,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/tools/lldb\",\n         \"src/target\",\n         \"src/stdsimd\",\n+        \"target\",\n     ];\n     skip.iter().any(|p| path.ends_with(p))\n }"}]}