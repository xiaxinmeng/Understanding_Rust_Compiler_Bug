{"sha": "e8da7d4061960844502e3064c33eef4a0dc3828e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZGE3ZDQwNjE5NjA4NDQ1MDJlMzA2NGMzM2VlZjRhMGRjMzgyOGU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-22T14:31:30Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-22T14:31:30Z"}, "message": "Remove unused parameters", "tree": {"sha": "b2200ed8cd948ba10959dfa54bf31bba7badcb6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2200ed8cd948ba10959dfa54bf31bba7badcb6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8da7d4061960844502e3064c33eef4a0dc3828e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8da7d4061960844502e3064c33eef4a0dc3828e", "html_url": "https://github.com/rust-lang/rust/commit/e8da7d4061960844502e3064c33eef4a0dc3828e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8da7d4061960844502e3064c33eef4a0dc3828e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "558956c84be5e8752986bae001c7fd3f06cbe86d", "url": "https://api.github.com/repos/rust-lang/rust/commits/558956c84be5e8752986bae001c7fd3f06cbe86d", "html_url": "https://github.com/rust-lang/rust/commit/558956c84be5e8752986bae001c7fd3f06cbe86d"}], "stats": {"total": 36, "additions": 13, "deletions": 23}, "files": [{"sha": "71f44b55631b6eb1b68383294f4920741d4d45dd", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e8da7d4061960844502e3064c33eef4a0dc3828e/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8da7d4061960844502e3064c33eef4a0dc3828e/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=e8da7d4061960844502e3064c33eef4a0dc3828e", "patch": "@@ -111,7 +111,7 @@ impl ItemScope {\n         self.legacy_macros.insert(name, mac);\n     }\n \n-    pub(crate) fn push_res(&mut self, name: Name, res: &Resolution, _import: bool) -> bool {\n+    pub(crate) fn push_res(&mut self, name: Name, res: &Resolution) -> bool {\n         let mut changed = false;\n         let existing = self.visible.entry(name.clone()).or_default();\n "}, {"sha": "d27c3e19775ca929185d6025d7d10604aaafa477", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e8da7d4061960844502e3064c33eef4a0dc3828e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8da7d4061960844502e3064c33eef4a0dc3828e/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=e8da7d4061960844502e3064c33eef4a0dc3828e", "patch": "@@ -215,11 +215,7 @@ where\n         // In Rust, `#[macro_export]` macros are unconditionally visible at the\n         // crate root, even if the parent modules is **not** visible.\n         if export {\n-            self.update(\n-                self.def_map.root,\n-                None,\n-                &[(name, Resolution { def: PerNs::macros(macro_) })],\n-            );\n+            self.update(self.def_map.root, &[(name, Resolution { def: PerNs::macros(macro_) })]);\n         }\n     }\n \n@@ -373,7 +369,7 @@ where\n                         // Module scoped macros is included\n                         let items = scope.collect_resolutions();\n \n-                        self.update(module_id, Some(import_id), &items);\n+                        self.update(module_id, &items);\n                     } else {\n                         // glob import from same crate => we do an initial\n                         // import, and then need to propagate any further\n@@ -383,7 +379,7 @@ where\n                         // Module scoped macros is included\n                         let items = scope.collect_resolutions();\n \n-                        self.update(module_id, Some(import_id), &items);\n+                        self.update(module_id, &items);\n                         // record the glob import in case we add further items\n                         let glob = self.glob_imports.entry(m.local_id).or_default();\n                         if !glob.iter().any(|it| *it == (module_id, import_id)) {\n@@ -406,7 +402,7 @@ where\n                             (name, res)\n                         })\n                         .collect::<Vec<_>>();\n-                    self.update(module_id, Some(import_id), &resolutions);\n+                    self.update(module_id, &resolutions);\n                 }\n                 Some(d) => {\n                     log::debug!(\"glob import {:?} from non-module/enum {:?}\", import, d);\n@@ -429,26 +425,20 @@ where\n                     }\n \n                     let resolution = Resolution { def };\n-                    self.update(module_id, Some(import_id), &[(name, resolution)]);\n+                    self.update(module_id, &[(name, resolution)]);\n                 }\n                 None => tested_by!(bogus_paths),\n             }\n         }\n     }\n \n-    fn update(\n-        &mut self,\n-        module_id: LocalModuleId,\n-        import: Option<raw::Import>,\n-        resolutions: &[(Name, Resolution)],\n-    ) {\n-        self.update_recursive(module_id, import, resolutions, 0)\n+    fn update(&mut self, module_id: LocalModuleId, resolutions: &[(Name, Resolution)]) {\n+        self.update_recursive(module_id, resolutions, 0)\n     }\n \n     fn update_recursive(\n         &mut self,\n         module_id: LocalModuleId,\n-        import: Option<raw::Import>,\n         resolutions: &[(Name, Resolution)],\n         depth: usize,\n     ) {\n@@ -459,7 +449,7 @@ where\n         let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            changed |= scope.push_res(name.clone(), res, import.is_some());\n+            changed |= scope.push_res(name.clone(), res);\n         }\n \n         if !changed {\n@@ -472,9 +462,9 @@ where\n             .flat_map(|v| v.iter())\n             .cloned()\n             .collect::<Vec<_>>();\n-        for (glob_importing_module, glob_import) in glob_imports {\n+        for (glob_importing_module, _glob_import) in glob_imports {\n             // We pass the glob import so that the tracked import in those modules is that glob import\n-            self.update_recursive(glob_importing_module, Some(glob_import), resolutions, depth + 1);\n+            self.update_recursive(glob_importing_module, resolutions, depth + 1);\n         }\n     }\n \n@@ -716,7 +706,7 @@ where\n         let def: ModuleDefId = module.into();\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n         let resolution = Resolution { def: def.into() };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)]);\n+        self.def_collector.update(self.module_id, &[(name, resolution)]);\n         res\n     }\n \n@@ -776,7 +766,7 @@ where\n         };\n         self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n         let resolution = Resolution { def: def.into() };\n-        self.def_collector.update(self.module_id, None, &[(name, resolution)])\n+        self.def_collector.update(self.module_id, &[(name, resolution)])\n     }\n \n     fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {"}]}