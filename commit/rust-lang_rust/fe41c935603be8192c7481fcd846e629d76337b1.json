{"sha": "fe41c935603be8192c7481fcd846e629d76337b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNDFjOTM1NjAzYmU4MTkyYzc0ODFmY2Q4NDZlNjI5ZDc2MzM3YjE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-06T03:31:50Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-06T03:31:50Z"}, "message": "Rollup merge of #23081 - alexcrichton:stabilize-fs, r=aturon\n\n This commit performs a stabilization pass over the `std::fs` module now that\nit's had some time to bake. The change was largely just adding `#[stable]` tags,\nbut there are a few APIs that remain `#[unstable]`.\n\nThe following apis are now marked `#[stable]`:\n\n* `std::fs` (the name)\n* `File`\n* `Metadata`\n* `ReadDir`\n* `DirEntry`\n* `OpenOptions`\n* `Permissions`\n* `File::{open, create}`\n* `File::{sync_all, sync_data}`\n* `File::set_len`\n* `File::metadata`\n* Trait implementations for `File` and `&File`\n* `OpenOptions::new`\n* `OpenOptions::{read, write, append, truncate, create}`\n* `OpenOptions::open` - this function was modified, however, to not attempt to\n  reject cross-platform openings of directories. This means that some platforms\n  will succeed in opening a directory and others will fail.\n* `Metadata::{is_dir, is_file, len, permissions}`\n* `Permissions::{readonly, set_readonly}`\n* `Iterator for ReadDir`\n* `DirEntry::path`\n* `remove_file` - like with `OpenOptions::open`, the extra windows code to\n  remove a readonly file has been removed. This means that removing a readonly\n  file will succeed on some platforms but fail on others.\n* `metadata`\n* `rename`\n* `copy`\n* `hard_link`\n* `soft_link`\n* `read_link`\n* `create_dir`\n* `create_dir_all`\n* `remove_dir`\n* `remove_dir_all`\n* `read_dir`\n\nThe following apis remain `#[unstable]`.\n\n* `WalkDir` and `walk` - there are many methods by which a directory walk can be\n  constructed, and it's unclear whether the current semantics are the right\n  ones. For example symlinks are not handled super well currently. This is now\n  behind a new `fs_walk` feature.\n* `File::path` - this is an extra abstraction which the standard library\n  provides on top of what the system offers and it's unclear whether we should\n  be doing so. This is now behind a new `file_path` feature.\n* `Metadata::{accessed, modified}` - we do not currently have a good\n  abstraction for a moment in time which is what these APIs should likely be\n  returning, so these remain `#[unstable]` for now. These are now behind a new\n  `fs_time` feature\n* `set_file_times` - like with `Metadata::accessed`, we do not currently have\n  the appropriate abstraction for the arguments here so this API remains\n  unstable behind the `fs_time` feature gate.\n* `PathExt` - the precise set of methods on this trait may change over time and\n  some methods may be removed. This API remains unstable behind the `path_ext`\n  feature gate.\n* `set_permissions` - we may wish to expose a more granular ability to set the\n  permissions on a file instead of just a blanket \\\"set all permissions\\\" method.\n  This function remains behind the `fs` feature.\n\nThe following apis are now `#[deprecated]`\n\n* The `TempDir` type is now entirely deprecated and is [located on\n  crates.io][tempdir] as the `tempdir` crate with [its source][github] at\n  rust-lang/tempdir.\n\n[tempdir]: https://crates.io/crates/tempdir\n[github]: https://github.com/rust-lang/tempdir\n\nThe stability of some of these APIs has been questioned over the past few weeks\nin using these APIs, and it is intentional that the majority of APIs here are\nmarked `#[stable]`. The `std::fs` module has a lot of room to grow and the\nmaterial is [being tracked in a RFC issue][rfc-issue].\n\n[rfc-issue]: rust-lang/rfcs#939\n\nCloses #22879\n\n[breaking-change]", "tree": {"sha": "5ac36a3a43faf5b042f994d7604d6b1a8c1e63b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ac36a3a43faf5b042f994d7604d6b1a8c1e63b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe41c935603be8192c7481fcd846e629d76337b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe41c935603be8192c7481fcd846e629d76337b1", "html_url": "https://github.com/rust-lang/rust/commit/fe41c935603be8192c7481fcd846e629d76337b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe41c935603be8192c7481fcd846e629d76337b1/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9063e0f98da9eb0cb30427010614ea634b409ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9063e0f98da9eb0cb30427010614ea634b409ed", "html_url": "https://github.com/rust-lang/rust/commit/c9063e0f98da9eb0cb30427010614ea634b409ed"}, {"sha": "73b0b25e326687aba319df99aee4b0c4124d4498", "url": "https://api.github.com/repos/rust-lang/rust/commits/73b0b25e326687aba319df99aee4b0c4124d4498", "html_url": "https://github.com/rust-lang/rust/commit/73b0b25e326687aba319df99aee4b0c4124d4498"}], "stats": {"total": 285, "additions": 229, "deletions": 56}, "files": [{"sha": "a7531152a84006034067fb2b5ef5ed37641ca531", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -24,8 +24,8 @@\n #![feature(path)]\n #![feature(os)]\n #![feature(io)]\n-#![feature(fs)]\n #![feature(net)]\n+#![feature(path_ext)]\n \n #![deny(warnings)]\n "}, {"sha": "49a062ca3e4bab13f3e866a0d5ea4894f91719df", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -92,8 +92,8 @@\n #![feature(collections)]\n #![feature(int_uint)]\n #![feature(staged_api)]\n-#![feature(str_words)]\n #![feature(core)]\n+#![feature(str_words)]\n #![cfg_attr(test, feature(rustc_private))]\n \n #[cfg(test)] #[macro_use] extern crate log;"}, {"sha": "027360b31ad462bc5afc8ec5920ec8650d151a57", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -40,8 +40,8 @@\n #![feature(std_misc)]\n #![feature(os)]\n #![feature(path)]\n-#![feature(fs)]\n #![feature(io)]\n+#![feature(path_ext)]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "ed44bf8952951ae6363d04bed52eb3c2a9d1f83f", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -11,14 +11,16 @@\n //! A helper class for dealing with static archives\n \n use std::env;\n-use std::fs::{self, TempDir};\n+use std::fs;\n use std::io::prelude::*;\n use std::io;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Output, Stdio};\n use std::str;\n use syntax::diagnostic::Handler as ErrorHandler;\n \n+use tempdir::TempDir;\n+\n pub const METADATA_FILENAME: &'static str = \"rust.metadata.bin\";\n \n pub struct ArchiveConfig<'a> {"}, {"sha": "a7ae9661c3d8329a57585854cf946ad6c08297b1", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -34,7 +34,6 @@\n #![feature(collections)]\n #![feature(core)]\n #![feature(old_fs)]\n-#![feature(fs)]\n #![feature(hash)]\n #![feature(int_uint)]\n #![feature(io)]\n@@ -44,14 +43,16 @@\n #![feature(path)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![feature(tempdir)]\n+#![feature(rand)]\n+#![feature(path_ext)]\n \n extern crate syntax;\n extern crate serialize;\n #[macro_use] extern crate log;\n \n pub mod abi;\n pub mod archive;\n+pub mod tempdir;\n pub mod arm;\n pub mod fs;\n pub mod mips;"}, {"sha": "4d8619a81216f940c6d14633703836187503fd71", "filename": "src/librustc_back/tempdir.rs", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env;\n+use std::io::{self, Error, ErrorKind};\n+use std::fs;\n+use std::path::{self, PathBuf, AsPath};\n+use std::rand::{thread_rng, Rng};\n+\n+/// A wrapper for a path to temporary directory implementing automatic\n+/// scope-based deletion.\n+pub struct TempDir {\n+    path: Option<PathBuf>,\n+}\n+\n+// How many times should we (re)try finding an unused random name? It should be\n+// enough that an attacker will run out of luck before we run out of patience.\n+const NUM_RETRIES: u32 = 1 << 31;\n+// How many characters should we include in a random file name? It needs to\n+// be enough to dissuade an attacker from trying to preemptively create names\n+// of that length, but not so huge that we unnecessarily drain the random number\n+// generator of entropy.\n+const NUM_RAND_CHARS: uint = 12;\n+\n+impl TempDir {\n+    /// Attempts to make a temporary directory inside of `tmpdir` whose name\n+    /// will have the prefix `prefix`. The directory will be automatically\n+    /// deleted once the returned wrapper is destroyed.\n+    ///\n+    /// If no directory can be created, `Err` is returned.\n+    #[allow(deprecated)] // rand usage\n+    pub fn new_in<P: AsPath + ?Sized>(tmpdir: &P, prefix: &str)\n+                                      -> io::Result<TempDir> {\n+        let storage;\n+        let mut tmpdir = tmpdir.as_path();\n+        if !tmpdir.is_absolute() {\n+            let cur_dir = try!(env::current_dir());\n+            storage = cur_dir.join(tmpdir);\n+            tmpdir = &storage;\n+            // return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n+        }\n+\n+        let mut rng = thread_rng();\n+        for _ in 0..NUM_RETRIES {\n+            let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n+            let leaf = if prefix.len() > 0 {\n+                format!(\"{}.{}\", prefix, suffix)\n+            } else {\n+                // If we're given an empty string for a prefix, then creating a\n+                // directory starting with \".\" would lead to it being\n+                // semi-invisible on some systems.\n+                suffix\n+            };\n+            let path = tmpdir.join(&leaf);\n+            match fs::create_dir(&path) {\n+                Ok(_) => return Ok(TempDir { path: Some(path) }),\n+                Err(ref e) if e.kind() == ErrorKind::PathAlreadyExists => {}\n+                Err(e) => return Err(e)\n+            }\n+        }\n+\n+        Err(Error::new(ErrorKind::PathAlreadyExists,\n+                       \"too many temporary directories already exist\",\n+                       None))\n+    }\n+\n+    /// Attempts to make a temporary directory inside of `env::temp_dir()` whose\n+    /// name will have the prefix `prefix`. The directory will be automatically\n+    /// deleted once the returned wrapper is destroyed.\n+    ///\n+    /// If no directory can be created, `Err` is returned.\n+    #[allow(deprecated)]\n+    pub fn new(prefix: &str) -> io::Result<TempDir> {\n+        TempDir::new_in(&env::temp_dir(), prefix)\n+    }\n+\n+    /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper.\n+    /// This discards the wrapper so that the automatic deletion of the\n+    /// temporary directory is prevented.\n+    pub fn into_path(mut self) -> PathBuf {\n+        self.path.take().unwrap()\n+    }\n+\n+    /// Access the wrapped `std::path::Path` to the temporary directory.\n+    pub fn path(&self) -> &path::Path {\n+        self.path.as_ref().unwrap()\n+    }\n+\n+    /// Close and remove the temporary directory\n+    ///\n+    /// Although `TempDir` removes the directory on drop, in the destructor\n+    /// any errors are ignored. To detect errors cleaning up the temporary\n+    /// directory, call `close` instead.\n+    pub fn close(mut self) -> io::Result<()> {\n+        self.cleanup_dir()\n+    }\n+\n+    fn cleanup_dir(&mut self) -> io::Result<()> {\n+        match self.path {\n+            Some(ref p) => fs::remove_dir_all(p),\n+            None => Ok(())\n+        }\n+    }\n+}\n+\n+impl Drop for TempDir {\n+    fn drop(&mut self) {\n+        let _ = self.cleanup_dir();\n+    }\n+}\n+\n+// the tests for this module need to change the path using change_dir,\n+// and this doesn't play nicely with other tests so these unit tests are located\n+// in src/test/run-pass/tempfile.rs"}, {"sha": "3743b7d9c7d9f8a96ad21b1d187f07331435ed35", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -39,7 +39,6 @@\n #![feature(exit_status)]\n #![feature(path)]\n #![feature(io)]\n-#![feature(fs)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "f353c69eca299b389384a95bab37605db61b74bf", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -26,9 +26,10 @@ use middle::ty::{self, Ty};\n use util::common::time;\n use util::ppaux;\n use util::sha2::{Digest, Sha256};\n+use rustc_back::tempdir::TempDir;\n \n use std::ffi::{AsOsStr, OsString};\n-use std::fs::{self, TempDir, PathExt};\n+use std::fs::{self, PathExt};\n use std::io::{self, Read, Write};\n use std::mem;\n use std::path::{Path, PathBuf};"}, {"sha": "7cdd1d0a456cc735eb536643980f6b42250776c2", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -38,10 +38,10 @@\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(io)]\n-#![feature(fs)]\n #![feature(path)]\n #![feature(os)]\n-#![feature(tempdir)]\n+#![feature(path_ext)]\n+#![feature(fs)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "712168ae7067996d45888adb645e551c9fce044a", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -35,9 +35,8 @@\n #![feature(unicode)]\n #![feature(str_words)]\n #![feature(io)]\n-#![feature(fs)]\n #![feature(path)]\n-#![feature(tempdir)]\n+#![feature(path_ext)]\n \n extern crate arena;\n extern crate getopts;\n@@ -47,6 +46,7 @@ extern crate rustc_trans;\n extern crate rustc_driver;\n extern crate rustc_resolve;\n extern crate rustc_lint;\n+extern crate rustc_back;\n extern crate serialize;\n extern crate syntax;\n extern crate \"test\" as testing;"}, {"sha": "c785d78dc9303e1247e87298cc9fca6c2adcc899", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -13,7 +13,6 @@ use std::collections::{HashSet, HashMap};\n use std::dynamic_lib::DynamicLibrary;\n use std::env;\n use std::ffi::OsString;\n-use std::fs::TempDir;\n use std::old_io;\n use std::io;\n use std::path::PathBuf;\n@@ -28,6 +27,7 @@ use rustc_lint;\n use rustc::session::{self, config};\n use rustc::session::config::get_unstable_features_setting;\n use rustc::session::search_paths::{SearchPaths, PathKind};\n+use rustc_back::tempdir::TempDir;\n use rustc_driver::{driver, Compilation};\n use syntax::codemap::CodeMap;\n use syntax::diagnostic;"}, {"sha": "ef2dd65a81610bc20374c3e9834fd57e1925a2cc", "filename": "src/libstd/fs/mod.rs", "status": "modified", "additions": 83, "deletions": 37, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibstd%2Ffs%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibstd%2Ffs%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Fmod.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -15,7 +15,7 @@\n //! operations. Extra platform-specific functionality can be found in the\n //! extension traits of `std::os::$platform`.\n \n-#![unstable(feature = \"fs\")]\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::prelude::*;\n \n@@ -25,6 +25,7 @@ use sys::fs2 as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n use vec::Vec;\n \n+#[allow(deprecated)]\n pub use self::tempdir::TempDir;\n \n mod tempdir;\n@@ -52,6 +53,7 @@ mod tempdir;\n /// # Ok(())\n /// # }\n /// ```\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct File {\n     inner: fs_imp::File,\n     path: PathBuf,\n@@ -62,6 +64,7 @@ pub struct File {\n /// This structure is returned from the `metadata` function or method and\n /// represents known metadata about a file such as its permissions, size,\n /// modification times, etc.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Metadata(fs_imp::FileAttr);\n \n /// Iterator over the entries in a directory.\n@@ -70,16 +73,22 @@ pub struct Metadata(fs_imp::FileAttr);\n /// will yield instances of `io::Result<DirEntry>`. Through a `DirEntry`\n /// information like the entry's path and possibly other metadata can be\n /// learned.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ReadDir(fs_imp::ReadDir);\n \n /// Entries returned by the `ReadDir` iterator.\n ///\n /// An instance of `DirEntry` represents an entry inside of a directory on the\n /// filesystem. Each entry can be inspected via methods to learn about the full\n /// path or possibly other metadata through per-platform extension traits.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct DirEntry(fs_imp::DirEntry);\n \n /// An iterator that recursively walks over the contents of a directory.\n+#[unstable(feature = \"fs_walk\",\n+           reason = \"the precise semantics and defaults for a recursive walk \\\n+                     may change and this may end up accounting for files such \\\n+                     as symlinks differently\")]\n pub struct WalkDir {\n     cur: Option<ReadDir>,\n     stack: Vec<io::Result<ReadDir>>,\n@@ -92,6 +101,7 @@ pub struct WalkDir {\n /// `File::create` methods are aliases for commonly used options using this\n /// builder.\n #[derive(Clone)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OpenOptions(fs_imp::OpenOptions);\n \n /// Representation of the various permissions on a file.\n@@ -101,6 +111,7 @@ pub struct OpenOptions(fs_imp::OpenOptions);\n /// functionality, such as mode bits, is available through the\n /// `os::unix::PermissionsExt` trait.\n #[derive(Clone, PartialEq, Eq, Debug)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Permissions(fs_imp::FilePermissions);\n \n impl File {\n@@ -112,6 +123,7 @@ impl File {\n     ///\n     /// This function will return an error if `path` does not already exist.\n     /// Other errors may also be returned according to `OpenOptions::open`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn open<P: AsPath + ?Sized>(path: &P) -> io::Result<File> {\n         OpenOptions::new().read(true).open(path)\n     }\n@@ -122,11 +134,15 @@ impl File {\n     /// and will truncate it if it does.\n     ///\n     /// See the `OpenOptions::open` function for more details.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn create<P: AsPath + ?Sized>(path: &P) -> io::Result<File> {\n         OpenOptions::new().write(true).create(true).truncate(true).open(path)\n     }\n \n     /// Returns the original path that was used to open this file.\n+    #[unstable(feature = \"file_path\",\n+               reason = \"this abstraction is imposed by this library instead \\\n+                         of the underlying OS and may be removed\")]\n     pub fn path(&self) -> Option<&Path> {\n         Some(&self.path)\n     }\n@@ -135,6 +151,7 @@ impl File {\n     ///\n     /// This function will attempt to ensure that all in-core data reaches the\n     /// filesystem before returning.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn sync_all(&self) -> io::Result<()> {\n         self.inner.fsync()\n     }\n@@ -148,6 +165,7 @@ impl File {\n     ///\n     /// Note that some platforms may simply implement this in terms of\n     /// `sync_all`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn sync_data(&self) -> io::Result<()> {\n         self.inner.datasync()\n     }\n@@ -159,11 +177,13 @@ impl File {\n     /// be shrunk. If it is greater than the current file's size, then the file\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_len(&self, size: u64) -> io::Result<()> {\n         self.inner.truncate(size)\n     }\n \n-    /// Queries information about the underlying file.\n+    /// Queries metadata about the underlying file.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn metadata(&self) -> io::Result<Metadata> {\n         self.inner.file_attr().map(Metadata)\n     }\n@@ -172,33 +192,39 @@ impl File {\n impl AsInner<fs_imp::File> for File {\n     fn as_inner(&self) -> &fs_imp::File { &self.inner }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for File {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for File {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.write(buf)\n     }\n     fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Seek for File {\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n         self.inner.seek(pos)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for &'a File {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for &'a File {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.write(buf)\n     }\n     fn flush(&mut self) -> io::Result<()> { self.inner.flush() }\n }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Seek for &'a File {\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n         self.inner.seek(pos)\n@@ -209,6 +235,7 @@ impl OpenOptions {\n     /// Creates a blank net set of options ready for configuration.\n     ///\n     /// All options are initially set to `false`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> OpenOptions {\n         OpenOptions(fs_imp::OpenOptions::new())\n     }\n@@ -217,6 +244,7 @@ impl OpenOptions {\n     ///\n     /// This option, when true, will indicate that the file should be\n     /// `read`-able if opened.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn read(&mut self, read: bool) -> &mut OpenOptions {\n         self.0.read(read); self\n     }\n@@ -225,6 +253,7 @@ impl OpenOptions {\n     ///\n     /// This option, when true, will indicate that the file should be\n     /// `write`-able if opened.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn write(&mut self, write: bool) -> &mut OpenOptions {\n         self.0.write(write); self\n     }\n@@ -233,6 +262,7 @@ impl OpenOptions {\n     ///\n     /// This option, when true, means that writes will append to a file instead\n     /// of overwriting previous contents.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn append(&mut self, append: bool) -> &mut OpenOptions {\n         self.0.append(append); self\n     }\n@@ -241,6 +271,7 @@ impl OpenOptions {\n     ///\n     /// If a file is successfully opened with this option set it will truncate\n     /// the file to 0 length if it already exists.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, truncate: bool) -> &mut OpenOptions {\n         self.0.truncate(truncate); self\n     }\n@@ -249,6 +280,7 @@ impl OpenOptions {\n     ///\n     /// This option indicates whether a new file will be created if the file\n     /// does not yet already exist.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn create(&mut self, create: bool) -> &mut OpenOptions {\n         self.0.create(create); self\n     }\n@@ -264,60 +296,66 @@ impl OpenOptions {\n     /// * Attempting to open a file with access that the user lacks\n     ///   permissions for\n     /// * Filesystem-level errors (full disk, etc)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn open<P: AsPath + ?Sized>(&self, path: &P) -> io::Result<File> {\n         let path = path.as_path();\n         let inner = try!(fs_imp::File::open(path, &self.0));\n-\n-        // On *BSD systems, we can open a directory as a file and read from\n-        // it: fd=open(\"/tmp\", O_RDONLY); read(fd, buf, N); due to an old\n-        // tradition before the introduction of opendir(3).  We explicitly\n-        // reject it because there are few use cases.\n-        if cfg!(not(any(target_os = \"linux\", target_os = \"android\"))) &&\n-           try!(inner.file_attr()).is_dir() {\n-            Err(Error::new(ErrorKind::InvalidInput, \"is a directory\", None))\n-        } else {\n-            Ok(File { path: path.to_path_buf(), inner: inner })\n-        }\n+        Ok(File { path: path.to_path_buf(), inner: inner })\n     }\n }\n+\n impl AsInnerMut<fs_imp::OpenOptions> for OpenOptions {\n     fn as_inner_mut(&mut self) -> &mut fs_imp::OpenOptions { &mut self.0 }\n }\n \n impl Metadata {\n     /// Returns whether this metadata is for a directory.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_dir(&self) -> bool { self.0.is_dir() }\n \n     /// Returns whether this metadata is for a regular file.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_file(&self) -> bool { self.0.is_file() }\n \n     /// Returns the size of the file, in bytes, this metadata is for.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> u64 { self.0.size() }\n \n     /// Returns the permissions of the file this metadata is for.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn permissions(&self) -> Permissions {\n         Permissions(self.0.perm())\n     }\n \n     /// Returns the most recent access time for a file.\n     ///\n     /// The return value is in milliseconds since the epoch.\n+    #[unstable(feature = \"fs_time\",\n+               reason = \"the return type of u64 is not quite appropriate for \\\n+                         this method and may change if the standard library \\\n+                         gains a type to represent a moment in time\")]\n     pub fn accessed(&self) -> u64 { self.0.accessed() }\n \n     /// Returns the most recent modification time for a file.\n     ///\n     /// The return value is in milliseconds since the epoch.\n+    #[unstable(feature = \"fs_time\",\n+               reason = \"the return type of u64 is not quite appropriate for \\\n+                         this method and may change if the standard library \\\n+                         gains a type to represent a moment in time\")]\n     pub fn modified(&self) -> u64 { self.0.modified() }\n }\n \n impl Permissions {\n     /// Returns whether these permissions describe a readonly file.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn readonly(&self) -> bool { self.0.readonly() }\n \n     /// Modify the readonly flag for this set of permissions.\n     ///\n     /// This operation does **not** modify the filesystem. To modify the\n     /// filesystem use the `fs::set_permissions` function.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_readonly(&mut self, readonly: bool) {\n         self.0.set_readonly(readonly)\n     }\n@@ -333,6 +371,7 @@ impl AsInner<fs_imp::FilePermissions> for Permissions {\n     fn as_inner(&self) -> &fs_imp::FilePermissions { &self.0 }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n \n@@ -341,11 +380,13 @@ impl Iterator for ReadDir {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl DirEntry {\n     /// Returns the full path to the file that this entry represents.\n     ///\n     /// The full path is created by joining the original path to `read_dir` or\n     /// `walk_dir` with the filename of this entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn path(&self) -> PathBuf { self.0.path() }\n }\n \n@@ -368,31 +409,9 @@ impl DirEntry {\n /// This function will return an error if `path` points to a directory, if the\n /// user lacks permissions to remove the file, or if some other filesystem-level\n /// error occurs.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn remove_file<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n-    let path = path.as_path();\n-    let e = match fs_imp::unlink(path) {\n-        Ok(()) => return Ok(()),\n-        Err(e) => e,\n-    };\n-    if !cfg!(windows) { return Err(e) }\n-\n-    // On unix, a readonly file can be successfully removed. On windows,\n-    // however, it cannot. To keep the two platforms in line with\n-    // respect to their behavior, catch this case on windows, attempt to\n-    // change it to read-write, and then remove the file.\n-    if e.kind() != ErrorKind::PermissionDenied { return Err(e) }\n-\n-    let attr = match metadata(path) { Ok(a) => a, Err(..) => return Err(e) };\n-    let mut perms = attr.permissions();\n-    if !perms.readonly() { return Err(e) }\n-    perms.set_readonly(false);\n-\n-    if set_permissions(path, perms).is_err() { return Err(e) }\n-    if fs_imp::unlink(path).is_ok() { return Ok(()) }\n-\n-    // Oops, try to put things back the way we found it\n-    let _ = set_permissions(path, attr.permissions());\n-    Err(e)\n+    fs_imp::unlink(path.as_path())\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -418,6 +437,7 @@ pub fn remove_file<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n /// This function will return an error if the user lacks the requisite\n /// permissions to perform a `metadata` call on the given `path` or if there\n /// is no entry in the filesystem at the provided path.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn metadata<P: AsPath + ?Sized>(path: &P) -> io::Result<Metadata> {\n     fs_imp::stat(path.as_path()).map(Metadata)\n }\n@@ -438,6 +458,7 @@ pub fn metadata<P: AsPath + ?Sized>(path: &P) -> io::Result<Metadata> {\n /// the process lacks permissions to view the contents, if `from` and `to`\n /// reside on separate filesystems, or if some other intermittent I/O error\n /// occurs.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn rename<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)\n                                                       -> io::Result<()> {\n     fs_imp::rename(from.as_path(), to.as_path())\n@@ -468,6 +489,7 @@ pub fn rename<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)\n /// * The `from` file does not exist\n /// * The current process does not have the permission rights to access\n ///   `from` or write `to`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn copy<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)\n                                                     -> io::Result<u64> {\n     let from = from.as_path();\n@@ -490,6 +512,7 @@ pub fn copy<P: AsPath + ?Sized, Q: AsPath + ?Sized>(from: &P, to: &Q)\n ///\n /// The `dst` path will be a link pointing to the `src` path. Note that systems\n /// often require these two paths to both be located on the same filesystem.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn hard_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)\n                                                          -> io::Result<()> {\n     fs_imp::link(src.as_path(), dst.as_path())\n@@ -498,6 +521,7 @@ pub fn hard_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)\n /// Creates a new soft link on the filesystem.\n ///\n /// The `dst` path will be a soft link pointing to the `src` path.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn soft_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)\n                                                          -> io::Result<()> {\n     fs_imp::symlink(src.as_path(), dst.as_path())\n@@ -510,6 +534,7 @@ pub fn soft_link<P: AsPath + ?Sized, Q: AsPath + ?Sized>(src: &P, dst: &Q)\n /// This function will return an error on failure. Failure conditions include\n /// reading a file that does not exist or reading a file that is not a soft\n /// link.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn read_link<P: AsPath + ?Sized>(path: &P) -> io::Result<PathBuf> {\n     fs_imp::readlink(path.as_path())\n }\n@@ -528,6 +553,7 @@ pub fn read_link<P: AsPath + ?Sized>(path: &P) -> io::Result<PathBuf> {\n ///\n /// This function will return an error if the user lacks permissions to make a\n /// new directory at the provided `path`, or if the directory already exists.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn create_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n     fs_imp::mkdir(path.as_path())\n }\n@@ -541,6 +567,7 @@ pub fn create_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n /// does not already exist and it could not be created otherwise. The specific\n /// error conditions for when a directory is being created (after it is\n /// determined to not exist) are outlined by `fs::create_dir`.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn create_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n     let path = path.as_path();\n     if path.is_dir() { return Ok(()) }\n@@ -572,6 +599,7 @@ pub fn create_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n ///\n /// This function will return an error if the user lacks permissions to remove\n /// the directory at the provided `path`, or if the directory isn't empty.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn remove_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n     fs_imp::rmdir(path.as_path())\n }\n@@ -585,6 +613,7 @@ pub fn remove_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n /// # Errors\n ///\n /// See `file::remove_file` and `fs::remove_dir`\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn remove_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n     let path = path.as_path();\n     for child in try!(read_dir(path)) {\n@@ -637,6 +666,7 @@ pub fn remove_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n /// This function will return an error if the provided `path` doesn't exist, if\n /// the process lacks permissions to view the contents or if the `path` points\n /// at a non-directory file\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn read_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<ReadDir> {\n     fs_imp::readdir(path.as_path()).map(ReadDir)\n }\n@@ -649,11 +679,16 @@ pub fn read_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<ReadDir> {\n ///\n /// The iterator will yield instances of `io::Result<DirEntry>`. New errors may\n /// be encountered after an iterator is initially constructed.\n+#[unstable(feature = \"fs_walk\",\n+           reason = \"the precise semantics and defaults for a recursive walk \\\n+                     may change and this may end up accounting for files such \\\n+                     as symlinks differently\")]\n pub fn walk_dir<P: AsPath + ?Sized>(path: &P) -> io::Result<WalkDir> {\n     let start = try!(read_dir(path));\n     Ok(WalkDir { cur: Some(start), stack: Vec::new() })\n }\n \n+#[unstable(feature = \"fs_walk\")]\n impl Iterator for WalkDir {\n     type Item = io::Result<DirEntry>;\n \n@@ -683,6 +718,9 @@ impl Iterator for WalkDir {\n }\n \n /// Utility methods for paths.\n+#[unstable(feature = \"path_ext\",\n+           reason = \"the precise set of methods exposed on this trait may \\\n+                     change and some methods may be removed\")]\n pub trait PathExt {\n     /// Get information on the file, directory, etc at this path.\n     ///\n@@ -727,6 +765,10 @@ impl PathExt for Path {\n /// The file at the path specified will have its last access time set to\n /// `atime` and its modification time set to `mtime`. The times specified should\n /// be in milliseconds.\n+#[unstable(feature = \"fs_time\",\n+           reason = \"the argument type of u64 is not quite appropriate for \\\n+                     this function and may change if the standard library \\\n+                     gains a type to represent a moment in time\")]\n pub fn set_file_times<P: AsPath + ?Sized>(path: &P, accessed: u64,\n                                           modified: u64) -> io::Result<()> {\n     fs_imp::utimes(path.as_path(), accessed, modified)\n@@ -752,6 +794,10 @@ pub fn set_file_times<P: AsPath + ?Sized>(path: &P, accessed: u64,\n /// This function will return an error if the provided `path` doesn't exist, if\n /// the process lacks permissions to change the attributes of the file, or if\n /// some other I/O error is encountered.\n+#[unstable(feature = \"fs\",\n+           reason = \"a more granual ability to set specific permissions may \\\n+                     be exposed on the Permissions structure itself and this \\\n+                     method may not always exist\")]\n pub fn set_permissions<P: AsPath + ?Sized>(path: &P, perm: Permissions)\n                                            -> io::Result<()> {\n     fs_imp::set_perm(path.as_path(), perm.0)"}, {"sha": "c1da77a6668f51b513ab79d7428a87aa1bcebd3d", "filename": "src/libstd/fs/tempdir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibstd%2Ffs%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibstd%2Ffs%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Ftempdir.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -9,6 +9,9 @@\n // except according to those terms.\n \n #![unstable(feature = \"tempdir\", reason = \"needs an RFC before stabilization\")]\n+#![deprecated(since = \"1.0.0\",\n+              reason = \"use the `tempdir` crate from crates.io instead\")]\n+#![allow(deprecated)]\n \n use prelude::v1::*;\n "}, {"sha": "c0977508112c5db14eea7d7ea03203ae9cd03d0e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -37,8 +37,8 @@\n #![feature(std_misc)]\n #![feature(unicode)]\n #![feature(path)]\n-#![feature(fs)]\n #![feature(io)]\n+#![feature(path_ext)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "317bacf0f5222771f637fcaffaaf6753b505ea53", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -52,7 +52,6 @@\n \n #![feature(box_syntax)]\n #![feature(collections)]\n-#![feature(fs)]\n #![feature(int_uint)]\n #![feature(io)]\n #![feature(old_io)]\n@@ -61,6 +60,7 @@\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n+#![feature(path_ext)]\n #![cfg_attr(windows, feature(libc))]\n \n #[macro_use] extern crate log;"}, {"sha": "06af12e807546c371e440e19967ee6f7472155db", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -39,7 +39,6 @@\n #![feature(int_uint)]\n #![feature(old_io)]\n #![feature(path)]\n-#![feature(fs)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(std_misc)]"}, {"sha": "731773917e09118452152504f0df79da09bd10e4", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -11,10 +11,11 @@\n //! Implementation of the `build` subcommand, used to compile a book.\n \n use std::env;\n-use std::fs::{self, File, TempDir};\n+use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io::{self, BufWriter};\n use std::path::{Path, PathBuf};\n+use rustc_back::tempdir::TempDir;\n \n use subcommand::Subcommand;\n use term::Term;"}, {"sha": "8df622b0b5d0c2e58c5b4a984dc0316293d44bf6", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe41c935603be8192c7481fcd846e629d76337b1/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe41c935603be8192c7481fcd846e629d76337b1/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=fe41c935603be8192c7481fcd846e629d76337b1", "patch": "@@ -12,14 +12,14 @@\n \n #![feature(core)]\n #![feature(exit_status)]\n-#![feature(fs)]\n #![feature(io)]\n #![feature(old_io)]\n #![feature(path)]\n #![feature(rustdoc)]\n-#![feature(tempdir)]\n+#![feature(rustc_private)]\n \n extern crate rustdoc;\n+extern crate rustc_back;\n \n use std::env;\n use std::error::Error;"}]}