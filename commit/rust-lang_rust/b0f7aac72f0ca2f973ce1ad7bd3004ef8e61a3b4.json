{"sha": "b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwZjdhYWM3MmYwY2EyZjk3M2NlMWFkN2JkMzAwNGVmOGU2MWEzYjQ=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-07-23T13:36:43Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-07-23T13:36:43Z"}, "message": "Respect `#[doc(hidden)]` in dot-completion", "tree": {"sha": "364eccb9b8538ad532536dbc4127fe2c75500876", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/364eccb9b8538ad532536dbc4127fe2c75500876"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4", "html_url": "https://github.com/rust-lang/rust/commit/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dd1814100b3b2bdc5cc1d1994b16caa613784b5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd1814100b3b2bdc5cc1d1994b16caa613784b5", "html_url": "https://github.com/rust-lang/rust/commit/1dd1814100b3b2bdc5cc1d1994b16caa613784b5"}], "stats": {"total": 149, "additions": 136, "deletions": 13}, "files": [{"sha": "9332cfc06749155978ff06a44a1f3557fc3752c9", "filename": "crates/hir/src/attrs.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fhir%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fhir%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fattrs.rs?ref=b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4", "patch": "@@ -11,8 +11,8 @@ use hir_ty::db::HirDatabase;\n use syntax::ast;\n \n use crate::{\n-    Adt, Const, ConstParam, Enum, Field, Function, GenericParam, Impl, LifetimeParam, MacroDef,\n-    Module, ModuleDef, Static, Struct, Trait, TypeAlias, TypeParam, Union, Variant,\n+    Adt, AssocItem, Const, ConstParam, Enum, Field, Function, GenericParam, Impl, LifetimeParam,\n+    MacroDef, Module, ModuleDef, Static, Struct, Trait, TypeAlias, TypeParam, Union, Variant,\n };\n \n pub trait HasAttrs {\n@@ -86,6 +86,37 @@ macro_rules! impl_has_attrs_enum {\n impl_has_attrs_enum![Struct, Union, Enum for Adt];\n impl_has_attrs_enum![TypeParam, ConstParam, LifetimeParam for GenericParam];\n \n+impl HasAttrs for AssocItem {\n+    fn attrs(self, db: &dyn HirDatabase) -> AttrsWithOwner {\n+        match self {\n+            AssocItem::Function(it) => it.attrs(db),\n+            AssocItem::Const(it) => it.attrs(db),\n+            AssocItem::TypeAlias(it) => it.attrs(db),\n+        }\n+    }\n+\n+    fn docs(self, db: &dyn HirDatabase) -> Option<Documentation> {\n+        match self {\n+            AssocItem::Function(it) => it.docs(db),\n+            AssocItem::Const(it) => it.docs(db),\n+            AssocItem::TypeAlias(it) => it.docs(db),\n+        }\n+    }\n+\n+    fn resolve_doc_path(\n+        self,\n+        db: &dyn HirDatabase,\n+        link: &str,\n+        ns: Option<Namespace>,\n+    ) -> Option<ModuleDef> {\n+        match self {\n+            AssocItem::Function(it) => it.resolve_doc_path(db, link, ns),\n+            AssocItem::Const(it) => it.resolve_doc_path(db, link, ns),\n+            AssocItem::TypeAlias(it) => it.resolve_doc_path(db, link, ns),\n+        }\n+    }\n+}\n+\n fn resolve_doc_path(\n     db: &dyn HirDatabase,\n     def: AttrDefId,"}, {"sha": "9673885e739491f72aaa8aefc8e5b1a6cfe85ade", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4", "patch": "@@ -2744,3 +2744,32 @@ pub trait HasVisibility {\n         vis.is_visible_from(db.upcast(), module.id)\n     }\n }\n+\n+/// Trait for obtaining the defining crate of an item.\n+pub trait HasCrate {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate;\n+}\n+\n+impl<T: hir_def::HasModule> HasCrate for T {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db.upcast()).krate().into()\n+    }\n+}\n+\n+impl HasCrate for AssocItem {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db).krate()\n+    }\n+}\n+\n+impl HasCrate for Field {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate {\n+        self.parent_def(db).module(db).krate()\n+    }\n+}\n+\n+impl HasCrate for Function {\n+    fn krate(&self, db: &dyn HirDatabase) -> Crate {\n+        self.module(db).krate()\n+    }\n+}"}, {"sha": "4471cdd8bc1803ce572ba02077b903924e22546c", "filename": "crates/hir_def/src/attr.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fhir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fhir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fattr.rs?ref=b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4", "patch": "@@ -12,7 +12,7 @@ use either::Either;\n use hir_expand::{hygiene::Hygiene, name::AsName, AstId, InFile};\n use itertools::Itertools;\n use la_arena::ArenaMap;\n-use mbe::ast_to_token_tree;\n+use mbe::{ast_to_token_tree, DelimiterKind};\n use smallvec::{smallvec, SmallVec};\n use syntax::{\n     ast::{self, AstNode, AttrsOwner},\n@@ -290,6 +290,13 @@ impl Attrs {\n             Some(Documentation(buf))\n         }\n     }\n+\n+    pub fn has_doc_hidden(&self) -> bool {\n+        self.by_key(\"doc\").tt_values().find(|tt| {\n+            tt.delimiter_kind() == Some(DelimiterKind::Parenthesis) &&\n+                matches!(&*tt.token_trees, [tt::TokenTree::Leaf(tt::Leaf::Ident(ident))] if ident.text == \"hidden\")\n+        }).is_some()\n+    }\n }\n \n impl AttrsWithOwner {"}, {"sha": "3494dfd306509136948b49e20d80925d56b6a6bb", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4", "patch": "@@ -1,7 +1,7 @@\n //! Completes references after dot (fields and method calls).\n \n use either::Either;\n-use hir::{HasVisibility, ScopeDef};\n+use hir::ScopeDef;\n use rustc_hash::FxHashSet;\n \n use crate::{context::CompletionContext, patterns::ImmediateLocation, Completions};\n@@ -63,9 +63,7 @@ fn complete_fields(\n ) {\n     for receiver in receiver.autoderef(ctx.db) {\n         for (field, ty) in receiver.fields(ctx.db) {\n-            if ctx.scope.module().map_or(false, |m| !field.is_visible_from(ctx.db, m)) {\n-                // Skip private field. FIXME: If the definition location of the\n-                // field is editable, we should show the completion\n+            if !ctx.is_visible(&field) {\n                 continue;\n             }\n             f(Either::Left(field), ty);\n@@ -87,7 +85,7 @@ fn complete_methods(\n         let traits_in_scope = ctx.scope.traits_in_scope();\n         receiver.iterate_method_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, func| {\n             if func.self_param(ctx.db).is_some()\n-                && ctx.scope.module().map_or(true, |m| func.is_visible_from(ctx.db, m))\n+                && ctx.is_visible(&func)\n                 && seen_methods.insert(func.name(ctx.db))\n             {\n                 f(func);\n@@ -210,6 +208,33 @@ fn foo(a: A) { a.$0 }\n         );\n     }\n \n+    #[test]\n+    fn test_doc_hidden_filtering() {\n+        check(\n+            r#\"\n+//- /lib.rs crate:lib deps:dep\n+fn foo(a: dep::A) { a.$0 }\n+//- /dep.rs crate:dep\n+pub struct A {\n+    #[doc(hidden)]\n+    pub hidden_field: u32,\n+    pub pub_field: u32,\n+}\n+\n+impl A {\n+    pub fn pub_method(&self) {}\n+\n+    #[doc(hidden)]\n+    pub fn hidden_method(&self) {}\n+}\n+            \"#,\n+            expect![[r#\"\n+                fd pub_field    u32\n+                me pub_method() fn(&self)\n+            \"#]]\n+        )\n+    }\n+\n     #[test]\n     fn test_union_field_completion() {\n         check("}, {"sha": "608398584dff4e5bc3f365b80150abbc2a5cc326", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4", "patch": "@@ -2,7 +2,6 @@\n \n use std::iter;\n \n-use hir::HasVisibility;\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n \n@@ -120,6 +119,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     _ => true,\n                 };\n \n+                // FIXME: respect #[doc(hidden)] (see `CompletionContext::is_visible`)\n                 if add_resolution {\n                     acc.add_resolution(ctx, name, &def);\n                 }\n@@ -163,7 +163,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             if let Some(krate) = krate {\n                 let traits_in_scope = ctx.scope.traits_in_scope();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n-                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                    if !ctx.is_visible(&item) {\n                         return None;\n                     }\n                     add_assoc_item(acc, ctx, item);\n@@ -172,7 +172,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n                 // Iterate assoc types separately\n                 ty.iterate_assoc_items(ctx.db, krate, |item| {\n-                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                    if !ctx.is_visible(&item) {\n                         return None;\n                     }\n                     if let hir::AssocItem::TypeAlias(ty) = item {\n@@ -185,7 +185,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n         hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n             // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n             for item in t.items(ctx.db) {\n-                if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                if !ctx.is_visible(&item) {\n                     continue;\n                 }\n                 add_assoc_item(acc, ctx, item);\n@@ -206,7 +206,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 let traits_in_scope = ctx.scope.traits_in_scope();\n                 let mut seen = FxHashSet::default();\n                 ty.iterate_path_candidates(ctx.db, krate, &traits_in_scope, None, |_ty, item| {\n-                    if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n+                    if !ctx.is_visible(&item) {\n                         return None;\n                     }\n "}, {"sha": "a056b5405a52c6e5e64de23f668308813e74b700", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=b0f7aac72f0ca2f973ce1ad7bd3004ef8e61a3b4", "patch": "@@ -361,6 +361,37 @@ impl<'a> CompletionContext<'a> {\n         self.path_context.as_ref().and_then(|it| it.qualifier.as_ref())\n     }\n \n+    /// Checks if an item is visible and not `doc(hidden)` at the completion site.\n+    pub(crate) fn is_visible<I>(&self, item: &I) -> bool\n+    where\n+        I: hir::HasVisibility + hir::HasAttrs + hir::HasCrate + Copy,\n+    {\n+        self.is_visible_impl(&item.visibility(self.db), &item.attrs(self.db), item.krate(self.db))\n+    }\n+\n+    fn is_visible_impl(\n+        &self,\n+        vis: &hir::Visibility,\n+        attrs: &hir::Attrs,\n+        defining_crate: hir::Crate,\n+    ) -> bool {\n+        let module = match self.scope.module() {\n+            Some(it) => it,\n+            None => return false,\n+        };\n+        if !vis.is_visible_from(self.db, module.into()) {\n+            // FIXME: if the definition location is editable, also show private items\n+            return false;\n+        }\n+\n+        if module.krate() != defining_crate && attrs.has_doc_hidden() {\n+            // `doc(hidden)` items are only completed within the defining crate.\n+            return false;\n+        }\n+\n+        true\n+    }\n+\n     fn fill_impl_def(&mut self) {\n         self.impl_def = self\n             .sema"}]}