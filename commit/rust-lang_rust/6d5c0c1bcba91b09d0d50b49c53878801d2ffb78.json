{"sha": "6d5c0c1bcba91b09d0d50b49c53878801d2ffb78", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNWMwYzFiY2JhOTFiMDlkMGQ1MGI0OWM1Mzg3ODgwMWQyZmZiNzg=", "commit": {"author": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-02-24T00:00:00Z"}, "committer": {"name": "Tomasz Mi\u0105sko", "email": "tomasz.miasko@gmail.com", "date": "2021-02-24T00:00:00Z"}, "message": "Consider inexpensive inlining criteria first\n\nRefactor inlining decisions so that inexpensive criteria are considered first:\n\n1. Based on code generation attributes.\n2. Based on MIR availability (examines call graph).\n3. Based on MIR body.", "tree": {"sha": "d60904113121dcd40f96c6a917edc3bcab077790", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d60904113121dcd40f96c6a917edc3bcab077790"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d5c0c1bcba91b09d0d50b49c53878801d2ffb78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d5c0c1bcba91b09d0d50b49c53878801d2ffb78", "html_url": "https://github.com/rust-lang/rust/commit/6d5c0c1bcba91b09d0d50b49c53878801d2ffb78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d5c0c1bcba91b09d0d50b49c53878801d2ffb78/comments", "author": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tmiasko", "id": 51362316, "node_id": "MDQ6VXNlcjUxMzYyMzE2", "avatar_url": "https://avatars.githubusercontent.com/u/51362316?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmiasko", "html_url": "https://github.com/tmiasko", "followers_url": "https://api.github.com/users/tmiasko/followers", "following_url": "https://api.github.com/users/tmiasko/following{/other_user}", "gists_url": "https://api.github.com/users/tmiasko/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmiasko/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmiasko/subscriptions", "organizations_url": "https://api.github.com/users/tmiasko/orgs", "repos_url": "https://api.github.com/users/tmiasko/repos", "events_url": "https://api.github.com/users/tmiasko/events{/privacy}", "received_events_url": "https://api.github.com/users/tmiasko/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b56603e35b39c9f6cc76782330e5e415f9e43d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b56603e35b39c9f6cc76782330e5e415f9e43d5", "html_url": "https://github.com/rust-lang/rust/commit/6b56603e35b39c9f6cc76782330e5e415f9e43d5"}], "stats": {"total": 270, "additions": 146, "deletions": 124}, "files": [{"sha": "16279040a1c3f48e6cd9f8dada35223fffd066a1", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 146, "deletions": 124, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/6d5c0c1bcba91b09d0d50b49c53878801d2ffb78/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5c0c1bcba91b09d0d50b49c53878801d2ffb78/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=6d5c0c1bcba91b09d0d50b49c53878801d2ffb78", "patch": "@@ -1,6 +1,6 @@\n //! Inlining pass for MIR functions\n \n-use rustc_attr as attr;\n+use rustc_attr::InlineAttr;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n@@ -106,72 +106,90 @@ struct Inliner<'tcx> {\n impl Inliner<'tcx> {\n     fn process_blocks(&mut self, caller_body: &mut Body<'tcx>, blocks: Range<BasicBlock>) {\n         for bb in blocks {\n-            let callsite = match self.get_valid_function_call(bb, &caller_body[bb], caller_body) {\n+            let bb_data = &caller_body[bb];\n+            if bb_data.is_cleanup {\n+                continue;\n+            }\n+\n+            let callsite = match self.resolve_callsite(caller_body, bb, bb_data) {\n                 None => continue,\n                 Some(it) => it,\n             };\n+\n             let span = trace_span!(\"process_blocks\", %callsite.callee, ?bb);\n             let _guard = span.enter();\n \n-            trace!(\n-                \"checking for self recursion ({:?} vs body_source: {:?})\",\n-                callsite.callee.def_id(),\n-                caller_body.source.def_id()\n-            );\n-            if callsite.callee.def_id() == caller_body.source.def_id() {\n-                debug!(\"Not inlining a function into itself\");\n-                continue;\n-            }\n-\n-            if !self.is_mir_available(callsite.callee, caller_body) {\n-                debug!(\"MIR unavailable {}\", callsite.callee);\n-                continue;\n+            match self.try_inlining(caller_body, &callsite) {\n+                Err(reason) => {\n+                    debug!(\"not-inlined {} [{}]\", callsite.callee, reason);\n+                    continue;\n+                }\n+                Ok(new_blocks) => {\n+                    debug!(\"inlined {}\", callsite.callee);\n+                    self.changed = true;\n+                    self.history.push(callsite.callee);\n+                    self.process_blocks(caller_body, new_blocks);\n+                    self.history.pop();\n+                }\n             }\n+        }\n+    }\n \n-            let span = trace_span!(\"instance_mir\", %callsite.callee);\n-            let instance_mir_guard = span.enter();\n-            let callee_body = self.tcx.instance_mir(callsite.callee.def);\n-            drop(instance_mir_guard);\n-            if !self.should_inline(callsite, callee_body) {\n-                continue;\n-            }\n+    /// Attempts to inline a callsite into the caller body. When successful returns basic blocks\n+    /// containing the inlined body. Otherwise returns an error describing why inlining didn't take\n+    /// place.\n+    fn try_inlining(\n+        &self,\n+        caller_body: &mut Body<'tcx>,\n+        callsite: &CallSite<'tcx>,\n+    ) -> Result<std::ops::Range<BasicBlock>, &'static str> {\n+        let callee_attrs = self.tcx.codegen_fn_attrs(callsite.callee.def_id());\n+        self.check_codegen_attributes(callsite, callee_attrs)?;\n+        self.check_mir_is_available(caller_body, &callsite.callee)?;\n+        let callee_body = self.tcx.instance_mir(callsite.callee.def);\n+        self.check_mir_body(callsite, callee_body, callee_attrs)?;\n+\n+        if !self.tcx.consider_optimizing(|| {\n+            format!(\"Inline {:?} into {}\", callee_body.span, callsite.callee)\n+        }) {\n+            return Err(\"optimization fuel exhausted\");\n+        }\n \n-            if !self.tcx.consider_optimizing(|| {\n-                format!(\"Inline {:?} into {}\", callee_body.span, callsite.callee)\n-            }) {\n-                return;\n-            }\n+        let callee_body = callsite.callee.subst_mir_and_normalize_erasing_regions(\n+            self.tcx,\n+            self.param_env,\n+            callee_body.clone(),\n+        );\n \n-            let callee_body = callsite.callee.subst_mir_and_normalize_erasing_regions(\n-                self.tcx,\n-                self.param_env,\n-                callee_body.clone(),\n-            );\n+        let old_blocks = caller_body.basic_blocks().next_index();\n+        self.inline_call(caller_body, &callsite, callee_body);\n+        let new_blocks = old_blocks..caller_body.basic_blocks().next_index();\n \n-            let old_blocks = caller_body.basic_blocks().next_index();\n-            self.inline_call(callsite, caller_body, callee_body);\n-            let new_blocks = old_blocks..caller_body.basic_blocks().next_index();\n-            self.changed = true;\n+        Ok(new_blocks)\n+    }\n \n-            self.history.push(callsite.callee);\n-            self.process_blocks(caller_body, new_blocks);\n-            self.history.pop();\n+    fn check_mir_is_available(\n+        &self,\n+        caller_body: &Body<'tcx>,\n+        callee: &Instance<'tcx>,\n+    ) -> Result<(), &'static str> {\n+        if callee.def_id() == caller_body.source.def_id() {\n+            return Err(\"self-recursion\");\n         }\n-    }\n \n-    #[instrument(level = \"debug\", skip(self, caller_body))]\n-    fn is_mir_available(&self, callee: Instance<'tcx>, caller_body: &Body<'tcx>) -> bool {\n         match callee.def {\n             InstanceDef::Item(_) => {\n                 // If there is no MIR available (either because it was not in metadata or\n                 // because it has no MIR because it's an extern function), then the inliner\n                 // won't cause cycles on this.\n                 if !self.tcx.is_mir_available(callee.def_id()) {\n-                    return false;\n+                    return Err(\"item MIR unavailable\");\n                 }\n             }\n             // These have no own callable MIR.\n-            InstanceDef::Intrinsic(_) | InstanceDef::Virtual(..) => return false,\n+            InstanceDef::Intrinsic(_) | InstanceDef::Virtual(..) => {\n+                return Err(\"instance without MIR (intrinsic / virtual)\");\n+            }\n             // This cannot result in an immediate cycle since the callee MIR is a shim, which does\n             // not get any optimizations run on it. Any subsequent inlining may cause cycles, but we\n             // do not need to catch this here, we can wait until the inliner decides to continue\n@@ -181,13 +199,13 @@ impl Inliner<'tcx> {\n             | InstanceDef::FnPtrShim(..)\n             | InstanceDef::ClosureOnceShim { .. }\n             | InstanceDef::DropGlue(..)\n-            | InstanceDef::CloneShim(..) => return true,\n+            | InstanceDef::CloneShim(..) => return Ok(()),\n         }\n \n         if self.tcx.is_constructor(callee.def_id()) {\n             trace!(\"constructors always have MIR\");\n             // Constructor functions cannot cause a query cycle.\n-            return true;\n+            return Ok(());\n         }\n \n         if let Some(callee_def_id) = callee.def_id().as_local() {\n@@ -196,39 +214,44 @@ impl Inliner<'tcx> {\n             // since their `optimized_mir` is used for layout computation, which can\n             // create a cycle, even when no attempt is made to inline the function\n             // in the other direction.\n-            caller_body.generator_kind.is_none()\n-                && (\n-                    // Avoid a cycle here by only using `instance_mir` only if we have\n-                    // a lower `HirId` than the callee. This ensures that the callee will\n-                    // not inline us. This trick only works without incremental compilation.\n-                    // So don't do it if that is enabled.\n-                    !self.tcx.dep_graph.is_fully_enabled()\n-                && self.hir_id < callee_hir_id\n-                // If we know for sure that the function we're calling will itself try to\n-                // call us, then we avoid inlining that function.\n-                || !self.tcx.mir_callgraph_reachable((callee, caller_body.source.def_id().expect_local()))\n-                )\n+            if caller_body.generator_kind.is_some() {\n+                return Err(\"local generator (query cycle avoidance)\");\n+            }\n+\n+            // Avoid a cycle here by only using `instance_mir` only if we have\n+            // a lower `HirId` than the callee. This ensures that the callee will\n+            // not inline us. This trick only works without incremental compilation.\n+            // So don't do it if that is enabled.\n+            if !self.tcx.dep_graph.is_fully_enabled() && self.hir_id < callee_hir_id {\n+                return Ok(());\n+            }\n+\n+            // If we know for sure that the function we're calling will itself try to\n+            // call us, then we avoid inlining that function.\n+            if self\n+                .tcx\n+                .mir_callgraph_reachable((*callee, caller_body.source.def_id().expect_local()))\n+            {\n+                return Err(\"caller might be reachable from callee (query cycle avoidance)\");\n+            }\n+\n+            Ok(())\n         } else {\n             // This cannot result in an immediate cycle since the callee MIR is from another crate\n             // and is already optimized. Any subsequent inlining may cause cycles, but we do\n             // not need to catch this here, we can wait until the inliner decides to continue\n             // inlining a second time.\n             trace!(\"functions from other crates always have MIR\");\n-            true\n+            Ok(())\n         }\n     }\n \n-    fn get_valid_function_call(\n+    fn resolve_callsite(\n         &self,\n+        caller_body: &Body<'tcx>,\n         bb: BasicBlock,\n         bb_data: &BasicBlockData<'tcx>,\n-        caller_body: &Body<'tcx>,\n     ) -> Option<CallSite<'tcx>> {\n-        // Don't inline calls that are in cleanup blocks.\n-        if bb_data.is_cleanup {\n-            return None;\n-        }\n-\n         // Only consider direct calls to functions\n         let terminator = bb_data.terminator();\n         if let TerminatorKind::Call { ref func, ref destination, .. } = terminator.kind {\n@@ -258,73 +281,73 @@ impl Inliner<'tcx> {\n         None\n     }\n \n-    #[instrument(level = \"debug\", skip(self, callee_body))]\n-    fn should_inline(&self, callsite: CallSite<'tcx>, callee_body: &Body<'tcx>) -> bool {\n-        let tcx = self.tcx;\n+    /// Returns an error if inlining is not possible based on codegen attributes alone. A success\n+    /// indicates that inlining decision should be based on other criteria.\n+    fn check_codegen_attributes(\n+        &self,\n+        callsite: &CallSite<'tcx>,\n+        callee_attrs: &CodegenFnAttrs,\n+    ) -> Result<(), &'satic str> {\n+        if let InlineAttr::Never = callee_attrs.inline {\n+            return Err(\"never inline hint\");\n+        }\n+\n+        // Only inline local functions if they would be eligible for cross-crate\n+        // inlining. This is to ensure that the final crate doesn't have MIR that\n+        // reference unexported symbols\n+        if callsite.callee.def_id().is_local() {\n+            let is_generic = callsite.callee.substs.non_erasable_generics().next().is_some();\n+            if !is_generic && !callee_attrs.requests_inline() {\n+                return Err(\"not exported\");\n+            }\n+        }\n \n         if callsite.fn_sig.c_variadic() {\n-            debug!(\"callee is variadic - not inlining\");\n-            return false;\n+            return Err(\"C variadic\");\n         }\n \n-        let codegen_fn_attrs = tcx.codegen_fn_attrs(callsite.callee.def_id());\n+        if callee_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n+            return Err(\"naked\");\n+        }\n \n-        let self_features = &self.codegen_fn_attrs.target_features;\n-        let callee_features = &codegen_fn_attrs.target_features;\n-        if callee_features.iter().any(|feature| !self_features.contains(feature)) {\n-            debug!(\"`callee has extra target features - not inlining\");\n-            return false;\n+        if callee_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n+            return Err(\"cold\");\n         }\n \n-        if self.codegen_fn_attrs.no_sanitize != codegen_fn_attrs.no_sanitize {\n-            debug!(\"`callee has incompatible no_sanitize attribute - not inlining\");\n-            return false;\n+        if callee_attrs.no_sanitize != self.codegen_fn_attrs.no_sanitize {\n+            return Err(\"incompatible sanitizer set\");\n         }\n \n-        if self.codegen_fn_attrs.instruction_set != codegen_fn_attrs.instruction_set {\n-            debug!(\"`callee has incompatible instruction set - not inlining\");\n-            return false;\n+        if callee_attrs.instruction_set != self.codegen_fn_attrs.instruction_set {\n+            return Err(\"incompatible instruction set\");\n         }\n \n-        let hinted = match codegen_fn_attrs.inline {\n-            // Just treat inline(always) as a hint for now,\n-            // there are cases that prevent inlining that we\n-            // need to check for first.\n-            attr::InlineAttr::Always => true,\n-            attr::InlineAttr::Never => {\n-                debug!(\"`#[inline(never)]` present - not inlining\");\n-                return false;\n-            }\n-            attr::InlineAttr::Hint => true,\n-            attr::InlineAttr::None => false,\n-        };\n-\n-        // Only inline local functions if they would be eligible for cross-crate\n-        // inlining. This is to ensure that the final crate doesn't have MIR that\n-        // reference unexported symbols\n-        if callsite.callee.def_id().is_local() {\n-            if callsite.callee.substs.non_erasable_generics().count() == 0 && !hinted {\n-                debug!(\"    callee is an exported function - not inlining\");\n-                return false;\n+        for feature in &callee_attrs.target_features {\n+            if !self.codegen_fn_attrs.target_features.contains(feature) {\n+                return Err(\"incompatible target feature\");\n             }\n         }\n \n-        let mut threshold = if hinted {\n+        Ok(())\n+    }\n+\n+    /// Returns inlining decision that is based on the examination of callee MIR body.\n+    /// Assumes that codegen attributes have been checked for compatibility already.\n+    #[instrument(level = \"debug\", skip(self, callee_body))]\n+    fn check_mir_body(\n+        &self,\n+        callsite: &CallSite<'tcx>,\n+        callee_body: &Body<'tcx>,\n+        callee_attrs: &CodegenFnAttrs,\n+    ) -> Result<(), &'static str> {\n+        let tcx = self.tcx;\n+\n+        let mut threshold = if callee_attrs.requests_inline() {\n             self.tcx.sess.opts.debugging_opts.inline_mir_hint_threshold\n         } else {\n             self.tcx.sess.opts.debugging_opts.inline_mir_threshold\n         };\n \n-        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::NAKED) {\n-            debug!(\"#[naked] present - not inlining\");\n-            return false;\n-        }\n-\n-        if codegen_fn_attrs.flags.contains(CodegenFnAttrFlags::COLD) {\n-            debug!(\"#[cold] present - not inlining\");\n-            return false;\n-        }\n-\n         // Give a bonus functions with a small number of blocks,\n         // We normally have two or three blocks for even\n         // very small functions.\n@@ -393,11 +416,10 @@ impl Inliner<'tcx> {\n                         if let Ok(Some(instance)) =\n                             Instance::resolve(self.tcx, self.param_env, def_id, substs)\n                         {\n-                            if callsite.callee.def_id() == instance.def_id()\n-                                || self.history.contains(&instance)\n-                            {\n-                                debug!(\"`callee is recursive - not inlining\");\n-                                return false;\n+                            if callsite.callee.def_id() == instance.def_id() {\n+                                return Err(\"self-recursion\");\n+                            } else if self.history.contains(&instance) {\n+                                return Err(\"already inlined\");\n                             }\n                         }\n                         // Don't give intrinsics the extra penalty for calls\n@@ -450,24 +472,24 @@ impl Inliner<'tcx> {\n             }\n         }\n \n-        if let attr::InlineAttr::Always = codegen_fn_attrs.inline {\n+        if let InlineAttr::Always = callee_attrs.inline {\n             debug!(\"INLINING {:?} because inline(always) [cost={}]\", callsite, cost);\n-            true\n+            Ok(())\n         } else {\n             if cost <= threshold {\n                 debug!(\"INLINING {:?} [cost={} <= threshold={}]\", callsite, cost, threshold);\n-                true\n+                Ok(())\n             } else {\n                 debug!(\"NOT inlining {:?} [cost={} > threshold={}]\", callsite, cost, threshold);\n-                false\n+                Err(\"cost above threshold\")\n             }\n         }\n     }\n \n     fn inline_call(\n         &self,\n-        callsite: CallSite<'tcx>,\n         caller_body: &mut Body<'tcx>,\n+        callsite: &CallSite<'tcx>,\n         mut callee_body: Body<'tcx>,\n     ) {\n         let terminator = caller_body[callsite.block].terminator.take().unwrap();"}]}