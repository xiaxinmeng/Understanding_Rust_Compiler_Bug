{"sha": "e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2ZmMwYmRmZmIyMTNmNmU5NGM1YmI0MDgxZTZkMTc1Y2NiZDUxOGY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-19T21:12:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-05-19T23:30:12Z"}, "message": "Moderate cleanup of add_function", "tree": {"sha": "13e97077b33a25d1923d946dfbcf636fea838f9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13e97077b33a25d1923d946dfbcf636fea838f9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "html_url": "https://github.com/rust-lang/rust/commit/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8eb3272ad6f774bccb967ee640b72a9a17273e7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8eb3272ad6f774bccb967ee640b72a9a17273e7b", "html_url": "https://github.com/rust-lang/rust/commit/8eb3272ad6f774bccb967ee640b72a9a17273e7b"}], "stats": {"total": 193, "additions": 128, "deletions": 65}, "files": [{"sha": "a0709630d27ef3662d8d1dbb705a6a83ce0b58d6", "filename": "crates/ra_assists/src/handlers/add_function.rs", "status": "modified", "additions": 47, "deletions": 33, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_function.rs?ref=e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "patch": "@@ -4,13 +4,13 @@ use ra_syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        ArgListOwner, AstNode, ModuleItemOwner,\n+        make, ArgListOwner, AstNode, ModuleItemOwner,\n     },\n     SyntaxKind, SyntaxNode, TextSize,\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-use crate::{utils::render_snippet, AssistContext, AssistId, Assists};\n+use crate::{assist_config::SnippetCap, utils::render_snippet, AssistContext, AssistId, Assists};\n \n // Assist: add_function\n //\n@@ -61,27 +61,33 @@ pub(crate) fn add_function(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     acc.add(AssistId(\"add_function\"), \"Add function\", target, |builder| {\n         let function_template = function_builder.render();\n         builder.set_file(function_template.file);\n+        let new_fn = function_template.to_string(ctx.config.snippet_cap);\n         match ctx.config.snippet_cap {\n-            Some(cap) => {\n-                let snippet = render_snippet(\n-                    function_template.fn_def.syntax(),\n-                    function_template.placeholder_expr.syntax(),\n-                );\n-                builder.insert_snippet(cap, function_template.insert_offset, snippet)\n-            }\n-            None => builder\n-                .insert(function_template.insert_offset, function_template.fn_def.to_string()),\n+            Some(cap) => builder.insert_snippet(cap, function_template.insert_offset, new_fn),\n+            None => builder.insert(function_template.insert_offset, new_fn),\n         }\n     })\n }\n \n struct FunctionTemplate {\n     insert_offset: TextSize,\n-    fn_def: ast::SourceFile,\n     placeholder_expr: ast::MacroCall,\n+    leading_ws: String,\n+    fn_def: ast::FnDef,\n+    trailing_ws: String,\n     file: FileId,\n }\n \n+impl FunctionTemplate {\n+    fn to_string(&self, cap: Option<SnippetCap>) -> String {\n+        let f = match cap {\n+            Some(cap) => render_snippet(cap, self.fn_def.syntax(), self.placeholder_expr.syntax()),\n+            None => self.fn_def.to_string(),\n+        };\n+        format!(\"{}{}{}\", self.leading_ws, f, self.trailing_ws)\n+    }\n+}\n+\n struct FunctionBuilder {\n     target: GeneratedFunctionTarget,\n     fn_name: ast::Name,\n@@ -119,33 +125,41 @@ impl FunctionBuilder {\n     }\n \n     fn render(self) -> FunctionTemplate {\n-        let placeholder_expr = ast::make::expr_todo();\n-        let fn_body = ast::make::block_expr(vec![], Some(placeholder_expr));\n-        let mut fn_def = ast::make::fn_def(self.fn_name, self.type_params, self.params, fn_body);\n-        if self.needs_pub {\n-            fn_def = ast::make::add_pub_crate_modifier(fn_def);\n-        }\n-\n-        let (fn_def, insert_offset) = match self.target {\n+        let placeholder_expr = make::expr_todo();\n+        let fn_body = make::block_expr(vec![], Some(placeholder_expr));\n+        let visibility = if self.needs_pub { Some(make::visibility_pub_crate()) } else { None };\n+        let mut fn_def =\n+            make::fn_def(visibility, self.fn_name, self.type_params, self.params, fn_body);\n+        let leading_ws;\n+        let trailing_ws;\n+\n+        let insert_offset = match self.target {\n             GeneratedFunctionTarget::BehindItem(it) => {\n-                let with_leading_blank_line = ast::make::add_leading_newlines(2, fn_def);\n-                let indented = with_leading_blank_line.indent(IndentLevel::from_node(&it));\n-                (indented, it.text_range().end())\n+                let indent = IndentLevel::from_node(&it);\n+                leading_ws = format!(\"\\n\\n{}\", indent);\n+                fn_def = fn_def.indent(indent);\n+                trailing_ws = String::new();\n+                it.text_range().end()\n             }\n             GeneratedFunctionTarget::InEmptyItemList(it) => {\n-                let indent_once = IndentLevel(1);\n                 let indent = IndentLevel::from_node(it.syntax());\n-                let fn_def = ast::make::add_leading_newlines(1, fn_def);\n-                let fn_def = fn_def.indent(indent_once);\n-                let fn_def = ast::make::add_trailing_newlines(1, fn_def);\n-                let fn_def = fn_def.indent(indent);\n-                (fn_def, it.syntax().text_range().start() + TextSize::of('{'))\n+                leading_ws = format!(\"\\n{}\", indent + 1);\n+                fn_def = fn_def.indent(indent + 1);\n+                trailing_ws = format!(\"\\n{}\", indent);\n+                it.syntax().text_range().start() + TextSize::of('{')\n             }\n         };\n \n         let placeholder_expr =\n             fn_def.syntax().descendants().find_map(ast::MacroCall::cast).unwrap();\n-        FunctionTemplate { insert_offset, placeholder_expr, fn_def, file: self.file }\n+        FunctionTemplate {\n+            insert_offset,\n+            placeholder_expr,\n+            leading_ws,\n+            fn_def,\n+            trailing_ws,\n+            file: self.file,\n+        }\n     }\n }\n \n@@ -165,7 +179,7 @@ impl GeneratedFunctionTarget {\n \n fn fn_name(call: &ast::Path) -> Option<ast::Name> {\n     let name = call.segment()?.syntax().to_string();\n-    Some(ast::make::name(&name))\n+    Some(make::name(&name))\n }\n \n /// Computes the type variables and arguments required for the generated function\n@@ -187,8 +201,8 @@ fn fn_args(\n         });\n     }\n     deduplicate_arg_names(&mut arg_names);\n-    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| ast::make::param(name, ty));\n-    Some((None, ast::make::param_list(params)))\n+    let params = arg_names.into_iter().zip(arg_types).map(|(name, ty)| make::param(name, ty));\n+    Some((None, make::param_list(params)))\n }\n \n /// Makes duplicate argument names unique by appending incrementing numbers."}, {"sha": "8a26a680828696e17eaf1960dce2ab4cc18aaeb2", "filename": "crates/ra_assists/src/utils.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/crates%2Fra_assists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/crates%2Fra_assists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Futils.rs?ref=e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "patch": "@@ -11,9 +11,15 @@ use ra_syntax::{\n };\n use rustc_hash::FxHashSet;\n \n+use crate::assist_config::SnippetCap;\n+\n pub(crate) use insert_use::insert_use_statement;\n \n-pub(crate) fn render_snippet(node: &SyntaxNode, placeholder: &SyntaxNode) -> String {\n+pub(crate) fn render_snippet(\n+    _cap: SnippetCap,\n+    node: &SyntaxNode,\n+    placeholder: &SyntaxNode,\n+) -> String {\n     assert!(placeholder.ancestors().any(|it| it == *node));\n     let range = placeholder.text_range() - node.text_range().start();\n     let range: ops::Range<usize> = range.into();"}, {"sha": "664894d1f839cfba0e1259bc625016fae30ad9d4", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "patch": "@@ -266,6 +266,15 @@ impl<'a> SyntaxRewriter<'a> {\n         let replacement = Replacement::Single(with.clone().into());\n         self.replacements.insert(what, replacement);\n     }\n+    pub fn replace_with_many<T: Clone + Into<SyntaxElement>>(\n+        &mut self,\n+        what: &T,\n+        with: Vec<SyntaxElement>,\n+    ) {\n+        let what = what.clone().into();\n+        let replacement = Replacement::Many(with);\n+        self.replacements.insert(what, replacement);\n+    }\n     pub fn replace_ast<T: AstNode>(&mut self, what: &T, with: &T) {\n         self.replace(what.syntax(), with.syntax())\n     }\n@@ -302,31 +311,41 @@ impl<'a> SyntaxRewriter<'a> {\n \n     fn rewrite_children(&self, node: &SyntaxNode) -> SyntaxNode {\n         //  FIXME: this could be made much faster.\n-        let new_children =\n-            node.children_with_tokens().flat_map(|it| self.rewrite_self(&it)).collect::<Vec<_>>();\n+        let mut new_children = Vec::new();\n+        for child in node.children_with_tokens() {\n+            self.rewrite_self(&mut new_children, &child);\n+        }\n         with_children(node, new_children)\n     }\n \n     fn rewrite_self(\n         &self,\n+        acc: &mut Vec<NodeOrToken<rowan::GreenNode, rowan::GreenToken>>,\n         element: &SyntaxElement,\n-    ) -> Option<NodeOrToken<rowan::GreenNode, rowan::GreenToken>> {\n+    ) {\n         if let Some(replacement) = self.replacement(&element) {\n-            return match replacement {\n+            match replacement {\n                 Replacement::Single(NodeOrToken::Node(it)) => {\n-                    Some(NodeOrToken::Node(it.green().clone()))\n+                    acc.push(NodeOrToken::Node(it.green().clone()))\n                 }\n                 Replacement::Single(NodeOrToken::Token(it)) => {\n-                    Some(NodeOrToken::Token(it.green().clone()))\n+                    acc.push(NodeOrToken::Token(it.green().clone()))\n                 }\n-                Replacement::Delete => None,\n+                Replacement::Many(replacements) => {\n+                    acc.extend(replacements.iter().map(|it| match it {\n+                        NodeOrToken::Node(it) => NodeOrToken::Node(it.green().clone()),\n+                        NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n+                    }))\n+                }\n+                Replacement::Delete => (),\n             };\n+            return;\n         }\n         let res = match element {\n             NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n             NodeOrToken::Node(it) => NodeOrToken::Node(self.rewrite_children(it).green().clone()),\n         };\n-        Some(res)\n+        acc.push(res)\n     }\n }\n \n@@ -341,6 +360,7 @@ impl ops::AddAssign for SyntaxRewriter<'_> {\n enum Replacement {\n     Delete,\n     Single(SyntaxElement),\n+    Many(Vec<SyntaxElement>),\n }\n \n fn with_children("}, {"sha": "29eb3fcb9ccca443055ef4c2bde26bf8f5735aac", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "patch": "@@ -1,7 +1,10 @@\n //! This module contains functions for editing syntax trees. As the trees are\n //! immutable, all function here return a fresh copy of the tree, instead of\n //! doing an in-place modification.\n-use std::{iter, ops::RangeInclusive};\n+use std::{\n+    fmt, iter,\n+    ops::{self, RangeInclusive},\n+};\n \n use arrayvec::ArrayVec;\n \n@@ -437,6 +440,28 @@ impl From<u8> for IndentLevel {\n     }\n }\n \n+impl fmt::Display for IndentLevel {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let spaces = \"                                        \";\n+        let buf;\n+        let len = self.0 as usize * 4;\n+        let indent = if len <= spaces.len() {\n+            &spaces[..len]\n+        } else {\n+            buf = iter::repeat(' ').take(len).collect::<String>();\n+            &buf\n+        };\n+        fmt::Display::fmt(indent, f)\n+    }\n+}\n+\n+impl ops::Add<u8> for IndentLevel {\n+    type Output = IndentLevel;\n+    fn add(self, rhs: u8) -> IndentLevel {\n+        IndentLevel(self.0 + rhs)\n+    }\n+}\n+\n impl IndentLevel {\n     pub fn from_node(node: &SyntaxNode) -> IndentLevel {\n         let first_token = match node.first_token() {\n@@ -453,6 +478,14 @@ impl IndentLevel {\n         IndentLevel(0)\n     }\n \n+    /// XXX: this intentionally doesn't change the indent of the very first token.\n+    /// Ie, in something like\n+    /// ```\n+    /// fn foo() {\n+    ///    92\n+    /// }\n+    /// ```\n+    /// if you indent the block, the `{` token would stay put.\n     fn increase_indent(self, node: SyntaxNode) -> SyntaxNode {\n         let mut rewriter = SyntaxRewriter::default();\n         node.descendants_with_tokens()\n@@ -463,12 +496,7 @@ impl IndentLevel {\n                 text.contains('\\n')\n             })\n             .for_each(|ws| {\n-                let new_ws = make::tokens::whitespace(&format!(\n-                    \"{}{:width$}\",\n-                    ws.syntax().text(),\n-                    \"\",\n-                    width = self.0 as usize * 4\n-                ));\n+                let new_ws = make::tokens::whitespace(&format!(\"{}{}\", ws.syntax(), self,));\n                 rewriter.replace(ws.syntax(), &new_ws)\n             });\n         rewriter.rewrite(&node)\n@@ -485,7 +513,7 @@ impl IndentLevel {\n             })\n             .for_each(|ws| {\n                 let new_ws = make::tokens::whitespace(\n-                    &ws.syntax().text().replace(&format!(\"\\n{:1$}\", \"\", self.0 as usize * 4), \"\\n\"),\n+                    &ws.syntax().text().replace(&format!(\"\\n{}\", self), \"\\n\"),\n                 );\n                 rewriter.replace(ws.syntax(), &new_ws)\n             });"}, {"sha": "b275780eca0e002b7a86186471ecbf6d41ac294c", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=e6fc0bdffb213f6e94c5bb4081e6d175ccbd518f", "patch": "@@ -277,29 +277,24 @@ pub fn param_list(pats: impl IntoIterator<Item = ast::Param>) -> ast::ParamList\n     ast_from_text(&format!(\"fn f({}) {{ }}\", args))\n }\n \n+pub fn visibility_pub_crate() -> ast::Visibility {\n+    ast_from_text(\"pub(crate) struct S\")\n+}\n+\n pub fn fn_def(\n+    visibility: Option<ast::Visibility>,\n     fn_name: ast::Name,\n     type_params: Option<ast::TypeParamList>,\n     params: ast::ParamList,\n     body: ast::BlockExpr,\n ) -> ast::FnDef {\n     let type_params =\n         if let Some(type_params) = type_params { format!(\"<{}>\", type_params) } else { \"\".into() };\n-    ast_from_text(&format!(\"fn {}{}{} {}\", fn_name, type_params, params, body))\n-}\n-\n-pub fn add_leading_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n-    let newlines = \"\\n\".repeat(amount_of_newlines);\n-    ast_from_text(&format!(\"{}{}\", newlines, t.syntax()))\n-}\n-\n-pub fn add_trailing_newlines(amount_of_newlines: usize, t: impl AstNode) -> ast::SourceFile {\n-    let newlines = \"\\n\".repeat(amount_of_newlines);\n-    ast_from_text(&format!(\"{}{}\", t.syntax(), newlines))\n-}\n-\n-pub fn add_pub_crate_modifier(fn_def: ast::FnDef) -> ast::FnDef {\n-    ast_from_text(&format!(\"pub(crate) {}\", fn_def))\n+    let visibility = match visibility {\n+        None => String::new(),\n+        Some(it) => format!(\"{} \", it),\n+    };\n+    ast_from_text(&format!(\"{}fn {}{}{} {}\", visibility, fn_name, type_params, params, body))\n }\n \n fn ast_from_text<N: AstNode>(text: &str) -> N {"}]}