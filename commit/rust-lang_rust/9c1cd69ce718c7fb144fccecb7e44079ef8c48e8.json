{"sha": "9c1cd69ce718c7fb144fccecb7e44079ef8c48e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljMWNkNjljZTcxOGM3ZmIxNDRmY2NlY2I3ZTQ0MDc5ZWY4YzQ4ZTg=", "commit": {"author": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2014-04-14T21:43:38Z"}, "committer": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2014-04-15T22:57:04Z"}, "message": "optimized SipHash implementation\n\nwork started from @gereeter's PR: https://github.com/mozilla/rust/pull/13114\nbut adjusted bits", "tree": {"sha": "7aebf7d4aef778ec4f41f6b0cd2fdcd03fa44289", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aebf7d4aef778ec4f41f6b0cd2fdcd03fa44289"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c1cd69ce718c7fb144fccecb7e44079ef8c48e8", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c1cd69ce718c7fb144fccecb7e44079ef8c48e8", "html_url": "https://github.com/rust-lang/rust/commit/9c1cd69ce718c7fb144fccecb7e44079ef8c48e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c1cd69ce718c7fb144fccecb7e44079ef8c48e8/comments", "author": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "246ebd2d5aebc68a581c33c33cbce5f2bc7dc7d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/246ebd2d5aebc68a581c33c33cbce5f2bc7dc7d6", "html_url": "https://github.com/rust-lang/rust/commit/246ebd2d5aebc68a581c33c33cbce5f2bc7dc7d6"}], "stats": {"total": 185, "additions": 143, "deletions": 42}, "files": [{"sha": "9afb7124c4bf273ff17b771f060c4f7e380c523e", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 143, "deletions": 42, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/9c1cd69ce718c7fb144fccecb7e44079ef8c48e8/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c1cd69ce718c7fb144fccecb7e44079ef8c48e8/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=9c1cd69ce718c7fb144fccecb7e44079ef8c48e8", "patch": "@@ -27,10 +27,12 @@\n use clone::Clone;\n use container::Container;\n use default::Default;\n+use int;\n use io::{IoResult, Writer};\n use iter::Iterator;\n use result::Ok;\n use slice::ImmutableVector;\n+use uint;\n \n use super::{Hash, Hasher};\n \n@@ -43,7 +45,7 @@ pub struct SipState {\n     v1: u64,\n     v2: u64,\n     v3: u64,\n-    tail: [u8, ..8], // unprocessed bytes\n+    tail: u64, // unprocessed bytes le\n     ntail: uint,  // how many bytes in tail are valid\n }\n \n@@ -60,7 +62,17 @@ macro_rules! u8to64_le (\n      $buf[4+$i] as u64 << 32 |\n      $buf[5+$i] as u64 << 40 |\n      $buf[6+$i] as u64 << 48 |\n-     $buf[7+$i] as u64 << 56)\n+     $buf[7+$i] as u64 << 56);\n+    ($buf:expr, $i:expr, $len:expr) =>\n+    ({\n+        let mut t = 0;\n+        let mut out = 0u64;\n+        while t < $len {\n+            out |= $buf[t+$i] as u64 << t*8;\n+            t += 1;\n+        }\n+        out\n+    });\n )\n \n macro_rules! rotl (\n@@ -98,7 +110,7 @@ impl SipState {\n             v1: 0,\n             v2: 0,\n             v3: 0,\n-            tail: [ 0, 0, 0, 0, 0, 0, 0, 0 ],\n+            tail: 0,\n             ntail: 0,\n         };\n         state.reset();\n@@ -124,15 +136,7 @@ impl SipState {\n         let mut v2 = self.v2;\n         let mut v3 = self.v3;\n \n-        let mut b : u64 = (self.length as u64 & 0xff) << 56;\n-\n-        if self.ntail > 0 { b |= self.tail[0] as u64 <<  0; }\n-        if self.ntail > 1 { b |= self.tail[1] as u64 <<  8; }\n-        if self.ntail > 2 { b |= self.tail[2] as u64 << 16; }\n-        if self.ntail > 3 { b |= self.tail[3] as u64 << 24; }\n-        if self.ntail > 4 { b |= self.tail[4] as u64 << 32; }\n-        if self.ntail > 5 { b |= self.tail[5] as u64 << 40; }\n-        if self.ntail > 6 { b |= self.tail[6] as u64 << 48; }\n+        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n \n         v3 ^= b;\n         compress!(v0, v1, v2, v3);\n@@ -147,8 +151,38 @@ impl SipState {\n \n         v0 ^ v1 ^ v2 ^ v3\n     }\n+\n+    #[inline]\n+    fn write_le(&mut self, n: u64, size: uint) {\n+        self.tail |= n << 8*self.ntail;\n+        self.ntail += size;\n+\n+        if self.ntail >= 8 {\n+            let m = self.tail;\n+\n+            self.v3 ^= m;\n+            compress!(self.v0, self.v1, self.v2, self.v3);\n+            compress!(self.v0, self.v1, self.v2, self.v3);\n+            self.v0 ^= m;\n+\n+            self.ntail -= 8;\n+            if self.ntail == 0 {\n+                self.tail = 0;\n+            } else {\n+                self.tail = n >> 64 - 8*self.ntail;\n+            }\n+        }\n+    }\n }\n \n+macro_rules! make_write_le(\n+    ($this:expr, $n:expr, $size:expr) => ({\n+          $this.write_le($n as u64, $size);\n+          $this.length += $size;\n+          Ok(())\n+    })\n+)\n+\n impl Writer for SipState {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) -> IoResult<()> {\n@@ -159,24 +193,13 @@ impl Writer for SipState {\n \n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n-\n             if length < needed {\n-                let mut t = 0;\n-                while t < length {\n-                    self.tail[self.ntail+t] = msg[t];\n-                    t += 1;\n-                }\n+                self.tail |= u8to64_le!(msg, 0, length) << 8*self.ntail;\n                 self.ntail += length;\n                 return Ok(());\n             }\n \n-            let mut t = 0;\n-            while t < needed {\n-                self.tail[self.ntail+t] = msg[t];\n-                t += 1;\n-            }\n-\n-            let m = u8to64_le!(self.tail, 0);\n+            let m = self.tail | u8to64_le!(msg, 0, needed) << 8*self.ntail;\n \n             self.v3 ^= m;\n             compress!(self.v0, self.v1, self.v2, self.v3);\n@@ -203,15 +226,62 @@ impl Writer for SipState {\n             i += 8;\n         }\n \n-        let mut t = 0u;\n-        while t < left {\n-            self.tail[t] = msg[i+t];\n-            t += 1\n-        }\n+        self.tail = u8to64_le!(msg, i, left);\n         self.ntail = left;\n \n         Ok(())\n     }\n+\n+    #[inline]\n+    fn write_u8(&mut self, n: u8) -> IoResult<()> {\n+        make_write_le!(self, n, 1)\n+    }\n+\n+    #[inline]\n+    fn write_le_u16(&mut self, n: u16) -> IoResult<()> {\n+        make_write_le!(self, n, 2)\n+    }\n+\n+    #[inline]\n+    fn write_le_u32(&mut self, n: u32) -> IoResult<()> {\n+        make_write_le!(self, n, 4)\n+    }\n+\n+    #[inline]\n+    fn write_le_u64(&mut self, n: u64) -> IoResult<()> {\n+        make_write_le!(self, n, 8)\n+    }\n+\n+    #[inline]\n+    fn write_le_uint(&mut self, n: uint) -> IoResult<()> {\n+        make_write_le!(self, n, uint::BYTES)\n+    }\n+\n+    #[inline]\n+    fn write_i8(&mut self, n: i8) -> IoResult<()> {\n+        make_write_le!(self, n, 1)\n+    }\n+\n+    #[inline]\n+    fn write_le_i16(&mut self, n: i16) -> IoResult<()> {\n+        make_write_le!(self, n, 2)\n+    }\n+\n+    #[inline]\n+    fn write_le_i32(&mut self, n: i32) -> IoResult<()> {\n+        make_write_le!(self, n, 4)\n+    }\n+\n+    #[inline]\n+    fn write_le_i64(&mut self, n: i64) -> IoResult<()> {\n+        make_write_le!(self, n, 8)\n+    }\n+\n+    #[inline]\n+    fn write_le_int(&mut self, n: int) -> IoResult<()> {\n+        make_write_le!(self, n, int::BYTES)\n+    }\n+\n }\n \n impl Clone for SipState {\n@@ -284,6 +354,8 @@ pub fn hash_with_keys<T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n     state.result()\n }\n \n+\n+\n #[cfg(test)]\n mod tests {\n     extern crate test;\n@@ -517,28 +589,57 @@ mod tests {\n     }\n \n     #[bench]\n-    fn bench_str(b: &mut Bencher) {\n+    fn bench_str_under_8_bytes(b: &mut Bencher) {\n         let s = \"foo\";\n         b.iter(|| {\n             assert_eq!(hash(&s), 16262950014981195938);\n         })\n     }\n \n+    #[bench]\n+    fn bench_str_of_8_bytes(b: &mut Bencher) {\n+        let s = \"foobar78\";\n+        b.iter(|| {\n+            assert_eq!(hash(&s), 4898293253460910787);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_str_over_8_bytes(b: &mut Bencher) {\n+        let s = \"foobarbaz0\";\n+        b.iter(|| {\n+            assert_eq!(hash(&s), 10581415515220175264);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_long_str(b: &mut Bencher) {\n+        let s = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor \\\n+incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud \\\n+exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute \\\n+irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla \\\n+pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui \\\n+officia deserunt mollit anim id est laborum.\";\n+        b.iter(|| {\n+            assert_eq!(hash(&s), 17717065544121360093);\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_u64(b: &mut Bencher) {\n+        let u = 16262950014981195938u64;\n+        b.iter(|| {\n+            assert_eq!(hash(&u), 5254097107239593357);\n+        })\n+    }\n+\n+    #[deriving(Hash)]\n     struct Compound {\n         x: u8,\n-        y: u16,\n+        y: u64,\n         z: ~str,\n     }\n \n-    impl<S: Writer> Hash<S> for Compound {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            self.x.hash(state);\n-            self.y.hash(state);\n-            self.z.hash(state);\n-        }\n-    }\n-\n     #[bench]\n     fn bench_compound_1(b: &mut Bencher) {\n         let compound = Compound {\n@@ -547,7 +648,7 @@ mod tests {\n             z: ~\"foobarbaz\",\n         };\n         b.iter(|| {\n-            assert_eq!(hash(&compound), 3581836382593270478);\n+            assert_eq!(hash(&compound), 15783192367317361799);\n         })\n     }\n }"}]}