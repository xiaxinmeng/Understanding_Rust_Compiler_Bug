{"sha": "2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlM2IwYzA1MWRjYTk4ODBiZjY2YjUzNjZkY2NkMmUwYmI0MjRiOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-01T22:41:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-01T22:41:08Z"}, "message": "Auto merge of #23955 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "2e8b8ea5a0daf51f819acaab9b9e2572459e2a60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e8b8ea5a0daf51f819acaab9b9e2572459e2a60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "html_url": "https://github.com/rust-lang/rust/commit/2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "html_url": "https://github.com/rust-lang/rust/commit/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a"}, {"sha": "0304e15e5c39654346e827c2bb25ca41ed310c86", "url": "https://api.github.com/repos/rust-lang/rust/commits/0304e15e5c39654346e827c2bb25ca41ed310c86", "html_url": "https://github.com/rust-lang/rust/commit/0304e15e5c39654346e827c2bb25ca41ed310c86"}], "stats": {"total": 6073, "additions": 3931, "deletions": 2142}, "files": [{"sha": "f00ff9bcbe5e5c4bec3ad7fbbd4336a72f1a2c55", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -31,7 +31,6 @@ extern crate log;\n use std::env;\n use std::fs;\n use std::path::{Path, PathBuf};\n-use std::thunk::Thunk;\n use getopts::{optopt, optflag, reqopt};\n use common::Config;\n use common::{Pretty, DebugInfoGdb, DebugInfoLldb, Codegen};\n@@ -351,7 +350,7 @@ pub fn make_test_name(config: &Config, testfile: &Path) -> test::TestName {\n pub fn make_test_closure(config: &Config, testfile: &Path) -> test::TestFn {\n     let config = (*config).clone();\n     let testfile = testfile.to_path_buf();\n-    test::DynTestFn(Thunk::new(move || {\n+    test::DynTestFn(Box::new(move || {\n         runtest::run(config, &testfile)\n     }))\n }"}, {"sha": "f5505b6e83a6738dd073b68513a4ef5755a339e4", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -311,7 +311,7 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n     parse_name_value_directive(line, \"exec-env\").map(|nv| {\n         // nv is either FOO or FOO=BAR\n         let mut strs: Vec<String> = nv\n-                                      .splitn(1, '=')\n+                                      .splitn(2, '=')\n                                       .map(|s| s.to_string())\n                                       .collect();\n "}, {"sha": "01b8163ffd372b89c75843e419dcc9bc968546e8", "filename": "src/doc/trpl/closures.md", "status": "modified", "additions": 401, "deletions": 137, "changes": 538, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fdoc%2Ftrpl%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fdoc%2Ftrpl%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fclosures.md?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -1,214 +1,478 @@\n % Closures\n \n-So far, we've made lots of functions in Rust, but we've given them all names.\n-Rust also allows us to create anonymous functions. Rust's anonymous\n-functions are called *closures*. By themselves, closures aren't all that\n-interesting, but when you combine them with functions that take closures as\n-arguments, really powerful things are possible.\n+Rust not only has named functions, but anonymous functions as well. Anonymous\n+functions that have an associated environment are called 'closures', because they\n+close over an environment. Rust has a really great implementation of them, as\n+we'll see.\n \n-Let's make a closure:\n+# Syntax\n \n-```{rust}\n-let add_one = |x| { 1 + x };\n+Closures look like this:\n \n-println!(\"The sum of 5 plus 1 is {}.\", add_one(5));\n+```rust\n+let plus_one = |x: i32| x + 1;\n+\n+assert_eq!(2, plus_one(1));\n+```\n+\n+We create a binding, `plus_one`, and assign it to a closure. The closure's\n+arguments go between the pipes (`|`), and the body is an expression, in this\n+case, `x + 1`. Remember that `{ }` is an expression, so we can have multi-line\n+closures too:\n+\n+```rust\n+let plus_two = |x| {\n+    let mut result: i32 = x;\n+\n+    result += 1;\n+    result += 1;\n+\n+    result\n+};\n+\n+assert_eq!(4, plus_two(2));\n+```\n+\n+You'll notice a few things about closures that are a bit different than regular\n+functions defined with `fn`. The first of which is that we did not need to\n+annotate the types of arguments the closure takes or the values it returns. We\n+can:\n+\n+```rust\n+let plus_one = |x: i32| -> i32 { x + 1 };\n+\n+assert_eq!(2, plus_one(1));\n+```\n+\n+But we don't have to. Why is this? Basically, it was chosen for ergonomic reasons.\n+While specifying the full type for named functions is helpful with things like\n+documentation and type inference, the types of closures are rarely documented\n+since they\u2019re anonymous, and they don\u2019t cause the kinds of error-at-a-distance\n+that inferring named function types can.\n+\n+The second is that the syntax is similar, but a bit different. I've added spaces\n+here to make them look a little closer:\n+\n+```rust\n+fn  plus_one_v1 (  x: i32 ) -> i32 { x + 1 }\n+let plus_one_v2 = |x: i32 | -> i32 { x + 1 };\n+let plus_one_v3 = |x: i32 |          x + 1  ;\n ```\n \n-We create a closure using the `|...| { ... }` syntax, and then we create a\n-binding so we can use it later. Note that we call the function using the\n-binding name and two parentheses, just like we would for a named function.\n+Small differences, but they're similar in ways.\n \n-Let's compare syntax. The two are pretty close:\n+# Closures and their environment\n \n-```{rust}\n-let add_one = |x: i32| -> i32 { 1 + x };\n-fn  add_one   (x: i32) -> i32 { 1 + x }\n+Closures are called such because they 'close over their environment.' It\n+looks like this:\n+\n+```rust\n+let num = 5;\n+let plus_num = |x: i32| x + num;\n+\n+assert_eq!(10, plus_num(5));\n ```\n \n-As you may have noticed, closures infer their argument and return types, so you\n-don't need to declare one. This is different from named functions, which\n-default to returning unit (`()`).\n+This closure, `plus_num`, refers to a `let` binding in its scope: `num`. More\n+specifically, it borrows the binding. If we do something that would conflict\n+with that binding, we get an error. Like this one:\n+\n+```rust,ignore\n+let mut num = 5;\n+let plus_num = |x: i32| x + num;\n \n-There's one big difference between a closure and named functions, and it's in\n-the name: a closure \"closes over its environment.\" What does that mean? It means\n-this:\n+let y = &mut num;\n+```\n \n-```{rust}\n+Which errors with:\n+\n+```text\n+error: cannot borrow `num` as mutable because it is also borrowed as immutable\n+    let y = &mut num;\n+                 ^~~\n+note: previous borrow of `num` occurs here due to use in closure; the immutable\n+  borrow prevents subsequent moves or mutable borrows of `num` until the borrow\n+  ends\n+    let plus_num = |x| x + num;\n+                   ^~~~~~~~~~~\n+note: previous borrow ends here\n fn main() {\n-    let x: i32 = 5;\n+    let mut num = 5;\n+    let plus_num = |x| x + num;\n+    \n+    let y = &mut num;\n+}\n+^\n+```\n+\n+A verbose yet helpful error message! As it says, we can't take a mutable borrow\n+on `num` because the closure is already borrowing it. If we let the closure go\n+out of scope, we can:\n+\n+```rust\n+let mut num = 5;\n+{\n+    let plus_num = |x: i32| x + num;\n+\n+} // plus_num goes out of scope, borrow of num ends\n \n-    let printer = || { println!(\"x is: {}\", x); };\n+let y = &mut num;\n+```\n+\n+If your closure requires it, however, Rust will take ownership and move\n+the environment instead:\n+\n+```rust,ignore\n+let nums = vec![1, 2, 3];\n+\n+let takes_nums = || nums;\n+\n+println!(\"{:?}\", nums);\n+```\n+\n+This gives us:\n+\n+```text\n+note: `nums` moved into closure environment here because it has type\n+  `[closure(()) -> collections::vec::Vec<i32>]`, which is non-copyable\n+let takes_nums = || nums;\n+                    ^~~~~~~\n+```\n+\n+`Vec<T>` has ownership over its contents, and therefore, when we refer to it\n+in our closure, we have to take ownership of `nums`. It's the same as if we'd\n+passed `nums` to a function that took ownership of it.\n+\n+## `move` closures\n+\n+We can force our closure to take ownership of its environment with the `move`\n+keyword:\n \n-    printer(); // prints \"x is: 5\"\n+```rust\n+let num = 5;\n+\n+let owns_num = move |x: i32| x + num;\n+```\n+\n+Now, even though the keyword is `move`, the variables follow normal move semantics.\n+In this case, `5` implements `Copy`, and so `owns_num` takes ownership of a copy\n+of `num`. So what's the difference?\n+\n+```rust\n+let mut num = 5;\n+\n+{ \n+    let mut add_num = |x: i32| num += x;\n+\n+    add_num(5);\n }\n+\n+assert_eq!(10, num);\n ```\n \n-The `||` syntax means this is an anonymous closure that takes no arguments.\n-Without it, we'd just have a block of code in `{}`s.\n+So in this case, our closure took a mutable reference to `num`, and then when\n+we called `add_num`, it mutated the underlying value, as we'd expect. We also\n+needed to declare `add_num` as `mut` too, because we\u2019re mutating its\n+environment.\n \n-In other words, a closure has access to variables in the scope where it's\n-defined. The closure borrows any variables it uses, so this will error:\n+We also had to declare `add_num` as mut, since we will be modifying its\n+environment.\n \n-```{rust,ignore}\n-fn main() {\n-    let mut x: i32 = 5;\n+If we change to a `move` closure, it's different:\n+\n+```rust\n+let mut num = 5;\n \n-    let printer = || { println!(\"x is: {}\", x); };\n+{ \n+    let mut add_num = move |x: i32| num += x;\n \n-    x = 6; // error: cannot assign to `x` because it is borrowed\n+    add_num(5);\n }\n+\n+assert_eq!(5, num);\n ```\n \n-## Moving closures\n+We only get `5`. Rather than taking a mutable borrow out on our `num`, we took\n+ownership of a copy.\n+\n+Another way to think about `move` closures: they give a closure its own stack\n+frame.  Without `move`, a closure may be tied to the stack frame that created\n+it, while a `move` closure is self-contained. This means that you cannot\n+generally return a non-`move` closure from a function, for example.\n+\n+But before we talk about taking and returning closures, we should talk some more\n+about the way that closures are implemented. As a systems language, Rust gives\n+you tons of control over what your code does, and closures are no different.\n \n-Rust has a second type of closure, called a *moving closure*. Moving\n-closures are indicated using the `move` keyword (e.g., `move || x *\n-x`). The difference between a moving closure and an ordinary closure\n-is that a moving closure always takes ownership of all variables that\n-it uses. Ordinary closures, in contrast, just create a reference into\n-the enclosing stack frame. Moving closures are most useful with Rust's\n-concurrency features, and so we'll just leave it at this for\n-now. We'll talk about them more in the \"Concurrency\" chapter of the book.\n+# Closure implementation\n \n-## Accepting closures as arguments\n+Rust's implementation of closures is a bit different than other languages. They\n+are effectively syntax sugar for traits. You'll want to make sure to have read\n+the [traits chapter][traits] before this one, as well as the chapter on [static\n+and dynamic dispatch][dispatch], which talks about trait objects.\n \n-Closures are most useful as an argument to another function. Here's an example:\n+[traits]: traits.html\n+[dispatch]: static-and-dynamic-dispatch.html\n \n-```{rust}\n-fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n-    f(x) + f(x)\n+Got all that? Good.\n+\n+The key to understanding how closures work under the hood is something a bit\n+strange: Using `()` to call a function, like `foo()`, is an overloadable\n+operator. From this, everything else clicks into place. In Rust, we use the\n+trait system to overload operators. Calling functions is no different. We have\n+three separate traits to overload with:\n+\n+```rust\n+# mod foo {\n+pub trait Fn<Args> : FnMut<Args> {\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n }\n \n-fn main() {\n-    let square = |x: i32| { x * x };\n+pub trait FnMut<Args> : FnOnce<Args> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n+pub trait FnOnce<Args> {\n+    type Output;\n \n-    twice(5, square); // evaluates to 50\n+    extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n+# }\n ```\n \n-Let's break the example down, starting with `main`:\n+You'll notice a few differences between these traits, but a big one is `self`:\n+`Fn` takes `&self`, `FnMut` takes `&mut self`, and `FnOnce` takes `self`. This\n+covers all three kinds of `self` via the usual method call syntax. But we've\n+split them up into three traits, rather than having a single one. This gives us\n+a large amount of control over what kind of closures we can take.\n \n-```{rust}\n-let square = |x: i32| { x * x };\n-```\n+The `|| {}` syntax for closures is sugar for these three traits. Rust will\n+generate a struct for the environment, `impl` the appropriate trait, and then\n+use it.\n+\n+# Taking closures as arguments\n+\n+Now that we know that closures are traits, we already know how to accept and\n+return closures: just like any other trait!\n+\n+This also means that we can choose static vs dynamic dispatch as well. First,\n+let's write a function which takes something callable, calls it, and returns\n+the result:\n+\n+```rust\n+fn call_with_one<F>(some_closure: F) -> i32\n+    where F : Fn(i32) -> i32 {\n+\n+    some_closure(1)\n+}\n \n-We've seen this before. We make a closure that takes an integer, and returns\n-its square.\n+let answer = call_with_one(|x| x + 2);\n \n-```{rust}\n-# fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 { f(x) + f(x) }\n-# let square = |x: i32| { x * x };\n-twice(5, square); // evaluates to 50\n+assert_eq!(3, answer);\n ```\n \n-This line is more interesting. Here, we call our function, `twice`, and we pass\n-it two arguments: an integer, `5`, and our closure, `square`. This is just like\n-passing any other two variable bindings to a function, but if you've never\n-worked with closures before, it can seem a little complex. Just think: \"I'm\n-passing two variables: one is an i32, and one is a function.\"\n+We pass our closure, `|x| x + 2`, to `call_with_one`. It just does what it\n+suggests: it calls the closure, giving it `1` as an argument.\n \n-Next, let's look at how `twice` is defined:\n+Let's examine the signature of `call_with_one` in more depth:\n \n-```{rust,ignore}\n-fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n+```rust\n+fn call_with_one<F>(some_closure: F) -> i32\n+#    where F : Fn(i32) -> i32 {\n+#    some_closure(1) }\n ```\n \n-`twice` takes two arguments, `x` and `f`. That's why we called it with two\n-arguments. `x` is an `i32`, we've done that a ton of times. `f` is a function,\n-though, and that function takes an `i32` and returns an `i32`. This is\n-what the requirement `Fn(i32) -> i32` for the type parameter `F` says.\n-Now `F` represents *any* function that takes an `i32` and returns an `i32`.\n+We take one parameter, and it has the type `F`. We also return a `i32`. This part\n+isn't interesting. The next part is:\n \n-This is the most complicated function signature we've seen yet! Give it a read\n-a few times until you can see how it works. It takes a teeny bit of practice, and\n-then it's easy. The good news is that this kind of passing a closure around\n-can be very efficient. With all the type information available at compile-time\n-the compiler can do wonders.\n+```rust\n+# fn call_with_one<F>(some_closure: F) -> i32\n+    where F : Fn(i32) -> i32 {\n+#   some_closure(1) }\n+```\n+\n+Because `Fn` is a trait, we can bound our generic with it. In this case, our closure\n+takes a `i32` as an argument and returns an `i32`, and so the generic bound we use\n+is `Fn(i32) -> i32`.\n \n-Finally, `twice` returns an `i32` as well.\n+There's one other key point here: because we're bounding a generic with a\n+trait, this will get monomorphized, and therefore, we'll be doing static\n+dispatch into the closure. That's pretty neat. In many langauges, closures are\n+inherently heap allocated, and will always involve dynamic dispatch. In Rust,\n+we can stack allocate our closure environment, and statically dispatch the\n+call. This happens quite often with iterators and their adapters, which often\n+take closures as arguments.\n \n-Okay, let's look at the body of `twice`:\n+Of course, if we want dynamic dispatch, we can get that too. A trait object\n+handles this case, as usual:\n \n-```{rust}\n-fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n-  f(x) + f(x)\n+```rust\n+fn call_with_one(some_closure: &Fn(i32) -> i32) -> i32 {\n+    some_closure(1)\n }\n+\n+let answer = call_with_one(&|x| x + 2);\n+\n+assert_eq!(3, answer);\n ```\n \n-Since our closure is named `f`, we can call it just like we called our closures\n-before, and we pass in our `x` argument to each one, hence the name `twice`.\n+Now we take a trait object, a `&Fn`. And we have to make a reference\n+to our closure when we pass it to `call_with_one`, so we use `&||`.\n \n-If you do the math, `(5 * 5) + (5 * 5) == 50`, so that's the output we get.\n+# Returning closures\n \n-Play around with this concept until you're comfortable with it. Rust's standard\n-library uses lots of closures where appropriate, so you'll be using\n-this technique a lot.\n+It\u2019s very common for functional-style code to return closures in various\n+situations. If you try to return a closure, you may run into an error. At\n+first, it may seem strange, but we'll figure it out. Here's how you'd probably\n+try to return a closure from a function:\n \n-If we didn't want to give `square` a name, we could just define it inline.\n-This example is the same as the previous one:\n+```rust,ignore\n+fn factory() -> (Fn(i32) -> Vec<i32>) {\n+    let vec = vec![1, 2, 3];\n \n-```{rust}\n-fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n-    f(x) + f(x)\n+    |n| vec.push(n)\n }\n \n-fn main() {\n-    twice(5, |x: i32| { x * x }); // evaluates to 50\n-}\n+let f = factory();\n+\n+let answer = f(4);\n+assert_eq!(vec![1, 2, 3, 4], answer);\n ```\n \n-A named function's name can be used wherever you'd use a closure. Another\n-way of writing the previous example:\n+This gives us these long, related errors:\n+\n+```text\n+error: the trait `core::marker::Sized` is not implemented for the type\n+`core::ops::Fn(i32) -> collections::vec::Vec<i32>` [E0277]\n+f = factory();\n+^\n+note: `core::ops::Fn(i32) -> collections::vec::Vec<i32>` does not have a\n+constant size known at compile-time\n+f = factory();\n+^\n+error: the trait `core::marker::Sized` is not implemented for the type\n+`core::ops::Fn(i32) -> collections::vec::Vec<i32>` [E0277]\n+factory() -> (Fn(i32) -> Vec<i32>) {\n+             ^~~~~~~~~~~~~~~~~~~~~\n+note: `core::ops::Fn(i32) -> collections::vec::Vec<i32>` does not have a constant size known at compile-time\n+fa ctory() -> (Fn(i32) -> Vec<i32>) {\n+              ^~~~~~~~~~~~~~~~~~~~~\n \n-```{rust}\n-fn twice<F: Fn(i32) -> i32>(x: i32, f: F) -> i32 {\n-    f(x) + f(x)\n-}\n+```\n \n-fn square(x: i32) -> i32 { x * x }\n+In order to return something from a function, Rust needs to know what\n+size the return type is. But since `Fn` is a trait, it could be various\n+things of various sizes: many different types can implement `Fn`. An easy\n+way to give something a size is to take a reference to it, as references\n+have a known size. So we'd write this:\n \n-fn main() {\n-    twice(5, square); // evaluates to 50\n+```rust,ignore\n+fn factory() -> &(Fn(i32) -> Vec<i32>) {\n+    let vec = vec![1, 2, 3];\n+\n+    |n| vec.push(n)\n }\n+\n+let f = factory();\n+\n+let answer = f(4);\n+assert_eq!(vec![1, 2, 3, 4], answer);\n+```\n+\n+But we get another error:\n+\n+```text\n+error: missing lifetime specifier [E0106]\n+fn factory() -> &(Fn(i32) -> i32) {\n+                ^~~~~~~~~~~~~~~~~\n ```\n \n-Doing this is not particularly common, but it's useful every once in a while.\n+Right. Because we have a reference, we need to give it a lifetime. But\n+our `factory()` function takes no arguments, so elision doesn't kick in\n+here. What lifetime can we choose? `'static`:\n \n-Before we move on, let us look at a function that accepts two closures.\n+```rust,ignore\n+fn factory() -> &'static (Fn(i32) -> i32) {\n+    let num = 5;\n \n-```{rust}\n-fn compose<F, G>(x: i32, f: F, g: G) -> i32\n-    where F: Fn(i32) -> i32, G: Fn(i32) -> i32 {\n-    g(f(x))\n+    |x| x + num\n }\n \n-fn main() {\n-    compose(5,\n-            |n: i32| { n + 42 },\n-            |n: i32| { n * 2 }); // evaluates to 94\n+let f = factory();\n+\n+let answer = f(1);\n+assert_eq!(6, answer);\n+```\n+\n+But we get another error:\n+\n+```text\n+error: mismatched types:\n+ expected `&'static core::ops::Fn(i32) -> i32`,\n+    found `[closure <anon>:7:9: 7:20]`\n+(expected &-ptr,\n+    found closure) [E0308]\n+         |x| x + num\n+         ^~~~~~~~~~~\n+\n+```\n+\n+This error is letting us know that we don't have a `&'static Fn(i32) -> i32`,\n+we have a `[closure <anon>:7:9: 7:20]`. Wait, what?\n+\n+Because each closure generates its own environment `struct` and implementation\n+of `Fn` and friends, these types are anonymous. They exist just solely for\n+this closure. So Rust shows them as `closure <anon>`, rather than some\n+autogenerated name.\n+\n+But why doesn't our closure implement `&'static Fn`? Well, as we discussed before,\n+closures borrow their environment. And in this case, our environment is based\n+on a stack-allocated `5`, the `num` variable binding. So the borrow has a lifetime\n+of the stack frame. So if we returned this closure, the function call would be\n+over, the stack frame would go away, and our closure is capturing an environment\n+of garbage memory!\n+\n+So what to do? This _almost_ works:\n+\n+```rust,ignore\n+fn factory() -> Box<Fn(i32) -> i32> {\n+    let num = 5;\n+\n+    Box::new(|x| x + num)\n }\n+# fn main() {\n+let f = factory();\n+\n+let answer = f(1);\n+assert_eq!(6, answer);\n+# }\n ```\n \n-You might ask yourself: why do we need to introduce two type\n-parameters `F` and `G` here?  Evidently, both `f` and `g` have the\n-same signature: `Fn(i32) -> i32`.\n+We use a trait object, by `Box`ing up the `Fn`. There's just one last problem:\n \n-That is because in Rust each closure has its own unique type.\n-So, not only do closures with different signatures have different types,\n-but different closures with the *same* signature have *different*\n-types, as well!\n+```text\n+error: `num` does not live long enough\n+Box::new(|x| x + num)\n+         ^~~~~~~~~~~\n+```\n+\n+We still have a reference to the parent stack frame. With one last fix, we can\n+make this work:\n \n-You can think of it this way: the behavior of a closure is part of its\n-type.  Therefore, using a single type parameter for both closures\n-will accept the first of them, rejecting the second. The distinct\n-type of the second closure does not allow it to be represented by the\n-same type parameter as that of the first.  We acknowledge this, and\n-use two different type parameters `F` and `G`.\n+```rust\n+fn factory() -> Box<Fn(i32) -> i32> {\n+    let num = 5;\n \n-This also introduces the `where` clause, which lets us describe type\n-parameters in a more flexible manner.\n+    Box::new(move |x| x + num)\n+}\n+# fn main() {\n+let f = factory();\n+\n+let answer = f(1);\n+assert_eq!(6, answer);\n+# }\n+```\n \n-That's all you need to get the hang of closures! Closures are a little bit\n-strange at first, but once you're used to them, you'll miss them\n-in other languages. Passing functions to other functions is\n-incredibly powerful, as you will see in the following chapter about iterators.\n+By making the inner closure a `move Fn`, we create a new stack frame for our\n+closure. By `Box`ing it up, we've given it a known size, and allowing it to\n+escape our stack frame."}, {"sha": "b9e7bd78c5b2fa26dd200d632ce8875b1da846e4", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -200,15 +200,15 @@ Because these kinds of situations are relatively rare, use panics sparingly.\n # Upgrading failures to panics\n \n In certain circumstances, even though a function may fail, we may want to treat\n-it as a panic instead. For example, `io::stdin().read_line()` returns an\n-`IoResult<String>`, a form of `Result`, when there is an error reading the\n-line. This allows us to handle and possibly recover from this sort of error.\n+it as a panic instead. For example, `io::stdin().read_line(&mut buffer)` returns\n+an `Result<usize>`, when there is an error reading the line. This allows us to\n+handle and possibly recover from error.\n \n If we don't want to handle this error, and would rather just abort the program,\n we can use the `unwrap()` method:\n \n ```{rust,ignore}\n-io::stdin().read_line().unwrap();\n+io::stdin().read_line(&mut buffer).unwrap();\n ```\n \n `unwrap()` will `panic!` if the `Option` is `None`. This basically says \"Give\n@@ -219,12 +219,13 @@ shorter. Sometimes, just crashing is appropriate.\n There's another way of doing this that's a bit nicer than `unwrap()`:\n \n ```{rust,ignore}\n-let input = io::stdin().read_line()\n+let mut buffer = String::new();\n+let input = io::stdin().read_line(&mut buffer)\n                        .ok()\n                        .expect(\"Failed to read line\");\n ```\n \n-`ok()` converts the `IoResult` into an `Option`, and `expect()` does the same\n+`ok()` converts the `Result` into an `Option`, and `expect()` does the same\n thing as `unwrap()`, but takes a message. This message is passed along to the\n underlying `panic!`, providing a better error message if the code errors.\n "}, {"sha": "918c0c66f76df070b99848c2d53be8a5894ad6db", "filename": "src/etc/rustup.sh", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fetc%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fetc%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frustup.sh?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -288,6 +288,7 @@ VAL_OPTIONS=\"\"\n flag uninstall \"only uninstall from the installation prefix\"\n valopt prefix \"\" \"set installation prefix\"\n valopt date \"\" \"use the YYYY-MM-DD nightly instead of the current nightly\"\n+valopt channel \"beta\" \"use the selected release channel [beta]\"\n flag save \"save the downloaded nightlies to ~/.rustup\"\n \n if [ $HELP -eq 1 ]\n@@ -307,7 +308,7 @@ CFG_CPUTYPE=$(uname -m)\n \n if [ $CFG_OSTYPE = Darwin -a $CFG_CPUTYPE = i386 ]\n then\n-    # Darwin's `uname -s` lies and always returns i386. We have to use sysctl\n+    # Darwin's `uname -m` lies and always returns i386. We have to use sysctl\n     # instead.\n     if sysctl hw.optional.x86_64 | grep -q ': 1'\n     then\n@@ -449,18 +450,28 @@ then\n fi\n \n RUST_URL=\"https://static.rust-lang.org/dist\"\n-RUST_PACKAGE_NAME=rust-nightly\n+case \"$CFG_CHANNEL\" in\n+    nightly)\n+        # add a date suffix if we want a particular nightly.\n+        if [ -n \"${CFG_DATE}\" ];\n+        then\n+            RUST_URL=\"${RUST_URL}/${CFG_DATE}\"\n+        fi\n+\n+        RUST_PACKAGE_NAME=rust-nightly\n+        ;;\n+    beta)\n+        RUST_PACKAGE_NAME=rust-1.0.0-beta\n+        ;;\n+    *)\n+        err \"Currently 'beta' and 'nightly' are the only supported channels\"\n+esac\n+\n RUST_PACKAGE_NAME_AND_TRIPLE=\"${RUST_PACKAGE_NAME}-${HOST_TRIPLE}\"\n RUST_TARBALL_NAME=\"${RUST_PACKAGE_NAME_AND_TRIPLE}.tar.gz\"\n RUST_LOCAL_INSTALL_DIR=\"${CFG_TMP_DIR}/${RUST_PACKAGE_NAME_AND_TRIPLE}\"\n RUST_LOCAL_INSTALL_SCRIPT=\"${RUST_LOCAL_INSTALL_DIR}/install.sh\"\n \n-# add a date suffix if we want a particular nighly.\n-if [ -n \"${CFG_DATE}\" ];\n-then\n-    RUST_URL=\"${RUST_URL}/${CFG_DATE}\"\n-fi\n-\n download_hash() {\n     msg \"Downloading ${remote_sha256}\"\n     remote_sha256=`\"${CFG_CURL}\" -f \"${remote_sha256}\"`"}, {"sha": "f87c450eda5edd69a29ae0a579c928eca2e22eb2", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -242,6 +242,41 @@ pub fn weak_count<T>(this: &Arc<T>) -> usize { this.inner().weak.load(SeqCst) -\n #[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Arc<T>) -> usize { this.inner().strong.load(SeqCst) }\n \n+\n+/// Try accessing a mutable reference to the contents behind an unique `Arc<T>`.\n+///\n+/// The access is granted only if this is the only reference to the object.\n+/// Otherwise, `None` is returned.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #![feature(alloc)]\n+/// extern crate alloc;\n+/// # fn main() {\n+/// use alloc::arc;\n+///\n+/// let mut four = arc::Arc::new(4);\n+///\n+/// arc::unique(&mut four).map(|num| *num = 5);\n+/// # }\n+/// ```\n+#[inline]\n+#[unstable(feature = \"alloc\")]\n+pub fn unique<T>(this: &mut Arc<T>) -> Option<&mut T> {\n+    if strong_count(this) == 1 && weak_count(this) == 0 {\n+        // This unsafety is ok because we're guaranteed that the pointer\n+        // returned is the *only* pointer that will ever be returned to T. Our\n+        // reference count is guaranteed to be 1 at this point, and we required\n+        // the Arc itself to be `mut`, so we're returning the only possible\n+        // reference to the inner data.\n+        let inner = unsafe { &mut **this._ptr };\n+        Some(&mut inner.data)\n+    }else {\n+        None\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Arc<T> {\n     /// Makes a clone of the `Arc<T>`.\n@@ -312,11 +347,8 @@ impl<T: Send + Sync + Clone> Arc<T> {\n            self.inner().weak.load(SeqCst) != 1 {\n             *self = Arc::new((**self).clone())\n         }\n-        // This unsafety is ok because we're guaranteed that the pointer\n-        // returned is the *only* pointer that will ever be returned to T. Our\n-        // reference count is guaranteed to be 1 at this point, and we required\n-        // the Arc itself to be `mut`, so we're returning the only possible\n-        // reference to the inner data.\n+        // As with `unique()`, the unsafety is ok because our reference was\n+        // either unique to begin with, or became one upon cloning the contents.\n         let inner = unsafe { &mut **self._ptr };\n         &mut inner.data\n     }\n@@ -659,7 +691,7 @@ mod tests {\n     use std::sync::atomic::Ordering::{Acquire, SeqCst};\n     use std::thread;\n     use std::vec::Vec;\n-    use super::{Arc, Weak, weak_count, strong_count};\n+    use super::{Arc, Weak, weak_count, strong_count, unique};\n     use std::sync::Mutex;\n \n     struct Canary(*mut atomic::AtomicUsize);\n@@ -695,6 +727,21 @@ mod tests {\n         assert_eq!((*arc_v)[4], 5);\n     }\n \n+    #[test]\n+    fn test_arc_unique() {\n+        let mut x = Arc::new(10);\n+        assert!(unique(&mut x).is_some());\n+        {\n+            let y = x.clone();\n+            assert!(unique(&mut x).is_none());\n+        }\n+        {\n+            let z = x.downgrade();\n+            assert!(unique(&mut x).is_none());\n+        }\n+        assert!(unique(&mut x).is_some());\n+    }\n+\n     #[test]\n     fn test_cowarc_clone_make_unique() {\n         let mut cow0 = Arc::new(75);"}, {"sha": "2801cf38cb75529d94912551a60a5eab51597235", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 65, "deletions": 49, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -51,15 +51,12 @@ use core::prelude::*;\n use core::any::Any;\n use core::cmp::Ordering;\n use core::default::Default;\n-use core::error::Error;\n use core::fmt;\n use core::hash::{self, Hash};\n use core::mem;\n use core::ops::{Deref, DerefMut};\n-use core::ptr::{self, Unique};\n-use core::raw::{TraitObject, Slice};\n-\n-use heap;\n+use core::ptr::{Unique};\n+use core::raw::{TraitObject};\n \n /// A value that represents the heap. This is the default place that the `box`\n /// keyword allocates into when no place is supplied.\n@@ -86,6 +83,7 @@ pub static HEAP: () = ();\n /// See the [module-level documentation](../../std/boxed/index.html) for more.\n #[lang = \"owned_box\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[fundamental]\n pub struct Box<T>(Unique<T>);\n \n impl<T> Box<T> {\n@@ -277,13 +275,6 @@ impl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Debug for Box<Any> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.pad(\"Box<Any>\")\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Box<T> {\n     type Target = T;\n@@ -309,49 +300,74 @@ impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, E: Error + 'a> From<E> for Box<Error + 'a> {\n-    fn from(err: E) -> Box<Error + 'a> {\n-        Box::new(err)\n+\n+/// `FnBox` is a version of the `FnOnce` intended for use with boxed\n+/// closure objects. The idea is that where one would normally store a\n+/// `Box<FnOnce()>` in a data structure, you should use\n+/// `Box<FnBox()>`. The two traits behave essentially the same, except\n+/// that a `FnBox` closure can only be called if it is boxed. (Note\n+/// that `FnBox` may be deprecated in the future if `Box<FnOnce()>`\n+/// closures become directly usable.)\n+///\n+/// ### Example\n+///\n+/// Here is a snippet of code which creates a hashmap full of boxed\n+/// once closures and then removes them one by one, calling each\n+/// closure as it is removed. Note that the type of the closures\n+/// stored in the map is `Box<FnBox() -> i32>` and not `Box<FnOnce()\n+/// -> i32>`.\n+///\n+/// ```\n+/// #![feature(core)]\n+///\n+/// use std::boxed::FnBox;\n+/// use std::collections::HashMap;\n+///\n+/// fn make_map() -> HashMap<i32, Box<FnBox() -> i32>> {\n+///     let mut map: HashMap<i32, Box<FnBox() -> i32>> = HashMap::new();\n+///     map.insert(1, Box::new(|| 22));\n+///     map.insert(2, Box::new(|| 44));\n+///     map\n+/// }\n+///\n+/// fn main() {\n+///     let mut map = make_map();\n+///     for i in &[1, 2] {\n+///         let f = map.remove(&i).unwrap();\n+///         assert_eq!(f(), i * 22);\n+///     }\n+/// }\n+/// ```\n+#[rustc_paren_sugar]\n+#[unstable(feature = \"core\", reason = \"Newly introduced\")]\n+pub trait FnBox<A> {\n+    type Output;\n+\n+    fn call_box(self: Box<Self>, args: A) -> Self::Output;\n+}\n+\n+impl<A,F> FnBox<A> for F\n+    where F: FnOnce<A>\n+{\n+    type Output = F::Output;\n+\n+    fn call_box(self: Box<F>, args: A) -> F::Output {\n+        self.call_once(args)\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, E: Error + Send + 'a> From<E> for Box<Error + Send + 'a> {\n-    fn from(err: E) -> Box<Error + Send + 'a> {\n-        Box::new(err)\n+impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+'a> {\n+    type Output = R;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> R {\n+        self.call_box(args)\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b> From<&'b str> for Box<Error + Send + 'a> {\n-    fn from(err: &'b str) -> Box<Error + Send + 'a> {\n-        #[derive(Debug)]\n-        struct StringError(Box<str>);\n-        impl Error for StringError {\n-            fn description(&self) -> &str { &self.0 }\n-        }\n-        impl fmt::Display for StringError {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                self.0.fmt(f)\n-            }\n-        }\n+impl<'a,A,R> FnOnce<A> for Box<FnBox<A,Output=R>+Send+'a> {\n+    type Output = R;\n \n-        // Unfortunately `String` is located in libcollections, so we construct\n-        // a `Box<str>` manually here.\n-        unsafe {\n-            let alloc = if err.len() == 0 {\n-                0 as *mut u8\n-            } else {\n-                let ptr = heap::allocate(err.len(), 1);\n-                if ptr.is_null() { ::oom(); }\n-                ptr as *mut u8\n-            };\n-            ptr::copy(err.as_bytes().as_ptr(), alloc, err.len());\n-            Box::new(StringError(mem::transmute(Slice {\n-                data: alloc,\n-                len: err.len(),\n-            })))\n-        }\n+    extern \"rust-call\" fn call_once(self, args: A) -> R {\n+        self.call_box(args)\n     }\n }"}, {"sha": "fc44ac4eac628b2eba405276caedb542f5d49bff", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -55,17 +55,17 @@ fn test_show() {\n     let b = Box::new(Test) as Box<Any>;\n     let a_str = format!(\"{:?}\", a);\n     let b_str = format!(\"{:?}\", b);\n-    assert_eq!(a_str, \"Box<Any>\");\n-    assert_eq!(b_str, \"Box<Any>\");\n+    assert_eq!(a_str, \"Any\");\n+    assert_eq!(b_str, \"Any\");\n \n     static EIGHT: usize = 8;\n     static TEST: Test = Test;\n     let a = &EIGHT as &Any;\n     let b = &TEST as &Any;\n     let s = format!(\"{:?}\", a);\n-    assert_eq!(s, \"&Any\");\n+    assert_eq!(s, \"Any\");\n     let s = format!(\"{:?}\", b);\n-    assert_eq!(s, \"&Any\");\n+    assert_eq!(s, \"Any\");\n }\n \n #[test]"}, {"sha": "a8be63d637359beff197d7947b43a037023d8b15", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -71,6 +71,8 @@\n #![feature(no_std)]\n #![no_std]\n #![feature(allocator)]\n+#![feature(custom_attribute)]\n+#![feature(fundamental)]\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]"}, {"sha": "d35173cbebf4cfd3d48b9d9c278ebb218058afa3", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -328,17 +328,20 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// `pred`, limited to returning at most `n` items.  The matched element is\n     /// not contained in the subslices.\n     ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n     /// # Examples\n     ///\n     /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n     /// `[20, 60, 50]`):\n     ///\n     /// ```\n     /// let v = [10, 40, 30, 20, 60, 50];\n-    /// for group in v.splitn(1, |num| *num % 3 == 0) {\n+    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n     ///     println!(\"{:?}\", group);\n     /// }\n     /// ```\n@@ -349,18 +352,21 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// `pred` limited to returning at most `n` items. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n     /// # Examples\n     ///\n     /// Print the slice split once, starting from the end, by numbers divisible\n     /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n     ///\n     /// ```\n     /// let v = [10, 40, 30, 20, 60, 50];\n-    /// for group in v.rsplitn(1, |num| *num % 3 == 0) {\n+    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n     ///     println!(\"{:?}\", group);\n     /// }\n     /// ```\n@@ -626,8 +632,11 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// `pred`, limited to returning at most `n` items.  The matched element is\n     /// not contained in the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n@@ -636,9 +645,12 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// `pred` limited to returning at most `n` items. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<T, F>"}, {"sha": "c22b6fb9286d192382c9dd8c7ec1f112677aaa6b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -610,24 +610,27 @@ impl str {\n         core_str::StrExt::split(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n-    /// restricted to splitting at most `count` times.\n+    /// An iterator over substrings of `self`, separated by characters matched\n+    /// by a pattern, returning most `count` items.\n     ///\n     /// The pattern can be a simple `&str`, or a closure that determines\n     /// the split.\n     ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// string.\n+    ///\n     /// # Examples\n     ///\n     /// Simple `&str` patterns:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    /// assert_eq!(v, [\"Mary\", \"had a little lambda\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    /// assert_eq!(v, [\"lion\", \"XtigerXleopard\"]);\n     ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n     /// assert_eq!(v, [\"abcXdef\"]);\n     ///\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n@@ -637,7 +640,7 @@ impl str {\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(2, |c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, [\"abc\", \"def2ghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -705,25 +708,28 @@ impl str {\n     }\n \n     /// An iterator over substrings of `self`, separated by a pattern,\n-    /// starting from the end of the string, restricted to splitting\n-    /// at most `count` times.\n+    /// starting from the end of the string, restricted to returning\n+    /// at most `count` items.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// string.\n     ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n     /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(1, \"::\").collect();\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n     /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(2, |c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "7a7725320914f6fdba19cb1443d0d1e9c2da753b", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -17,7 +17,6 @@\n use core::prelude::*;\n \n use core::default::Default;\n-use core::error::Error;\n use core::fmt;\n use core::hash;\n use core::iter::{IntoIterator, FromIterator};\n@@ -723,23 +722,13 @@ impl fmt::Display for FromUtf8Error {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for FromUtf8Error {\n-    fn description(&self) -> &str { \"invalid utf-8\" }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for FromUtf16Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(\"invalid utf-16: lone surrogate found\", f)\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for FromUtf16Error {\n-    fn description(&self) -> &str { \"invalid utf-16\" }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromIterator<char> for String {\n     fn from_iter<I: IntoIterator<Item=char>>(iter: I) -> String {"}, {"sha": "9dc12aa5bd9b4956e5e076047fcc596de144245e", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -867,37 +867,37 @@ fn test_splitnator() {\n     let xs = &[1,2,3,4,5];\n \n     let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-    assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&[_]] = &[&[1], &[3,4,5]];\n-    assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn(2, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&[_]] = &[&[], &[], &[], &[4,5]];\n-    assert_eq!(xs.splitn(3, |_| true).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn(4, |_| true).collect::<Vec<_>>(),\n                splits);\n \n     let xs: &[i32] = &[];\n     let splits: &[&[i32]] = &[&[]];\n-    assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<_>>(), splits);\n+    assert_eq!(xs.splitn(2, |x| *x == 5).collect::<Vec<_>>(), splits);\n }\n \n #[test]\n fn test_splitnator_mut() {\n     let xs = &mut [1,2,3,4,5];\n \n     let splits: &[&mut[_]] = &[&mut [1,2,3,4,5]];\n-    assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&mut[_]] = &[&mut [1], &mut [3,4,5]];\n-    assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn_mut(2, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&mut[_]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n-    assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn_mut(4, |_| true).collect::<Vec<_>>(),\n                splits);\n \n     let xs: &mut [i32] = &mut [];\n     let splits: &[&mut[i32]] = &[&mut []];\n-    assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn_mut(2, |x| *x == 5).collect::<Vec<_>>(),\n                splits);\n }\n \n@@ -928,18 +928,19 @@ fn test_rsplitnator() {\n     let xs = &[1,2,3,4,5];\n \n     let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-    assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&[_]] = &[&[5], &[1,2,3]];\n-    assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.rsplitn(2, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&[_]] = &[&[], &[], &[], &[1,2]];\n-    assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<_>>(),\n+    assert_eq!(xs.rsplitn(4, |_| true).collect::<Vec<_>>(),\n                splits);\n \n     let xs: &[i32]  = &[];\n     let splits: &[&[i32]] = &[&[]];\n-    assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n+    assert_eq!(xs.rsplitn(2, |x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n+    assert!(xs.rsplitn(0, |x| *x % 2 == 0).next().is_none());\n }\n \n #[test]"}, {"sha": "495a961fa360e2564bb72cbf7a8d91e717c4f20e", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -885,17 +885,17 @@ fn test_char_indices_revator() {\n fn test_splitn_char_iterator() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-    let split: Vec<&str> = data.splitn(3, ' ').collect();\n+    let split: Vec<&str> = data.splitn(4, ' ').collect();\n     assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-    let split: Vec<&str> = data.splitn(3, |c: char| c == ' ').collect();\n+    let split: Vec<&str> = data.splitn(4, |c: char| c == ' ').collect();\n     assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n     // Unicode\n-    let split: Vec<&str> = data.splitn(3, '\u00e4').collect();\n+    let split: Vec<&str> = data.splitn(4, '\u00e4').collect();\n     assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-    let split: Vec<&str> = data.splitn(3, |c: char| c == '\u00e4').collect();\n+    let split: Vec<&str> = data.splitn(4, |c: char| c == '\u00e4').collect();\n     assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n }\n \n@@ -928,13 +928,13 @@ fn test_rsplit() {\n fn test_rsplitn() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-    let split: Vec<&str> = data.rsplitn(1, ' ').collect();\n+    let split: Vec<&str> = data.rsplitn(2, ' ').collect();\n     assert_eq!(split, [\"l\u00e4mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle\"]);\n \n-    let split: Vec<&str> = data.rsplitn(1, \"l\u00e4mb\").collect();\n+    let split: Vec<&str> = data.rsplitn(2, \"l\u00e4mb\").collect();\n     assert_eq!(split, [\"\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle \"]);\n \n-    let split: Vec<&str> = data.rsplitn(1, |c: char| c == '\u00e4').collect();\n+    let split: Vec<&str> = data.rsplitn(2, |c: char| c == '\u00e4').collect();\n     assert_eq!(split, [\"mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\"]);\n }\n "}, {"sha": "320fdd50b3510bd41df790ca167bb72857839f85", "filename": "src/libcore/any.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -71,6 +71,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use fmt;\n use marker::Send;\n use mem::transmute;\n use option::Option::{self, Some, None};\n@@ -105,6 +106,13 @@ impl<T> Any for T\n // Extension methods for Any trait objects.\n ///////////////////////////////////////////////////////////////////////////////\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Any {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.pad(\"Any\")\n+    }\n+}\n+\n impl Any {\n     /// Returns true if the boxed type is the same as `T`\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "24035b7d9a83bdc8ff23a6c687ee58de29461a90", "filename": "src/libcore/error.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d528aa9960cb9b937d8ef6c09905a6a8076d5f3a/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=d528aa9960cb9b937d8ef6c09905a6a8076d5f3a", "patch": "@@ -1,56 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Traits for working with Errors.\n-//!\n-//! # The `Error` trait\n-//!\n-//! `Error` is a trait representing the basic expectations for error values,\n-//! i.e. values of type `E` in `Result<T, E>`. At a minimum, errors must provide\n-//! a description, but they may optionally provide additional detail (via\n-//! `Display`) and cause chain information:\n-//!\n-//! ```\n-//! use std::fmt::Display;\n-//!\n-//! trait Error: Display {\n-//!     fn description(&self) -> &str;\n-//!\n-//!     fn cause(&self) -> Option<&Error> { None }\n-//! }\n-//! ```\n-//!\n-//! The `cause` method is generally used when errors cross \"abstraction\n-//! boundaries\", i.e.  when a one module must report an error that is \"caused\"\n-//! by an error from a lower-level module. This setup makes it possible for the\n-//! high-level module to provide its own errors that do not commit to any\n-//! particular implementation, but also reveal some of its implementation for\n-//! debugging via `cause` chains.\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-use prelude::*;\n-use fmt::{Debug, Display};\n-\n-/// Base functionality for all errors in Rust.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait Error: Debug + Display {\n-    /// A short description of the error.\n-    ///\n-    /// The description should not contain newlines or sentence-ending\n-    /// punctuation, to facilitate embedding in larger user-facing\n-    /// strings.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn description(&self) -> &str;\n-\n-    /// The lower-level cause of this error, if any.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn cause(&self) -> Option<&Error> { None }\n-}"}, {"sha": "3f8bbeb1feb88eb35126a9f16b3efd061141d240", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -12,7 +12,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use any;\n use cell::{Cell, RefCell, Ref, RefMut, BorrowState};\n use char::CharExt;\n use iter::Iterator;\n@@ -997,11 +996,6 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Debug for &'a (any::Any+'a) {\n-    fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {"}, {"sha": "42e90ec34db7ce97853ff8a734997604d7f439f4", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -45,10 +45,8 @@\n //! let mut it = values.into_iter();\n //! loop {\n //!     match it.next() {\n-//!         Some(x) => {\n-//!             println!(\"{}\", x);\n-//!         }\n-//!         None => { break }\n+//!         Some(x) => println!(\"{}\", x),\n+//!         None => break,\n //!     }\n //! }\n //! ```"}, {"sha": "2189e2c3ad1baca6a42e615d71f4b3c26190f865", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -70,8 +70,10 @@\n #![feature(unboxed_closures)]\n #![feature(rustc_attrs)]\n #![feature(optin_builtin_traits)]\n+#![feature(fundamental)]\n #![feature(concat_idents)]\n #![feature(reflect)]\n+#![feature(custom_attribute)]\n \n #[macro_use]\n mod macros;\n@@ -145,7 +147,6 @@ pub mod slice;\n pub mod str;\n pub mod hash;\n pub mod fmt;\n-pub mod error;\n \n #[doc(primitive = \"bool\")]\n mod bool {"}, {"sha": "d1d9c3899427b04e21d29e8dd4f53372dc0ee87b", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -49,6 +49,7 @@ impl !Send for Managed { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang=\"sized\"]\n #[rustc_on_unimplemented = \"`{Self}` does not have a constant size known at compile-time\"]\n+#[fundamental] // for Default, for example, which requires that `[T]: !Default` be evaluatable\n pub trait Sized : MarkerTrait {\n     // Empty.\n }\n@@ -346,17 +347,16 @@ impl<T:?Sized> MarkerTrait for T { }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n \n-/// `PhantomData` is a way to tell the compiler about fake fields.\n-/// Phantom data is required whenever type parameters are not used.\n-/// The idea is that if the compiler encounters a `PhantomData<T>`\n-/// instance, it will behave *as if* an instance of the type `T` were\n-/// present for the purpose of various automatic analyses.\n+/// `PhantomData<T>` allows you to describe that a type acts as if it stores a value of type `T`,\n+/// even though it does not. This allows you to inform the compiler about certain safety properties\n+/// of your code.\n+///\n+/// Though they both have scary names, `PhantomData<T>` and \"phantom types\" are unrelated. \ud83d\udc7b\ud83d\udc7b\ud83d\udc7b\n ///\n /// # Examples\n ///\n /// When handling external resources over a foreign function interface, `PhantomData<T>` can\n-/// prevent mismatches by enforcing types in the method implementations, although the struct\n-/// doesn't actually contain values of the resource type.\n+/// prevent mismatches by enforcing types in the method implementations:\n ///\n /// ```\n /// # trait ResType { fn foo(&self); };\n@@ -397,11 +397,6 @@ pub trait PhantomFn<A:?Sized,R:?Sized=()> { }\n /// commonly necessary if the structure is using an unsafe pointer\n /// like `*mut T` whose referent may be dropped when the type is\n /// dropped, as a `*mut T` is otherwise not treated as owned.\n-///\n-/// FIXME. Better documentation and examples of common patterns needed\n-/// here! For now, please see [RFC 738][738] for more information.\n-///\n-/// [738]: https://github.com/rust-lang/rfcs/blob/master/text/0738-variance.md\n #[lang=\"phantom_data\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PhantomData<T:?Sized>;"}, {"sha": "4e458e993a0ce662b6f489b05428d1fb28404a62", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -20,7 +20,6 @@ use self::wrapping::{OverflowingOps, WrappingOps};\n use char::CharExt;\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord};\n-use error::Error;\n use fmt;\n use intrinsics;\n use iter::Iterator;\n@@ -820,6 +819,18 @@ macro_rules! int_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n+        /// Returns the smallest value that can be represented by this integer type.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub fn min_value() -> $T {\n+            (-1 as $T) << ($BITS - 1)\n+        }\n+\n+        /// Returns the largest value that can be represented by this integer type.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub fn max_value() -> $T {\n+            let min: $T = Int::min_value(); !min\n+        }\n+\n         /// Convert a string slice in a given base to an integer.\n         ///\n         /// Leading and trailing whitespace represent an error.\n@@ -1330,6 +1341,14 @@ macro_rules! uint_impl {\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n+        /// Returns the smallest value that can be represented by this integer type.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub fn min_value() -> $T { 0 }\n+\n+        /// Returns the largest value that can be represented by this integer type.\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        pub fn max_value() -> $T { -1 }\n+\n         /// Convert a string slice in a given base to an integer.\n         ///\n         /// Leading and trailing whitespace represent an error.\n@@ -2948,16 +2967,9 @@ enum IntErrorKind {\n     Underflow,\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for ParseIntError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.description().fmt(f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for ParseIntError {\n-    fn description(&self) -> &str {\n+impl ParseIntError {\n+    #[unstable(feature = \"core\", reason = \"available through Error trait\")]\n+    pub fn description(&self) -> &str {\n         match self.kind {\n             IntErrorKind::Empty => \"cannot parse integer from empty string\",\n             IntErrorKind::InvalidDigit => \"invalid digit found in string\",\n@@ -2967,6 +2979,13 @@ impl Error for ParseIntError {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseIntError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}\n+\n /// An error which can be returned when parsing a float.\n #[derive(Debug, Clone, PartialEq)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2978,19 +2997,19 @@ enum FloatErrorKind {\n     Invalid,\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl fmt::Display for ParseFloatError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.description().fmt(f)\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for ParseFloatError {\n-    fn description(&self) -> &str {\n+impl ParseFloatError {\n+    #[unstable(feature = \"core\", reason = \"available through Error trait\")]\n+    pub fn description(&self) -> &str {\n         match self.kind {\n             FloatErrorKind::Empty => \"cannot parse float from empty string\",\n             FloatErrorKind::Invalid => \"invalid float literal\",\n         }\n     }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Display for ParseFloatError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.description().fmt(f)\n+    }\n+}"}, {"sha": "21af342b1bf788ca448a08e8eecc50905ed4342b", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -1117,6 +1117,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[lang=\"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait Fn<Args> : FnMut<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n@@ -1126,6 +1127,7 @@ pub trait Fn<Args> : FnMut<Args> {\n #[lang=\"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait FnMut<Args> : FnOnce<Args> {\n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n@@ -1135,10 +1137,60 @@ pub trait FnMut<Args> : FnOnce<Args> {\n #[lang=\"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait FnOnce<Args> {\n     /// The returned type after the call operator is used.\n     type Output;\n \n     /// This is called when the call operator is used.\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n+\n+#[cfg(not(stage0))]\n+mod impls {\n+    use marker::Sized;\n+    use super::{Fn, FnMut, FnOnce};\n+\n+    impl<'a,A,F:?Sized> Fn<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        extern \"rust-call\" fn call(&self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    impl<'a,A,F:?Sized> FnMut<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (**self).call(args)\n+        }\n+    }\n+\n+    impl<'a,A,F:?Sized> FnOnce<A> for &'a F\n+        where F : Fn<A>\n+    {\n+        type Output = F::Output;\n+\n+        extern \"rust-call\" fn call_once(self, args: A) -> F::Output {\n+            (*self).call(args)\n+        }\n+    }\n+\n+    impl<'a,A,F:?Sized> FnMut<A> for &'a mut F\n+        where F : FnMut<A>\n+    {\n+        extern \"rust-call\" fn call_mut(&mut self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+\n+    impl<'a,A,F:?Sized> FnOnce<A> for &'a mut F\n+        where F : FnMut<A>\n+    {\n+        type Output = F::Output;\n+        extern \"rust-call\" fn call_once(mut self, args: A) -> F::Output {\n+            (*self).call_mut(args)\n+        }\n+    }\n+}"}, {"sha": "70e60adf64c2a3649b9d2256a7eadd8a46ff7346", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -1126,18 +1126,20 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        if self.count == 0 {\n-            self.iter.finish()\n-        } else {\n-            self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+        match self.count {\n+            0 => None,\n+            1 => { self.count -= 1; self.iter.finish() }\n+            _ => {\n+                self.count -= 1;\n+                if self.invert {self.iter.next_back()} else {self.iter.next()}\n+            }\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper_opt) = self.iter.size_hint();\n-        (lower, upper_opt.map(|upper| cmp::min(self.count + 1, upper)))\n+        (lower, upper_opt.map(|upper| cmp::min(self.count, upper)))\n     }\n }\n "}, {"sha": "f07c988c2b4eec29f8ba6683de8e88e9eca316bb", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -22,7 +22,6 @@ use char::CharExt;\n use clone::Clone;\n use cmp::{self, Eq};\n use default::Default;\n-use error::Error;\n use fmt;\n use iter::ExactSizeIterator;\n use iter::{Map, Iterator, DoubleEndedIterator};\n@@ -192,11 +191,6 @@ impl fmt::Display for ParseBoolError {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for ParseBoolError {\n-    fn description(&self) -> &str { \"failed to parse bool\" }\n-}\n-\n /*\n Section: Creating a string\n */\n@@ -241,16 +235,6 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n     mem::transmute(v)\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Error for Utf8Error {\n-    fn description(&self) -> &str {\n-        match *self {\n-            Utf8Error::TooShort => \"invalid utf-8: not enough bytes\",\n-            Utf8Error::InvalidByte(..) => \"invalid utf-8: corrupt contents\",\n-        }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Utf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -505,7 +489,7 @@ struct CharSplits<'a, P: Pattern<'a>> {\n /// splitting at most `count` times.\n struct CharSplitsN<'a, P: Pattern<'a>> {\n     iter: CharSplits<'a, P>,\n-    /// The number of splits remaining\n+    /// The number of items remaining\n     count: usize,\n }\n \n@@ -612,11 +596,10 @@ impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n-        if self.count != 0 {\n-            self.count -= 1;\n-            self.iter.next()\n-        } else {\n-            self.iter.get_end()\n+        match self.count {\n+            0 => None,\n+            1 => { self.count = 0; self.iter.get_end() }\n+            _ => { self.count -= 1; self.iter.next() }\n         }\n     }\n }\n@@ -666,11 +649,10 @@ impl<'a, P: Pattern<'a>> Iterator for RCharSplitsN<'a, P>\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n-        if self.count != 0 {\n-            self.count -= 1;\n-            self.iter.next()\n-        } else {\n-            self.iter.get_remainder()\n+        match self.count {\n+            0 => None,\n+            1 => { self.count -= 1; self.iter.get_remainder() }\n+            _ => { self.count -= 1; self.iter.next() }\n         }\n     }\n }"}, {"sha": "5fce527d9798df979a3183c2d3a433f191d05234", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -65,20 +65,20 @@ fn test_strslice_contains() {\n fn test_rsplitn_char_iterator() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-    let mut split: Vec<&str> = data.rsplitn(3, ' ').collect();\n+    let mut split: Vec<&str> = data.rsplitn(4, ' ').collect();\n     split.reverse();\n     assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-    let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == ' ').collect();\n+    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == ' ').collect();\n     split.reverse();\n     assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     // Unicode\n-    let mut split: Vec<&str> = data.rsplitn(3, '\u00e4').collect();\n+    let mut split: Vec<&str> = data.rsplitn(4, '\u00e4').collect();\n     split.reverse();\n     assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-    let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == '\u00e4').collect();\n+    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == '\u00e4').collect();\n     split.reverse();\n     assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n }"}, {"sha": "a4bb17bc354769d18a2253b7b9a0eb19421aa0f5", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -120,6 +120,8 @@ pub mod middle {\n     pub mod traits;\n     pub mod ty;\n     pub mod ty_fold;\n+    pub mod ty_match;\n+    pub mod ty_relate;\n     pub mod ty_walk;\n     pub mod weak_lang_items;\n }"}, {"sha": "862ced78c082c5056322e6ec8db9e6f4c2777e9f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -34,8 +34,7 @@ use std::io::prelude::*;\n use std::io::{Cursor, SeekFrom};\n use syntax::abi;\n use syntax::ast::{self, DefId, NodeId};\n-use syntax::ast_map::{PathElem, PathElems};\n-use syntax::ast_map;\n+use syntax::ast_map::{self, LinkedPath, PathElem, PathElems};\n use syntax::ast_util::*;\n use syntax::ast_util;\n use syntax::attr;\n@@ -1513,7 +1512,7 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                         &krate.module,\n                         &[],\n                         ast::CRATE_NODE_ID,\n-                        [].iter().cloned().chain(None),\n+                        [].iter().cloned().chain(LinkedPath::empty()),\n                         syntax::parse::token::special_idents::invalid,\n                         ast::Public);\n \n@@ -1874,7 +1873,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n     }\n \n     // Encode reexports for the root module.\n-    encode_reexports(ecx, rbml_w, 0, [].iter().cloned().chain(None));\n+    encode_reexports(ecx, rbml_w, 0, [].iter().cloned().chain(LinkedPath::empty()));\n \n     rbml_w.end_tag();\n     rbml_w.end_tag();"}, {"sha": "7e436d95192f5da4b12c9965d3513cac86e5872e", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             pprust::NodeIdent(_) | pprust::NodeName(_) => 0,\n             pprust::NodeExpr(expr) => expr.id,\n             pprust::NodeBlock(blk) => blk.id,\n-            pprust::NodeItem(_) => 0,\n+            pprust::NodeItem(_) | pprust::NodeSubItem(_) => 0,\n             pprust::NodePat(pat) => pat.id\n         };\n "}, {"sha": "c60bb229be142aba8a94353ea6dac1ce6efde82c", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -65,7 +65,7 @@ pub enum Def {\n ///     <T as Trait>::AssocX::AssocY::MethodOrAssocType\n ///           ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~\n ///           base_def        depth = 2\n-#[derive(Copy, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub struct PathResolution {\n     pub base_def: Def,\n     pub last_private: LastPrivate,\n@@ -85,6 +85,17 @@ impl PathResolution {\n     pub fn def_id(&self) -> ast::DefId {\n         self.full_def().def_id()\n     }\n+\n+    pub fn new(base_def: Def,\n+               last_private: LastPrivate,\n+               depth: usize)\n+               -> PathResolution {\n+        PathResolution {\n+            base_def: base_def,\n+            last_private: last_private,\n+            depth: depth,\n+        }\n+    }\n }\n \n // Definition mapping"}, {"sha": "940dc75271c22f0a33d1585ab2af2a0eee1aede9", "filename": "src/librustc/middle/infer/bivariate.rs", "status": "modified", "additions": 43, "deletions": 50, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fbivariate.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -25,66 +25,54 @@\n //! In particular, it might be enough to say (A,B) are bivariant for\n //! all (A,B).\n \n-use middle::ty::BuiltinBounds;\n+use super::combine::{self, CombineFields};\n+use super::type_variable::{BiTo};\n+\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::infer::combine::*;\n-use middle::infer::cres;\n-use middle::infer::type_variable::BiTo;\n-use util::ppaux::Repr;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use util::ppaux::{Repr};\n \n-pub struct Bivariate<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Bivariate<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Bivariate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Bivariate<'f, 'tcx> {\n-    Bivariate { fields: cf }\n+impl<'a, 'tcx> Bivariate<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Bivariate<'a, 'tcx> {\n+        Bivariate { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Bivariate<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Bivariate\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Bivariate<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Bivariate\" }\n \n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Contravariant => self.tys(a, b),\n-            ty::Bivariant => self.tys(a, b),\n-        }\n-    }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Contravariant => self.regions(a, b),\n-            ty::Bivariant => self.regions(a, b),\n-        }\n-    }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn regions(&self, a: ty::Region, _: ty::Region) -> cres<'tcx, ty::Region> {\n-        Ok(a)\n-    }\n-\n-    fn builtin_bounds(&self,\n-                      a: BuiltinBounds,\n-                      b: BuiltinBounds)\n-                      -> cres<'tcx, BuiltinBounds>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        if a != b {\n-            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n+        match variance {\n+            // If we have Foo<A> and Foo is invariant w/r/t A,\n+            // and we want to assert that\n+            //\n+            //     Foo<A> <: Foo<B> ||\n+            //     Foo<B> <: Foo<A>\n+            //\n+            // then still A must equal B.\n+            ty::Invariant => self.relate(a, b),\n+\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.relate(a, b),\n+            ty::Contravariant => self.relate(a, b),\n         }\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n@@ -109,17 +97,22 @@ impl<'f, 'tcx> Combine<'tcx> for Bivariate<'f, 'tcx> {\n             }\n \n             _ => {\n-                super_tys(self, a, b)\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)\n             }\n         }\n     }\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn regions(&mut self, a: ty::Region, _: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n         let a1 = ty::erase_late_bound_regions(self.tcx(), a);\n         let b1 = ty::erase_late_bound_regions(self.tcx(), b);\n-        let c = try!(Combineable::combine(self, &a1, &b1));\n+        let c = try!(self.relate(&a1, &b1));\n         Ok(ty::Binder(c))\n     }\n }"}, {"sha": "86f12b669b35ebe42f714835d26cb2c5cb7a74dd", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 131, "deletions": 575, "changes": 706, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -37,630 +37,155 @@ use super::equate::Equate;\n use super::glb::Glb;\n use super::lub::Lub;\n use super::sub::Sub;\n-use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n-use super::{InferCtxt, cres};\n+use super::{InferCtxt};\n use super::{MiscVariable, TypeTrace};\n use super::type_variable::{RelationDir, BiTo, EqTo, SubtypeOf, SupertypeOf};\n \n-use middle::subst;\n-use middle::subst::{ErasedRegions, NonerasedRegions, Substs};\n-use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n+use middle::ty::{TyVar};\n use middle::ty::{IntType, UintType};\n-use middle::ty::BuiltinBounds;\n use middle::ty::{self, Ty};\n use middle::ty_fold;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty_relate::{self, Relate, RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n-use std::rc::Rc;\n-use syntax::ast::Unsafety;\n use syntax::ast;\n-use syntax::abi;\n use syntax::codemap::Span;\n \n-pub trait Combine<'tcx> : Sized {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n-    fn tag(&self) -> String;\n-\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx>;\n-\n-    fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx> { self.fields().infcx }\n-    fn a_is_expected(&self) -> bool { self.fields().a_is_expected }\n-    fn trace(&self) -> TypeTrace<'tcx> { self.fields().trace.clone() }\n-    fn equate<'a>(&'a self) -> Equate<'a, 'tcx> { self.fields().equate() }\n-    fn bivariate<'a>(&'a self) -> Bivariate<'a, 'tcx> { self.fields().bivariate() }\n-\n-    fn sub<'a>(&'a self) -> Sub<'a, 'tcx> { self.fields().sub() }\n-    fn lub<'a>(&'a self) -> Lub<'a, 'tcx> { Lub(self.fields().clone()) }\n-    fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields().clone()) }\n-\n-    fn mts(&self, a: &ty::mt<'tcx>, b: &ty::mt<'tcx>) -> cres<'tcx, ty::mt<'tcx>> {\n-        debug!(\"{}.mts({}, {})\",\n-               self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n-\n-        if a.mutbl != b.mutbl {\n-            Err(ty::terr_mutability)\n-        } else {\n-            let mutbl = a.mutbl;\n-            let variance = match mutbl {\n-                ast::MutImmutable => ty::Covariant,\n-                ast::MutMutable => ty::Invariant,\n-            };\n-            let ty = try!(self.tys_with_variance(variance, a.ty, b.ty));\n-            Ok(ty::mt {ty: ty, mutbl: mutbl})\n-        }\n-    }\n-\n-    fn tys_with_variance(&self, variance: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>;\n-\n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>>;\n-\n-    fn regions_with_variance(&self, variance: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>;\n-\n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n-\n-    fn substs(&self,\n-              item_def_id: ast::DefId,\n-              a_subst: &subst::Substs<'tcx>,\n-              b_subst: &subst::Substs<'tcx>)\n-              -> cres<'tcx, subst::Substs<'tcx>>\n-    {\n-        debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n-               item_def_id.repr(self.infcx().tcx),\n-               a_subst.repr(self.infcx().tcx),\n-               b_subst.repr(self.infcx().tcx));\n-\n-        let variances = if self.infcx().tcx.variance_computed.get() {\n-            Some(ty::item_variances(self.infcx().tcx, item_def_id))\n-        } else {\n-            None\n-        };\n-        self.substs_variances(variances.as_ref().map(|v| &**v), a_subst, b_subst)\n-    }\n-\n-    fn substs_variances(&self,\n-                        variances: Option<&ty::ItemVariances>,\n-                        a_subst: &subst::Substs<'tcx>,\n-                        b_subst: &subst::Substs<'tcx>)\n-                        -> cres<'tcx, subst::Substs<'tcx>>\n-    {\n-        let mut substs = subst::Substs::empty();\n-\n-        for &space in &subst::ParamSpace::all() {\n-            let a_tps = a_subst.types.get_slice(space);\n-            let b_tps = b_subst.types.get_slice(space);\n-            let t_variances = variances.map(|v| v.types.get_slice(space));\n-            let tps = try!(relate_type_params(self, t_variances, a_tps, b_tps));\n-            substs.types.replace(space, tps);\n-        }\n-\n-        match (&a_subst.regions, &b_subst.regions) {\n-            (&ErasedRegions, _) | (_, &ErasedRegions) => {\n-                substs.regions = ErasedRegions;\n-            }\n-\n-            (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n-                for &space in &subst::ParamSpace::all() {\n-                    let a_regions = a.get_slice(space);\n-                    let b_regions = b.get_slice(space);\n-                    let r_variances = variances.map(|v| v.regions.get_slice(space));\n-                    let regions = try!(relate_region_params(self,\n-                                                            r_variances,\n-                                                            a_regions,\n-                                                            b_regions));\n-                    substs.mut_regions().replace(space, regions);\n-                }\n-            }\n-        }\n-\n-        return Ok(substs);\n-\n-        fn relate_type_params<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                      variances: Option<&[ty::Variance]>,\n-                                                      a_tys: &[Ty<'tcx>],\n-                                                      b_tys: &[Ty<'tcx>])\n-                                                      -> cres<'tcx, Vec<Ty<'tcx>>>\n-        {\n-            if a_tys.len() != b_tys.len() {\n-                return Err(ty::terr_ty_param_size(expected_found(this,\n-                                                                 a_tys.len(),\n-                                                                 b_tys.len())));\n-            }\n-\n-            (0.. a_tys.len()).map(|i| {\n-                let a_ty = a_tys[i];\n-                let b_ty = b_tys[i];\n-                let v = variances.map_or(ty::Invariant, |v| v[i]);\n-                this.tys_with_variance(v, a_ty, b_ty)\n-            }).collect()\n-        }\n-\n-        fn relate_region_params<'tcx, C: Combine<'tcx>>(this: &C,\n-                                                        variances: Option<&[ty::Variance]>,\n-                                                        a_rs: &[ty::Region],\n-                                                        b_rs: &[ty::Region])\n-                                                        -> cres<'tcx, Vec<ty::Region>>\n-        {\n-            let tcx = this.infcx().tcx;\n-            let num_region_params = a_rs.len();\n-\n-            debug!(\"relate_region_params(\\\n-                   a_rs={}, \\\n-                   b_rs={},\n-                   variances={})\",\n-                   a_rs.repr(tcx),\n-                   b_rs.repr(tcx),\n-                   variances.repr(tcx));\n-\n-            assert_eq!(num_region_params,\n-                       variances.map_or(num_region_params,\n-                                        |v| v.len()));\n-\n-            assert_eq!(num_region_params, b_rs.len());\n-\n-            (0..a_rs.len()).map(|i| {\n-                let a_r = a_rs[i];\n-                let b_r = b_rs[i];\n-                let variance = variances.map_or(ty::Invariant, |v| v[i]);\n-                this.regions_with_variance(variance, a_r, b_r)\n-            }).collect()\n-        }\n-    }\n-\n-    fn bare_fn_tys(&self, a: &ty::BareFnTy<'tcx>,\n-                   b: &ty::BareFnTy<'tcx>) -> cres<'tcx, ty::BareFnTy<'tcx>> {\n-        let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n-        let abi = try!(self.abi(a.abi, b.abi));\n-        let sig = try!(self.binders(&a.sig, &b.sig));\n-        Ok(ty::BareFnTy {unsafety: unsafety,\n-                         abi: abi,\n-                         sig: sig})\n-    }\n-\n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>> {\n-        if a.variadic != b.variadic {\n-            return Err(ty::terr_variadic_mismatch(expected_found(self, a.variadic, b.variadic)));\n-        }\n-\n-        let inputs = try!(argvecs(self,\n-                                  &a.inputs,\n-                                  &b.inputs));\n-\n-        let output = try!(match (a.output, b.output) {\n-            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n-                Ok(ty::FnConverging(try!(self.tys(a_ty, b_ty)))),\n-            (ty::FnDiverging, ty::FnDiverging) =>\n-                Ok(ty::FnDiverging),\n-            (a, b) =>\n-                Err(ty::terr_convergence_mismatch(\n-                    expected_found(self, a != ty::FnDiverging, b != ty::FnDiverging))),\n-        });\n-\n-        return Ok(ty::FnSig {inputs: inputs,\n-                             output: output,\n-                             variadic: a.variadic});\n-\n-\n-        fn argvecs<'tcx, C>(combiner: &C,\n-                            a_args: &[Ty<'tcx>],\n-                            b_args: &[Ty<'tcx>])\n-                            -> cres<'tcx, Vec<Ty<'tcx>>>\n-                            where C: Combine<'tcx> {\n-            if a_args.len() == b_args.len() {\n-                a_args.iter().zip(b_args.iter())\n-                    .map(|(a, b)| combiner.args(*a, *b)).collect()\n-            } else {\n-                Err(ty::terr_arg_count)\n-            }\n-        }\n-    }\n-\n-    fn args(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        self.tys_with_variance(ty::Contravariant, a, b).and_then(|t| Ok(t))\n-    }\n-\n-    fn unsafeties(&self, a: Unsafety, b: Unsafety) -> cres<'tcx, Unsafety> {\n-        if a != b {\n-            Err(ty::terr_unsafety_mismatch(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n-        }\n-    }\n-\n-    fn abi(&self, a: abi::Abi, b: abi::Abi) -> cres<'tcx, abi::Abi> {\n-        if a == b {\n-            Ok(a)\n-        } else {\n-            Err(ty::terr_abi_mismatch(expected_found(self, a, b)))\n-        }\n-    }\n-\n-    fn projection_tys(&self,\n-                      a: &ty::ProjectionTy<'tcx>,\n-                      b: &ty::ProjectionTy<'tcx>)\n-                      -> cres<'tcx, ty::ProjectionTy<'tcx>>\n-    {\n-        if a.item_name != b.item_name {\n-            Err(ty::terr_projection_name_mismatched(\n-                expected_found(self, a.item_name, b.item_name)))\n-        } else {\n-            let trait_ref = try!(self.trait_refs(&*a.trait_ref, &*b.trait_ref));\n-            Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n-        }\n-    }\n-\n-    fn projection_predicates(&self,\n-                             a: &ty::ProjectionPredicate<'tcx>,\n-                             b: &ty::ProjectionPredicate<'tcx>)\n-                             -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n-    {\n-        let projection_ty = try!(self.projection_tys(&a.projection_ty, &b.projection_ty));\n-        let ty = try!(self.tys(a.ty, b.ty));\n-        Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n-    }\n-\n-    fn projection_bounds(&self,\n-                         a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n-                         b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                         -> cres<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n-    {\n-        // To be compatible, `a` and `b` must be for precisely the\n-        // same set of traits and item names. We always require that\n-        // projection bounds lists are sorted by trait-def-id and item-name,\n-        // so we can just iterate through the lists pairwise, so long as they are the\n-        // same length.\n-        if a.len() != b.len() {\n-            Err(ty::terr_projection_bounds_length(expected_found(self, a.len(), b.len())))\n-        } else {\n-            a.iter()\n-                .zip(b.iter())\n-                .map(|(a, b)| self.binders(a, b))\n-                .collect()\n-        }\n-    }\n-\n-    fn existential_bounds(&self,\n-                          a: &ty::ExistentialBounds<'tcx>,\n-                          b: &ty::ExistentialBounds<'tcx>)\n-                          -> cres<'tcx, ty::ExistentialBounds<'tcx>>\n-    {\n-        let r = try!(self.regions_with_variance(ty::Contravariant, a.region_bound, b.region_bound));\n-        let nb = try!(self.builtin_bounds(a.builtin_bounds, b.builtin_bounds));\n-        let pb = try!(self.projection_bounds(&a.projection_bounds, &b.projection_bounds));\n-        Ok(ty::ExistentialBounds { region_bound: r,\n-                                   builtin_bounds: nb,\n-                                   projection_bounds: pb })\n-    }\n-\n-    fn builtin_bounds(&self,\n-                      a: BuiltinBounds,\n-                      b: BuiltinBounds)\n-                      -> cres<'tcx, BuiltinBounds>\n-    {\n-        // Two sets of builtin bounds are only relatable if they are\n-        // precisely the same (but see the coercion code).\n-        if a != b {\n-            Err(ty::terr_builtin_bounds(expected_found(self, a, b)))\n-        } else {\n-            Ok(a)\n-        }\n-    }\n-\n-    fn trait_refs(&self,\n-                  a: &ty::TraitRef<'tcx>,\n-                  b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>>\n-    {\n-        // Different traits cannot be related\n-        if a.def_id != b.def_id {\n-            Err(ty::terr_traits(expected_found(self, a.def_id, b.def_id)))\n-        } else {\n-            let substs = try!(self.substs(a.def_id, a.substs, b.substs));\n-            Ok(ty::TraitRef { def_id: a.def_id, substs: self.tcx().mk_substs(substs) })\n-        }\n-    }\n-\n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>;\n-    // this must be overridden to do correctly, so as to account for higher-ranked\n-    // behavior\n-}\n-\n-pub trait Combineable<'tcx> : Repr<'tcx> + TypeFoldable<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<'tcx, Self>;\n-}\n-\n-impl<'tcx,T> Combineable<'tcx> for Rc<T>\n-    where T : Combineable<'tcx>\n-{\n-    fn combine<C>(combiner: &C,\n-                  a: &Rc<T>,\n-                  b: &Rc<T>)\n-                  -> cres<'tcx, Rc<T>>\n-                  where C: Combine<'tcx> {\n-        Ok(Rc::new(try!(Combineable::combine(combiner, &**a, &**b))))\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &ty::TraitRef<'tcx>,\n-                  b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.trait_refs(a, b)\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for Ty<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &Ty<'tcx>,\n-                  b: &Ty<'tcx>)\n-                  -> cres<'tcx, Ty<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.tys(*a, *b)\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &ty::ProjectionPredicate<'tcx>,\n-                  b: &ty::ProjectionPredicate<'tcx>)\n-                  -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.projection_predicates(a, b)\n-    }\n-}\n-\n-impl<'tcx> Combineable<'tcx> for ty::FnSig<'tcx> {\n-    fn combine<C>(combiner: &C,\n-                  a: &ty::FnSig<'tcx>,\n-                  b: &ty::FnSig<'tcx>)\n-                  -> cres<'tcx, ty::FnSig<'tcx>>\n-                  where C: Combine<'tcx> {\n-        combiner.fn_sigs(a, b)\n-    }\n-}\n-\n #[derive(Clone)]\n pub struct CombineFields<'a, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n     pub a_is_expected: bool,\n     pub trace: TypeTrace<'tcx>,\n }\n \n-pub fn expected_found<'tcx, C, T>(this: &C,\n-                                  a: T,\n-                                  b: T)\n-                                  -> ty::expected_found<T>\n-                                  where C: Combine<'tcx> {\n-    if this.a_is_expected() {\n-        ty::expected_found {expected: a, found: b}\n-    } else {\n-        ty::expected_found {expected: b, found: a}\n-    }\n-}\n-\n-pub fn super_tys<'tcx, C>(this: &C,\n-                          a: Ty<'tcx>,\n-                          b: Ty<'tcx>)\n-                          -> cres<'tcx, Ty<'tcx>>\n-                          where C: Combine<'tcx> {\n-    let tcx = this.infcx().tcx;\n-    let a_sty = &a.sty;\n-    let b_sty = &b.sty;\n-    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n-    return match (a_sty, b_sty) {\n-        // The \"subtype\" ought to be handling cases involving var:\n-        (&ty::ty_infer(TyVar(_)), _)\n-        | (_, &ty::ty_infer(TyVar(_))) =>\n-            tcx.sess.bug(\n-                &format!(\"{}: bot and var types should have been handled ({},{})\",\n-                this.tag(),\n-                a.repr(this.infcx().tcx),\n-                b.repr(this.infcx().tcx))),\n-\n-        (&ty::ty_err, _) | (_, &ty::ty_err) => Ok(tcx.types.err),\n+pub fn super_combine_tys<'a,'tcx:'a,R>(infcx: &InferCtxt<'a, 'tcx>,\n+                                       relation: &mut R,\n+                                       a: Ty<'tcx>,\n+                                       b: Ty<'tcx>)\n+                                       -> RelateResult<'tcx, Ty<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let a_is_expected = relation.a_is_expected();\n \n+    match (&a.sty, &b.sty) {\n         // Relate integral variables to other types\n-        (&ty::ty_infer(IntVar(a_id)), &ty::ty_infer(IntVar(b_id))) => {\n-            try!(this.infcx().simple_vars(this.a_is_expected(),\n-                                            a_id, b_id));\n+        (&ty::ty_infer(ty::IntVar(a_id)), &ty::ty_infer(ty::IntVar(b_id))) => {\n+            try!(infcx.int_unification_table\n+                      .borrow_mut()\n+                      .unify_var_var(a_id, b_id)\n+                      .map_err(|e| int_unification_error(a_is_expected, e)));\n             Ok(a)\n         }\n-        (&ty::ty_infer(IntVar(v_id)), &ty::ty_int(v)) => {\n-            unify_integral_variable(this, this.a_is_expected(),\n-                                    v_id, IntType(v))\n+        (&ty::ty_infer(ty::IntVar(v_id)), &ty::ty_int(v)) => {\n+            unify_integral_variable(infcx, a_is_expected, v_id, IntType(v))\n         }\n-        (&ty::ty_int(v), &ty::ty_infer(IntVar(v_id))) => {\n-            unify_integral_variable(this, !this.a_is_expected(),\n-                                    v_id, IntType(v))\n+        (&ty::ty_int(v), &ty::ty_infer(ty::IntVar(v_id))) => {\n+            unify_integral_variable(infcx, !a_is_expected, v_id, IntType(v))\n         }\n-        (&ty::ty_infer(IntVar(v_id)), &ty::ty_uint(v)) => {\n-            unify_integral_variable(this, this.a_is_expected(),\n-                                    v_id, UintType(v))\n+        (&ty::ty_infer(ty::IntVar(v_id)), &ty::ty_uint(v)) => {\n+            unify_integral_variable(infcx, a_is_expected, v_id, UintType(v))\n         }\n-        (&ty::ty_uint(v), &ty::ty_infer(IntVar(v_id))) => {\n-            unify_integral_variable(this, !this.a_is_expected(),\n-                                    v_id, UintType(v))\n+        (&ty::ty_uint(v), &ty::ty_infer(ty::IntVar(v_id))) => {\n+            unify_integral_variable(infcx, !a_is_expected, v_id, UintType(v))\n         }\n \n         // Relate floating-point variables to other types\n-        (&ty::ty_infer(FloatVar(a_id)), &ty::ty_infer(FloatVar(b_id))) => {\n-            try!(this.infcx().simple_vars(this.a_is_expected(), a_id, b_id));\n+        (&ty::ty_infer(ty::FloatVar(a_id)), &ty::ty_infer(ty::FloatVar(b_id))) => {\n+            try!(infcx.float_unification_table\n+                      .borrow_mut()\n+                      .unify_var_var(a_id, b_id)\n+                      .map_err(|e| float_unification_error(relation.a_is_expected(), e)));\n             Ok(a)\n         }\n-        (&ty::ty_infer(FloatVar(v_id)), &ty::ty_float(v)) => {\n-            unify_float_variable(this, this.a_is_expected(), v_id, v)\n-        }\n-        (&ty::ty_float(v), &ty::ty_infer(FloatVar(v_id))) => {\n-            unify_float_variable(this, !this.a_is_expected(), v_id, v)\n+        (&ty::ty_infer(ty::FloatVar(v_id)), &ty::ty_float(v)) => {\n+            unify_float_variable(infcx, a_is_expected, v_id, v)\n         }\n-\n-        (&ty::ty_char, _)\n-        | (&ty::ty_bool, _)\n-        | (&ty::ty_int(_), _)\n-        | (&ty::ty_uint(_), _)\n-        | (&ty::ty_float(_), _) => {\n-            if a == b {\n-                Ok(a)\n-            } else {\n-                Err(ty::terr_sorts(expected_found(this, a, b)))\n-            }\n+        (&ty::ty_float(v), &ty::ty_infer(ty::FloatVar(v_id))) => {\n+            unify_float_variable(infcx, !a_is_expected, v_id, v)\n         }\n \n-        (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p)) if\n-          a_p.idx == b_p.idx && a_p.space == b_p.space => Ok(a),\n-\n-        (&ty::ty_enum(a_id, a_substs), &ty::ty_enum(b_id, b_substs))\n-          if a_id == b_id => {\n-            let substs = try!(this.substs(a_id, a_substs, b_substs));\n-            Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n+        // All other cases of inference are errors\n+        (&ty::ty_infer(_), _) |\n+        (_, &ty::ty_infer(_)) => {\n+            Err(ty::terr_sorts(ty_relate::expected_found(relation, &a, &b)))\n         }\n \n-        (&ty::ty_trait(ref a_), &ty::ty_trait(ref b_)) => {\n-            debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n-            let principal = try!(this.binders(&a_.principal, &b_.principal));\n-            let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n-            Ok(ty::mk_trait(tcx, principal, bounds))\n-        }\n-\n-        (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n-          if a_id == b_id => {\n-            let substs = try!(this.substs(a_id, a_substs, b_substs));\n-            Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n-        }\n-\n-        (&ty::ty_closure(a_id, a_substs),\n-         &ty::ty_closure(b_id, b_substs))\n-          if a_id == b_id => {\n-            // All ty_closure types with the same id represent\n-            // the (anonymous) type of the same closure expression. So\n-            // all of their regions should be equated.\n-            let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-            Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n-        }\n \n-        (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n-            let typ = try!(this.tys(a_inner, b_inner));\n-            Ok(ty::mk_uniq(tcx, typ))\n-        }\n-\n-        (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-            let mt = try!(this.mts(a_mt, b_mt));\n-            Ok(ty::mk_ptr(tcx, mt))\n-        }\n-\n-        (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n-            let r = try!(this.regions_with_variance(ty::Contravariant, *a_r, *b_r));\n-            let mt = try!(this.mts(a_mt, b_mt));\n-            Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n-        }\n-\n-        (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) => {\n-            this.tys(a_t, b_t).and_then(|t| {\n-                if sz_a == sz_b {\n-                    Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n-                } else {\n-                    Err(ty::terr_fixed_array_size(expected_found(this, sz_a, sz_b)))\n-                }\n-            })\n-        }\n-\n-        (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {\n-            this.tys(a_t, b_t).and_then(|t| {\n-                if sz_a == sz_b {\n-                    Ok(ty::mk_vec(tcx, t, sz_a))\n-                } else {\n-                    Err(ty::terr_sorts(expected_found(this, a, b)))\n-                }\n-            })\n-        }\n-\n-        (&ty::ty_str, &ty::ty_str) => Ok(ty::mk_str(tcx)),\n-\n-        (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n-            if as_.len() == bs.len() {\n-                as_.iter().zip(bs.iter())\n-                   .map(|(a, b)| this.tys(*a, *b))\n-                   .collect::<Result<_, _>>()\n-                   .map(|ts| ty::mk_tup(tcx, ts))\n-            } else if as_.len() != 0 && bs.len() != 0 {\n-                Err(ty::terr_tuple_size(\n-                    expected_found(this, as_.len(), bs.len())))\n-            } else {\n-                Err(ty::terr_sorts(expected_found(this, a, b)))\n-            }\n-        }\n-\n-        (&ty::ty_bare_fn(a_opt_def_id, a_fty), &ty::ty_bare_fn(b_opt_def_id, b_fty))\n-            if a_opt_def_id == b_opt_def_id =>\n-        {\n-            let fty = try!(this.bare_fn_tys(a_fty, b_fty));\n-            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n-        }\n-\n-        (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) => {\n-            let projection_ty = try!(this.projection_tys(a_data, b_data));\n-            Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n-        }\n-\n-        _ => Err(ty::terr_sorts(expected_found(this, a, b))),\n-    };\n-\n-    fn unify_integral_variable<'tcx, C>(this: &C,\n-                                        vid_is_expected: bool,\n-                                        vid: ty::IntVid,\n-                                        val: ty::IntVarValue)\n-                                        -> cres<'tcx, Ty<'tcx>>\n-                                        where C: Combine<'tcx> {\n-        try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n-        match val {\n-            IntType(v) => Ok(ty::mk_mach_int(this.tcx(), v)),\n-            UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v)),\n+        _ => {\n+            ty_relate::super_relate_tys(relation, a, b)\n         }\n     }\n+}\n \n-    fn unify_float_variable<'tcx, C>(this: &C,\n-                                     vid_is_expected: bool,\n-                                     vid: ty::FloatVid,\n-                                     val: ast::FloatTy)\n-                                     -> cres<'tcx, Ty<'tcx>>\n-                                     where C: Combine<'tcx> {\n-        try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n-        Ok(ty::mk_mach_float(this.tcx(), val))\n+fn unify_integral_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                    vid_is_expected: bool,\n+                                    vid: ty::IntVid,\n+                                    val: ty::IntVarValue)\n+                                    -> RelateResult<'tcx, Ty<'tcx>>\n+{\n+    try!(infcx\n+         .int_unification_table\n+         .borrow_mut()\n+         .unify_var_value(vid, val)\n+         .map_err(|e| int_unification_error(vid_is_expected, e)));\n+    match val {\n+        IntType(v) => Ok(ty::mk_mach_int(infcx.tcx, v)),\n+        UintType(v) => Ok(ty::mk_mach_uint(infcx.tcx, v)),\n     }\n }\n \n-impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n-    pub fn switch_expected(&self) -> CombineFields<'f, 'tcx> {\n+fn unify_float_variable<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                 vid_is_expected: bool,\n+                                 vid: ty::FloatVid,\n+                                 val: ast::FloatTy)\n+                                 -> RelateResult<'tcx, Ty<'tcx>>\n+{\n+    try!(infcx\n+         .float_unification_table\n+         .borrow_mut()\n+         .unify_var_value(vid, val)\n+         .map_err(|e| float_unification_error(vid_is_expected, e)));\n+    Ok(ty::mk_mach_float(infcx.tcx, val))\n+}\n+\n+impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n+    pub fn tcx(&self) -> &'a ty::ctxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    pub fn switch_expected(&self) -> CombineFields<'a, 'tcx> {\n         CombineFields {\n             a_is_expected: !self.a_is_expected,\n             ..(*self).clone()\n         }\n     }\n \n-    fn equate(&self) -> Equate<'f, 'tcx> {\n-        Equate((*self).clone())\n+    pub fn equate(&self) -> Equate<'a, 'tcx> {\n+        Equate::new(self.clone())\n+    }\n+\n+    pub fn bivariate(&self) -> Bivariate<'a, 'tcx> {\n+        Bivariate::new(self.clone())\n+    }\n+\n+    pub fn sub(&self) -> Sub<'a, 'tcx> {\n+        Sub::new(self.clone())\n     }\n \n-    fn bivariate(&self) -> Bivariate<'f, 'tcx> {\n-        Bivariate((*self).clone())\n+    pub fn lub(&self) -> Lub<'a, 'tcx> {\n+        Lub::new(self.clone())\n     }\n \n-    fn sub(&self) -> Sub<'f, 'tcx> {\n-        Sub((*self).clone())\n+    pub fn glb(&self) -> Glb<'a, 'tcx> {\n+        Glb::new(self.clone())\n     }\n \n     pub fn instantiate(&self,\n                        a_ty: Ty<'tcx>,\n                        dir: RelationDir,\n                        b_vid: ty::TyVid)\n-                       -> cres<'tcx, ()>\n+                       -> RelateResult<'tcx, ()>\n     {\n         let tcx = self.infcx.tcx;\n         let mut stack = Vec::new();\n@@ -724,15 +249,12 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n             // relations wind up attributed to the same spans. We need\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n-            match dir {\n-                BiTo => try!(self.bivariate().tys(a_ty, b_ty)),\n-\n-                EqTo => try!(self.equate().tys(a_ty, b_ty)),\n-\n-                SubtypeOf => try!(self.sub().tys(a_ty, b_ty)),\n-\n-                SupertypeOf => try!(self.sub().tys_with_variance(ty::Contravariant, a_ty, b_ty)),\n-            };\n+            try!(match dir {\n+                BiTo => self.bivariate().relate(&a_ty, &b_ty),\n+                EqTo => self.equate().relate(&a_ty, &b_ty),\n+                SubtypeOf => self.sub().relate(&a_ty, &b_ty),\n+                SupertypeOf => self.sub().relate_with_variance(ty::Contravariant, &a_ty, &b_ty),\n+            });\n         }\n \n         Ok(())\n@@ -746,7 +268,7 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                   ty: Ty<'tcx>,\n                   for_vid: ty::TyVid,\n                   make_region_vars: bool)\n-                  -> cres<'tcx, Ty<'tcx>>\n+                  -> RelateResult<'tcx, Ty<'tcx>>\n     {\n         let mut generalize = Generalizer {\n             infcx: self.infcx,\n@@ -839,3 +361,37 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n         self.infcx.next_region_var(MiscVariable(self.span))\n     }\n }\n+\n+pub trait RelateResultCompare<'tcx, T> {\n+    fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n+        F: FnOnce() -> ty::type_err<'tcx>;\n+}\n+\n+impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'tcx, T> {\n+    fn compare<F>(&self, t: T, f: F) -> RelateResult<'tcx, T> where\n+        F: FnOnce() -> ty::type_err<'tcx>,\n+    {\n+        self.clone().and_then(|s| {\n+            if s == t {\n+                self.clone()\n+            } else {\n+                Err(f())\n+            }\n+        })\n+    }\n+}\n+\n+fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::IntVarValue))\n+                               -> ty::type_err<'tcx>\n+{\n+    let (a, b) = v;\n+    ty::terr_int_mismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n+}\n+\n+fn float_unification_error<'tcx>(a_is_expected: bool,\n+                                 v: (ast::FloatTy, ast::FloatTy))\n+                                 -> ty::type_err<'tcx>\n+{\n+    let (a, b) = v;\n+    ty::terr_float_mismatch(ty_relate::expected_found_bool(a_is_expected, &a, &b))\n+}"}, {"sha": "2003f459d89b42cb895625da636b8d3e74ecb04f", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -8,51 +8,43 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use super::combine::{self, CombineFields};\n+use super::higher_ranked::HigherRankedRelations;\n+use super::{Subtype};\n+use super::type_variable::{EqTo};\n+\n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use middle::infer::combine::*;\n-use middle::infer::cres;\n-use middle::infer::Subtype;\n-use middle::infer::type_variable::EqTo;\n-use util::ppaux::Repr;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use util::ppaux::{Repr};\n \n-pub struct Equate<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Equate<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Equate<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Equate<'f, 'tcx> {\n-    Equate { fields: cf }\n+impl<'a, 'tcx> Equate<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Equate<'a, 'tcx> {\n+        Equate { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Equate\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a,'tcx> for Equate<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Equate\" }\n \n-    fn tys_with_variance(&self, _: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>\n-    {\n-        // Once we're equating, it doesn't matter what the variance is.\n-        self.tys(a, b)\n-    }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n \n-    fn regions_with_variance(&self, _: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>\n-    {\n-        // Once we're equating, it doesn't matter what the variance is.\n-        self.regions(a, b)\n-    }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n-               self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n-        self.infcx().region_vars.make_eqregion(Subtype(self.trace()), a, b);\n-        Ok(a)\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               _: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n+    {\n+        self.relate(a, b)\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n                a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n         if a == b { return Ok(a); }\n@@ -77,15 +69,26 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n             }\n \n             _ => {\n-                super_tys(self, a, b)\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)\n             }\n         }\n     }\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        debug!(\"{}.regions({}, {})\",\n+               self.tag(),\n+               a.repr(self.fields.infcx.tcx),\n+               b.repr(self.fields.infcx.tcx));\n+        let origin = Subtype(self.fields.trace.clone());\n+        self.fields.infcx.region_vars.make_eqregion(origin, a, b);\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a, 'tcx>\n     {\n-        try!(self.sub().binders(a, b));\n-        self.sub().binders(b, a)\n+        try!(self.fields.higher_ranked_sub(a, b));\n+        self.fields.higher_ranked_sub(b, a)\n     }\n }"}, {"sha": "29f74d12ea3e814bb82c3030687b78d9eb7bd534", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -37,7 +37,7 @@ use middle::ty_fold::TypeFolder;\n use std::collections::hash_map::{self, Entry};\n \n use super::InferCtxt;\n-use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n+use super::unify::ToType;\n \n pub struct TypeFreshener<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -104,29 +104,38 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        let tcx = self.infcx.tcx;\n+\n         match t.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n-                self.freshen(self.infcx.type_variables.borrow().probe(v),\n-                               ty::TyVar(v),\n-                               ty::FreshTy)\n+                self.freshen(\n+                    self.infcx.type_variables.borrow().probe(v),\n+                    ty::TyVar(v),\n+                    ty::FreshTy)\n             }\n \n             ty::ty_infer(ty::IntVar(v)) => {\n-                self.freshen(self.infcx.probe_var(v),\n-                             ty::IntVar(v),\n-                             ty::FreshIntTy)\n+                self.freshen(\n+                    self.infcx.int_unification_table.borrow_mut()\n+                                                    .probe(v)\n+                                                    .map(|v| v.to_type(tcx)),\n+                    ty::IntVar(v),\n+                    ty::FreshIntTy)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n-                self.freshen(self.infcx.probe_var(v),\n-                             ty::FloatVar(v),\n-                             ty::FreshIntTy)\n+                self.freshen(\n+                    self.infcx.float_unification_table.borrow_mut()\n+                                                      .probe(v)\n+                                                      .map(|v| v.to_type(tcx)),\n+                    ty::FloatVar(v),\n+                    ty::FreshIntTy)\n             }\n \n             ty::ty_infer(ty::FreshTy(c)) |\n             ty::ty_infer(ty::FreshIntTy(c)) => {\n                 if c >= self.freshen_count {\n-                    self.tcx().sess.bug(\n+                    tcx.sess.bug(\n                         &format!(\"Encountered a freshend type with id {} \\\n                                   but our counter is only at {}\",\n                                  c,"}, {"sha": "5822fb0f2d432fba8d7c3fe10959268c158d3fc4", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -8,67 +8,79 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::*;\n-use super::lattice::*;\n+use super::combine::CombineFields;\n use super::higher_ranked::HigherRankedRelations;\n-use super::cres;\n+use super::InferCtxt;\n+use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n use middle::ty::{self, Ty};\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Glb<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Glb<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Glb<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Glb<'f, 'tcx> {\n-    Glb { fields: cf }\n+impl<'a, 'tcx> Glb<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Glb<'a, 'tcx> {\n+        Glb { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Glb\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Glb<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Glb\" }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n+\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Bivariant => self.bivariate().tys(a, b),\n-            ty::Contravariant => self.lub().tys(a, b),\n+        match variance {\n+            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.fields.bivariate().relate(a, b),\n+            ty::Contravariant => self.fields.lub().relate(a, b),\n         }\n     }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Bivariant => self.bivariate().regions(a, b),\n-            ty::Contravariant => self.lub().regions(a, b),\n-        }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.fields.infcx.tcx),\n                b.repr(self.fields.infcx.tcx));\n \n-        Ok(self.fields.infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n+        let origin = Subtype(self.fields.trace.clone());\n+        Ok(self.fields.infcx.region_vars.glb_regions(origin, a, b))\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        super_lattice_tys(self, a, b)\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a, 'tcx>\n+    {\n+        self.fields.higher_ranked_glb(a, b)\n     }\n+}\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n-    {\n-        self.higher_ranked_glb(a, b)\n+impl<'a, 'tcx> LatticeDir<'a,'tcx> for Glb<'a, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+        self.fields.infcx\n+    }\n+\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n+        let mut sub = self.fields.sub();\n+        try!(sub.relate(&v, &a));\n+        try!(sub.relate(&v, &b));\n+        Ok(())\n     }\n }"}, {"sha": "f347d28b93c2b0aa06f41e6e4dd00abedc938ae1", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 66, "deletions": 63, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -11,25 +11,26 @@\n //! Helper routines for higher-ranked things. See the `doc` module at\n //! the end of the file for details.\n \n-use super::{CombinedSnapshot, cres, InferCtxt, HigherRankedType, SkolemizationMap};\n-use super::combine::{Combine, Combineable};\n+use super::{CombinedSnapshot, InferCtxt, HigherRankedType, SkolemizationMap};\n+use super::combine::CombineFields;\n \n use middle::subst;\n use middle::ty::{self, Binder};\n use middle::ty_fold::{self, TypeFoldable};\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use syntax::codemap::Span;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux::Repr;\n \n-pub trait HigherRankedRelations<'tcx> {\n-    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>;\n+pub trait HigherRankedRelations<'a,'tcx> {\n+    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>;\n \n-    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>;\n+    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>;\n \n-    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>;\n+    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>;\n }\n \n trait InferCtxtExt {\n@@ -40,15 +41,15 @@ trait InferCtxtExt {\n                                         -> Vec<ty::RegionVid>;\n }\n \n-impl<'tcx,C> HigherRankedRelations<'tcx> for C\n-    where C : Combine<'tcx>\n-{\n+impl<'a,'tcx> HigherRankedRelations<'a,'tcx> for CombineFields<'a,'tcx> {\n     fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n-                            -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>\n+                            -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n+        let tcx = self.infcx.tcx;\n+\n         debug!(\"higher_ranked_sub(a={}, b={})\",\n-               a.repr(self.tcx()), b.repr(self.tcx()));\n+               a.repr(tcx), b.repr(tcx));\n \n         // Rather than checking the subtype relationship between `a` and `b`\n         // as-is, we need to do some extra work here in order to make sure\n@@ -60,32 +61,32 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().try(|snapshot| {\n+        return self.infcx.commit_if_ok(|snapshot| {\n             // First, we instantiate each bound region in the subtype with a fresh\n             // region variable.\n             let (a_prime, _) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n-                    self.trace().origin.span(),\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    self.trace.origin.span(),\n                     HigherRankedType,\n                     a);\n \n             // Second, we instantiate each bound region in the supertype with a\n             // fresh concrete region.\n             let (b_prime, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(b, snapshot);\n+                self.infcx.skolemize_late_bound_regions(b, snapshot);\n \n-            debug!(\"a_prime={}\", a_prime.repr(self.tcx()));\n-            debug!(\"b_prime={}\", b_prime.repr(self.tcx()));\n+            debug!(\"a_prime={}\", a_prime.repr(tcx));\n+            debug!(\"b_prime={}\", b_prime.repr(tcx));\n \n             // Compare types now that bound regions have been replaced.\n-            let result = try!(Combineable::combine(self, &a_prime, &b_prime));\n+            let result = try!(self.sub().relate(&a_prime, &b_prime));\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n-            match leak_check(self.infcx(), &skol_map, snapshot) {\n+            match leak_check(self.infcx, &skol_map, snapshot) {\n                 Ok(()) => { }\n                 Err((skol_br, tainted_region)) => {\n-                    if self.a_is_expected() {\n+                    if self.a_is_expected {\n                         debug!(\"Not as polymorphic!\");\n                         return Err(ty::terr_regions_insufficiently_polymorphic(skol_br,\n                                                                                tainted_region));\n@@ -98,42 +99,42 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             }\n \n             debug!(\"higher_ranked_sub: OK result={}\",\n-                   result.repr(self.tcx()));\n+                   result.repr(tcx));\n \n             Ok(ty::Binder(result))\n         });\n     }\n \n-    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().try(|snapshot| {\n+        return self.infcx.commit_if_ok(|snapshot| {\n             // Instantiate each bound region with a fresh region variable.\n-            let span = self.trace().origin.span();\n+            let span = self.trace.origin.span();\n             let (a_with_fresh, a_map) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n                     span, HigherRankedType, a);\n             let (b_with_fresh, _) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n                     span, HigherRankedType, b);\n \n             // Collect constraints.\n             let result0 =\n-                try!(Combineable::combine(self, &a_with_fresh, &b_with_fresh));\n+                try!(self.lub().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n-                self.infcx().resolve_type_vars_if_possible(&result0);\n+                self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n \n             // Generalize the regions appearing in result0 if possible\n-            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace().origin.span();\n+            let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n+            let span = self.trace.origin.span();\n             let result1 =\n                 fold_regions_in(\n                     self.tcx(),\n                     &result0,\n-                    |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n+                    |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n                                                     &new_vars, &a_map, r));\n \n             debug!(\"lub({},{}) = {}\",\n@@ -194,40 +195,40 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n         }\n     }\n \n-    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> RelateResult<'tcx, Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n-        debug!(\"{}.higher_ranked_glb({}, {})\",\n-               self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n+        debug!(\"higher_ranked_glb({}, {})\",\n+               a.repr(self.tcx()), b.repr(self.tcx()));\n \n         // Make a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        return self.infcx().try(|snapshot| {\n+        return self.infcx.commit_if_ok(|snapshot| {\n             // Instantiate each bound region with a fresh region variable.\n             let (a_with_fresh, a_map) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n-                    self.trace().origin.span(), HigherRankedType, a);\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    self.trace.origin.span(), HigherRankedType, a);\n             let (b_with_fresh, b_map) =\n-                self.infcx().replace_late_bound_regions_with_fresh_var(\n-                    self.trace().origin.span(), HigherRankedType, b);\n+                self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    self.trace.origin.span(), HigherRankedType, b);\n             let a_vars = var_ids(self, &a_map);\n             let b_vars = var_ids(self, &b_map);\n \n             // Collect constraints.\n             let result0 =\n-                try!(Combineable::combine(self, &a_with_fresh, &b_with_fresh));\n+                try!(self.glb().relate(&a_with_fresh, &b_with_fresh));\n             let result0 =\n-                self.infcx().resolve_type_vars_if_possible(&result0);\n+                self.infcx.resolve_type_vars_if_possible(&result0);\n             debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n \n             // Generalize the regions appearing in result0 if possible\n-            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n-            let span = self.trace().origin.span();\n+            let new_vars = self.infcx.region_vars_confined_to_snapshot(snapshot);\n+            let span = self.trace.origin.span();\n             let result1 =\n                 fold_regions_in(\n                     self.tcx(),\n                     &result0,\n-                    |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n+                    |r, debruijn| generalize_region(self.infcx, span, snapshot, debruijn,\n                                                     &new_vars,\n                                                     &a_map, &a_vars, &b_vars,\n                                                     r));\n@@ -332,17 +333,19 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     }\n }\n \n-fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n-                                   map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n-                                   -> Vec<ty::RegionVid> {\n-    map.iter().map(|(_, r)| match *r {\n-            ty::ReInfer(ty::ReVar(r)) => { r }\n-            r => {\n-                combiner.infcx().tcx.sess.span_bug(\n-                    combiner.trace().origin.span(),\n-                    &format!(\"found non-region-vid: {:?}\", r));\n-            }\n-        }).collect()\n+fn var_ids<'a, 'tcx>(fields: &CombineFields<'a, 'tcx>,\n+                      map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n+                     -> Vec<ty::RegionVid> {\n+    map.iter()\n+       .map(|(_, r)| match *r {\n+           ty::ReInfer(ty::ReVar(r)) => { r }\n+           r => {\n+               fields.tcx().sess.span_bug(\n+                   fields.trace.origin.span(),\n+                   &format!(\"found non-region-vid: {:?}\", r));\n+           }\n+       })\n+       .collect()\n }\n \n fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n@@ -356,8 +359,8 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n                                unbound_value: &T,\n                                mut fldr: F)\n                                -> T\n-    where T : Combineable<'tcx>,\n-          F : FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n+    where T: TypeFoldable<'tcx>,\n+          F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n     unbound_value.fold_with(&mut ty_fold::RegionFolder::new(tcx, &mut |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,"}, {"sha": "57001083b03e200e410d7fa0e9de3a76854a09a4", "filename": "src/librustc/middle/infer/lattice.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flattice.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -29,48 +29,32 @@\n //! over a `LatticeValue`, which is a value defined with respect to\n //! a lattice.\n \n-use super::*;\n-use super::combine::*;\n-use super::glb::Glb;\n-use super::lub::Lub;\n+use super::combine;\n+use super::InferCtxt;\n \n use middle::ty::TyVar;\n use middle::ty::{self, Ty};\n+use middle::ty_relate::{RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n-pub trait LatticeDir<'tcx> {\n+pub trait LatticeDir<'f,'tcx> : TypeRelation<'f,'tcx> {\n+    fn infcx(&self) -> &'f InferCtxt<'f, 'tcx>;\n+\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()>;\n-}\n-\n-impl<'a, 'tcx> LatticeDir<'tcx> for Lub<'a, 'tcx> {\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()> {\n-        let sub = self.sub();\n-        try!(sub.tys(a, v));\n-        try!(sub.tys(b, v));\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, 'tcx> LatticeDir<'tcx> for Glb<'a, 'tcx> {\n-    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, ()> {\n-        let sub = self.sub();\n-        try!(sub.tys(v, a));\n-        try!(sub.tys(v, b));\n-        Ok(())\n-    }\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }\n \n-pub fn super_lattice_tys<'tcx, L:LatticeDir<'tcx>+Combine<'tcx>>(this: &L,\n-                                                                 a: Ty<'tcx>,\n-                                                                 b: Ty<'tcx>)\n-                                                                 -> cres<'tcx, Ty<'tcx>>\n+pub fn super_lattice_tys<'a,'tcx,L:LatticeDir<'a,'tcx>>(this: &mut L,\n+                                                        a: Ty<'tcx>,\n+                                                        b: Ty<'tcx>)\n+                                                        -> RelateResult<'tcx, Ty<'tcx>>\n+    where 'tcx: 'a\n {\n     debug!(\"{}.lattice_tys({}, {})\",\n            this.tag(),\n-           a.repr(this.infcx().tcx),\n-           b.repr(this.infcx().tcx));\n+           a.repr(this.tcx()),\n+           b.repr(this.tcx()));\n \n     if a == b {\n         return Ok(a);\n@@ -95,7 +79,7 @@ pub fn super_lattice_tys<'tcx, L:LatticeDir<'tcx>+Combine<'tcx>>(this: &L,\n         }\n \n         _ => {\n-            super_tys(this, a, b)\n+            combine::super_combine_tys(this.infcx(), this, a, b)\n         }\n     }\n }"}, {"sha": "f456687be13ac49567537768bfdc0c72f4a4a6a5", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 48, "deletions": 35, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -8,67 +8,80 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::*;\n+use super::combine::CombineFields;\n use super::higher_ranked::HigherRankedRelations;\n-use super::lattice::*;\n-use super::cres;\n+use super::InferCtxt;\n+use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n use middle::ty::{self, Ty};\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n use util::ppaux::Repr;\n \n /// \"Least upper bound\" (common supertype)\n-pub struct Lub<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Lub<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Lub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Lub<'f, 'tcx> {\n-    Lub { fields: cf }\n+impl<'a, 'tcx> Lub<'a, 'tcx> {\n+    pub fn new(fields: CombineFields<'a, 'tcx>) -> Lub<'a, 'tcx> {\n+        Lub { fields: fields }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Lub\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Lub<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Lub\" }\n+\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.tcx() }\n+\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Bivariant => self.bivariate().tys(a, b),\n-            ty::Contravariant => self.glb().tys(a, b),\n+        match variance {\n+            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.fields.bivariate().relate(a, b),\n+            ty::Contravariant => self.fields.glb().relate(a, b),\n         }\n     }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Bivariant => self.bivariate().regions(a, b),\n-            ty::Contravariant => self.glb().regions(a, b),\n-        }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        lattice::super_lattice_tys(self, a, b)\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n \n-        Ok(self.infcx().region_vars.lub_regions(Subtype(self.trace()), a, b))\n+        let origin = Subtype(self.fields.trace.clone());\n+        Ok(self.fields.infcx.region_vars.lub_regions(origin, a, b))\n     }\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        super_lattice_tys(self, a, b)\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a, 'tcx>\n+    {\n+        self.fields.higher_ranked_lub(a, b)\n     }\n+}\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n-    {\n-        self.higher_ranked_lub(a, b)\n+impl<'a, 'tcx> LatticeDir<'a,'tcx> for Lub<'a, 'tcx> {\n+    fn infcx(&self) -> &'a InferCtxt<'a,'tcx> {\n+        self.fields.infcx\n+    }\n+\n+    fn relate_bound(&self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n+        let mut sub = self.fields.sub();\n+        try!(sub.relate(&a, &v));\n+        try!(sub.relate(&b, &v));\n+        Ok(())\n     }\n }\n+"}, {"sha": "da811c354578de5bbc4747c3439fe9f8efa74a5c", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 96, "deletions": 146, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -28,7 +28,8 @@ use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, UnconstrainedNumeric};\n use middle::ty::replace_late_bound_regions;\n use middle::ty::{self, Ty};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use std::cell::RefCell;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use std::cell::{RefCell};\n use std::fmt;\n use std::rc::Rc;\n use syntax::ast;\n@@ -38,12 +39,9 @@ use util::nodemap::FnvHashMap;\n use util::ppaux::ty_to_string;\n use util::ppaux::{Repr, UserString};\n \n-use self::combine::{Combine, Combineable, CombineFields};\n+use self::combine::CombineFields;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n-use self::equate::Equate;\n-use self::sub::Sub;\n-use self::lub::Lub;\n-use self::unify::{UnificationTable, InferCtxtMethodsForSimplyUnifiableTypes};\n+use self::unify::{ToType, UnificationTable};\n use self::error_reporting::ErrorReporting;\n \n pub mod bivariate;\n@@ -62,9 +60,7 @@ pub mod type_variable;\n pub mod unify;\n \n pub type Bound<T> = Option<T>;\n-\n-pub type cres<'tcx, T> = Result<T,ty::type_err<'tcx>>; // \"combine result\"\n-pub type ures<'tcx> = cres<'tcx, ()>; // \"unify result\"\n+pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n \n pub struct InferCtxt<'a, 'tcx: 'a> {\n@@ -265,7 +261,7 @@ pub enum LateBoundRegionConversionTime {\n ///\n /// See `error_reporting.rs` for more details\n #[derive(Clone, Debug)]\n-pub enum RegionVariableOrigin<'tcx> {\n+pub enum RegionVariableOrigin {\n     // Region variables created for ill-categorized reasons,\n     // mostly indicates places in need of refactoring\n     MiscVariable(Span),\n@@ -280,7 +276,7 @@ pub enum RegionVariableOrigin<'tcx> {\n     Autoref(Span),\n \n     // Regions created as part of an automatic coercion\n-    Coercion(TypeTrace<'tcx>),\n+    Coercion(Span),\n \n     // Region variables created as the values for early-bound regions\n     EarlyBoundRegion(Span, ast::Name),\n@@ -343,8 +339,7 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n         values: Types(expected_found(a_is_expected, a, b))\n     };\n \n-    let result =\n-        cx.commit_if_ok(|| cx.lub(a_is_expected, trace.clone()).tys(a, b));\n+    let result = cx.commit_if_ok(|_| cx.lub(a_is_expected, trace.clone()).relate(&a, &b));\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n@@ -359,29 +354,28 @@ pub fn mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                           origin: TypeOrigin,\n                           a: Ty<'tcx>,\n                           b: Ty<'tcx>)\n-                          -> ures<'tcx>\n+                          -> UnitResult<'tcx>\n {\n     debug!(\"mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(|| {\n-        cx.sub_types(a_is_expected, origin, a, b)\n-    })\n+    cx.sub_types(a_is_expected, origin, a, b)\n }\n \n pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                               a: Ty<'tcx>,\n                               b: Ty<'tcx>)\n-                              -> ures<'tcx> {\n+                              -> UnitResult<'tcx> {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.probe(|_| {\n         let trace = TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n         };\n-        cx.sub(true, trace).tys(a, b).to_ures()\n+        cx.sub(true, trace).relate(&a, &b).map(|_| ())\n     })\n }\n \n-pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> ures<'tcx>\n+pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>)\n+                             -> UnitResult<'tcx>\n {\n     cx.can_equate(&a, &b)\n }\n@@ -401,24 +395,22 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                          origin: TypeOrigin,\n                          a: Ty<'tcx>,\n                          b: Ty<'tcx>)\n-                         -> ures<'tcx>\n+                         -> UnitResult<'tcx>\n {\n     debug!(\"mk_eqty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(\n-        || cx.eq_types(a_is_expected, origin, a, b))\n+    cx.commit_if_ok(|_| cx.eq_types(a_is_expected, origin, a, b))\n }\n \n pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                    a_is_expected: bool,\n                                    origin: TypeOrigin,\n                                    a: ty::PolyTraitRef<'tcx>,\n                                    b: ty::PolyTraitRef<'tcx>)\n-                                   -> ures<'tcx>\n+                                   -> UnitResult<'tcx>\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.commit_if_ok(\n-        || cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n+    cx.commit_if_ok(|_| cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n }\n \n fn expected_found<T>(a_is_expected: bool,\n@@ -433,57 +425,6 @@ fn expected_found<T>(a_is_expected: bool,\n     }\n }\n \n-trait then<'tcx> {\n-    fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n-        T: Clone,\n-        F: FnOnce() -> Result<T, ty::type_err<'tcx>>;\n-}\n-\n-impl<'tcx> then<'tcx> for ures<'tcx> {\n-    fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n-        T: Clone,\n-        F: FnOnce() -> Result<T, ty::type_err<'tcx>>,\n-    {\n-        self.and_then(move |_| f())\n-    }\n-}\n-\n-trait ToUres<'tcx> {\n-    fn to_ures(&self) -> ures<'tcx>;\n-}\n-\n-impl<'tcx, T> ToUres<'tcx> for cres<'tcx, T> {\n-    fn to_ures(&self) -> ures<'tcx> {\n-        match *self {\n-          Ok(ref _v) => Ok(()),\n-          Err(ref e) => Err((*e))\n-        }\n-    }\n-}\n-\n-trait CresCompare<'tcx, T> {\n-    fn compare<F>(&self, t: T, f: F) -> cres<'tcx, T> where\n-        F: FnOnce() -> ty::type_err<'tcx>;\n-}\n-\n-impl<'tcx, T:Clone + PartialEq> CresCompare<'tcx, T> for cres<'tcx, T> {\n-    fn compare<F>(&self, t: T, f: F) -> cres<'tcx, T> where\n-        F: FnOnce() -> ty::type_err<'tcx>,\n-    {\n-        (*self).clone().and_then(move |s| {\n-            if s == t {\n-                (*self).clone()\n-            } else {\n-                Err(f())\n-            }\n-        })\n-    }\n-}\n-\n-pub fn uok<'tcx>() -> ures<'tcx> {\n-    Ok(())\n-}\n-\n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot {\n     type_snapshot: type_variable::Snapshot,\n@@ -512,41 +453,56 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         use middle::ty::UnconstrainedNumeric::{Neither, UnconstrainedInt, UnconstrainedFloat};\n         match ty.sty {\n             ty::ty_infer(ty::IntVar(vid)) => {\n-                match self.int_unification_table.borrow_mut().get(self.tcx, vid).value {\n-                    None => UnconstrainedInt,\n-                    _ => Neither,\n+                if self.int_unification_table.borrow_mut().has_value(vid) {\n+                    Neither\n+                } else {\n+                    UnconstrainedInt\n                 }\n             },\n             ty::ty_infer(ty::FloatVar(vid)) => {\n-                match self.float_unification_table.borrow_mut().get(self.tcx, vid).value {\n-                    None => return UnconstrainedFloat,\n-                    _ => Neither,\n+                if self.float_unification_table.borrow_mut().has_value(vid) {\n+                    Neither\n+                } else {\n+                    UnconstrainedFloat\n                 }\n             },\n             _ => Neither,\n         }\n     }\n \n-    pub fn combine_fields<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                              -> CombineFields<'b, 'tcx> {\n+    fn combine_fields(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+                      -> CombineFields<'a, 'tcx> {\n         CombineFields {infcx: self,\n                        a_is_expected: a_is_expected,\n                        trace: trace}\n     }\n \n-    pub fn equate<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                      -> Equate<'b, 'tcx> {\n-        Equate(self.combine_fields(a_is_expected, trace))\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn equate(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+              -> equate::Equate<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).equate()\n     }\n \n-    pub fn sub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                   -> Sub<'b, 'tcx> {\n-        Sub(self.combine_fields(a_is_expected, trace))\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn sub(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> sub::Sub<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).sub()\n     }\n \n-    pub fn lub<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n-                   -> Lub<'b, 'tcx> {\n-        Lub(self.combine_fields(a_is_expected, trace))\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn lub(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> lub::Lub<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).lub()\n+    }\n+\n+    // public so that it can be used from the rustc_driver unit tests\n+    pub fn glb(&'a self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n+               -> glb::Glb<'a, 'tcx>\n+    {\n+        self.combine_fields(a_is_expected, trace).glb()\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n@@ -609,11 +565,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n-    /// Execute `f` and commit the bindings if successful\n+    /// Execute `f` and commit the bindings if closure `f` returns `Ok(_)`\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce() -> Result<T, E>\n+        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n     {\n-        self.commit_unconditionally(move || self.try(move |_| f()))\n+        debug!(\"commit_if_ok()\");\n+        let snapshot = self.start_snapshot();\n+        let r = f(&snapshot);\n+        debug!(\"commit_if_ok() -- r.is_ok() = {}\", r.is_ok());\n+        match r {\n+            Ok(_) => { self.commit_from(snapshot); }\n+            Err(_) => { self.rollback_to(snapshot); }\n+        }\n+        r\n     }\n \n     /// Execute `f` and commit only the region bindings if successful.\n@@ -628,7 +592,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                float_snapshot,\n                                region_vars_snapshot } = self.start_snapshot();\n \n-        let r = self.try(move |_| f());\n+        let r = self.commit_if_ok(|_| f());\n \n         // Roll back any non-region bindings - they should be resolved\n         // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n@@ -649,25 +613,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n-    /// Execute `f`, unroll bindings on panic\n-    pub fn try<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n-    {\n-        debug!(\"try()\");\n-        let snapshot = self.start_snapshot();\n-        let r = f(&snapshot);\n-        debug!(\"try() -- r.is_ok() = {}\", r.is_ok());\n-        match r {\n-            Ok(_) => {\n-                self.commit_from(snapshot);\n-            }\n-            Err(_) => {\n-                self.rollback_to(snapshot);\n-            }\n-        }\n-        r\n-    }\n-\n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n         F: FnOnce(&CombinedSnapshot) -> R,\n@@ -691,12 +636,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                      origin: TypeOrigin,\n                      a: Ty<'tcx>,\n                      b: Ty<'tcx>)\n-                     -> ures<'tcx>\n+                     -> UnitResult<'tcx>\n     {\n         debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.sub(a_is_expected, trace).tys(a, b).to_ures()\n+            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -705,11 +650,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     origin: TypeOrigin,\n                     a: Ty<'tcx>,\n                     b: Ty<'tcx>)\n-                    -> ures<'tcx>\n+                    -> UnitResult<'tcx>\n     {\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(origin, a_is_expected, a, b);\n-            self.equate(a_is_expected, trace).tys(a, b).to_ures()\n+            self.equate(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -718,17 +663,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                           origin: TypeOrigin,\n                           a: Rc<ty::TraitRef<'tcx>>,\n                           b: Rc<ty::TraitRef<'tcx>>)\n-                          -> ures<'tcx>\n+                          -> UnitResult<'tcx>\n     {\n         debug!(\"sub_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n                b.repr(self.tcx));\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).trait_refs(&*a, &*b).to_ures()\n+            self.sub(a_is_expected, trace).relate(&*a, &*b).map(|_| ())\n         })\n     }\n \n@@ -737,17 +682,17 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                origin: TypeOrigin,\n                                a: ty::PolyTraitRef<'tcx>,\n                                b: ty::PolyTraitRef<'tcx>)\n-                               -> ures<'tcx>\n+                               -> UnitResult<'tcx>\n     {\n         debug!(\"sub_poly_trait_refs({} <: {})\",\n                a.repr(self.tcx),\n                b.repr(self.tcx));\n-        self.commit_if_ok(|| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace {\n                 origin: origin,\n                 values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n-            self.sub(a_is_expected, trace).binders(&a, &b).to_ures()\n+            self.sub(a_is_expected, trace).relate(&a, &b).map(|_| ())\n         })\n     }\n \n@@ -774,7 +719,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn leak_check(&self,\n                       skol_map: &SkolemizationMap,\n                       snapshot: &CombinedSnapshot)\n-                      -> ures<'tcx>\n+                      -> UnitResult<'tcx>\n     {\n         /*! See `higher_ranked::leak_check` */\n \n@@ -799,8 +744,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn equality_predicate(&self,\n                               span: Span,\n                               predicate: &ty::PolyEquatePredicate<'tcx>)\n-                              -> ures<'tcx> {\n-        self.try(|snapshot| {\n+                              -> UnitResult<'tcx> {\n+        self.commit_if_ok(|snapshot| {\n             let (ty::EquatePredicate(a, b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = EquatePredicate(span);\n@@ -812,8 +757,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn region_outlives_predicate(&self,\n                                      span: Span,\n                                      predicate: &ty::PolyRegionOutlivesPredicate)\n-                                     -> ures<'tcx> {\n-        self.try(|snapshot| {\n+                                     -> UnitResult<'tcx> {\n+        self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = RelateRegionParamBound(span);\n@@ -852,7 +797,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .new_key(None)\n     }\n \n-    pub fn next_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> ty::Region {\n+    pub fn next_region_var(&self, origin: RegionVariableOrigin) -> ty::Region {\n         ty::ReInfer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n@@ -948,12 +893,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n \n             ty::ty_infer(ty::IntVar(v)) => {\n-                self.probe_var(v)\n+                self.int_unification_table\n+                    .borrow_mut()\n+                    .probe(v)\n+                    .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n-                self.probe_var(v)\n+                self.float_unification_table\n+                    .borrow_mut()\n+                    .probe(v)\n+                    .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n \n@@ -1104,8 +1055,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.region_vars.verify_generic_bound(origin, kind, a, bs);\n     }\n \n-    pub fn can_equate<T>(&self, a: &T, b: &T) -> ures<'tcx>\n-        where T : Combineable<'tcx> + Repr<'tcx>\n+    pub fn can_equate<'b,T>(&'b self, a: &T, b: &T) -> UnitResult<'tcx>\n+        where T: Relate<'b,'tcx> + Repr<'tcx>\n     {\n         debug!(\"can_equate({}, {})\", a.repr(self.tcx), b.repr(self.tcx));\n         self.probe(|_| {\n@@ -1116,9 +1067,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let e = self.tcx.types.err;\n             let trace = TypeTrace { origin: Misc(codemap::DUMMY_SP),\n                                     values: Types(expected_found(true, e, e)) };\n-            let eq = self.equate(true, trace);\n-            Combineable::combine(&eq, a, b)\n-        }).to_ures()\n+            self.equate(true, trace).relate(a, b)\n+        }).map(|_| ())\n     }\n }\n \n@@ -1304,14 +1254,14 @@ impl<'tcx> Repr<'tcx> for SubregionOrigin<'tcx> {\n     }\n }\n \n-impl<'tcx> RegionVariableOrigin<'tcx> {\n+impl RegionVariableOrigin {\n     pub fn span(&self) -> Span {\n         match *self {\n             MiscVariable(a) => a,\n             PatternRegion(a) => a,\n             AddrOfRegion(a) => a,\n             Autoref(a) => a,\n-            Coercion(ref a) => a.span(),\n+            Coercion(a) => a,\n             EarlyBoundRegion(a, _) => a,\n             LateBoundRegion(a, _, _) => a,\n             BoundRegionInCoherence(_) => codemap::DUMMY_SP,\n@@ -1320,7 +1270,7 @@ impl<'tcx> RegionVariableOrigin<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n+impl<'tcx> Repr<'tcx> for RegionVariableOrigin {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         match *self {\n             MiscVariable(a) => {\n@@ -1333,7 +1283,7 @@ impl<'tcx> Repr<'tcx> for RegionVariableOrigin<'tcx> {\n                 format!(\"AddrOfRegion({})\", a.repr(tcx))\n             }\n             Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n-            Coercion(ref a) => format!(\"Coercion({})\", a.repr(tcx)),\n+            Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n             EarlyBoundRegion(a, b) => {\n                 format!(\"EarlyBoundRegion({},{})\", a.repr(tcx), b.repr(tcx))\n             }"}, {"sha": "98347e97e09c3cb498a7692c76b7f59533a7564b", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -18,14 +18,14 @@ pub use self::RegionResolutionError::*;\n pub use self::VarValue::*;\n use self::Classification::*;\n \n-use super::cres;\n use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n \n use middle::region;\n use middle::ty::{self, Ty};\n use middle::ty::{BoundRegion, FreeRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReInfer, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n+use middle::ty_relate::RelateResult;\n use middle::graph;\n use middle::graph::{Direction, NodeIndex};\n use util::common::indenter;\n@@ -115,7 +115,7 @@ pub enum RegionResolutionError<'tcx> {\n     /// Could not infer a value for `v` because `sub_r <= v` (due to\n     /// `sub_origin`) but `v <= sup_r` (due to `sup_origin`) and\n     /// `sub_r <= sup_r` does not hold.\n-    SubSupConflict(RegionVariableOrigin<'tcx>,\n+    SubSupConflict(RegionVariableOrigin,\n                    SubregionOrigin<'tcx>, Region,\n                    SubregionOrigin<'tcx>, Region),\n \n@@ -124,15 +124,15 @@ pub enum RegionResolutionError<'tcx> {\n     /// Could not infer a value for `v` because `v <= r1` (due to\n     /// `origin1`) and `v <= r2` (due to `origin2`) and\n     /// `r1` and `r2` have no intersection.\n-    SupSupConflict(RegionVariableOrigin<'tcx>,\n+    SupSupConflict(RegionVariableOrigin,\n                    SubregionOrigin<'tcx>, Region,\n                    SubregionOrigin<'tcx>, Region),\n \n     /// For subsets of `ConcreteFailure` and `SubSupConflict`, we can derive\n     /// more specific errors message by suggesting to the user where they\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<RegionVariableOrigin<'tcx>>,\n+    ProcessedErrors(Vec<RegionVariableOrigin>,\n                     Vec<(TypeTrace<'tcx>, ty::type_err<'tcx>)>,\n                     Vec<SameRegions>),\n }\n@@ -168,7 +168,7 @@ pub type CombineMap = FnvHashMap<TwoRegions, RegionVid>;\n \n pub struct RegionVarBindings<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    var_origins: RefCell<Vec<RegionVariableOrigin<'tcx>>>,\n+    var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n     // Constraints of the form `A <= B` introduced by the region\n     // checker.  Here at least one of `A` and `B` must be a region\n@@ -316,7 +316,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         len as u32\n     }\n \n-    pub fn new_region_var(&self, origin: RegionVariableOrigin<'tcx>) -> RegionVid {\n+    pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n         self.var_origins.borrow_mut().push(origin.clone());\n         let vid = RegionVid { index: id };\n@@ -798,7 +798,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// regions are given as argument, in any order, a consistent result is returned.\n     fn lub_free_regions(&self,\n                         a: &FreeRegion,\n-                        b: &FreeRegion) -> ty::Region\n+                        b: &FreeRegion)\n+                        -> ty::Region\n     {\n         return match a.cmp(b) {\n             Less => helper(self, a, b),\n@@ -823,7 +824,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     fn glb_concrete_regions(&self,\n                             a: Region,\n                             b: Region)\n-                         -> cres<'tcx, Region> {\n+                            -> RelateResult<'tcx, Region>\n+    {\n         debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n             (ReLateBound(..), _) |\n@@ -898,7 +900,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// returned.\n     fn glb_free_regions(&self,\n                         a: &FreeRegion,\n-                        b: &FreeRegion) -> cres<'tcx, ty::Region>\n+                        b: &FreeRegion)\n+                        -> RelateResult<'tcx, ty::Region>\n     {\n         return match a.cmp(b) {\n             Less => helper(self, a, b),\n@@ -908,7 +911,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         fn helper<'a, 'tcx>(this: &RegionVarBindings<'a, 'tcx>,\n                             a: &FreeRegion,\n-                            b: &FreeRegion) -> cres<'tcx, ty::Region>\n+                            b: &FreeRegion) -> RelateResult<'tcx, ty::Region>\n         {\n             if this.tcx.region_maps.sub_free_region(*a, *b) {\n                 Ok(ty::ReFree(*a))\n@@ -926,7 +929,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         region_a: ty::Region,\n                         region_b: ty::Region,\n                         scope_a: region::CodeExtent,\n-                        scope_b: region::CodeExtent) -> cres<'tcx, Region>\n+                        scope_b: region::CodeExtent)\n+                        -> RelateResult<'tcx, Region>\n     {\n         // We want to generate the intersection of two\n         // scopes or two free regions.  So, if one of"}, {"sha": "31b654a5b3fd3b5fcfba885019ade59349aa69a6", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -8,64 +8,49 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::combine::*;\n-use super::cres;\n+use super::combine::{self, CombineFields};\n use super::higher_ranked::HigherRankedRelations;\n use super::Subtype;\n use super::type_variable::{SubtypeOf, SupertypeOf};\n \n use middle::ty::{self, Ty};\n use middle::ty::TyVar;\n-use util::ppaux::Repr;\n+use middle::ty_relate::{Relate, RelateResult, TypeRelation};\n+use util::ppaux::{Repr};\n \n /// \"Greatest lower bound\" (common subtype)\n-pub struct Sub<'f, 'tcx: 'f> {\n-    fields: CombineFields<'f, 'tcx>\n+pub struct Sub<'a, 'tcx: 'a> {\n+    fields: CombineFields<'a, 'tcx>\n }\n \n-#[allow(non_snake_case)]\n-pub fn Sub<'f, 'tcx>(cf: CombineFields<'f, 'tcx>) -> Sub<'f, 'tcx> {\n-    Sub { fields: cf }\n+impl<'a, 'tcx> Sub<'a, 'tcx> {\n+    pub fn new(f: CombineFields<'a, 'tcx>) -> Sub<'a, 'tcx> {\n+        Sub { fields: f }\n+    }\n }\n \n-impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n-    fn tag(&self) -> String { \"Sub\".to_string() }\n-    fn fields<'a>(&'a self) -> &'a CombineFields<'a, 'tcx> { &self.fields }\n-\n-    fn tys_with_variance(&self, v: ty::Variance, a: Ty<'tcx>, b: Ty<'tcx>)\n-                         -> cres<'tcx, Ty<'tcx>>\n-    {\n-        match v {\n-            ty::Invariant => self.equate().tys(a, b),\n-            ty::Covariant => self.tys(a, b),\n-            ty::Bivariant => self.bivariate().tys(a, b),\n-            ty::Contravariant => Sub(self.fields.switch_expected()).tys(b, a),\n-        }\n-    }\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Sub<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Sub\" }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.fields.infcx.tcx }\n+    fn a_is_expected(&self) -> bool { self.fields.a_is_expected }\n \n-    fn regions_with_variance(&self, v: ty::Variance, a: ty::Region, b: ty::Region)\n-                             -> cres<'tcx, ty::Region>\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n     {\n-        match v {\n-            ty::Invariant => self.equate().regions(a, b),\n-            ty::Covariant => self.regions(a, b),\n-            ty::Bivariant => self.bivariate().regions(a, b),\n-            ty::Contravariant => Sub(self.fields.switch_expected()).regions(b, a),\n+        match variance {\n+            ty::Invariant => self.fields.equate().relate(a, b),\n+            ty::Covariant => self.relate(a, b),\n+            ty::Bivariant => self.fields.bivariate().relate(a, b),\n+            ty::Contravariant => self.fields.switch_expected().sub().relate(b, a),\n         }\n     }\n \n-    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region> {\n-        debug!(\"{}.regions({}, {})\",\n-               self.tag(),\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n-        self.infcx().region_vars.make_subregion(Subtype(self.trace()), a, b);\n-        Ok(a)\n-    }\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({}, {})\", self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n \n-    fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n-        debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.tcx()), b.repr(self.tcx()));\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n@@ -80,8 +65,8 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n             }\n             (&ty::ty_infer(TyVar(a_id)), _) => {\n                 try!(self.fields\n-                       .switch_expected()\n-                       .instantiate(b, SupertypeOf, a_id));\n+                         .switch_expected()\n+                         .instantiate(b, SupertypeOf, a_id));\n                 Ok(a)\n             }\n             (_, &ty::ty_infer(TyVar(b_id))) => {\n@@ -94,14 +79,25 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n             }\n \n             _ => {\n-                super_tys(self, a, b)\n+                combine::super_combine_tys(self.fields.infcx, self, a, b)\n             }\n         }\n     }\n \n-    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n-        where T : Combineable<'tcx>\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        debug!(\"{}.regions({}, {})\",\n+               self.tag(),\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n+        let origin = Subtype(self.fields.trace.clone());\n+        self.fields.infcx.region_vars.make_subregion(origin, a, b);\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>\n     {\n-        self.higher_ranked_sub(a, b)\n+        self.fields.higher_ranked_sub(a, b)\n     }\n }"}, {"sha": "39271d4cdc597cb8f448c5dc8205f568b92164ee", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 82, "deletions": 160, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -12,11 +12,8 @@ pub use self::VarValue::*;\n \n use std::marker;\n \n-use middle::ty::{expected_found, IntVarValue};\n+use middle::ty::{IntVarValue};\n use middle::ty::{self, Ty};\n-use middle::infer::{uok, ures};\n-use middle::infer::InferCtxt;\n-use std::cell::RefCell;\n use std::fmt::Debug;\n use std::marker::PhantomData;\n use syntax::ast;\n@@ -35,14 +32,9 @@ use util::snapshot_vec as sv;\n pub trait UnifyKey : Clone + Debug + PartialEq {\n     type Value : UnifyValue;\n \n-    fn index(&self) -> usize;\n+    fn index(&self) -> u32;\n \n-    fn from_index(u: usize) -> Self;\n-\n-    // Given an inference context, returns the unification table\n-    // appropriate to this key type.\n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-                             -> &'v RefCell<UnificationTable<Self>>;\n+    fn from_index(u: u32) -> Self;\n \n     fn tag(k: Option<Self>) -> &'static str;\n }\n@@ -130,21 +122,25 @@ impl<K:UnifyKey> UnificationTable<K> {\n \n     pub fn new_key(&mut self, value: K::Value) -> K {\n         let index = self.values.push(Root(value, 0));\n-        let k = UnifyKey::from_index(index);\n+        let k = UnifyKey::from_index(index as u32);\n         debug!(\"{}: created new key: {:?}\",\n                UnifyKey::tag(None::<K>),\n                k);\n         k\n     }\n \n-    /// Find the root node for `vid`. This uses the standard union-find algorithm with path\n-    /// compression: http://en.wikipedia.org/wiki/Disjoint-set_data_structure\n-    pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K> {\n-        let index = vid.index();\n+    /// Find the root node for `vid`. This uses the standard\n+    /// union-find algorithm with path compression:\n+    /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n+    ///\n+    /// NB. This is a building-block operation and you would probably\n+    /// prefer to call `probe` below.\n+    fn get(&mut self, vid: K) -> Node<K> {\n+        let index = vid.index() as usize;\n         let value = (*self.values.get(index)).clone();\n         match value {\n             Redirect(redirect) => {\n-                let node: Node<K> = self.get(tcx, redirect.clone());\n+                let node: Node<K> = self.get(redirect.clone());\n                 if node.key != redirect {\n                     // Path compression\n                     self.values.set(index, Redirect(node.key.clone()));\n@@ -158,58 +154,58 @@ impl<K:UnifyKey> UnificationTable<K> {\n     }\n \n     fn is_root(&self, key: &K) -> bool {\n-        match *self.values.get(key.index()) {\n+        let index = key.index() as usize;\n+        match *self.values.get(index) {\n             Redirect(..) => false,\n             Root(..) => true,\n         }\n     }\n \n-    /// Sets the value for `vid` to `new_value`. `vid` MUST be a root node! Also, we must be in the\n-    /// middle of a snapshot.\n-    pub fn set<'tcx>(&mut self,\n-                     _tcx: &ty::ctxt<'tcx>,\n-                     key: K,\n-                     new_value: VarValue<K>)\n-    {\n+    /// Sets the value for `vid` to `new_value`. `vid` MUST be a root\n+    /// node! This is an internal operation used to impl other things.\n+    fn set(&mut self, key: K, new_value: VarValue<K>) {\n         assert!(self.is_root(&key));\n \n         debug!(\"Updating variable {:?} to {:?}\",\n                key, new_value);\n \n-        self.values.set(key.index(), new_value);\n+        let index = key.index() as usize;\n+        self.values.set(index, new_value);\n     }\n \n-    /// Either redirects node_a to node_b or vice versa, depending on the relative rank. Returns\n-    /// the new root and rank. You should then update the value of the new root to something\n-    /// suitable.\n-    pub fn unify<'tcx>(&mut self,\n-                       tcx: &ty::ctxt<'tcx>,\n-                       node_a: &Node<K>,\n-                       node_b: &Node<K>)\n-                       -> (K, usize)\n-    {\n+    /// Either redirects `node_a` to `node_b` or vice versa, depending\n+    /// on the relative rank. The value associated with the new root\n+    /// will be `new_value`.\n+    ///\n+    /// NB: This is the \"union\" operation of \"union-find\". It is\n+    /// really more of a building block. If the values associated with\n+    /// your key are non-trivial, you would probably prefer to call\n+    /// `unify_var_var` below.\n+    fn unify(&mut self, node_a: &Node<K>, node_b: &Node<K>, new_value: K::Value) {\n         debug!(\"unify(node_a(id={:?}, rank={:?}), node_b(id={:?}, rank={:?}))\",\n                node_a.key,\n                node_a.rank,\n                node_b.key,\n                node_b.rank);\n \n-        if node_a.rank > node_b.rank {\n+        let (new_root, new_rank) = if node_a.rank > node_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(tcx, node_b.key.clone(), Redirect(node_a.key.clone()));\n+            self.set(node_b.key.clone(), Redirect(node_a.key.clone()));\n             (node_a.key.clone(), node_a.rank)\n         } else if node_a.rank < node_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(tcx, node_a.key.clone(), Redirect(node_b.key.clone()));\n+            self.set(node_a.key.clone(), Redirect(node_b.key.clone()));\n             (node_b.key.clone(), node_b.rank)\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n             assert_eq!(node_a.rank, node_b.rank);\n-            self.set(tcx, node_b.key.clone(), Redirect(node_a.key.clone()));\n+            self.set(node_b.key.clone(), Redirect(node_a.key.clone()));\n             (node_a.key.clone(), node_a.rank + 1)\n-        }\n+        };\n+\n+        self.set(new_root, Root(new_value, new_rank));\n     }\n }\n \n@@ -223,165 +219,104 @@ impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Code to handle simple keys like ints, floats---anything that\n-// doesn't have a subtyping relationship we need to worry about.\n-\n-/// Indicates a type that does not have any kind of subtyping\n-/// relationship.\n-pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Debug {\n-    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n-    fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;\n-}\n-\n-pub fn err<'tcx, V:SimplyUnifiable<'tcx>>(a_is_expected: bool,\n-                                          a_t: V,\n-                                          b_t: V)\n-                                          -> ures<'tcx> {\n-    if a_is_expected {\n-        Err(SimplyUnifiable::to_type_err(\n-            ty::expected_found {expected: a_t, found: b_t}))\n-    } else {\n-        Err(SimplyUnifiable::to_type_err(\n-            ty::expected_found {expected: b_t, found: a_t}))\n-    }\n-}\n-\n-pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V>\n-    where K : UnifyKey<Value=Option<V>>,\n-          V : SimplyUnifiable<'tcx>,\n-          Option<V> : UnifyValue,\n-{\n-    fn simple_vars(&self,\n-                   a_is_expected: bool,\n-                   a_id: K,\n-                   b_id: K)\n-                   -> ures<'tcx>;\n-    fn simple_var_t(&self,\n-                    a_is_expected: bool,\n-                    a_id: K,\n-                    b: V)\n-                    -> ures<'tcx>;\n-    fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>>;\n-}\n-\n-impl<'a,'tcx,V,K> InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V> for InferCtxt<'a,'tcx>\n-    where K : UnifyKey<Value=Option<V>>,\n-          V : SimplyUnifiable<'tcx>,\n-          Option<V> : UnifyValue,\n+// Code to handle keys which carry a value, like ints,\n+// floats---anything that doesn't have a subtyping relationship we\n+// need to worry about.\n+\n+impl<'tcx,K,V> UnificationTable<K>\n+    where K: UnifyKey<Value=Option<V>>,\n+          V: Clone+PartialEq,\n+          Option<V>: UnifyValue,\n {\n-    /// Unifies two simple keys. Because simple keys do not have any subtyping relationships, if\n-    /// both keys have already been associated with a value, then those two values must be the\n-    /// same.\n-    fn simple_vars(&self,\n-                   a_is_expected: bool,\n-                   a_id: K,\n-                   b_id: K)\n-                   -> ures<'tcx>\n+    pub fn unify_var_var(&mut self,\n+                         a_id: K,\n+                         b_id: K)\n+                         -> Result<(),(V,V)>\n     {\n-        let tcx = self.tcx;\n-        let table = UnifyKey::unification_table(self);\n-        let node_a: Node<K> = table.borrow_mut().get(tcx, a_id);\n-        let node_b: Node<K> = table.borrow_mut().get(tcx, b_id);\n+        let node_a = self.get(a_id);\n+        let node_b = self.get(b_id);\n         let a_id = node_a.key.clone();\n         let b_id = node_b.key.clone();\n \n-        if a_id == b_id { return uok(); }\n+        if a_id == b_id { return Ok(()); }\n \n         let combined = {\n             match (&node_a.value, &node_b.value) {\n                 (&None, &None) => {\n                     None\n                 }\n                 (&Some(ref v), &None) | (&None, &Some(ref v)) => {\n-                    Some((*v).clone())\n+                    Some(v.clone())\n                 }\n                 (&Some(ref v1), &Some(ref v2)) => {\n                     if *v1 != *v2 {\n-                        return err(a_is_expected, (*v1).clone(), (*v2).clone())\n+                        return Err((v1.clone(), v2.clone()));\n                     }\n-                    Some((*v1).clone())\n+                    Some(v1.clone())\n                 }\n             }\n         };\n \n-        let (new_root, new_rank) = table.borrow_mut().unify(tcx,\n-                                                            &node_a,\n-                                                            &node_b);\n-        table.borrow_mut().set(tcx, new_root, Root(combined, new_rank));\n-        return Ok(())\n+        Ok(self.unify(&node_a, &node_b, combined))\n     }\n \n     /// Sets the value of the key `a_id` to `b`. Because simple keys do not have any subtyping\n     /// relationships, if `a_id` already has a value, it must be the same as `b`.\n-    fn simple_var_t(&self,\n-                    a_is_expected: bool,\n-                    a_id: K,\n-                    b: V)\n-                    -> ures<'tcx>\n+    pub fn unify_var_value(&mut self,\n+                           a_id: K,\n+                           b: V)\n+                           -> Result<(),(V,V)>\n     {\n-        let tcx = self.tcx;\n-        let table = UnifyKey::unification_table(self);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n+        let node_a = self.get(a_id);\n         let a_id = node_a.key.clone();\n \n         match node_a.value {\n             None => {\n-                table.borrow_mut().set(tcx, a_id, Root(Some(b), node_a.rank));\n-                return Ok(());\n+                self.set(a_id, Root(Some(b), node_a.rank));\n+                Ok(())\n             }\n \n             Some(ref a_t) => {\n                 if *a_t == b {\n-                    return Ok(());\n+                    Ok(())\n                 } else {\n-                    return err(a_is_expected, (*a_t).clone(), b);\n+                    Err((a_t.clone(), b))\n                 }\n             }\n         }\n     }\n \n-    fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>> {\n-        let tcx = self.tcx;\n-        let table = UnifyKey::unification_table(self);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n-        match node_a.value {\n-            None => None,\n-            Some(ref a_t) => Some(a_t.to_type(tcx))\n-        }\n+    pub fn has_value(&mut self, id: K) -> bool {\n+        self.get(id).value.is_some()\n+    }\n+\n+    pub fn probe(&mut self, a_id: K) -> Option<V> {\n+        self.get(a_id).value.clone()\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n \n // Integral type keys\n \n+pub trait ToType<'tcx> {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n+}\n+\n impl UnifyKey for ty::IntVid {\n     type Value = Option<IntVarValue>;\n-\n-    fn index(&self) -> usize { self.index as usize }\n-\n-    fn from_index(i: usize) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n-\n-    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::IntVid>> {\n-        return &infcx.int_unification_table;\n-    }\n-\n-    fn tag(_: Option<ty::IntVid>) -> &'static str {\n-        \"IntVid\"\n-    }\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::IntVid { ty::IntVid { index: i } }\n+    fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n }\n \n-impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n+impl<'tcx> ToType<'tcx> for IntVarValue {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => ty::mk_mach_int(tcx, i),\n             ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n         }\n     }\n-\n-    fn to_type_err(err: expected_found<IntVarValue>) -> ty::type_err<'tcx> {\n-        return ty::terr_int_mismatch(err);\n-    }\n }\n \n impl UnifyValue for Option<IntVarValue> { }\n@@ -390,29 +325,16 @@ impl UnifyValue for Option<IntVarValue> { }\n \n impl UnifyKey for ty::FloatVid {\n     type Value = Option<ast::FloatTy>;\n-\n-    fn index(&self) -> usize { self.index as usize }\n-\n-    fn from_index(i: usize) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n-\n-    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::FloatVid>> {\n-        return &infcx.float_unification_table;\n-    }\n-\n-    fn tag(_: Option<ty::FloatVid>) -> &'static str {\n-        \"FloatVid\"\n-    }\n+    fn index(&self) -> u32 { self.index }\n+    fn from_index(i: u32) -> ty::FloatVid { ty::FloatVid { index: i } }\n+    fn tag(_: Option<ty::FloatVid>) -> &'static str { \"FloatVid\" }\n }\n \n impl UnifyValue for Option<ast::FloatTy> {\n }\n \n-impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n+impl<'tcx> ToType<'tcx> for ast::FloatTy {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         ty::mk_mach_float(tcx, *self)\n     }\n-\n-    fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err<'tcx> {\n-        ty::terr_float_mismatch(err)\n-    }\n }"}, {"sha": "d8efb5655aaabc2c62ade363978214b7183ecc9a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -32,7 +32,7 @@ pub type ExternalExports = DefIdSet;\n /// reexporting a public struct doesn't inline the doc).\n pub type PublicItems = NodeSet;\n \n-#[derive(Copy, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum LastPrivate {\n     LastMod(PrivateDep),\n     // `use` directives (imports) can refer to two separate definitions in the\n@@ -46,14 +46,14 @@ pub enum LastPrivate {\n                type_used: ImportUse},\n }\n \n-#[derive(Copy, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum PrivateDep {\n     AllPublic,\n     DependsOn(ast::DefId),\n }\n \n // How an import is used.\n-#[derive(Copy, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum ImportUse {\n     Unused,       // The import is not used.\n     Used,         // The import is used."}, {"sha": "411be28b89695162d75d435751b793d64ec6788b", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 150, "deletions": 53, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -17,15 +17,17 @@ use super::PredicateObligation;\n use super::project;\n use super::util;\n \n-use middle::subst::{Subst, TypeSpace};\n+use middle::subst::{Subst, Substs, TypeSpace};\n use middle::ty::{self, ToPolyTraitRef, Ty};\n use middle::infer::{self, InferCtxt};\n-use std::collections::HashSet;\n use std::rc::Rc;\n use syntax::ast;\n-use syntax::codemap::DUMMY_SP;\n+use syntax::codemap::{DUMMY_SP, Span};\n use util::ppaux::Repr;\n \n+#[derive(Copy)]\n+struct ParamIsLocal(bool);\n+\n /// True if there exist types that satisfy both of the two given impls.\n pub fn overlapping_impls(infcx: &InferCtxt,\n                          impl1_def_id: ast::DefId,\n@@ -56,10 +58,16 @@ fn overlap(selcx: &mut SelectionContext,\n            a_def_id.repr(selcx.tcx()),\n            b_def_id.repr(selcx.tcx()));\n \n-    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx, a_def_id);\n-    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx, b_def_id);\n+    let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx,\n+                                                                a_def_id,\n+                                                                util::free_substs_for_impl);\n+\n+    let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx,\n+                                                                b_def_id,\n+                                                                util::fresh_type_vars_for_impl);\n \n     debug!(\"overlap: a_trait_ref={}\", a_trait_ref.repr(selcx.tcx()));\n+\n     debug!(\"overlap: b_trait_ref={}\", b_trait_ref.repr(selcx.tcx()));\n \n     // Does `a <: b` hold? If not, no overlap.\n@@ -74,28 +82,68 @@ fn overlap(selcx: &mut SelectionContext,\n     debug!(\"overlap: subtraitref check succeeded\");\n \n     // Are any of the obligations unsatisfiable? If so, no overlap.\n+    let tcx = selcx.tcx();\n+    let infcx = selcx.infcx();\n     let opt_failing_obligation =\n         a_obligations.iter()\n                      .chain(b_obligations.iter())\n+                     .map(|o| infcx.resolve_type_vars_if_possible(o))\n                      .find(|o| !selcx.evaluate_obligation(o));\n \n     if let Some(failing_obligation) = opt_failing_obligation {\n-        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr(selcx.tcx()));\n-        return false;\n+        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr(tcx));\n+        return false\n     }\n \n     true\n }\n \n+pub fn trait_ref_is_knowable<'tcx>(tcx: &ty::ctxt<'tcx>, trait_ref: &ty::TraitRef<'tcx>) -> bool\n+{\n+    debug!(\"trait_ref_is_knowable(trait_ref={})\", trait_ref.repr(tcx));\n+\n+    // if the orphan rules pass, that means that no ancestor crate can\n+    // impl this, so it's up to us.\n+    if orphan_check_trait_ref(tcx, trait_ref, ParamIsLocal(false)).is_ok() {\n+        debug!(\"trait_ref_is_knowable: orphan check passed\");\n+        return true;\n+    }\n+\n+    // if the trait is not marked fundamental, then it's always possible that\n+    // an ancestor crate will impl this in the future, if they haven't\n+    // already\n+    if\n+        trait_ref.def_id.krate != ast::LOCAL_CRATE &&\n+        !ty::has_attr(tcx, trait_ref.def_id, \"fundamental\")\n+    {\n+        debug!(\"trait_ref_is_knowable: trait is neither local nor fundamental\");\n+        return false;\n+    }\n+\n+    // find out when some downstream (or cousin) crate could impl this\n+    // trait-ref, presuming that all the parameters were instantiated\n+    // with downstream types. If not, then it could only be\n+    // implemented by an upstream crate, which means that the impl\n+    // must be visible to us, and -- since the trait is fundamental\n+    // -- we can test.\n+    orphan_check_trait_ref(tcx, trait_ref, ParamIsLocal(true)).is_err()\n+}\n+\n+type SubstsFn = for<'a,'tcx> fn(infcx: &InferCtxt<'a, 'tcx>,\n+                                span: Span,\n+                                impl_def_id: ast::DefId)\n+                                -> Substs<'tcx>;\n+\n /// Instantiate fresh variables for all bound parameters of the impl\n /// and return the impl trait ref with those variables substituted.\n fn impl_trait_ref_and_oblig<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                                     impl_def_id: ast::DefId)\n+                                     impl_def_id: ast::DefId,\n+                                     substs_fn: SubstsFn)\n                                      -> (Rc<ty::TraitRef<'tcx>>,\n                                          Vec<PredicateObligation<'tcx>>)\n {\n     let impl_substs =\n-        &util::fresh_substs_for_impl(selcx.infcx(), DUMMY_SP, impl_def_id);\n+        &substs_fn(selcx.infcx(), DUMMY_SP, impl_def_id);\n     let impl_trait_ref =\n         ty::impl_trait_ref(selcx.tcx(), impl_def_id).unwrap();\n     let impl_trait_ref =\n@@ -134,12 +182,12 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n                           impl_def_id: ast::DefId)\n                           -> Result<(), OrphanCheckErr<'tcx>>\n {\n-    debug!(\"impl_is_local({})\", impl_def_id.repr(tcx));\n+    debug!(\"orphan_check({})\", impl_def_id.repr(tcx));\n \n     // We only except this routine to be invoked on implementations\n     // of a trait, not inherent implementations.\n     let trait_ref = ty::impl_trait_ref(tcx, impl_def_id).unwrap();\n-    debug!(\"trait_ref={}\", trait_ref.repr(tcx));\n+    debug!(\"orphan_check: trait_ref={}\", trait_ref.repr(tcx));\n \n     // If the *trait* is local to the crate, ok.\n     if trait_ref.def_id.krate == ast::LOCAL_CRATE {\n@@ -148,34 +196,106 @@ pub fn orphan_check<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return Ok(());\n     }\n \n+    orphan_check_trait_ref(tcx, &trait_ref, ParamIsLocal(false))\n+}\n+\n+fn orphan_check_trait_ref<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                trait_ref: &ty::TraitRef<'tcx>,\n+                                param_is_local: ParamIsLocal)\n+                                -> Result<(), OrphanCheckErr<'tcx>>\n+{\n+    debug!(\"orphan_check_trait_ref(trait_ref={}, param_is_local={})\",\n+           trait_ref.repr(tcx), param_is_local.0);\n+\n     // First, create an ordered iterator over all the type parameters to the trait, with the self\n     // type appearing first.\n     let input_tys = Some(trait_ref.self_ty());\n     let input_tys = input_tys.iter().chain(trait_ref.substs.types.get_slice(TypeSpace).iter());\n-    let mut input_tys = input_tys;\n \n     // Find the first input type that either references a type parameter OR\n     // some local type.\n-    match input_tys.find(|&&input_ty| references_local_or_type_parameter(tcx, input_ty)) {\n-        Some(&input_ty) => {\n-            // Within this first type, check that all type parameters are covered by a local\n-            // type constructor. Note that if there is no local type constructor, then any\n-            // type parameter at all will be an error.\n-            let covered_params = type_parameters_covered_by_ty(tcx, input_ty);\n-            let all_params = type_parameters_reachable_from_ty(input_ty);\n-            for &param in all_params.difference(&covered_params) {\n-                return Err(OrphanCheckErr::UncoveredTy(param));\n+    for input_ty in input_tys {\n+        if ty_is_local(tcx, input_ty, param_is_local) {\n+            debug!(\"orphan_check_trait_ref: ty_is_local `{}`\", input_ty.repr(tcx));\n+\n+            // First local input type. Check that there are no\n+            // uncovered type parameters.\n+            let uncovered_tys = uncovered_tys(tcx, input_ty, param_is_local);\n+            for uncovered_ty in uncovered_tys {\n+                if let Some(param) = uncovered_ty.walk().find(|t| is_type_parameter(t)) {\n+                    debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n+                    return Err(OrphanCheckErr::UncoveredTy(param));\n+                }\n             }\n+\n+            // OK, found local type, all prior types upheld invariant.\n+            return Ok(());\n         }\n-        None => {\n-            return Err(OrphanCheckErr::NoLocalInputType);\n+\n+        // Otherwise, enforce invariant that there are no type\n+        // parameters reachable.\n+        if !param_is_local.0 {\n+            if let Some(param) = input_ty.walk().find(|t| is_type_parameter(t)) {\n+                debug!(\"orphan_check_trait_ref: uncovered type `{}`\", param.repr(tcx));\n+                return Err(OrphanCheckErr::UncoveredTy(param));\n+            }\n         }\n     }\n \n-    return Ok(());\n+    // If we exit above loop, never found a local type.\n+    debug!(\"orphan_check_trait_ref: no local type\");\n+    return Err(OrphanCheckErr::NoLocalInputType);\n+}\n+\n+fn uncovered_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                       ty: Ty<'tcx>,\n+                       param_is_local: ParamIsLocal)\n+                       -> Vec<Ty<'tcx>>\n+{\n+    if ty_is_local_constructor(tcx, ty, param_is_local) {\n+        vec![]\n+    } else if fundamental_ty(tcx, ty) {\n+        ty.walk_shallow()\n+          .flat_map(|t| uncovered_tys(tcx, t, param_is_local).into_iter())\n+          .collect()\n+    } else {\n+        vec![ty]\n+    }\n }\n \n-fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n+    match ty.sty {\n+        // FIXME(#20590) straighten story about projection types\n+        ty::ty_projection(..) | ty::ty_param(..) => true,\n+        _ => false,\n+    }\n+}\n+\n+fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>, param_is_local: ParamIsLocal) -> bool\n+{\n+    ty_is_local_constructor(tcx, ty, param_is_local) ||\n+        fundamental_ty(tcx, ty) && ty.walk_shallow().any(|t| ty_is_local(tcx, t, param_is_local))\n+}\n+\n+fn fundamental_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool\n+{\n+    match ty.sty {\n+        ty::ty_uniq(..) | ty::ty_rptr(..) =>\n+            true,\n+        ty::ty_enum(def_id, _) | ty::ty_struct(def_id, _) =>\n+            ty::has_attr(tcx, def_id, \"fundamental\"),\n+        ty::ty_trait(ref data) =>\n+            ty::has_attr(tcx, data.principal_def_id(), \"fundamental\"),\n+        _ =>\n+            false\n+    }\n+}\n+\n+fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                 ty: Ty<'tcx>,\n+                                 param_is_local: ParamIsLocal)\n+                                 -> bool\n+{\n     debug!(\"ty_is_local_constructor({})\", ty.repr(tcx));\n \n     match ty.sty {\n@@ -190,11 +310,15 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_ptr(..) |\n         ty::ty_rptr(..) |\n         ty::ty_tup(..) |\n-        ty::ty_param(..) |\n+        ty::ty_infer(..) |\n         ty::ty_projection(..) => {\n             false\n         }\n \n+        ty::ty_param(..) => {\n+            param_is_local.0\n+        }\n+\n         ty::ty_enum(def_id, _) |\n         ty::ty_struct(def_id, _) => {\n             def_id.krate == ast::LOCAL_CRATE\n@@ -210,7 +334,6 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n \n         ty::ty_closure(..) |\n-        ty::ty_infer(..) |\n         ty::ty_err => {\n             tcx.sess.bug(\n                 &format!(\"ty_is_local invoked on unexpected type: {}\",\n@@ -219,30 +342,4 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-fn type_parameters_covered_by_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                       ty: Ty<'tcx>)\n-                                       -> HashSet<Ty<'tcx>>\n-{\n-    if ty_is_local_constructor(tcx, ty) {\n-        type_parameters_reachable_from_ty(ty)\n-    } else {\n-        ty.walk_children().flat_map(|t| type_parameters_covered_by_ty(tcx, t).into_iter()).collect()\n-    }\n-}\n-\n-/// All type parameters reachable from `ty`\n-fn type_parameters_reachable_from_ty<'tcx>(ty: Ty<'tcx>) -> HashSet<Ty<'tcx>> {\n-    ty.walk().filter(|&t| is_type_parameter(t)).collect()\n-}\n-\n-fn references_local_or_type_parameter<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.walk().any(|ty| is_type_parameter(ty) || ty_is_local_constructor(tcx, ty))\n-}\n \n-fn is_type_parameter<'tcx>(ty: Ty<'tcx>) -> bool {\n-    match ty.sty {\n-        // FIXME(#20590) straighten story about projection types\n-        ty::ty_projection(..) | ty::ty_param(..) => true,\n-        _ => false,\n-    }\n-}"}, {"sha": "7488b8f046e74eff8215258fe5127b4c99895384", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -81,7 +81,7 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n            obligation.repr(selcx.tcx()));\n \n     let infcx = selcx.infcx();\n-    infcx.try(|snapshot| {\n+    infcx.commit_if_ok(|snapshot| {\n         let (skol_predicate, skol_map) =\n             infcx.skolemize_late_bound_regions(&obligation.predicate, snapshot);\n \n@@ -291,6 +291,7 @@ impl<'a,'b,'tcx> TypeFolder<'tcx> for AssociatedTypeNormalizer<'a,'b,'tcx> {\n     }\n }\n \n+#[derive(Clone)]\n pub struct Normalized<'tcx,T> {\n     pub value: T,\n     pub obligations: Vec<PredicateObligation<'tcx>>,"}, {"sha": "bb2d37c944c86d3833f61e6943cd5e2e748f9dec", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 98, "deletions": 37, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -17,6 +17,7 @@ use self::SelectionCandidate::*;\n use self::BuiltinBoundConditions::*;\n use self::EvaluationResult::*;\n \n+use super::coherence;\n use super::DerivedObligationCause;\n use super::project;\n use super::project::{normalize_with_depth, Normalized};\n@@ -38,11 +39,13 @@ use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use middle::infer;\n use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n+use middle::ty_match;\n+use middle::ty_relate::TypeRelation;\n use std::cell::RefCell;\n-use std::collections::hash_map::HashMap;\n use std::rc::Rc;\n use syntax::{abi, ast};\n use util::common::ErrorReported;\n+use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n pub struct SelectionContext<'cx, 'tcx:'cx> {\n@@ -81,13 +84,13 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     /// selection-context's freshener. Used to check for recursion.\n     fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n-    previous: Option<&'prev TraitObligationStack<'prev, 'tcx>>\n+    previous: TraitObligationStackList<'prev, 'tcx>,\n }\n \n #[derive(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<HashMap<Rc<ty::TraitRef<'tcx>>,\n-                             SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n+    hashmap: RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+                                SelectionResult<'tcx, SelectionCandidate<'tcx>>>>,\n }\n \n pub enum MethodMatchResult {\n@@ -245,7 +248,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"select({})\", obligation.repr(self.tcx()));\n         assert!(!obligation.predicate.has_escaping_regions());\n \n-        let stack = self.push_stack(None, obligation);\n+        let stack = self.push_stack(TraitObligationStackList::empty(), obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n             None => {\n                 self.consider_unification_despite_ambiguity(obligation);\n@@ -327,7 +330,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n \n-        self.evaluate_predicate_recursively(None, obligation).may_apply()\n+        self.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+            .may_apply()\n     }\n \n     fn evaluate_builtin_bound_recursively<'o>(&mut self,\n@@ -346,7 +350,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match obligation {\n             Ok(obligation) => {\n-                self.evaluate_predicate_recursively(Some(previous_stack), &obligation)\n+                self.evaluate_predicate_recursively(previous_stack.list(), &obligation)\n             }\n             Err(ErrorReported) => {\n                 EvaluatedToOk\n@@ -355,7 +359,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn evaluate_predicates_recursively<'a,'o,I>(&mut self,\n-                                                stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                                stack: TraitObligationStackList<'o, 'tcx>,\n                                                 predicates: I)\n                                                 -> EvaluationResult<'tcx>\n         where I : Iterator<Item=&'a PredicateObligation<'tcx>>, 'tcx:'a\n@@ -372,7 +376,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn evaluate_predicate_recursively<'o>(&mut self,\n-                                          previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                          previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                           obligation: &PredicateObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n@@ -423,14 +427,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn evaluate_obligation_recursively<'o>(&mut self,\n-                                           previous_stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                                           previous_stack: TraitObligationStackList<'o, 'tcx>,\n                                            obligation: &TraitObligation<'tcx>)\n                                            -> EvaluationResult<'tcx>\n     {\n         debug!(\"evaluate_obligation_recursively({})\",\n                obligation.repr(self.tcx()));\n \n-        let stack = self.push_stack(previous_stack.map(|x| x), obligation);\n+        let stack = self.push_stack(previous_stack, obligation);\n \n         let result = self.evaluate_stack(&stack);\n \n@@ -472,7 +476,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             unbound_input_types &&\n              (self.intercrate ||\n               stack.iter().skip(1).any(\n-                  |prev| stack.fresh_trait_ref.def_id() == prev.fresh_trait_ref.def_id()))\n+                  |prev| self.match_fresh_trait_refs(&stack.fresh_trait_ref,\n+                                                     &prev.fresh_trait_ref)))\n         {\n             debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n                    stack.fresh_trait_ref.repr(self.tcx()));\n@@ -538,7 +543,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                        obligation.recursion_depth + 1,\n                                                        skol_map,\n                                                        snapshot);\n-                    self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n+                    self.winnow_selection(TraitObligationStackList::empty(),\n+                                          VtableImpl(vtable_impl)).may_apply()\n                 }\n                 Err(()) => {\n                     false\n@@ -607,6 +613,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Ok(Some(ErrorCandidate));\n         }\n \n+        if !self.is_knowable(stack) {\n+            debug!(\"intercrate not knowable\");\n+            return Ok(None);\n+        }\n+\n         let candidate_set = try!(self.assemble_candidates(stack));\n \n         if candidate_set.ambiguous {\n@@ -707,6 +718,27 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         Ok(Some(candidate))\n     }\n \n+    fn is_knowable<'o>(&mut self,\n+                       stack: &TraitObligationStack<'o, 'tcx>)\n+                       -> bool\n+    {\n+        debug!(\"is_knowable(intercrate={})\", self.intercrate);\n+\n+        if !self.intercrate {\n+            return true;\n+        }\n+\n+        let obligation = &stack.obligation;\n+        let predicate = self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n+\n+        // ok to skip binder because of the nature of the\n+        // trait-ref-is-knowable check, which does not care about\n+        // bound regions\n+        let trait_ref = &predicate.skip_binder().trait_ref;\n+\n+        coherence::trait_ref_is_knowable(self.tcx(), trait_ref)\n+    }\n+\n     fn pick_candidate_cache(&self) -> &SelectionCache<'tcx> {\n         // If there are any where-clauses in scope, then we always use\n         // a cache local to this particular scope. Otherwise, we\n@@ -1026,7 +1058,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx().probe(move |_| {\n             match self.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n-                    self.evaluate_predicates_recursively(Some(stack), obligations.iter())\n+                    self.evaluate_predicates_recursively(stack.list(), obligations.iter())\n                 }\n                 Err(()) => {\n                     EvaluatedToErr(Unimplemented)\n@@ -1242,7 +1274,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return;\n         }\n \n-        self.infcx.try(|snapshot| {\n+        self.infcx.commit_if_ok(|snapshot| {\n             let bound_self_ty =\n                 self.infcx.resolve_type_vars_if_possible(&obligation.self_ty());\n             let (self_ty, _) =\n@@ -1310,7 +1342,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let result = self.infcx.probe(|_| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n-                Ok(selection) => self.winnow_selection(Some(stack), selection),\n+                Ok(selection) => self.winnow_selection(stack.list(),\n+                                                       selection),\n                 Err(error) => EvaluatedToErr(error),\n             }\n         });\n@@ -1320,7 +1353,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn winnow_selection<'o>(&mut self,\n-                            stack: Option<&TraitObligationStack<'o, 'tcx>>,\n+                            stack: TraitObligationStackList<'o,'tcx>,\n                             selection: Selection<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n@@ -1778,7 +1811,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // For each type, produce a vector of resulting obligations\n         let obligations: Result<Vec<Vec<_>>, _> = bound_types.iter().map(|nested_ty| {\n-            self.infcx.try(|snapshot| {\n+            self.infcx.commit_if_ok(|snapshot| {\n                 let (skol_ty, skol_map) =\n                     self.infcx().skolemize_late_bound_regions(nested_ty, snapshot);\n                 let Normalized { value: normalized_ty, mut obligations } =\n@@ -1888,7 +1921,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     obligation: &TraitObligation<'tcx>)\n     {\n         let _: Result<(),()> =\n-            self.infcx.try(|snapshot| {\n+            self.infcx.commit_if_ok(|snapshot| {\n                 let result =\n                     self.match_projection_obligation_against_bounds_from_trait(obligation,\n                                                                                snapshot);\n@@ -2043,7 +2076,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                                 trait_def_id,\n                                                                 nested);\n \n-        let trait_obligations: Result<VecPerParamSpace<_>,()> = self.infcx.try(|snapshot| {\n+        let trait_obligations: Result<VecPerParamSpace<_>,()> = self.infcx.commit_if_ok(|snapshot| {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n                 self.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n@@ -2077,7 +2110,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        self.infcx.try(|snapshot| {\n+        self.infcx.commit_if_ok(|snapshot| {\n             let (skol_obligation_trait_ref, skol_map) =\n                 self.infcx().skolemize_late_bound_regions(&obligation.predicate, snapshot);\n             let substs =\n@@ -2303,9 +2336,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             return Err(());\n         }\n \n-        let impl_substs = util::fresh_substs_for_impl(self.infcx,\n-                                                      obligation.cause.span,\n-                                                      impl_def_id);\n+        let impl_substs = util::fresh_type_vars_for_impl(self.infcx,\n+                                                         obligation.cause.span,\n+                                                         impl_def_id);\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n                                                   &impl_substs);\n@@ -2423,9 +2456,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         // Create fresh type variables for each type parameter declared\n         // on the impl etc.\n-        let impl_substs = util::fresh_substs_for_impl(self.infcx,\n-                                                      obligation_cause.span,\n-                                                      impl_def_id);\n+        let impl_substs = util::fresh_type_vars_for_impl(self.infcx,\n+                                                         obligation_cause.span,\n+                                                         impl_def_id);\n \n         // Find the self type for the impl.\n         let impl_self_ty = ty::lookup_item_type(self.tcx(), impl_def_id).ty;\n@@ -2475,8 +2508,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // Miscellany\n \n+    fn match_fresh_trait_refs(&self,\n+                              previous: &ty::PolyTraitRef<'tcx>,\n+                              current: &ty::PolyTraitRef<'tcx>)\n+                              -> bool\n+    {\n+        let mut matcher = ty_match::Match::new(self.tcx());\n+        matcher.relate(previous, current).is_ok()\n+    }\n+\n     fn push_stack<'o,'s:'o>(&mut self,\n-                            previous_stack: Option<&'s TraitObligationStack<'s, 'tcx>>,\n+                            previous_stack: TraitObligationStackList<'s, 'tcx>,\n                             obligation: &'o TraitObligation<'tcx>)\n                             -> TraitObligationStack<'o, 'tcx>\n     {\n@@ -2486,7 +2528,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         TraitObligationStack {\n             obligation: obligation,\n             fresh_trait_ref: fresh_trait_ref,\n-            previous: previous_stack.map(|p| p), // FIXME variance\n+            previous: previous_stack,\n         }\n     }\n \n@@ -2634,22 +2676,41 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n impl<'tcx> SelectionCache<'tcx> {\n     pub fn new() -> SelectionCache<'tcx> {\n         SelectionCache {\n-            hashmap: RefCell::new(HashMap::new())\n+            hashmap: RefCell::new(FnvHashMap())\n         }\n     }\n }\n \n-impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n-    fn iter(&self) -> Option<&TraitObligationStack<'o, 'tcx>> {\n-        Some(self)\n+impl<'o,'tcx> TraitObligationStack<'o,'tcx> {\n+    fn list(&'o self) -> TraitObligationStackList<'o,'tcx> {\n+        TraitObligationStackList::with(self)\n     }\n+\n+    fn iter(&'o self) -> TraitObligationStackList<'o,'tcx> {\n+        self.list()\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+struct TraitObligationStackList<'o,'tcx:'o> {\n+    head: Option<&'o TraitObligationStack<'o,'tcx>>\n }\n \n-impl<'o, 'tcx> Iterator for Option<&'o TraitObligationStack<'o, 'tcx>> {\n+impl<'o,'tcx> TraitObligationStackList<'o,'tcx> {\n+    fn empty() -> TraitObligationStackList<'o,'tcx> {\n+        TraitObligationStackList { head: None }\n+    }\n+\n+    fn with(r: &'o TraitObligationStack<'o,'tcx>) -> TraitObligationStackList<'o,'tcx> {\n+        TraitObligationStackList { head: Some(r) }\n+    }\n+}\n+\n+impl<'o,'tcx> Iterator for TraitObligationStackList<'o,'tcx>{\n     type Item = &'o TraitObligationStack<'o,'tcx>;\n \n-    fn next(&mut self) -> Option<&'o TraitObligationStack<'o, 'tcx>> {\n-        match *self {\n+    fn next(&mut self) -> Option<&'o TraitObligationStack<'o,'tcx>> {\n+        match self.head {\n             Some(o) => {\n                 *self = o.previous;\n                 Some(o)\n@@ -2659,7 +2720,7 @@ impl<'o, 'tcx> Iterator for Option<&'o TraitObligationStack<'o, 'tcx>> {\n     }\n }\n \n-impl<'o, 'tcx> Repr<'tcx> for TraitObligationStack<'o, 'tcx> {\n+impl<'o,'tcx> Repr<'tcx> for TraitObligationStack<'o,'tcx> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"TraitObligationStack({})\",\n                 self.obligation.repr(tcx))"}, {"sha": "297cea13207e57a99a5f9871db3e36b9e8a752dd", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::region;\n use middle::subst::{Substs, VecPerParamSpace};\n use middle::infer::InferCtxt;\n use middle::ty::{self, Ty, AsPredicate, ToPolyTraitRef};\n@@ -285,7 +286,6 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n     }\n }\n \n-\n ///////////////////////////////////////////////////////////////////////////\n // Other\n ///////////////////////////////////////////////////////////////////////////\n@@ -294,16 +294,44 @@ impl<'tcx,I:Iterator<Item=ty::Predicate<'tcx>>> Iterator for FilterToTraits<I> {\n // declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n // would return ($0, $1) where $0 and $1 are freshly instantiated type\n // variables.\n-pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n-                                       span: Span,\n-                                       impl_def_id: ast::DefId)\n-                                       -> Substs<'tcx>\n+pub fn fresh_type_vars_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                          span: Span,\n+                                          impl_def_id: ast::DefId)\n+                                          -> Substs<'tcx>\n {\n     let tcx = infcx.tcx;\n     let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n+// determine the `self` type, using fresh variables for all variables\n+// declared on the impl declaration e.g., `impl<A,B> for Box<[(A,B)]>`\n+// would return ($0, $1) where $0 and $1 are freshly instantiated type\n+// variables.\n+pub fn free_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n+                                      _span: Span,\n+                                      impl_def_id: ast::DefId)\n+                                      -> Substs<'tcx>\n+{\n+    let tcx = infcx.tcx;\n+    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n+\n+    let some_types = impl_generics.types.map(|def| {\n+        ty::mk_param_from_def(tcx, def)\n+    });\n+\n+    let some_regions = impl_generics.regions.map(|def| {\n+        // FIXME. This destruction scope information is pretty darn\n+        // bogus; after all, the impl might not even be in this crate!\n+        // But given what we do in coherence, it is harmless enough\n+        // for now I think. -nmatsakis\n+        let extent = region::DestructionScopeData::new(ast::DUMMY_NODE_ID);\n+        ty::free_region_from_def(extent, def)\n+    });\n+\n+    Substs::new(some_types, some_regions)\n+}\n+\n impl<'tcx, N> fmt::Debug for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({:?})\", self.impl_def_id)"}, {"sha": "0814ec2c84e7085f62573c1d6b9235ed6a9f9867", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -58,7 +58,7 @@ use middle::subst::{self, ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n-use middle::ty_walk::TypeWalker;\n+use middle::ty_walk::{self, TypeWalker};\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::ty_to_string;\n use util::ppaux::{Repr, UserString};\n@@ -89,7 +89,8 @@ use syntax::codemap::Span;\n use syntax::parse::token::{self, InternedString, special_idents};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::{ast, ast_map};\n+use syntax::ast;\n+use syntax::ast_map::{self, LinkedPath};\n \n pub type Disr = u64;\n \n@@ -3167,21 +3168,11 @@ impl<'tcx> TyS<'tcx> {\n         TypeWalker::new(self)\n     }\n \n-    /// Iterator that walks types reachable from `self`, in\n-    /// depth-first order. Note that this is a shallow walk. For\n-    /// example:\n-    ///\n-    /// ```notrust\n-    /// isize => { }\n-    /// Foo<Bar<isize>> => { Bar<isize>, isize }\n-    /// [isize] => { isize }\n-    /// ```\n-    pub fn walk_children(&'tcx self) -> TypeWalker<'tcx> {\n-        // Walks type reachable from `self` but not `self\n-        let mut walker = self.walk();\n-        let r = walker.next();\n-        assert_eq!(r, Some(self));\n-        walker\n+    /// Iterator that walks the immediate children of `self`.  Hence\n+    /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n+    /// (but not `i32`, like `walk`).\n+    pub fn walk_shallow(&'tcx self) -> IntoIter<Ty<'tcx>> {\n+        ty_walk::walk_shallow(self)\n     }\n \n     pub fn as_opt_param_ty(&self) -> Option<ty::ParamTy> {\n@@ -5484,7 +5475,7 @@ pub fn with_path<T, F>(cx: &ctxt, id: ast::DefId, f: F) -> T where\n     if id.krate == ast::LOCAL_CRATE {\n         cx.map.with_path(id.node, f)\n     } else {\n-        f(csearch::get_item_path(cx, id).iter().cloned().chain(None))\n+        f(csearch::get_item_path(cx, id).iter().cloned().chain(LinkedPath::empty()))\n     }\n }\n "}, {"sha": "5f77574f65ed4351692f8cc5868678bd73117b25", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -39,6 +39,8 @@ use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n use middle::traits;\n use std::rc::Rc;\n+use syntax::abi;\n+use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n use util::ppaux::Repr;\n \n@@ -47,7 +49,7 @@ use util::ppaux::Repr;\n \n /// The TypeFoldable trait is implemented for every type that can be folded.\n /// Basically, every type that has a corresponding method in TypeFolder.\n-pub trait TypeFoldable<'tcx> {\n+pub trait TypeFoldable<'tcx>: Repr<'tcx> + Clone {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n }\n \n@@ -149,12 +151,20 @@ pub trait TypeFolder<'tcx> : Sized {\n // can easily refactor the folding into the TypeFolder trait as\n // needed.\n \n-impl<'tcx> TypeFoldable<'tcx> for () {\n-    fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> () {\n-        ()\n+macro_rules! CopyImpls {\n+    ($($ty:ty),+) => {\n+        $(\n+            impl<'tcx> TypeFoldable<'tcx> for $ty {\n+                fn fold_with<F:TypeFolder<'tcx>>(&self, _: &mut F) -> $ty {\n+                    *self\n+                }\n+            }\n+        )+\n     }\n }\n \n+CopyImpls! { (), ast::Unsafety, abi::Abi }\n+\n impl<'tcx, T:TypeFoldable<'tcx>, U:TypeFoldable<'tcx>> TypeFoldable<'tcx> for (T, U) {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n         (self.0.fold_with(folder), self.1.fold_with(folder))"}, {"sha": "bb00fadc39c95c062ab61c9ccc3b04794797e9ef", "filename": "src/librustc/middle/ty_match.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_match.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use middle::ty::{self, Ty};\n+use middle::ty_relate::{self, Relate, TypeRelation, RelateResult};\n+use util::ppaux::Repr;\n+\n+/// A type \"A\" *matches* \"B\" if the fresh types in B could be\n+/// substituted with values so as to make it equal to A. Matching is\n+/// intended to be used only on freshened types, and it basically\n+/// indicates if the non-freshened versions of A and B could have been\n+/// unified.\n+///\n+/// It is only an approximation. If it yields false, unification would\n+/// definitely fail, but a true result doesn't mean unification would\n+/// succeed. This is because we don't track the \"side-constraints\" on\n+/// type variables, nor do we track if the same freshened type appears\n+/// more than once. To some extent these approximations could be\n+/// fixed, given effort.\n+///\n+/// Like subtyping, matching is really a binary relation, so the only\n+/// important thing about the result is Ok/Err. Also, matching never\n+/// affects any type variables or unification state.\n+pub struct Match<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>\n+}\n+\n+impl<'a, 'tcx> Match<'a, 'tcx> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>) -> Match<'a, 'tcx> {\n+        Match { tcx: tcx }\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n+    fn tag(&self) -> &'static str { \"Match\" }\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+    fn a_is_expected(&self) -> bool { true } // irrelevant\n+\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               _: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>\n+    {\n+        self.relate(a, b)\n+    }\n+\n+    fn regions(&mut self, a: ty::Region, b: ty::Region) -> RelateResult<'tcx, ty::Region> {\n+        debug!(\"{}.regions({}, {})\",\n+               self.tag(),\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n+        Ok(a)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"{}.tys({}, {})\", self.tag(),\n+               a.repr(self.tcx()), b.repr(self.tcx()));\n+        if a == b { return Ok(a); }\n+\n+        match (&a.sty, &b.sty) {\n+            (_, &ty::ty_infer(ty::FreshTy(_))) |\n+            (_, &ty::ty_infer(ty::FreshIntTy(_))) => {\n+                Ok(a)\n+            }\n+\n+            (&ty::ty_infer(_), _) |\n+            (_, &ty::ty_infer(_)) => {\n+                Err(ty::terr_sorts(ty_relate::expected_found(self, &a, &b)))\n+            }\n+\n+            (&ty::ty_err, _) | (_, &ty::ty_err) => {\n+                Ok(self.tcx().types.err)\n+            }\n+\n+            _ => {\n+                ty_relate::super_relate_tys(self, a, b)\n+            }\n+        }\n+    }\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>\n+    {\n+        Ok(ty::Binder(try!(self.relate(a.skip_binder(), b.skip_binder()))))\n+    }\n+}"}, {"sha": "1205b7d957930aaf8f25a0f540efe074a62f43f9", "filename": "src/librustc/middle/ty_relate/mod.rs", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_relate%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,655 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Generalized type relating mechanism. A type relation R relates a\n+//! pair of values (A, B). A and B are usually types or regions but\n+//! can be other things. Examples of type relations are subtyping,\n+//! type equality, etc.\n+\n+use middle::subst::{ErasedRegions, NonerasedRegions, ParamSpace, Substs};\n+use middle::ty::{self, Ty};\n+use middle::ty_fold::TypeFoldable;\n+use std::rc::Rc;\n+use syntax::abi;\n+use syntax::ast;\n+use util::ppaux::Repr;\n+\n+pub type RelateResult<'tcx, T> = Result<T, ty::type_err<'tcx>>;\n+\n+pub trait TypeRelation<'a,'tcx> : Sized {\n+    fn tcx(&self) -> &'a ty::ctxt<'tcx>;\n+\n+    /// Returns a static string we can use for printouts.\n+    fn tag(&self) -> &'static str;\n+\n+    /// Returns true if the value `a` is the \"expected\" type in the\n+    /// relation. Just affects error messages.\n+    fn a_is_expected(&self) -> bool;\n+\n+    /// Generic relation routine suitable for most anything.\n+    fn relate<T:Relate<'a,'tcx>>(&mut self, a: &T, b: &T) -> RelateResult<'tcx, T> {\n+        Relate::relate(self, a, b)\n+    }\n+\n+    /// Switch variance for the purpose of relating `a` and `b`.\n+    fn relate_with_variance<T:Relate<'a,'tcx>>(&mut self,\n+                                               variance: ty::Variance,\n+                                               a: &T,\n+                                               b: &T)\n+                                               -> RelateResult<'tcx, T>;\n+\n+    // Overrideable relations. You shouldn't typically call these\n+    // directly, instead call `relate()`, which in turn calls\n+    // these. This is both more uniform but also allows us to add\n+    // additional hooks for other types in the future if needed\n+    // without making older code, which called `relate`, obsolete.\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>)\n+           -> RelateResult<'tcx, Ty<'tcx>>;\n+\n+    fn regions(&mut self, a: ty::Region, b: ty::Region)\n+               -> RelateResult<'tcx, ty::Region>;\n+\n+    fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n+                  -> RelateResult<'tcx, ty::Binder<T>>\n+        where T: Relate<'a,'tcx>;\n+}\n+\n+pub trait Relate<'a,'tcx>: TypeFoldable<'tcx> {\n+    fn relate<R:TypeRelation<'a,'tcx>>(relation: &mut R,\n+                                       a: &Self,\n+                                       b: &Self)\n+                                       -> RelateResult<'tcx, Self>;\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Relate impls\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::mt<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::mt<'tcx>,\n+                 b: &ty::mt<'tcx>)\n+                 -> RelateResult<'tcx, ty::mt<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        debug!(\"{}.mts({}, {})\",\n+               relation.tag(),\n+               a.repr(relation.tcx()),\n+               b.repr(relation.tcx()));\n+        if a.mutbl != b.mutbl {\n+            Err(ty::terr_mutability)\n+        } else {\n+            let mutbl = a.mutbl;\n+            let variance = match mutbl {\n+                ast::MutImmutable => ty::Covariant,\n+                ast::MutMutable => ty::Invariant,\n+            };\n+            let ty = try!(relation.relate_with_variance(variance, &a.ty, &b.ty));\n+            Ok(ty::mt {ty: ty, mutbl: mutbl})\n+        }\n+    }\n+}\n+\n+// substitutions are not themselves relatable without more context,\n+// but they is an important subroutine for things that ARE relatable,\n+// like traits etc.\n+fn relate_item_substs<'a,'tcx:'a,R>(relation: &mut R,\n+                                    item_def_id: ast::DefId,\n+                                    a_subst: &Substs<'tcx>,\n+                                    b_subst: &Substs<'tcx>)\n+                                    -> RelateResult<'tcx, Substs<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    debug!(\"substs: item_def_id={} a_subst={} b_subst={}\",\n+           item_def_id.repr(relation.tcx()),\n+           a_subst.repr(relation.tcx()),\n+           b_subst.repr(relation.tcx()));\n+\n+    let variances;\n+    let opt_variances = if relation.tcx().variance_computed.get() {\n+        variances = ty::item_variances(relation.tcx(), item_def_id);\n+        Some(&*variances)\n+    } else {\n+        None\n+    };\n+    relate_substs(relation, opt_variances, a_subst, b_subst)\n+}\n+\n+fn relate_substs<'a,'tcx,R>(relation: &mut R,\n+                            variances: Option<&ty::ItemVariances>,\n+                            a_subst: &Substs<'tcx>,\n+                            b_subst: &Substs<'tcx>)\n+                            -> RelateResult<'tcx, Substs<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let mut substs = Substs::empty();\n+\n+    for &space in &ParamSpace::all() {\n+        let a_tps = a_subst.types.get_slice(space);\n+        let b_tps = b_subst.types.get_slice(space);\n+        let t_variances = variances.map(|v| v.types.get_slice(space));\n+        let tps = try!(relate_type_params(relation, t_variances, a_tps, b_tps));\n+        substs.types.replace(space, tps);\n+    }\n+\n+    match (&a_subst.regions, &b_subst.regions) {\n+        (&ErasedRegions, _) | (_, &ErasedRegions) => {\n+            substs.regions = ErasedRegions;\n+        }\n+\n+        (&NonerasedRegions(ref a), &NonerasedRegions(ref b)) => {\n+            for &space in &ParamSpace::all() {\n+                let a_regions = a.get_slice(space);\n+                let b_regions = b.get_slice(space);\n+                let r_variances = variances.map(|v| v.regions.get_slice(space));\n+                let regions = try!(relate_region_params(relation,\n+                                                        r_variances,\n+                                                        a_regions,\n+                                                        b_regions));\n+                substs.mut_regions().replace(space, regions);\n+            }\n+        }\n+    }\n+\n+    Ok(substs)\n+}\n+\n+fn relate_type_params<'a,'tcx,R>(relation: &mut R,\n+                                 variances: Option<&[ty::Variance]>,\n+                                 a_tys: &[Ty<'tcx>],\n+                                 b_tys: &[Ty<'tcx>])\n+                                 -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    if a_tys.len() != b_tys.len() {\n+        return Err(ty::terr_ty_param_size(expected_found(relation,\n+                                                         &a_tys.len(),\n+                                                         &b_tys.len())));\n+    }\n+\n+    (0 .. a_tys.len())\n+        .map(|i| {\n+            let a_ty = a_tys[i];\n+            let b_ty = b_tys[i];\n+            let v = variances.map_or(ty::Invariant, |v| v[i]);\n+            relation.relate_with_variance(v, &a_ty, &b_ty)\n+        })\n+        .collect()\n+}\n+\n+fn relate_region_params<'a,'tcx:'a,R>(relation: &mut R,\n+                                      variances: Option<&[ty::Variance]>,\n+                                      a_rs: &[ty::Region],\n+                                      b_rs: &[ty::Region])\n+                                      -> RelateResult<'tcx, Vec<ty::Region>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let tcx = relation.tcx();\n+    let num_region_params = a_rs.len();\n+\n+    debug!(\"relate_region_params(a_rs={}, \\\n+            b_rs={}, variances={})\",\n+           a_rs.repr(tcx),\n+           b_rs.repr(tcx),\n+           variances.repr(tcx));\n+\n+    assert_eq!(num_region_params,\n+               variances.map_or(num_region_params,\n+                                |v| v.len()));\n+\n+    assert_eq!(num_region_params, b_rs.len());\n+\n+    (0..a_rs.len())\n+        .map(|i| {\n+            let a_r = a_rs[i];\n+            let b_r = b_rs[i];\n+            let variance = variances.map_or(ty::Invariant, |v| v[i]);\n+            relation.relate_with_variance(variance, &a_r, &b_r)\n+        })\n+        .collect()\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BareFnTy<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::BareFnTy<'tcx>,\n+                 b: &ty::BareFnTy<'tcx>)\n+                 -> RelateResult<'tcx, ty::BareFnTy<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let unsafety = try!(relation.relate(&a.unsafety, &b.unsafety));\n+        let abi = try!(relation.relate(&a.abi, &b.abi));\n+        let sig = try!(relation.relate(&a.sig, &b.sig));\n+        Ok(ty::BareFnTy {unsafety: unsafety,\n+                         abi: abi,\n+                         sig: sig})\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::FnSig<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::FnSig<'tcx>,\n+                 b: &ty::FnSig<'tcx>)\n+                 -> RelateResult<'tcx, ty::FnSig<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a.variadic != b.variadic {\n+            return Err(ty::terr_variadic_mismatch(\n+                expected_found(relation, &a.variadic, &b.variadic)));\n+        }\n+\n+        let inputs = try!(relate_arg_vecs(relation,\n+                                          &a.inputs,\n+                                          &b.inputs));\n+\n+        let output = try!(match (a.output, b.output) {\n+            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n+                Ok(ty::FnConverging(try!(relation.relate(&a_ty, &b_ty)))),\n+            (ty::FnDiverging, ty::FnDiverging) =>\n+                Ok(ty::FnDiverging),\n+            (a, b) =>\n+                Err(ty::terr_convergence_mismatch(\n+                    expected_found(relation, &(a != ty::FnDiverging), &(b != ty::FnDiverging)))),\n+        });\n+\n+        return Ok(ty::FnSig {inputs: inputs,\n+                             output: output,\n+                             variadic: a.variadic});\n+    }\n+}\n+\n+fn relate_arg_vecs<'a,'tcx,R>(relation: &mut R,\n+                              a_args: &[Ty<'tcx>],\n+                              b_args: &[Ty<'tcx>])\n+                              -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    if a_args.len() != b_args.len() {\n+        return Err(ty::terr_arg_count);\n+    }\n+\n+    a_args.iter()\n+          .zip(b_args.iter())\n+          .map(|(a, b)| relation.relate_with_variance(ty::Contravariant, a, b))\n+          .collect()\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ast::Unsafety {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ast::Unsafety,\n+                 b: &ast::Unsafety)\n+                 -> RelateResult<'tcx, ast::Unsafety>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a != b {\n+            Err(ty::terr_unsafety_mismatch(expected_found(relation, a, b)))\n+        } else {\n+            Ok(*a)\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for abi::Abi {\n+    fn relate<R>(relation: &mut R,\n+                 a: &abi::Abi,\n+                 b: &abi::Abi)\n+                 -> RelateResult<'tcx, abi::Abi>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a == b {\n+            Ok(*a)\n+        } else {\n+            Err(ty::terr_abi_mismatch(expected_found(relation, a, b)))\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionTy<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ProjectionTy<'tcx>,\n+                 b: &ty::ProjectionTy<'tcx>)\n+                 -> RelateResult<'tcx, ty::ProjectionTy<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        if a.item_name != b.item_name {\n+            Err(ty::terr_projection_name_mismatched(\n+                expected_found(relation, &a.item_name, &b.item_name)))\n+        } else {\n+            let trait_ref = try!(relation.relate(&*a.trait_ref, &*b.trait_ref));\n+            Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ProjectionPredicate<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ProjectionPredicate<'tcx>,\n+                 b: &ty::ProjectionPredicate<'tcx>)\n+                 -> RelateResult<'tcx, ty::ProjectionPredicate<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let projection_ty = try!(relation.relate(&a.projection_ty, &b.projection_ty));\n+        let ty = try!(relation.relate(&a.ty, &b.ty));\n+        Ok(ty::ProjectionPredicate { projection_ty: projection_ty, ty: ty })\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for Vec<ty::PolyProjectionPredicate<'tcx>> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &Vec<ty::PolyProjectionPredicate<'tcx>>,\n+                 b: &Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                 -> RelateResult<'tcx, Vec<ty::PolyProjectionPredicate<'tcx>>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        // To be compatible, `a` and `b` must be for precisely the\n+        // same set of traits and item names. We always require that\n+        // projection bounds lists are sorted by trait-def-id and item-name,\n+        // so we can just iterate through the lists pairwise, so long as they are the\n+        // same length.\n+        if a.len() != b.len() {\n+            Err(ty::terr_projection_bounds_length(expected_found(relation, &a.len(), &b.len())))\n+        } else {\n+            a.iter()\n+                .zip(b.iter())\n+                .map(|(a, b)| relation.relate(a, b))\n+                .collect()\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::ExistentialBounds<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::ExistentialBounds<'tcx>,\n+                 b: &ty::ExistentialBounds<'tcx>)\n+                 -> RelateResult<'tcx, ty::ExistentialBounds<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let r = try!(relation.relate_with_variance(ty::Contravariant,\n+                                                   &a.region_bound,\n+                                                   &b.region_bound));\n+        let nb = try!(relation.relate(&a.builtin_bounds, &b.builtin_bounds));\n+        let pb = try!(relation.relate(&a.projection_bounds, &b.projection_bounds));\n+        Ok(ty::ExistentialBounds { region_bound: r,\n+                                   builtin_bounds: nb,\n+                                   projection_bounds: pb })\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::BuiltinBounds {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::BuiltinBounds,\n+                 b: &ty::BuiltinBounds)\n+                 -> RelateResult<'tcx, ty::BuiltinBounds>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        // Two sets of builtin bounds are only relatable if they are\n+        // precisely the same (but see the coercion code).\n+        if a != b {\n+            Err(ty::terr_builtin_bounds(expected_found(relation, a, b)))\n+        } else {\n+            Ok(*a)\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::TraitRef<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::TraitRef<'tcx>,\n+                 b: &ty::TraitRef<'tcx>)\n+                 -> RelateResult<'tcx, ty::TraitRef<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        // Different traits cannot be related\n+        if a.def_id != b.def_id {\n+            Err(ty::terr_traits(expected_found(relation, &a.def_id, &b.def_id)))\n+        } else {\n+            let substs = try!(relate_item_substs(relation, a.def_id, a.substs, b.substs));\n+            Ok(ty::TraitRef { def_id: a.def_id, substs: relation.tcx().mk_substs(substs) })\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for Ty<'tcx> {\n+    fn relate<R>(relation: &mut R,\n+                 a: &Ty<'tcx>,\n+                 b: &Ty<'tcx>)\n+                 -> RelateResult<'tcx, Ty<'tcx>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relation.tys(a, b)\n+    }\n+}\n+\n+/// The main \"type relation\" routine. Note that this does not handle\n+/// inference artifacts, so you should filter those out before calling\n+/// it.\n+pub fn super_relate_tys<'a,'tcx:'a,R>(relation: &mut R,\n+                                      a: Ty<'tcx>,\n+                                      b: Ty<'tcx>)\n+                                      -> RelateResult<'tcx, Ty<'tcx>>\n+    where R: TypeRelation<'a,'tcx>\n+{\n+    let tcx = relation.tcx();\n+    let a_sty = &a.sty;\n+    let b_sty = &b.sty;\n+    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n+    match (a_sty, b_sty) {\n+        (&ty::ty_infer(_), _) |\n+        (_, &ty::ty_infer(_)) =>\n+        {\n+            // The caller should handle these cases!\n+            tcx.sess.bug(\"var types encountered in super_relate_tys\")\n+        }\n+\n+        (&ty::ty_err, _) | (_, &ty::ty_err) =>\n+        {\n+            Ok(tcx.types.err)\n+        }\n+\n+        (&ty::ty_char, _) |\n+        (&ty::ty_bool, _) |\n+        (&ty::ty_int(_), _) |\n+        (&ty::ty_uint(_), _) |\n+        (&ty::ty_float(_), _) |\n+        (&ty::ty_str, _)\n+            if a == b =>\n+        {\n+            Ok(a)\n+        }\n+\n+        (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p))\n+            if a_p.idx == b_p.idx && a_p.space == b_p.space =>\n+        {\n+            Ok(a)\n+        }\n+\n+        (&ty::ty_enum(a_id, a_substs), &ty::ty_enum(b_id, b_substs))\n+            if a_id == b_id =>\n+        {\n+            let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n+            Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_trait(ref a_), &ty::ty_trait(ref b_)) =>\n+        {\n+            let principal = try!(relation.relate(&a_.principal, &b_.principal));\n+            let bounds = try!(relation.relate(&a_.bounds, &b_.bounds));\n+            Ok(ty::mk_trait(tcx, principal, bounds))\n+        }\n+\n+        (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n+            if a_id == b_id =>\n+        {\n+            let substs = try!(relate_item_substs(relation, a_id, a_substs, b_substs));\n+            Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_closure(a_id, a_substs),\n+         &ty::ty_closure(b_id, b_substs))\n+            if a_id == b_id =>\n+        {\n+            // All ty_closure types with the same id represent\n+            // the (anonymous) type of the same closure expression. So\n+            // all of their regions should be equated.\n+            let substs = try!(relate_substs(relation, None, a_substs, b_substs));\n+            Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) =>\n+        {\n+            let typ = try!(relation.relate(&a_inner, &b_inner));\n+            Ok(ty::mk_uniq(tcx, typ))\n+        }\n+\n+        (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) =>\n+        {\n+            let mt = try!(relation.relate(a_mt, b_mt));\n+            Ok(ty::mk_ptr(tcx, mt))\n+        }\n+\n+        (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) =>\n+        {\n+            let r = try!(relation.relate_with_variance(ty::Contravariant, a_r, b_r));\n+            let mt = try!(relation.relate(a_mt, b_mt));\n+            Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n+        }\n+\n+        (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) =>\n+        {\n+            let t = try!(relation.relate(&a_t, &b_t));\n+            if sz_a == sz_b {\n+                Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n+            } else {\n+                Err(ty::terr_fixed_array_size(expected_found(relation, &sz_a, &sz_b)))\n+            }\n+        }\n+\n+        (&ty::ty_vec(a_t, None), &ty::ty_vec(b_t, None)) =>\n+        {\n+            let t = try!(relation.relate(&a_t, &b_t));\n+            Ok(ty::mk_vec(tcx, t, None))\n+        }\n+\n+        (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) =>\n+        {\n+            if as_.len() == bs.len() {\n+                let ts = try!(as_.iter()\n+                                 .zip(bs.iter())\n+                                 .map(|(a, b)| relation.relate(a, b))\n+                                 .collect::<Result<_, _>>());\n+                Ok(ty::mk_tup(tcx, ts))\n+            } else if as_.len() != 0 && bs.len() != 0 {\n+                Err(ty::terr_tuple_size(\n+                    expected_found(relation, &as_.len(), &bs.len())))\n+            } else {\n+                Err(ty::terr_sorts(expected_found(relation, &a, &b)))\n+            }\n+        }\n+\n+        (&ty::ty_bare_fn(a_opt_def_id, a_fty), &ty::ty_bare_fn(b_opt_def_id, b_fty))\n+            if a_opt_def_id == b_opt_def_id =>\n+        {\n+            let fty = try!(relation.relate(a_fty, b_fty));\n+            Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n+        }\n+\n+        (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) =>\n+        {\n+            let projection_ty = try!(relation.relate(a_data, b_data));\n+            Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n+        }\n+\n+        _ =>\n+        {\n+            Err(ty::terr_sorts(expected_found(relation, &a, &b)))\n+        }\n+    }\n+}\n+\n+impl<'a,'tcx:'a> Relate<'a,'tcx> for ty::Region {\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::Region,\n+                 b: &ty::Region)\n+                 -> RelateResult<'tcx, ty::Region>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relation.regions(*a, *b)\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T> Relate<'a,'tcx> for ty::Binder<T>\n+    where T: Relate<'a,'tcx>\n+{\n+    fn relate<R>(relation: &mut R,\n+                 a: &ty::Binder<T>,\n+                 b: &ty::Binder<T>)\n+                 -> RelateResult<'tcx, ty::Binder<T>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        relation.binders(a, b)\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Rc<T>\n+    where T: Relate<'a,'tcx>\n+{\n+    fn relate<R>(relation: &mut R,\n+                 a: &Rc<T>,\n+                 b: &Rc<T>)\n+                 -> RelateResult<'tcx, Rc<T>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let a: &T = a;\n+        let b: &T = b;\n+        Ok(Rc::new(try!(relation.relate(a, b))))\n+    }\n+}\n+\n+impl<'a,'tcx:'a,T> Relate<'a,'tcx> for Box<T>\n+    where T: Relate<'a,'tcx>\n+{\n+    fn relate<R>(relation: &mut R,\n+                 a: &Box<T>,\n+                 b: &Box<T>)\n+                 -> RelateResult<'tcx, Box<T>>\n+        where R: TypeRelation<'a,'tcx>\n+    {\n+        let a: &T = a;\n+        let b: &T = b;\n+        Ok(Box::new(try!(relation.relate(a, b))))\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Error handling\n+\n+pub fn expected_found<'a,'tcx,R,T>(relation: &mut R,\n+                                   a: &T,\n+                                   b: &T)\n+                                   -> ty::expected_found<T>\n+    where R: TypeRelation<'a,'tcx>, T: Clone\n+{\n+    expected_found_bool(relation.a_is_expected(), a, b)\n+}\n+\n+pub fn expected_found_bool<T>(a_is_expected: bool,\n+                              a: &T,\n+                              b: &T)\n+                              -> ty::expected_found<T>\n+    where T: Clone\n+{\n+    let a = a.clone();\n+    let b = b.clone();\n+    if a_is_expected {\n+        ty::expected_found {expected: a, found: b}\n+    } else {\n+        ty::expected_found {expected: b, found: a}\n+    }\n+}\n+"}, {"sha": "ec09d6dcc1ee2c05e35f121c7b4d1e5e7af6f942", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 62, "deletions": 55, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -12,6 +12,7 @@\n \n use middle::ty::{self, Ty};\n use std::iter::Iterator;\n+use std::vec::IntoIter;\n \n pub struct TypeWalker<'tcx> {\n     stack: Vec<Ty<'tcx>>,\n@@ -23,60 +24,6 @@ impl<'tcx> TypeWalker<'tcx> {\n         TypeWalker { stack: vec!(ty), last_subtree: 1, }\n     }\n \n-    fn push_subtypes(&mut self, parent_ty: Ty<'tcx>) {\n-        match parent_ty.sty {\n-            ty::ty_bool | ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n-            ty::ty_str | ty::ty_infer(_) | ty::ty_param(_) | ty::ty_err => {\n-            }\n-            ty::ty_uniq(ty) | ty::ty_vec(ty, _) => {\n-                self.stack.push(ty);\n-            }\n-            ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n-                self.stack.push(mt.ty);\n-            }\n-            ty::ty_projection(ref data) => {\n-                self.push_reversed(data.trait_ref.substs.types.as_slice());\n-            }\n-            ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n-                self.push_reversed(principal.substs().types.as_slice());\n-                self.push_reversed(&bounds.projection_bounds.iter().map(|pred| {\n-                    pred.0.ty\n-                }).collect::<Vec<_>>());\n-            }\n-            ty::ty_enum(_, ref substs) |\n-            ty::ty_struct(_, ref substs) |\n-            ty::ty_closure(_, ref substs) => {\n-                self.push_reversed(substs.types.as_slice());\n-            }\n-            ty::ty_tup(ref ts) => {\n-                self.push_reversed(ts);\n-            }\n-            ty::ty_bare_fn(_, ref ft) => {\n-                self.push_sig_subtypes(&ft.sig);\n-            }\n-        }\n-    }\n-\n-    fn push_sig_subtypes(&mut self, sig: &ty::PolyFnSig<'tcx>) {\n-        match sig.0.output {\n-            ty::FnConverging(output) => { self.stack.push(output); }\n-            ty::FnDiverging => { }\n-        }\n-        self.push_reversed(&sig.0.inputs);\n-    }\n-\n-    fn push_reversed(&mut self, tys: &[Ty<'tcx>]) {\n-        // We push slices on the stack in reverse order so as to\n-        // maintain a pre-order traversal. As of the time of this\n-        // writing, the fact that the traversal is pre-order is not\n-        // known to be significant to any code, but it seems like the\n-        // natural order one would expect (basically, the order of the\n-        // types as they are written).\n-        for &ty in tys.iter().rev() {\n-            self.stack.push(ty);\n-        }\n-    }\n-\n     /// Skips the subtree of types corresponding to the last type\n     /// returned by `next()`.\n     ///\n@@ -105,10 +52,70 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n             }\n             Some(ty) => {\n                 self.last_subtree = self.stack.len();\n-                self.push_subtypes(ty);\n+                push_subtypes(&mut self.stack, ty);\n                 debug!(\"next: stack={:?}\", self.stack);\n                 Some(ty)\n             }\n         }\n     }\n }\n+\n+pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> IntoIter<Ty<'tcx>> {\n+    let mut stack = vec![];\n+    push_subtypes(&mut stack, ty);\n+    stack.into_iter()\n+}\n+\n+fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n+    match parent_ty.sty {\n+        ty::ty_bool | ty::ty_char | ty::ty_int(_) | ty::ty_uint(_) | ty::ty_float(_) |\n+        ty::ty_str | ty::ty_infer(_) | ty::ty_param(_) | ty::ty_err => {\n+        }\n+        ty::ty_uniq(ty) | ty::ty_vec(ty, _) => {\n+            stack.push(ty);\n+        }\n+        ty::ty_ptr(ref mt) | ty::ty_rptr(_, ref mt) => {\n+            stack.push(mt.ty);\n+        }\n+        ty::ty_projection(ref data) => {\n+            push_reversed(stack, data.trait_ref.substs.types.as_slice());\n+        }\n+        ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n+            push_reversed(stack, principal.substs().types.as_slice());\n+            push_reversed(stack, &bounds.projection_bounds.iter().map(|pred| {\n+                pred.0.ty\n+            }).collect::<Vec<_>>());\n+        }\n+        ty::ty_enum(_, ref substs) |\n+        ty::ty_struct(_, ref substs) |\n+        ty::ty_closure(_, ref substs) => {\n+            push_reversed(stack, substs.types.as_slice());\n+        }\n+        ty::ty_tup(ref ts) => {\n+            push_reversed(stack, ts);\n+        }\n+        ty::ty_bare_fn(_, ref ft) => {\n+            push_sig_subtypes(stack, &ft.sig);\n+        }\n+    }\n+}\n+\n+fn push_sig_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, sig: &ty::PolyFnSig<'tcx>) {\n+    match sig.0.output {\n+        ty::FnConverging(output) => { stack.push(output); }\n+        ty::FnDiverging => { }\n+    }\n+    push_reversed(stack, &sig.0.inputs);\n+}\n+\n+fn push_reversed<'tcx>(stack: &mut Vec<Ty<'tcx>>, tys: &[Ty<'tcx>]) {\n+    // We push slices on the stack in reverse order so as to\n+    // maintain a pre-order traversal. As of the time of this\n+    // writing, the fact that the traversal is pre-order is not\n+    // known to be significant to any code, but it seems like the\n+    // natural order one would expect (basically, the order of the\n+    // types as they are written).\n+    for &ty in tys.iter().rev() {\n+        stack.push(ty);\n+    }\n+}"}, {"sha": "5a5989211952913ea800c291818e7576510006ed", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -304,7 +304,7 @@ macro_rules! options {\n     {\n         let mut op = $defaultfn();\n         for option in matches.opt_strs($prefix) {\n-            let mut iter = option.splitn(1, '=');\n+            let mut iter = option.splitn(2, '=');\n             let key = iter.next().unwrap();\n             let value = iter.next();\n             let option_to_lookup = key.replace(\"-\", \"_\");\n@@ -958,7 +958,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     }\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n-        let mut parts = s.splitn(1, '=');\n+        let mut parts = s.splitn(2, '=');\n         let kind = parts.next().unwrap();\n         let (name, kind) = match (parts.next(), kind) {\n             (None, name) |\n@@ -1010,7 +1010,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut externs = HashMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n-        let mut parts = arg.splitn(1, '=');\n+        let mut parts = arg.splitn(2, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n             None => early_error(\"--extern value must not be empty\"),"}, {"sha": "60b422b3769d5bc0a2c322a590d89b776a691493", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -384,13 +384,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_infer(infer_ty) => infer_ty_to_string(cx, infer_ty),\n         ty_err => \"[type error]\".to_string(),\n-        ty_param(ref param_ty) => {\n-            if cx.sess.verbose() {\n-                param_ty.repr(cx)\n-            } else {\n-                param_ty.user_string(cx)\n-            }\n-        }\n+        ty_param(ref param_ty) => param_ty.user_string(cx),\n         ty_enum(did, substs) | ty_struct(did, substs) => {\n             let base = ty::item_path_str(cx, did);\n             parameterized(cx, &base, substs, did, &[],\n@@ -1532,3 +1526,9 @@ impl<'tcx> UserString<'tcx> for ty::Predicate<'tcx> {\n         }\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for ast::Unsafety {\n+    fn repr(&self, _: &ctxt<'tcx>) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+}"}, {"sha": "e5847400496833a6cf7274019d4fba7076ccdc53", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -74,7 +74,7 @@ pub enum PpMode {\n pub fn parse_pretty(sess: &Session,\n                     name: &str,\n                     extended: bool) -> (PpMode, Option<UserIdentifiedItem>) {\n-    let mut split = name.splitn(1, '=');\n+    let mut split = name.splitn(2, '=');\n     let first = split.next().unwrap();\n     let opt_second = split.next();\n     let first = match (first, extended) {\n@@ -226,6 +226,10 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n                 try!(pp::space(&mut s.s));\n                 s.synth_comment(item.id.to_string())\n             }\n+            pprust::NodeSubItem(id) => {\n+                try!(pp::space(&mut s.s));\n+                s.synth_comment(id.to_string())\n+            }\n             pprust::NodeBlock(blk) => {\n                 try!(pp::space(&mut s.s));\n                 s.synth_comment(format!(\"block {}\", blk.id))"}, {"sha": "f9be71561e384b5b2a85800eeca108ef90fef1c7", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -22,7 +22,7 @@ use rustc_typeck::middle::stability;\n use rustc_typeck::middle::subst;\n use rustc_typeck::middle::subst::Subst;\n use rustc_typeck::middle::ty::{self, Ty};\n-use rustc_typeck::middle::infer::combine::Combine;\n+use rustc_typeck::middle::ty_relate::TypeRelation;\n use rustc_typeck::middle::infer;\n use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;\n@@ -350,21 +350,21 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn sub(&self) -> Sub<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n-        Sub(self.infcx.combine_fields(true, trace))\n+        self.infcx.sub(true, trace)\n     }\n \n     pub fn lub(&self) -> Lub<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n-        Lub(self.infcx.combine_fields(true, trace))\n+        self.infcx.lub(true, trace)\n     }\n \n     pub fn glb(&self) -> Glb<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n-        Glb(self.infcx.combine_fields(true, trace))\n+        self.infcx.glb(true, trace)\n     }\n \n     pub fn make_lub_ty(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) -> Ty<'tcx> {\n-        match self.lub().tys(t1, t2) {\n+        match self.lub().relate(&t1, &t2) {\n             Ok(t) => t,\n             Err(ref e) => panic!(\"unexpected error computing LUB: {}\",\n                                 ty::type_err_to_str(self.infcx.tcx, e))\n@@ -374,7 +374,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `t1 <: t2` is true (this may register additional\n     /// region checks).\n     pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub().tys(t1, t2) {\n+        match self.sub().relate(&t1, &t2) {\n             Ok(_) => { }\n             Err(ref e) => {\n                 panic!(\"unexpected error computing sub({},{}): {}\",\n@@ -388,7 +388,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     /// Checks that `t1 <: t2` is false (this may register additional\n     /// region checks).\n     pub fn check_not_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n-        match self.sub().tys(t1, t2) {\n+        match self.sub().relate(&t1, &t2) {\n             Err(_) => { }\n             Ok(_) => {\n                 panic!(\"unexpected success computing sub({},{})\",\n@@ -400,7 +400,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n-        match self.lub().tys(t1, t2) {\n+        match self.lub().relate(&t1, &t2) {\n             Ok(t) => {\n                 self.assert_eq(t, t_lub);\n             }\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                self.ty_to_string(t1),\n                self.ty_to_string(t2),\n                self.ty_to_string(t_glb));\n-        match self.glb().tys(t1, t2) {\n+        match self.glb().relate(&t1, &t2) {\n             Err(e) => {\n                 panic!(\"unexpected error computing LUB: {:?}\", e)\n             }"}, {"sha": "ece83b578d25774a9653d13fe6a0b61274f05028", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -162,9 +162,12 @@ impl NamespaceResult {\n }\n \n enum NameDefinition {\n-    NoNameDefinition,           //< The name was unbound.\n-    ChildNameDefinition(Def, LastPrivate), //< The name identifies an immediate child.\n-    ImportNameDefinition(Def, LastPrivate) //< The name identifies an import.\n+    // The name was unbound.\n+    NoNameDefinition,\n+    // The name identifies an immediate child.\n+    ChildNameDefinition(Def, LastPrivate),\n+    // The name identifies an import.\n+    ImportNameDefinition(Def, LastPrivate),\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n@@ -795,11 +798,6 @@ pub struct Resolver<'a, 'tcx:'a> {\n     // The current self type if inside an impl (used for better errors).\n     current_self_type: Option<Ty>,\n \n-    // The ident for the keyword \"self\".\n-    self_name: Name,\n-    // The ident for the non-keyword \"Self\".\n-    type_self_name: Name,\n-\n     // The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n@@ -869,9 +867,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             current_trait_ref: None,\n             current_self_type: None,\n \n-            self_name: special_names::self_,\n-            type_self_name: special_names::type_self,\n-\n             primitive_type_table: PrimitiveTypeTable::new(),\n \n             def_map: RefCell::new(NodeMap()),\n@@ -1822,7 +1817,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let mut self_type_rib = Rib::new(ItemRibKind);\n \n                 // plain insert (no renaming, types are not currently hygienic....)\n-                let name = self.type_self_name;\n+                let name = special_names::type_self;\n                 self_type_rib.bindings.insert(name, DlDef(DefSelfTy(item.id)));\n                 self.type_ribs.push(self_type_rib);\n \n@@ -2047,8 +2042,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn with_optional_trait_ref<T, F>(&mut self,\n                                      opt_trait_ref: Option<&TraitRef>,\n-                                     f: F) -> T where\n-        F: FnOnce(&mut Resolver) -> T,\n+                                     f: F)\n+                                     -> T\n+        where F: FnOnce(&mut Resolver) -> T,\n     {\n         let mut new_val = None;\n         if let Some(trait_ref) = opt_trait_ref {\n@@ -2585,11 +2581,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len()-path_depth];\n \n-        let mk_res = |(def, lp)| PathResolution {\n-            base_def: def,\n-            last_private: lp,\n-            depth: path_depth\n-        };\n+        let mk_res = |(def, lp)| PathResolution::new(def, lp, path_depth);\n \n         if path.global {\n             let def = self.resolve_crate_relative_path(span, segments, namespace);\n@@ -2603,25 +2595,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         check_ribs,\n                                         span);\n \n-        if segments.len() > 1 {\n-            let def = self.resolve_module_relative_path(span, segments, namespace);\n-            match (def, unqualified_def) {\n-                (Some((ref d, _)), Some((ref ud, _))) if *d == *ud => {\n-                    self.session\n-                        .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n-                                  id, span,\n-                                  \"unnecessary qualification\".to_string());\n-                }\n-                _ => ()\n-            }\n+        if segments.len() <= 1 {\n+            return unqualified_def.map(mk_res);\n+        }\n \n-            def.map(mk_res)\n-        } else {\n-            unqualified_def.map(mk_res)\n+        let def = self.resolve_module_relative_path(span, segments, namespace);\n+        match (def, unqualified_def) {\n+            (Some((ref d, _)), Some((ref ud, _))) if *d == *ud => {\n+                self.session\n+                    .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n+                              id, span,\n+                              \"unnecessary qualification\".to_string());\n+            }\n+            _ => {}\n         }\n+\n+        def.map(mk_res)\n     }\n \n-    // resolve a single identifier (used as a varref)\n+    // Resolve a single identifier.\n     fn resolve_identifier(&mut self,\n                           identifier: Ident,\n                           namespace: Namespace,\n@@ -2662,8 +2654,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match child_name_bindings.def_for_namespace(namespace) {\n                     Some(def) => {\n                         // Found it. Stop the search here.\n-                        let p = child_name_bindings.defined_in_public_namespace(\n-                                        namespace);\n+                        let p = child_name_bindings.defined_in_public_namespace(namespace);\n                         let lp = if p {LastMod(AllPublic)} else {\n                             LastMod(DependsOn(def.def_id()))\n                         };\n@@ -2734,8 +2725,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let containing_module;\n         let last_private;\n-        let module = self.current_module.clone();\n-        match self.resolve_module_path(module,\n+        let current_module = self.current_module.clone();\n+        match self.resolve_module_path(current_module,\n                                        &module_path[..],\n                                        UseLexicalScope,\n                                        span,\n@@ -2858,8 +2849,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         match search_result {\n             Some(DlDef(def)) => {\n-                debug!(\"(resolving path in local ribs) resolved `{}` to \\\n-                        local: {:?}\",\n+                debug!(\"(resolving path in local ribs) resolved `{}` to local: {:?}\",\n                        token::get_ident(ident),\n                        def);\n                 Some(def)\n@@ -2904,15 +2894,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 panic!(\"unexpected indeterminate result\");\n             }\n             Failed(err) => {\n-                match err {\n-                    Some((span, msg)) =>\n-                        self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                         msg)),\n-                    None => ()\n-                }\n-\n                 debug!(\"(resolving item path by identifier in lexical scope) \\\n                          failed to resolve {}\", token::get_name(name));\n+\n+                if let Some((span, msg)) = err {\n+                    self.resolve_error(span, &format!(\"failed to resolve. {}\", msg))\n+                }\n+\n                 return None;\n             }\n         }\n@@ -2964,10 +2952,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                &name_path[..],\n-                                                UseLexicalScope,\n-                                                span,\n-                                                PathSearch) {\n+                                               &name_path[..],\n+                                               UseLexicalScope,\n+                                               span,\n+                                               PathSearch) {\n                     Success((module, _)) => Some(module),\n                     _ => None\n                 }\n@@ -3203,8 +3191,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 false // Stop advancing\n                             });\n \n-                            if method_scope && &token::get_name(self.self_name)[..]\n-                                                                == path_name {\n+                            if method_scope &&\n+                               &token::get_name(special_names::self_)[..] == path_name {\n                                     self.resolve_error(\n                                         expr.span,\n                                         \"`self` is not available \\"}, {"sha": "5b1ac88c2089b951113911b16527cba09b547af8", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -40,6 +40,10 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     let fcx = cx.fcx;\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n \n+    if cx.unreachable.get() {\n+        return cx;\n+    }\n+\n     if cx.sess().asm_comments() {\n         add_span_comment(cx, s.span, &s.repr(cx.tcx()));\n     }\n@@ -76,6 +80,11 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n pub fn trans_stmt_semi<'blk, 'tcx>(cx: Block<'blk, 'tcx>, e: &ast::Expr)\n                                    -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_stmt_semi\");\n+\n+    if cx.unreachable.get() {\n+        return cx;\n+    }\n+\n     let ty = expr_ty(cx, e);\n     if cx.fcx.type_needs_drop(ty) {\n         expr::trans_to_lvalue(cx, e, \"stmt\").bcx\n@@ -89,6 +98,11 @@ pub fn trans_block<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                mut dest: expr::Dest)\n                                -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_block\");\n+\n+    if bcx.unreachable.get() {\n+        return bcx;\n+    }\n+\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n \n@@ -141,6 +155,11 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            bcx.to_str(), if_id, bcx.expr_to_string(cond), thn.id,\n            dest.to_string(bcx.ccx()));\n     let _icx = push_ctxt(\"trans_if\");\n+\n+    if bcx.unreachable.get() {\n+        return bcx;\n+    }\n+\n     let mut bcx = bcx;\n \n     let cond_val = unpack_result!(bcx, expr::trans(bcx, cond).to_llbool());\n@@ -214,6 +233,11 @@ pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                body: &ast::Block)\n                                -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_while\");\n+\n+    if bcx.unreachable.get() {\n+        return bcx;\n+    }\n+\n     let fcx = bcx.fcx;\n \n     //            bcx\n@@ -257,6 +281,11 @@ pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               body: &ast::Block)\n                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_loop\");\n+\n+    if bcx.unreachable.get() {\n+        return bcx;\n+    }\n+\n     let fcx = bcx.fcx;\n \n     //            bcx\n@@ -296,12 +325,13 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     exit: usize)\n                                     -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_break_cont\");\n-    let fcx = bcx.fcx;\n \n     if bcx.unreachable.get() {\n         return bcx;\n     }\n \n+    let fcx = bcx.fcx;\n+\n     // Locate loop that we will break to\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n@@ -341,6 +371,11 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                              retval_expr: Option<&ast::Expr>)\n                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_ret\");\n+\n+    if bcx.unreachable.get() {\n+        return bcx;\n+    }\n+\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n     let dest = match (fcx.llretslotptr.get(), retval_expr) {\n@@ -372,6 +407,10 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_value\");\n \n+    if bcx.unreachable.get() {\n+        return bcx;\n+    }\n+\n     let v_str = C_str_slice(ccx, fail_str);\n     let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n     let filename = token::intern_and_get_ident(&loc.file.name);\n@@ -399,6 +438,10 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let ccx = bcx.ccx();\n     let _icx = push_ctxt(\"trans_fail_bounds_check\");\n \n+    if bcx.unreachable.get() {\n+        return bcx;\n+    }\n+\n     // Extract the file/line from the span\n     let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n     let filename = token::intern_and_get_ident(&loc.file.name);"}, {"sha": "939142cff1c32b6d7aba9d61bf675e7fc75c0cdd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 93, "deletions": 56, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -140,13 +140,7 @@ pub trait AstConv<'tcx> {\n                     span: Span,\n                     _trait_ref: Rc<ty::TraitRef<'tcx>>,\n                     _item_name: ast::Name)\n-                    -> Ty<'tcx>\n-    {\n-        span_err!(self.tcx().sess, span, E0213,\n-            \"associated types are not accepted in this context\");\n-\n-        self.tcx().types.err\n-    }\n+                    -> Ty<'tcx>;\n }\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n@@ -924,9 +918,12 @@ fn ast_path_to_ty<'tcx>(\n         }\n     };\n \n-    let substs = ast_path_substs_for_ty(this, rscope,\n-                                        span, param_mode,\n-                                        &generics, item_segment);\n+    let substs = ast_path_substs_for_ty(this,\n+                                        rscope,\n+                                        span,\n+                                        param_mode,\n+                                        &generics,\n+                                        item_segment);\n \n     // FIXME(#12938): This is a hack until we have full support for DST.\n     if Some(did) == this.tcx().lang_items.owned_box() {\n@@ -1044,6 +1041,12 @@ fn report_ambiguous_associated_type(tcx: &ty::ctxt,\n               type_str, trait_str, name);\n }\n \n+// Create a type from a a path to an associated type.\n+// For a path A::B::C::D, ty and ty_path_def are the type and def for A::B::C\n+// and item_segment is the path segment for D. We return a type and a def for\n+// the whole path.\n+// Will fail except for T::A and Self::A; i.e., if ty/ty_path_def are not a type\n+// parameter or Self.\n fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                    span: Span,\n                                    ty: Ty<'tcx>,\n@@ -1052,35 +1055,43 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                    -> (Ty<'tcx>, def::Def)\n {\n     let tcx = this.tcx();\n-    check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n     let assoc_name = item_segment.identifier.name;\n \n-    let is_param = match (&ty.sty, ty_path_def) {\n-        (&ty::ty_param(_), def::DefTyParam(..)) |\n-        (&ty::ty_param(_), def::DefSelfTy(_)) => true,\n-        _ => false\n-    };\n+    debug!(\"associated_path_def_to_ty: {}::{}\", ty.repr(tcx), token::get_name(assoc_name));\n \n-    let ty_param_node_id = if is_param {\n-        ty_path_def.local_node_id()\n-    } else {\n-        report_ambiguous_associated_type(\n-            tcx, span, &ty.user_string(tcx), \"Trait\", &token::get_name(assoc_name));\n-        return (tcx.types.err, ty_path_def);\n-    };\n+    check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n+\n+    // Check that the path prefix given by ty/ty_path_def is a type parameter/Self.\n+    match (&ty.sty, ty_path_def) {\n+        (&ty::ty_param(_), def::DefTyParam(..)) |\n+        (&ty::ty_param(_), def::DefSelfTy(_)) => {}\n+        _ => {\n+            report_ambiguous_associated_type(tcx,\n+                                             span,\n+                                             &ty.user_string(tcx),\n+                                             \"Trait\",\n+                                             &token::get_name(assoc_name));\n+            return (tcx.types.err, ty_path_def);\n+        }\n+    }\n \n+    let ty_param_node_id = ty_path_def.local_node_id();\n     let ty_param_name = tcx.ty_param_defs.borrow().get(&ty_param_node_id).unwrap().name;\n \n     let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n         Ok(v) => v,\n-        Err(ErrorReported) => { return (tcx.types.err, ty_path_def); }\n+        Err(ErrorReported) => {\n+            return (tcx.types.err, ty_path_def);\n+        }\n     };\n \n-    // ensure the super predicates and stop if we encountered an error\n+    // Ensure the super predicates and stop if we encountered an error.\n     if bounds.iter().any(|b| this.ensure_super_predicates(span, b.def_id()).is_err()) {\n         return (this.tcx().types.err, ty_path_def);\n     }\n \n+    // Check that there is exactly one way to find an associated type with the\n+    // correct name.\n     let mut suitable_bounds: Vec<_> =\n         traits::transitive_bounds(tcx, &bounds)\n         .filter(|b| this.trait_defines_associated_type_named(b.def_id(), assoc_name))\n@@ -1118,7 +1129,8 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         // by type collection, which may be in progress at this point.\n         match this.tcx().map.expect_item(trait_did.node).node {\n             ast::ItemTrait(_, _, _, ref trait_items) => {\n-                let item = trait_items.iter().find(|i| i.ident.name == assoc_name)\n+                let item = trait_items.iter()\n+                                      .find(|i| i.ident.name == assoc_name)\n                                       .expect(\"missing associated type\");\n                 ast_util::local_def(item.id)\n             }\n@@ -1129,6 +1141,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         let item = trait_items.iter().find(|i| i.name() == assoc_name);\n         item.expect(\"missing associated type\").def_id()\n     };\n+\n     (ty, def::DefAssociatedTy(trait_did, item_did))\n }\n \n@@ -1150,8 +1163,11 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n         ty\n     } else {\n         let path_str = ty::item_path_str(tcx, trait_def_id);\n-        report_ambiguous_associated_type(\n-            tcx, span, \"Type\", &path_str, &token::get_ident(item_segment.identifier));\n+        report_ambiguous_associated_type(tcx,\n+                                         span,\n+                                         \"Type\",\n+                                         &path_str,\n+                                         &token::get_ident(item_segment.identifier));\n         return tcx.types.err;\n     };\n \n@@ -1204,13 +1220,15 @@ pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n }\n \n+// Note that both base_segments and assoc_segments may be empty, although not at\n+// the same time.\n pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                         rscope: &RegionScope,\n                                         span: Span,\n                                         param_mode: PathParamMode,\n-                                        def: &mut def::Def,\n+                                        def: &def::Def,\n                                         opt_self_ty: Option<Ty<'tcx>>,\n-                                        segments: &[ast::PathSegment],\n+                                        base_segments: &[ast::PathSegment],\n                                         assoc_segments: &[ast::PathSegment])\n                                         -> Ty<'tcx> {\n     let tcx = this.tcx();\n@@ -1226,52 +1244,64 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                                           span,\n                                                           param_mode,\n                                                           trait_def_id,\n-                                                          segments.last().unwrap(),\n+                                                          base_segments.last().unwrap(),\n                                                           &mut projection_bounds);\n \n-            check_path_args(tcx, segments.init(), NO_TPS | NO_REGIONS);\n-            trait_ref_to_object_type(this, rscope, span, trait_ref,\n-                                     projection_bounds, &[])\n+            check_path_args(tcx, base_segments.init(), NO_TPS | NO_REGIONS);\n+            trait_ref_to_object_type(this,\n+                                     rscope,\n+                                     span,\n+                                     trait_ref,\n+                                     projection_bounds,\n+                                     &[])\n         }\n         def::DefTy(did, _) | def::DefStruct(did) => {\n-            check_path_args(tcx, segments.init(), NO_TPS | NO_REGIONS);\n+            check_path_args(tcx, base_segments.init(), NO_TPS | NO_REGIONS);\n             ast_path_to_ty(this, rscope, span,\n                            param_mode, did,\n-                           segments.last().unwrap())\n+                           base_segments.last().unwrap())\n         }\n         def::DefTyParam(space, index, _, name) => {\n-            check_path_args(tcx, segments, NO_TPS | NO_REGIONS);\n+            check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n             ty::mk_param(tcx, space, index, name)\n         }\n         def::DefSelfTy(_) => {\n-            // n.b.: resolve guarantees that the this type only appears in a\n+            // N.b.: resolve guarantees that the this type only appears in a\n             // trait, which we rely upon in various places when creating\n-            // substs\n-            check_path_args(tcx, segments, NO_TPS | NO_REGIONS);\n+            // substs.\n+            check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n             ty::mk_self_type(tcx)\n         }\n         def::DefAssociatedTy(trait_did, _) => {\n-            check_path_args(tcx, &segments[..segments.len()-2], NO_TPS | NO_REGIONS);\n-            qpath_to_ty(this, rscope, span, param_mode,\n-                        opt_self_ty, trait_did,\n-                        &segments[segments.len()-2],\n-                        segments.last().unwrap())\n+            check_path_args(tcx, &base_segments[..base_segments.len()-2], NO_TPS | NO_REGIONS);\n+            qpath_to_ty(this,\n+                        rscope,\n+                        span,\n+                        param_mode,\n+                        opt_self_ty,\n+                        trait_did,\n+                        &base_segments[base_segments.len()-2],\n+                        base_segments.last().unwrap())\n         }\n         def::DefMod(id) => {\n             // Used as sentinel by callers to indicate the `<T>::A::B::C` form.\n             // FIXME(#22519) This part of the resolution logic should be\n             // avoided entirely for that form, once we stop needed a Def\n             // for `associated_path_def_to_ty`.\n-            if segments.is_empty() {\n-                opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n-            } else {\n-                span_err!(tcx.sess, span, E0247, \"found module name used as a type: {}\",\n+\n+            if !base_segments.is_empty() {\n+                span_err!(tcx.sess,\n+                          span,\n+                          E0247,\n+                          \"found module name used as a type: {}\",\n                           tcx.map.node_to_string(id.node));\n                 return this.tcx().types.err;\n             }\n+\n+            opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n         }\n         def::DefPrimTy(prim_ty) => {\n-            prim_ty_to_ty(tcx, segments, prim_ty)\n+            prim_ty_to_ty(tcx, base_segments, prim_ty)\n         }\n         _ => {\n             span_err!(tcx.sess, span, E0248,\n@@ -1282,15 +1312,19 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     // If any associated type segments remain, attempt to resolve them.\n     let mut ty = base_ty;\n+    let mut def = *def;\n     for segment in assoc_segments {\n         if ty.sty == ty::ty_err {\n             break;\n         }\n         // This is pretty bad (it will fail except for T::A and Self::A).\n-        let (a_ty, a_def) = associated_path_def_to_ty(this, span,\n-                                                      ty, *def, segment);\n+        let (a_ty, a_def) = associated_path_def_to_ty(this,\n+                                                      span,\n+                                                      ty,\n+                                                      def,\n+                                                      segment);\n         ty = a_ty;\n-        *def = a_def;\n+        def = a_def;\n     }\n     ty\n }\n@@ -1378,13 +1412,16 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 tcx.sess.span_bug(ast_ty.span,\n                                   &format!(\"unbound path {}\", ast_ty.repr(tcx)))\n             };\n-            let mut def = path_res.base_def;\n+            let def = path_res.base_def;\n             let base_ty_end = path.segments.len() - path_res.depth;\n             let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n                 ast_ty_to_ty(this, rscope, &qself.ty)\n             });\n-            let ty = finish_resolving_def_to_ty(this, rscope, ast_ty.span,\n-                                                PathParamMode::Explicit, &mut def,\n+            let ty = finish_resolving_def_to_ty(this,\n+                                                rscope,\n+                                                ast_ty.span,\n+                                                PathParamMode::Explicit,\n+                                                &def,\n                                                 opt_self_ty,\n                                                 &path.segments[..base_ty_end],\n                                                 &path.segments[base_ty_end..]);"}, {"sha": "3f9c14e0afe398ab8d3b905cf60e3ef082dfb029", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -83,9 +83,7 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                   UnresolvedTypeAction::Error,\n                   LvaluePreference::NoPreference,\n                   |adj_ty, idx| {\n-                      let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n-                      try_overloaded_call_step(fcx, call_expr, callee_expr,\n-                                               adj_ty, autoderefref)\n+                      try_overloaded_call_step(fcx, call_expr, callee_expr, adj_ty, idx)\n                   });\n \n     match result {\n@@ -119,13 +117,15 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       call_expr: &'tcx ast::Expr,\n                                       callee_expr: &'tcx ast::Expr,\n                                       adjusted_ty: Ty<'tcx>,\n-                                      autoderefref: ty::AutoDerefRef<'tcx>)\n+                                      autoderefs: usize)\n                                       -> Option<CallStep<'tcx>>\n {\n-    debug!(\"try_overloaded_call_step(call_expr={}, adjusted_ty={}, autoderefref={})\",\n+    debug!(\"try_overloaded_call_step(call_expr={}, adjusted_ty={}, autoderefs={})\",\n            call_expr.repr(fcx.tcx()),\n            adjusted_ty.repr(fcx.tcx()),\n-           autoderefref.repr(fcx.tcx()));\n+           autoderefs);\n+\n+    let autoderefref = ty::AutoDerefRef { autoderefs: autoderefs, autoref: None };\n \n     // If the callee is a bare function or a closure, then we're all set.\n     match structurally_resolved_type(fcx, callee_expr.span, adjusted_ty).sty {\n@@ -161,6 +161,18 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n         }\n \n+        // Hack: we know that there are traits implementing Fn for &F\n+        // where F:Fn and so forth. In the particular case of types\n+        // like `x: &mut FnMut()`, if there is a call `x()`, we would\n+        // normally translate to `FnMut::call_mut(&mut x, ())`, but\n+        // that winds up requiring `mut x: &mut FnMut()`. A little\n+        // over the top. The simplest fix by far is to just ignore\n+        // this case and deref again, so we wind up with\n+        // `FnMut::call_mut(&mut *x, ())`.\n+        ty::ty_rptr(..) if autoderefs == 0 => {\n+            return None;\n+        }\n+\n         _ => {}\n     }\n "}, {"sha": "ced6cec3ef0dc3daef00349ce18f90f9e057a242", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -62,12 +62,11 @@\n \n use check::{autoderef, FnCtxt, NoPreference, PreferMutLvalue, UnresolvedTypeAction};\n \n-use middle::infer::{self, cres, Coercion, TypeTrace};\n-use middle::infer::combine::Combine;\n-use middle::infer::sub::Sub;\n+use middle::infer::{self, Coercion};\n use middle::subst;\n use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n use middle::ty::{self, mt, Ty};\n+use middle::ty_relate::RelateResult;\n use util::common::indent;\n use util::ppaux;\n use util::ppaux::Repr;\n@@ -76,25 +75,27 @@ use syntax::ast;\n \n struct Coerce<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n-    trace: TypeTrace<'tcx>\n+    origin: infer::TypeOrigin,\n }\n \n-type CoerceResult<'tcx> = cres<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n+type CoerceResult<'tcx> = RelateResult<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n \n     fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        let sub = Sub(self.fcx.infcx().combine_fields(false, self.trace.clone()));\n-        try!(sub.tys(a, b));\n+        try!(self.fcx.infcx().sub_types(false, self.origin.clone(), a, b));\n         Ok(None) // No coercion required.\n     }\n \n-    fn outlives(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ()> {\n-        let sub = Sub(self.fcx.infcx().combine_fields(false, self.trace.clone()));\n-        try!(sub.regions(b, a));\n+    fn outlives(&self,\n+                origin: infer::SubregionOrigin<'tcx>,\n+                a: ty::Region,\n+                b: ty::Region)\n+                -> RelateResult<'tcx, ()> {\n+        infer::mk_subr(self.fcx.infcx(), origin, b, a);\n         Ok(())\n     }\n \n@@ -190,7 +191,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             _ => return self.subtype(a, b)\n         }\n \n-        let coercion = Coercion(self.trace.clone());\n+        let coercion = Coercion(self.origin.span());\n         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n         let autoref = Some(AutoPtr(r_borrow, mutbl_b, None));\n \n@@ -214,7 +215,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n             let ty = ty::mk_rptr(self.tcx(), r_borrow,\n                                  mt {ty: inner_ty, mutbl: mutbl_b});\n-            if let Err(err) = self.fcx.infcx().try(|_| self.subtype(ty, b)) {\n+            if let Err(err) = self.subtype(ty, b) {\n                 if first_error.is_none() {\n                     first_error = Some(err);\n                 }\n@@ -264,12 +265,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             return Err(ty::terr_mutability);\n                         }\n \n-                        let coercion = Coercion(self.trace.clone());\n+                        let coercion = Coercion(self.origin.span());\n                         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n                         let ty = ty::mk_rptr(self.tcx(),\n                                              self.tcx().mk_region(r_borrow),\n                                              ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        try!(self.subtype(ty, b));\n                         debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                 AutoPtr(AutoUnsize({:?})))\", kind);\n                         Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -290,7 +291,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                         let ty = ty::mk_ptr(self.tcx(),\n                                              ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        try!(self.subtype(ty, b));\n                         debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                 AutoPtr(AutoUnsize({:?})))\", kind);\n                         Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -306,7 +307,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 match self.unsize_ty(t_a, t_b) {\n                     Some((ty, kind)) => {\n                         let ty = ty::mk_uniq(self.tcx(), ty);\n-                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        try!(self.subtype(ty, b));\n                         debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                 AutoUnsizeUniq({:?}))\", kind);\n                         Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -365,9 +366,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n \n                             // relate `a1` to `b`\n-                            let result = self.fcx.infcx().try(|_| {\n+                            let result = self.fcx.infcx().commit_if_ok(|_| {\n                                 // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n-                                try!(self.outlives(data_a.bounds.region_bound,\n+                                try!(self.outlives(infer::RelateObjectBound(self.origin.span()),\n+                                                   data_a.bounds.region_bound,\n                                                    data_b.bounds.region_bound));\n                                 self.subtype(ty_a1, ty_b)\n                             });\n@@ -399,7 +401,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                         let mut result = None;\n                         let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n                         for (i, (tp_a, tp_b)) in tps {\n-                            if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n+                            if self.subtype(*tp_a, *tp_b).is_ok() {\n                                 continue;\n                             }\n                             match self.unsize_ty(*tp_a, *tp_b) {\n@@ -408,7 +410,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                     let mut new_substs = substs_a.clone();\n                                     new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n                                     let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n-                                    if self.fcx.infcx().try(|_| self.subtype(ty, ty_b)).is_err() {\n+                                    if self.subtype(ty, ty_b).is_err() {\n                                         debug!(\"Unsized type parameter '{}', but still \\\n                                                 could not match types {} and {}\",\n                                                ppaux::ty_to_string(tcx, *tp_a),\n@@ -534,14 +536,13 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              expr: &ast::Expr,\n                              a: Ty<'tcx>,\n                              b: Ty<'tcx>)\n-                             -> cres<'tcx, ()> {\n+                             -> RelateResult<'tcx, ()> {\n     debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n     let adjustment = try!(indent(|| {\n-        fcx.infcx().commit_if_ok(|| {\n-            let origin = infer::ExprAssignable(expr.span);\n+        fcx.infcx().commit_if_ok(|_| {\n             Coerce {\n                 fcx: fcx,\n-                trace: infer::TypeTrace::types(origin, false, a, b)\n+                origin: infer::ExprAssignable(expr.span),\n             }.coerce(expr, a, b)\n         })\n     }));"}, {"sha": "532277d75b2e06af52afc2002fffe37f62957b58", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -282,7 +282,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let trait_fty = ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(trait_m.fty.clone()));\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n-    let err = infcx.try(|snapshot| {\n+    let err = infcx.commit_if_ok(|snapshot| {\n         let origin = infer::MethodCompatCheck(impl_m_span);\n \n         let (impl_sig, _) ="}, {"sha": "2f7e0073e1751ad0f99ee08fc7714ee5269749ff", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -95,7 +95,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         ty::lookup_item_type(tcx, self_type_did);\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    infcx.try(|snapshot| {\n+    infcx.commit_if_ok(|snapshot| {\n         let (named_type_to_skolem, skol_map) =\n             infcx.construct_skolemized_subst(named_type_generics, snapshot);\n         let named_type_skolem = named_type.subst(tcx, &named_type_to_skolem);"}, {"sha": "e203019bd0638fe43d2fe0ea2d8d307c35db27b5", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -1130,7 +1130,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n-    fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::ures<'tcx> {\n+    fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::UnitResult<'tcx> {\n         self.infcx().sub_types(false, infer::Misc(DUMMY_SP), sub, sup)\n     }\n "}, {"sha": "b9a0070f205be88a8c13ee04790774564fed509c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -3329,7 +3329,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 &format!(\"unbound path {}\", expr.repr(tcx)))\n           };\n \n-          let mut def = path_res.base_def;\n+          let def = path_res.base_def;\n           if path_res.depth == 0 {\n               let (scheme, predicates) =\n                   type_scheme_and_predicates_for_def(fcx, expr.span, def);\n@@ -3339,9 +3339,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           } else {\n               let ty_segments = path.segments.init();\n               let base_ty_end = path.segments.len() - path_res.depth;\n-              let ty = astconv::finish_resolving_def_to_ty(fcx, fcx, expr.span,\n+              let ty = astconv::finish_resolving_def_to_ty(fcx,\n+                                                           fcx,\n+                                                           expr.span,\n                                                            PathParamMode::Optional,\n-                                                           &mut def,\n+                                                           &def,\n                                                            opt_self_ty,\n                                                            &ty_segments[..base_ty_end],\n                                                            &ty_segments[base_ty_end..]);"}, {"sha": "9171367468026a8f9226b4537b22500f4ff51394", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -1542,7 +1542,7 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n             debug!(\"projection_bounds: outlives={} (2)\",\n                    outlives.repr(tcx));\n \n-            let region_result = infcx.try(|_| {\n+            let region_result = infcx.commit_if_ok(|_| {\n                 let (outlives, _) =\n                     infcx.replace_late_bound_regions_with_fresh_var(\n                         span,"}, {"sha": "51d0c18872dc4213b9756cb3585bb5d7a8bc34cd", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -30,7 +30,6 @@ use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n use middle::ty::ty_projection;\n use middle::ty;\n use CrateCtxt;\n-use middle::infer::combine::Combine;\n use middle::infer::InferCtxt;\n use middle::infer::new_infer_ctxt;\n use std::collections::HashSet;"}, {"sha": "e0ed83f401945b11d07bfbaf5992fde6b75a3cff", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -2392,7 +2392,7 @@ fn resolve_type(cx: &DocContext,\n     };\n \n     match def {\n-        def::DefSelfTy(..) => {\n+        def::DefSelfTy(..) if path.segments.len() == 1 => {\n             return Generic(token::get_name(special_idents::type_self.name).to_string());\n         }\n         def::DefPrimTy(p) => match p {\n@@ -2412,7 +2412,9 @@ fn resolve_type(cx: &DocContext,\n             ast::TyFloat(ast::TyF32) => return Primitive(F32),\n             ast::TyFloat(ast::TyF64) => return Primitive(F64),\n         },\n-        def::DefTyParam(_, _, _, n) => return Generic(token::get_name(n).to_string()),\n+        def::DefTyParam(_, _, _, n) => {\n+            return Generic(token::get_name(n).to_string())\n+        }\n         _ => {}\n     };\n     let did = register_def(&*cx, def);"}, {"sha": "d1dcfc26008686624e92cdd22ce8085caf612980", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -333,7 +333,7 @@ fn acquire_input(input: &str,\n fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n     let mut externs = HashMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n-        let mut parts = arg.splitn(1, '=');\n+        let mut parts = arg.splitn(2, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n             None => {"}, {"sha": "f5bee6240d46c80dc5ee321742b500cb958ec3c0", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -19,7 +19,6 @@ use std::path::PathBuf;\n use std::process::Command;\n use std::str;\n use std::sync::{Arc, Mutex};\n-use std::thunk::Thunk;\n \n use testing;\n use rustc_lint;\n@@ -366,7 +365,7 @@ impl Collector {\n                 ignore: should_ignore,\n                 should_panic: testing::ShouldPanic::No, // compiler failures are test failures\n             },\n-            testfn: testing::DynTestFn(Thunk::new(move|| {\n+            testfn: testing::DynTestFn(Box::new(move|| {\n                 runtest(&test,\n                         &cratename,\n                         libs,"}, {"sha": "150ffcdd77a9f3ef523b5c07a5d7d89060a67136", "filename": "src/libstd/error.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,152 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Traits for working with Errors.\n+//!\n+//! # The `Error` trait\n+//!\n+//! `Error` is a trait representing the basic expectations for error values,\n+//! i.e. values of type `E` in `Result<T, E>`. At a minimum, errors must provide\n+//! a description, but they may optionally provide additional detail (via\n+//! `Display`) and cause chain information:\n+//!\n+//! ```\n+//! use std::fmt::Display;\n+//!\n+//! trait Error: Display {\n+//!     fn description(&self) -> &str;\n+//!\n+//!     fn cause(&self) -> Option<&Error> { None }\n+//! }\n+//! ```\n+//!\n+//! The `cause` method is generally used when errors cross \"abstraction\n+//! boundaries\", i.e.  when a one module must report an error that is \"caused\"\n+//! by an error from a lower-level module. This setup makes it possible for the\n+//! high-level module to provide its own errors that do not commit to any\n+//! particular implementation, but also reveal some of its implementation for\n+//! debugging via `cause` chains.\n+\n+#![stable(feature = \"rust1\", since = \"1.0.0\")]\n+\n+// A note about crates and the facade:\n+//\n+// Originally, the `Error` trait was defined in libcore, and the impls\n+// were scattered about. However, coherence objected to this\n+// arrangement, because to create the blanket impls for `Box` required\n+// knowing that `&str: !Error`, and we have no means to deal with that\n+// sort of conflict just now. Therefore, for the time being, we have\n+// moved the `Error` trait into libstd. As we evolve a sol'n to the\n+// coherence challenge (e.g., specialization, neg impls, etc) we can\n+// reconsider what crate these items belong in.\n+\n+use boxed::Box;\n+use convert::From;\n+use fmt::{self, Debug, Display};\n+use marker::Send;\n+use num;\n+use option::Option;\n+use option::Option::None;\n+use str;\n+use string::{self, String};\n+\n+/// Base functionality for all errors in Rust.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub trait Error: Debug + Display {\n+    /// A short description of the error.\n+    ///\n+    /// The description should not contain newlines or sentence-ending\n+    /// punctuation, to facilitate embedding in larger user-facing\n+    /// strings.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn description(&self) -> &str;\n+\n+    /// The lower-level cause of this error, if any.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn cause(&self) -> Option<&Error> { None }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, E: Error + 'a> From<E> for Box<Error + 'a> {\n+    fn from(err: E) -> Box<Error + 'a> {\n+        Box::new(err)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, E: Error + Send + 'a> From<E> for Box<Error + Send + 'a> {\n+    fn from(err: E) -> Box<Error + Send + 'a> {\n+        Box::new(err)\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, 'b> From<&'b str> for Box<Error + Send + 'a> {\n+    fn from(err: &'b str) -> Box<Error + Send + 'a> {\n+        #[derive(Debug)]\n+        struct StringError(String);\n+\n+        impl Error for StringError {\n+            fn description(&self) -> &str { &self.0 }\n+        }\n+\n+        impl Display for StringError {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                Display::fmt(&self.0, f)\n+            }\n+        }\n+\n+        Box::new(StringError(String::from_str(err)))\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for str::ParseBoolError {\n+    fn description(&self) -> &str { \"failed to parse bool\" }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for str::Utf8Error {\n+    fn description(&self) -> &str {\n+        match *self {\n+            str::Utf8Error::TooShort => \"invalid utf-8: not enough bytes\",\n+            str::Utf8Error::InvalidByte(..) => \"invalid utf-8: corrupt contents\",\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for num::ParseIntError {\n+    fn description(&self) -> &str {\n+        self.description()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for num::ParseFloatError {\n+    fn description(&self) -> &str {\n+        self.description()\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for string::FromUtf8Error {\n+    fn description(&self) -> &str {\n+        \"invalid utf-8\"\n+    }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Error for string::FromUtf16Error {\n+    fn description(&self) -> &str {\n+        \"invalid utf-16\"\n+    }\n+}\n+"}, {"sha": "c6335015d7251d67d73bd1cf5dc90ac03a57e31a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -101,18 +101,14 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n     let start_len = buf.len();\n     let mut len = start_len;\n-    let mut cap_bump = 16;\n+    let mut new_write_size = 16;\n     let ret;\n     loop {\n         if len == buf.len() {\n-            if buf.capacity() == buf.len() {\n-                if cap_bump < DEFAULT_BUF_SIZE {\n-                    cap_bump *= 2;\n-                }\n-                buf.reserve(cap_bump);\n+            if new_write_size < DEFAULT_BUF_SIZE {\n+                new_write_size *= 2;\n             }\n-            let new_area = buf.capacity() - buf.len();\n-            buf.extend(iter::repeat(0).take(new_area));\n+            buf.extend(iter::repeat(0).take(new_write_size));\n         }\n \n         match r.read(&mut buf[len..]) {"}, {"sha": "5c9ff544fa3e8f3380b0876f87bf8e6495a4ef5e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -183,7 +183,7 @@ pub use core::raw;\n pub use core::simd;\n pub use core::result;\n pub use core::option;\n-pub use core::error;\n+pub mod error;\n \n #[cfg(not(test))] pub use alloc::boxed;\n pub use alloc::rc;\n@@ -243,6 +243,7 @@ mod uint_macros;\n #[path = \"num/f64.rs\"]   pub mod f64;\n \n pub mod ascii;\n+\n pub mod thunk;\n \n /* Common traits */"}, {"sha": "886f252fb192672b086bc347b87f8b0acae2d130", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -441,7 +441,7 @@ impl ToSocketAddrs for str {\n         }\n \n         // split the string by ':' and convert the second part to u16\n-        let mut parts_iter = self.rsplitn(1, ':');\n+        let mut parts_iter = self.rsplitn(2, ':');\n         let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n         let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n         let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");"}, {"sha": "4471b5afa84c888b600cd0def724eca4013466c8", "filename": "src/libstd/path.rs", "status": "modified", "additions": 214, "deletions": 1, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -343,6 +343,15 @@ impl<'a> Prefix<'a> {\n \n /// Determine whether the character is one of the permitted path\n /// separators for the current platform.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::path;\n+///\n+/// assert!(path::is_separator('/'));\n+/// assert!(!path::is_separator('\u2764'));\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn is_separator(c: char) -> bool {\n     use ascii::*;\n@@ -406,7 +415,7 @@ fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n         // contents of the encoding and (2) new &OsStr values are produced\n         // only from ASCII-bounded slices of existing &OsStr values.\n \n-        let mut iter = os_str_as_u8_slice(file).rsplitn(1, |b| *b == b'.');\n+        let mut iter = os_str_as_u8_slice(file).rsplitn(2, |b| *b == b'.');\n         let after = iter.next();\n         let before = iter.next();\n         if before == Some(b\"\") {\n@@ -539,6 +548,18 @@ impl<'a> AsRef<OsStr> for Component<'a> {\n ///\n /// See the module documentation for an in-depth explanation of components and\n /// their role in the API.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::path::Path;\n+///\n+/// let path = Path::new(\"/tmp/foo/bar.txt\");\n+///\n+/// for component in path.components() {\n+///     println!(\"{:?}\", component);\n+/// }\n+/// ```\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Components<'a> {\n@@ -609,6 +630,16 @@ impl<'a> Components<'a> {\n     }\n \n     /// Extract a slice corresponding to the portion of the path remaining for iteration.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo/bar.txt\");\n+    ///\n+    /// println!(\"{:?}\", path.components().as_path());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_path(&self) -> &'a Path {\n         let mut comps = self.clone();\n@@ -1210,12 +1241,28 @@ impl Path {\n     /// Directly wrap a string slice as a `Path` slice.\n     ///\n     /// This is a cost-free conversion.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// Path::new(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path {\n         unsafe { mem::transmute(s.as_ref()) }\n     }\n \n     /// Yield the underlying `OsStr` slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let os_str = Path::new(\"foo.txt\").as_os_str();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(&self) -> &OsStr {\n         &self.inner\n@@ -1224,6 +1271,14 @@ impl Path {\n     /// Yield a `&str` slice if the `Path` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path_str = Path::new(\"foo.txt\").to_str();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_str(&self) -> Option<&str> {\n         self.inner.to_str()\n@@ -1232,12 +1287,28 @@ impl Path {\n     /// Convert a `Path` to a `Cow<str>`.\n     ///\n     /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path_str = Path::new(\"foo.txt\").to_string_lossy();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         self.inner.to_string_lossy()\n     }\n \n     /// Convert a `Path` to an owned `PathBuf`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path_str = Path::new(\"foo.txt\").to_path_buf();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_path_buf(&self) -> PathBuf {\n         PathBuf::from(self.inner.to_os_string())\n@@ -1251,13 +1322,29 @@ impl Path {\n     /// * On Windows, a path is absolute if it has a prefix and starts with the\n     /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not. In\n     /// other words, `path.is_absolute() == path.prefix().is_some() && path.has_root()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// assert_eq!(false, Path::new(\"foo.txt\").is_absolute());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_absolute(&self) -> bool {\n         self.has_root() &&\n             (cfg!(unix) || self.prefix().is_some())\n     }\n \n     /// A path is *relative* if it is not absolute.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// assert!(Path::new(\"foo.txt\").is_relative());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_relative(&self) -> bool {\n         !self.is_absolute()\n@@ -1281,6 +1368,14 @@ impl Path {\n     ///     * has no prefix and begins with a separator, e.g. `\\\\windows`\n     ///     * has a prefix followed by a separator, e.g. `c:\\windows` but not `c:windows`\n     ///     * has any non-disk prefix, e.g. `\\\\server\\share`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// assert!(Path::new(\"/etc/passwd\").has_root());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn has_root(&self) -> bool {\n          self.components().has_root()\n@@ -1297,8 +1392,11 @@ impl Path {\n     ///\n     /// let path = Path::new(\"/foo/bar\");\n     /// let foo = path.parent().unwrap();\n+    ///\n     /// assert!(foo == Path::new(\"/foo\"));\n+    ///\n     /// let root = foo.parent().unwrap();\n+    ///\n     /// assert!(root == Path::new(\"/\"));\n     /// assert!(root.parent() == None);\n     /// ```\n@@ -1318,6 +1416,17 @@ impl Path {\n     ///\n     /// If the path terminates in `.`, `..`, or consists solely or a root of\n     /// prefix, `file_name` will return `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"hello_world.rs\");\n+    /// let filename = \"hello_world.rs\";\n+    ///\n+    /// assert_eq!(filename, path.file_name().unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n         self.components().next_back().and_then(|p| match p {\n@@ -1337,12 +1446,32 @@ impl Path {\n     }\n \n     /// Determines whether `base` is a prefix of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/etc/passwd\");\n+    ///\n+    /// assert!(path.starts_with(\"/etc\"));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool {\n         iter_after(self.components(), base.as_ref().components()).is_some()\n     }\n \n     /// Determines whether `child` is a suffix of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/etc/passwd\");\n+    ///\n+    /// assert!(path.ends_with(\"passwd\"));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool {\n         iter_after(self.components().rev(), child.as_ref().components().rev()).is_some()\n@@ -1356,6 +1485,16 @@ impl Path {\n     /// * The entire file name if there is no embedded `.`;\n     /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name before the final `.`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"foo.rs\");\n+    ///\n+    /// assert_eq!(\"foo\", path.file_stem().unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_stem(&self) -> Option<&OsStr> {\n         self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.or(after))\n@@ -1369,6 +1508,16 @@ impl Path {\n     /// * None, if there is no embedded `.`;\n     /// * None, if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name after the final `.`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"foo.rs\");\n+    ///\n+    /// assert_eq!(\"rs\", path.extension().unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn extension(&self) -> Option<&OsStr> {\n         self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.and(after))\n@@ -1377,6 +1526,16 @@ impl Path {\n     /// Creates an owned `PathBuf` with `path` adjoined to `self`.\n     ///\n     /// See `PathBuf::push` for more details on what it means to adjoin a path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp\");\n+    ///\n+    /// let new_path = path.join(\"foo\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf {\n         let mut buf = self.to_path_buf();\n@@ -1387,6 +1546,16 @@ impl Path {\n     /// Creates an owned `PathBuf` like `self` but with the given file name.\n     ///\n     /// See `PathBuf::set_file_name` for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// let new_path = path.with_file_name(\"bar.rs\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n@@ -1397,6 +1566,16 @@ impl Path {\n     /// Creates an owned `PathBuf` like `self` but with the given extension.\n     ///\n     /// See `PathBuf::set_extension` for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// let new_path = path.with_extension(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n@@ -1405,6 +1584,18 @@ impl Path {\n     }\n \n     /// Produce an iterator over the components of the path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// for component in path.components() {\n+    ///     println!(\"{:?}\", component);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn components(&self) -> Components {\n         let prefix = parse_prefix(self.as_os_str());\n@@ -1418,13 +1609,35 @@ impl Path {\n     }\n \n     /// Produce an iterator over the path's components viewed as `OsStr` slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// for component in path.iter() {\n+    ///     println!(\"{:?}\", component);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n         Iter { inner: self.components() }\n     }\n \n     /// Returns an object that implements `Display` for safely printing paths\n     /// that may contain non-Unicode data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// println!(\"{}\", path.display());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn display(&self) -> Display {\n         Display { path: self }"}, {"sha": "38c57eec684dbda7ff4f4d8eea948249ed532451", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -185,9 +185,9 @@ mod imp {\n mod imp {\n     use prelude::v1::*;\n \n+    use io;\n     use old_io::IoResult;\n     use mem;\n-    use os;\n     use rand::Rng;\n     use libc::{c_int, size_t};\n \n@@ -241,7 +241,7 @@ mod imp {\n                 SecRandomCopyBytes(kSecRandomDefault, v.len() as size_t, v.as_mut_ptr())\n             };\n             if ret == -1 {\n-                panic!(\"couldn't generate random bytes: {}\", os::last_os_error());\n+                panic!(\"couldn't generate random bytes: {}\", io::Error::last_os_error());\n             }\n         }\n     }"}, {"sha": "beb2870807a7e1aab75edf77b704879eb78e50ca", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -64,7 +64,7 @@ pub fn cleanup() {\n             if queue as usize != 0 {\n                 let queue: Box<Queue> = Box::from_raw(queue);\n                 for to_run in *queue {\n-                    to_run.invoke(());\n+                    to_run();\n                 }\n             }\n         }"}, {"sha": "632d964721239661442c9bb1cba5b78d66bd8360", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -21,7 +21,6 @@\n \n use prelude::v1::*;\n use sys;\n-use thunk::Thunk;\n use usize;\n \n // Reexport some of our utilities which are expected by other crates.\n@@ -153,7 +152,7 @@ fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {\n /// that the closure could not be registered, meaning that it is not scheduled\n /// to be rune.\n pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n-    if at_exit_imp::push(Thunk::new(f)) {Ok(())} else {Err(())}\n+    if at_exit_imp::push(Box::new(f)) {Ok(())} else {Err(())}\n }\n \n /// One-time runtime cleanup."}, {"sha": "a7d8b287a64c031567a8605f50c69fb8ef6dc9a8", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -140,33 +140,43 @@ impl Condvar {\n     /// Wait on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///\n-    /// The semantics of this function are equivalent to `wait()` except that\n-    /// the thread will be blocked for roughly no longer than `dur`. This method\n-    /// should not be used for precise timing due to anomalies such as\n-    /// preemption or platform differences that may not cause the maximum amount\n-    /// of time waited to be precisely `dur`.\n+    /// The semantics of this function are equivalent to `wait()`\n+    /// except that the thread will be blocked for roughly no longer\n+    /// than `ms` milliseconds. This method should not be used for\n+    /// precise timing due to anomalies such as preemption or platform\n+    /// differences that may not cause the maximum amount of time\n+    /// waited to be precisely `ms`.\n     ///\n-    /// If the wait timed out, then `false` will be returned. Otherwise if a\n-    /// notification was received then `true` will be returned.\n+    /// The returned boolean is `false` only if the timeout is known\n+    /// to have elapsed.\n     ///\n     /// Like `wait`, the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n-                           -> LockResult<(MutexGuard<'a, T>, bool)> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn wait_timeout_ms<'a, T>(&self, guard: MutexGuard<'a, T>, ms: u32)\n+                                  -> LockResult<(MutexGuard<'a, T>, bool)> {\n         unsafe {\n             let me: &'static Condvar = &*(self as *const _);\n-            me.inner.wait_timeout(guard, dur)\n+            me.inner.wait_timeout_ms(guard, ms)\n         }\n     }\n \n+    /// Deprecated: use `wait_timeout_ms` instead.\n+    #[unstable(feature = \"std_misc\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use wait_timeout_ms instead\")]\n+    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n+                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n+        self.wait_timeout_ms(guard, dur.num_milliseconds() as u32)\n+    }\n+\n     /// Wait on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///\n     /// The semantics of this function are equivalent to `wait_timeout` except\n     /// that the implementation will repeatedly wait while the duration has not\n     /// passed and the provided function returns `false`.\n-    #[unstable(feature = \"std_misc\")]\n+    #[unstable(feature = \"wait_timeout_with\",\n+               reason = \"unsure if this API is broadly needed or what form it should take\")]\n     pub fn wait_timeout_with<'a, T, F>(&self,\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n@@ -235,12 +245,12 @@ impl StaticCondvar {\n     /// See `Condvar::wait_timeout`.\n     #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Condvar in the future\")]\n-    pub fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)\n-                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n+    pub fn wait_timeout_ms<'a, T>(&'static self, guard: MutexGuard<'a, T>, ms: u32)\n+                                  -> LockResult<(MutexGuard<'a, T>, bool)> {\n         let (poisoned, success) = unsafe {\n             let lock = mutex::guard_lock(&guard);\n             self.verify(lock);\n-            let success = self.inner.wait_timeout(lock, dur);\n+            let success = self.inner.wait_timeout(lock, Duration::milliseconds(ms as i64));\n             (mutex::guard_poison(&guard).get(), success)\n         };\n         if poisoned {\n@@ -275,7 +285,8 @@ impl StaticCondvar {\n             let now = SteadyTime::now();\n             let consumed = &now - &start;\n             let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n-            let (new_guard_result, no_timeout) = match self.wait_timeout(guard, dur - consumed) {\n+            let res = self.wait_timeout_ms(guard, (dur - consumed).num_milliseconds() as u32);\n+            let (new_guard_result, no_timeout) = match res {\n                 Ok((new_guard, no_timeout)) => (Ok(new_guard), no_timeout),\n                 Err(err) => {\n                     let (new_guard, no_timeout) = err.into_inner();\n@@ -350,6 +361,7 @@ mod tests {\n     use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n     use thread;\n     use time::Duration;\n+    use u32;\n \n     #[test]\n     fn smoke() {\n@@ -418,19 +430,19 @@ mod tests {\n     }\n \n     #[test]\n-    fn wait_timeout() {\n+    fn wait_timeout_ms() {\n         static C: StaticCondvar = CONDVAR_INIT;\n         static M: StaticMutex = MUTEX_INIT;\n \n         let g = M.lock().unwrap();\n-        let (g, _no_timeout) = C.wait_timeout(g, Duration::nanoseconds(1000)).unwrap();\n+        let (g, _no_timeout) = C.wait_timeout_ms(g, 1).unwrap();\n         // spurious wakeups mean this isn't necessarily true\n         // assert!(!no_timeout);\n         let _t = thread::spawn(move || {\n             let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n-        let (g, no_timeout) = C.wait_timeout(g, Duration::days(1)).unwrap();\n+        let (g, no_timeout) = C.wait_timeout_ms(g, u32::MAX).unwrap();\n         assert!(no_timeout);\n         drop(g);\n         unsafe { C.destroy(); M.destroy(); }"}, {"sha": "2cdde1aca9e682c7696d67ffad62c8f45adaa043", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -36,6 +36,7 @@\n use core::prelude::*;\n use core::mem::replace;\n \n+use boxed::Box;\n use self::FutureState::*;\n use sync::mpsc::{Receiver, channel};\n use thunk::Thunk;\n@@ -84,7 +85,7 @@ impl<A> Future<A> {\n                 match replace(&mut self.state, Evaluating) {\n                     Forced(_) | Evaluating => panic!(\"Logic error.\"),\n                     Pending(f) => {\n-                        self.state = Forced(f.invoke(()));\n+                        self.state = Forced(f());\n                         self.get_ref()\n                     }\n                 }\n@@ -114,7 +115,7 @@ impl<A> Future<A> {\n          * function. It is not spawned into another task.\n          */\n \n-        Future {state: Pending(Thunk::new(f))}\n+        Future {state: Pending(Box::new(f))}\n     }\n }\n "}, {"sha": "1845b6266ed8d1aa405ad7581278205ef5a30546", "filename": "src/libstd/sys/common/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -25,6 +25,7 @@ pub fn start_thread(main: *mut libc::c_void) {\n     unsafe {\n         stack::record_os_managed_stack_bounds(0, usize::MAX);\n         let _handler = stack_overflow::Handler::new();\n-        Box::from_raw(main as *mut Thunk).invoke(());\n+        let main: Box<Thunk> = Box::from_raw(main as *mut Thunk);\n+        main();\n     }\n }"}, {"sha": "d2220bdec32b78fa1f054a720742c900ac7a6e63", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -409,7 +409,7 @@ pub fn env() -> Env {\n     };\n \n     fn parse(input: &[u8]) -> (OsString, OsString) {\n-        let mut it = input.splitn(1, |b| *b == b'=');\n+        let mut it = input.splitn(2, |b| *b == b'=');\n         let key = it.next().unwrap().to_vec();\n         let default: &[u8] = &[];\n         let val = it.next().unwrap_or(default).to_vec();"}, {"sha": "5fe6e80d6e93a0c851b2c857e9d220b6f6c14051", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -257,7 +257,7 @@ impl Builder {\n     pub fn spawn<F>(self, f: F) -> io::Result<JoinHandle> where\n         F: FnOnce(), F: Send + 'static\n     {\n-        self.spawn_inner(Thunk::new(f)).map(|i| JoinHandle(i))\n+        self.spawn_inner(Box::new(f)).map(|i| JoinHandle(i))\n     }\n \n     /// Spawn a new child thread that must be joined within a given\n@@ -279,7 +279,7 @@ impl Builder {\n     pub fn scoped<'a, T, F>(self, f: F) -> io::Result<JoinGuard<'a, T>> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n-        self.spawn_inner(Thunk::new(f)).map(|inner| {\n+        self.spawn_inner(Box::new(f)).map(|inner| {\n             JoinGuard { inner: inner, _marker: PhantomData }\n         })\n     }\n@@ -315,7 +315,7 @@ impl Builder {\n                 thread_info::set(imp::guard::current(), their_thread);\n             }\n \n-            let mut output = None;\n+            let mut output: Option<T> = None;\n             let try_result = {\n                 let ptr = &mut output;\n \n@@ -327,7 +327,11 @@ impl Builder {\n                 // 'unwinding' flag in the thread itself. For these reasons,\n                 // this unsafety should be ok.\n                 unsafe {\n-                    unwind::try(move || *ptr = Some(f.invoke(())))\n+                    unwind::try(move || {\n+                        let f: Thunk<(), T> = f;\n+                        let v: T = f();\n+                        *ptr = Some(v)\n+                    })\n                 }\n             };\n             unsafe {\n@@ -340,7 +344,7 @@ impl Builder {\n         };\n \n         Ok(JoinInner {\n-            native: try!(unsafe { imp::create(stack_size, Thunk::new(main)) }),\n+            native: try!(unsafe { imp::create(stack_size, Box::new(main)) }),\n             thread: my_thread,\n             packet: my_packet,\n             joined: false,\n@@ -465,9 +469,16 @@ pub fn catch_panic<F, R>(f: F) -> Result<R>\n /// specifics or platform-dependent functionality. Note that on unix platforms\n /// this function will not return early due to a signal being received or a\n /// spurious wakeup.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn sleep_ms(ms: u32) {\n+    imp::sleep(Duration::milliseconds(ms as i64))\n+}\n+\n+/// Deprecated: use `sleep_ms` instead.\n #[unstable(feature = \"thread_sleep\",\n            reason = \"recently added, needs an RFC, and `Duration` itself is \\\n                      unstable\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use sleep_ms instead\")]\n pub fn sleep(dur: Duration) {\n     imp::sleep(dur)\n }\n@@ -501,17 +512,24 @@ pub fn park() {\n /// amount of time waited to be precisely *duration* long.\n ///\n /// See the module doc for more detail.\n-#[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n-pub fn park_timeout(duration: Duration) {\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn park_timeout_ms(ms: u32) {\n     let thread = current();\n     let mut guard = thread.inner.lock.lock().unwrap();\n     if !*guard {\n-        let (g, _) = thread.inner.cvar.wait_timeout(guard, duration).unwrap();\n+        let (g, _) = thread.inner.cvar.wait_timeout_ms(guard, ms).unwrap();\n         guard = g;\n     }\n     *guard = false;\n }\n \n+/// Deprecated: use `park_timeout_ms`\n+#[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use park_timeout_ms instead\")]\n+pub fn park_timeout(duration: Duration) {\n+    park_timeout_ms(duration.num_milliseconds() as u32)\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Thread\n ////////////////////////////////////////////////////////////////////////////////\n@@ -716,6 +734,7 @@ mod test {\n     use thread;\n     use thunk::Thunk;\n     use time::Duration;\n+    use u32;\n \n     // !!! These tests are dangerous. If something is buggy, they will hang, !!!\n     // !!! instead of exiting cleanly. This might wedge the buildbots.       !!!\n@@ -820,7 +839,7 @@ mod test {\n         let x: Box<_> = box 1;\n         let x_in_parent = (&*x) as *const i32 as usize;\n \n-        spawnfn(Thunk::new(move|| {\n+        spawnfn(Box::new(move|| {\n             let x_in_child = (&*x) as *const i32 as usize;\n             tx.send(x_in_child).unwrap();\n         }));\n@@ -832,15 +851,15 @@ mod test {\n     #[test]\n     fn test_avoid_copying_the_body_spawn() {\n         avoid_copying_the_body(|v| {\n-            thread::spawn(move || v.invoke(()));\n+            thread::spawn(move || v());\n         });\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_thread_spawn() {\n         avoid_copying_the_body(|f| {\n             thread::spawn(move|| {\n-                f.invoke(());\n+                f();\n             });\n         })\n     }\n@@ -849,7 +868,7 @@ mod test {\n     fn test_avoid_copying_the_body_join() {\n         avoid_copying_the_body(|f| {\n             let _ = thread::spawn(move|| {\n-                f.invoke(())\n+                f()\n             }).join();\n         })\n     }\n@@ -862,13 +881,13 @@ mod test {\n         // valgrind-friendly. try this at home, instead..!)\n         const GENERATIONS: u32 = 16;\n         fn child_no(x: u32) -> Thunk<'static> {\n-            return Thunk::new(move|| {\n+            return Box::new(move|| {\n                 if x < GENERATIONS {\n-                    thread::spawn(move|| child_no(x+1).invoke(()));\n+                    thread::spawn(move|| child_no(x+1)());\n                 }\n             });\n         }\n-        thread::spawn(|| child_no(0).invoke(()));\n+        thread::spawn(|| child_no(0)());\n     }\n \n     #[test]\n@@ -936,14 +955,14 @@ mod test {\n     fn test_park_timeout_unpark_before() {\n         for _ in 0..10 {\n             thread::current().unpark();\n-            thread::park_timeout(Duration::seconds(10_000_000));\n+            thread::park_timeout_ms(u32::MAX);\n         }\n     }\n \n     #[test]\n     fn test_park_timeout_unpark_not_called() {\n         for _ in 0..10 {\n-            thread::park_timeout(Duration::milliseconds(10));\n+            thread::park_timeout_ms(10);\n         }\n     }\n \n@@ -959,14 +978,13 @@ mod test {\n                 th.unpark();\n             });\n \n-            thread::park_timeout(Duration::seconds(10_000_000));\n+            thread::park_timeout_ms(u32::MAX);\n         }\n     }\n \n     #[test]\n-    fn sleep_smoke() {\n-        thread::sleep(Duration::milliseconds(2));\n-        thread::sleep(Duration::milliseconds(-2));\n+    fn sleep_ms_smoke() {\n+        thread::sleep_ms(2);\n     }\n \n     // NOTE: the corresponding test for stderr is in run-pass/task-stderr, due"}, {"sha": "6091794ed428660162d848512845e186a1b075a9", "filename": "src/libstd/thunk.rs", "status": "modified", "additions": 3, "deletions": 39, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -12,45 +12,9 @@\n #![allow(missing_docs)]\n #![unstable(feature = \"std_misc\")]\n \n-use alloc::boxed::Box;\n+use alloc::boxed::{Box, FnBox};\n use core::marker::Send;\n-use core::ops::FnOnce;\n \n-pub struct Thunk<'a, A=(),R=()> {\n-    invoke: Box<Invoke<A,R>+Send + 'a>,\n-}\n+pub type Thunk<'a, A=(), R=()> =\n+    Box<FnBox<A,Output=R> + Send + 'a>;\n \n-impl<'a, R> Thunk<'a,(),R> {\n-    pub fn new<F>(func: F) -> Thunk<'a,(),R>\n-        where F : FnOnce() -> R, F : Send + 'a\n-    {\n-        Thunk::with_arg(move|()| func())\n-    }\n-}\n-\n-impl<'a,A,R> Thunk<'a,A,R> {\n-    pub fn with_arg<F>(func: F) -> Thunk<'a,A,R>\n-        where F : FnOnce(A) -> R, F : Send + 'a\n-    {\n-        Thunk {\n-            invoke: Box::<F>::new(func)\n-        }\n-    }\n-\n-    pub fn invoke(self, arg: A) -> R {\n-        self.invoke.invoke(arg)\n-    }\n-}\n-\n-pub trait Invoke<A=(),R=()> {\n-    fn invoke(self: Box<Self>, arg: A) -> R;\n-}\n-\n-impl<A,R,F> Invoke<A,R> for F\n-    where F : FnOnce(A) -> R\n-{\n-    fn invoke(self: Box<F>, arg: A) -> R {\n-        let f = *self;\n-        f(arg)\n-    }\n-}"}, {"sha": "2b5cb7076f463c8e4da518d5a5dcf17f32e9fd06", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -53,18 +53,29 @@ impl fmt::Display for PathElem {\n }\n \n #[derive(Clone)]\n-struct LinkedPathNode<'a> {\n+pub struct LinkedPathNode<'a> {\n     node: PathElem,\n     next: LinkedPath<'a>,\n }\n \n-type LinkedPath<'a> = Option<&'a LinkedPathNode<'a>>;\n+#[derive(Copy, Clone)]\n+pub struct LinkedPath<'a>(Option<&'a LinkedPathNode<'a>>);\n+\n+impl<'a> LinkedPath<'a> {\n+    pub fn empty() -> LinkedPath<'a> {\n+        LinkedPath(None)\n+    }\n+\n+    pub fn from(node: &'a LinkedPathNode) -> LinkedPath<'a> {\n+        LinkedPath(Some(node))\n+    }\n+}\n \n impl<'a> Iterator for LinkedPath<'a> {\n     type Item = PathElem;\n \n     fn next(&mut self) -> Option<PathElem> {\n-        match *self {\n+        match self.0 {\n             Some(node) => {\n                 *self = node.next;\n                 Some(node.node)\n@@ -384,7 +395,7 @@ impl<'ast> Map<'ast> {\n     pub fn with_path<T, F>(&self, id: NodeId, f: F) -> T where\n         F: FnOnce(PathElems) -> T,\n     {\n-        self.with_path_next(id, None, f)\n+        self.with_path_next(id, LinkedPath::empty(), f)\n     }\n \n     pub fn path_to_string(&self, id: NodeId) -> String {\n@@ -422,7 +433,7 @@ impl<'ast> Map<'ast> {\n                 _ => f([].iter().cloned().chain(next))\n             }\n         } else {\n-            self.with_path_next(parent, Some(&LinkedPathNode {\n+            self.with_path_next(parent, LinkedPath::from(&LinkedPathNode {\n                 node: self.get_path_elem(id),\n                 next: next\n             }), f)"}, {"sha": "4c01cecc67ca2a0d0091ade31ee159e7700dea64", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -25,7 +25,7 @@\n use self::Status::*;\n use self::AttributeType::*;\n \n-use abi::RustIntrinsic;\n+use abi::Abi;\n use ast::NodeId;\n use ast;\n use attr;\n@@ -91,6 +91,8 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     (\"start\", \"1.0.0\", Active),\n     (\"main\", \"1.0.0\", Active),\n \n+    (\"fundamental\", \"1.0.0\", Active),\n+\n     // Deprecate after snapshot\n     // SNAP 5520801\n     (\"unsafe_destructor\", \"1.0.0\", Active),\n@@ -237,6 +239,10 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"allow_internal_unstable\", Gated(\"allow_internal_unstable\",\n                                       EXPLAIN_ALLOW_INTERNAL_UNSTABLE)),\n \n+    (\"fundamental\", Gated(\"fundamental\",\n+                          \"the `#[fundamental]` attribute \\\n+                           is an experimental feature\")),\n+\n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\"doc\", Whitelisted),\n \n@@ -511,7 +517,7 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                        across platforms, it is recommended to \\\n                                        use `#[link(name = \\\"foo\\\")]` instead\")\n                 }\n-                if foreign_module.abi == RustIntrinsic {\n+                if foreign_module.abi == Abi::RustIntrinsic {\n                     self.gate_feature(\"intrinsics\",\n                                       i.span,\n                                       \"intrinsics are subject to change\")\n@@ -627,11 +633,17 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 span: Span,\n                 _node_id: NodeId) {\n         match fn_kind {\n-            visit::FkItemFn(_, _, _, abi) if abi == RustIntrinsic => {\n+            visit::FkItemFn(_, _, _, abi) if abi == Abi::RustIntrinsic => {\n                 self.gate_feature(\"intrinsics\",\n                                   span,\n                                   \"intrinsics are subject to change\")\n             }\n+            visit::FkItemFn(_, _, _, abi) |\n+            visit::FkMethod(_, &ast::MethodSig { abi, .. }) if abi == Abi::RustCall => {\n+                self.gate_feature(\"unboxed_closures\",\n+                                  span,\n+                                  \"rust-call ABI is subject to change\")\n+            }\n             _ => {}\n         }\n         visit::walk_fn(self, fn_kind, fn_decl, block, span);"}, {"sha": "c2f323f98afc56d5a3808ac1db1bdf3ff1b0482d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -37,6 +37,7 @@ pub enum AnnNode<'a> {\n     NodeName(&'a ast::Name),\n     NodeBlock(&'a ast::Block),\n     NodeItem(&'a ast::Item),\n+    NodeSubItem(ast::NodeId),\n     NodeExpr(&'a ast::Expr),\n     NodePat(&'a ast::Pat),\n }\n@@ -1264,6 +1265,7 @@ impl<'a> State<'a> {\n \n     pub fn print_trait_item(&mut self, ti: &ast::TraitItem)\n                             -> io::Result<()> {\n+        try!(self.ann.pre(self, NodeSubItem(ti.id)));\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(ti.span.lo));\n         try!(self.print_outer_attributes(&ti.attrs));\n@@ -1275,19 +1277,21 @@ impl<'a> State<'a> {\n                 try!(self.print_method_sig(ti.ident, sig, ast::Inherited));\n                 if let Some(ref body) = *body {\n                     try!(self.nbsp());\n-                    self.print_block_with_attrs(body, &ti.attrs)\n+                    try!(self.print_block_with_attrs(body, &ti.attrs));\n                 } else {\n-                    word(&mut self.s, \";\")\n+                    try!(word(&mut self.s, \";\"));\n                 }\n             }\n             ast::TypeTraitItem(ref bounds, ref default) => {\n-                self.print_associated_type(ti.ident, Some(bounds),\n-                                           default.as_ref().map(|ty| &**ty))\n+                try!(self.print_associated_type(ti.ident, Some(bounds),\n+                                                default.as_ref().map(|ty| &**ty)));\n             }\n         }\n+        self.ann.post(self, NodeSubItem(ti.id))\n     }\n \n     pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> {\n+        try!(self.ann.pre(self, NodeSubItem(ii.id)));\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(ii.span.lo));\n         try!(self.print_outer_attributes(&ii.attrs));\n@@ -1296,10 +1300,10 @@ impl<'a> State<'a> {\n                 try!(self.head(\"\"));\n                 try!(self.print_method_sig(ii.ident, sig, ii.vis));\n                 try!(self.nbsp());\n-                self.print_block_with_attrs(body, &ii.attrs)\n+                try!(self.print_block_with_attrs(body, &ii.attrs));\n             }\n             ast::TypeImplItem(ref ty) => {\n-                self.print_associated_type(ii.ident, None, Some(ty))\n+                try!(self.print_associated_type(ii.ident, None, Some(ty)));\n             }\n             ast::MacImplItem(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                                 ..}) => {\n@@ -1311,9 +1315,10 @@ impl<'a> State<'a> {\n                 try!(self.print_tts(&tts[..]));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n-                self.end()\n+                try!(self.end())\n             }\n         }\n+        self.ann.post(self, NodeSubItem(ii.id))\n     }\n \n     pub fn print_outer_attributes(&mut self,"}, {"sha": "00117775eee38cba26a42819eb05960cda19c2b2", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -62,6 +62,7 @@ use self::OutputLocation::*;\n use stats::Stats;\n use getopts::{OptGroup, optflag, optopt};\n use serialize::Encodable;\n+use std::boxed::FnBox;\n use term::Terminal;\n use term::color::{Color, RED, YELLOW, GREEN, CYAN};\n \n@@ -79,7 +80,7 @@ use std::path::PathBuf;\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n-use std::thunk::{Thunk, Invoke};\n+use std::thunk::Thunk;\n use std::time::Duration;\n \n // to be used by rustc to compile tests in libtest\n@@ -158,7 +159,7 @@ pub enum TestFn {\n     StaticBenchFn(fn(&mut Bencher)),\n     StaticMetricFn(fn(&mut MetricMap)),\n     DynTestFn(Thunk<'static>),\n-    DynMetricFn(Box<for<'a> Invoke<&'a mut MetricMap>+'static>),\n+    DynMetricFn(Box<FnBox(&mut MetricMap)+Send>),\n     DynBenchFn(Box<TDynBenchFn+'static>)\n }\n \n@@ -936,7 +937,7 @@ pub fn run_test(opts: &TestOpts,\n                     io::set_print(box Sink(data2.clone()));\n                     io::set_panic(box Sink(data2));\n                 }\n-                testfn.invoke(())\n+                testfn()\n             }).unwrap();\n             let test_result = calc_result(&desc, result_guard.join());\n             let stdout = data.lock().unwrap().to_vec();\n@@ -957,7 +958,7 @@ pub fn run_test(opts: &TestOpts,\n         }\n         DynMetricFn(f) => {\n             let mut mm = MetricMap::new();\n-            f.invoke(&mut mm);\n+            f.call_box((&mut mm,));\n             monitor_ch.send((desc, TrMetrics(mm), Vec::new())).unwrap();\n             return;\n         }\n@@ -969,7 +970,7 @@ pub fn run_test(opts: &TestOpts,\n         }\n         DynTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture, f),\n         StaticTestFn(f) => run_test_inner(desc, monitor_ch, opts.nocapture,\n-                                          Thunk::new(move|| f()))\n+                                          Box::new(move|| f()))\n     }\n }\n \n@@ -1185,7 +1186,7 @@ mod tests {\n                 ignore: true,\n                 should_panic: ShouldPanic::No,\n             },\n-            testfn: DynTestFn(Thunk::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1202,7 +1203,7 @@ mod tests {\n                 ignore: true,\n                 should_panic: ShouldPanic::No,\n             },\n-            testfn: DynTestFn(Thunk::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1219,7 +1220,7 @@ mod tests {\n                 ignore: false,\n                 should_panic: ShouldPanic::Yes(None)\n             },\n-            testfn: DynTestFn(Thunk::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1236,7 +1237,7 @@ mod tests {\n                 ignore: false,\n                 should_panic: ShouldPanic::Yes(Some(\"error message\"))\n             },\n-            testfn: DynTestFn(Thunk::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1253,7 +1254,7 @@ mod tests {\n                 ignore: false,\n                 should_panic: ShouldPanic::Yes(Some(\"foobar\"))\n             },\n-            testfn: DynTestFn(Thunk::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1270,7 +1271,7 @@ mod tests {\n                 ignore: false,\n                 should_panic: ShouldPanic::Yes(None)\n             },\n-            testfn: DynTestFn(Thunk::new(move|| f())),\n+            testfn: DynTestFn(Box::new(move|| f())),\n         };\n         let (tx, rx) = channel();\n         run_test(&TestOpts::new(), false, desc, tx);\n@@ -1306,15 +1307,15 @@ mod tests {\n                     ignore: true,\n                     should_panic: ShouldPanic::No,\n                 },\n-                testfn: DynTestFn(Thunk::new(move|| {})),\n+                testfn: DynTestFn(Box::new(move|| {})),\n             },\n             TestDescAndFn {\n                 desc: TestDesc {\n                     name: StaticTestName(\"2\"),\n                     ignore: false,\n                     should_panic: ShouldPanic::No,\n                 },\n-                testfn: DynTestFn(Thunk::new(move|| {})),\n+                testfn: DynTestFn(Box::new(move|| {})),\n             });\n         let filtered = filter_tests(&opts, tests);\n \n@@ -1350,7 +1351,7 @@ mod tests {\n                         ignore: false,\n                         should_panic: ShouldPanic::No,\n                     },\n-                    testfn: DynTestFn(Thunk::new(testfn)),\n+                    testfn: DynTestFn(Box::new(testfn)),\n                 };\n                 tests.push(test);\n             }"}, {"sha": "a1e1b48c2c4e98a6987a7e8c15839641f8856c7a", "filename": "src/test/auxiliary/coherence_copy_like_lib.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fauxiliary%2Fcoherence_copy_like_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fauxiliary%2Fcoherence_copy_like_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcoherence_copy_like_lib.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"rlib\"]\n+#![feature(fundamental)]\n+\n+use std::marker::MarkerTrait;\n+\n+pub trait MyCopy : MarkerTrait { }\n+impl MyCopy for i32 { }\n+\n+pub struct MyStruct<T>(T);\n+\n+#[fundamental]\n+pub struct MyFundamentalStruct<T>(T);"}, {"sha": "530bbf57d9104f8acec3e13aaa92bd277968b9e5", "filename": "src/test/compile-fail/coherence-cow-1.rs", "status": "renamed", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-1.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -10,16 +10,19 @@\n \n // aux-build:coherence_lib.rs\n \n-// Test that it's ok for T to appear first in the self-type, as long\n-// as it's covered somewhere.\n-\n // pretty-expanded FIXME #23616\n \n+// Test that the `Pair` type reports an error if it contains type\n+// parameters, even when they are covered by local types. This test\n+// was originally intended to test the opposite, but the rules changed\n+// with RFC 1023 and this became illegal.\n+\n extern crate coherence_lib as lib;\n use lib::{Remote,Pair};\n \n pub struct Cover<T>(T);\n \n impl<T> Remote for Pair<T,Cover<T>> { }\n+//~^ ERROR E0210\n \n fn main() { }", "previous_filename": "src/test/run-pass/coherence-cow-1.rs"}, {"sha": "52abceab98b69c9873e29dc4201e37ae1c98c524", "filename": "src/test/compile-fail/coherence-cow-2.rs", "status": "renamed", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-2.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -10,8 +10,10 @@\n \n // aux-build:coherence_lib.rs\n \n-// Test that it's ok for T to appear second in the self-type, as long\n-// as it's covered somewhere.\n+// Test that the `Pair` type reports an error if it contains type\n+// parameters, even when they are covered by local types. This test\n+// was originally intended to test the opposite, but the rules changed\n+// with RFC 1023 and this became illegal.\n \n // pretty-expanded FIXME #23616\n \n@@ -20,6 +22,6 @@ use lib::{Remote,Pair};\n \n pub struct Cover<T>(T);\n \n-impl<T> Remote for Pair<Cover<T>,T> { }\n+impl<T> Remote for Pair<Cover<T>,T> { } //~ ERROR E0210\n \n fn main() { }", "previous_filename": "src/test/run-pass/coherence-cow-2.rs"}, {"sha": "cd32e797ae9bf0a8d237c6b067fc5a82ffd1ce2b", "filename": "src/test/compile-fail/coherence-cow-no-cover.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-no-cover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-no-cover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-cow-no-cover.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -10,14 +10,14 @@\n \n // aux-build:coherence_lib.rs\n \n-// Test that it's not ok for U to appear uncovered\n+// Test that it's not ok for T to appear uncovered\n \n extern crate coherence_lib as lib;\n use lib::{Remote,Pair};\n \n pub struct Cover<T>(T);\n \n impl<T,U> Remote for Pair<Cover<T>,U> { }\n-//~^ ERROR type parameter `U` must be used as the type parameter for some local type\n+//~^ ERROR type parameter `T` must be used as the type parameter for some local type\n \n fn main() { }"}, {"sha": "b99b2e1205b9bfd26c3f93f1fc5af331a8a1dafc", "filename": "src/test/compile-fail/coherence-impls-copy.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-copy.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -23,17 +23,24 @@ impl !Sync for NotSync {}\n \n impl Copy for TestE {}\n impl Copy for MyType {}\n+\n+impl Copy for &'static mut MyType {}\n+//~^ ERROR E0206\n+\n impl Copy for (MyType, MyType) {}\n //~^ ERROR E0206\n+//~| ERROR E0117\n \n impl Copy for &'static NotSync {}\n //~^ ERROR E0206\n \n impl Copy for [MyType] {}\n //~^ ERROR E0206\n+//~| ERROR E0117\n \n impl Copy for &'static [NotSync] {}\n //~^ ERROR E0206\n+//~| ERROR E0117\n \n fn main() {\n }"}, {"sha": "f130a9353516f527462a79183cb49b4436ad7257", "filename": "src/test/compile-fail/coherence-impls-send.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-send.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -24,17 +24,17 @@ impl !Sync for NotSync {}\n unsafe impl Send for TestE {}\n unsafe impl Send for MyType {}\n unsafe impl Send for (MyType, MyType) {}\n-//~^ ERROR E0321\n+//~^ ERROR E0117\n \n unsafe impl Send for &'static NotSync {}\n //~^ ERROR E0321\n \n unsafe impl Send for [MyType] {}\n-//~^ ERROR E0321\n+//~^ ERROR E0117\n \n unsafe impl Send for &'static [NotSync] {}\n-//~^ ERROR E0321\n-//~| ERROR conflicting implementations\n+//~^ ERROR E0117\n+//~| ERROR E0119\n \n fn main() {\n }"}, {"sha": "2ac4bb0492b1f6f4df24a1454829c785aaf66e0f", "filename": "src/test/compile-fail/coherence-impls-sized.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-impls-sized.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -22,12 +22,17 @@ struct NotSync;\n impl !Sync for NotSync {}\n \n impl Sized for TestE {} //~ ERROR E0322\n+\n impl Sized for MyType {} //~ ERROR E0322\n-impl Sized for (MyType, MyType) {} //~ ERROR E0322\n+\n+impl Sized for (MyType, MyType) {} //~ ERROR E0117\n+\n impl Sized for &'static NotSync {} //~ ERROR E0322\n-impl Sized for [MyType] {} //~ ERROR E0322\n+\n+impl Sized for [MyType] {} //~ ERROR E0117\n //~^ ERROR E0277\n-impl Sized for &'static [NotSync] {} //~ ERROR E0322\n+\n+impl Sized for &'static [NotSync] {} //~ ERROR E0117\n \n fn main() {\n }"}, {"sha": "d7f060a3bfe73dfb87be02c0858c64ef255a8e51", "filename": "src/test/compile-fail/coherence-overlap-issue-23516.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-overlap-issue-23516.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that we consider `Box<U>: !Sugar` to be ambiguous, even\n+// though we see no impl of `Sugar` for `Box`. Therefore, an overlap\n+// error is reported for the following pair of impls (#23516).\n+\n+pub trait Sugar { fn dummy(&self) { } }\n+pub trait Sweet { fn dummy(&self) { } }\n+impl<T:Sugar> Sweet for T { } //~ ERROR E0119\n+impl<U:Sugar> Sweet for Box<U> { }\n+fn main() { }"}, {"sha": "5f0b56af2c22637b279877731b7d404b24b906e9", "filename": "src/test/compile-fail/coherence-vec-local-2.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local-2.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that a local, generic type appearing within a\n+// *non-fundamental* remote type like `Vec` is not considered local.\n+\n // aux-build:coherence_lib.rs\n \n // pretty-expanded FIXME #23616\n@@ -17,6 +20,6 @@ use lib::Remote;\n \n struct Local<T>(T);\n \n-impl<T> Remote for Vec<Local<T>> { }\n+impl<T> Remote for Vec<Local<T>> { } //~ ERROR E0210\n \n fn main() { }", "previous_filename": "src/test/run-pass/coherence-local-2.rs"}, {"sha": "c354caac2b5c261714f3f62c5d381b6d2c060d8c", "filename": "src/test/compile-fail/coherence-vec-local.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-vec-local.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Test that a local type (with no type parameters) appearing within a\n+// *non-fundamental* remote type like `Vec` is not considered local.\n+\n // aux-build:coherence_lib.rs\n \n // pretty-expanded FIXME #23616\n@@ -17,6 +20,6 @@ use lib::Remote;\n \n struct Local;\n \n-impl Remote for Vec<Local> { }\n+impl Remote for Vec<Local> { } //~ ERROR E0117\n \n fn main() { }", "previous_filename": "src/test/run-pass/coherence-local-1.rs"}, {"sha": "f13175ce8e2a4e1ce3fbfb66f00b6d202b75b5f5", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+impl<T: lib::MyCopy> MyTrait for T { }\n+\n+// `MyFundamentalStruct` is declared fundamental, so we can test that\n+//\n+//    MyFundamentalStruct<MyTrait>: !MyTrait\n+//\n+// Huzzah.\n+impl MyTrait for lib::MyFundamentalStruct<MyType> { }\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "ae3d242af705ea9b7b5a1a9ba3fa8cbb7c891c79", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct_ref.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_ref.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+impl<T: lib::MyCopy> MyTrait for T { }\n+\n+// `MyFundamentalStruct` is declared fundamental, so we can test that\n+//\n+//    MyFundamentalStruct<&MyTrait>: !MyTrait\n+//\n+// Huzzah.\n+impl<'a> MyTrait for lib::MyFundamentalStruct<&'a MyType> { }\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "c4e95e772356a8f471b59632b41914ccf459ed98", "filename": "src/test/compile-fail/coherence_copy_like_err_fundamental_struct_tuple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_fundamental_struct_tuple.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+\n+impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n+\n+// Tuples are not fundamental.\n+impl MyTrait for lib::MyFundamentalStruct<(MyType,)> { }\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "f768a475ee820701332512b21ed921a36fd433e0", "filename": "src/test/compile-fail/coherence_copy_like_err_struct.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_struct.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n+\n+// `MyStruct` is not declared fundamental, therefore this would\n+// require that\n+//\n+//     MyStruct<MyType>: !MyTrait\n+//\n+// which we cannot approve.\n+impl MyTrait for lib::MyStruct<MyType> { }\n+\n+fn main() { }"}, {"sha": "0c78fffd2dfab2ca1a7094eb6fcf21508143f2ef", "filename": "src/test/compile-fail/coherence_copy_like_err_tuple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_copy_like_err_tuple.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+impl<T: lib::MyCopy> MyTrait for T { } //~ ERROR E0119\n+\n+// Tuples are not fundamental, therefore this would require that\n+//\n+//     (MyType,): !MyTrait\n+//\n+// which we cannot approve.\n+impl MyTrait for (MyType,) { }\n+\n+fn main() { }"}, {"sha": "551577b6b4e08c8c820e827f0884b0c4925c16d4", "filename": "src/test/compile-fail/coherence_local.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_local.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+struct MyType { x: i32 }\n+\n+// These are all legal because they are all fundamental types:\n+\n+impl lib::MyCopy for MyType { }\n+impl<'a> lib::MyCopy for &'a MyType { }\n+impl<'a> lib::MyCopy for &'a Box<MyType> { }\n+impl lib::MyCopy for Box<MyType> { }\n+impl lib::MyCopy for lib::MyFundamentalStruct<MyType> { }\n+impl lib::MyCopy for lib::MyFundamentalStruct<Box<MyType>> { }\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "01f4c1cd8a5c9f311786dfd95be76214e572da04", "filename": "src/test/compile-fail/coherence_local_err_struct.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_struct.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+struct MyType { x: i32 }\n+\n+// These are all legal because they are all fundamental types:\n+\n+// MyStruct is not fundamental.\n+impl lib::MyCopy for lib::MyStruct<MyType> { } //~ ERROR E0117\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "590f68cee59ef3fb9898f5e1a6822559344cf39e", "filename": "src/test/compile-fail/coherence_local_err_tuple.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_local_err_tuple.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+struct MyType { x: i32 }\n+\n+// These are all legal because they are all fundamental types:\n+\n+// Tuples are not fundamental, so this is not a local impl.\n+impl lib::MyCopy for (MyType,) { } //~ ERROR E0117\n+\n+#[rustc_error]\n+fn main() { }"}, {"sha": "f6e1aab59766a1e7d0b1884516cf37c7cb21f889", "filename": "src/test/compile-fail/coherence_local_ref.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_local_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fcoherence_local_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_local_ref.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+struct MyType { x: i32 }\n+\n+// naturally, legal\n+impl lib::MyCopy for MyType { }\n+\n+#[rustc_error]\n+fn main() { } //~ ERROR compilation successful"}, {"sha": "2d87345db2245f5c71701480ad892e3cceda4f61", "filename": "src/test/compile-fail/dst-bad-coerce1.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coerce1.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -23,10 +23,6 @@ pub fn main() {\n     let f2: &Fat<[isize; 3]> = &f1;\n     let f3: &Fat<[usize]> = f2;\n     //~^ ERROR mismatched types\n-    //~| expected `&Fat<[usize]>`\n-    //~| found `&Fat<[isize; 3]>`\n-    //~| expected usize\n-    //~| found isize\n \n     // With a trait.\n     let f1 = Fat { ptr: Foo };"}, {"sha": "029a9cad65fcfe3869fa53904eb47ca1dbfad181", "filename": "src/test/compile-fail/feature-gate-rust-call.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rust-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rust-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-rust-call.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern \"rust-call\" fn foo() { } //~ ERROR rust-call ABI is subject to change\n+\n+trait Foo {\n+    extern \"rust-call\" fn foo();\n+}\n+\n+impl Foo for i32 {\n+    extern \"rust-call\" fn foo() { } //~ ERROR rust-call ABI is subject to change\n+}\n+\n+fn main() { }"}, {"sha": "5df309321d3108a956131d8494dfc1d1a1ccd1f4", "filename": "src/test/compile-fail/feature-gate-unboxed-closures-manual-impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -17,23 +17,23 @@\n \n struct Foo;\n impl Fn<()> for Foo {\n-    //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n     extern \"rust-call\" fn call(self, args: ()) -> () {}\n+    //~^ ERROR rust-call ABI is subject to change\n }\n struct Foo1;\n impl FnOnce() for Foo1 {\n-    //~^ ERROR associated type bindings are not allowed here\n     extern \"rust-call\" fn call_once(self, args: ()) -> () {}\n+    //~^ ERROR rust-call ABI is subject to change\n }\n struct Bar;\n impl FnMut<()> for Bar {\n-    //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n     extern \"rust-call\" fn call_mut(&self, args: ()) -> () {}\n+    //~^ ERROR rust-call ABI is subject to change\n }\n struct Baz;\n impl FnOnce<()> for Baz {\n-    //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n     extern \"rust-call\" fn call_once(&self, args: ()) -> () {}\n+    //~^ ERROR rust-call ABI is subject to change\n }\n \n fn main() {}"}, {"sha": "4fba45e2a66c589f61ff74396997e632b30088ae", "filename": "src/test/compile-fail/object-lifetime-default-elision.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-elision.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -81,8 +81,8 @@ fn load3<'a,'b>(ss: &'a SomeTrait) -> &'b SomeTrait {\n     // which fails to type check.\n \n     ss\n-        //~^ ERROR cannot infer\n-        //~| ERROR mismatched types\n+        //~^ ERROR lifetime of the source pointer does not outlive lifetime bound\n+        //~| ERROR cannot infer\n }\n \n fn main() {"}, {"sha": "7fae530984f898e36b8781d30e7eb577fee63bd4", "filename": "src/test/compile-fail/object-lifetime-default-from-box-error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-lifetime-default-from-box-error.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -25,7 +25,7 @@ fn load(ss: &mut SomeStruct) -> Box<SomeTrait> {\n     // `Box<SomeTrait>` defaults to a `'static` bound, so this return\n     // is illegal.\n \n-    ss.r //~ ERROR mismatched types\n+    ss.r //~ ERROR lifetime of the source pointer does not outlive lifetime bound\n }\n \n fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n@@ -38,7 +38,7 @@ fn store(ss: &mut SomeStruct, b: Box<SomeTrait>) {\n fn store1<'b>(ss: &mut SomeStruct, b: Box<SomeTrait+'b>) {\n     // Here we override the lifetimes explicitly, and so naturally we get an error.\n \n-    ss.r = b; //~ ERROR mismatched types\n+    ss.r = b; //~ ERROR lifetime of the source pointer does not outlive lifetime bound\n }\n \n fn main() {"}, {"sha": "10b883d4dc830b8568e8eb3391d5ffe0a0f3e0fc", "filename": "src/test/compile-fail/regions-close-over-type-parameter-multiple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-multiple.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -27,7 +27,7 @@ fn make_object_good2<'a,'b,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'b> {\n \n fn make_object_bad<'a,'b,'c,A:SomeTrait+'a+'b>(v: A) -> Box<SomeTrait+'c> {\n     // A outlives 'a AND 'b...but not 'c.\n-    box v as Box<SomeTrait+'a> //~ ERROR mismatched types\n+    box v as Box<SomeTrait+'a> //~ ERROR lifetime of the source pointer does not outlive\n }\n \n fn main() {"}, {"sha": "f3722690ef8959f27e0e158d3e2329cb7f0b01fd", "filename": "src/test/compile-fail/regions-trait-object-subtyping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-object-subtyping.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -22,7 +22,7 @@ fn foo2<'a:'b,'b>(x: &'b mut (Dummy+'a)) -> &'b mut (Dummy+'b) {\n \n fn foo3<'a,'b>(x: &'a mut Dummy) -> &'b mut Dummy {\n     // Without knowing 'a:'b, we can't coerce\n-    x //~ ERROR mismatched types\n+    x //~ ERROR lifetime of the source pointer does not outlive\n      //~^ ERROR cannot infer\n }\n "}, {"sha": "b1febae76803608b861d36212c623c964e92400e", "filename": "src/test/compile-fail/typeck-default-trait-impl-cross-crate-coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-cross-crate-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-cross-crate-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-default-trait-impl-cross-crate-coherence.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -20,15 +20,15 @@ extern crate typeck_default_trait_impl_cross_crate_coherence_lib as lib;\n use lib::DefaultedTrait;\n \n struct A;\n-impl DefaultedTrait for (A,) { } //~ ERROR E0321\n+impl DefaultedTrait for (A,) { } //~ ERROR E0117\n \n struct B;\n-impl !DefaultedTrait for (B,) { } //~ ERROR E0321\n+impl !DefaultedTrait for (B,) { } //~ ERROR E0117\n \n struct C;\n struct D<T>(T);\n impl DefaultedTrait for Box<C> { } //~ ERROR E0321\n-impl DefaultedTrait for lib::Something<C> { } //~ ERROR E0321\n+impl DefaultedTrait for lib::Something<C> { } //~ ERROR E0117\n impl DefaultedTrait for D<C> { } // OK\n \n fn main() { }"}, {"sha": "63536b1383475be0889ea6b93bb21a572f6ccb74", "filename": "src/test/debuginfo/unreachable-locals.rs", "status": "modified", "additions": 84, "deletions": 1, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fdebuginfo%2Funreachable-locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Fdebuginfo%2Funreachable-locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funreachable-locals.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -26,6 +26,22 @@ fn after_return() {\n         (a, ref b) => {}\n     }\n     for a in &[111i32] {}\n+    let test = if some_predicate() { 1 } else { 2 };\n+    while some_predicate() {\n+        let abc = !some_predicate();\n+    }\n+    loop {\n+        let abc = !some_predicate();\n+        break;\n+    }\n+    // nested block\n+    {\n+        let abc = !some_predicate();\n+\n+        {\n+            let def = !some_predicate();\n+        }\n+    }\n }\n \n fn after_panic() {\n@@ -36,6 +52,22 @@ fn after_panic() {\n         (a, ref b) => {}\n     }\n     for a in &[111i32] {}\n+    let test = if some_predicate() { 1 } else { 2 };\n+    while some_predicate() {\n+        let abc = !some_predicate();\n+    }\n+    loop {\n+        let abc = !some_predicate();\n+        break;\n+    }\n+    // nested block\n+    {\n+        let abc = !some_predicate();\n+\n+        {\n+            let def = !some_predicate();\n+        }\n+    }\n }\n \n fn after_diverging_function() {\n@@ -46,6 +78,22 @@ fn after_diverging_function() {\n         (a, ref b) => {}\n     }\n     for a in &[111i32] {}\n+    let test = if some_predicate() { 1 } else { 2 };\n+    while some_predicate() {\n+        let abc = !some_predicate();\n+    }\n+    loop {\n+        let abc = !some_predicate();\n+        break;\n+    }\n+    // nested block\n+    {\n+        let abc = !some_predicate();\n+\n+        {\n+            let def = !some_predicate();\n+        }\n+    }\n }\n \n fn after_break() {\n@@ -57,18 +105,50 @@ fn after_break() {\n             (a, ref b) => {}\n         }\n         for a in &[111i32] {}\n+        let test = if some_predicate() { 1 } else { 2 };\n+        while some_predicate() {\n+            let abc = !some_predicate();\n+        }\n+        loop {\n+            let abc = !some_predicate();\n+            break;\n+        }\n+        // nested block\n+        {\n+            let abc = !some_predicate();\n+\n+            {\n+                let def = !some_predicate();\n+            }\n+        }\n     }\n }\n \n fn after_continue() {\n     for _ in 0..10i32 {\n-        break;\n+        continue;\n         let x = \"0\";\n         let (ref y,z) = (1i32, 2u32);\n         match (20i32, 'c') {\n             (a, ref b) => {}\n         }\n         for a in &[111i32] {}\n+        let test = if some_predicate() { 1 } else { 2 };\n+        while some_predicate() {\n+            let abc = !some_predicate();\n+        }\n+        loop {\n+            let abc = !some_predicate();\n+            break;\n+        }\n+        // nested block\n+        {\n+            let abc = !some_predicate();\n+\n+            {\n+                let def = !some_predicate();\n+            }\n+        }\n     }\n }\n \n@@ -83,3 +163,6 @@ fn main() {\n fn diverge() -> ! {\n     panic!();\n }\n+\n+fn some_predicate() -> bool { true || false }\n+"}, {"sha": "26a05f8490fd191d207d60a90d03fc0e7e3efd3d", "filename": "src/test/run-make/rustdoc-extern-method/bar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-make%2Frustdoc-extern-method%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-make%2Frustdoc-extern-method%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-extern-method%2Fbar.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unboxed_closures)]\n+\n extern crate foo;\n \n // @has bar/trait.Foo.html //pre \"pub trait Foo\""}, {"sha": "96a7a8378b792e04d01a0e5837043f455417af05", "filename": "src/test/run-make/rustdoc-extern-method/foo.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-make%2Frustdoc-extern-method%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-make%2Frustdoc-extern-method%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Frustdoc-extern-method%2Ffoo.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![crate_type=\"lib\"]\n+#![feature(unboxed_closures)]\n \n pub trait Foo {\n     extern \"rust-call\" fn foo(&self, _: ()) -> i32;"}, {"sha": "db9893613ad111816a167af5bb6b6c98949cc004", "filename": "src/test/run-pass/coherence_copy_like.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fcoherence_copy_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fcoherence_copy_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence_copy_like.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to introduce a negative constraint that\n+// `MyType: !MyTrait` along with other \"fundamental\" wrappers.\n+\n+// aux-build:coherence_copy_like_lib.rs\n+\n+extern crate coherence_copy_like_lib as lib;\n+\n+use std::marker::MarkerTrait;\n+\n+struct MyType { x: i32 }\n+\n+trait MyTrait : MarkerTrait { }\n+impl<T: lib::MyCopy> MyTrait for T { }\n+impl MyTrait for MyType { }\n+impl<'a> MyTrait for &'a MyType { }\n+impl MyTrait for Box<MyType> { }\n+impl<'a> MyTrait for &'a Box<MyType> { }\n+\n+fn main() { }"}, {"sha": "3ad78f088f9c9f5fe26e92187f40e0cee21218d7", "filename": "src/test/run-pass/issue-11709.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-11709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-11709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11709.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -25,7 +25,7 @@ fn test(slot: &mut Option<Thunk<(),Thunk>>) -> () {\n   let a = slot.take();\n   let _a = match a {\n     // `{let .. a(); }` would break\n-    Some(a) => { let _a = a.invoke(()); },\n+    Some(a) => { let _a = a(); },\n     None => (),\n   };\n }"}, {"sha": "def85b4766783ff499e58efd9a8859a995968c03", "filename": "src/test/run-pass/issue-11958.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-11958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-11958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11958.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -23,5 +23,5 @@ use std::thunk::Thunk;\n \n pub fn main() {\n     let mut x = 1;\n-    let _thunk = Thunk::new(move|| { x = 2; });\n+    let _thunk = Box::new(move|| { x = 2; });\n }"}, {"sha": "cf8c54fdd808667afc3262f7791369e8746e8ec6", "filename": "src/test/run-pass/issue-17897.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-17897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-17897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17897.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -12,10 +12,10 @@\n \n use std::thunk::Thunk;\n \n-fn action(cb: Thunk<usize, usize>) -> usize {\n-    cb.invoke(1)\n+fn action(cb: Thunk<(usize,), usize>) -> usize {\n+    cb(1)\n }\n \n pub fn main() {\n-    println!(\"num: {}\", action(Thunk::with_arg(move |u| u)));\n+    println!(\"num: {}\", action(Box::new(move |u| u)));\n }"}, {"sha": "059d25173c2ad75e57f88fa3f2b979a13092eeb2", "filename": "src/test/run-pass/issue-18188.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-18188.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-18188.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18188.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -16,13 +16,13 @@ use std::thunk::Thunk;\n \n pub trait Promisable: Send + Sync {}\n impl<T: Send + Sync> Promisable for T {}\n-pub fn propagate<'a, T, E, F, G>(action: F) -> Thunk<'a,Result<T, E>, Result<T, E>>\n+pub fn propagate<'a, T, E, F, G>(action: F) -> Thunk<'a, (Result<T, E>,), Result<T, E>>\n     where\n         T: Promisable + Clone + 'a,\n         E: Promisable + Clone + 'a,\n         F: FnOnce(&T) -> Result<T, E> + Send + 'a,\n         G: FnOnce(Result<T, E>) -> Result<T, E> + 'a {\n-    Thunk::with_arg(move |result: Result<T, E>| {\n+    Box::new(move |result: Result<T, E>| {\n         match result {\n             Ok(ref t) => action(t),\n             Err(ref e) => Err(e.clone()),"}, {"sha": "5c84c30aa7fa3631a7fc277f4697f3cb8def9f1e", "filename": "src/test/run-pass/issue-2190-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2190-1.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -18,11 +18,11 @@ use std::thunk::Thunk;\n static generations: usize = 1024+256+128+49;\n \n fn spawn(f: Thunk<'static>) {\n-    Builder::new().stack_size(32 * 1024).spawn(move|| f.invoke(()));\n+    Builder::new().stack_size(32 * 1024).spawn(move|| f());\n }\n \n fn child_no(x: usize) -> Thunk<'static> {\n-    Thunk::new(move|| {\n+    Box::new(move|| {\n         if x < generations {\n             spawn(child_no(x+1));\n         }"}, {"sha": "2167a3df9766ffd471abad9e07e154448ae16308", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -13,7 +13,6 @@\n \n use std::thread;\n use std::sync::mpsc::Sender;\n-use std::thunk::Invoke;\n \n type RingBuffer = Vec<f64> ;\n type SamplesFn = Box<FnMut(&RingBuffer) + Send>;"}, {"sha": "2ceff22adb9eb4da6e5d204d9b00c8c6711056e1", "filename": "src/test/run-pass/method-two-trait-defer-resolution-2.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-trait-defer-resolution-2.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -8,13 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that we pick which version of `Foo` to run based on whether\n-// the type we (ultimately) inferred for `x` is copyable or not.\n-//\n-// In this case, the two versions are both impls of same trait, and\n-// hence we we can resolve method even without knowing yet which\n-// version will run (note that the `push` occurs after the call to\n-// `foo()`).\n+// Test that when we write `x.foo()`, we do nothave to know the\n+// complete type of `x` in order to type-check the method call. In\n+// this case, we know that `x: Vec<_1>`, but we don't know what type\n+// `_1` is (because the call to `push` comes later). To pick between\n+// the impls, we would have to know `_1`, since we have to know\n+// whether `_1: MyCopy` or `_1 == Box<i32>`.  However (and this is the\n+// point of the test), we don't have to pick between the two impls --\n+// it is enough to know that `foo` comes from the `Foo` trait. We can\n+// translate the call as `Foo::foo(&x)` and let the specific impl get\n+// chosen later.\n \n // pretty-expanded FIXME #23616\n \n@@ -25,25 +28,29 @@ trait Foo {\n     fn foo(&self) -> isize;\n }\n \n-impl<T:Copy> Foo for Vec<T> {\n+trait MyCopy { fn foo(&self) { } }\n+impl MyCopy for i32 { }\n+\n+impl<T:MyCopy> Foo for Vec<T> {\n     fn foo(&self) -> isize {1}\n }\n \n-impl<T> Foo for Vec<Box<T>> {\n+impl Foo for Vec<Box<i32>> {\n     fn foo(&self) -> isize {2}\n }\n \n fn call_foo_copy() -> isize {\n     let mut x = Vec::new();\n     let y = x.foo();\n-    x.push(0_usize);\n+    x.push(0_i32);\n     y\n }\n \n fn call_foo_other() -> isize {\n-    let mut x: Vec<Box<_>> = Vec::new();\n+    let mut x: Vec<_> = Vec::new();\n     let y = x.foo();\n-    x.push(box 0);\n+    let z: Box<i32> = box 0;\n+    x.push(z);\n     y\n }\n "}, {"sha": "0190b7b7b9628370a408733e302da67757825e24", "filename": "src/test/run-pass/traits-conditional-dispatch.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftraits-conditional-dispatch.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -17,16 +17,24 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n+use std::marker::MarkerTrait;\n+\n trait Get {\n     fn get(&self) -> Self;\n }\n \n-impl<T:Copy> Get for T {\n-    fn get(&self) -> T { *self }\n+trait MyCopy : MarkerTrait { fn copy(&self) -> Self; }\n+impl MyCopy for u16 { fn copy(&self) -> Self { *self } }\n+impl MyCopy for u32 { fn copy(&self) -> Self { *self } }\n+impl MyCopy for i32 { fn copy(&self) -> Self { *self } }\n+impl<T:Copy> MyCopy for Option<T> { fn copy(&self) -> Self { *self } }\n+\n+impl<T:MyCopy> Get for T {\n+    fn get(&self) -> T { self.copy() }\n }\n \n-impl<T:Get> Get for Box<T> {\n-    fn get(&self) -> Box<T> { box get_it(&**self) }\n+impl Get for Box<i32> {\n+    fn get(&self) -> Box<i32> { box get_it(&**self) }\n }\n \n fn get_it<T:Get>(t: &T) -> T {"}, {"sha": "37dccca1e22455c883bb1807f6a275055ef670bd", "filename": "src/test/run-pass/unboxed-closures-blanket-fn-mut.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn-mut.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that you can supply `&F` where `F: FnMut()`.\n+\n+// pretty-expanded FIXME #23616\n+\n+#![feature(lang_items, unboxed_closures)]\n+\n+fn a<F:FnMut() -> i32>(mut f: F) -> i32 {\n+    f()\n+}\n+\n+fn b(f: &mut FnMut() -> i32) -> i32 {\n+    a(f)\n+}\n+\n+fn c<F:FnMut() -> i32>(f: &mut F) -> i32 {\n+    a(f)\n+}\n+\n+fn main() {\n+    let z: isize = 7;\n+\n+    let x = b(&mut || 22);\n+    assert_eq!(x, 22);\n+\n+    let x = c(&mut || 22);\n+    assert_eq!(x, 22);\n+}"}, {"sha": "0f93966077bc30ae3c850c1e6a231eccfd27278a", "filename": "src/test/run-pass/unboxed-closures-blanket-fn.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e3b0c051dca9880bf66b5366dccd2e0bb424b99/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-blanket-fn.rs?ref=2e3b0c051dca9880bf66b5366dccd2e0bb424b99", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that you can supply `&F` where `F: Fn()`.\n+\n+// pretty-expanded FIXME #23616\n+\n+#![feature(lang_items, unboxed_closures)]\n+\n+fn a<F:Fn() -> i32>(f: F) -> i32 {\n+    f()\n+}\n+\n+fn b(f: &Fn() -> i32) -> i32 {\n+    a(f)\n+}\n+\n+fn c<F:Fn() -> i32>(f: &F) -> i32 {\n+    a(f)\n+}\n+\n+fn main() {\n+    let z: isize = 7;\n+\n+    let x = b(&|| 22);\n+    assert_eq!(x, 22);\n+\n+    let x = c(&|| 22);\n+    assert_eq!(x, 22);\n+}"}]}