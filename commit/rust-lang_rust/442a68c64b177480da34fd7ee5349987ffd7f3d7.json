{"sha": "442a68c64b177480da34fd7ee5349987ffd7f3d7", "node_id": "C_kwDOAAsO6NoAKDQ0MmE2OGM2NGIxNzc0ODBkYTM0ZmQ3ZWU1MzQ5OTg3ZmZkN2YzZDc", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-28T15:56:20Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-28T16:48:26Z"}, "message": "Only check parent node once in `dereference.rs`", "tree": {"sha": "dcf02beca61130afca632c807e86011ee4685870", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcf02beca61130afca632c807e86011ee4685870"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/442a68c64b177480da34fd7ee5349987ffd7f3d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/442a68c64b177480da34fd7ee5349987ffd7f3d7", "html_url": "https://github.com/rust-lang/rust/commit/442a68c64b177480da34fd7ee5349987ffd7f3d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/442a68c64b177480da34fd7ee5349987ffd7f3d7/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "20ea26234a99eb94727b901c00a1f31de91e22b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/20ea26234a99eb94727b901c00a1f31de91e22b8", "html_url": "https://github.com/rust-lang/rust/commit/20ea26234a99eb94727b901c00a1f31de91e22b8"}], "stats": {"total": 115, "additions": 40, "deletions": 75}, "files": [{"sha": "12c796bd100322850daad831e5b607969b5d9beb", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 40, "deletions": 75, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/442a68c64b177480da34fd7ee5349987ffd7f3d7/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442a68c64b177480da34fd7ee5349987ffd7f3d7/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=442a68c64b177480da34fd7ee5349987ffd7f3d7", "patch": "@@ -15,7 +15,7 @@ use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeckResults};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span, Symbol};\n+use rustc_span::{symbol::sym, Span, Symbol, SyntaxContext};\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -244,23 +244,22 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n \n         match (self.state.take(), kind) {\n             (None, kind) => {\n-                let parent = get_parent_node(cx.tcx, expr.hir_id);\n                 let expr_ty = typeck.expr_ty(expr);\n+                let (position, parent_ctxt) = get_expr_position(cx, expr);\n                 match kind {\n                     RefOp::Deref => {\n-                        if let Some(Node::Expr(e)) = parent\n-                            && let ExprKind::Field(_, name) = e.kind\n-                            && !ty_contains_field(typeck.expr_ty(sub_expr), name.name)\n+                        if let Position::FieldAccess(name) = position\n+                            && !ty_contains_field(typeck.expr_ty(sub_expr), name)\n                         {\n                             self.state = Some((\n-                                State::ExplicitDerefField { name: name.name },\n+                                State::ExplicitDerefField { name },\n                                 StateData { span: expr.span, hir_id: expr.hir_id },\n                             ));\n                         }\n                     }\n                     RefOp::Method(target_mut)\n                         if !is_lint_allowed(cx, EXPLICIT_DEREF_METHODS, expr.hir_id)\n-                            && is_linted_explicit_deref_position(parent, expr.hir_id, expr.span) =>\n+                            && (position.lint_explicit_deref() || parent_ctxt != expr.span.ctxt()) =>\n                     {\n                         self.state = Some((\n                             State::DerefMethod {\n@@ -322,8 +321,7 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n                             \"this expression creates a reference which is immediately dereferenced by the compiler\";\n                         let borrow_msg = \"this expression borrows a value the compiler would automatically borrow\";\n \n-                        let (required_refs, required_precedence, msg) = if is_auto_borrow_position(parent, expr.hir_id)\n-                        {\n+                        let (required_refs, required_precedence, msg) = if position.can_auto_borrow() {\n                             (1, PREC_POSTFIX, if deref_count == 1 { borrow_msg } else { deref_msg })\n                         } else if let Some(&Adjust::Borrow(AutoBorrow::Ref(_, mutability))) =\n                             next_adjust.map(|a| &a.kind)\n@@ -573,60 +571,41 @@ fn deref_method_same_type<'tcx>(result_ty: Ty<'tcx>, arg_ty: Ty<'tcx>) -> bool {\n     }\n }\n \n-// Checks whether the parent node is a suitable context for switching from a deref method to the\n-// deref operator.\n-fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId, child_span: Span) -> bool {\n-    let parent = match parent {\n-        Some(Node::Expr(e)) if e.span.ctxt() == child_span.ctxt() => e,\n-        _ => return true,\n-    };\n-    match parent.kind {\n-        // Leave deref calls in the middle of a method chain.\n-        // e.g. x.deref().foo()\n-        ExprKind::MethodCall(_, [self_arg, ..], _) if self_arg.hir_id == child_id => false,\n-\n-        // Leave deref calls resulting in a called function\n-        // e.g. (x.deref())()\n-        ExprKind::Call(func_expr, _) if func_expr.hir_id == child_id => false,\n+#[derive(Clone, Copy)]\n+enum Position {\n+    MethodReceiver,\n+    FieldAccess(Symbol),\n+    Callee,\n+    Postfix,\n+    Deref,\n+    Other,\n+}\n+impl Position {\n+    fn can_auto_borrow(self) -> bool {\n+        matches!(self, Self::MethodReceiver | Self::FieldAccess(_) | Self::Callee)\n+    }\n \n-        // Makes an ugly suggestion\n-        // e.g. *x.deref() => *&*x\n-        ExprKind::Unary(UnOp::Deref, _)\n-        // Postfix expressions would require parens\n-        | ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n-        | ExprKind::Field(..)\n-        | ExprKind::Index(..)\n-        | ExprKind::Err => false,\n+    fn lint_explicit_deref(self) -> bool {\n+        matches!(self, Self::Other)\n+    }\n+}\n \n-        ExprKind::Box(..)\n-        | ExprKind::ConstBlock(..)\n-        | ExprKind::Array(_)\n-        | ExprKind::Call(..)\n-        | ExprKind::MethodCall(..)\n-        | ExprKind::Tup(..)\n-        | ExprKind::Binary(..)\n-        | ExprKind::Unary(..)\n-        | ExprKind::Lit(..)\n-        | ExprKind::Cast(..)\n-        | ExprKind::Type(..)\n-        | ExprKind::DropTemps(..)\n-        | ExprKind::If(..)\n-        | ExprKind::Loop(..)\n-        | ExprKind::Match(..)\n-        | ExprKind::Let(..)\n-        | ExprKind::Closure{..}\n-        | ExprKind::Block(..)\n-        | ExprKind::Assign(..)\n-        | ExprKind::AssignOp(..)\n-        | ExprKind::Path(..)\n-        | ExprKind::AddrOf(..)\n-        | ExprKind::Break(..)\n-        | ExprKind::Continue(..)\n-        | ExprKind::Ret(..)\n-        | ExprKind::InlineAsm(..)\n-        | ExprKind::Struct(..)\n-        | ExprKind::Repeat(..)\n-        | ExprKind::Yield(..) => true,\n+/// Get which position an expression is in relative to it's parent.\n+fn get_expr_position(cx: &LateContext<'_>, e: &Expr<'_>) -> (Position, SyntaxContext) {\n+    if let Some(Node::Expr(parent)) = get_parent_node(cx.tcx, e.hir_id) {\n+        let pos = match parent.kind {\n+            ExprKind::MethodCall(_, [self_arg, ..], _) if self_arg.hir_id == e.hir_id => Position::MethodReceiver,\n+            ExprKind::Field(_, name) => Position::FieldAccess(name.name),\n+            ExprKind::Call(f, _) if f.hir_id == e.hir_id => Position::Callee,\n+            ExprKind::Unary(UnOp::Deref, _) => Position::Deref,\n+            ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar) | ExprKind::Index(..) => {\n+                Position::Postfix\n+            },\n+            _ => Position::Other,\n+        };\n+        (pos, parent.span.ctxt())\n+    } else {\n+        (Position::Other, SyntaxContext::root())\n     }\n }\n \n@@ -748,20 +727,6 @@ fn walk_parents<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> (AutoDerefSt\n     (stability, adjustments)\n }\n \n-/// Checks if the given expression is a position which can auto-borrow.\n-fn is_auto_borrow_position(parent: Option<Node<'_>>, child_id: HirId) -> bool {\n-    if let Some(Node::Expr(parent)) = parent {\n-        match parent.kind {\n-            // ExprKind::MethodCall(_, [self_arg, ..], _) => self_arg.hir_id == child_id,\n-            ExprKind::Field(..) => true,\n-            ExprKind::Call(f, _) => f.hir_id == child_id,\n-            _ => false,\n-        }\n-    } else {\n-        false\n-    }\n-}\n-\n // Checks the stability of auto-deref when assigned to a binding with the given explicit type.\n //\n // e.g."}]}