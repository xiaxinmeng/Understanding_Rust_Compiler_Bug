{"sha": "d51a84259e796aba141e27b7811f2abc95363fca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MWE4NDI1OWU3OTZhYmExNDFlMjdiNzgxMWYyYWJjOTUzNjNmY2E=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-26T12:17:42Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-26T12:17:42Z"}, "message": "Rollup merge of #65761 - popzxc:document-ast, r=petrochenkov\n\nlibsyntax: Enhance documentation of the AST module\n\nThis PR enhances documentation state to the `libsyntax/ast.rs` (as initiative caused by [rustc-guide#474](https://github.com/rust-lang/rustc-guide/issues/474)), by adding:\n- Module documentation.\n- Doc-comments (and a bit of usual comments) in non-obvious (as for me) places.\n- Minor style fixes to improve module readability.", "tree": {"sha": "cd200f1f6e1ce3ee799c3702d82f671636958a97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd200f1f6e1ce3ee799c3702d82f671636958a97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d51a84259e796aba141e27b7811f2abc95363fca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdtDlmCRBK7hj4Ov3rIwAAdHIIALBVymKL2BU1yu41dkvs8MFO\na+ezKtsWuBkmoGqsFgxhkJC4n1REtCSWt0WRbFGI1IuxzOcJBrGB4HsC0NvBOtrx\nQ8gJmo4mbvkNWrWY8fQBi5EXN0f5TJCgGXhK+WsnJ8yAad7ekK6vVQZHCMjoHOR+\nGW+13sFuf+YzufCU4J/dVl1zVt/v7uXWFb2yWWrELyHnJNWGIWglbBOWDW1I2nzo\nCiXcE2SBpcWlEK876t7BqTStWJSoYh+/TxUkD/wLU6xqtCO2kqIPhDvbe9qtA2J5\nOjtzFzH8zgi48vg+a90p+pIwRI0v9wnuRgWP3gwyNEqLRFTx9c5qT0qOvwKt38k=\n=aZV+\n-----END PGP SIGNATURE-----\n", "payload": "tree cd200f1f6e1ce3ee799c3702d82f671636958a97\nparent 4f4335296498c7fbfd19cd2de2e193cd48c5051c\nparent ae5203a1420013e88b212d882ccf53dfa64170ad\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1572092262 +0200\ncommitter GitHub <noreply@github.com> 1572092262 +0200\n\nRollup merge of #65761 - popzxc:document-ast, r=petrochenkov\n\nlibsyntax: Enhance documentation of the AST module\n\nThis PR enhances documentation state to the `libsyntax/ast.rs` (as initiative caused by [rustc-guide#474](https://github.com/rust-lang/rustc-guide/issues/474)), by adding:\n- Module documentation.\n- Doc-comments (and a bit of usual comments) in non-obvious (as for me) places.\n- Minor style fixes to improve module readability.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d51a84259e796aba141e27b7811f2abc95363fca", "html_url": "https://github.com/rust-lang/rust/commit/d51a84259e796aba141e27b7811f2abc95363fca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d51a84259e796aba141e27b7811f2abc95363fca/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f4335296498c7fbfd19cd2de2e193cd48c5051c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4335296498c7fbfd19cd2de2e193cd48c5051c", "html_url": "https://github.com/rust-lang/rust/commit/4f4335296498c7fbfd19cd2de2e193cd48c5051c"}, {"sha": "ae5203a1420013e88b212d882ccf53dfa64170ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae5203a1420013e88b212d882ccf53dfa64170ad", "html_url": "https://github.com/rust-lang/rust/commit/ae5203a1420013e88b212d882ccf53dfa64170ad"}], "stats": {"total": 138, "additions": 112, "deletions": 26}, "files": [{"sha": "8b96704884851e0cda8effdc06431d23e1b27f06", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 112, "deletions": 26, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/d51a84259e796aba141e27b7811f2abc95363fca/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d51a84259e796aba141e27b7811f2abc95363fca/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d51a84259e796aba141e27b7811f2abc95363fca", "patch": "@@ -1,33 +1,63 @@\n-// The Rust abstract syntax tree.\n+//! The Rust abstract syntax tree module.\n+//!\n+//! This module contains common structures forming the language AST.\n+//! Two main entities in the module are [`Item`] (which represents an AST element with\n+//! additional metadata), and [`ItemKind`] (which represents a concrete type and contains\n+//! information specific to the type of the item).\n+//!\n+//! Other module items that worth mentioning:\n+//! - [`Ty`] and [`TyKind`]: A parsed Rust type.\n+//! - [`Expr`] and [`ExprKind`]: A parsed Rust expression.\n+//! - [`Pat`] and [`PatKind`]: A parsed Rust pattern. Patterns are often dual to expressions.\n+//! - [`Stmt`] and [`StmtKind`]: An executable action that does not return a value.\n+//! - [`FnDecl`], [`FnHeader`] and [`Param`]: Metadata associated with a function declaration.\n+//! - [`Generics`], [`GenericParam`], [`WhereClause`]: Metadata associated with generic parameters.\n+//! - [`EnumDef`] and [`Variant`]: Enum declaration.\n+//! - [`Lit`] and [`LitKind`]: Literal expressions.\n+//! - [`MacroDef`], [`MacStmtStyle`], [`Mac`], [`MacDelimeter`]: Macro definition and invocation.\n+//! - [`Attribute`]: Metadata associated with item.\n+//! - [`UnOp`], [`UnOpKind`], [`BinOp`], [`BinOpKind`]: Unary and binary operators.\n \n pub use GenericArgs::*;\n pub use UnsafeSource::*;\n pub use crate::util::parser::ExprPrecedence;\n \n+pub use rustc_target::abi::FloatTy;\n+pub use syntax_pos::symbol::{Ident, Symbol as Name};\n+\n use crate::parse::token::{self, DelimToken};\n use crate::ptr::P;\n use crate::source_map::{dummy_spanned, respan, Spanned};\n use crate::tokenstream::TokenStream;\n \n-use rustc_target::spec::abi::Abi;\n-pub use rustc_target::abi::FloatTy;\n-\n-use syntax_pos::{Span, DUMMY_SP, ExpnId};\n use syntax_pos::symbol::{kw, sym, Symbol};\n-pub use syntax_pos::symbol::{Ident, Symbol as Name};\n+use syntax_pos::{Span, DUMMY_SP, ExpnId};\n \n-use rustc_index::vec::Idx;\n-#[cfg(target_arch = \"x86_64\")]\n-use rustc_data_structures::static_assert_size;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_index::vec::Idx;\n use rustc_serialize::{self, Decoder, Encoder};\n+use rustc_target::spec::abi::Abi;\n+\n+#[cfg(target_arch = \"x86_64\")]\n+use rustc_data_structures::static_assert_size;\n+\n use std::fmt;\n \n #[cfg(test)]\n mod tests;\n \n+/// A \"Label\" is an identifier of some point in sources,\n+/// e.g. in the following code:\n+///\n+/// ```rust\n+/// 'outer: loop {\n+///     break 'outer;\n+/// }\n+/// ```\n+///\n+/// `'outer` is a label.\n #[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n pub struct Label {\n     pub ident: Ident,\n@@ -39,6 +69,8 @@ impl fmt::Debug for Label {\n     }\n }\n \n+/// A \"Lifetime\" is an annotation of the scope in which variable\n+/// can be used, e.g. `'a` in `&'a i32`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -161,10 +193,14 @@ impl GenericArgs {\n     }\n }\n \n+/// Concrete argument in the sequence of generic args.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum GenericArg {\n+    /// `'a` in `Foo<'a>`\n     Lifetime(Lifetime),\n+    /// `Bar` in `Foo<Bar>`\n     Type(P<Ty>),\n+    /// `1` in `Foo<1>`\n     Const(AnonConst),\n }\n \n@@ -549,15 +585,24 @@ impl Pat {\n         }\n \n         match &self.kind {\n+            // Walk into the pattern associated with `Ident` (if any).\n             PatKind::Ident(_, _, Some(p)) => p.walk(it),\n+\n+            // Walk into each field of struct.\n             PatKind::Struct(_, fields, _) => fields.iter().for_each(|field| field.pat.walk(it)),\n+\n+            // Sequence of patterns.\n             PatKind::TupleStruct(_, s)\n             | PatKind::Tuple(s)\n             | PatKind::Slice(s)\n             | PatKind::Or(s) => s.iter().for_each(|p| p.walk(it)),\n+\n+            // Trivial wrappers over inner patterns.\n             PatKind::Box(s)\n             | PatKind::Ref(s, _)\n             | PatKind::Paren(s) => s.walk(it),\n+\n+            // These patterns do not contain subpatterns, skip.\n             PatKind::Wild\n             | PatKind::Rest\n             | PatKind::Lit(_)\n@@ -609,7 +654,9 @@ pub enum RangeEnd {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum RangeSyntax {\n+    /// `...`\n     DotDotDot,\n+    /// `..=`\n     DotDotEq,\n }\n \n@@ -768,6 +815,8 @@ impl BinOpKind {\n \n     pub fn is_comparison(&self) -> bool {\n         use BinOpKind::*;\n+        // Note for developers: please keep this as is;\n+        // we want compilation to fail if another variant is added.\n         match *self {\n             Eq | Lt | Le | Ne | Gt | Ge => true,\n             And | Or | Add | Sub | Mul | Div | Rem | BitXor | BitAnd | BitOr | Shl | Shr => false,\n@@ -782,6 +831,9 @@ impl BinOpKind {\n \n pub type BinOp = Spanned<BinOpKind>;\n \n+/// Unary operator.\n+///\n+/// Note that `&data` is not an operator, it's an `AddrOf` expression.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy)]\n pub enum UnOp {\n     /// The `*` operator for dereferencing\n@@ -849,10 +901,8 @@ impl Stmt {\n pub enum StmtKind {\n     /// A local (let) binding.\n     Local(P<Local>),\n-\n     /// An item definition.\n     Item(P<Item>),\n-\n     /// Expr without trailing semi-colon.\n     Expr(P<Expr>),\n     /// Expr with a trailing semi-colon.\n@@ -899,14 +949,18 @@ pub struct Local {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Arm {\n     pub attrs: Vec<Attribute>,\n+    /// Match arm pattern, e.g. `10` in `match foo { 10 => {}, _ => {} }`\n     pub pat: P<Pat>,\n+    /// Match arm guard, e.g. `n > 10` in `match foo { n if n > 10 => {}, _ => {} }`\n     pub guard: Option<P<Expr>>,\n+    /// Match arm body.\n     pub body: P<Expr>,\n     pub span: Span,\n     pub id: NodeId,\n     pub is_placeholder: bool,\n }\n \n+/// Access of a named (e.g., `obj.foo`) or unnamed (e.g., `obj.0`) struct field.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Field {\n     pub ident: Ident,\n@@ -989,32 +1043,45 @@ impl Expr {\n         }\n     }\n \n+    /// Attempts to reparse as `Ty` (for diagnostic purposes).\n     pub(super) fn to_ty(&self) -> Option<P<Ty>> {\n         let kind = match &self.kind {\n+            // Trivial conversions.\n             ExprKind::Path(qself, path) => TyKind::Path(qself.clone(), path.clone()),\n             ExprKind::Mac(mac) => TyKind::Mac(mac.clone()),\n+\n             ExprKind::Paren(expr) => expr.to_ty().map(TyKind::Paren)?,\n+\n             ExprKind::AddrOf(mutbl, expr) => expr\n                 .to_ty()\n                 .map(|ty| TyKind::Rptr(None, MutTy { ty, mutbl: *mutbl }))?,\n+\n             ExprKind::Repeat(expr, expr_len) => {\n                 expr.to_ty().map(|ty| TyKind::Array(ty, expr_len.clone()))?\n             }\n+\n             ExprKind::Array(exprs) if exprs.len() == 1 => exprs[0].to_ty().map(TyKind::Slice)?,\n+\n             ExprKind::Tup(exprs) => {\n                 let tys = exprs\n                     .iter()\n                     .map(|expr| expr.to_ty())\n                     .collect::<Option<Vec<_>>>()?;\n                 TyKind::Tup(tys)\n             }\n+\n+            // If binary operator is `Add` and both `lhs` and `rhs` are trait bounds,\n+            // then type of result is trait object.\n+            // Othewise we don't assume the result type.\n             ExprKind::Binary(binop, lhs, rhs) if binop.node == BinOpKind::Add => {\n                 if let (Some(lhs), Some(rhs)) = (lhs.to_bound(), rhs.to_bound()) {\n                     TyKind::TraitObject(vec![lhs, rhs], TraitObjectSyntax::None)\n                 } else {\n                     return None;\n                 }\n             }\n+\n+            // This expression doesn't look like a type syntactically.\n             _ => return None,\n         };\n \n@@ -1241,10 +1308,12 @@ pub struct QSelf {\n     pub position: usize,\n }\n \n-/// A capture clause.\n+/// A capture clause used in closures and `async` blocks.\n #[derive(Clone, Copy, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n pub enum CaptureBy {\n+    /// `move |x| y + x`.\n     Value,\n+    /// `move` keyword was not specified.\n     Ref,\n }\n \n@@ -1293,9 +1362,11 @@ impl MacDelimiter {\n     }\n }\n \n+/// Represents a macro definition.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct MacroDef {\n     pub tokens: TokenStream,\n+    /// `true` if macro was defined with `macro_rules`.\n     pub legacy: bool,\n }\n \n@@ -1329,10 +1400,14 @@ pub struct Lit {\n }\n \n // Clippy uses Hash and PartialEq\n+/// Type of the integer literal based on provided suffix.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, PartialEq)]\n pub enum LitIntType {\n+    /// e.g. `42_i32`.\n     Signed(IntTy),\n+    /// e.g. `42_u32`.\n     Unsigned(UintTy),\n+    /// e.g. `42`.\n     Unsuffixed,\n }\n \n@@ -1390,7 +1465,16 @@ impl LitKind {\n     /// Returns `true` if this literal has no suffix.\n     /// Note: this will return true for literals with prefixes such as raw strings and byte strings.\n     pub fn is_unsuffixed(&self) -> bool {\n+        !self.is_suffixed()\n+    }\n+\n+    /// Returns `true` if this literal has a suffix.\n+    pub fn is_suffixed(&self) -> bool {\n         match *self {\n+            // suffixed variants\n+            LitKind::Int(_, LitIntType::Signed(..))\n+            | LitKind::Int(_, LitIntType::Unsigned(..))\n+            | LitKind::Float(..) => true,\n             // unsuffixed variants\n             LitKind::Str(..)\n             | LitKind::ByteStr(..)\n@@ -1399,18 +1483,9 @@ impl LitKind {\n             | LitKind::Int(_, LitIntType::Unsuffixed)\n             | LitKind::FloatUnsuffixed(..)\n             | LitKind::Bool(..)\n-            | LitKind::Err(..) => true,\n-            // suffixed variants\n-            LitKind::Int(_, LitIntType::Signed(..))\n-            | LitKind::Int(_, LitIntType::Unsigned(..))\n-            | LitKind::Float(..) => false,\n+            | LitKind::Err(..) => false,\n         }\n     }\n-\n-    /// Returns `true` if this literal has a suffix.\n-    pub fn is_suffixed(&self) -> bool {\n-        !self.is_unsuffixed()\n-    }\n }\n \n // N.B., If you change this, you'll probably want to change the corresponding\n@@ -1779,6 +1854,7 @@ pub enum SelfKind {\n pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Param {\n+    /// Attempts to cast parameter to `ExplicitSelf`.\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n         if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.kind {\n             if ident.name == kw::SelfLower {\n@@ -1797,6 +1873,7 @@ impl Param {\n         None\n     }\n \n+    /// Returns `true` if parameter is `self`.\n     pub fn is_self(&self) -> bool {\n         if let PatKind::Ident(_, ident, _) = self.pat.kind {\n             ident.name == kw::SelfLower\n@@ -1805,6 +1882,7 @@ impl Param {\n         }\n     }\n \n+    /// Builds a `Param` object from `ExplicitSelf`.\n     pub fn from_self(attrs: ThinVec<Attribute>, eself: ExplicitSelf, eself_ident: Ident) -> Param {\n         let span = eself.span.to(eself_ident.span);\n         let infer_ty = P(Ty {\n@@ -1845,9 +1923,12 @@ impl Param {\n     }\n }\n \n-/// A header (not the body) of a function declaration.\n+/// A signature (not the body) of a function declaration.\n ///\n /// E.g., `fn foo(bar: baz)`.\n+///\n+/// Please note that it's different from `FnHeader` structure\n+/// which contains metadata about function safety, asyncness, constness and ABI.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnDecl {\n     pub inputs: Vec<Param>,\n@@ -1859,13 +1940,13 @@ impl FnDecl {\n         self.inputs.get(0).and_then(Param::to_self)\n     }\n     pub fn has_self(&self) -> bool {\n-        self.inputs.get(0).map(Param::is_self).unwrap_or(false)\n+        self.inputs.get(0).map_or(false, Param::is_self)\n     }\n     pub fn c_variadic(&self) -> bool {\n-        self.inputs.last().map(|arg| match arg.ty.kind {\n+        self.inputs.last().map_or(false, |arg| match arg.ty.kind {\n             TyKind::CVarArgs => true,\n             _ => false,\n-        }).unwrap_or(false)\n+        })\n     }\n }\n \n@@ -1918,6 +1999,8 @@ pub enum Constness {\n     NotConst,\n }\n \n+/// Item defaultness.\n+/// For details see the [RFC #2532](https://github.com/rust-lang/rfcs/pull/2532).\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug)]\n pub enum Defaultness {\n     Default,\n@@ -2009,6 +2092,7 @@ pub struct EnumDef {\n     pub variants: Vec<Variant>,\n }\n \n+/// Enum variant.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Variant {\n     /// Name of the variant.\n@@ -2111,6 +2195,8 @@ pub struct AttrItem {\n pub struct Attribute {\n     pub item: AttrItem,\n     pub id: AttrId,\n+    /// Denotes if the attribute decorates the following construct (outer)\n+    /// or the construct this attribute is contained within (inner).\n     pub style: AttrStyle,\n     pub is_sugared_doc: bool,\n     pub span: Span,"}]}