{"sha": "ac270fc8549b12040b6e71ad8e30634157ec6c96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMjcwZmM4NTQ5YjEyMDQwYjZlNzFhZDhlMzA2MzQxNTdlYzZjOTY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-22T21:56:51Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-12-22T21:56:51Z"}, "message": "Allocate heap cells to store non-empty object bodies.", "tree": {"sha": "04a49655b00c05e8fc879e68227911a5a877f010", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04a49655b00c05e8fc879e68227911a5a877f010"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac270fc8549b12040b6e71ad8e30634157ec6c96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac270fc8549b12040b6e71ad8e30634157ec6c96", "html_url": "https://github.com/rust-lang/rust/commit/ac270fc8549b12040b6e71ad8e30634157ec6c96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac270fc8549b12040b6e71ad8e30634157ec6c96/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0411132679b58ff3c177ccf24a22212881d6538d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0411132679b58ff3c177ccf24a22212881d6538d", "html_url": "https://github.com/rust-lang/rust/commit/0411132679b58ff3c177ccf24a22212881d6538d"}], "stats": {"total": 55, "additions": 45, "deletions": 10}, "files": [{"sha": "1ed9370c996fb3639108a49728b85762c355744d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ac270fc8549b12040b6e71ad8e30634157ec6c96/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac270fc8549b12040b6e71ad8e30634157ec6c96/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ac270fc8549b12040b6e71ad8e30634157ec6c96", "patch": "@@ -18,6 +18,7 @@ import back.abi;\n import middle.ty.pat_ty;\n \n import util.common;\n+import util.common.append;\n import util.common.istr;\n import util.common.new_def_hash;\n import util.common.new_str_hash;\n@@ -566,15 +567,20 @@ fn align_of(TypeRef t) -> ValueRef {\n     ret llvm.LLVMConstIntCast(lib.llvm.llvm.LLVMAlignOf(t), T_int(), False);\n }\n \n-fn trans_malloc(@block_ctxt cx, @ty.t t) -> result {\n-    auto scope_cx = find_scope_cx(cx);\n-    auto ptr_ty = type_of(cx.fcx.ccx, t);\n-    auto body_ty = lib.llvm.llvm.LLVMGetElementType(ptr_ty);\n+fn trans_malloc_inner(@block_ctxt cx, TypeRef llptr_ty) -> result {\n+    auto llbody_ty = lib.llvm.llvm.LLVMGetElementType(llptr_ty);\n     // FIXME: need a table to collect tydesc globals.\n     auto tydesc = C_int(0);\n-    auto sz = size_of(body_ty);\n+    auto sz = size_of(llbody_ty);\n     auto sub = trans_upcall(cx, \"upcall_malloc\", vec(sz, tydesc));\n-    sub.val = sub.bcx.build.IntToPtr(sub.val, ptr_ty);\n+    sub.val = sub.bcx.build.IntToPtr(sub.val, llptr_ty);\n+    ret sub;\n+}\n+\n+fn trans_malloc(@block_ctxt cx, @ty.t t) -> result {\n+    auto scope_cx = find_scope_cx(cx);\n+    auto llptr_ty = type_of(cx.fcx.ccx, t);\n+    auto sub = trans_malloc_inner(cx, llptr_ty);\n     scope_cx.cleanups += clean(bind drop_ty(_, sub.val, t));\n     ret sub;\n }\n@@ -2442,7 +2448,7 @@ impure fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n     auto llctor_decl = cx.item_ids.get(oid);\n     cx.item_names.insert(cx.path, llctor_decl);\n \n-    // Translate obj ctor fields to function arguments.\n+    // Translate obj ctor args to function arguments.\n     let vec[ast.arg] fn_args = vec();\n     for (ast.obj_field f in ob.fields) {\n         fn_args += vec(rec(mode=ast.alias,\n@@ -2456,7 +2462,8 @@ impure fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n \n     auto bcx = new_top_block_ctxt(fcx);\n \n-    copy_args_to_allocas(bcx, fn_args, arg_tys_of_fn(ann));\n+    let vec[ty.arg] arg_tys = arg_tys_of_fn(ann);\n+    copy_args_to_allocas(bcx, fn_args, arg_tys);\n \n     auto pair = bcx.build.Alloca(type_of(cx, ret_ty_of_fn(ann)));\n     auto vtbl = trans_vtbl(cx, ob, ty_params);\n@@ -2468,9 +2475,37 @@ impure fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n                                       C_int(abi.obj_field_box)));\n     bcx.build.Store(vtbl, pair_vtbl);\n \n-    // FIXME: allocate the object body, copy the args in, etc.\n-    bcx.build.Store(C_null(T_ptr(T_box(T_nil()))), pair_box);\n+    let TypeRef llbox_ty = T_ptr(T_box(T_nil()));\n+    if (_vec.len[ty.arg](arg_tys) == 0u) {\n+        // Store null into pair, if no args.\n+        bcx.build.Store(C_null(llbox_ty), pair_box);\n+    } else {\n+        // Malloc a box for the body and copy args in.\n+        let vec[@ty.t] obj_fields = vec();\n+        for (ty.arg a in arg_tys) {\n+            append[@ty.t](obj_fields, a.ty);\n+        }\n+        // Synthesize an obj body:\n+        let @ty.t fields_ty = ty.plain_ty(ty.ty_tup(obj_fields));\n+        let TypeRef llfields_ty = type_of(bcx.fcx.ccx, fields_ty);\n+        let TypeRef llobj_body_ty =\n+            T_ptr(T_box(T_struct(vec(T_tydesc(),\n+                                     llfields_ty))));\n+        auto r = trans_malloc_inner(bcx, llobj_body_ty);\n+        auto box = r.val;\n+        auto rc = r.bcx.build.GEP(box,\n+                                  vec(C_int(0),\n+                                      C_int(abi.box_rc_field_refcnt)));\n+        auto body = r.bcx.build.GEP(box,\n+                                    vec(C_int(0),\n+                                        C_int(abi.box_rc_field_body)));\n+        r.bcx.build.Store(C_int(1), rc);\n+\n+        // FIXME: Copy args into body\n \n+        auto p = r.bcx.build.PointerCast(box, llbox_ty);\n+        r.bcx.build.Store(p, pair_box);\n+    }\n     bcx.build.Ret(bcx.build.Load(pair));\n }\n "}]}