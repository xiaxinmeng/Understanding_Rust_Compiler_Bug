{"sha": "e383004985a5d725cec91cc48793284eedbcdbce", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzODMwMDQ5ODVhNWQ3MjVjZWM5MWNjNDg3OTMyODRlZWRiY2RiY2U=", "commit": {"author": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-11-16T02:11:22Z"}, "committer": {"name": "Josh Matthews", "email": "josh@joshmatthews.net", "date": "2011-12-19T04:41:03Z"}, "message": "Add debug info for local vars, basic fundamental types, and lexical blocks, along with source line information generation for individual instructions.", "tree": {"sha": "b336f479402c26e0776e213dd0ba153cb392e18f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b336f479402c26e0776e213dd0ba153cb392e18f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e383004985a5d725cec91cc48793284eedbcdbce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e383004985a5d725cec91cc48793284eedbcdbce", "html_url": "https://github.com/rust-lang/rust/commit/e383004985a5d725cec91cc48793284eedbcdbce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e383004985a5d725cec91cc48793284eedbcdbce/comments", "author": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jdm", "id": 27658, "node_id": "MDQ6VXNlcjI3NjU4", "avatar_url": "https://avatars.githubusercontent.com/u/27658?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jdm", "html_url": "https://github.com/jdm", "followers_url": "https://api.github.com/users/jdm/followers", "following_url": "https://api.github.com/users/jdm/following{/other_user}", "gists_url": "https://api.github.com/users/jdm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jdm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jdm/subscriptions", "organizations_url": "https://api.github.com/users/jdm/orgs", "repos_url": "https://api.github.com/users/jdm/repos", "events_url": "https://api.github.com/users/jdm/events{/privacy}", "received_events_url": "https://api.github.com/users/jdm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10030a37d50f5c3ae681709598be201153e0b1e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/10030a37d50f5c3ae681709598be201153e0b1e5", "html_url": "https://github.com/rust-lang/rust/commit/10030a37d50f5c3ae681709598be201153e0b1e5"}], "stats": {"total": 714, "additions": 561, "deletions": 153}, "files": [{"sha": "c0fe027f39b4f693750a353b7f32e20131f210da", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e383004985a5d725cec91cc48793284eedbcdbce/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e383004985a5d725cec91cc48793284eedbcdbce/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=e383004985a5d725cec91cc48793284eedbcdbce", "patch": "@@ -234,9 +234,11 @@ native mod llvm {\n     /* Operations on other types */\n     fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n     fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n+    fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n \n     fn LLVMVoidType() -> TypeRef;\n     fn LLVMLabelType() -> TypeRef;\n+    fn LLVMMetadataType() -> TypeRef;\n \n     /* Operations on all values */\n     fn LLVMTypeOf(Val: ValueRef) -> TypeRef;"}, {"sha": "9379c42623c1b2b6dcf2de583ac03195d4fa7c44", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 247, "deletions": 53, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/e383004985a5d725cec91cc48793284eedbcdbce/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e383004985a5d725cec91cc48793284eedbcdbce/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=e383004985a5d725cec91cc48793284eedbcdbce", "patch": "@@ -1,19 +1,32 @@\n-import std::{vec, str, map, option, unsafe};\n-import std::vec::to_ptr;\n+import std::{vec, str, option, unsafe, fs};\n import std::map::hashmap;\n import lib::llvm::llvm;\n-import lib::llvm::llvm::{ModuleRef, ValueRef};\n+import lib::llvm::llvm::ValueRef;\n import middle::trans_common::*;\n+import middle::ty;\n+import ast::ty;\n import syntax::{ast, codemap};\n \n-const LLVMDebugVersion: int = 0x80000;\n+const LLVMDebugVersion: int = (9 << 16); //& 0xffff0000; // 0x80000 ?\n \n const DW_LANG_RUST: int = 0x9000;\n const DW_VIRTUALITY_none: int = 0;\n \n const CompileUnitTag: int = 17;\n const FileDescriptorTag: int = 41;\n const SubprogramTag: int = 46;\n+const BasicTypeDescriptorTag: int = 36;\n+const AutoVariableTag: int = 256;\n+const ArgVariableTag: int = 257;\n+const ReturnVariableTag: int = 258;\n+const LexicalBlockTag: int = 11;\n+\n+const DW_ATE_boolean: int = 0x02;\n+const DW_ATE_float: int = 0x04;\n+const DW_ATE_signed: int = 0x05;\n+const DW_ATE_signed_char: int = 0x06;\n+const DW_ATE_unsigned: int = 0x07;\n+const DW_ATE_unsigned_char: int = 0x08;\n \n fn as_buf(s: str) -> str::sbuf {\n     str::as_buf(s, {|sbuf| sbuf})\n@@ -23,11 +36,14 @@ fn llstr(s: str) -> ValueRef {\n }\n \n fn lltag(lltag: int) -> ValueRef {\n-    lli32(0x80000 + lltag)\n+    lli32(LLVMDebugVersion | lltag)\n }\n fn lli32(val: int) -> ValueRef {\n     C_i32(val as i32)\n }\n+fn lli64(val: int) -> ValueRef {\n+    C_i64(val as i64)\n+}\n fn lli1(bval: bool) -> ValueRef {\n     C_bool(bval)\n }\n@@ -38,6 +54,9 @@ fn llmdnode(elems: [ValueRef]) -> ValueRef unsafe {\n fn llunused() -> ValueRef {\n     lli32(0x0)\n }\n+fn llnull() -> ValueRef {\n+    C_null(T_ptr(T_nil()))\n+}\n \n fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n     let existing = if cache.contains_key(mdtag) {\n@@ -55,25 +74,41 @@ type metadata<T> = {node: ValueRef, data: T};\n type file_md = {path: str};\n type compile_unit_md = {path: str};\n type subprogram_md = {name: str, file: str};\n+type local_var_md = {id: ast::node_id};\n+type tydesc_md = {hash: uint};\n+type block_md = {start: codemap::loc, end: codemap::loc};\n \n type metadata_cache = hashmap<int, [debug_metadata]>;\n \n tag debug_metadata {\n     file_metadata(@metadata<file_md>);\n     compile_unit_metadata(@metadata<compile_unit_md>);\n     subprogram_metadata(@metadata<subprogram_md>);\n+    local_var_metadata(@metadata<local_var_md>);\n+    tydesc_metadata(@metadata<tydesc_md>);\n+    block_metadata(@metadata<block_md>);\n+}\n+\n+fn cast_safely<T, U>(val: T) -> U unsafe {\n+    let val2 = val;\n+    let val3 = unsafe::reinterpret_cast(val2);\n+    unsafe::leak(val2);\n+    ret val3;\n }\n \n fn md_from_metadata<T>(val: debug_metadata) -> T unsafe {\n     alt val {\n-      file_metadata(md) { unsafe::reinterpret_cast(md) }\n-      compile_unit_metadata(md) { unsafe::reinterpret_cast(md) }\n-      subprogram_metadata(md) { unsafe::reinterpret_cast(md) }\n+      file_metadata(md) { cast_safely(md) }\n+      compile_unit_metadata(md) { cast_safely(md) }\n+      subprogram_metadata(md) { cast_safely(md) }\n+      local_var_metadata(md) { cast_safely(md) }\n+      tydesc_metadata(md) { cast_safely(md) }\n+      block_metadata(md) { cast_safely(md) }\n     }\n }\n \n fn cached_metadata<T>(cache: metadata_cache, mdtag: int,\n-                      eq: block(md: T) -> bool) -> option::t<T> {\n+                      eq: block(md: T) -> bool) -> option::t<T> unsafe {\n     if cache.contains_key(mdtag) {\n         let items = cache.get(mdtag);\n         for item in items {\n@@ -94,10 +129,8 @@ fn get_compile_unit_metadata(cx: @crate_ctxt, full_path: str)\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n-    let sep = str::rindex(full_path, '/' as u8) as uint;\n-    let fname = str::slice(full_path, sep + 1u,\n-                           str::byte_len(full_path));\n-    let path = str::slice(full_path, 0u, sep + 1u);\n+    let fname = fs::basename(full_path);\n+    let path = fs::dirname(full_path);\n     let unit_metadata = [lltag(CompileUnitTag),\n                          llunused(),\n                          lli32(DW_LANG_RUST),\n@@ -122,22 +155,18 @@ fn get_compile_unit_metadata(cx: @crate_ctxt, full_path: str)\n     ret mdval;\n }\n \n-//        let kind_id = llvm::LLVMGetMDKindID(as_buf(\"dbg\"),\n-//                                            str::byte_len(\"dbg\"));\n-\n-\n fn get_file_metadata(cx: @crate_ctxt, full_path: str) -> @metadata<file_md> {\n     let cache = cx.llmetadata;\n     alt cached_metadata::<@metadata<file_md>>(\n-        cache, FileDescriptorTag, {|md| md.data.path == full_path}) {\n+        cache, FileDescriptorTag,\n+        {|md|\n+         md.data.path == full_path}) {\n       option::some(md) { ret md; }\n       option::none. {}\n     }\n-    let sep = str::rindex(full_path, '/' as u8) as uint;\n-    let fname = str::slice(full_path, sep + 1u,\n-                           str::byte_len(full_path));\n-    let path = str::slice(full_path, 0u, sep + 1u);\n-    let unit_node = get_compile_unit_metadata(cx, path).node;\n+    let fname = fs::basename(full_path);\n+    let path = fs::dirname(full_path);\n+    let unit_node = get_compile_unit_metadata(cx, full_path).node;\n     let file_md = [lltag(FileDescriptorTag),\n                    llstr(fname),\n                    llstr(path),\n@@ -148,6 +177,162 @@ fn get_file_metadata(cx: @crate_ctxt, full_path: str) -> @metadata<file_md> {\n     ret mdval;\n }\n \n+fn get_block_metadata(cx: @block_ctxt) -> @metadata<block_md> {\n+    let cache = bcx_ccx(cx).llmetadata;\n+    let start = codemap::lookup_char_pos(bcx_ccx(cx).sess.get_codemap(),\n+                                         cx.sp.lo);\n+    let fname = start.filename;\n+    let end = codemap::lookup_char_pos(bcx_ccx(cx).sess.get_codemap(),\n+                                       cx.sp.hi);\n+    alt cached_metadata::<@metadata<block_md>>(\n+        cache, LexicalBlockTag,\n+        {|md| start == md.data.start && end == md.data.end}) {\n+      option::some(md) { ret md; }\n+      option::none. {}\n+    }\n+    let parent = alt cx.parent {\n+      trans_common::parent_none. { llnull() }\n+      trans_common::parent_some(bcx) {\n+        get_block_metadata(bcx).node\n+      }\n+    };\n+    let file_node = get_file_metadata(bcx_ccx(cx), fname);\n+    let unique_id = alt cache.find(LexicalBlockTag) {\n+      option::some(v) { vec::len(v) as int }\n+      option::none. { 0 }\n+    };\n+    let lldata = [lltag(LexicalBlockTag),\n+                  parent,\n+                  lli32(start.line as int),\n+                  lli32(start.col as int),\n+                  file_node.node,\n+                  lli32(unique_id)\n+                 ];\n+      let val = llmdnode(lldata);\n+      let mdval = @{node: val, data: {start: start, end: end}};\n+      update_cache(cache, LexicalBlockTag, block_metadata(mdval));\n+      ret mdval;\n+}\n+\n+fn get_ty_metadata(cx: @crate_ctxt, t: ty::t, ty: @ast::ty) -> @metadata<tydesc_md> {\n+    let cache = cx.llmetadata;\n+    alt cached_metadata::<@metadata<tydesc_md>>(\n+        cache, BasicTypeDescriptorTag,\n+        {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n+      option::some(md) { ret md; }\n+      option::none. {}\n+    }\n+    let (name, size, flags) = alt ty.node {\n+      ast::ty_bool. { (\"bool\", 1, DW_ATE_boolean) }\n+      ast::ty_int. { (\"int\", 32, DW_ATE_signed) } //XXX machine-dependent?\n+      ast::ty_uint. { (\"uint\", 32, DW_ATE_unsigned) } //XXX machine-dependent?\n+      ast::ty_float. { (\"float\", 32, DW_ATE_float) } //XXX machine-dependent?\n+      ast::ty_machine(m) { alt m {\n+        ast::ty_i8. { (\"i8\", 1, DW_ATE_signed_char) }\n+        ast::ty_i16. { (\"i16\", 16, DW_ATE_signed) }\n+        ast::ty_i32. { (\"i32\", 32, DW_ATE_signed) }\n+        ast::ty_i64. { (\"i64\", 64, DW_ATE_signed) }\n+        ast::ty_u8. { (\"u8\", 8, DW_ATE_unsigned_char) }\n+        ast::ty_u16. { (\"u16\", 16, DW_ATE_unsigned) }\n+        ast::ty_u32. { (\"u32\", 32, DW_ATE_unsigned) }\n+        ast::ty_u64. { (\"u64\", 64, DW_ATE_unsigned) }\n+        ast::ty_f32. { (\"f32\", 32, DW_ATE_float) }\n+        ast::ty_f64. { (\"f64\", 64, DW_ATE_float) }\n+      } }\n+      ast::ty_char. { (\"char\", 32, DW_ATE_unsigned) }\n+    };\n+    let lldata = [lltag(BasicTypeDescriptorTag),\n+                  llunused(), //XXX scope context\n+                  llstr(name),\n+                  llnull(), //XXX basic types only\n+                  lli32(0), //XXX basic types only\n+                  lli64(size),\n+                  lli64(32), //XXX alignment?\n+                  lli64(0), //XXX offset?\n+                  lli32(flags)];\n+    let llnode = llmdnode(lldata);\n+    let mdval = @{node: llnode, data: {hash: ty::hash_ty(t)}};\n+    update_cache(cache, BasicTypeDescriptorTag, tydesc_metadata(mdval));\n+    ret mdval;\n+}\n+\n+fn get_local_var_metadata(bcx: @block_ctxt, local: @ast::local)\n+    -> @metadata<local_var_md> unsafe {\n+    let cx = bcx_ccx(bcx);\n+    let cache = cx.llmetadata;\n+    alt cached_metadata::<@metadata<local_var_md>>(\n+        cache, AutoVariableTag, {|md| md.data.id == local.node.id}) {\n+      option::some(md) { ret md; }\n+      option::none. {}\n+    }\n+    let name = alt local.node.pat.node {\n+      ast::pat_bind(ident) { ident }\n+    };\n+    let loc = codemap::lookup_char_pos(cx.sess.get_codemap(),\n+                                       local.span.lo);\n+    let ty = trans::node_id_type(cx, local.node.id);\n+    let tymd = get_ty_metadata(cx, ty, local.node.ty);\n+    let filemd = get_file_metadata(cx, loc.filename);\n+    let blockmd = get_block_metadata(bcx);\n+    let lldata = [lltag(AutoVariableTag),\n+                  blockmd.node, //XXX block context (maybe subprogram if possible?)\n+                  llstr(name), // name\n+                  filemd.node,\n+                  lli32(loc.line as int), // line\n+                  tymd.node,\n+                  lli32(0), //XXX flags\n+                  llnull() // inline loc reference\n+                 ];\n+    let mdnode = llmdnode(lldata);\n+    let mdval = @{node: mdnode, data: {id: local.node.id}};\n+    update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n+    let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n+      option::some(local_mem(v)) { v }\n+      option::none. {\n+        alt bcx.fcx.lllocals.get(local.node.pat.id) {\n+          local_imm(v) { v }\n+        }\n+      }\n+    };\n+    let declargs = [llmdnode([llptr]), mdnode];\n+    let instr = trans_build::Call(bcx, cx.intrinsics.get(\"llvm.dbg.declare\"),\n+                                  declargs);\n+    llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.vars\"),\n+                                      str::byte_len(\"llvm.dbg.vars\"),\n+                                      mdnode);\n+    ret mdval;\n+}\n+\n+fn update_source_pos<T>(cx: @block_ctxt, s: T) {\n+    if !bcx_ccx(cx).sess.get_opts().debuginfo {\n+        ret;\n+    }\n+    cx.source_pos = option::some(\n+        codemap::lookup_char_pos(bcx_ccx(cx).sess.get_codemap(),\n+                                 s.span.lo)); //XXX maybe hi\n+\n+}\n+\n+fn reset_source_pos(cx: @block_ctxt) {\n+    cx.source_pos = option::none;\n+}\n+\n+fn add_line_info(cx: @block_ctxt, llinstr: ValueRef) {\n+    if !bcx_ccx(cx).sess.get_opts().debuginfo ||\n+        option::is_none(cx.source_pos) {\n+        ret;\n+    }\n+    let loc = option::get(cx.source_pos);\n+    let blockmd = get_block_metadata(cx);\n+    let kind_id = llvm::LLVMGetMDKindID(as_buf(\"dbg\"), str::byte_len(\"dbg\"));\n+    let scopedata = [lli32(loc.line as int),\n+                     lli32(loc.col as int),\n+                     blockmd.node,\n+                     llnull()];\n+    let dbgscope = llmdnode(scopedata);\n+    llvm::LLVMSetMetadata(llinstr, kind_id, dbgscope);    \n+}\n+\n fn get_function_metadata(cx: @crate_ctxt, item: @ast::item,\n                          llfndecl: ValueRef) -> @metadata<subprogram_md> {\n     let cache = cx.llmetadata;\n@@ -159,34 +344,43 @@ fn get_function_metadata(cx: @crate_ctxt, item: @ast::item,\n     }\n     let loc = codemap::lookup_char_pos(cx.sess.get_codemap(),\n                                            item.span.lo);\n-        let file_node = get_file_metadata(cx, loc.filename).node;\n-        let fn_metadata = [lltag(SubprogramTag),\n-                           llunused(),\n-                           file_node,\n-                           llstr(item.ident),\n-                           llstr(item.ident), //XXX fully-qualified C++ name\n-                           llstr(item.ident), //XXX MIPS name?????\n-                           file_node,\n-                           lli32(loc.line as int),\n-                           C_null(T_ptr(T_nil())), // XXX reference to tydesc\n-                           lli1(false), //XXX static\n-                           lli1(true), // not extern\n-                           lli32(DW_VIRTUALITY_none), // virtual-ness\n-                           lli32(0i), //index into virt func\n-                           C_null(T_ptr(T_nil())), // base type with vtbl\n-                           lli1(false), // artificial\n-                           lli1(cx.sess.get_opts().optimize != 0u),\n-                           llfndecl\n-                           //list of template params\n-                           //func decl descriptor\n-                           //list of func vars\n-                          ];\n-        let val = llmdnode(fn_metadata);\n-        llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.sp\"),\n-                                          str::byte_len(\"llvm.dbg.sp\"),\n-                                          val);\n-        let mdval = @{node: val, data: {name: item.ident,\n-                                        file: loc.filename}};\n-        update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n-        ret mdval;\n+    let file_node = get_file_metadata(cx, loc.filename).node;\n+    let mangled = cx.item_symbols.get(item.id);\n+    let ret_ty = alt item.node {\n+      ast::item_fn(f, _) { f.decl.output }\n+    };\n+    let ty_node = alt ret_ty.node {\n+      ast::ty_nil. { llnull() }\n+      _ { get_ty_metadata(cx, ty::node_id_to_type(ccx_tcx(cx), item.id),\n+                          ret_ty).node }\n+    };\n+    let fn_metadata = [lltag(SubprogramTag),\n+                       llunused(),\n+                       file_node,\n+                       llstr(item.ident),\n+                       llstr(item.ident), //XXX fully-qualified C++ name\n+                       llstr(mangled), //XXX MIPS name?????\n+                       file_node,\n+                       lli32(loc.line as int),\n+                       ty_node,\n+                       lli1(false), //XXX static (check export)\n+                       lli1(true), // not extern\n+                       lli32(DW_VIRTUALITY_none), // virtual-ness\n+                       lli32(0i), //index into virt func\n+                       llnull(), // base type with vtbl\n+                       lli1(false), // artificial\n+                       lli1(cx.sess.get_opts().optimize != 0u),\n+                       llfndecl\n+                       //list of template params\n+                       //func decl descriptor\n+                       //list of func vars\n+                      ];\n+    let val = llmdnode(fn_metadata);\n+    llvm::LLVMAddNamedMetadataOperand(cx.llmod, as_buf(\"llvm.dbg.sp\"),\n+                                      str::byte_len(\"llvm.dbg.sp\"),\n+                                      val);\n+    let mdval = @{node: val, data: {name: item.ident,\n+                                    file: loc.filename}};\n+    update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n+    ret mdval;\n }\n\\ No newline at end of file"}, {"sha": "551ac18a1b200f2800e19f1a313be2fd18b4fb5c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 36, "deletions": 5, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e383004985a5d725cec91cc48793284eedbcdbce/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e383004985a5d725cec91cc48793284eedbcdbce/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=e383004985a5d725cec91cc48793284eedbcdbce", "patch": "@@ -3519,6 +3519,8 @@ fn trans_temp_expr(bcx: @block_ctxt, e: @ast::expr) -> result {\n // - exprs with non-immediate type never get dest=by_val\n fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n     let tcx = bcx_tcx(bcx);\n+    debuginfo::update_source_pos(bcx, e);\n+\n     if expr_is_lval(bcx, e) {\n         ret lval_to_dps(bcx, e, dest);\n     }\n@@ -4012,6 +4014,8 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n     }\n \n     let bcx = cx;\n+    debuginfo::update_source_pos(cx, s);\n+    \n     alt s.node {\n       ast::stmt_expr(e, _) { bcx = trans_expr(cx, e, ignore); }\n       ast::stmt_decl(d, _) {\n@@ -4023,13 +4027,18 @@ fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n                 } else {\n                     bcx = init_ref_local(bcx, local);\n                 }\n+                if bcx_ccx(cx).sess.get_opts().debuginfo {\n+                    debuginfo::get_local_var_metadata(bcx, local);\n+                }\n             }\n           }\n           ast::decl_item(i) { trans_item(cx.fcx.lcx, *i); }\n         }\n       }\n       _ { bcx_ccx(cx).sess.unimpl(\"stmt variant\"); }\n     }\n+\n+    debuginfo::reset_source_pos(cx);\n     ret bcx;\n }\n \n@@ -4053,7 +4062,8 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n                 mutable lpad_dirty: true,\n                 mutable lpad: option::none,\n                 sp: cx.sp,\n-                fcx: cx};\n+                fcx: cx,\n+                mutable source_pos: option::none};\n     alt parent {\n       parent_some(cx) {\n         if cx.unreachable { Unreachable(bcx); }\n@@ -4097,7 +4107,8 @@ fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n           mutable lpad_dirty: true,\n           mutable lpad: option::none,\n           sp: fcx.sp,\n-          fcx: fcx};\n+          fcx: fcx,\n+          mutable source_pos: option::none};\n }\n \n \n@@ -4164,7 +4175,8 @@ fn llstaticallocas_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           mutable lpad_dirty: true,\n           mutable lpad: option::none,\n           sp: fcx.sp,\n-          fcx: fcx};\n+          fcx: fcx,\n+          mutable source_pos: option::none};\n }\n \n fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n@@ -4177,7 +4189,8 @@ fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           mutable lpad_dirty: true,\n           mutable lpad: option::none,\n           sp: fcx.sp,\n-          fcx: fcx};\n+          fcx: fcx,\n+          mutable source_pos: option::none};\n }\n \n \n@@ -4250,6 +4263,7 @@ fn trans_block(bcx: @block_ctxt, b: ast::blk) -> @block_ctxt {\n fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n     -> @block_ctxt {\n     let bcx = bcx;\n+    debuginfo::update_source_pos(bcx, b);\n     block_locals(b) {|local| bcx = alloc_local(bcx, local); };\n     for s: @ast::stmt in b.node.stmts {\n         bcx = trans_stmt(bcx, *s);\n@@ -4261,7 +4275,9 @@ fn trans_block_dps(bcx: @block_ctxt, b: ast::blk, dest: dest)\n       }\n       _ { assert dest == ignore || bcx.unreachable; }\n     }\n-    ret trans_block_cleanups(bcx, find_scope_cx(bcx));\n+    let rv = trans_block_cleanups(bcx, find_scope_cx(bcx));\n+    debuginfo::reset_source_pos(bcx);\n+    ret rv;\n }\n \n fn new_local_ctxt(ccx: @crate_ctxt) -> @local_ctxt {\n@@ -5465,6 +5481,18 @@ fn declare_intrinsics(llmod: ModuleRef) -> hashmap<str, ValueRef> {\n     ret intrinsics;\n }\n \n+fn declare_dbg_intrinsics(llmod: ModuleRef,\n+                          intrinsics: hashmap<str, ValueRef>) {\n+    let declare =\n+        decl_cdecl_fn(llmod, \"llvm.dbg.declare\",\n+                      T_fn([T_metadata(), T_metadata()], T_void()));\n+    let value =\n+        decl_cdecl_fn(llmod, \"llvm.dbg.value\",\n+                      T_fn([T_metadata(), T_i64(), T_metadata()], T_void()));\n+    intrinsics.insert(\"llvm.dbg.declare\", declare);\n+    intrinsics.insert(\"llvm.dbg.value\", value);\n+}\n+\n fn trap(bcx: @block_ctxt) {\n     let v: [ValueRef] = [];\n     alt bcx_ccx(bcx).intrinsics.find(\"llvm.trap\") {\n@@ -5601,6 +5629,9 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n     let td = mk_target_data(sess.get_targ_cfg().target_strs.data_layout);\n     let tn = mk_type_names();\n     let intrinsics = declare_intrinsics(llmod);\n+    if sess.get_opts().debuginfo {\n+        declare_dbg_intrinsics(llmod, intrinsics);\n+    }\n     let int_type = T_int(targ_cfg);\n     let float_type = T_float(targ_cfg);\n     let task_type = T_task(targ_cfg);"}, {"sha": "26c63290405d9eed1d6fa712f941b5a03bba3c63", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 262, "deletions": 93, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/e383004985a5d725cec91cc48793284eedbcdbce/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e383004985a5d725cec91cc48793284eedbcdbce/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=e383004985a5d725cec91cc48793284eedbcdbce", "patch": "@@ -25,47 +25,54 @@ fn RetVoid(cx: @block_ctxt) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    llvm::LLVMBuildRetVoid(B(cx));\n+    let instr = llvm::LLVMBuildRetVoid(B(cx));\n+    debuginfo::add_line_info(cx, instr);\n }\n \n fn Ret(cx: @block_ctxt, V: ValueRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    llvm::LLVMBuildRet(B(cx), V);\n+    let instr = llvm::LLVMBuildRet(B(cx), V);\n+    debuginfo::add_line_info(cx, instr);\n }\n \n fn AggregateRet(cx: @block_ctxt, RetVals: [ValueRef]) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n     unsafe {\n-        llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n-                                    vec::len(RetVals));\n+        let instr = llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n+                                                vec::len(RetVals));\n+        debuginfo::add_line_info(cx, instr);\n     }\n }\n \n fn Br(cx: @block_ctxt, Dest: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    llvm::LLVMBuildBr(B(cx), Dest);\n+    let instr = llvm::LLVMBuildBr(B(cx), Dest);\n+    debuginfo::add_line_info(cx, instr);\n }\n \n fn CondBr(cx: @block_ctxt, If: ValueRef, Then: BasicBlockRef,\n           Else: BasicBlockRef) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n+    let instr = llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n+    debuginfo::add_line_info(cx, instr);\n }\n \n fn Switch(cx: @block_ctxt, V: ValueRef, Else: BasicBlockRef, NumCases: uint)\n     -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n     assert !cx.terminated;\n     cx.terminated = true;\n-    ret llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases);\n+    let instr = llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases);\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn AddCase(S: ValueRef, OnVal: ValueRef, Dest: BasicBlockRef) {\n@@ -77,7 +84,8 @@ fn IndirectBr(cx: @block_ctxt, Addr: ValueRef, NumDests: uint) {\n     if cx.unreachable { ret; }\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n+    let instr = llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n+    debuginfo::add_line_info(cx, instr);\n }\n \n // This is a really awful way to get a zero-length c-string, but better (and a\n@@ -93,8 +101,10 @@ fn Invoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n     assert (!cx.terminated);\n     cx.terminated = true;\n     unsafe {\n-        llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n-                              vec::len(Args), Then, Catch, noname());\n+        let instr = llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n+                                          vec::len(Args), Then, Catch,\n+                                          noname());\n+        debuginfo::add_line_info(cx, instr);\n     }\n }\n \n@@ -107,6 +117,7 @@ fn FastInvoke(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef],\n         let v = llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n                                       vec::len(Args), Then, Catch, noname());\n         llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n+        debuginfo::add_line_info(cx, v);\n     }\n }\n \n@@ -123,183 +134,254 @@ fn _Undef(val: ValueRef) -> ValueRef {\n /* Arithmetic */\n fn Add(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildAdd(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn NSWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn NUWAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FAdd(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildFAdd(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Sub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildSub(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn NSWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn NUWSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FSub(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildFSub(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Mul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildMul(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn NSWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn NUWMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FMul(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildFMul(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn UDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildUDiv(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn SDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildSDiv(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn ExactSDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FDiv(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildFDiv(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn URem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildURem(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn SRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildSRem(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FRem(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildFRem(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Shl(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildShl(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn LShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildLShr(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn AShr(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildAShr(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn And(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildAnd(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Or(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildOr(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Xor(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildXor(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn BinOp(cx: @block_ctxt, Op: Opcode, LHS: ValueRef, RHS: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret _Undef(LHS); }\n-    ret llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Neg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    ret llvm::LLVMBuildNeg(B(cx), V, noname());\n+    let instr = llvm::LLVMBuildNeg(B(cx), V, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn NSWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    ret llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n+    let instr = llvm::LLVMBuildNSWNeg(B(cx), V, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn NUWNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    ret llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n+    let instr = llvm::LLVMBuildNUWNeg(B(cx), V, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n fn FNeg(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    ret llvm::LLVMBuildFNeg(B(cx), V, noname());\n+    let instr = llvm::LLVMBuildFNeg(B(cx), V, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Not(cx: @block_ctxt, V: ValueRef) -> ValueRef {\n     if cx.unreachable { ret _Undef(V); }\n-    ret llvm::LLVMBuildNot(B(cx), V, noname());\n+    let instr = llvm::LLVMBuildNot(B(cx), V, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n /* Memory */\n fn Malloc(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    ret llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n+    let instr = llvm::LLVMBuildMalloc(B(cx), Ty, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn ArrayMalloc(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    ret llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n+    let instr = llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Alloca(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    ret llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n+    let instr = llvm::LLVMBuildAlloca(B(cx), Ty, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn ArrayAlloca(cx: @block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(Ty)); }\n-    ret llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n+    let instr = llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Free(cx: @block_ctxt, PointerVal: ValueRef) {\n     if cx.unreachable { ret; }\n-    llvm::LLVMBuildFree(B(cx), PointerVal);\n+    let instr = llvm::LLVMBuildFree(B(cx), PointerVal);\n+    debuginfo::add_line_info(cx, instr);\n }\n \n fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n@@ -310,19 +392,24 @@ fn Load(cx: @block_ctxt, PointerVal: ValueRef) -> ValueRef {\n             llvm::LLVMGetElementType(ty) } else { ccx.int_type };\n         ret llvm::LLVMGetUndef(eltty);\n     }\n-    ret llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n+    let instr = llvm::LLVMBuildLoad(B(cx), PointerVal, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Store(cx: @block_ctxt, Val: ValueRef, Ptr: ValueRef) {\n     if cx.unreachable { ret; }\n-    llvm::LLVMBuildStore(B(cx), Val, Ptr);\n+    let instr = llvm::LLVMBuildStore(B(cx), Val, Ptr);\n+    debuginfo::add_line_info(cx, instr);\n }\n \n fn GEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-        ret llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n-                               vec::len(Indices), noname());\n+        let instr = llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n+                                       vec::len(Indices), noname());\n+        debuginfo::add_line_info(cx, instr);\n+        ret instr;\n     }\n }\n \n@@ -338,142 +425,195 @@ fn InBoundsGEP(cx: @block_ctxt, Pointer: ValueRef, Indices: [ValueRef]) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n     unsafe {\n-        ret llvm::LLVMBuildInBoundsGEP(B(cx), Pointer, vec::to_ptr(Indices),\n-                                       vec::len(Indices), noname());\n+        let v = llvm::LLVMBuildInBoundsGEP(B(cx), Pointer,\n+                                           vec::to_ptr(Indices),\n+                                           vec::len(Indices), noname());\n+        debuginfo::add_line_info(cx, v);\n+        ret v;\n     }\n }\n \n fn StructGEP(cx: @block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_nil())); }\n-    ret llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, noname());\n+    let instr = llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn GlobalString(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    ret llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n+    let instr = llvm::LLVMBuildGlobalString(B(cx), _Str, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn GlobalStringPtr(cx: @block_ctxt, _Str: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_ptr(T_i8())); }\n-    ret llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n+    let instr = llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n /* Casts */\n fn Trunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildTrunc(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn ZExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildZExt(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn SExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildSExt(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FPToUI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FPToSI(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn UIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn SIToFP(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FPTrunc(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FPExt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildFPExt(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn PtrToInt(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn IntToPtr(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn BitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildBitCast(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn ZExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn SExtOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn TruncOrBitCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Cast(cx: @block_ctxt, Op: Opcode, Val: ValueRef, DestTy: TypeRef,\n         _Name: sbuf) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn PointerCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn IntCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildIntCast(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FPCast(cx: @block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(DestTy); }\n-    ret llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n+    let instr = llvm::LLVMBuildFPCast(B(cx), Val, DestTy, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n \n /* Comparisons */\n fn ICmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    ret llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn FCmp(cx: @block_ctxt, Op: uint, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    ret llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n /* Miscellaneous instructions */\n fn EmptyPhi(cx: @block_ctxt, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n-    ret llvm::LLVMBuildPhi(B(cx), Ty, noname());\n+    let instr = llvm::LLVMBuildPhi(B(cx), Ty, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Phi(cx: @block_ctxt, Ty: TypeRef, vals: [ValueRef], bbs: [BasicBlockRef])\n@@ -528,8 +668,10 @@ fn add_comment(bcx: @block_ctxt, text: str) {\n fn Call(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n     if cx.unreachable { ret _UndefReturn(cx, Fn); }\n     unsafe {\n-        ret llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n-                                vec::len(Args), noname());\n+        let instr = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n+                                        vec::len(Args), noname());\n+        debuginfo::add_line_info(cx, instr);\n+        ret instr;\n     }\n }\n \n@@ -539,6 +681,7 @@ fn FastCall(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef]) -> ValueRef {\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                                     vec::len(Args), noname());\n         llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n+        debuginfo::add_line_info(cx, v);\n         ret v;\n     }\n }\n@@ -550,64 +693,84 @@ fn CallWithConv(cx: @block_ctxt, Fn: ValueRef, Args: [ValueRef], Conv: uint)\n         let v = llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                                     vec::len(Args), noname());\n         llvm::LLVMSetInstructionCallConv(v, Conv);\n+        debuginfo::add_line_info(cx, v);\n         ret v;\n     }\n }\n \n fn Select(cx: @block_ctxt, If: ValueRef, Then: ValueRef, Else: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret _Undef(Then); }\n-    ret llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n+    let instr = llvm::LLVMBuildSelect(B(cx), If, Then, Else, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn VAArg(cx: @block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(Ty); }\n-    ret llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n+    let instr = llvm::LLVMBuildVAArg(B(cx), list, Ty, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn ExtractElement(cx: @block_ctxt, VecVal: ValueRef, Index: ValueRef) ->\n    ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n-    ret llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n+    let instr = llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn InsertElement(cx: @block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) {\n     if cx.unreachable { ret; }\n-    llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, noname());\n+    let instr = llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index,\n+                                             noname());\n+    debuginfo::add_line_info(cx, instr);\n }\n \n fn ShuffleVector(cx: @block_ctxt, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) {\n     if cx.unreachable { ret; }\n-    llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n+    let instr = llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, noname());\n+    debuginfo::add_line_info(cx, instr);\n }\n \n fn ExtractValue(cx: @block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_nil()); }\n-    ret llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, noname());\n+    let instr = llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn InsertValue(cx: @block_ctxt, AggVal: ValueRef, EltVal: ValueRef,\n                Index: uint) {\n     if cx.unreachable { ret; }\n-    llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index, noname());\n+    let instr = llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index,\n+                                           noname());\n+    debuginfo::add_line_info(cx, instr);\n }\n \n fn IsNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    ret llvm::LLVMBuildIsNull(B(cx), Val, noname());\n+    let instr = llvm::LLVMBuildIsNull(B(cx), Val, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn IsNotNull(cx: @block_ctxt, Val: ValueRef) -> ValueRef {\n     if cx.unreachable { ret llvm::LLVMGetUndef(T_i1()); }\n-    ret llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n+    let instr = llvm::LLVMBuildIsNotNull(B(cx), Val, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn PtrDiff(cx: @block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n     let ccx = cx.fcx.lcx.ccx;\n     if cx.unreachable { ret llvm::LLVMGetUndef(ccx.int_type); }\n-    ret llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n+    let instr = llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn Trap(cx: @block_ctxt) {\n@@ -622,15 +785,19 @@ fn Trap(cx: @block_ctxt) {\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n     unsafe {\n-        llvm::LLVMBuildCall(b, T, vec::to_ptr(Args),\n-                            vec::len(Args), noname());\n+        let instr = llvm::LLVMBuildCall(b, T, vec::to_ptr(Args),\n+                                        vec::len(Args), noname());\n+        debuginfo::add_line_info(cx, instr);\n     }\n }\n \n fn LandingPad(cx: @block_ctxt, Ty: TypeRef, PersFn: ValueRef,\n               NumClauses: uint) -> ValueRef {\n     assert !cx.terminated && !cx.unreachable;\n-    ret llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn, NumClauses, noname());\n+    let instr = llvm::LLVMBuildLandingPad(B(cx), Ty, PersFn, NumClauses,\n+                                          noname());\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n fn SetCleanup(_cx: @block_ctxt, LandingPad: ValueRef) {\n@@ -640,7 +807,9 @@ fn SetCleanup(_cx: @block_ctxt, LandingPad: ValueRef) {\n fn Resume(cx: @block_ctxt, Exn: ValueRef) -> ValueRef {\n     assert (!cx.terminated);\n     cx.terminated = true;\n-    ret llvm::LLVMBuildResume(B(cx), Exn);\n+    let instr = llvm::LLVMBuildResume(B(cx), Exn);\n+    debuginfo::add_line_info(cx, instr);\n+    ret instr;\n }\n \n //"}, {"sha": "98c4b497ab53d525f00c8d44f32ec692b29a2fff", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e383004985a5d725cec91cc48793284eedbcdbce/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e383004985a5d725cec91cc48793284eedbcdbce/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=e383004985a5d725cec91cc48793284eedbcdbce", "patch": "@@ -385,7 +385,8 @@ type block_ctxt =\n      mutable lpad_dirty: bool,\n      mutable lpad: option::t<BasicBlockRef>,\n      sp: span,\n-     fcx: @fn_ctxt};\n+     fcx: @fn_ctxt,\n+     mutable source_pos: option::t<syntax::codemap::loc>};\n \n // FIXME: we should be able to use option::t<@block_parent> here but\n // the infinite-tag check in rustboot gets upset.\n@@ -464,6 +465,8 @@ fn T_nil() -> TypeRef {\n     ret llvm::LLVMInt1Type();\n }\n \n+fn T_metadata() -> TypeRef { ret llvm::LLVMMetadataType(); }\n+\n fn T_i1() -> TypeRef { ret llvm::LLVMInt1Type(); }\n \n fn T_i8() -> TypeRef { ret llvm::LLVMInt8Type(); }\n@@ -801,6 +804,10 @@ fn C_i32(i: i32) -> ValueRef {\n     ret C_integral(T_i32(), i as u64, True);\n }\n \n+fn C_i64(i: i64) -> ValueRef {\n+    ret C_integral(T_i64(), i as uint, True);\n+}\n+\n fn C_int(cx: @crate_ctxt, i: int) -> ValueRef {\n     ret C_integral(cx.int_type, i as u64, True);\n }"}, {"sha": "8c5c2385c9b3b94c0d20250dc419aec5f24d7009", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e383004985a5d725cec91cc48793284eedbcdbce/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/e383004985a5d725cec91cc48793284eedbcdbce/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=e383004985a5d725cec91cc48793284eedbcdbce", "patch": "@@ -60,6 +60,7 @@ LLVMAddLoopRotatePass\n LLVMAddLoopUnrollPass\n LLVMAddLoopUnswitchPass\n LLVMAddMemCpyOptPass\n+LLVMAddNamedMetadataOperand\n LLVMAddPromoteMemoryToRegisterPass\n LLVMAddPruneEHPass\n LLVMAddReassociatePass\n@@ -483,11 +484,15 @@ LLVMIsThreadLocal\n LLVMIsUndef\n LLVMLabelType\n LLVMLabelTypeInContext\n+LLVMLinkInInterpreter\n+LLVMLinkInJIT\n+LLVMLinkInMCJIT\n LLVMMDNode\n LLVMMDNodeInContext\n LLVMMDString\n LLVMMDStringInContext\n-LLVMAddNamedMetadataOperand\n+LLVMMetadataType\n+LLVMMetadataTypeInContext\n LLVMModuleCreateWithName\n LLVMModuleCreateWithNameInContext\n LLVMMoveBasicBlockAfter"}]}