{"sha": "0701b37d97d08da7074ece7a7dcb4449498f4bfa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MDFiMzdkOTdkMDhkYTcwNzRlY2U3YTdkY2I0NDQ5NDk4ZjRiZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-18T17:30:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-18T17:30:29Z"}, "message": "Auto merge of #44678 - alexcrichton:rollup, r=alexcrichton\n\nRollup of 11 pull requests\n\n- Successful merges: #44364, #44466, #44537, #44548, #44640, #44651, #44657, #44661, #44668, #44671, #44675\n- Failed merges:", "tree": {"sha": "796f1ce756d1bce72a8462d6d74c28f11263895c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/796f1ce756d1bce72a8462d6d74c28f11263895c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0701b37d97d08da7074ece7a7dcb4449498f4bfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0701b37d97d08da7074ece7a7dcb4449498f4bfa", "html_url": "https://github.com/rust-lang/rust/commit/0701b37d97d08da7074ece7a7dcb4449498f4bfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0701b37d97d08da7074ece7a7dcb4449498f4bfa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a7b960731fd1cf86f1879b1a0d44196a0917c53", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a7b960731fd1cf86f1879b1a0d44196a0917c53", "html_url": "https://github.com/rust-lang/rust/commit/3a7b960731fd1cf86f1879b1a0d44196a0917c53"}, {"sha": "929215db7c598722410709022e69f71702f02e0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/929215db7c598722410709022e69f71702f02e0b", "html_url": "https://github.com/rust-lang/rust/commit/929215db7c598722410709022e69f71702f02e0b"}], "stats": {"total": 2783, "additions": 1985, "deletions": 798}, "files": [{"sha": "2e4bb1a5257c94b76899fc56324825666a4542be", "filename": "src/doc/unstable-book/src/library-features/splice.md", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsplice.md?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -1,14 +1,13 @@\n # `splice`\n \n-The tracking issue for this feature is: [#32310]\n+The tracking issue for this feature is: [#44643]\n \n-[#32310]: https://github.com/rust-lang/rust/issues/32310\n+[#44643]: https://github.com/rust-lang/rust/issues/44643\n \n ------------------------\n \n-The `splice()` method on `Vec` and `String` allows you to replace a range\n-of values in a vector or string with another range of values, and returns\n-the replaced values.\n+The `splice()` method on `String` allows you to replace a range\n+of values in a string with another range of values.\n \n A simple example:\n \n@@ -20,4 +19,4 @@ let beta_offset = s.find('\u03b2').unwrap_or(s.len());\n // Replace the range up until the \u03b2 from the string\n s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n-```\n\\ No newline at end of file\n+```"}, {"sha": "6d0bb264df1863b50264b1f73df9a6d6d683dbe0", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -1451,7 +1451,7 @@ impl String {\n     /// s.splice(..beta_offset, \"\u0391 is capital alpha; \");\n     /// assert_eq!(s, \"\u0391 is capital alpha; \u03b2 is beta\");\n     /// ```\n-    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"44643\")]\n     pub fn splice<R>(&mut self, range: R, replace_with: &str)\n         where R: RangeArgument<usize>\n     {"}, {"sha": "75d54b82076069dd53a56a7299876501368db1be", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -1943,15 +1943,14 @@ impl<T> Vec<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(splice)]\n     /// let mut v = vec![1, 2, 3];\n     /// let new = [7, 8];\n     /// let u: Vec<_> = v.splice(..2, new.iter().cloned()).collect();\n     /// assert_eq!(v, &[7, 8, 3]);\n     /// assert_eq!(u, &[1, 2]);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+    #[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n     pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n         where R: RangeArgument<usize>, I: IntoIterator<Item=T>\n     {\n@@ -2554,13 +2553,13 @@ impl<'a, T> InPlace<T> for PlaceBack<'a, T> {\n /// [`splice()`]: struct.Vec.html#method.splice\n /// [`Vec`]: struct.Vec.html\n #[derive(Debug)]\n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n pub struct Splice<'a, I: Iterator + 'a> {\n     drain: Drain<'a, I::Item>,\n     replace_with: I,\n }\n \n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n     type Item = I::Item;\n \n@@ -2573,18 +2572,18 @@ impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n     }\n }\n \n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n impl<'a, I: Iterator> DoubleEndedIterator for Splice<'a, I> {\n     fn next_back(&mut self) -> Option<Self::Item> {\n         self.drain.next_back()\n     }\n }\n \n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n impl<'a, I: Iterator> ExactSizeIterator for Splice<'a, I> {}\n \n \n-#[unstable(feature = \"splice\", reason = \"recently added\", issue = \"32310\")]\n+#[stable(feature = \"vec_splice\", since = \"1.22.0\")]\n impl<'a, I: Iterator> Drop for Splice<'a, I> {\n     fn drop(&mut self) {\n         // exhaust drain first"}, {"sha": "bc82f0230e5b44b1f52dcce24b15050ffc5a73d8", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -1381,38 +1381,7 @@ extern \"rust-intrinsic\" {\n }\n \n #[cfg(stage0)]\n-/// Computes the byte offset that needs to be applied to `ptr` in order to\n-/// make it aligned to `align`.\n-/// If it is not possible to align `ptr`, the implementation returns\n-/// `usize::max_value()`.\n-///\n-/// There are no guarantees whatsover that offsetting the pointer will not\n-/// overflow or go beyond the allocation that `ptr` points into.\n-/// It is up to the caller to ensure that the returned offset is correct\n-/// in all terms other than alignment.\n-///\n-/// # Examples\n-///\n-/// Accessing adjacent `u8` as `u16`\n-///\n-/// ```\n-/// # #![feature(core_intrinsics)]\n-/// # fn foo(n: usize) {\n-/// # use std::intrinsics::align_offset;\n-/// # use std::mem::align_of;\n-/// # unsafe {\n-/// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n-/// let ptr = &x[n] as *const u8;\n-/// let offset = align_offset(ptr as *const (), align_of::<u16>());\n-/// if offset < x.len() - n - 1 {\n-///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n-///     assert_ne!(*u16_ptr, 500);\n-/// } else {\n-///     // while the pointer can be aligned via `offset`, it would point\n-///     // outside the allocation\n-/// }\n-/// # } }\n-/// ```\n+/// remove me after the next release\n pub unsafe fn align_offset(ptr: *const (), align: usize) -> usize {\n     let offset = ptr as usize % align;\n     if offset == 0 {"}, {"sha": "7ef50396c82bf5192ca812770aeeeb650bf80246", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -196,6 +196,23 @@ pub trait FromIterator<A>: Sized {\n ///     assert_eq!(i as i32, n);\n /// }\n /// ```\n+///\n+/// It is common to use `IntoIterator` as a trait bound. This allows\n+/// the input collection type to change, so long as it is still an\n+/// iterator. Additional bounds can be specified by restricting on\n+/// `Item`:\n+///\n+/// ```rust\n+/// fn collect_as_strings<T>(collection: T) -> Vec<String>\n+///     where T: IntoIterator,\n+///           T::Item : std::fmt::Debug,\n+/// {\n+///     collection\n+///         .into_iter()\n+///         .map(|item| format!(\"{:?}\", item))\n+///         .collect()\n+/// }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IntoIterator {\n     /// The type of the elements being iterated over."}, {"sha": "4041a3760e5ca467fa8d1a99e4ba2bd8551366c9", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -1064,7 +1064,43 @@ impl<T: ?Sized> *const T {\n         copy_nonoverlapping(self, dest, count)\n     }\n \n-\n+    /// Computes the byte offset that needs to be applied in order to\n+    /// make the pointer aligned to `align`.\n+    /// If it is not possible to align the pointer, the implementation returns\n+    /// `usize::max_value()`.\n+    ///\n+    /// There are no guarantees whatsover that offsetting the pointer will not\n+    /// overflow or go beyond the allocation that the pointer points into.\n+    /// It is up to the caller to ensure that the returned offset is correct\n+    /// in all terms other than alignment.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Accessing adjacent `u8` as `u16`\n+    ///\n+    /// ```\n+    /// # #![feature(align_offset)]\n+    /// # fn foo(n: usize) {\n+    /// # use std::mem::align_of;\n+    /// # unsafe {\n+    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n+    /// let ptr = &x[n] as *const u8;\n+    /// let offset = ptr.align_offset(align_of::<u16>());\n+    /// if offset < x.len() - n - 1 {\n+    ///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n+    ///     assert_ne!(*u16_ptr, 500);\n+    /// } else {\n+    ///     // while the pointer can be aligned via `offset`, it would point\n+    ///     // outside the allocation\n+    /// }\n+    /// # } }\n+    /// ```\n+    #[unstable(feature = \"align_offset\", issue = \"44488\")]\n+    pub fn align_offset(self, align: usize) -> usize {\n+        unsafe {\n+            intrinsics::align_offset(self as *const _, align)\n+        }\n+    }\n }\n \n #[lang = \"mut_ptr\"]\n@@ -1284,6 +1320,43 @@ impl<T: ?Sized> *mut T {\n         }\n     }\n \n+    /// Computes the byte offset that needs to be applied in order to\n+    /// make the pointer aligned to `align`.\n+    /// If it is not possible to align the pointer, the implementation returns\n+    /// `usize::max_value()`.\n+    ///\n+    /// There are no guarantees whatsover that offsetting the pointer will not\n+    /// overflow or go beyond the allocation that the pointer points into.\n+    /// It is up to the caller to ensure that the returned offset is correct\n+    /// in all terms other than alignment.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Accessing adjacent `u8` as `u16`\n+    ///\n+    /// ```\n+    /// # #![feature(align_offset)]\n+    /// # fn foo(n: usize) {\n+    /// # use std::mem::align_of;\n+    /// # unsafe {\n+    /// let x = [5u8, 6u8, 7u8, 8u8, 9u8];\n+    /// let ptr = &x[n] as *const u8;\n+    /// let offset = ptr.align_offset(align_of::<u16>());\n+    /// if offset < x.len() - n - 1 {\n+    ///     let u16_ptr = ptr.offset(offset as isize) as *const u16;\n+    ///     assert_ne!(*u16_ptr, 500);\n+    /// } else {\n+    ///     // while the pointer can be aligned via `offset`, it would point\n+    ///     // outside the allocation\n+    /// }\n+    /// # } }\n+    /// ```\n+    #[unstable(feature = \"align_offset\", issue = \"44488\")]\n+    pub fn align_offset(self, align: usize) -> usize {\n+        unsafe {\n+            intrinsics::align_offset(self as *const _, align)\n+        }\n+    }\n \n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///"}, {"sha": "c24cdb30badaede0a9c14a9d14982815767c2155", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -23,7 +23,6 @@ use fmt;\n use iter::{Map, Cloned, FusedIterator};\n use slice::{self, SliceIndex};\n use mem;\n-use intrinsics::align_offset;\n \n pub mod pattern;\n \n@@ -404,7 +403,7 @@ unsafe fn from_raw_parts_mut<'a>(p: *mut u8, len: usize) -> &'a mut str {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n-    mem::transmute(v)\n+    &*(v as *const [u8] as *const str)\n }\n \n /// Converts a slice of bytes to a string slice without checking\n@@ -429,7 +428,7 @@ pub unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n #[inline]\n #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n pub unsafe fn from_utf8_unchecked_mut(v: &mut [u8]) -> &mut str {\n-    mem::transmute(v)\n+    &mut *(v as *mut [u8] as *mut str)\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1515,7 +1514,7 @@ fn run_utf8_validation(v: &[u8]) -> Result<(), Utf8Error> {\n             let ptr = v.as_ptr();\n             let align = unsafe {\n                 // the offset is safe, because `index` is guaranteed inbounds\n-                align_offset(ptr.offset(index as isize) as *const (), usize_bytes)\n+                ptr.offset(index as isize).align_offset(usize_bytes)\n             };\n             if align == 0 {\n                 while index < blocks_end {\n@@ -2447,12 +2446,12 @@ impl StrExt for str {\n \n     #[inline]\n     fn as_bytes(&self) -> &[u8] {\n-        unsafe { mem::transmute(self) }\n+        unsafe { &*(self as *const str as *const [u8]) }\n     }\n \n     #[inline]\n     unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n-        mem::transmute(self)\n+        &mut *(self as *mut str as *mut [u8])\n     }\n \n     fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {"}, {"sha": "7c21bba49f81b3ff594f683eae0417435431e7ee", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -603,12 +603,12 @@ trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {\n }\n \n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a, T> DepNodeParams<'a, 'gcx, 'tcx> for T\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + fmt::Debug\n+    where T: HashStable<StableHashingContext<'gcx>> + fmt::Debug\n {\n     default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     default fn to_fingerprint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Fingerprint {\n-        let mut hcx = StableHashingContext::new(tcx);\n+        let mut hcx = tcx.create_stable_hashing_context();\n         let mut hasher = StableHasher::new();\n \n         self.hash_stable(&mut hcx, &mut hasher);\n@@ -633,6 +633,18 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId,) {\n     }\n }\n \n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIndex,) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        tcx.hir.definitions().def_path_hash(self.0).0\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        tcx.item_path_str(DefId::local(self.0))\n+    }\n+}\n+\n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n "}, {"sha": "7679b7e7971ebdcee387fafb99ebce4c3da6115c", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -9,11 +9,15 @@\n // except according to those terms.\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHashingContextProvider};\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n use util::common::{ProfileQueriesMsg, profq_msg};\n \n+use ich::Fingerprint;\n+\n use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n@@ -71,10 +75,6 @@ impl DepGraph {\n         self.data.as_ref().map(|data| raii::IgnoreTask::new(&data.edges))\n     }\n \n-    pub fn in_task<'graph>(&'graph self, key: DepNode) -> Option<raii::DepTask<'graph>> {\n-        self.data.as_ref().map(|data| raii::DepTask::new(&data.edges, key))\n-    }\n-\n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n         where OP: FnOnce() -> R\n     {\n@@ -109,24 +109,38 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [README]: README.md\n-    pub fn with_task<C, A, R>(&self,\n-                              key: DepNode,\n-                              cx: C,\n-                              arg: A,\n-                              task: fn(C, A) -> R)\n-                              -> (R, DepNodeIndex)\n-        where C: DepGraphSafe\n+    pub fn with_task<C, A, R, HCX>(&self,\n+                                   key: DepNode,\n+                                   cx: C,\n+                                   arg: A,\n+                                   task: fn(C, A) -> R)\n+                                   -> (R, DepNodeIndex)\n+        where C: DepGraphSafe + StableHashingContextProvider<ContextType=HCX>,\n+              R: HashStable<HCX>,\n     {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().push_task(key);\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n             };\n+\n+            // In incremental mode, hash the result of the task. We don't\n+            // do anything with the hash yet, but we are computing it\n+            // anyway so that\n+            //  - we make sure that the infrastructure works and\n+            //  - we can get an idea of the runtime cost.\n+            let mut hcx = cx.create_stable_hashing_context();\n+\n             let result = task(cx, arg);\n             if cfg!(debug_assertions) {\n                 profq_msg(ProfileQueriesMsg::TaskEnd)\n             };\n             let dep_node_index = data.edges.borrow_mut().pop_task(key);\n+\n+            let mut stable_hasher = StableHasher::new();\n+            result.hash_stable(&mut hcx, &mut stable_hasher);\n+            let _: Fingerprint = stable_hasher.finish();\n+\n             (result, dep_node_index)\n         } else {\n             (task(cx, arg), DepNodeIndex::INVALID)"}, {"sha": "f82bf9be033908386c43fdbae67528ab6bf44e16", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -58,6 +58,13 @@ impl<'a, A> DepGraphSafe for &'a A\n {\n }\n \n+/// Mut ref to dep-graph-safe stuff should still be dep-graph-safe.\n+impl<'a, A> DepGraphSafe for &'a mut A\n+    where A: DepGraphSafe,\n+{\n+}\n+\n+\n /// No data here! :)\n impl DepGraphSafe for () {\n }"}, {"sha": "b2d6886e7f22800bcd137c734953c75247be70c3", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -247,7 +247,7 @@ pub struct Map<'hir> {\n     /// plain old integers.\n     map: Vec<MapEntry<'hir>>,\n \n-    definitions: Definitions,\n+    definitions: &'hir Definitions,\n \n     /// Bodies inlined from other crates are cached here.\n     inlined_bodies: RefCell<DefIdMap<&'hir Body>>,\n@@ -304,8 +304,8 @@ impl<'hir> Map<'hir> {\n     }\n \n     #[inline]\n-    pub fn definitions(&self) -> &Definitions {\n-        &self.definitions\n+    pub fn definitions(&self) -> &'hir Definitions {\n+        self.definitions\n     }\n \n     pub fn def_key(&self, def_id: DefId) -> DefKey {\n@@ -1013,7 +1013,7 @@ impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n pub fn map_crate<'hir>(forest: &'hir mut Forest,\n-                       definitions: Definitions)\n+                       definitions: &'hir Definitions)\n                        -> Map<'hir> {\n     let map = {\n         let mut collector = NodeCollector::root(&forest.krate,"}, {"sha": "71e442b3bb2132494642458cd0408237d3f69ccf", "filename": "src/librustc/ich/caching_codemap_view.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fcaching_codemap_view.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -11,7 +11,6 @@\n use std::rc::Rc;\n use syntax::codemap::CodeMap;\n use syntax_pos::{BytePos, FileMap};\n-use ty::TyCtxt;\n \n #[derive(Clone)]\n struct CacheEntry {\n@@ -23,15 +22,14 @@ struct CacheEntry {\n     file_index: usize,\n }\n \n-pub struct CachingCodemapView<'tcx> {\n-    codemap: &'tcx CodeMap,\n+pub struct CachingCodemapView<'cm> {\n+    codemap: &'cm CodeMap,\n     line_cache: [CacheEntry; 3],\n     time_stamp: usize,\n }\n \n-impl<'gcx> CachingCodemapView<'gcx> {\n-    pub fn new<'a, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> CachingCodemapView<'gcx> {\n-        let codemap = tcx.sess.codemap();\n+impl<'cm> CachingCodemapView<'cm> {\n+    pub fn new(codemap: &'cm CodeMap) -> CachingCodemapView<'cm> {\n         let files = codemap.files();\n         let first_file = files[0].clone();\n         let entry = CacheEntry {"}, {"sha": "64fc63002da1f49badb6caffd2e3b383063066c5", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 191, "deletions": 136, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -9,72 +9,116 @@\n // except according to those terms.\n \n use hir;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, DefIndex};\n use hir::map::DefPathHash;\n+use hir::map::definitions::Definitions;\n use ich::{self, CachingCodemapView};\n+use middle::cstore::CrateStore;\n use session::config::DebugInfoLevel::NoDebugInfo;\n-use ty::TyCtxt;\n-use util::nodemap::{NodeMap, ItemLocalMap};\n+use ty::{TyCtxt, fast_reject};\n+use session::Session;\n \n+use std::cmp::Ord;\n use std::hash as std_hash;\n-use std::collections::{HashMap, HashSet, BTreeMap};\n+use std::cell::RefCell;\n+use std::collections::HashMap;\n \n use syntax::ast;\n use syntax::attr;\n+use syntax::codemap::CodeMap;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHashingContextProvider,\n+                                           StableHasher, StableHasherResult,\n+                                           ToStableHashKey};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use rustc_data_structures::fx::FxHashSet;\n+\n+thread_local!(static IGNORED_ATTR_NAMES: RefCell<FxHashSet<Symbol>> =\n+    RefCell::new(FxHashSet()));\n \n /// This is the context state available during incr. comp. hashing. It contains\n /// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n /// a reference to the TyCtxt) and it holds a few caches for speeding up various\n /// things (e.g. each DefId/DefPath is only hashed once).\n-pub struct StableHashingContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    codemap: CachingCodemapView<'gcx>,\n+pub struct StableHashingContext<'gcx> {\n+    sess: &'gcx Session,\n+    definitions: &'gcx Definitions,\n+    cstore: &'gcx CrateStore,\n+    body_resolver: BodyResolver<'gcx>,\n     hash_spans: bool,\n     hash_bodies: bool,\n     overflow_checks_enabled: bool,\n     node_id_hashing_mode: NodeIdHashingMode,\n-    // A sorted array of symbol keys for fast lookup.\n-    ignored_attr_names: Vec<Symbol>,\n+\n+    // Very often, we are hashing something that does not need the\n+    // CachingCodemapView, so we initialize it lazily.\n+    raw_codemap: &'gcx CodeMap,\n+    caching_codemap: Option<CachingCodemapView<'gcx>>,\n }\n \n #[derive(PartialEq, Eq, Clone, Copy)]\n pub enum NodeIdHashingMode {\n     Ignore,\n     HashDefPath,\n-    HashTraitsInScope,\n }\n \n-impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n-\n-    pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Self {\n-        let hash_spans_initial = tcx.sess.opts.debuginfo != NoDebugInfo;\n-        let check_overflow_initial = tcx.sess.overflow_checks();\n-\n-        let mut ignored_attr_names: Vec<_> = ich::IGNORED_ATTRIBUTES\n-            .iter()\n-            .map(|&s| Symbol::intern(s))\n-            .collect();\n+/// The BodyResolver allows to map a BodyId to the corresponding hir::Body.\n+/// We could also just store a plain reference to the hir::Crate but we want\n+/// to avoid that the crate is used to get untracked access to all of the HIR.\n+#[derive(Clone, Copy)]\n+struct BodyResolver<'gcx>(&'gcx hir::Crate);\n+\n+impl<'gcx> BodyResolver<'gcx> {\n+    // Return a reference to the hir::Body with the given BodyId.\n+    // DOES NOT DO ANY TRACKING, use carefully.\n+    fn body(self, id: hir::BodyId) -> &'gcx hir::Body {\n+        self.0.body(id)\n+    }\n+}\n \n-        ignored_attr_names.sort();\n+impl<'gcx> StableHashingContext<'gcx> {\n+    // The `krate` here is only used for mapping BodyIds to Bodies.\n+    // Don't use it for anything else or you'll run the risk of\n+    // leaking data out of the tracking system.\n+    pub fn new(sess: &'gcx Session,\n+               krate: &'gcx hir::Crate,\n+               definitions: &'gcx Definitions,\n+               cstore: &'gcx CrateStore)\n+               -> Self {\n+        let hash_spans_initial = sess.opts.debuginfo != NoDebugInfo;\n+        let check_overflow_initial = sess.overflow_checks();\n+\n+        debug_assert!(ich::IGNORED_ATTRIBUTES.len() > 0);\n+        IGNORED_ATTR_NAMES.with(|names| {\n+            let mut names = names.borrow_mut();\n+            if names.is_empty() {\n+                names.extend(ich::IGNORED_ATTRIBUTES.iter()\n+                                                    .map(|&s| Symbol::intern(s)));\n+            }\n+        });\n \n         StableHashingContext {\n-            tcx,\n-            codemap: CachingCodemapView::new(tcx),\n+            sess,\n+            body_resolver: BodyResolver(krate),\n+            definitions,\n+            cstore,\n+            caching_codemap: None,\n+            raw_codemap: sess.codemap(),\n             hash_spans: hash_spans_initial,\n             hash_bodies: true,\n             overflow_checks_enabled: check_overflow_initial,\n             node_id_hashing_mode: NodeIdHashingMode::HashDefPath,\n-            ignored_attr_names,\n         }\n     }\n \n+    #[inline]\n+    pub fn sess(&self) -> &'gcx Session {\n+        self.sess\n+    }\n+\n     pub fn force_span_hashing(mut self) -> Self {\n         self.hash_spans = true;\n         self\n@@ -111,13 +155,17 @@ impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n-        self.tcx\n+    pub fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n+        if def_id.is_local() {\n+            self.definitions.def_path_hash(def_id.index)\n+        } else {\n+            self.cstore.def_path_hash(def_id)\n+        }\n     }\n \n     #[inline]\n-    pub fn def_path_hash(&mut self, def_id: DefId) -> DefPathHash {\n-        self.tcx.def_path_hash(def_id)\n+    pub fn local_def_path_hash(&self, def_index: DefIndex) -> DefPathHash {\n+        self.definitions.def_path_hash(def_index)\n     }\n \n     #[inline]\n@@ -132,12 +180,22 @@ impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn codemap(&mut self) -> &mut CachingCodemapView<'gcx> {\n-        &mut self.codemap\n+        match self.caching_codemap {\n+            Some(ref mut cm) => {\n+                cm\n+            }\n+            ref mut none => {\n+                *none = Some(CachingCodemapView::new(self.raw_codemap));\n+                none.as_mut().unwrap()\n+            }\n+        }\n     }\n \n     #[inline]\n     pub fn is_ignored_attr(&self, name: Symbol) -> bool {\n-        self.ignored_attr_names.binary_search(&name).is_ok()\n+        IGNORED_ATTR_NAMES.with(|names| {\n+            names.borrow().contains(&name)\n+        })\n     }\n \n     pub fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self,\n@@ -194,44 +252,84 @@ impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n     }\n }\n \n+impl<'a, 'gcx, 'lcx> StableHashingContextProvider for TyCtxt<'a, 'gcx, 'lcx> {\n+    type ContextType = StableHashingContext<'gcx>;\n+    fn create_stable_hashing_context(&self) -> Self::ContextType {\n+        (*self).create_stable_hashing_context()\n+    }\n+}\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::BodyId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        if hcx.hash_bodies() {\n+            hcx.body_resolver.body(*self).hash_stable(hcx, hasher);\n+        }\n+    }\n+}\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::NodeId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::HirId {\n+    #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let hir_id = hcx.tcx.hir.node_to_hir_id(*self);\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n-                // Most NodeIds in the HIR can be ignored, but if there is a\n-                // corresponding entry in the `trait_map` we need to hash that.\n-                // Make sure we don't ignore too much by checking that there is\n-                // no entry in a debug_assert!().\n-                debug_assert!(hcx.tcx.in_scope_traits(hir_id).is_none());\n+                // Don't do anything.\n             }\n             NodeIdHashingMode::HashDefPath => {\n-                hir_id.hash_stable(hcx, hasher);\n+                let hir::HirId {\n+                    owner,\n+                    local_id,\n+                } = *self;\n+\n+                hcx.local_def_path_hash(owner).hash_stable(hcx, hasher);\n+                local_id.hash_stable(hcx, hasher);\n             }\n-            NodeIdHashingMode::HashTraitsInScope => {\n-                if let Some(traits) = hcx.tcx.in_scope_traits(hir_id) {\n-                    // The ordering of the candidates is not fixed. So we hash\n-                    // the def-ids and then sort them and hash the collection.\n-                    let mut candidates: AccumulateVec<[_; 8]> =\n-                        traits.iter()\n-                              .map(|&hir::TraitCandidate { def_id, import_id: _ }| {\n-                                  hcx.def_path_hash(def_id)\n-                              })\n-                              .collect();\n-                    if traits.len() > 1 {\n-                        candidates.sort();\n-                    }\n-                    candidates.hash_stable(hcx, hasher);\n-                }\n+        }\n+    }\n+}\n+\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::HirId {\n+    type KeyType = (DefPathHash, hir::ItemLocalId);\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          hcx: &StableHashingContext<'gcx>)\n+                          -> (DefPathHash, hir::ItemLocalId) {\n+        let def_path_hash = hcx.local_def_path_hash(self.owner);\n+        (def_path_hash, self.local_id)\n+    }\n+}\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::NodeId {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        match hcx.node_id_hashing_mode {\n+            NodeIdHashingMode::Ignore => {\n+                // Don't do anything.\n+            }\n+            NodeIdHashingMode::HashDefPath => {\n+                hcx.definitions.node_to_hir_id(*self).hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for ast::NodeId {\n+    type KeyType = (DefPathHash, hir::ItemLocalId);\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          hcx: &StableHashingContext<'gcx>)\n+                          -> (DefPathHash, hir::ItemLocalId) {\n+        hcx.definitions.node_to_hir_id(*self).to_stable_hash_key(hcx)\n+    }\n+}\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos\n     // fields (that would be similar to hashing pointers, since those are just\n@@ -243,7 +341,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n     // Also, hashing filenames is expensive so we avoid doing it twice when the\n     // span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use syntax_pos::Pos;\n \n@@ -306,90 +404,47 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n     }\n }\n \n-pub fn hash_stable_hashmap<'a, 'gcx, 'tcx, K, V, R, SK, F, W>(\n-    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+pub fn hash_stable_trait_impls<'gcx, W, R>(\n+    hcx: &mut StableHashingContext<'gcx>,\n     hasher: &mut StableHasher<W>,\n-    map: &HashMap<K, V, R>,\n-    extract_stable_key: F)\n-    where K: Eq + std_hash::Hash,\n-          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+    blanket_impls: &Vec<DefId>,\n+    non_blanket_impls: &HashMap<fast_reject::SimplifiedType, Vec<DefId>, R>)\n+    where W: StableHasherResult,\n           R: std_hash::BuildHasher,\n-          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n-          W: StableHasherResult,\n {\n-    let mut keys: Vec<_> = map.keys()\n-                              .map(|k| (extract_stable_key(hcx, k), k))\n-                              .collect();\n-    keys.sort_unstable_by_key(|&(ref stable_key, _)| stable_key.clone());\n-    keys.len().hash_stable(hcx, hasher);\n-    for (stable_key, key) in keys {\n-        stable_key.hash_stable(hcx, hasher);\n-        map[key].hash_stable(hcx, hasher);\n-    }\n-}\n-\n-pub fn hash_stable_hashset<'a, 'tcx, 'gcx, K, R, SK, F, W>(\n-    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-    hasher: &mut StableHasher<W>,\n-    set: &HashSet<K, R>,\n-    extract_stable_key: F)\n-    where K: Eq + std_hash::Hash,\n-          R: std_hash::BuildHasher,\n-          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n-          W: StableHasherResult,\n-{\n-    let mut keys: Vec<_> = set.iter()\n-                              .map(|k| extract_stable_key(hcx, k))\n-                              .collect();\n-    keys.sort_unstable();\n-    keys.hash_stable(hcx, hasher);\n-}\n+    {\n+        let mut blanket_impls: AccumulateVec<[_; 8]> = blanket_impls\n+            .iter()\n+            .map(|&def_id| hcx.def_path_hash(def_id))\n+            .collect();\n \n-pub fn hash_stable_nodemap<'a, 'tcx, 'gcx, V, W>(\n-    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-    hasher: &mut StableHasher<W>,\n-    map: &NodeMap<V>)\n-    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          W: StableHasherResult,\n-{\n-    hash_stable_hashmap(hcx, hasher, map, |hcx, node_id| {\n-        hcx.tcx.hir.definitions().node_to_hir_id(*node_id).local_id\n-    });\n-}\n+        if blanket_impls.len() > 1 {\n+            blanket_impls.sort_unstable();\n+        }\n \n-pub fn hash_stable_itemlocalmap<'a, 'tcx, 'gcx, V, W>(\n-    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-    hasher: &mut StableHasher<W>,\n-    map: &ItemLocalMap<V>)\n-    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          W: StableHasherResult,\n-{\n-    hash_stable_hashmap(hcx, hasher, map, |_, local_id| {\n-        *local_id\n-    });\n-}\n+        blanket_impls.hash_stable(hcx, hasher);\n+    }\n \n+    {\n+        let mut keys: AccumulateVec<[_; 8]> =\n+            non_blanket_impls.keys()\n+                             .map(|k| (k, k.map_def(|d| hcx.def_path_hash(d))))\n+                             .collect();\n+        keys.sort_unstable_by(|&(_, ref k1), &(_, ref k2)| k1.cmp(k2));\n+        keys.len().hash_stable(hcx, hasher);\n+        for (key, ref stable_key) in keys {\n+            stable_key.hash_stable(hcx, hasher);\n+            let mut impls : AccumulateVec<[_; 8]> = non_blanket_impls[key]\n+                .iter()\n+                .map(|&impl_id| hcx.def_path_hash(impl_id))\n+                .collect();\n+\n+            if impls.len() > 1 {\n+                impls.sort_unstable();\n+            }\n \n-pub fn hash_stable_btreemap<'a, 'tcx, 'gcx, K, V, SK, F, W>(\n-    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-    hasher: &mut StableHasher<W>,\n-    map: &BTreeMap<K, V>,\n-    extract_stable_key: F)\n-    where K: Eq + Ord,\n-          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          SK: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> + Ord + Clone,\n-          F: Fn(&mut StableHashingContext<'a, 'gcx, 'tcx>, &K) -> SK,\n-          W: StableHasherResult,\n-{\n-    let mut keys: Vec<_> = map.keys()\n-                              .map(|k| (extract_stable_key(hcx, k), k))\n-                              .collect();\n-    keys.sort_unstable_by_key(|&(ref stable_key, _)| stable_key.clone());\n-    keys.len().hash_stable(hcx, hasher);\n-    for (stable_key, key) in keys {\n-        stable_key.hash_stable(hcx, hasher);\n-        map[key].hash_stable(hcx, hasher);\n+            impls.hash_stable(hcx, hasher);\n+        }\n     }\n }\n+"}, {"sha": "18a02ff5c58826f711b604662324df24b7500a7d", "filename": "src/librustc/ich/impls_cstore.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -11,6 +11,8 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::middle::cstore in no particular order.\n \n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n+\n use middle;\n \n impl_stable_hash_for!(enum middle::cstore::DepKind {\n@@ -38,3 +40,42 @@ impl_stable_hash_for!(enum middle::cstore::LinkagePreference {\n     RequireDynamic,\n     RequireStatic\n });\n+\n+impl_stable_hash_for!(struct middle::cstore::ExternCrate {\n+    def_id,\n+    span,\n+    direct,\n+    path_len\n+});\n+\n+impl_stable_hash_for!(struct middle::cstore::CrateSource {\n+    dylib,\n+    rlib,\n+    rmeta\n+});\n+\n+impl<HCX> HashStable<HCX> for middle::cstore::ExternBodyNestedBodies {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut HCX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let middle::cstore::ExternBodyNestedBodies {\n+            nested_bodies: _,\n+            fingerprint,\n+        } = *self;\n+\n+        fingerprint.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, HCX> HashStable<HCX> for middle::cstore::ExternConstBody<'a> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut HCX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let middle::cstore::ExternConstBody {\n+            body: _,\n+            fingerprint,\n+        } = *self;\n+\n+        fingerprint.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "9582b03ce1c8a80b7b373a4d5e429a073f25b532", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 163, "deletions": 159, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -12,45 +12,36 @@\n //! types in no particular order.\n \n use hir;\n+use hir::map::DefPathHash;\n use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n use ich::{StableHashingContext, NodeIdHashingMode};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n+                                           StableHasher, StableHasherResult};\n use std::mem;\n-\n use syntax::ast;\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n-\n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for DefId {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(*self).hash_stable(hcx, hasher);\n     }\n }\n \n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for DefId {\n+    type KeyType = DefPathHash;\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::HirId {\n     #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::HirId {\n-            owner,\n-            local_id,\n-        } = *self;\n-\n-        hcx.def_path_hash(DefId::local(owner)).hash_stable(hcx, hasher);\n-        local_id.hash_stable(hcx, hasher);\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+        hcx.def_path_hash(*self)\n     }\n }\n \n-\n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for CrateNum {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for CrateNum {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.def_path_hash(DefId {\n             krate: *self,\n@@ -59,18 +50,40 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for CrateN\n     }\n }\n \n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for CrateNum {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+        let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n+        def_id.to_stable_hash_key(hcx)\n+    }\n+}\n+\n impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n \n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>>\n+for hir::ItemLocalId {\n+    type KeyType = hir::ItemLocalId;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          _: &StableHashingContext<'gcx>)\n+                          -> hir::ItemLocalId {\n+        *self\n+    }\n+}\n+\n // The following implementations of HashStable for ItemId, TraitItemId, and\n // ImplItemId deserve special attention. Normally we do not hash NodeIds within\n // the HIR, since they just signify a HIR nodes own path. But ItemId et al\n // are used when another item in the HIR is *referenced* and we certainly\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ItemId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ItemId {\n             id\n@@ -82,9 +95,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitItemId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItemId {\n             node_id\n@@ -96,9 +109,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::T\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ImplItemId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItemId {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItemId {\n             node_id\n@@ -218,40 +231,17 @@ impl_stable_hash_for!(struct hir::TypeBinding {\n     span\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Ty {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Ty {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let node_id_hashing_mode = match self.node {\n-            hir::TySlice(..)       |\n-            hir::TyArray(..)       |\n-            hir::TyPtr(..)         |\n-            hir::TyRptr(..)        |\n-            hir::TyBareFn(..)      |\n-            hir::TyNever           |\n-            hir::TyTup(..)         |\n-            hir::TyTraitObject(..) |\n-            hir::TyImplTrait(..)   |\n-            hir::TyTypeof(..)      |\n-            hir::TyErr             |\n-            hir::TyInfer           => {\n-                NodeIdHashingMode::Ignore\n-            }\n-            hir::TyPath(..) => {\n-                NodeIdHashingMode::HashTraitsInScope\n-            }\n-        };\n-\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n-                id,\n+                id: _,\n                 ref node,\n                 ref span,\n             } = *self;\n \n-            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n-                id.hash_stable(hcx, hasher);\n-            });\n             node.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         })\n@@ -302,19 +292,17 @@ impl_stable_hash_for!(enum hir::FunctionRetTy {\n     Return(t)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitRef {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitRef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitRef {\n             ref path,\n-            ref_id,\n+            // Don't hash the ref_id. It is tracked via the thing it is used to access\n+            ref_id: _,\n         } = *self;\n \n         path.hash_stable(hcx, hasher);\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashTraitsInScope, |hcx| {\n-            ref_id.hash_stable(hcx, hasher);\n-        });\n     }\n }\n \n@@ -341,14 +329,14 @@ impl_stable_hash_for!(struct hir::MacroDef {\n });\n \n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Block {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Block {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Block {\n             ref stmts,\n             ref expr,\n-            id,\n+            id: _,\n             hir_id: _,\n             rules,\n             span,\n@@ -383,45 +371,24 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::B\n         }\n \n         expr.hash_stable(hcx, hasher);\n-        id.hash_stable(hcx, hasher);\n         rules.hash_stable(hcx, hasher);\n         span.hash_stable(hcx, hasher);\n         targeted_by_break.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Pat {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Pat {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let node_id_hashing_mode = match self.node {\n-            hir::PatKind::Wild        |\n-            hir::PatKind::Binding(..) |\n-            hir::PatKind::Tuple(..)   |\n-            hir::PatKind::Box(..)     |\n-            hir::PatKind::Ref(..)     |\n-            hir::PatKind::Lit(..)     |\n-            hir::PatKind::Range(..)   |\n-            hir::PatKind::Slice(..)   => {\n-                NodeIdHashingMode::Ignore\n-            }\n-            hir::PatKind::Path(..)        |\n-            hir::PatKind::Struct(..)      |\n-            hir::PatKind::TupleStruct(..) => {\n-                NodeIdHashingMode::HashTraitsInScope\n-            }\n-        };\n-\n         let hir::Pat {\n-            id,\n+            id: _,\n             hir_id: _,\n             ref node,\n             ref span\n         } = *self;\n \n-        hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n-            id.hash_stable(hcx, hasher);\n-        });\n+\n         node.hash_stable(hcx, hasher);\n         span.hash_stable(hcx, hasher);\n     }\n@@ -537,20 +504,20 @@ impl_stable_hash_for!(enum hir::UnsafeSource {\n     UserProvided\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Expr {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Expr {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n-                id,\n+                id: _,\n                 hir_id: _,\n                 ref span,\n                 ref node,\n                 ref attrs\n             } = *self;\n \n-            let (spans_always_on, node_id_hashing_mode) = match *node {\n+            let spans_always_on = match *node {\n                 hir::ExprBox(..)        |\n                 hir::ExprArray(..)      |\n                 hir::ExprCall(..)       |\n@@ -569,41 +536,33 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::E\n                 hir::ExprBreak(..)      |\n                 hir::ExprAgain(..)      |\n                 hir::ExprRet(..)        |\n-                hir::ExprYield(..)    |\n+                hir::ExprYield(..)      |\n                 hir::ExprInlineAsm(..)  |\n                 hir::ExprRepeat(..)     |\n-                hir::ExprTup(..)        => {\n+                hir::ExprTup(..)        |\n+                hir::ExprMethodCall(..) |\n+                hir::ExprPath(..)       |\n+                hir::ExprStruct(..)     |\n+                hir::ExprField(..)      => {\n                     // For these we only hash the span when debuginfo is on.\n-                    (false, NodeIdHashingMode::Ignore)\n+                    false\n                 }\n                 // For the following, spans might be significant because of\n                 // panic messages indicating the source location.\n                 hir::ExprBinary(op, ..) => {\n-                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::Ignore)\n+                    hcx.binop_can_panic_at_runtime(op.node)\n                 }\n                 hir::ExprUnary(op, _) => {\n-                    (hcx.unop_can_panic_at_runtime(op), NodeIdHashingMode::Ignore)\n+                    hcx.unop_can_panic_at_runtime(op)\n                 }\n                 hir::ExprAssignOp(op, ..) => {\n-                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::Ignore)\n+                    hcx.binop_can_panic_at_runtime(op.node)\n                 }\n                 hir::ExprIndex(..) => {\n-                    (true, NodeIdHashingMode::Ignore)\n-                }\n-                // For these we don't care about the span, but want to hash the\n-                // trait in scope\n-                hir::ExprMethodCall(..) |\n-                hir::ExprPath(..)       |\n-                hir::ExprStruct(..)     |\n-                hir::ExprField(..)      => {\n-                    (false, NodeIdHashingMode::HashTraitsInScope)\n+                    true\n                 }\n             };\n \n-            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n-                id.hash_stable(hcx, hasher);\n-            });\n-\n             if spans_always_on {\n                 hcx.while_hashing_spans(true, |hcx| {\n                     span.hash_stable(hcx, hasher);\n@@ -663,9 +622,9 @@ impl_stable_hash_for!(enum hir::LoopSource {\n     ForLoop\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::MatchSource {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::MatchSource {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use hir::MatchSource;\n \n@@ -714,9 +673,9 @@ impl_stable_hash_for!(enum hir::ScopeTarget {\n     Loop(loop_id_result)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Ident {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Ident {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ast::Ident {\n             ref name,\n@@ -727,9 +686,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::I\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::TraitItem {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::TraitItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id,\n@@ -761,9 +720,9 @@ impl_stable_hash_for!(enum hir::TraitItemKind {\n     Type(bounds, rhs)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::ImplItem {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::ImplItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id,\n@@ -794,9 +753,9 @@ impl_stable_hash_for!(enum hir::ImplItemKind {\n     Type(t)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Visibility {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Visibility {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -806,7 +765,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::V\n                 // No fields to hash.\n             }\n             hir::Visibility::Restricted { ref path, id } => {\n-                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashTraitsInScope, |hcx| {\n+                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                     id.hash_stable(hcx, hasher);\n                 });\n                 path.hash_stable(hcx, hasher);\n@@ -815,9 +774,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::V\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Defaultness {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Defaultness {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -836,9 +795,9 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Mod {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Mod {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Mod {\n             inner,\n@@ -891,20 +850,17 @@ impl_stable_hash_for!(enum hir::VariantData {\n     Unit(id)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::Item {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Item {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let (node_id_hashing_mode, hash_spans) = match self.node {\n+        let hash_spans = match self.node {\n             hir::ItemStatic(..)      |\n             hir::ItemConst(..)       |\n             hir::ItemFn(..)          => {\n-                (NodeIdHashingMode::Ignore, hcx.hash_spans())\n+                hcx.hash_spans()\n             }\n-            hir::ItemUse(..) => {\n-                (NodeIdHashingMode::HashTraitsInScope, false)\n-            }\n-\n+            hir::ItemUse(..)         |\n             hir::ItemExternCrate(..) |\n             hir::ItemForeignMod(..)  |\n             hir::ItemGlobalAsm(..)   |\n@@ -916,14 +872,14 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n             hir::ItemEnum(..)        |\n             hir::ItemStruct(..)      |\n             hir::ItemUnion(..)       => {\n-                (NodeIdHashingMode::Ignore, false)\n+                false\n             }\n         };\n \n         let hir::Item {\n             name,\n             ref attrs,\n-            id,\n+            id: _,\n             hir_id: _,\n             ref node,\n             ref vis,\n@@ -932,9 +888,6 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n \n         hcx.hash_hir_item_like(attrs, |hcx| {\n             hcx.while_hashing_spans(hash_spans, |hcx| {\n-                hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n-                    id.hash_stable(hcx, hasher);\n-                });\n                 name.hash_stable(hcx, hasher);\n                 attrs.hash_stable(hcx, hasher);\n                 node.hash_stable(hcx, hasher);\n@@ -980,10 +933,10 @@ impl_stable_hash_for!(struct hir::ImplItemRef {\n     defaultness\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for hir::AssociatedItemKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -1024,19 +977,33 @@ impl_stable_hash_for!(struct hir::Arg {\n     hir_id\n });\n \n-impl_stable_hash_for!(struct hir::Body {\n-    arguments,\n-    value,\n-    is_generator\n-});\n-\n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::BodyId {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::Body {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        if hcx.hash_bodies() {\n-            hcx.tcx().hir.body(*self).hash_stable(hcx, hasher);\n-        }\n+        let hir::Body {\n+            ref arguments,\n+            ref value,\n+            is_generator,\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::Ignore, |hcx| {\n+            arguments.hash_stable(hcx, hasher);\n+            value.hash_stable(hcx, hasher);\n+            is_generator.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for hir::BodyId {\n+    type KeyType = (DefPathHash, hir::ItemLocalId);\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          hcx: &StableHashingContext<'gcx>)\n+                          -> (DefPathHash, hir::ItemLocalId) {\n+        let hir::BodyId { node_id } = *self;\n+        node_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -1046,9 +1013,9 @@ impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     is_indirect\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::GlobalAsm {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::GlobalAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::GlobalAsm {\n             asm,\n@@ -1059,9 +1026,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::G\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::InlineAsm {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for hir::InlineAsm {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::InlineAsm {\n             asm,\n@@ -1136,13 +1103,23 @@ impl_stable_hash_for!(enum hir::Constness {\n     NotConst\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        DefId::local(*self).hash_stable(hcx, hasher);\n+        hcx.local_def_path_hash(*self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>>\n+for hir::def_id::DefIndex {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+         hcx.local_def_path_hash(*self)\n     }\n }\n \n@@ -1152,11 +1129,38 @@ impl_stable_hash_for!(struct hir::def::Export {\n     span\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          _: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         ::std::hash::Hash::hash(self, hasher);\n     }\n }\n+\n+impl_stable_hash_for!(struct ::middle::lang_items::LanguageItems {\n+    items,\n+    missing\n+});\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+for hir::TraitCandidate {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            let hir::TraitCandidate {\n+                def_id,\n+                import_id,\n+            } = *self;\n+\n+            def_id.hash_stable(hcx, hasher);\n+            import_id.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(struct hir::Freevar {\n+    def,\n+    span\n+});"}, {"sha": "9b6613e4cae96a61d6853be19e3d38d4779b70c3", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -33,11 +33,11 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, by_ref });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::Terminator<'gcx> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Terminator {\n             ref kind,\n@@ -76,61 +76,61 @@ for mir::Terminator<'gcx> {\n }\n \n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Local {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Local {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::BasicBlock {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::BasicBlock {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Field {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Field {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::VisibilityScope {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Promoted {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Promoted {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use rustc_data_structures::indexed_vec::Idx;\n         self.index().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::TerminatorKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -196,10 +196,10 @@ for mir::TerminatorKind<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::AssertMessage<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -219,10 +219,10 @@ for mir::AssertMessage<'gcx> {\n \n impl_stable_hash_for!(struct mir::Statement<'tcx> { source_info, kind });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::StatementKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -256,12 +256,12 @@ for mir::StatementKind<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n     for mir::ValidationOperand<'gcx, T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    where T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>)\n     {\n         self.lval.hash_stable(hcx, hasher);\n@@ -273,9 +273,9 @@ impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n \n impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(region_scope) });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Lvalue<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Lvalue<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -292,14 +292,14 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::L\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, B, V, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, B, V, T> HashStable<StableHashingContext<'gcx>>\n for mir::Projection<'gcx, B, V, T>\n-    where B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    where B: HashStable<StableHashingContext<'gcx>>,\n+          V: HashStable<StableHashingContext<'gcx>>,\n+          T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let mir::Projection {\n             ref base,\n@@ -311,13 +311,13 @@ for mir::Projection<'gcx, B, V, T>\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, V, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, V, T> HashStable<StableHashingContext<'gcx>>\n for mir::ProjectionElem<'gcx, V, T>\n-    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    where V: HashStable<StableHashingContext<'gcx>>,\n+          T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -348,9 +348,9 @@ for mir::ProjectionElem<'gcx, V, T>\n \n impl_stable_hash_for!(struct mir::VisibilityScopeData { span, parent_scope });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Operand<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Operand<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -365,9 +365,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::O\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Rvalue<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Rvalue<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -425,10 +425,10 @@ impl_stable_hash_for!(enum mir::CastKind {\n     Unsize\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for mir::AggregateKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -487,9 +487,9 @@ impl_stable_hash_for!(enum mir::NullOp {\n \n impl_stable_hash_for!(struct mir::Constant<'tcx> { span, ty, literal });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Literal<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for mir::Literal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "951315fb4a84931cd04205f8380c0105f364c76f", "filename": "src/librustc/ich/impls_misc.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_misc.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! that don't fit into any of the other impls_xxx modules.\n+\n+impl_stable_hash_for!(enum ::session::search_paths::PathKind {\n+    Native,\n+    Crate,\n+    Dependency,\n+    Framework,\n+    ExternFlag,\n+    All\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_back::PanicStrategy {\n+    Abort,\n+    Unwind\n+});"}, {"sha": "6821ac85298001627eb9e2e27d7f0960d0234bc3", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 52, "deletions": 25, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -18,35 +18,57 @@ use std::mem;\n \n use syntax::ast;\n use syntax::parse::token;\n+use syntax::symbol::InternedString;\n use syntax::tokenstream;\n use syntax_pos::{Span, FileMap};\n \n use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n+                                           StableHasher, StableHasherResult};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-for ::syntax::symbol::InternedString {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for InternedString {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let s: &str = &**self;\n         s.hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Name {\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for InternedString {\n+    type KeyType = InternedString;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          _: &StableHashingContext<'gcx>)\n+                          -> InternedString {\n+        self.clone()\n+    }\n+}\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_str().hash_stable(hcx, hasher);\n     }\n }\n \n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for ast::Name {\n+    type KeyType = InternedString;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          _: &StableHashingContext<'gcx>)\n+                          -> InternedString {\n+        self.as_str()\n+    }\n+}\n+\n impl_stable_hash_for!(enum ::syntax::ast::AsmDialect {\n     Att,\n     Intel\n@@ -88,10 +110,10 @@ impl_stable_hash_for!(struct ::syntax::attr::Stability {\n     rustc_const_unstable\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ::syntax::attr::StabilityLevel {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -143,10 +165,15 @@ impl_stable_hash_for!(struct ::syntax::ast::Lifetime { id, span, ident });\n impl_stable_hash_for!(enum ::syntax::ast::StrStyle { Cooked, Raw(pounds) });\n impl_stable_hash_for!(enum ::syntax::ast::AttrStyle { Outer, Inner });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for [ast::Attribute] {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for [ast::Attribute] {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n+        if self.len() == 0 {\n+            self.len().hash_stable(hcx, hasher);\n+            return\n+        }\n+\n         // Some attributes are always ignored during hashing.\n         let filtered: AccumulateVec<[&ast::Attribute; 8]> = self\n             .iter()\n@@ -163,9 +190,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for [ast::\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Attribute {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ast::Attribute {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         // Make sure that these have been filtered out.\n         debug_assert!(self.name().map(|name| !hcx.is_ignored_attr(name)).unwrap_or(true));\n@@ -192,10 +219,10 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::A\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for tokenstream::TokenTree {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -214,21 +241,21 @@ for tokenstream::TokenTree {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for tokenstream::TokenStream {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         for sub_tt in self.trees() {\n             sub_tt.hash_stable(hcx, hasher);\n         }\n     }\n }\n \n-fn hash_token<'a, 'gcx, 'tcx, W: StableHasherResult>(token: &token::Token,\n-                                               hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-                                               hasher: &mut StableHasher<W>,\n-                                               error_reporting_span: Span) {\n+fn hash_token<'gcx, W: StableHasherResult>(token: &token::Token,\n+                                           hcx: &mut StableHashingContext<'gcx>,\n+                                           hasher: &mut StableHasher<W>,\n+                                           error_reporting_span: Span) {\n     mem::discriminant(token).hash_stable(hcx, hasher);\n     match *token {\n         token::Token::Eq |\n@@ -297,11 +324,11 @@ fn hash_token<'a, 'gcx, 'tcx, W: StableHasherResult>(token: &token::Token,\n             //            in a stable way, in addition to the HIR.\n             //            Since this is hardly used anywhere, just emit a\n             //            warning for now.\n-            if hcx.tcx().sess.opts.debugging_opts.incremental.is_some() {\n+            if hcx.sess().opts.debugging_opts.incremental.is_some() {\n                 let msg = format!(\"Quasi-quoting might make incremental \\\n                                    compilation very inefficient: {:?}\",\n                                   non_terminal);\n-                hcx.tcx().sess.span_warn(error_reporting_span, &msg[..]);\n+                hcx.sess().span_warn(error_reporting_span, &msg[..]);\n             }\n \n             std_hash::Hash::hash(non_terminal, hasher);\n@@ -331,9 +358,9 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n     NameValue(lit)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for FileMap {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let FileMap {\n             ref name,"}, {"sha": "e3ecaae953a6bdaadb0d2e1fee8549ce8f5f22c9", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 236, "deletions": 88, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -11,38 +11,39 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::ty in no particular order.\n \n-use ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use ich::{StableHashingContext, NodeIdHashingMode};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n+                                           StableHasher, StableHasherResult};\n use std::hash as std_hash;\n use std::mem;\n use middle::region;\n+use traits;\n use ty;\n \n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n for &'gcx ty::Slice<T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>> {\n+    where T: HashStable<StableHashingContext<'gcx>> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         (&self[..]).hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::subst::Kind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         self.as_type().hash_stable(hcx, hasher);\n         self.as_region().hash_stable(hcx, hasher);\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::RegionKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -80,10 +81,10 @@ for ty::RegionKind {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::adjustment::AutoBorrow<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -98,10 +99,10 @@ for ty::adjustment::AutoBorrow<'gcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::adjustment::Adjust<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -123,19 +124,20 @@ for ty::adjustment::Adjust<'gcx> {\n \n impl_stable_hash_for!(struct ty::adjustment::Adjustment<'tcx> { kind, target });\n impl_stable_hash_for!(struct ty::adjustment::OverloadedDeref<'tcx> { region, mutbl });\n-impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n impl_stable_hash_for!(struct ty::UpvarBorrow<'tcx> { kind, region });\n \n+impl_stable_hash_for!(struct ty::UpvarId { var_id, closure_expr_id });\n+\n impl_stable_hash_for!(enum ty::BorrowKind {\n     ImmBorrow,\n     UniqueImmBorrow,\n     MutBorrow\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::UpvarCapture<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -159,11 +161,11 @@ impl_stable_hash_for!(struct ty::FnSig<'tcx> {\n     abi\n });\n \n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Binder<T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>> for ty::Binder<T>\n+    where T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Binder(ref inner) = *self;\n         inner.hash_stable(hcx, hasher);\n@@ -183,13 +185,13 @@ impl_stable_hash_for!(struct ty::TraitPredicate<'tcx> { trait_ref });\n impl_stable_hash_for!(tuple_struct ty::EquatePredicate<'tcx> { t1, t2 });\n impl_stable_hash_for!(struct ty::SubtypePredicate<'tcx> { a_is_expected, a, b });\n \n-impl<'a, 'gcx, 'tcx, A, B> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, A, B> HashStable<StableHashingContext<'gcx>>\n for ty::OutlivesPredicate<A, B>\n-    where A: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+    where A: HashStable<StableHashingContext<'gcx>>,\n+          B: HashStable<StableHashingContext<'gcx>>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::OutlivesPredicate(ref a, ref b) = *self;\n         a.hash_stable(hcx, hasher);\n@@ -201,9 +203,9 @@ impl_stable_hash_for!(struct ty::ProjectionPredicate<'tcx> { projection_ty, ty }\n impl_stable_hash_for!(struct ty::ProjectionTy<'tcx> { substs, item_def_id });\n \n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Predicate<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Predicate<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -243,9 +245,9 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Pr\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::AdtFlags {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::AdtFlags {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          _: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         std_hash::Hash::hash(self, hasher);\n     }\n@@ -270,10 +272,10 @@ impl_stable_hash_for!(struct ty::FieldDef {\n     vis\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ::middle::const_val::ConstVal<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::const_val::ConstVal::*;\n         use middle::const_val::ConstAggregate::*;\n@@ -304,7 +306,9 @@ for ::middle::const_val::ConstVal<'gcx> {\n             }\n             Function(def_id, substs) => {\n                 def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n+                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                    substs.hash_stable(hcx, hasher);\n+                });\n             }\n             Aggregate(Struct(ref name_values)) => {\n                 let mut values = name_values.to_vec();\n@@ -338,6 +342,54 @@ impl_stable_hash_for!(struct ty::Const<'tcx> {\n     val\n });\n \n+impl_stable_hash_for!(struct ::middle::const_val::ConstEvalErr<'tcx> {\n+    span,\n+    kind\n+});\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+for ::middle::const_val::ErrKind<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use middle::const_val::ErrKind::*;\n+\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            CannotCast |\n+            MissingStructField |\n+            NonConstPath |\n+            ExpectedConstTuple |\n+            ExpectedConstStruct |\n+            IndexedNonVec |\n+            IndexNotUsize |\n+            MiscBinaryOp |\n+            MiscCatchAll |\n+            IndexOpFeatureGated |\n+            TypeckError => {\n+                // nothing to do\n+            }\n+            UnimplementedConstVal(s) => {\n+                s.hash_stable(hcx, hasher);\n+            }\n+            IndexOutOfBounds { len, index } => {\n+                len.hash_stable(hcx, hasher);\n+                index.hash_stable(hcx, hasher);\n+            }\n+            Math(ref const_math_err) => {\n+                const_math_err.hash_stable(hcx, hasher);\n+            }\n+            LayoutError(ref layout_error) => {\n+                layout_error.hash_stable(hcx, hasher);\n+            }\n+            ErroneousReferencedConstant(ref const_val) => {\n+                const_val.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n impl_stable_hash_for!(struct ty::ClosureSubsts<'tcx> { substs });\n \n impl_stable_hash_for!(struct ty::GeneratorInterior<'tcx> { witness });\n@@ -358,9 +410,9 @@ impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n     Struct(index)\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Generics {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::Generics {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::Generics {\n             parent,\n@@ -386,10 +438,10 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::Ge\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::RegionParameterDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::RegionParameterDef {\n             name,\n@@ -414,13 +466,12 @@ impl_stable_hash_for!(struct ty::TypeParameterDef {\n     pure_wrt_drop\n });\n \n-\n-impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n for ::middle::resolve_lifetime::Set1<T>\n-    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    where T: HashStable<StableHashingContext<'gcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use middle::resolve_lifetime::Set1;\n \n@@ -463,26 +514,20 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-for region::Scope\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            region::Scope::Node(node_id) |\n-            region::Scope::Destruction(node_id) => {\n-                node_id.hash_stable(hcx, hasher);\n-            }\n-            region::Scope::CallSite(body_id) |\n-            region::Scope::Arguments(body_id) => {\n-                body_id.hash_stable(hcx, hasher);\n-            }\n-            region::Scope::Remainder(block_remainder) => {\n-                block_remainder.hash_stable(hcx, hasher);\n-            }\n-        }\n+impl_stable_hash_for!(enum ::middle::region::Scope {\n+    Node(local_id),\n+    Destruction(local_id),\n+    CallSite(local_id),\n+    Arguments(local_id),\n+    Remainder(block_remainder)\n+});\n+\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for region::Scope {\n+    type KeyType = region::Scope;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, _: &StableHashingContext<'gcx>) -> region::Scope {\n+        *self\n     }\n }\n \n@@ -507,11 +552,11 @@ impl_stable_hash_for!(enum ty::BoundRegion {\n     BrEnv\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::TypeVariants<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         use ty::TypeVariants::*;\n \n@@ -520,6 +565,7 @@ for ty::TypeVariants<'gcx>\n             TyBool  |\n             TyChar  |\n             TyStr   |\n+            TyError |\n             TyNever => {\n                 // Nothing more to hash.\n             }\n@@ -585,10 +631,8 @@ for ty::TypeVariants<'gcx>\n             TyParam(param_ty) => {\n                 param_ty.hash_stable(hcx, hasher);\n             }\n-\n-            TyError     |\n             TyInfer(..) => {\n-                bug!(\"ty::TypeVariants::hash_stable() - Unexpected variant.\")\n+                bug!(\"ty::TypeVariants::hash_stable() - Unexpected variant {:?}.\", *self)\n             }\n         }\n     }\n@@ -604,11 +648,11 @@ impl_stable_hash_for!(struct ty::TypeAndMut<'tcx> {\n     mutbl\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n for ty::ExistentialPredicate<'gcx>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n@@ -636,34 +680,14 @@ impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n     ty\n });\n \n-impl_stable_hash_for!(enum ty::fast_reject::SimplifiedType {\n-    BoolSimplifiedType,\n-    CharSimplifiedType,\n-    IntSimplifiedType(int_ty),\n-    UintSimplifiedType(int_ty),\n-    FloatSimplifiedType(float_ty),\n-    AdtSimplifiedType(def_id),\n-    StrSimplifiedType,\n-    ArraySimplifiedType,\n-    PtrSimplifiedType,\n-    NeverSimplifiedType,\n-    TupleSimplifiedType(size),\n-    TraitSimplifiedType(def_id),\n-    ClosureSimplifiedType(def_id),\n-    GeneratorSimplifiedType(def_id),\n-    AnonSimplifiedType(def_id),\n-    FunctionSimplifiedType(params),\n-    ParameterSimplifiedType\n-});\n-\n impl_stable_hash_for!(struct ty::Instance<'tcx> {\n     def,\n     substs\n });\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::InstanceDef<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::InstanceDef<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n@@ -697,3 +721,127 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::In\n     }\n }\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::TraitDef {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::TraitDef {\n+            // We already have the def_path_hash below, no need to hash it twice\n+            def_id: _,\n+            unsafety,\n+            paren_sugar,\n+            has_default_impl,\n+            def_path_hash,\n+        } = *self;\n+\n+        unsafety.hash_stable(hcx, hasher);\n+        paren_sugar.hash_stable(hcx, hasher);\n+        has_default_impl.hash_stable(hcx, hasher);\n+        def_path_hash.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::Destructor {\n+    did\n+});\n+\n+impl_stable_hash_for!(struct ty::DtorckConstraint<'tcx> {\n+    outlives,\n+    dtorck_types\n+});\n+\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::CrateVariancesMap {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::CrateVariancesMap {\n+            ref dependencies,\n+            ref variances,\n+            // This is just an irrelevant helper value.\n+            empty_variance: _,\n+        } = *self;\n+\n+        dependencies.hash_stable(hcx, hasher);\n+        variances.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::AssociatedItem {\n+    def_id,\n+    name,\n+    kind,\n+    vis,\n+    defaultness,\n+    container,\n+    method_has_self_argument\n+});\n+\n+impl_stable_hash_for!(enum ty::AssociatedKind {\n+    Const,\n+    Method,\n+    Type\n+});\n+\n+impl_stable_hash_for!(enum ty::AssociatedItemContainer {\n+    TraitContainer(def_id),\n+    ImplContainer(def_id)\n+});\n+\n+\n+impl<'gcx, T> HashStable<StableHashingContext<'gcx>>\n+for ty::steal::Steal<T>\n+    where T: HashStable<StableHashingContext<'gcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.borrow().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::ParamEnv<'tcx> {\n+    caller_bounds,\n+    reveal\n+});\n+\n+impl_stable_hash_for!(enum traits::Reveal {\n+    UserFacing,\n+    All\n+});\n+\n+impl_stable_hash_for!(enum ::middle::privacy::AccessLevel {\n+    Reachable,\n+    Exported,\n+    Public\n+});\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>>\n+for ::middle::privacy::AccessLevels {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            let ::middle::privacy::AccessLevels {\n+                ref map\n+            } = *self;\n+\n+            map.hash_stable(hcx, hasher);\n+        });\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ty::CrateInherentImpls {\n+    inherent_impls\n+});\n+\n+impl_stable_hash_for!(enum ::session::CompileIncomplete {\n+    Stopped,\n+    Errored(error_reported)\n+});\n+\n+impl_stable_hash_for!(struct ::util::common::ErrorReported {});\n+\n+impl_stable_hash_for!(tuple_struct ::middle::reachable::ReachableSet {\n+    reachable_set\n+});"}, {"sha": "cd0749a686511f34379f94526e1db7221df4ad79", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -12,9 +12,8 @@\n \n pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n-pub use self::hcx::{StableHashingContext, NodeIdHashingMode, hash_stable_hashmap,\n-                    hash_stable_hashset, hash_stable_nodemap,\n-                    hash_stable_btreemap, hash_stable_itemlocalmap};\n+pub use self::hcx::{StableHashingContext, NodeIdHashingMode,\n+                    hash_stable_trait_impls};\n mod fingerprint;\n mod caching_codemap_view;\n mod hcx;\n@@ -23,6 +22,7 @@ mod impls_const_math;\n mod impls_cstore;\n mod impls_hir;\n mod impls_mir;\n+mod impls_misc;\n mod impls_ty;\n mod impls_syntax;\n "}, {"sha": "6c57130a9955f62197651ca4277b1117e93cd821", "filename": "src/librustc/infer/error_reporting/different_lifetimes.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fdifferent_lifetimes.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -245,10 +245,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     // region at the right depth with the same index\n                     (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n                         debug!(\"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n-                                        def_id={:?}\",\n-                               self.infcx.tcx.hir.local_def_id(id),\n-                               def_id);\n-                        if self.infcx.tcx.hir.local_def_id(id) == def_id {\n+                                        def_id={:?}\", id, def_id);\n+                        if id == def_id {\n                             self.found_type = Some(arg);\n                             return; // we can stop visiting now\n                         }\n@@ -260,11 +258,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindNestedTypeVisitor<'a, 'gcx, 'tcx> {\n                     (Some(rl::Region::LateBound(debruijn_index, id)), ty::BrNamed(def_id, _)) => {\n                         debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n                                debruijn_index.depth);\n-                        debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\",\n-                               self.infcx.tcx.hir.local_def_id(id));\n+                        debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\", id);\n                         debug!(\"def_id={:?}\", def_id);\n-                        if debruijn_index.depth == self.depth &&\n-                           self.infcx.tcx.hir.local_def_id(id) == def_id {\n+                        if debruijn_index.depth == self.depth && id == def_id {\n                             self.found_type = Some(arg);\n                             return; // we can stop visiting now\n                         }\n@@ -336,10 +332,8 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n \n             (Some(rl::Region::EarlyBound(_, id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"EarlyBound self.infcx.tcx.hir.local_def_id(id)={:?} \\\n-                                        def_id={:?}\",\n-                       self.infcx.tcx.hir.local_def_id(id),\n-                       def_id);\n-                if self.infcx.tcx.hir.local_def_id(id) == def_id {\n+                                        def_id={:?}\", id, def_id);\n+                if id == def_id {\n                     self.found_it = true;\n                     return; // we can stop visiting now\n                 }\n@@ -348,11 +342,9 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for TyPathVisitor<'a, 'gcx, 'tcx> {\n             (Some(rl::Region::LateBound(debruijn_index, id)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\",\n                        debruijn_index.depth);\n-                debug!(\"self.infcx.tcx.hir.local_def_id(id)={:?}\",\n-                       self.infcx.tcx.hir.local_def_id(id));\n+                debug!(\"id={:?}\", id);\n                 debug!(\"def_id={:?}\", def_id);\n-                if debruijn_index.depth == self.depth &&\n-                   self.infcx.tcx.hir.local_def_id(id) == def_id {\n+                if debruijn_index.depth == self.depth && id == def_id {\n                     self.found_it = true;\n                     return; // we can stop visiting now\n                 }"}, {"sha": "21dfd3267df5125910694b6b5472e66b4baa1580", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -12,9 +12,12 @@ use std::cmp;\n \n use errors::DiagnosticBuilder;\n use hir::HirId;\n+use ich::StableHashingContext;\n use lint::builtin;\n use lint::context::CheckLintNameResult;\n use lint::{self, Lint, LintId, Level, LintSource};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n+                                           StableHasher, StableHasherResult};\n use session::Session;\n use syntax::ast;\n use syntax::attr;\n@@ -382,3 +385,62 @@ impl LintLevelMap {\n         })\n     }\n }\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for LintLevelMap {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let LintLevelMap {\n+            ref sets,\n+            ref id_to_set,\n+        } = *self;\n+\n+        id_to_set.hash_stable(hcx, hasher);\n+\n+        let LintLevelSets {\n+            ref list,\n+            lint_cap,\n+        } = *sets;\n+\n+        lint_cap.hash_stable(hcx, hasher);\n+\n+        hcx.while_hashing_spans(true, |hcx| {\n+            list.len().hash_stable(hcx, hasher);\n+\n+            // We are working under the assumption here that the list of\n+            // lint-sets is built in a deterministic order.\n+            for lint_set in list {\n+                ::std::mem::discriminant(lint_set).hash_stable(hcx, hasher);\n+\n+                match *lint_set {\n+                    LintSet::CommandLine { ref specs } => {\n+                        specs.hash_stable(hcx, hasher);\n+                    }\n+                    LintSet::Node { ref specs, parent } => {\n+                        specs.hash_stable(hcx, hasher);\n+                        parent.hash_stable(hcx, hasher);\n+                    }\n+                }\n+            }\n+        })\n+    }\n+}\n+\n+impl<HCX> HashStable<HCX> for LintId {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut HCX,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.lint_name_raw().hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<HCX> ToStableHashKey<HCX> for LintId {\n+    type KeyType = &'static str;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, _: &HCX) -> &'static str {\n+        self.lint_name_raw()\n+    }\n+}"}, {"sha": "42b5e2dd83de598151b4664026abda4a39f88abb", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -305,6 +305,10 @@ impl LintId {\n         }\n     }\n \n+    pub fn lint_name_raw(&self) -> &'static str {\n+        self.lint.name\n+    }\n+\n     /// Get the name of the lint.\n     pub fn to_string(&self) -> String {\n         self.lint.name_lower()\n@@ -317,6 +321,13 @@ pub enum Level {\n     Allow, Warn, Deny, Forbid\n }\n \n+impl_stable_hash_for!(enum self::Level {\n+    Allow,\n+    Warn,\n+    Deny,\n+    Forbid\n+});\n+\n impl Level {\n     /// Convert a level to a lower-case string.\n     pub fn as_str(self) -> &'static str {\n@@ -354,6 +365,12 @@ pub enum LintSource {\n     CommandLine(Symbol),\n }\n \n+impl_stable_hash_for!(enum self::LintSource {\n+    Default,\n+    Node(name, span),\n+    CommandLine(text)\n+});\n+\n pub type LevelSource = (Level, LintSource);\n \n pub mod builtin;"}, {"sha": "f0285d6a937824b2487dee5b0c70d7ab1902f111", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -73,10 +73,10 @@ macro_rules! __impl_stable_hash_field {\n #[macro_export]\n macro_rules! impl_stable_hash_for {\n     (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* }) => {\n-        impl<'a, 'tcx, 'lcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx, 'lcx>> for $enum_name {\n+        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx, 'lcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 use $enum_name::*;\n                 ::std::mem::discriminant(self).hash_stable(__ctx, __hasher);\n@@ -92,10 +92,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'a, 'tcx, 'lcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx, 'lcx>> for $struct_name {\n+        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx, 'lcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name {\n                     $(ref $field),*\n@@ -106,10 +106,10 @@ macro_rules! impl_stable_hash_for {\n         }\n     };\n     (tuple_struct $struct_name:path { $($field:ident),* }) => {\n-        impl<'a, 'tcx, 'lcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a, 'tcx, 'lcx>> for $struct_name {\n+        impl<'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'tcx>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n-                                                  __ctx: &mut $crate::ich::StableHashingContext<'a, 'tcx, 'lcx>,\n+                                                  __ctx: &mut $crate::ich::StableHashingContext<'tcx>,\n                                                   __hasher: &mut ::rustc_data_structures::stable_hasher::StableHasher<W>) {\n                 let $struct_name (\n                     $(ref $field),*\n@@ -125,11 +125,11 @@ macro_rules! impl_stable_hash_for {\n macro_rules! impl_stable_hash_for_spanned {\n     ($T:path) => (\n \n-        impl<'a, 'tcx, 'lcx> HashStable<StableHashingContext<'a, 'tcx, 'lcx>> for ::syntax::codemap::Spanned<$T>\n+        impl<'tcx> HashStable<StableHashingContext<'tcx>> for ::syntax::codemap::Spanned<$T>\n         {\n             #[inline]\n             fn hash_stable<W: StableHasherResult>(&self,\n-                                                  hcx: &mut StableHashingContext<'a, 'tcx, 'lcx>,\n+                                                  hcx: &mut StableHashingContext<'tcx>,\n                                                   hasher: &mut StableHasher<W>) {\n                 self.node.hash_stable(hcx, hasher);\n                 self.span.hash_stable(hcx, hasher);"}, {"sha": "de647913f0f3baca3c67f67a70989ba907123466", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -22,6 +22,7 @@\n //! are *mostly* used as a part of that interface, but these should\n //! probably get a better home if someone can find one.\n \n+use hir;\n use hir::def;\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as hir_map;\n@@ -34,6 +35,7 @@ use session::search_paths::PathKind;\n use util::nodemap::NodeSet;\n \n use std::any::Any;\n+use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use owning_ref::ErasedBoxRef;\n@@ -132,7 +134,7 @@ pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n     pub name: Symbol,\n     pub cfg: Option<ast::MetaItem>,\n-    pub foreign_items: Vec<DefIndex>,\n+    pub foreign_items: Vec<DefId>,\n }\n \n pub enum LoadedMacro {\n@@ -218,6 +220,26 @@ pub trait MetadataLoader {\n                           -> Result<ErasedBoxRef<[u8]>, String>;\n }\n \n+#[derive(Clone)]\n+pub struct ExternConstBody<'tcx> {\n+    pub body: &'tcx hir::Body,\n+\n+    // It would require a lot of infrastructure to enable stable-hashing Bodies\n+    // from other crates, so we hash on export and just store the fingerprint\n+    // with them.\n+    pub fingerprint: ich::Fingerprint,\n+}\n+\n+#[derive(Clone)]\n+pub struct ExternBodyNestedBodies {\n+    pub nested_bodies: Rc<BTreeMap<hir::BodyId, hir::Body>>,\n+\n+    // It would require a lot of infrastructure to enable stable-hashing Bodies\n+    // from other crates, so we hash on export and just store the fingerprint\n+    // with them.\n+    pub fingerprint: ich::Fingerprint,\n+}\n+\n /// A store of Rust crates, through with their metadata\n /// can be accessed.\n ///"}, {"sha": "d650dbe88b5c89a736198613ecd3d4dd5c201077", "filename": "src/librustc/middle/exported_symbols.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexported_symbols.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -19,6 +19,11 @@ pub enum SymbolExportLevel {\n     Rust,\n }\n \n+impl_stable_hash_for!(enum self::SymbolExportLevel {\n+    C,\n+    Rust\n+});\n+\n impl SymbolExportLevel {\n     pub fn is_below_threshold(self, threshold: SymbolExportLevel) -> bool {\n         if threshold == SymbolExportLevel::Rust {"}, {"sha": "0c0b9697338e92f0feb66d77c177f7d3ee6248b3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -192,8 +192,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {\n     let mut collector = LanguageItemCollector::new(tcx);\n     for &cnum in tcx.crates().iter() {\n-        for &(index, item_index) in tcx.defined_lang_items(cnum).iter() {\n-            let def_id = DefId { krate: cnum, index: index };\n+        for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n             collector.collect_item(item_index, def_id);\n         }\n     }"}, {"sha": "fa29dda86ddd04dbdf0a0385ea5e917664ef142f", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -369,7 +369,13 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n     }\n }\n \n-fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> Rc<NodeSet> {\n+// We introduce a new-type here, so we can have a specialized HashStable\n+// implementation for it.\n+#[derive(Clone)]\n+pub struct ReachableSet(pub Rc<NodeSet>);\n+\n+\n+fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) -> ReachableSet {\n     debug_assert!(crate_num == LOCAL_CRATE);\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n@@ -414,7 +420,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     reachable_context.propagate();\n \n     // Return the set of reachable symbols.\n-    Rc::new(reachable_context.reachable_symbols)\n+    ReachableSet(Rc::new(reachable_context.reachable_symbols))\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "5b286c6593b7adfc09400161fba186eeaa85e002", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -14,6 +14,7 @@\n //! Most of the documentation on regions can be found in\n //! `middle/infer/region_inference/README.md`\n \n+use ich::{StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n@@ -31,6 +32,8 @@ use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use mir::transform::MirSource;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n \n /// Scope represents a statically-describable scope that can be\n /// used to bound the lifetime/region for values.\n@@ -1235,3 +1238,32 @@ pub fn provide(providers: &mut Providers) {\n         ..*providers\n     };\n }\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ScopeTree {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ScopeTree {\n+            root_body,\n+            root_parent,\n+            ref parent_map,\n+            ref var_map,\n+            ref destruction_scopes,\n+            ref rvalue_scopes,\n+            ref closure_tree,\n+            ref yield_in_scope,\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            root_body.hash_stable(hcx, hasher);\n+            root_parent.hash_stable(hcx, hasher);\n+        });\n+\n+        parent_map.hash_stable(hcx, hasher);\n+        var_map.hash_stable(hcx, hasher);\n+        destruction_scopes.hash_stable(hcx, hasher);\n+        rvalue_scopes.hash_stable(hcx, hasher);\n+        closure_tree.hash_stable(hcx, hasher);\n+        yield_in_scope.hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "2d201e5935ec7c7ba8c8db2774fc1189dc0be855", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -39,22 +39,24 @@ use hir::intravisit::{self, Visitor, NestedVisitorMap};\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum Region {\n     Static,\n-    EarlyBound(/* index */ u32, /* lifetime decl */ ast::NodeId),\n-    LateBound(ty::DebruijnIndex, /* lifetime decl */ ast::NodeId),\n+    EarlyBound(/* index */ u32, /* lifetime decl */ DefId),\n+    LateBound(ty::DebruijnIndex, /* lifetime decl */ DefId),\n     LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n-    Free(DefId, /* lifetime decl */ ast::NodeId),\n+    Free(DefId, /* lifetime decl */ DefId),\n }\n \n impl Region {\n-    fn early(index: &mut u32, def: &hir::LifetimeDef) -> (ast::Name, Region) {\n+    fn early(hir_map: &Map, index: &mut u32, def: &hir::LifetimeDef) -> (ast::Name, Region) {\n         let i = *index;\n         *index += 1;\n-        (def.lifetime.name, Region::EarlyBound(i, def.lifetime.id))\n+        let def_id = hir_map.local_def_id(def.lifetime.id);\n+        (def.lifetime.name, Region::EarlyBound(i, def_id))\n     }\n \n-    fn late(def: &hir::LifetimeDef) -> (ast::Name, Region) {\n+    fn late(hir_map: &Map, def: &hir::LifetimeDef) -> (ast::Name, Region) {\n         let depth = ty::DebruijnIndex::new(1);\n-        (def.lifetime.name, Region::LateBound(depth, def.lifetime.id))\n+        let def_id = hir_map.local_def_id(def.lifetime.id);\n+        (def.lifetime.name, Region::LateBound(depth, def_id))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -64,7 +66,7 @@ impl Region {\n         Region::LateBoundAnon(depth, i)\n     }\n \n-    fn id(&self) -> Option<ast::NodeId> {\n+    fn id(&self) -> Option<DefId> {\n         match *self {\n             Region::Static |\n             Region::LateBoundAnon(..) => None,\n@@ -337,7 +339,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     0\n                 };\n                 let lifetimes = generics.lifetimes.iter().map(|def| {\n-                    Region::early(&mut index, def)\n+                    Region::early(self.hir_map, &mut index, def)\n                 }).collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n@@ -368,7 +370,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n                 let scope = Scope::Binder {\n-                    lifetimes: c.lifetimes.iter().map(Region::late).collect(),\n+                    lifetimes: c.lifetimes.iter().map(|def| {\n+                            Region::late(self.hir_map, def)\n+                        }).collect(),\n                     s: self.scope\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -467,7 +471,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     if !bound_lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n                         let scope = Scope::Binder {\n-                            lifetimes: bound_lifetimes.iter().map(Region::late).collect(),\n+                            lifetimes: bound_lifetimes.iter().map(|def| {\n+                                    Region::late(self.hir_map, def)\n+                                }).collect(),\n                             s: self.scope\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n@@ -512,7 +518,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                           \"nested quantification of lifetimes\");\n             }\n             let scope = Scope::Binder {\n-                lifetimes: trait_ref.bound_lifetimes.iter().map(Region::late).collect(),\n+                lifetimes: trait_ref.bound_lifetimes.iter().map(|def| {\n+                        Region::late(self.hir_map, def)\n+                    }).collect(),\n                 s: self.scope\n             };\n             self.with(scope, |old_scope, this| {\n@@ -647,10 +655,13 @@ fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n                 Scope::Binder { ref lifetimes, s } => {\n                     // FIXME (#24278): non-hygienic comparison\n                     if let Some(def) = lifetimes.get(&label) {\n+                        let node_id = hir_map.as_local_node_id(def.id().unwrap())\n+                                             .unwrap();\n+\n                         signal_shadowing_problem(\n                             sess,\n                             label,\n-                            original_lifetime(hir_map.span(def.id().unwrap())),\n+                            original_lifetime(hir_map.span(node_id)),\n                             shadower_label(label_span));\n                         return;\n                     }\n@@ -749,7 +760,8 @@ fn object_lifetime_defaults_for_item(hir_map: &Map, generics: &hir::Generics)\n                     generics.lifetimes.iter().enumerate().find(|&(_, def)| {\n                         def.lifetime.name == name\n                     }).map_or(Set1::Many, |(i, def)| {\n-                        Set1::One(Region::EarlyBound(i as u32, def.lifetime.id))\n+                        let def_id = hir_map.local_def_id(def.lifetime.id);\n+                        Set1::One(Region::EarlyBound(i as u32, def_id))\n                     })\n                 }\n             }\n@@ -835,9 +847,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let lifetimes = generics.lifetimes.iter().map(|def| {\n             if self.map.late_bound.contains(&def.lifetime.id) {\n-                Region::late(def)\n+                Region::late(self.hir_map, def)\n             } else {\n-                Region::early(&mut index, def)\n+                Region::early(self.hir_map, &mut index, def)\n             }\n         }).collect();\n \n@@ -1483,10 +1495,14 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Binder { ref lifetimes, s } => {\n                     if let Some(&def) = lifetimes.get(&lifetime.name) {\n+                        let node_id = self.hir_map\n+                                          .as_local_node_id(def.id().unwrap())\n+                                          .unwrap();\n+\n                         signal_shadowing_problem(\n                             self.sess,\n                             lifetime.name,\n-                            original_lifetime(self.hir_map.span(def.id().unwrap())),\n+                            original_lifetime(self.hir_map.span(node_id)),\n                             shadower_lifetime(&lifetime));\n                         return;\n                     }"}, {"sha": "89049958309a126a61a033afde7f6b71587e7d9e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -65,6 +65,11 @@ pub struct DeprecationEntry {\n     origin: Option<HirId>,\n }\n \n+impl_stable_hash_for!(struct self::DeprecationEntry {\n+    attr,\n+    origin\n+});\n+\n impl DeprecationEntry {\n     fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n         DeprecationEntry {\n@@ -102,6 +107,13 @@ pub struct Index<'tcx> {\n     active_features: FxHashSet<Symbol>,\n }\n \n+impl_stable_hash_for!(struct self::Index<'tcx> {\n+    stab_map,\n+    depr_map,\n+    staged_api,\n+    active_features\n+});\n+\n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "7744c9c3d1238aac16c558eb0a9297f501d424e3", "filename": "src/librustc/middle/trans.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -12,6 +12,9 @@ use syntax::ast::NodeId;\n use syntax::symbol::InternedString;\n use ty::Instance;\n use util::nodemap::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n+                                           StableHasher};\n+use ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n pub enum TransItem<'tcx> {\n@@ -20,6 +23,26 @@ pub enum TransItem<'tcx> {\n     GlobalAsm(NodeId),\n }\n \n+impl<'tcx> HashStable<StableHashingContext<'tcx>> for TransItem<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                           hcx: &mut StableHashingContext<'tcx>,\n+                                           hasher: &mut StableHasher<W>) {\n+        ::std::mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            TransItem::Fn(ref instance) => {\n+                instance.hash_stable(hcx, hasher);\n+            }\n+            TransItem::Static(node_id)    |\n+            TransItem::GlobalAsm(node_id) => {\n+                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+                    node_id.hash_stable(hcx, hasher);\n+                })\n+            }\n+        }\n+    }\n+}\n+\n pub struct CodegenUnit<'tcx> {\n     /// A name for this CGU. Incremental compilation requires that\n     /// name be unique amongst **all** crates.  Therefore, it should\n@@ -44,13 +67,33 @@ pub enum Linkage {\n     Common,\n }\n \n+impl_stable_hash_for!(enum self::Linkage {\n+    External,\n+    AvailableExternally,\n+    LinkOnceAny,\n+    LinkOnceODR,\n+    WeakAny,\n+    WeakODR,\n+    Appending,\n+    Internal,\n+    Private,\n+    ExternalWeak,\n+    Common\n+});\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Visibility {\n     Default,\n     Hidden,\n     Protected,\n }\n \n+impl_stable_hash_for!(enum self::Visibility {\n+    Default,\n+    Hidden,\n+    Protected\n+});\n+\n impl<'tcx> CodegenUnit<'tcx> {\n     pub fn new(name: InternedString) -> CodegenUnit<'tcx> {\n         CodegenUnit {\n@@ -78,6 +121,29 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n }\n \n+impl<'tcx> HashStable<StableHashingContext<'tcx>> for CodegenUnit<'tcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                           hcx: &mut StableHashingContext<'tcx>,\n+                                           hasher: &mut StableHasher<W>) {\n+        let CodegenUnit {\n+            ref items,\n+            name,\n+        } = *self;\n+\n+        name.hash_stable(hcx, hasher);\n+\n+        let mut items: Vec<(Fingerprint, _)> = items.iter().map(|(trans_item, &attrs)| {\n+            let mut hasher = StableHasher::new();\n+            trans_item.hash_stable(hcx, &mut hasher);\n+            let trans_item_fingerprint = hasher.finish();\n+            (trans_item_fingerprint, attrs)\n+        }).collect();\n+\n+        items.sort_unstable_by_key(|i| i.0);\n+        items.hash_stable(hcx, hasher);\n+    }\n+}\n+\n #[derive(Clone, Default)]\n pub struct Stats {\n     pub n_glues_created: usize,\n@@ -92,6 +158,18 @@ pub struct Stats {\n     pub fn_stats: Vec<(String, usize)>,\n }\n \n+impl_stable_hash_for!(struct self::Stats {\n+    n_glues_created,\n+    n_null_glues,\n+    n_real_glues,\n+    n_fns,\n+    n_inlines,\n+    n_closures,\n+    n_llvm_insns,\n+    llvm_insns,\n+    fn_stats\n+});\n+\n impl Stats {\n     pub fn extend(&mut self, stats: Stats) {\n         self.n_glues_created += stats.n_glues_created;\n@@ -108,3 +186,4 @@ impl Stats {\n         self.fn_stats.extend(stats.fn_stats);\n     }\n }\n+"}, {"sha": "efc2f647cfdf532827cdcf08419f440e9493096a", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -35,9 +35,9 @@ impl serialize::Decodable for Cache {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Cache {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Cache {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          _: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          _: &mut StableHashingContext<'gcx>,\n                                           _: &mut StableHasher<W>) {\n         // do nothing\n     }"}, {"sha": "e1107a9b97fce337b9b8120a30cf78b52b3c67c6", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 36, "deletions": 3, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -19,8 +19,10 @@ pub use self::DebugInfoLevel::*;\n use session::{early_error, early_warn, Session};\n use session::search_paths::SearchPaths;\n \n+use ich::StableHashingContext;\n use rustc_back::{LinkerFlavor, PanicStrategy, RelroLevel};\n use rustc_back::target::Target;\n+use rustc_data_structures::stable_hasher::ToStableHashKey;\n use lint;\n use middle::cstore;\n \n@@ -90,6 +92,25 @@ pub enum OutputType {\n     DepInfo,\n }\n \n+impl_stable_hash_for!(enum self::OutputType {\n+    Bitcode,\n+    Assembly,\n+    LlvmAssembly,\n+    Mir,\n+    Metadata,\n+    Object,\n+    Exe,\n+    DepInfo\n+});\n+\n+impl<'tcx> ToStableHashKey<StableHashingContext<'tcx>> for OutputType {\n+    type KeyType = OutputType;\n+    #[inline]\n+    fn to_stable_hash_key(&self, _: &StableHashingContext<'tcx>) -> Self::KeyType {\n+        *self\n+    }\n+}\n+\n impl OutputType {\n     fn is_compatible_with_codegen_units_and_single_output_file(&self) -> bool {\n         match *self {\n@@ -149,6 +170,10 @@ impl Default for ErrorOutputType {\n #[derive(Clone, Hash)]\n pub struct OutputTypes(BTreeMap<OutputType, Option<PathBuf>>);\n \n+impl_stable_hash_for!(tuple_struct self::OutputTypes {\n+    map\n+});\n+\n impl OutputTypes {\n     pub fn new(entries: &[(OutputType, Option<PathBuf>)]) -> OutputTypes {\n         OutputTypes(BTreeMap::from_iter(entries.iter()\n@@ -373,6 +398,14 @@ pub struct OutputFilenames {\n     pub outputs: OutputTypes,\n }\n \n+impl_stable_hash_for!(struct self::OutputFilenames {\n+    out_directory,\n+    out_filestem,\n+    single_output_file,\n+    extra,\n+    outputs\n+});\n+\n /// Codegen unit names generated by the numbered naming scheme will contain this\n /// marker right before the index of the codegen unit.\n pub const NUMBERED_CODEGEN_UNIT_MARKER: &'static str = \".cgu-\";\n@@ -905,7 +938,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n     debug_assertions: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"explicitly enable the cfg(debug_assertions) directive\"),\n     inline_threshold: Option<usize> = (None, parse_opt_uint, [TRACKED],\n-        \"set the inlining threshold for\"),\n+        \"set the threshold for inlining a function (default: 225)\"),\n     panic: Option<PanicStrategy> = (None, parse_panic_strategy,\n         [TRACKED], \"panic strategy to compile crate with\"),\n }\n@@ -1052,9 +1085,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     linker_flavor: Option<LinkerFlavor> = (None, parse_linker_flavor, [UNTRACKED],\n                                            \"Linker flavor\"),\n     fuel: Option<(String, u64)> = (None, parse_optimization_fuel, [TRACKED],\n-        \"Set the optimization fuel quota for a crate.\"),\n+        \"set the optimization fuel quota for a crate\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n-        \"Make Rustc print the total optimization fuel used by a crate.\"),\n+        \"make Rustc print the total optimization fuel used by a crate\"),\n     remap_path_prefix_from: Vec<String> = (vec![], parse_string_push, [TRACKED],\n         \"add a source pattern to the file path remapping config\"),\n     remap_path_prefix_to: Vec<String> = (vec![], parse_string_push, [TRACKED],"}, {"sha": "0651d1904bf06697f0a6ba0fe26c912880552989", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -11,6 +11,9 @@\n use super::OverlapError;\n \n use hir::def_id::DefId;\n+use ich::{self, StableHashingContext};\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n@@ -365,3 +368,21 @@ pub fn ancestors(tcx: TyCtxt,\n         current_source: Some(Node::Impl(start_from_impl)),\n     }\n }\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Children {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let Children {\n+            ref nonblanket_impls,\n+            ref blanket_impls,\n+        } = *self;\n+\n+        ich::hash_stable_trait_impls(hcx, hasher, blanket_impls, nonblanket_impls);\n+    }\n+}\n+\n+impl_stable_hash_for!(struct self::Graph {\n+    parent,\n+    children\n+});"}, {"sha": "8005714433f5ef9d0e3eb9e30a2cda1db0e01562", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -21,7 +21,7 @@ use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n-use ich::{self, StableHashingContext, NodeIdHashingMode};\n+use ich::{StableHashingContext, NodeIdHashingMode};\n use middle::const_val::ConstVal;\n use middle::cstore::{CrateStore, LinkMeta, EncodedMetadataHashes};\n use middle::cstore::EncodedMetadata;\n@@ -49,8 +49,8 @@ use ty::BindingMode;\n use util::nodemap::{NodeMap, NodeSet, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n+                                           StableHasher, StableHasherResult};\n \n use arena::{TypedArena, DroplessArena};\n use rustc_const_math::{ConstInt, ConstUsize};\n@@ -687,9 +687,9 @@ impl<'tcx> TypeckTables<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TypeckTables<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TypeckTables {\n             local_id_root,\n@@ -714,12 +714,12 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Typeck\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            ich::hash_stable_itemlocalmap(hcx, hasher, type_dependent_defs);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, node_types);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, node_substs);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, adjustments);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, pat_binding_modes);\n-            ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n+            type_dependent_defs.hash_stable(hcx, hasher);\n+            node_types.hash_stable(hcx, hasher);\n+            node_substs.hash_stable(hcx, hasher);\n+            adjustments.hash_stable(hcx, hasher);\n+            pat_binding_modes.hash_stable(hcx, hasher);\n+            hash_stable_hashmap(hcx, hasher, upvar_capture_map, |up_var_id, hcx| {\n                 let ty::UpvarId {\n                     var_id,\n                     closure_expr_id\n@@ -736,22 +736,19 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Typeck\n                     krate: local_id_root.krate,\n                     index: closure_expr_id,\n                 };\n-                ((hcx.def_path_hash(var_owner_def_id), var_id.local_id),\n+                (hcx.def_path_hash(var_owner_def_id),\n+                 var_id.local_id,\n                  hcx.def_path_hash(closure_def_id))\n             });\n \n-            ich::hash_stable_itemlocalmap(hcx, hasher, closure_tys);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, closure_kinds);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, liberated_fn_sigs);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, fru_field_types);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, cast_kinds);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, generator_sigs);\n-            ich::hash_stable_itemlocalmap(hcx, hasher, generator_interiors);\n-\n-            ich::hash_stable_hashset(hcx, hasher, used_trait_imports, |hcx, def_id| {\n-                hcx.def_path_hash(*def_id)\n-            });\n-\n+            closure_tys.hash_stable(hcx, hasher);\n+            closure_kinds.hash_stable(hcx, hasher);\n+            liberated_fn_sigs.hash_stable(hcx, hasher);\n+            fru_field_types.hash_stable(hcx, hasher);\n+            cast_kinds.hash_stable(hcx, hasher);\n+            generator_sigs.hash_stable(hcx, hasher);\n+            generator_interiors.hash_stable(hcx, hasher);\n+            used_trait_imports.hash_stable(hcx, hasher);\n             tainted_by_errors.hash_stable(hcx, hasher);\n             free_region_map.hash_stable(hcx, hasher);\n         })\n@@ -1083,6 +1080,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n+        // FIXME(mw): Each of the Vecs in the trait_map should be brought into\n+        // a deterministic order here. Otherwise we might end up with\n+        // unnecessarily unstable incr. comp. hashes.\n         let mut trait_map = FxHashMap();\n         for (k, v) in resolutions.trait_map {\n             let hir_id = hir.node_to_hir_id(k);\n@@ -1171,17 +1171,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn lang_items(self) -> Rc<middle::lang_items::LanguageItems> {\n-        // FIXME(#42293) Right now we insert a `with_ignore` node in the dep\n-        // graph here to ignore the fact that `get_lang_items` below depends on\n-        // the entire crate.  For now this'll prevent false positives of\n-        // recompiling too much when anything changes.\n-        //\n-        // Once red/green incremental compilation lands we should be able to\n-        // remove this because while the crate changes often the lint level map\n-        // will change rarely.\n-        self.dep_graph.with_ignore(|| {\n-            self.get_lang_items(LOCAL_CRATE)\n-        })\n+        self.get_lang_items(LOCAL_CRATE)\n     }\n \n     pub fn stability(self) -> Rc<stability::Index<'tcx>> {\n@@ -1235,6 +1225,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Rc<Any> {\n         self.cstore.crate_data_as_rc_any(cnum)\n     }\n+\n+    pub fn create_stable_hashing_context(self) -> StableHashingContext<'gcx> {\n+        let krate = self.dep_graph.with_ignore(|| self.gcx.hir.krate());\n+\n+        StableHashingContext::new(self.sess,\n+                                  krate,\n+                                  self.hir.definitions(),\n+                                  self.cstore)\n+    }\n }\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n@@ -2198,7 +2197,15 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     };\n     providers.get_lang_items = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n-        Rc::new(middle::lang_items::collect(tcx))\n+        // FIXME(#42293) Right now we insert a `with_ignore` node in the dep\n+        // graph here to ignore the fact that `get_lang_items` below depends on\n+        // the entire crate.  For now this'll prevent false positives of\n+        // recompiling too much when anything changes.\n+        //\n+        // Once red/green incremental compilation lands we should be able to\n+        // remove this because while the crate changes often the lint level map\n+        // will change rarely.\n+        tcx.dep_graph.with_ignore(|| Rc::new(middle::lang_items::collect(tcx)))\n     };\n     providers.freevars = |tcx, id| tcx.gcx.freevars.get(&id).cloned();\n     providers.maybe_unused_trait_import = |tcx, id| {"}, {"sha": "490bfe78a9a1f4e816cf6a805566a6a90cf70d63", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 84, "deletions": 10, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -9,29 +9,44 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n-use ty::{self, Ty, TyCtxt};\n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult,\n+                                           HashStable};\n+use std::fmt::Debug;\n+use std::hash::Hash;\n+use std::mem;\n use syntax::ast;\n+use ty::{self, Ty, TyCtxt};\n \n-use self::SimplifiedType::*;\n+use self::SimplifiedTypeGen::*;\n \n-/// See `simplify_type\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum SimplifiedType {\n+pub type SimplifiedType = SimplifiedTypeGen<DefId>;\n+\n+/// See `simplify_type`\n+///\n+/// Note that we keep this type generic over the type of identifier it uses\n+/// because we sometimes need to use SimplifiedTypeGen values as stable sorting\n+/// keys (in which case we use a DefPathHash as id-type) but in the general case\n+/// the non-stable but fast to construct DefId-version is the better choice.\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub enum SimplifiedTypeGen<D>\n+    where D: Copy + Debug + Ord + Eq + Hash\n+{\n     BoolSimplifiedType,\n     CharSimplifiedType,\n     IntSimplifiedType(ast::IntTy),\n     UintSimplifiedType(ast::UintTy),\n     FloatSimplifiedType(ast::FloatTy),\n-    AdtSimplifiedType(DefId),\n+    AdtSimplifiedType(D),\n     StrSimplifiedType,\n     ArraySimplifiedType,\n     PtrSimplifiedType,\n     NeverSimplifiedType,\n     TupleSimplifiedType(usize),\n-    TraitSimplifiedType(DefId),\n-    ClosureSimplifiedType(DefId),\n-    GeneratorSimplifiedType(DefId),\n-    AnonSimplifiedType(DefId),\n+    TraitSimplifiedType(D),\n+    ClosureSimplifiedType(D),\n+    GeneratorSimplifiedType(D),\n+    AnonSimplifiedType(D),\n     FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n }\n@@ -101,3 +116,62 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyInfer(_) | ty::TyError => None,\n     }\n }\n+\n+impl<D: Copy + Debug + Ord + Eq + Hash> SimplifiedTypeGen<D> {\n+    pub fn map_def<U, F>(self, map: F) -> SimplifiedTypeGen<U>\n+        where F: Fn(D) -> U,\n+              U: Copy + Debug + Ord + Eq + Hash,\n+    {\n+        match self {\n+            BoolSimplifiedType => BoolSimplifiedType,\n+            CharSimplifiedType => CharSimplifiedType,\n+            IntSimplifiedType(t) => IntSimplifiedType(t),\n+            UintSimplifiedType(t) => UintSimplifiedType(t),\n+            FloatSimplifiedType(t) => FloatSimplifiedType(t),\n+            AdtSimplifiedType(d) => AdtSimplifiedType(map(d)),\n+            StrSimplifiedType => StrSimplifiedType,\n+            ArraySimplifiedType => ArraySimplifiedType,\n+            PtrSimplifiedType => PtrSimplifiedType,\n+            NeverSimplifiedType => NeverSimplifiedType,\n+            TupleSimplifiedType(n) => TupleSimplifiedType(n),\n+            TraitSimplifiedType(d) => TraitSimplifiedType(map(d)),\n+            ClosureSimplifiedType(d) => ClosureSimplifiedType(map(d)),\n+            GeneratorSimplifiedType(d) => GeneratorSimplifiedType(map(d)),\n+            AnonSimplifiedType(d) => AnonSimplifiedType(map(d)),\n+            FunctionSimplifiedType(n) => FunctionSimplifiedType(n),\n+            ParameterSimplifiedType => ParameterSimplifiedType,\n+        }\n+    }\n+}\n+\n+impl<'gcx, D> HashStable<StableHashingContext<'gcx>> for SimplifiedTypeGen<D>\n+    where D: Copy + Debug + Ord + Eq + Hash +\n+             HashStable<StableHashingContext<'gcx>>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            BoolSimplifiedType |\n+            CharSimplifiedType |\n+            StrSimplifiedType |\n+            ArraySimplifiedType |\n+            PtrSimplifiedType |\n+            NeverSimplifiedType |\n+            ParameterSimplifiedType => {\n+                // nothing to do\n+            }\n+            IntSimplifiedType(t) => t.hash_stable(hcx, hasher),\n+            UintSimplifiedType(t) => t.hash_stable(hcx, hasher),\n+            FloatSimplifiedType(t) => t.hash_stable(hcx, hasher),\n+            AdtSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            TupleSimplifiedType(n) => n.hash_stable(hcx, hasher),\n+            TraitSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            ClosureSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            GeneratorSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            AnonSimplifiedType(d) => d.hash_stable(hcx, hasher),\n+            FunctionSimplifiedType(n) => n.hash_stable(hcx, hasher),\n+        }\n+    }\n+}"}, {"sha": "1709f9ed2df1c9a8e5d6d773955043703d982855", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -23,8 +23,13 @@ use std::cmp;\n use std::fmt;\n use std::i64;\n use std::iter;\n+use std::mem;\n use std::ops::Deref;\n \n+use ich::StableHashingContext;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n+\n /// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n /// for a target, which contains everything needed to compute layouts.\n pub struct TargetDataLayout {\n@@ -2300,3 +2305,128 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n         cx.layout_of(cx.normalize_projections(self.field_type(cx, i)))\n     }\n }\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use ty::layout::Layout::*;\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            Scalar { value, non_zero } => {\n+                value.hash_stable(hcx, hasher);\n+                non_zero.hash_stable(hcx, hasher);\n+            }\n+            Vector { element, count } => {\n+                element.hash_stable(hcx, hasher);\n+                count.hash_stable(hcx, hasher);\n+            }\n+            Array { sized, align, primitive_align, element_size, count } => {\n+                sized.hash_stable(hcx, hasher);\n+                align.hash_stable(hcx, hasher);\n+                primitive_align.hash_stable(hcx, hasher);\n+                element_size.hash_stable(hcx, hasher);\n+                count.hash_stable(hcx, hasher);\n+            }\n+            FatPointer { ref metadata, non_zero } => {\n+                metadata.hash_stable(hcx, hasher);\n+                non_zero.hash_stable(hcx, hasher);\n+            }\n+            CEnum { discr, signed, non_zero, min, max } => {\n+                discr.hash_stable(hcx, hasher);\n+                signed.hash_stable(hcx, hasher);\n+                non_zero.hash_stable(hcx, hasher);\n+                min.hash_stable(hcx, hasher);\n+                max.hash_stable(hcx, hasher);\n+            }\n+            Univariant { ref variant, non_zero } => {\n+                variant.hash_stable(hcx, hasher);\n+                non_zero.hash_stable(hcx, hasher);\n+            }\n+            UntaggedUnion { ref variants } => {\n+                variants.hash_stable(hcx, hasher);\n+            }\n+            General { discr, ref variants, size, align, primitive_align } => {\n+                discr.hash_stable(hcx, hasher);\n+                variants.hash_stable(hcx, hasher);\n+                size.hash_stable(hcx, hasher);\n+                align.hash_stable(hcx, hasher);\n+                primitive_align.hash_stable(hcx, hasher);\n+            }\n+            RawNullablePointer { nndiscr, ref value } => {\n+                nndiscr.hash_stable(hcx, hasher);\n+                value.hash_stable(hcx, hasher);\n+            }\n+            StructWrappedNullablePointer {\n+                nndiscr,\n+                ref nonnull,\n+                ref discrfield,\n+                ref discrfield_source\n+            } => {\n+                nndiscr.hash_stable(hcx, hasher);\n+                nonnull.hash_stable(hcx, hasher);\n+                discrfield.hash_stable(hcx, hasher);\n+                discrfield_source.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum ::ty::layout::Integer {\n+    I1,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128\n+});\n+\n+impl_stable_hash_for!(enum ::ty::layout::Primitive {\n+    Int(integer),\n+    F32,\n+    F64,\n+    Pointer\n+});\n+\n+impl_stable_hash_for!(struct ::ty::layout::Align {\n+    abi,\n+    pref\n+});\n+\n+impl_stable_hash_for!(struct ::ty::layout::Size {\n+    raw\n+});\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for LayoutError<'gcx>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use ty::layout::LayoutError::*;\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            Unknown(t) |\n+            SizeOverflow(t) => t.hash_stable(hcx, hasher)\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(struct ::ty::layout::Struct {\n+    align,\n+    primitive_align,\n+    packed,\n+    sized,\n+    offsets,\n+    memory_index,\n+    min_size\n+});\n+\n+impl_stable_hash_for!(struct ::ty::layout::Union {\n+    align,\n+    primitive_align,\n+    min_size,\n+    packed\n+});"}, {"sha": "c0045483ced47fbeaa712f6c181f4bd5b645cb4a", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -16,9 +16,11 @@ use hir::{self, TraitCandidate, ItemLocalId};\n use hir::svh::Svh;\n use lint;\n use middle::const_val;\n-use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary};\n-use middle::cstore::{NativeLibraryKind, DepKind, CrateSource};\n+use middle::cstore::{ExternCrate, LinkagePreference, NativeLibrary,\n+                     ExternBodyNestedBodies};\n+use middle::cstore::{NativeLibraryKind, DepKind, CrateSource, ExternConstBody};\n use middle::privacy::AccessLevels;\n+use middle::reachable::ReachableSet;\n use middle::region;\n use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n use middle::stability::{self, DeprecationEntry};\n@@ -36,19 +38,19 @@ use ty::item_path;\n use ty::steal::Steal;\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n-use util::nodemap::{DefIdSet, NodeSet, DefIdMap};\n+use util::nodemap::{DefIdSet, DefIdMap};\n use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::cell::{RefCell, RefMut, Cell};\n+\n use std::fmt::Debug;\n use std::hash::Hash;\n use std::marker::PhantomData;\n use std::mem;\n-use std::collections::BTreeMap;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -925,9 +927,8 @@ macro_rules! define_maps {\n                     span = key.default_span(tcx)\n                 }\n \n+                let dep_node = Self::to_dep_node(tcx, &key);\n                 let res = tcx.cycle_check(span, Query::$name(key), || {\n-                    let dep_node = Self::to_dep_node(tcx, &key);\n-\n                     tcx.sess.diagnostic().track_diagnostics(|| {\n                         if dep_node.kind.is_anon() {\n                             tcx.dep_graph.with_anon_task(dep_node.kind, || {\n@@ -1300,7 +1301,7 @@ define_maps! { <'tcx>\n     /// Performs the privacy check and computes \"access levels\".\n     [] fn privacy_access_levels: PrivacyAccessLevels(CrateNum) -> Rc<AccessLevels>,\n \n-    [] fn reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n+    [] fn reachable_set: reachability_dep_node(CrateNum) -> ReachableSet,\n \n     /// Per-body `region::ScopeTree`. The `DefId` should be the owner-def-id for the body;\n     /// in the case of closures, this will be redirected to the enclosing function.\n@@ -1320,8 +1321,7 @@ define_maps! { <'tcx>\n     [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n     [] fn trait_of_item: TraitOfItem(DefId) -> Option<DefId>,\n     [] fn is_exported_symbol: IsExportedSymbol(DefId) -> bool,\n-    [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId)\n-        -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n+    [] fn item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> ExternBodyNestedBodies,\n     [] fn const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] fn is_mir_available: IsMirAvailable(DefId) -> bool,\n \n@@ -1399,9 +1399,9 @@ define_maps! { <'tcx>\n     [] fn extern_mod_stmt_cnum: ExternModStmtCnum(DefId) -> Option<CrateNum>,\n \n     [] fn get_lang_items: get_lang_items_node(CrateNum) -> Rc<LanguageItems>,\n-    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefIndex, usize)>>,\n+    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefId, usize)>>,\n     [] fn missing_lang_items: MissingLangItems(CrateNum) -> Rc<Vec<LangItem>>,\n-    [] fn extern_const_body: ExternConstBody(DefId) -> &'tcx hir::Body,\n+    [] fn extern_const_body: ExternConstBody(DefId) -> ExternConstBody<'tcx>,\n     [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n         -> Rc<DefIdMap<DefId>>,\n     [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n@@ -1417,7 +1417,7 @@ define_maps! { <'tcx>\n     [] fn all_crate_nums: all_crate_nums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n \n     [] fn exported_symbols: ExportedSymbols(CrateNum)\n-        -> Arc<Vec<(String, DefId, SymbolExportLevel)>>,\n+        -> Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n     [] fn collect_and_partition_translation_items:\n         collect_and_partition_translation_items_node(CrateNum)\n         -> (Arc<DefIdSet>, Arc<Vec<Arc<CodegenUnit<'tcx>>>>),"}, {"sha": "2c1b3e28ffb00e9d768c4697f0b0393690c62192", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -500,9 +500,9 @@ impl<'tcx> TyS<'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ty::TyS<'gcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for ty::TyS<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::TyS {\n             ref sty,\n@@ -1334,9 +1334,9 @@ impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for AdtDef {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for AdtDef {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let ty::AdtDef {\n             did,\n@@ -2575,6 +2575,10 @@ pub struct SymbolName {\n     pub name: InternedString\n }\n \n+impl_stable_hash_for!(struct self::SymbolName {\n+    name\n+});\n+\n impl Deref for SymbolName {\n     type Target = str;\n "}, {"sha": "e0b05c2ba39ac7ad3dab4283363db1061bbdcb18", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -11,13 +11,15 @@\n use hir;\n use hir::def_id::DefId;\n use hir::map::DefPathHash;\n+use ich::{self, StableHashingContext};\n use traits::specialization_graph;\n use ty::fast_reject;\n use ty::fold::TypeFoldable;\n use ty::{Ty, TyCtxt};\n \n use rustc_data_structures::fx::FxHashMap;\n-\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n use std::rc::Rc;\n \n /// A trait's definition with type information.\n@@ -183,3 +185,16 @@ pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         non_blanket_impls: non_blanket_impls,\n     })\n }\n+\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for TraitImpls {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let TraitImpls {\n+            ref blanket_impls,\n+            ref non_blanket_impls,\n+        } = *self;\n+\n+        ich::hash_stable_trait_impls(hcx, hasher, blanket_impls, non_blanket_impls);\n+    }\n+}"}, {"sha": "27819f551b9b3f47cabcd6fb319eb82395cf8aff", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -12,7 +12,7 @@\n \n use hir::def_id::{DefId, LOCAL_CRATE};\n use hir::map::DefPathData;\n-use ich::{StableHashingContext, NodeIdHashingMode};\n+use ich::NodeIdHashingMode;\n use middle::const_val::ConstVal;\n use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n@@ -214,7 +214,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// context it's calculated within. This is used by the `type_id` intrinsic.\n     pub fn type_id_hash(self, ty: Ty<'tcx>) -> u64 {\n         let mut hasher = StableHasher::new();\n-        let mut hcx = StableHashingContext::new(self);\n+        let mut hcx = self.create_stable_hashing_context();\n \n         // We want the type_id be independent of the types free regions, so we\n         // erase them. The erase_regions() call will also anonymize bound"}, {"sha": "7520c6ac652baf44c2dc543a914d5f8a3895ad5c", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -34,7 +34,6 @@ use syntax_pos::Span;\n use std::cmp::Ordering;\n \n use rustc_const_math::*;\n-\n macro_rules! signal {\n     ($e:expr, $exn:expr) => {\n         return Err(ConstEvalErr { span: $e.span, kind: $exn })\n@@ -366,7 +365,7 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n             }\n           } else {\n             if tcx.is_const_fn(def_id) {\n-                tcx.extern_const_body(def_id)\n+                tcx.extern_const_body(def_id).body\n             } else {\n                 signal!(e, TypeckError)\n             }\n@@ -790,7 +789,7 @@ fn const_eval<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.mir_const_qualif(def_id);\n         tcx.hir.body(tcx.hir.body_owned_by(id))\n     } else {\n-        tcx.extern_const_body(def_id)\n+        tcx.extern_const_body(def_id).body\n     };\n     ConstContext::new(tcx, key.param_env.and(substs), tables).eval(&body.value)\n }"}, {"sha": "7586ad5a75f818bbf2637fbccc55fc838b9abca8", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -607,7 +607,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         let body = if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n                             self.tcx.hir.body(self.tcx.hir.body_owned_by(id))\n                         } else {\n-                            self.tcx.extern_const_body(def_id)\n+                            self.tcx.extern_const_body(def_id).body\n                         };\n                         let pat = self.lower_const_expr(&body.value, pat_id, span);\n                         self.tables = old_tables;"}, {"sha": "f6b23af2f73746b74dbbe101a365c695be71b5a2", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 159, "deletions": 26, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash::{Hash, Hasher};\n+use std::hash::{Hash, Hasher, BuildHasher};\n use std::marker::PhantomData;\n use std::mem;\n use blake2b::Blake2bHasher;\n@@ -192,6 +192,28 @@ impl<W> Hasher for StableHasher<W> {\n }\n \n \n+/// Something that can provide a stable hashing context.\n+pub trait StableHashingContextProvider {\n+    type ContextType;\n+    fn create_stable_hashing_context(&self) -> Self::ContextType;\n+}\n+\n+impl<'a, T: StableHashingContextProvider> StableHashingContextProvider for &'a T {\n+    type ContextType = T::ContextType;\n+\n+    fn create_stable_hashing_context(&self) -> Self::ContextType {\n+        (**self).create_stable_hashing_context()\n+    }\n+}\n+\n+impl<'a, T: StableHashingContextProvider> StableHashingContextProvider for &'a mut T {\n+    type ContextType = T::ContextType;\n+\n+    fn create_stable_hashing_context(&self) -> Self::ContextType {\n+        (**self).create_stable_hashing_context()\n+    }\n+}\n+\n /// Something that implements `HashStable<CTX>` can be hashed in a way that is\n /// stable across multiple compilation sessions.\n pub trait HashStable<CTX> {\n@@ -200,6 +222,14 @@ pub trait HashStable<CTX> {\n                                           hasher: &mut StableHasher<W>);\n }\n \n+/// Implement this for types that can be turned into stable keys like, for\n+/// example, for DefId that can be converted to a DefPathHash. This is used for\n+/// bringing maps into a predictable order before hashing them.\n+pub trait ToStableHashKey<HCX> {\n+    type KeyType: Ord + Clone + Sized + HashStable<HCX>;\n+    fn to_stable_hash_key(&self, hcx: &HCX) -> Self::KeyType;\n+}\n+\n // Implement HashStable by just calling `Hash::hash()`. This works fine for\n // self-contained values that don't depend on the hashing context `CTX`.\n macro_rules! impl_stable_hash_via_hash {\n@@ -259,16 +289,33 @@ impl<T1: HashStable<CTX>, CTX> HashStable<CTX> for (T1,) {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,\n                                           hasher: &mut StableHasher<W>) {\n-        self.0.hash_stable(ctx, hasher);\n+        let (ref _0,) = *self;\n+        _0.hash_stable(ctx, hasher);\n     }\n }\n \n impl<T1: HashStable<CTX>, T2: HashStable<CTX>, CTX> HashStable<CTX> for (T1, T2) {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,\n                                           hasher: &mut StableHasher<W>) {\n-        self.0.hash_stable(ctx, hasher);\n-        self.1.hash_stable(ctx, hasher);\n+        let (ref _0, ref _1) = *self;\n+        _0.hash_stable(ctx, hasher);\n+        _1.hash_stable(ctx, hasher);\n+    }\n+}\n+\n+impl<T1, T2, T3, CTX> HashStable<CTX> for (T1, T2, T3)\n+     where T1: HashStable<CTX>,\n+           T2: HashStable<CTX>,\n+           T3: HashStable<CTX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let (ref _0, ref _1, ref _2) = *self;\n+        _0.hash_stable(ctx, hasher);\n+        _1.hash_stable(ctx, hasher);\n+        _2.hash_stable(ctx, hasher);\n     }\n }\n \n@@ -292,7 +339,7 @@ impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Vec<T> {\n     }\n }\n \n-impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Box<T> {\n+impl<T: ?Sized + HashStable<CTX>, CTX> HashStable<CTX> for Box<T> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,\n@@ -301,7 +348,7 @@ impl<T: HashStable<CTX>, CTX> HashStable<CTX> for Box<T> {\n     }\n }\n \n-impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ::std::rc::Rc<T> {\n+impl<T: ?Sized + HashStable<CTX>, CTX> HashStable<CTX> for ::std::rc::Rc<T> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,\n@@ -310,7 +357,7 @@ impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ::std::rc::Rc<T> {\n     }\n }\n \n-impl<T: HashStable<CTX>, CTX> HashStable<CTX> for ::std::sync::Arc<T> {\n+impl<T: ?Sized + HashStable<CTX>, CTX> HashStable<CTX> for ::std::sync::Arc<T> {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,\n@@ -339,6 +386,14 @@ impl<CTX> HashStable<CTX> for String {\n     }\n }\n \n+impl<HCX> ToStableHashKey<HCX> for String {\n+    type KeyType = String;\n+    #[inline]\n+    fn to_stable_hash_key(&self, _: &HCX) -> Self::KeyType {\n+        self.clone()\n+    }\n+}\n+\n impl<CTX> HashStable<CTX> for bool {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -365,8 +420,24 @@ impl<T, CTX> HashStable<CTX> for Option<T>\n     }\n }\n \n+impl<T1, T2, CTX> HashStable<CTX> for Result<T1, T2>\n+    where T1: HashStable<CTX>,\n+          T2: HashStable<CTX>,\n+{\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          ctx: &mut CTX,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(ctx, hasher);\n+        match *self {\n+            Ok(ref x) => x.hash_stable(ctx, hasher),\n+            Err(ref x) => x.hash_stable(ctx, hasher),\n+        }\n+    }\n+}\n+\n impl<'a, T, CTX> HashStable<CTX> for &'a T\n-    where T: HashStable<CTX>\n+    where T: HashStable<CTX> + ?Sized\n {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -385,43 +456,105 @@ impl<T, CTX> HashStable<CTX> for ::std::mem::Discriminant<T> {\n     }\n }\n \n-impl<K, V, CTX> HashStable<CTX> for ::std::collections::BTreeMap<K, V>\n-    where K: Ord + HashStable<CTX>,\n-          V: HashStable<CTX>,\n+impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<I, T>\n+    where T: HashStable<CTX>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,\n                                           hasher: &mut StableHasher<W>) {\n         self.len().hash_stable(ctx, hasher);\n-        for (k, v) in self {\n-            k.hash_stable(ctx, hasher);\n+        for v in &self.raw {\n             v.hash_stable(ctx, hasher);\n         }\n     }\n }\n \n-impl<T, CTX> HashStable<CTX> for ::std::collections::BTreeSet<T>\n-    where T: Ord + HashStable<CTX>,\n+\n+impl<I: ::indexed_vec::Idx, CTX> HashStable<CTX> for ::indexed_set::IdxSetBuf<I>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,\n                                           hasher: &mut StableHasher<W>) {\n-        self.len().hash_stable(ctx, hasher);\n-        for v in self {\n-            v.hash_stable(ctx, hasher);\n-        }\n+        self.words().hash_stable(ctx, hasher);\n     }\n }\n \n-impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<I, T>\n-    where T: HashStable<CTX>,\n+impl_stable_hash_via_hash!(::std::path::Path);\n+impl_stable_hash_via_hash!(::std::path::PathBuf);\n+\n+impl<K, V, R, HCX> HashStable<HCX> for ::std::collections::HashMap<K, V, R>\n+    where K: ToStableHashKey<HCX> + Eq + Hash,\n+          V: HashStable<HCX>,\n+          R: BuildHasher,\n {\n+    #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n+                                          hcx: &mut HCX,\n                                           hasher: &mut StableHasher<W>) {\n-        self.len().hash_stable(ctx, hasher);\n-        for v in &self.raw {\n-            v.hash_stable(ctx, hasher);\n-        }\n+        hash_stable_hashmap(hcx, hasher, self, ToStableHashKey::to_stable_hash_key);\n     }\n }\n+\n+impl<K, R, HCX> HashStable<HCX> for ::std::collections::HashSet<K, R>\n+    where K: ToStableHashKey<HCX> + Eq + Hash,\n+          R: BuildHasher,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut HCX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let mut keys: Vec<_> = self.iter()\n+                                   .map(|k| k.to_stable_hash_key(hcx))\n+                                   .collect();\n+        keys.sort_unstable();\n+        keys.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<K, V, HCX> HashStable<HCX> for ::std::collections::BTreeMap<K, V>\n+    where K: ToStableHashKey<HCX>,\n+          V: HashStable<HCX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut HCX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let mut entries: Vec<_> = self.iter()\n+                                      .map(|(k, v)| (k.to_stable_hash_key(hcx), v))\n+                                      .collect();\n+        entries.sort_unstable_by(|&(ref sk1, _), &(ref sk2, _)| sk1.cmp(sk2));\n+        entries.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<K, HCX> HashStable<HCX> for ::std::collections::BTreeSet<K>\n+    where K: ToStableHashKey<HCX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut HCX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let mut keys: Vec<_> = self.iter()\n+                                   .map(|k| k.to_stable_hash_key(hcx))\n+                                   .collect();\n+        keys.sort_unstable();\n+        keys.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+pub fn hash_stable_hashmap<HCX, K, V, R, SK, F, W>(\n+    hcx: &mut HCX,\n+    hasher: &mut StableHasher<W>,\n+    map: &::std::collections::HashMap<K, V, R>,\n+    to_stable_hash_key: F)\n+    where K: Eq + Hash,\n+          V: HashStable<HCX>,\n+          R: BuildHasher,\n+          SK: HashStable<HCX> + Ord + Clone,\n+          F: Fn(&K, &HCX) -> SK,\n+          W: StableHasherResult,\n+{\n+    let mut entries: Vec<_> = map.iter()\n+                                  .map(|(k, v)| (to_stable_hash_key(k, hcx), v))\n+                                  .collect();\n+    entries.sort_unstable_by(|&(ref sk1, _), &(ref sk2, _)| sk1.cmp(sk2));\n+    entries.hash_stable(hcx, hasher);\n+}\n+"}, {"sha": "d50d3deb67347f9e5a3ff69b9e6c986432939e30", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -175,7 +175,7 @@ pub fn compile_input(sess: &Session,\n         // Construct the HIR map\n         let hir_map = time(sess.time_passes(),\n                            \"indexing hir\",\n-                           || hir_map::map_crate(&mut hir_forest, defs));\n+                           || hir_map::map_crate(&mut hir_forest, &defs));\n \n         {\n             let _ignore = hir_map.dep_graph.in_ignore();"}, {"sha": "daabf481e461f941565f00ab1818c8f959adfcb1", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -133,7 +133,7 @@ fn test_env<F>(source_string: &str,\n \n     let arena = DroplessArena::new();\n     let arenas = ty::GlobalArenas::new();\n-    let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n+    let hir_map = hir_map::map_crate(&mut hir_forest, &defs);\n \n     // run just enough stuff to build a tcx:\n     let named_region_map = resolve_lifetime::krate(&sess, &*cstore, &hir_map);"}, {"sha": "0329aa8d6741b71e1476089419735d8d86eb3c14", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -31,7 +31,7 @@ use std::cell::RefCell;\n use std::hash::Hash;\n use rustc::dep_graph::{DepNode, DepKind};\n use rustc::hir;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n use rustc::hir::map::DefPathHash;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ich::{Fingerprint, StableHashingContext};\n@@ -90,48 +90,61 @@ impl<'a> ::std::ops::Index<&'a DepNode> for IncrementalHashesMap {\n }\n \n struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n-    hcx: StableHashingContext<'a, 'tcx, 'tcx>,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    hcx: StableHashingContext<'tcx>,\n     hashes: IncrementalHashesMap,\n }\n \n impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n     fn compute_and_store_ich_for_item_like<T>(&mut self,\n-                                              dep_node: DepNode,\n+                                              def_index: DefIndex,\n                                               hash_bodies: bool,\n                                               item_like: T)\n-        where T: HashStable<StableHashingContext<'a, 'tcx, 'tcx>>\n+        where T: HashStable<StableHashingContext<'tcx>>\n     {\n-        if !hash_bodies && !self.hcx.tcx().sess.opts.build_dep_graph() {\n+        if !hash_bodies && !self.tcx.sess.opts.build_dep_graph() {\n             // If we just need the hashes in order to compute the SVH, we don't\n             // need have two hashes per item. Just the one containing also the\n             // item's body is sufficient.\n             return\n         }\n \n+        let def_path_hash = self.hcx.local_def_path_hash(def_index);\n+\n         let mut hasher = IchHasher::new();\n         self.hcx.while_hashing_hir_bodies(hash_bodies, |hcx| {\n             item_like.hash_stable(hcx, &mut hasher);\n         });\n \n         let bytes_hashed = hasher.bytes_hashed();\n         let item_hash = hasher.finish();\n+        let dep_node = if hash_bodies {\n+            def_path_hash.to_dep_node(DepKind::HirBody)\n+        } else {\n+            def_path_hash.to_dep_node(DepKind::Hir)\n+        };\n         debug!(\"calculate_def_hash: dep_node={:?} hash={:?}\", dep_node, item_hash);\n         self.hashes.insert(dep_node, item_hash);\n \n-        let tcx = self.hcx.tcx();\n         let bytes_hashed =\n-            tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n-            bytes_hashed;\n-        tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n+            self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() + bytes_hashed;\n+        self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n+\n+        if hash_bodies {\n+            let in_scope_traits_map = self.tcx.in_scope_traits_map(def_index);\n+            let mut hasher = IchHasher::new();\n+            in_scope_traits_map.hash_stable(&mut self.hcx, &mut hasher);\n+            let dep_node = def_path_hash.to_dep_node(DepKind::InScopeTraits);\n+            self.hashes.insert(dep_node, hasher.finish());\n+        }\n     }\n \n     fn compute_crate_hash(&mut self) {\n-        let tcx = self.hcx.tcx();\n-        let krate = tcx.hir.krate();\n+        let krate = self.tcx.hir.krate();\n \n         let mut crate_state = IchHasher::new();\n \n-        let crate_disambiguator = tcx.sess.local_crate_disambiguator();\n+        let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n         \"crate_disambiguator\".hash(&mut crate_state);\n         crate_disambiguator.as_str().len().hash(&mut crate_state);\n         crate_disambiguator.as_str().hash(&mut crate_state);\n@@ -145,6 +158,7 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n                                 // This `match` determines what kinds of nodes\n                                 // go into the SVH:\n                                 match item_dep_node.kind {\n+                                    DepKind::InScopeTraits |\n                                     DepKind::Hir |\n                                     DepKind::HirBody => {\n                                         // We want to incoporate these into the\n@@ -195,18 +209,17 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n             body_ids: _,\n         } = *krate;\n \n-        let def_path_hash = self.hcx.tcx().hir.definitions().def_path_hash(CRATE_DEF_INDEX);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+        self.compute_and_store_ich_for_item_like(CRATE_DEF_INDEX,\n                                                  false,\n                                                  (module, (span, attrs)));\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+        self.compute_and_store_ich_for_item_like(CRATE_DEF_INDEX,\n                                                  true,\n                                                  (module, (span, attrs)));\n     }\n \n     fn compute_and_store_ich_for_trait_impls(&mut self, krate: &'tcx hir::Crate)\n     {\n-        let tcx = self.hcx.tcx();\n+        let tcx = self.tcx;\n \n         let mut impls: Vec<(DefPathHash, Fingerprint)> = krate\n             .trait_impls\n@@ -251,34 +264,31 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n-        let def_path_hash = self.hcx.tcx().def_path_hash(def_id);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+        let def_index = self.tcx.hir.local_def_id(item.id).index;\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  false,\n                                                  item);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  true,\n                                                  item);\n     }\n \n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n-        let def_path_hash = self.hcx.tcx().def_path_hash(def_id);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+        let def_index = self.tcx.hir.local_def_id(item.id).index;\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  false,\n                                                  item);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  true,\n                                                  item);\n     }\n \n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n-        let def_path_hash = self.hcx.tcx().def_path_hash(def_id);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+        let def_index = self.tcx.hir.local_def_id(item.id).index;\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  false,\n                                                  item);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  true,\n                                                  item);\n     }\n@@ -292,7 +302,8 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     let krate = tcx.hir.krate();\n \n     let mut visitor = ComputeItemHashesVisitor {\n-        hcx: StableHashingContext::new(tcx),\n+        tcx,\n+        hcx: tcx.create_stable_hashing_context(),\n         hashes: IncrementalHashesMap::new(),\n     };\n \n@@ -301,12 +312,11 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n         krate.visit_all_item_likes(&mut visitor);\n \n         for macro_def in krate.exported_macros.iter() {\n-            let def_id = tcx.hir.local_def_id(macro_def.id);\n-            let def_path_hash = tcx.def_path_hash(def_id);\n-            visitor.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+            let def_index = tcx.hir.local_def_id(macro_def.id).index;\n+            visitor.compute_and_store_ich_for_item_like(def_index,\n                                                         false,\n                                                         macro_def);\n-            visitor.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+            visitor.compute_and_store_ich_for_item_like(def_index,\n                                                         true,\n                                                         macro_def);\n         }"}, {"sha": "8355f319139386b013204024f02ef5e60617c384", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -49,6 +49,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         match dep_node.kind {\n             DepKind::Krate |\n             DepKind::Hir |\n+            DepKind::InScopeTraits |\n             DepKind::HirBody =>\n                 true,\n             DepKind::MetaData => {\n@@ -66,6 +67,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             }\n \n             // HIR nodes (which always come from our crate) are an input:\n+            DepKind::InScopeTraits |\n             DepKind::Hir |\n             DepKind::HirBody => {\n                 Some(self.incremental_hashes_map[dep_node])"}, {"sha": "9865ea8c2856acd2f36beefb51fe7656136bda02", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -104,6 +104,7 @@ fn does_still_exist(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n     match dep_node.kind {\n         DepKind::Hir |\n         DepKind::HirBody |\n+        DepKind::InScopeTraits |\n         DepKind::MetaData => {\n             dep_node.extract_def_id(tcx).is_some()\n         }"}, {"sha": "d9ab2562efff26b87d70643bea77b9504c2d3ca2", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -16,26 +16,46 @@ use schema::*;\n use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n \n+use rustc::ich::Fingerprint;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Ast<'tcx> {\n     pub body: Lazy<hir::Body>,\n     pub tables: Lazy<ty::TypeckTables<'tcx>>,\n     pub nested_bodies: LazySeq<hir::Body>,\n     pub rvalue_promotable_to_static: bool,\n+    pub stable_bodies_hash: Fingerprint,\n }\n \n impl_stable_hash_for!(struct Ast<'tcx> {\n     body,\n     tables,\n     nested_bodies,\n-    rvalue_promotable_to_static\n+    rvalue_promotable_to_static,\n+    stable_bodies_hash\n });\n \n impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n     pub fn encode_body(&mut self, body_id: hir::BodyId) -> Lazy<Ast<'tcx>> {\n         let body = self.tcx.hir.body(body_id);\n-        let lazy_body = self.lazy(body);\n \n+        // In order to avoid having to hash hir::Bodies from extern crates, we\n+        // hash them here, during export, and store the hash with metadata.\n+        let stable_bodies_hash = {\n+            let mut hcx = self.tcx.create_stable_hashing_context();\n+            let mut hasher = StableHasher::new();\n+\n+            hcx.while_hashing_hir_bodies(true, |hcx| {\n+                hcx.while_hashing_spans(false, |hcx| {\n+                    body.hash_stable(hcx, &mut hasher);\n+                });\n+            });\n+\n+            hasher.finish()\n+        };\n+\n+        let lazy_body = self.lazy(body);\n         let tables = self.tcx.body_tables(body_id);\n         let lazy_tables = self.lazy(tables);\n \n@@ -54,6 +74,7 @@ impl<'a, 'b, 'tcx> IsolatedEncoder<'a, 'b, 'tcx> {\n             tables: lazy_tables,\n             nested_bodies: lazy_nested_bodies,\n             rvalue_promotable_to_static,\n+            stable_bodies_hash,\n         })\n     }\n }"}, {"sha": "39bdf88925e4444f2c2630dc65fc34381093fcd8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -301,7 +301,10 @@ impl<'a> CrateLoader<'a> {\n             .decode(&cmeta)\n             .filter(|lib| relevant_lib(self.sess, lib) &&\n                           lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n-            .flat_map(|lib| lib.foreign_items.into_iter())\n+            .flat_map(|lib| {\n+                assert!(lib.foreign_items.iter().all(|def_id| def_id.krate == cnum));\n+                lib.foreign_items.into_iter().map(|def_id| def_id.index)\n+            })\n             .collect();\n \n         cmeta.dllimport_foreign_items = dllimports;"}, {"sha": "78c44c7e45cdff125274b7062d7aa979fbeb8696", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -159,7 +159,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_exported_symbol => {\n         cdata.exported_symbols.contains(&def_id.index)\n     }\n-    item_body_nested_bodies => { Rc::new(cdata.item_body_nested_bodies(def_id.index)) }\n+    item_body_nested_bodies => { cdata.item_body_nested_bodies(def_id.index) }\n     const_is_rvalue_promotable_to_static => {\n         cdata.const_is_rvalue_promotable_to_static(def_id.index)\n     }\n@@ -264,7 +264,7 @@ pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n             tcx.native_libraries(id.krate)\n                 .iter()\n                 .filter(|lib| native_libs::relevant_lib(&tcx.sess, lib))\n-                .find(|l| l.foreign_items.contains(&id.index))\n+                .find(|l| l.foreign_items.contains(&id))\n                 .map(|l| l.kind)\n         },\n         native_libraries: |tcx, cnum| {"}, {"sha": "65cf15e5a0ec782e21acc47dfd458cb552acfe52", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -17,9 +17,11 @@ use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n \n use rustc::middle::const_val::ByteArray;\n-use rustc::middle::cstore::LinkagePreference;\n+use rustc::middle::cstore::{LinkagePreference, ExternConstBody,\n+                            ExternBodyNestedBodies};\n use rustc::hir::def::{self, Def, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc::ich::Fingerprint;\n use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -659,10 +661,11 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self) -> Vec<(DefIndex, usize)> {\n+    pub fn get_lang_items(&self) -> Vec<(DefId, usize)> {\n         self.root\n             .lang_items\n             .decode(self)\n+            .map(|(def_index, index)| (self.local_def_id(def_index), index))\n             .collect()\n     }\n \n@@ -774,12 +777,16 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn extern_const_body(&self,\n                              tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              id: DefIndex)\n-                             -> &'tcx hir::Body {\n+                             -> ExternConstBody<'tcx> {\n         assert!(!self.is_proc_macro(id));\n         let ast = self.entry(id).ast.unwrap();\n         let def_id = self.local_def_id(id);\n-        let body = ast.decode((self, tcx)).body.decode((self, tcx));\n-        tcx.hir.intern_inlined_body(def_id, body)\n+        let ast = ast.decode((self, tcx));\n+        let body = ast.body.decode((self, tcx));\n+        ExternConstBody {\n+            body: tcx.hir.intern_inlined_body(def_id, body),\n+            fingerprint: ast.stable_bodies_hash,\n+        }\n     }\n \n     pub fn item_body_tables(&self,\n@@ -790,10 +797,23 @@ impl<'a, 'tcx> CrateMetadata {\n         tcx.alloc_tables(ast.tables.decode((self, tcx)))\n     }\n \n-    pub fn item_body_nested_bodies(&self, id: DefIndex) -> BTreeMap<hir::BodyId, hir::Body> {\n-        self.entry(id).ast.into_iter().flat_map(|ast| {\n-            ast.decode(self).nested_bodies.decode(self).map(|body| (body.id(), body))\n-        }).collect()\n+    pub fn item_body_nested_bodies(&self, id: DefIndex) -> ExternBodyNestedBodies {\n+        if let Some(ref ast) = self.entry(id).ast {\n+            let ast = ast.decode(self);\n+            let nested_bodies: BTreeMap<_, _> = ast.nested_bodies\n+                                                   .decode(self)\n+                                                   .map(|body| (body.id(), body))\n+                                                   .collect();\n+            ExternBodyNestedBodies {\n+                nested_bodies: Rc::new(nested_bodies),\n+                fingerprint: ast.stable_bodies_hash,\n+            }\n+        } else {\n+            ExternBodyNestedBodies {\n+                nested_bodies: Rc::new(BTreeMap::new()),\n+                fingerprint: Fingerprint::zero(),\n+            }\n+        }\n     }\n \n     pub fn const_is_rvalue_promotable_to_static(&self, id: DefIndex) -> bool {"}, {"sha": "7dc50fe29df07a245bc9a53cbfb9cc64300de779", "filename": "src/librustc_metadata/isolated_encoder.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fisolated_encoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fisolated_encoder.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -23,7 +23,7 @@ use rustc_serialize::Encodable;\n pub struct IsolatedEncoder<'a, 'b: 'a, 'tcx: 'b> {\n     pub tcx: TyCtxt<'b, 'tcx, 'tcx>,\n     ecx: &'a mut EncodeContext<'b, 'tcx>,\n-    hcx: Option<(StableHashingContext<'b, 'tcx, 'tcx>, StableHasher<Fingerprint>)>,\n+    hcx: Option<(StableHashingContext<'tcx>, StableHasher<Fingerprint>)>,\n }\n \n impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n@@ -40,9 +40,9 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 // Except when -Zquery-dep-graph is specified because we don't\n                 // want to mess up our tests.\n                 let hcx = if tcx.sess.opts.debugging_opts.query_dep_graph {\n-                    StableHashingContext::new(tcx)\n+                    tcx.create_stable_hashing_context()\n                 } else {\n-                    StableHashingContext::new(tcx).force_span_hashing()\n+                    tcx.create_stable_hashing_context().force_span_hashing()\n                 };\n \n                 Some((hcx, StableHasher::new()))\n@@ -61,7 +61,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy<T>(&mut self, value: &T) -> Lazy<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             value.hash_stable(hcx, hasher);\n@@ -72,7 +72,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     pub fn lazy_seq<I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = T>,\n-              T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n+              T: Encodable + HashStable<StableHashingContext<'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             let iter = iter.into_iter();\n@@ -111,7 +111,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     pub fn lazy_seq_ref<'x, I, T>(&mut self, iter: I) -> LazySeq<T>\n         where I: IntoIterator<Item = &'x T>,\n-              T: 'x + Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n+              T: 'x + Encodable + HashStable<StableHashingContext<'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             let iter = iter.into_iter();\n@@ -149,7 +149,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy_seq_from_slice<T>(&mut self, slice: &[T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             slice.hash_stable(hcx, hasher);\n@@ -159,7 +159,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n     }\n \n     pub fn lazy_seq_ref_from_slice<T>(&mut self, slice: &[&T]) -> LazySeq<T>\n-        where T: Encodable + HashStable<StableHashingContext<'b, 'tcx, 'tcx>>\n+        where T: Encodable + HashStable<StableHashingContext<'tcx>>\n     {\n         if let Some((ref mut hcx, ref mut hasher)) = self.hcx {\n             slice.hash_stable(hcx, hasher);"}, {"sha": "cc332acb5b08e8315aff614941e8523fc7ee447b", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                 list[0].meta_item().unwrap().clone()\n             });\n             let foreign_items = fm.items.iter()\n-                .map(|it| self.tcx.hir.local_def_id(it.id).index)\n+                .map(|it| self.tcx.hir.local_def_id(it.id))\n                 .collect();\n             let lib = NativeLibrary {\n                 name: n,"}, {"sha": "dad0d26d2715d172ae92150765170b20039b86d4", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -229,9 +229,9 @@ pub struct TraitImpls {\n     pub impls: LazySeq<DefIndex>,\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TraitImpls {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for TraitImpls {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         let TraitImpls {\n             trait_id: (krate, def_index),\n@@ -312,9 +312,9 @@ pub enum EntryKind<'tcx> {\n     AssociatedConst(AssociatedContainer, u8),\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for EntryKind<'tcx> {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for EntryKind<'gcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {"}, {"sha": "e1f97e2c923db17d42ce32aab2a4be64fdc7363d", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -14,7 +14,7 @@ use std::sync::Arc;\n use base;\n use monomorphize::Instance;\n use rustc::hir::def_id::CrateNum;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE, INVALID_CRATE, CRATE_DEF_INDEX};\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config;\n use rustc::ty::TyCtxt;\n@@ -24,7 +24,7 @@ use rustc_allocator::ALLOCATOR_METHODS;\n \n pub type ExportedSymbols = FxHashMap<\n     CrateNum,\n-    Arc<Vec<(String, DefId, SymbolExportLevel)>>,\n+    Arc<Vec<(String, Option<DefId>, SymbolExportLevel)>>,\n >;\n \n pub fn threshold(tcx: TyCtxt) -> SymbolExportLevel {\n@@ -65,11 +65,13 @@ pub fn provide_local(providers: &mut Providers) {\n         Rc::new(tcx.exported_symbols(cnum)\n             .iter()\n             .filter_map(|&(_, id, level)| {\n-                if level.is_below_threshold(export_threshold) {\n-                    Some(id)\n-                } else {\n-                    None\n-                }\n+                id.and_then(|id| {\n+                    if level.is_below_threshold(export_threshold) {\n+                        Some(id)\n+                    } else {\n+                        None\n+                    }\n+                })\n             })\n             .collect())\n     };\n@@ -95,25 +97,20 @@ pub fn provide_local(providers: &mut Providers) {\n                 let name = tcx.symbol_name(Instance::mono(tcx, def_id));\n                 let export_level = export_level(tcx, def_id);\n                 debug!(\"EXPORTED SYMBOL (local): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), def_id, export_level)\n+                (str::to_owned(&name), Some(def_id), export_level)\n             })\n             .collect();\n \n-        const INVALID_DEF_ID: DefId = DefId {\n-            krate: INVALID_CRATE,\n-            index: CRATE_DEF_INDEX,\n-        };\n-\n         if let Some(_) = *tcx.sess.entry_fn.borrow() {\n             local_crate.push((\"main\".to_string(),\n-                              INVALID_DEF_ID,\n+                              None,\n                               SymbolExportLevel::C));\n         }\n \n         if tcx.sess.allocator_kind.get().is_some() {\n             for method in ALLOCATOR_METHODS {\n                 local_crate.push((format!(\"__rust_{}\", method.name),\n-                                  INVALID_DEF_ID,\n+                                  None,\n                                   SymbolExportLevel::Rust));\n             }\n         }\n@@ -123,12 +120,12 @@ pub fn provide_local(providers: &mut Providers) {\n             let idx = def_id.index;\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             let registrar = tcx.sess.generate_derive_registrar_symbol(disambiguator, idx);\n-            local_crate.push((registrar, def_id, SymbolExportLevel::C));\n+            local_crate.push((registrar, Some(def_id), SymbolExportLevel::C));\n         }\n \n         if tcx.sess.crate_types.borrow().contains(&config::CrateTypeDylib) {\n             local_crate.push((metadata_symbol_name(tcx),\n-                              INVALID_DEF_ID,\n+                              None,\n                               SymbolExportLevel::Rust));\n         }\n         Arc::new(local_crate)\n@@ -178,7 +175,7 @@ pub fn provide_extern(providers: &mut Providers) {\n                     export_level(tcx, def_id)\n                 };\n                 debug!(\"EXPORTED SYMBOL (re-export): {} ({:?})\", name, export_level);\n-                (str::to_owned(&name), def_id, export_level)\n+                (str::to_owned(&name), Some(def_id), export_level)\n             })\n             .collect();\n "}, {"sha": "ba15f3522ac1fffd38c25bcca6239dc55b567890", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -41,7 +41,6 @@ use rustc::middle::trans::{Linkage, Visibility, Stats};\n use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::Providers;\n-use rustc::dep_graph::AssertDepGraphSafe;\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::hir::map as hir_map;\n use rustc::util::common::{time, print_time_passes_entry};\n@@ -894,7 +893,7 @@ fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n /// This list is later used by linkers to determine the set of symbols needed to\n /// be exposed from a dynamic library and it's also encoded into the metadata.\n pub fn find_exported_symbols(tcx: TyCtxt) -> NodeSet {\n-    tcx.reachable_set(LOCAL_CRATE).iter().cloned().filter(|&id| {\n+    tcx.reachable_set(LOCAL_CRATE).0.iter().cloned().filter(|&id| {\n         // Next, we want to ignore some FFI functions that are not exposed from\n         // this crate. Reachable FFI functions can be lumped into two\n         // categories:\n@@ -1070,7 +1069,6 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let start_time = Instant::now();\n         all_stats.extend(tcx.compile_codegen_unit(*cgu.name()));\n         total_trans_time += start_time.elapsed();\n-\n         ongoing_translation.check_for_errors(tcx.sess);\n     }\n \n@@ -1371,8 +1369,8 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let dep_node = cgu.work_product_dep_node();\n     let ((stats, module), _) =\n         tcx.dep_graph.with_task(dep_node,\n-                                AssertDepGraphSafe(tcx),\n-                                AssertDepGraphSafe(cgu),\n+                                tcx,\n+                                cgu,\n                                 module_translation);\n     let time_to_translate = start_time.elapsed();\n \n@@ -1393,14 +1391,10 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     return stats;\n \n     fn module_translation<'a, 'tcx>(\n-        tcx: AssertDepGraphSafe<TyCtxt<'a, 'tcx, 'tcx>>,\n-        args: AssertDepGraphSafe<Arc<CodegenUnit<'tcx>>>)\n+        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        cgu: Arc<CodegenUnit<'tcx>>)\n         -> (Stats, ModuleTranslation)\n     {\n-        // FIXME(#40304): We ought to be using the id as a key and some queries, I think.\n-        let AssertDepGraphSafe(tcx) = tcx;\n-        let AssertDepGraphSafe(cgu) = args;\n-\n         let cgu_name = cgu.name().to_string();\n         let cgu_id = cgu.work_product_id();\n         let symbol_name_hash = cgu.compute_symbol_name_hash(tcx);\n@@ -1567,3 +1561,25 @@ pub fn visibility_to_llvm(linkage: Visibility) -> llvm::Visibility {\n         Visibility::Protected => llvm::Visibility::Protected,\n     }\n }\n+\n+// FIXME(mw): Anything that is produced via DepGraph::with_task() must implement\n+//            the HashStable trait. Normally DepGraph::with_task() calls are\n+//            hidden behind queries, but CGU creation is a special case in two\n+//            ways: (1) it's not a query and (2) CGU are output nodes, so their\n+//            Fingerprints are not actually needed. It remains to be clarified\n+//            how exactly this case will be handled in the red/green system but\n+//            for now we content ourselves with providing a no-op HashStable\n+//            implementation for CGUs.\n+mod temp_stable_hash_impls {\n+    use rustc_data_structures::stable_hasher::{StableHasherResult, StableHasher,\n+                                               HashStable};\n+    use ModuleTranslation;\n+\n+    impl<HCX> HashStable<HCX> for ModuleTranslation {\n+        fn hash_stable<W: StableHasherResult>(&self,\n+                                              _: &mut HCX,\n+                                              _: &mut StableHasher<W>) {\n+            // do nothing\n+        }\n+    }\n+}"}, {"sha": "b394911c9234df9a65c0b67f73bfcc874fc9bb24", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -14,6 +14,7 @@ use llvm::{ContextRef, ModuleRef, ValueRef};\n use rustc::dep_graph::{DepGraph, DepGraphSafe};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n+use rustc::ich::StableHashingContext;\n use rustc::traits;\n use debuginfo;\n use callee;\n@@ -25,8 +26,9 @@ use partitioning::CodegenUnit;\n use type_::Type;\n use rustc_data_structures::base_n;\n use rustc::middle::trans::Stats;\n-use rustc::session::Session;\n+use rustc_data_structures::stable_hasher::StableHashingContextProvider;\n use rustc::session::config::{self, NoDebugInfo};\n+use rustc::session::Session;\n use rustc::ty::layout::{LayoutCx, LayoutError, LayoutTyper, TyLayout};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n@@ -134,6 +136,17 @@ impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n impl<'a, 'tcx> DepGraphSafe for CrateContext<'a, 'tcx> {\n }\n \n+impl<'a, 'tcx> DepGraphSafe for SharedCrateContext<'a, 'tcx> {\n+}\n+\n+impl<'a, 'tcx> StableHashingContextProvider for SharedCrateContext<'a, 'tcx> {\n+    type ContextType = StableHashingContext<'tcx>;\n+\n+    fn create_stable_hashing_context(&self) -> Self::ContextType {\n+        self.tcx.create_stable_hashing_context()\n+    }\n+}\n+\n pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n         Some(ref s) => &s[..],"}, {"sha": "5256bb22781175cbb561ad647d8eb58d89862077", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -96,36 +96,40 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         -> ty::Region<'tcx>\n     {\n         let tcx = self.tcx();\n+        let lifetime_name = |def_id| {\n+            tcx.hir.name(tcx.hir.as_local_node_id(def_id).unwrap())\n+        };\n+\n         let hir_id = tcx.hir.node_to_hir_id(lifetime.id);\n         let r = match tcx.named_region(hir_id) {\n             Some(rl::Region::Static) => {\n                 tcx.types.re_static\n             }\n \n             Some(rl::Region::LateBound(debruijn, id)) => {\n-                let name = tcx.hir.name(id);\n+                let name = lifetime_name(id);\n                 tcx.mk_region(ty::ReLateBound(debruijn,\n-                    ty::BrNamed(tcx.hir.local_def_id(id), name)))\n+                    ty::BrNamed(id, name)))\n             }\n \n             Some(rl::Region::LateBoundAnon(debruijn, index)) => {\n                 tcx.mk_region(ty::ReLateBound(debruijn, ty::BrAnon(index)))\n             }\n \n             Some(rl::Region::EarlyBound(index, id)) => {\n-                let name = tcx.hir.name(id);\n+                let name = lifetime_name(id);\n                 tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-                    def_id: tcx.hir.local_def_id(id),\n+                    def_id: id,\n                     index,\n                     name,\n                 }))\n             }\n \n             Some(rl::Region::Free(scope, id)) => {\n-                let name = tcx.hir.name(id);\n+                let name = lifetime_name(id);\n                 tcx.mk_region(ty::ReFree(ty::FreeRegion {\n                     scope,\n-                    bound_region: ty::BrNamed(tcx.hir.local_def_id(id), name)\n+                    bound_region: ty::BrNamed(id, name)\n                 }))\n \n                     // (*) -- not late-bound, won't change"}, {"sha": "29da763f334c7b016eafadbbd78c2326e1e32aa5", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -14,14 +14,16 @@\n //! We walk the set of items and, for each member, generate new constraints.\n \n use hir::def_id::DefId;\n-use rustc::dep_graph::{AssertDepGraphSafe, DepKind};\n+use rustc::dep_graph::{DepGraphSafe, DepKind};\n+use rustc::ich::StableHashingContext;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use rustc_data_structures::stable_hasher::StableHashingContextProvider;\n \n use super::terms::*;\n use super::terms::VarianceTerm::*;\n@@ -138,6 +140,16 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> StableHashingContextProvider for ConstraintContext<'a, 'tcx> {\n+    type ContextType = StableHashingContext<'tcx>;\n+\n+    fn create_stable_hashing_context(&self) -> Self::ContextType {\n+         self.terms_cx.tcx.create_stable_hashing_context()\n+    }\n+}\n+\n+impl<'a, 'tcx> DepGraphSafe for ConstraintContext<'a, 'tcx> {}\n+\n impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn visit_node_helper(&mut self, id: ast::NodeId) {\n         let tcx = self.terms_cx.tcx;\n@@ -151,14 +163,14 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         // on dep-graph management.\n         let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n         tcx.dep_graph.with_task(dep_node,\n-                                AssertDepGraphSafe(self),\n+                                self,\n                                 def_id,\n                                 visit_item_task);\n \n-        fn visit_item_task<'a, 'tcx>(ccx: AssertDepGraphSafe<&mut ConstraintContext<'a, 'tcx>>,\n+        fn visit_item_task<'a, 'tcx>(ccx: &mut ConstraintContext<'a, 'tcx>,\n                                      def_id: DefId)\n         {\n-            ccx.0.build_constraints_for_item(def_id);\n+            ccx.build_constraints_for_item(def_id);\n         }\n     }\n "}, {"sha": "3a4dcc3217388706c32784990768c985521216e2", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -474,9 +474,9 @@ impl hir::print::PpAnn for InlinedConst {\n }\n \n pub fn print_inlined_const(cx: &DocContext, did: DefId) -> String {\n-    let body = cx.tcx.extern_const_body(did);\n+    let body = cx.tcx.extern_const_body(did).body;\n     let inlined = InlinedConst {\n-        nested_bodies: cx.tcx.item_body_nested_bodies(did)\n+        nested_bodies: cx.tcx.item_body_nested_bodies(did).nested_bodies\n     };\n     hir::print::to_string(&inlined, |s| s.print_expr(&body.value))\n }"}, {"sha": "73ab286f185aa318b77e48545ada76109a40c9be", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -1835,7 +1835,8 @@ impl Clean<Type> for hir::Ty {\n                     for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n                         if let Some(lt) = provided_params.lifetimes.get(i).cloned() {\n                             if !lt.is_elided() {\n-                                lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n+                                let lt_def_id = cx.tcx.hir.local_def_id(lt_param.lifetime.id);\n+                                lt_substs.insert(lt_def_id, lt.clean(cx));\n                             }\n                         }\n                     }"}, {"sha": "1663e5ad142864072a8ca9f534fe4c72e7940540", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -24,7 +24,7 @@ use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_metadata::cstore::CStore;\n \n-use syntax::{ast, codemap};\n+use syntax::codemap;\n use syntax::feature_gate::UnstableFeatures;\n use syntax::fold::Folder;\n use errors;\n@@ -65,7 +65,7 @@ pub struct DocContext<'a, 'tcx: 'a> {\n     /// Table type parameter definition -> substituted type\n     pub ty_substs: RefCell<FxHashMap<Def, clean::Type>>,\n     /// Table node id of lifetime parameter definition -> substituted lifetime\n-    pub lt_substs: RefCell<FxHashMap<ast::NodeId, clean::Lifetime>>,\n+    pub lt_substs: RefCell<FxHashMap<DefId, clean::Lifetime>>,\n }\n \n impl<'a, 'tcx> DocContext<'a, 'tcx> {\n@@ -77,7 +77,7 @@ impl<'a, 'tcx> DocContext<'a, 'tcx> {\n     /// the substitutions for a type alias' RHS.\n     pub fn enter_alias<F, R>(&self,\n                              ty_substs: FxHashMap<Def, clean::Type>,\n-                             lt_substs: FxHashMap<ast::NodeId, clean::Lifetime>,\n+                             lt_substs: FxHashMap<DefId, clean::Lifetime>,\n                              f: F) -> R\n     where F: FnOnce() -> R {\n         let (old_tys, old_lts) =\n@@ -175,7 +175,7 @@ pub fn run_core(search_paths: SearchPaths,\n \n     let arena = DroplessArena::new();\n     let arenas = GlobalArenas::new();\n-    let hir_map = hir_map::map_crate(&mut hir_forest, defs);\n+    let hir_map = hir_map::map_crate(&mut hir_forest, &defs);\n     let output_filenames = driver::build_output_filenames(&input,\n                                                           &None,\n                                                           &None,"}, {"sha": "bf0fe5f6e9d98958d9d6383a1edf73db61981734", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -2671,8 +2671,9 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 let ns_id = derive_id(format!(\"{}.{}\",\n                                               field.name.as_ref().unwrap(),\n                                               ItemType::StructField.name_space()));\n-                write!(w, \"<span id='{id}' class=\\\"{item_type}\\\">\n-                           <span id='{ns_id}' class='invisible'>\n+                write!(w, \"<span id=\\\"{id}\\\" class=\\\"{item_type} small-section-header\\\">\n+                           <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\n+                           <span id=\\\"{ns_id}\\\" class='invisible'>\n                            <code>{name}: {ty}</code>\n                            </span></span>\",\n                        item_type = ItemType::StructField,\n@@ -2793,7 +2794,8 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             let ns_id = derive_id(format!(\"{}.{}\",\n                                           variant.name.as_ref().unwrap(),\n                                           ItemType::Variant.name_space()));\n-            write!(w, \"<span id='{id}' class='variant'>\\\n+            write!(w, \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n+                       <a href=\\\"#{id}\\\" class=\\\"anchor field\\\"></a>\\\n                        <span id='{ns_id}' class='invisible'><code>{name}\",\n                    id = id,\n                    ns_id = ns_id,"}, {"sha": "5727d3c5f70684199febcb145071f44c0ee972a7", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -288,6 +288,7 @@ nav.sub {\n \n .docblock {\n \tmargin-left: 24px;\n+\tposition: relative;\n }\n \n .content .out-of-band {\n@@ -456,8 +457,13 @@ a {\n }\n .anchor {\n \tdisplay: none;\n+\tposition: absolute;\n+\tleft: -25px;\n }\n-.anchor:after {\n+.anchor.field {\n+\tleft: -20px;\n+}\n+.anchor:before {\n \tcontent: '\\2002\\00a7\\2002';\n }\n \n@@ -625,7 +631,9 @@ a.test-arrow:hover{\n \ttext-decoration: none;\n }\n \n-.section-header:hover a:after {\n+.section-header:hover a:before {\n+\tposition: absolute;\n+\tleft: -25px;\n \tcontent: '\\2002\\00a7\\2002';\n }\n \n@@ -817,6 +825,7 @@ span.since {\n \tposition: absolute;\n \tleft: -1px;\n \tmargin-top: 7px;\n+\tz-index: 1;\n }\n \n .tooltip {\n@@ -853,3 +862,7 @@ span.since {\n \tborder-style: solid;\n \tborder-color: transparent black transparent transparent;\n }\n+\n+pre.rust {\n+\tposition: relative;\n+}"}, {"sha": "36efc37a8095c8927be6881b32a88bb513967bdf", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -124,7 +124,7 @@ pub fn run(input: &str,\n                                        render_type);\n \n     {\n-        let map = hir::map::map_crate(&mut hir_forest, defs);\n+        let map = hir::map::map_crate(&mut hir_forest, &defs);\n         let krate = map.krate();\n         let mut hir_collector = HirCollector {\n             sess: &sess,"}, {"sha": "6d64ea0d50332d49ab3e7927287edad9ec238821", "filename": "src/libstd/error.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -53,6 +53,7 @@\n \n use alloc::allocator;\n use any::TypeId;\n+use borrow::Cow;\n use cell;\n use char;\n use fmt::{self, Debug, Display};\n@@ -217,6 +218,20 @@ impl<'a> From<&'a str> for Box<Error> {\n     }\n }\n \n+#[stable(feature = \"cow_box_error\", since = \"1.22.0\")]\n+impl<'a, 'b> From<Cow<'b, str>> for Box<Error + Send + Sync + 'a> {\n+    fn from(err: Cow<'b, str>) -> Box<Error + Send + Sync + 'a> {\n+        From::from(String::from(err))\n+    }\n+}\n+\n+#[stable(feature = \"cow_box_error\", since = \"1.22.0\")]\n+impl<'a> From<Cow<'a, str>> for Box<Error> {\n+    fn from(err: Cow<'a, str>) -> Box<Error> {\n+        From::from(String::from(err))\n+    }\n+}\n+\n #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n impl Error for ! {\n     fn description(&self) -> &str { *self }"}, {"sha": "a3eecd46e90514ae408818e50d2fe018d87181fa", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -242,6 +242,7 @@\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n+#![feature(align_offset)]\n #![feature(asm)]\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]"}, {"sha": "50f998eb4867dc087476835f2feef4bd25f6056e", "filename": "src/libstd/sys_common/memchr.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibstd%2Fsys_common%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibstd%2Fsys_common%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fmemchr.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -65,15 +65,12 @@ pub mod fallback {\n         let usize_bytes = mem::size_of::<usize>();\n \n         // search up to an aligned boundary\n-        let align = (ptr as usize) & (usize_bytes- 1);\n-        let mut offset;\n-        if align > 0 {\n-            offset = cmp::min(usize_bytes - align, len);\n+        let mut offset = ptr.align_offset(usize_bytes);\n+        if offset > 0 {\n+            offset = cmp::min(offset, len);\n             if let Some(index) = text[..offset].iter().position(|elt| *elt == x) {\n                 return Some(index);\n             }\n-        } else {\n-            offset = 0;\n         }\n \n         // search the body of the text"}, {"sha": "30887b16c602856bde066cc562343172aad1eb68", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -287,6 +287,8 @@ impl Builder {\n     /// Names the thread-to-be. Currently the name is used for identification\n     /// only in panic messages.\n     ///\n+    /// The name must not contain null bytes (`\\0`).\n+    ///\n     /// For more information about named threads, see\n     /// [this module-level documentation][naming-threads].\n     ///\n@@ -355,6 +357,10 @@ impl Builder {\n     /// [`io::Result`]: ../../std/io/type.Result.html\n     /// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n     ///\n+    /// # Panics\n+    ///\n+    /// Panics if a thread name was set and it contained null bytes.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -941,6 +947,7 @@ pub struct Thread {\n \n impl Thread {\n     // Used only internally to construct a thread object without spawning\n+    // Panics if the name contains nuls.\n     pub(crate) fn new(name: Option<String>) -> Thread {\n         let cname = name.map(|n| {\n             CString::new(n).expect(\"thread name may not contain interior null bytes\")"}, {"sha": "496be8b3eb23e93b22b0f51c9ed9366dcf8a8242", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -1221,7 +1221,8 @@ pub enum ImplItemKind {\n     Macro(Mac),\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n+         PartialOrd, Ord)]\n pub enum IntTy {\n     Is,\n     I8,\n@@ -1274,7 +1275,8 @@ impl IntTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n+         PartialOrd, Ord)]\n pub enum UintTy {\n     Us,\n     U8,\n@@ -1324,7 +1326,8 @@ impl fmt::Display for UintTy {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy,\n+         PartialOrd, Ord)]\n pub enum FloatTy {\n     F32,\n     F64,"}, {"sha": "7f4e2b0f17652b2dd8110f4d20b4c314d761c097", "filename": "src/test/incremental/ich_method_call_trait_scope.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0701b37d97d08da7074ece7a7dcb4449498f4bfa/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs?ref=0701b37d97d08da7074ece7a7dcb4449498f4bfa", "patch": "@@ -12,6 +12,7 @@\n // scope.\n \n // revisions: rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n \n@@ -47,13 +48,15 @@ mod mod3 {\n     use Trait2;\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n     fn bar() {\n         ().method();\n     }\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n     #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n     fn baz() {\n         22; // no method call, traits in scope don't matter\n     }"}]}