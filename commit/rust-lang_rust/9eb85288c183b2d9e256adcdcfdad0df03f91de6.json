{"sha": "9eb85288c183b2d9e256adcdcfdad0df03f91de6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYjg1Mjg4YzE4M2IyZDllMjU2YWRjZGNmZGFkMGRmMDNmOTFkZTY=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-09T20:30:43Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-04-09T23:07:32Z"}, "message": "Copyediting for 'variable bindings'", "tree": {"sha": "20638de0512839519bbf34249d42d1fee922332c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20638de0512839519bbf34249d42d1fee922332c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9eb85288c183b2d9e256adcdcfdad0df03f91de6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9eb85288c183b2d9e256adcdcfdad0df03f91de6", "html_url": "https://github.com/rust-lang/rust/commit/9eb85288c183b2d9e256adcdcfdad0df03f91de6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9eb85288c183b2d9e256adcdcfdad0df03f91de6/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e57410cd9254d68684255c0a6f95aaa8af603ddd", "url": "https://api.github.com/repos/rust-lang/rust/commits/e57410cd9254d68684255c0a6f95aaa8af603ddd", "html_url": "https://github.com/rust-lang/rust/commit/e57410cd9254d68684255c0a6f95aaa8af603ddd"}], "stats": {"total": 106, "additions": 57, "deletions": 49}, "files": [{"sha": "d971e557a9a2edba517ad91e859e4b8675f46ea3", "filename": "src/doc/trpl/variable-bindings.md", "status": "modified", "additions": 57, "deletions": 49, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9eb85288c183b2d9e256adcdcfdad0df03f91de6/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/9eb85288c183b2d9e256adcdcfdad0df03f91de6/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvariable-bindings.md?ref=9eb85288c183b2d9e256adcdcfdad0df03f91de6", "patch": "@@ -1,44 +1,48 @@\n % Variable Bindings\n \n-The first thing we'll learn about are *variable bindings*. They look like this:\n+Vitually every non-\u2019Hello World\u2019 Rust program uses *variable bindings*. They\n+look like this:\n \n-```{rust}\n+```rust\n fn main() {\n     let x = 5;\n }\n ```\n \n-Putting `fn main() {` in each example is a bit tedious, so we'll leave that out\n-in the future. If you're following along, make sure to edit your `main()`\n-function, rather than leaving it off. Otherwise, you'll get an error.\n+Putting `fn main() {` in each example is a bit tedious, so we\u2019ll leave that out\n+in the future. If you\u2019re following along, make sure to edit your `main()`\n+function, rather than leaving it off. Otherwise, you\u2019ll get an error.\n \n-In many languages, this is called a *variable*. But Rust's variable bindings\n-have a few tricks up their sleeves. Rust has a very powerful feature called\n-*pattern matching* that we'll get into detail with later, but the left\n-hand side of a `let` expression is a full pattern, not just a variable name.\n-This means we can do things like:\n+In many languages, this is called a *variable*, but Rust\u2019s variable bindings\n+have a few tricks up their sleeves. For example the left-hand side of a `let`\n+expression is a \u2018[pattern][pattern]\u2019, not just a variable name. This means we\n+can do things like:\n \n-```{rust}\n+```rust\n let (x, y) = (1, 2);\n ```\n \n After this expression is evaluated, `x` will be one, and `y` will be two.\n-Patterns are really powerful, but this is about all we can do with them so far.\n-So let's just keep this in the back of our minds as we go forward.\n+Patterns are really powerful, and have [their own section][pattern] in the\n+book. We don\u2019t need those features for now, so we\u2019ll just keep this in the back\n+of our minds as we go forward.\n+\n+[pattern]: patterns.html\n \n Rust is a statically typed language, which means that we specify our types up\n-front. So why does our first example compile? Well, Rust has this thing called\n-*type inference*. If it can figure out what the type of something is, Rust\n-doesn't require you to actually type it out.\n+front, and they\u2019re checked at compile time. So why does our first example\n+compile? Well, Rust has this thing called \u2018type inference\u2019. If it can figure\n+out what the type of something is, Rust doesn\u2019t require you to actually type it\n+out.\n \n We can add the type if we want to, though. Types come after a colon (`:`):\n \n-```{rust}\n+```rust\n let x: i32 = 5;\n ```\n \n-If I asked you to read this out loud to the rest of the class, you'd say \"`x`\n-is a binding with the type `i32` and the value `five`.\"\n+If I asked you to read this out loud to the rest of the class, you\u2019d say \u201c`x`\n+is a binding with the type `i32` and the value `five`.\u201d\n \n In this case we chose to represent `x` as a 32-bit signed integer. Rust has\n many different primitive integer types. They begin with `i` for signed integers\n@@ -48,19 +52,20 @@ bits.\n In future examples, we may annotate the type in a comment. The examples will\n look like this:\n \n-```{rust}\n+```rust\n fn main() {\n     let x = 5; // x: i32\n }\n ```\n \n-Note the similarities between this annotation and the syntax you use with `let`.\n-Including these kinds of comments is not idiomatic Rust, but we'll occasionally\n-include them to help you understand what the types that Rust infers are.\n+Note the similarities between this annotation and the syntax you use with\n+`let`. Including these kinds of comments is not idiomatic Rust, but we'll\n+occasionally include them to help you understand what the types that Rust\n+infers are.\n \n By default, bindings are *immutable*. This code will not compile:\n \n-```{ignore}\n+```rust,ignore\n let x = 5;\n x = 10;\n ```\n@@ -75,62 +80,63 @@ error: re-assignment of immutable variable `x`\n \n If you want a binding to be mutable, you can use `mut`:\n \n-```{rust}\n+```rust\n let mut x = 5; // mut x: i32\n x = 10;\n ```\n \n There is no single reason that bindings are immutable by default, but we can\n-think about it through one of Rust's primary focuses: safety. If you forget to\n+think about it through one of Rust\u2019s primary focuses: safety. If you forget to\n say `mut`, the compiler will catch it, and let you know that you have mutated\n something you may not have intended to mutate. If bindings were mutable by\n default, the compiler would not be able to tell you this. If you _did_ intend\n mutation, then the solution is quite easy: add `mut`.\n \n-There are other good reasons to avoid mutable state when possible, but they're\n+There are other good reasons to avoid mutable state when possible, but they\u2019re\n out of the scope of this guide. In general, you can often avoid explicit\n mutation, and so it is preferable in Rust. That said, sometimes, mutation is\n-what you need, so it's not verboten.\n+what you need, so it\u2019s not verboten.\n \n-Let's get back to bindings. Rust variable bindings have one more aspect that\n+Let\u2019s get back to bindings. Rust variable bindings have one more aspect that\n differs from other languages: bindings are required to be initialized with a\n value before you're allowed to use them.\n \n-Let's try it out. Change your `src/main.rs` file to look like this:\n+Let\u2019s try it out. Change your `src/main.rs` file to look like this:\n \n-```{rust}\n+```rust\n fn main() {\n     let x: i32;\n \n     println!(\"Hello world!\");\n }\n ```\n \n-You can use `cargo build` on the command line to build it. You'll get a warning,\n-but it will still print \"Hello, world!\":\n+You can use `cargo build` on the command line to build it. You\u2019ll get a\n+warning, but it will still print \"Hello, world!\":\n \n ```text\n    Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n-src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)] on by default\n+src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]\n+   on by default\n src/main.rs:2     let x: i32;\n                       ^\n ```\n \n-Rust warns us that we never use the variable binding, but since we never use it,\n-no harm, no foul. Things change if we try to actually use this `x`, however. Let's\n-do that. Change your program to look like this:\n+Rust warns us that we never use the variable binding, but since we never use\n+it, no harm, no foul. Things change if we try to actually use this `x`,\n+however. Let\u2019s do that. Change your program to look like this:\n \n-```{rust,ignore}\n+```rust,ignore\n fn main() {\n     let x: i32;\n \n     println!(\"The value of x is: {}\", x);\n }\n ```\n \n-And try to build it. You'll get an error:\n+And try to build it. You\u2019ll get an error:\n \n-```{bash}\n+```bash\n $ cargo build\n    Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)\n src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`\n@@ -144,18 +150,20 @@ error: aborting due to previous error\n Could not compile `hello_world`.\n ```\n \n-Rust will not let us use a value that has not been initialized. Next, let's\n+Rust will not let us use a value that has not been initialized. Next, let\u2019s\n talk about this stuff we've added to `println!`.\n \n If you include two curly braces (`{}`, some call them moustaches...) in your\n string to print, Rust will interpret this as a request to interpolate some sort\n of value. *String interpolation* is a computer science term that means \"stick\n in the middle of a string.\" We add a comma, and then `x`, to indicate that we\n-want `x` to be the value we're interpolating. The comma is used to separate\n-arguments we pass to functions and macros, if you're passing more than one.\n-\n-When you just use the curly braces, Rust will attempt to display the\n-value in a meaningful way by checking out its type. If you want to specify the\n-format in a more detailed manner, there are a [wide number of options\n-available](../std/fmt/index.html). For now, we'll just stick to the default:\n-integers aren't very complicated to print.\n+want `x` to be the value we\u2019re interpolating. The comma is used to separate\n+arguments we pass to functions and macros, if you\u2019re passing more than one.\n+\n+When you just use the curly braces, Rust will attempt to display the value in a\n+meaningful way by checking out its type. If you want to specify the format in a\n+more detailed manner, there are a [wide number of options available][format].\n+For now, we'll just stick to the default: integers aren't very complicated to\n+print.\n+\n+[format]: ../std/fmt/index.html"}]}