{"sha": "443332afaffbd0220452002567a2b61fd0e3fd9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MzMzMmFmYWZmYmQwMjIwNDUyMDAyNTY3YTJiNjFmZDBlM2ZkOWQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-11-03T15:17:33Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-11-03T15:30:04Z"}, "message": "Refactor internal suggestion API", "tree": {"sha": "469b7ba52733921fc97745acb6db16a77855711f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/469b7ba52733921fc97745acb6db16a77855711f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/443332afaffbd0220452002567a2b61fd0e3fd9d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAln8i3wACgkQpp+NIls6\n19mLvBAAqZ14yIAdyQY+8mWLWZ28pHrHqcaLSMQ7qvXvIWxFjtfYNEZPAGdP6X7l\nIiGaWNKpMN7HWRCw3CNbVYj9irx0K+UIoNJh/NO6tG6rIgWEe/qtvD6WCfUcQbwk\nHOxYjMENyEjdc783pda2ZyKRefyKA4GJS8lApSdwXtJeV+Xq9a54TnmkjPvo38Qg\nnkI0/FNakYm8me2EzDBI38kb6Hn6Nv+Dnf7x8o/52s4Yze1NjCx2QqbHbB0Y7pYj\nmiSFVLIM43qwuPdoFp8Qb/12OGFyNqmmmYAdQbzRRVpVBPqzPiYH3w0dg8L6bvd6\nw3rQe2QyN7rIyK3kZrrfFcvFpjTqKBb4B9l5XhDAC64MpRK1nA+ig+FUfnjw2/cP\niES2EWZ/T8XAFkFlph+Yxs0m5lAHL7Lc0289J9xNX3oLSaME6XRc5IjR9vah1fz8\nmnA/o4QpUpM2eu4ksg72eMHNPMp9lm1fKeGO3Bk7LT5BV9dzYX3L+EgMK1CNnH5F\n5SmK4L8cf23pixBRhEwlGsVLpOdCrdh5AIciU2OGhzEZ32t0r1tRN94iQpmjEjiq\nhfPjEFm7ZEg7b28ryEI8PYSDWS6rWCc8dkURWSOKOGWUJ+CH4rGdPdBnp3F47xYz\nB1yfpif5f7k566bumXDFkvpZElzjPYKZUNT7bsNaQt+VwhNfNcM=\n=vN6G\n-----END PGP SIGNATURE-----", "payload": "tree 469b7ba52733921fc97745acb6db16a77855711f\nparent 525b81d570b15df2ed5896f0215baea5c64c650c\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1509722253 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1509723004 +0100\n\nRefactor internal suggestion API\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/443332afaffbd0220452002567a2b61fd0e3fd9d", "html_url": "https://github.com/rust-lang/rust/commit/443332afaffbd0220452002567a2b61fd0e3fd9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/443332afaffbd0220452002567a2b61fd0e3fd9d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "525b81d570b15df2ed5896f0215baea5c64c650c", "url": "https://api.github.com/repos/rust-lang/rust/commits/525b81d570b15df2ed5896f0215baea5c64c650c", "html_url": "https://github.com/rust-lang/rust/commit/525b81d570b15df2ed5896f0215baea5c64c650c"}], "stats": {"total": 243, "additions": 116, "deletions": 127}, "files": [{"sha": "c7e9c8268f0b32d977cf5c33afdde49a1d253901", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/443332afaffbd0220452002567a2b61fd0e3fd9d/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/443332afaffbd0220452002567a2b61fd0e3fd9d/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=443332afaffbd0220452002567a2b61fd0e3fd9d", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use CodeSuggestion;\n+use SubstitutionPart;\n use Substitution;\n use Level;\n use RenderSpan;\n@@ -217,9 +218,11 @@ impl Diagnostic {\n     /// See `CodeSuggestion` for more information.\n     pub fn span_suggestion_short(&mut self, sp: Span, msg: &str, suggestion: String) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n-            substitution_parts: vec![Substitution {\n-                span: sp,\n-                substitutions: vec![suggestion],\n+            substitutions: vec![Substitution {\n+                parts: vec![SubstitutionPart {\n+                    snippet: suggestion,\n+                    span: sp,\n+                }],\n             }],\n             msg: msg.to_owned(),\n             show_code_when_inline: false,\n@@ -245,9 +248,11 @@ impl Diagnostic {\n     /// See `CodeSuggestion` for more information.\n     pub fn span_suggestion(&mut self, sp: Span, msg: &str, suggestion: String) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n-            substitution_parts: vec![Substitution {\n-                span: sp,\n-                substitutions: vec![suggestion],\n+            substitutions: vec![Substitution {\n+                parts: vec![SubstitutionPart {\n+                    snippet: suggestion,\n+                    span: sp,\n+                }],\n             }],\n             msg: msg.to_owned(),\n             show_code_when_inline: true,\n@@ -258,10 +263,12 @@ impl Diagnostic {\n     /// Prints out a message with multiple suggested edits of the code.\n     pub fn span_suggestions(&mut self, sp: Span, msg: &str, suggestions: Vec<String>) -> &mut Self {\n         self.suggestions.push(CodeSuggestion {\n-            substitution_parts: vec![Substitution {\n-                span: sp,\n-                substitutions: suggestions,\n-            }],\n+            substitutions: suggestions.into_iter().map(|snippet| Substitution {\n+                parts: vec![SubstitutionPart {\n+                    snippet,\n+                    span: sp,\n+                }],\n+            }).collect(),\n             msg: msg.to_owned(),\n             show_code_when_inline: true,\n         });"}, {"sha": "63e13c9beeaceb7c5f5480552f272fbde373c458", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/443332afaffbd0220452002567a2b61fd0e3fd9d/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/443332afaffbd0220452002567a2b61fd0e3fd9d/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=443332afaffbd0220452002567a2b61fd0e3fd9d", "patch": "@@ -38,23 +38,23 @@ impl Emitter for EmitterWriter {\n \n         if let Some((sugg, rest)) = db.suggestions.split_first() {\n             if rest.is_empty() &&\n-               // don't display multipart suggestions as labels\n-               sugg.substitution_parts.len() == 1 &&\n                // don't display multi-suggestions as labels\n-               sugg.substitutions() == 1 &&\n+               sugg.substitutions.len() == 1 &&\n+               // don't display multipart suggestions as labels\n+               sugg.substitutions[0].parts.len() == 1 &&\n                // don't display long messages as labels\n                sugg.msg.split_whitespace().count() < 10 &&\n                // don't display multiline suggestions as labels\n-               sugg.substitution_parts[0].substitutions[0].find('\\n').is_none() {\n-                let substitution = &sugg.substitution_parts[0].substitutions[0];\n+               !sugg.substitutions[0].parts[0].snippet.contains('\\n') {\n+                let substitution = &sugg.substitutions[0].parts[0].snippet;\n                 let msg = if substitution.len() == 0 || !sugg.show_code_when_inline {\n                     // This substitution is only removal or we explicitly don't want to show the\n                     // code inline, don't show it\n                     format!(\"help: {}\", sugg.msg)\n                 } else {\n                     format!(\"help: {}: `{}`\", sugg.msg, substitution)\n                 };\n-                primary_span.push_span_label(sugg.substitution_spans().next().unwrap(), msg);\n+                primary_span.push_span_label(sugg.substitutions[0].parts[0].span, msg);\n             } else {\n                 // if there are multiple suggestions, print them all in full\n                 // to be consistent. We could try to figure out if we can\n@@ -1098,30 +1098,34 @@ impl EmitterWriter {\n                                -> io::Result<()> {\n         use std::borrow::Borrow;\n \n-        let primary_sub = &suggestion.substitution_parts[0];\n         if let Some(ref cm) = self.cm {\n             let mut buffer = StyledBuffer::new();\n \n-            let lines = cm.span_to_lines(primary_sub.span).unwrap();\n-\n-            assert!(!lines.lines.is_empty());\n-\n+            // Render the suggestion message\n             buffer.append(0, &level.to_string(), Style::Level(level.clone()));\n             buffer.append(0, \": \", Style::HeaderMsg);\n             self.msg_to_buffer(&mut buffer,\n-                               &[(suggestion.msg.to_owned(), Style::NoStyle)],\n-                               max_line_num_len,\n-                               \"suggestion\",\n-                               Some(Style::HeaderMsg));\n+                            &[(suggestion.msg.to_owned(), Style::NoStyle)],\n+                            max_line_num_len,\n+                            \"suggestion\",\n+                            Some(Style::HeaderMsg));\n \n+            // Render the replacements for each suggestion\n             let suggestions = suggestion.splice_lines(cm.borrow());\n-            let span_start_pos = cm.lookup_char_pos(primary_sub.span.lo());\n-            let line_start = span_start_pos.line;\n-            draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n+\n             let mut row_num = 2;\n-            for (&(ref complete, show_underline), ref sub) in suggestions\n-                    .iter().zip(primary_sub.substitutions.iter()).take(MAX_SUGGESTIONS)\n-            {\n+            for &(ref complete, ref parts) in suggestions.iter().take(MAX_SUGGESTIONS) {\n+                let show_underline = parts.len() == 1\n+                    && complete.lines().count() == 1\n+                    && parts[0].snippet.trim() != complete.trim();\n+\n+                let lines = cm.span_to_lines(parts[0].span).unwrap();\n+\n+                assert!(!lines.lines.is_empty());\n+\n+                let span_start_pos = cm.lookup_char_pos(parts[0].span.lo());\n+                let line_start = span_start_pos.line;\n+                draw_col_separator_no_space(&mut buffer, 1, max_line_num_len + 1);\n                 let mut line_pos = 0;\n                 // Only show underline if there's a single suggestion and it is a single line\n                 let mut lines = complete.lines();\n@@ -1136,21 +1140,21 @@ impl EmitterWriter {\n                     buffer.append(row_num, line, Style::NoStyle);\n                     line_pos += 1;\n                     row_num += 1;\n-                    // Only show an underline in the suggestions if the suggestion is not the\n-                    // entirety of the code being shown and the displayed code is not multiline.\n-                    if show_underline {\n-                        draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n-                        let sub_len = sub.trim_right().len();\n-                        let underline_start = span_start_pos.col.0;\n-                        let underline_end = span_start_pos.col.0 + sub_len;\n-                        for p in underline_start..underline_end {\n-                            buffer.putc(row_num,\n-                                        max_line_num_len + 3 + p,\n-                                        '^',\n-                                        Style::UnderlinePrimary);\n-                        }\n-                        row_num += 1;\n+                }\n+                // Only show an underline in the suggestions if the suggestion is not the\n+                // entirety of the code being shown and the displayed code is not multiline.\n+                if show_underline {\n+                    draw_col_separator(&mut buffer, row_num, max_line_num_len + 1);\n+                    let sub_len = parts[0].snippet.len();\n+                    let underline_start = span_start_pos.col.0;\n+                    let underline_end = span_start_pos.col.0 + sub_len;\n+                    for p in underline_start..underline_end {\n+                        buffer.putc(row_num,\n+                                    max_line_num_len + 3 + p,\n+                                    '^',\n+                                    Style::UnderlinePrimary);\n                     }\n+                    row_num += 1;\n                 }\n \n                 // if we elided some lines, add an ellipsis"}, {"sha": "7bf64d2432571ae8fc02f0b2c95177d1ebd8a9fa", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 55, "deletions": 77, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/443332afaffbd0220452002567a2b61fd0e3fd9d/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/443332afaffbd0220452002567a2b61fd0e3fd9d/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=443332afaffbd0220452002567a2b61fd0e3fd9d", "patch": "@@ -76,26 +76,34 @@ pub struct CodeSuggestion {\n     ///\n     /// ```\n     /// vec![\n-    ///     (0..3, vec![\"a\", \"x\"]),\n-    ///     (4..7, vec![\"b\", \"y\"]),\n+    ///     Substitution { parts: vec![(0..3, \"a\"), (4..7, \"b\")] },\n+    ///     Substitution { parts: vec![(0..3, \"x\"), (4..7, \"y\")] },\n     /// ]\n     /// ```\n     ///\n     /// or by replacing the entire span:\n     ///\n     /// ```\n-    /// vec![(0..7, vec![\"a.b\", \"x.y\"])]\n+    /// vec![\n+    ///     Substitution { parts: vec![(0..7, \"a.b\")] },\n+    ///     Substitution { parts: vec![(0..7, \"x.y\")] },\n+    /// ]\n     /// ```\n-    pub substitution_parts: Vec<Substitution>,\n+    pub substitutions: Vec<Substitution>,\n     pub msg: String,\n     pub show_code_when_inline: bool,\n }\n \n #[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n /// See the docs on `CodeSuggestion::substitutions`\n pub struct Substitution {\n+    pub parts: Vec<SubstitutionPart>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct SubstitutionPart {\n     pub span: Span,\n-    pub substitutions: Vec<String>,\n+    pub snippet: String,\n }\n \n pub trait CodeMapper {\n@@ -109,18 +117,8 @@ pub trait CodeMapper {\n }\n \n impl CodeSuggestion {\n-    /// Returns the number of substitutions\n-    fn substitutions(&self) -> usize {\n-        self.substitution_parts[0].substitutions.len()\n-    }\n-\n-    /// Returns the number of substitutions\n-    fn substitution_spans<'a>(&'a self) -> impl Iterator<Item = Span> + 'a {\n-        self.substitution_parts.iter().map(|sub| sub.span)\n-    }\n-\n-    /// Returns the assembled code suggestions and wether they should be shown with an underline.\n-    pub fn splice_lines(&self, cm: &CodeMapper) -> Vec<(String, bool)> {\n+    /// Returns the assembled code suggestions and whether they should be shown with an underline.\n+    pub fn splice_lines(&self, cm: &CodeMapper) -> Vec<(String, Vec<SubstitutionPart>)> {\n         use syntax_pos::{CharPos, Loc, Pos};\n \n         fn push_trailing(buf: &mut String,\n@@ -142,60 +140,42 @@ impl CodeSuggestion {\n             }\n         }\n \n-        if self.substitution_parts.is_empty() {\n-            return vec![(String::new(), false)];\n-        }\n-\n-        let mut primary_spans: Vec<_> = self.substitution_parts\n-            .iter()\n-            .map(|sub| (sub.span, &sub.substitutions))\n-            .collect();\n-\n-        // Assumption: all spans are in the same file, and all spans\n-        // are disjoint. Sort in ascending order.\n-        primary_spans.sort_by_key(|sp| sp.0.lo());\n-\n-        // Find the bounding span.\n-        let lo = primary_spans.iter().map(|sp| sp.0.lo()).min().unwrap();\n-        let hi = primary_spans.iter().map(|sp| sp.0.hi()).min().unwrap();\n-        let bounding_span = Span::new(lo, hi, NO_EXPANSION);\n-        let lines = cm.span_to_lines(bounding_span).unwrap();\n-        assert!(!lines.lines.is_empty());\n-\n-        // To build up the result, we do this for each span:\n-        // - push the line segment trailing the previous span\n-        //   (at the beginning a \"phantom\" span pointing at the start of the line)\n-        // - push lines between the previous and current span (if any)\n-        // - if the previous and current span are not on the same line\n-        //   push the line segment leading up to the current span\n-        // - splice in the span substitution\n-        //\n-        // Finally push the trailing line segment of the last span\n-        let fm = &lines.file;\n-        let mut prev_hi = cm.lookup_char_pos(bounding_span.lo());\n-        prev_hi.col = CharPos::from_usize(0);\n-\n-        let mut prev_line = fm.get_line(lines.lines[0].line_index);\n-        let mut bufs = vec![(String::new(), false); self.substitutions()];\n-\n-        for (sp, substitutes) in primary_spans {\n-            let cur_lo = cm.lookup_char_pos(sp.lo());\n-            for (&mut (ref mut buf, ref mut underline), substitute) in bufs.iter_mut()\n-                                                                           .zip(substitutes) {\n+        assert!(!self.substitutions.is_empty());\n+\n+        self.substitutions.iter().cloned().map(|mut substitution| {\n+            // Assumption: all spans are in the same file, and all spans\n+            // are disjoint. Sort in ascending order.\n+            substitution.parts.sort_by_key(|part| part.span.lo());\n+\n+            // Find the bounding span.\n+            let lo = substitution.parts.iter().map(|part| part.span.lo()).min().unwrap();\n+            let hi = substitution.parts.iter().map(|part| part.span.hi()).min().unwrap();\n+            let bounding_span = Span::new(lo, hi, NO_EXPANSION);\n+            let lines = cm.span_to_lines(bounding_span).unwrap();\n+            assert!(!lines.lines.is_empty());\n+\n+            // To build up the result, we do this for each span:\n+            // - push the line segment trailing the previous span\n+            //   (at the beginning a \"phantom\" span pointing at the start of the line)\n+            // - push lines between the previous and current span (if any)\n+            // - if the previous and current span are not on the same line\n+            //   push the line segment leading up to the current span\n+            // - splice in the span substitution\n+            //\n+            // Finally push the trailing line segment of the last span\n+            let fm = &lines.file;\n+            let mut prev_hi = cm.lookup_char_pos(bounding_span.lo());\n+            prev_hi.col = CharPos::from_usize(0);\n+\n+            let mut prev_line = fm.get_line(lines.lines[0].line_index);\n+            let mut buf = String::new();\n+\n+            for part in &substitution.parts {\n+                let cur_lo = cm.lookup_char_pos(part.span.lo());\n                 if prev_hi.line == cur_lo.line {\n-                    push_trailing(buf, prev_line.as_ref(), &prev_hi, Some(&cur_lo));\n-\n-                    // Only show an underline in the suggestions if the suggestion is not the\n-                    // entirety of the code being shown and the displayed code is not multiline.\n-                    if prev_line.as_ref().unwrap().trim().len() > 0\n-                        && !substitute.ends_with('\\n')\n-                        && substitute.lines().count() == 1\n-                    {\n-                        *underline = true;\n-                    }\n+                    push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, Some(&cur_lo));\n                 } else {\n-                    *underline = false;\n-                    push_trailing(buf, prev_line.as_ref(), &prev_hi, None);\n+                    push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, None);\n                     // push lines between the previous and current span (if any)\n                     for idx in prev_hi.line..(cur_lo.line - 1) {\n                         if let Some(line) = fm.get_line(idx) {\n@@ -207,22 +187,20 @@ impl CodeSuggestion {\n                         buf.push_str(&cur_line[..cur_lo.col.to_usize()]);\n                     }\n                 }\n-                buf.push_str(substitute);\n+                buf.push_str(&part.snippet);\n+                prev_hi = cm.lookup_char_pos(part.span.hi());\n+                prev_line = fm.get_line(prev_hi.line - 1);\n             }\n-            prev_hi = cm.lookup_char_pos(sp.hi());\n-            prev_line = fm.get_line(prev_hi.line - 1);\n-        }\n-        for &mut (ref mut buf, _) in &mut bufs {\n             // if the replacement already ends with a newline, don't print the next line\n             if !buf.ends_with('\\n') {\n-                push_trailing(buf, prev_line.as_ref(), &prev_hi, None);\n+                push_trailing(&mut buf, prev_line.as_ref(), &prev_hi, None);\n             }\n             // remove trailing newlines\n             while buf.ends_with('\\n') {\n                 buf.pop();\n             }\n-        }\n-        bufs\n+            (buf, substitution.parts)\n+        }).collect()\n     }\n }\n "}, {"sha": "4f06238a7cf8f31f134c0bf34ba78d31aa806a58", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/443332afaffbd0220452002567a2b61fd0e3fd9d/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/443332afaffbd0220452002567a2b61fd0e3fd9d/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=443332afaffbd0220452002567a2b61fd0e3fd9d", "patch": "@@ -278,17 +278,17 @@ impl DiagnosticSpan {\n \n     fn from_suggestion(suggestion: &CodeSuggestion, je: &JsonEmitter)\n                        -> Vec<DiagnosticSpan> {\n-        suggestion.substitution_parts\n+        suggestion.substitutions\n                       .iter()\n                       .flat_map(|substitution| {\n-                          substitution.substitutions.iter().map(move |suggestion| {\n+                          substitution.parts.iter().map(move |suggestion| {\n                               let span_label = SpanLabel {\n-                                  span: substitution.span,\n+                                  span: suggestion.span,\n                                   is_primary: true,\n                                   label: None,\n                               };\n                               DiagnosticSpan::from_span_label(span_label,\n-                                                              Some(suggestion),\n+                                                              Some(&suggestion.snippet),\n                                                               je)\n                           })\n                       })"}, {"sha": "8de00af6baf37901224e6fc5932177e2163cf198", "filename": "src/test/ui/block-result/unexpected-return-on-unit.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/443332afaffbd0220452002567a2b61fd0e3fd9d/src%2Ftest%2Fui%2Fblock-result%2Funexpected-return-on-unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/443332afaffbd0220452002567a2b61fd0e3fd9d/src%2Ftest%2Fui%2Fblock-result%2Funexpected-return-on-unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Funexpected-return-on-unit.stderr?ref=443332afaffbd0220452002567a2b61fd0e3fd9d", "patch": "@@ -13,7 +13,7 @@ help: try adding a semicolon\n help: try adding a return type\n    |\n 18 | fn bar() -> usize {\n-   |          ^^^^^^^^\n+   |          ^^^^^^^^^\n \n error: aborting due to previous error\n "}]}