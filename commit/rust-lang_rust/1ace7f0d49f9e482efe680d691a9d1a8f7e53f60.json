{"sha": "1ace7f0d49f9e482efe680d691a9d1a8f7e53f60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhY2U3ZjBkNDlmOWU0ODJlZmU2ODBkNjkxYTlkMWE4ZjdlNTNmNjA=", "commit": {"author": {"name": "Wang Xuerui", "email": "idontknw.wang@gmail.com", "date": "2016-06-05T12:39:05Z"}, "committer": {"name": "Wang Xuerui", "email": "idontknw.wang@gmail.com", "date": "2016-07-13T19:10:44Z"}, "message": "syntax_ext: format: resolve named arguments early\n\nConverts named argument references into indices, right after\nverification as suggested by @alexcrichton. This drastically simplifies\nthe whole process!", "tree": {"sha": "9d3aa2c61edf101de77b0de074a6ee8cb9843d43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d3aa2c61edf101de77b0de074a6ee8cb9843d43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ace7f0d49f9e482efe680d691a9d1a8f7e53f60", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXhpI0AAoJEHg5bO9pIxDsNkcP/i/UlAQhBFj/aonL0bEBDQe8\n21gIofZ2+ct/GP8+EyY4ZdJaRXaXw3762vkfJaq4r56GrKH+LEVHqPZnDCxUl0ml\ntArZ+IlhMl/ihEe5NRfkV5MD3yqGMI1tJB8/paAPRUBQoA1K7507fEPid1a+894F\njReNYqmvKZLRHFEPyUw7KkIzXh3AyYSNW2TMYahMgAh0XCHTcNxODxyx1s1AnLC+\neZmxcwIMBp5s4dHJrQvfNCM5EV2YZ6iOm6wqDPzTkNzj1w6XO0//eykNYHNkUSLg\nshZXZFHiZVksd/pruvpPmgv5ui6N0YCx6MuJb4e3V41ckGuujUVBik6rBm6DZx2k\nzF5HI2BTcJ/HR4C7PutytJOK9M2j9hyIlF2DduKRuHSBy9rumpGGk1lgToVDc+bq\ndKsyw/826G7bwb19Tk54hF8ofwNfo/ERETjgnTTGzRQm8oti4HUk69FNi7/1Aj55\n5dSfvb6d6ZINcucNItyezExnFPPmBpSSOvt/Ae5I8my873i8VZjddhhGi+3GtvgX\n/5NtOEoKt3nGBJqVqmIFMC4tlU7aK4r5uskiCzw0I/1el6/qizITChzCIJb9a+tv\nxfNkVpPLvnQ+1DTWJONARLR9meuY2wrCeUsVtp9+QX3ZldkyjcEw1uldyN3jMyA/\nHNII1/ib5/KW8OQ5z5vI\n=PT3p\n-----END PGP SIGNATURE-----", "payload": "tree 9d3aa2c61edf101de77b0de074a6ee8cb9843d43\nparent 0e2a96321a368c62cf98e73c67507a9bcdded01e\nauthor Wang Xuerui <idontknw.wang@gmail.com> 1465130345 +0800\ncommitter Wang Xuerui <idontknw.wang@gmail.com> 1468437044 +0800\n\nsyntax_ext: format: resolve named arguments early\n\nConverts named argument references into indices, right after\nverification as suggested by @alexcrichton. This drastically simplifies\nthe whole process!\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ace7f0d49f9e482efe680d691a9d1a8f7e53f60", "html_url": "https://github.com/rust-lang/rust/commit/1ace7f0d49f9e482efe680d691a9d1a8f7e53f60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ace7f0d49f9e482efe680d691a9d1a8f7e53f60/comments", "author": {"login": "xen0n", "id": 1175567, "node_id": "MDQ6VXNlcjExNzU1Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/1175567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xen0n", "html_url": "https://github.com/xen0n", "followers_url": "https://api.github.com/users/xen0n/followers", "following_url": "https://api.github.com/users/xen0n/following{/other_user}", "gists_url": "https://api.github.com/users/xen0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/xen0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xen0n/subscriptions", "organizations_url": "https://api.github.com/users/xen0n/orgs", "repos_url": "https://api.github.com/users/xen0n/repos", "events_url": "https://api.github.com/users/xen0n/events{/privacy}", "received_events_url": "https://api.github.com/users/xen0n/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xen0n", "id": 1175567, "node_id": "MDQ6VXNlcjExNzU1Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/1175567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xen0n", "html_url": "https://github.com/xen0n", "followers_url": "https://api.github.com/users/xen0n/followers", "following_url": "https://api.github.com/users/xen0n/following{/other_user}", "gists_url": "https://api.github.com/users/xen0n/gists{/gist_id}", "starred_url": "https://api.github.com/users/xen0n/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xen0n/subscriptions", "organizations_url": "https://api.github.com/users/xen0n/orgs", "repos_url": "https://api.github.com/users/xen0n/repos", "events_url": "https://api.github.com/users/xen0n/events{/privacy}", "received_events_url": "https://api.github.com/users/xen0n/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e2a96321a368c62cf98e73c67507a9bcdded01e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e2a96321a368c62cf98e73c67507a9bcdded01e", "html_url": "https://github.com/rust-lang/rust/commit/0e2a96321a368c62cf98e73c67507a9bcdded01e"}], "stats": {"total": 147, "additions": 62, "deletions": 85}, "files": [{"sha": "2635213f58e603367b8eecc5e2cde371f8c2074f", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 62, "deletions": 85, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/1ace7f0d49f9e482efe680d691a9d1a8f7e53f60/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ace7f0d49f9e482efe680d691a9d1a8f7e53f60/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=1ace7f0d49f9e482efe680d691a9d1a8f7e53f60", "patch": "@@ -46,15 +46,12 @@ struct Context<'a, 'b:'a> {\n \n     /// Parsed argument expressions and the types that we've found so far for\n     /// them.\n+    /// Named expressions are resolved early, and are appended to the end of\n+    /// argument expressions.\n     args: Vec<P<ast::Expr>>,\n     arg_types: Vec<Option<ArgumentType>>,\n-    /// Parsed named expressions and the types that we've found for them so far.\n-    /// Note that we keep a side-array of the ordering of the named arguments\n-    /// found to be sure that we can translate them in the same order that they\n-    /// were declared in.\n-    names: HashMap<String, P<ast::Expr>>,\n-    name_types: HashMap<String, ArgumentType>,\n-    name_ordering: Vec<String>,\n+    /// Map from named arguments to their resolved indices.\n+    names: HashMap<String, usize>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n@@ -66,8 +63,6 @@ struct Context<'a, 'b:'a> {\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n-    name_positions: HashMap<String, usize>,\n-\n     /// Current position of the implicit positional arg pointer, as if it\n     /// still existed in this phase of processing.\n     /// Used only for `all_pieces_simple` tracking in `trans_piece`.\n@@ -80,15 +75,12 @@ struct Context<'a, 'b:'a> {\n ///\n /// If parsing succeeds, the return value is:\n /// ```ignore\n-/// Some((fmtstr, unnamed arguments, ordering of named arguments,\n-///       named arguments))\n+/// Some((fmtstr, parsed arguments, index map for named arguments))\n /// ```\n fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-              -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, Vec<String>,\n-                         HashMap<String, P<ast::Expr>>)> {\n-    let mut args = Vec::new();\n-    let mut names = HashMap::<String, P<ast::Expr>>::new();\n-    let mut order = Vec::new();\n+              -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, HashMap<String, usize>)> {\n+    let mut args = Vec::<P<ast::Expr>>::new();\n+    let mut names = HashMap::<String, usize>::new();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -132,20 +124,45 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                 ecx.struct_span_err(e.span,\n                                     &format!(\"duplicate argument named `{}`\",\n                                              name))\n-                    .span_note(prev.span, \"previously here\")\n+                    .span_note(args[*prev].span, \"previously here\")\n                     .emit();\n                 continue;\n             }\n-            order.push(name.to_string());\n-            names.insert(name.to_string(), e);\n+\n+            // Resolve names into slots early.\n+            // Since all the positional args are already seen at this point\n+            // if the input is valid, we can simply append to the positional\n+            // args. And remember the names.\n+            let slot = args.len();\n+            names.insert(name.to_string(), slot);\n+            args.push(e);\n         } else {\n             args.push(panictry!(p.parse_expr()));\n         }\n     }\n-    Some((fmtstr, args, order, names))\n+    Some((fmtstr, args, names))\n }\n \n impl<'a, 'b> Context<'a, 'b> {\n+    fn resolve_name_inplace(&self, p: &mut parse::Piece) {\n+        let lookup = |s| *self.names.get(s).unwrap_or(&0);\n+\n+        match *p {\n+            parse::String(_) => {}\n+            parse::NextArgument(ref mut arg) => {\n+                if let parse::ArgumentNamed(s) = arg.position {\n+                    arg.position = parse::ArgumentIs(lookup(s));\n+                }\n+                if let parse::CountIsName(s) = arg.format.width {\n+                    arg.format.width = parse::CountIsParam(lookup(s));\n+                }\n+                if let parse::CountIsName(s) = arg.format.precision {\n+                    arg.format.precision = parse::CountIsParam(lookup(s));\n+                }\n+            }\n+        }\n+    }\n+\n     /// Verifies one piece of a parse string. All errors are not emitted as\n     /// fatal so we can continue giving errors about this and possibly other\n     /// format strings.\n@@ -214,24 +231,16 @@ impl<'a, 'b> Context<'a, 'b> {\n             }\n \n             Named(name) => {\n-                let span = match self.names.get(&name) {\n-                    Some(e) => e.span,\n+                let idx = match self.names.get(&name) {\n+                    Some(e) => *e,\n                     None => {\n                         let msg = format!(\"there is no argument named `{}`\", name);\n                         self.ecx.span_err(self.fmtsp, &msg[..]);\n                         return;\n                     }\n                 };\n-                self.verify_same(span, &ty, self.name_types.get(&name));\n-                if !self.name_types.contains_key(&name) {\n-                    self.name_types.insert(name.clone(), ty);\n-                }\n-                // Assign this named argument a slot in the arguments array if\n-                // it hasn't already been assigned a slot.\n-                if !self.name_positions.contains_key(&name) {\n-                    let slot = self.name_positions.len();\n-                    self.name_positions.insert(name, slot);\n-                }\n+                // Treat as positional arg.\n+                self.verify_arg_type(Exact(idx), ty)\n             }\n         }\n     }\n@@ -301,14 +310,8 @@ impl<'a, 'b> Context<'a, 'b> {\n                 count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n             }\n             parse::CountImplied => count(\"Implied\", None),\n-            parse::CountIsName(n) => {\n-                let i = match self.name_positions.get(n) {\n-                    Some(&i) => i,\n-                    None => 0, // error already emitted elsewhere\n-                };\n-                let i = i + self.args.len();\n-                count(\"Param\", Some(self.ecx.expr_usize(sp, i)))\n-            }\n+            // should never be the case, names are already resolved\n+            parse::CountIsName(_) => panic!(\"should never happen\"),\n         }\n     }\n \n@@ -348,16 +351,9 @@ impl<'a, 'b> Context<'a, 'b> {\n                     match arg.position {\n                         parse::ArgumentIs(i) => pos(\"At\", Some(i)),\n \n-                        // Named arguments are converted to positional arguments\n-                        // at the end of the list of arguments\n-                        parse::ArgumentNamed(n) => {\n-                            let i = match self.name_positions.get(n) {\n-                                Some(&i) => i,\n-                                None => 0, // error already emitted elsewhere\n-                            };\n-                            let i = i + self.args.len();\n-                            pos(\"At\", Some(i))\n-                        }\n+                        // should never be the case, because names are already\n+                        // resolved.\n+                        parse::ArgumentNamed(_) => panic!(\"should never happen\"),\n                     }\n                 };\n \n@@ -448,7 +444,6 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// to\n     fn into_expr(mut self) -> P<ast::Expr> {\n         let mut locals = Vec::new();\n-        let mut names = vec![None; self.name_positions.len()];\n         let mut pats = Vec::new();\n         let mut heads = Vec::new();\n \n@@ -485,29 +480,11 @@ impl<'a, 'b> Context<'a, 'b> {\n                                             self.ecx.expr_ident(e.span, name)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));\n         }\n-        for name in &self.name_ordering {\n-            let e = match self.names.remove(name) {\n-                Some(e) => e,\n-                None => continue\n-            };\n-            let arg_ty = match self.name_types.get(name) {\n-                Some(ty) => ty,\n-                None => continue\n-            };\n-\n-            let lname = self.ecx.ident_of(&format!(\"__arg{}\",\n-                                                  *name));\n-            pats.push(self.ecx.pat_ident(DUMMY_SP, lname));\n-            names[*self.name_positions.get(name).unwrap()] =\n-                Some(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty,\n-                                         self.ecx.expr_ident(e.span, lname)));\n-            heads.push(self.ecx.expr_addr_of(e.span, e));\n-        }\n \n         // Now create a vector containing all the arguments\n-        let args = locals.into_iter().chain(names.into_iter().map(|a| a.unwrap()));\n+        let args = locals.into_iter().collect();\n \n-        let args_array = self.ecx.expr_vec(self.fmtsp, args.collect());\n+        let args_array = self.ecx.expr_vec(self.fmtsp, args);\n \n         // Constructs an AST equivalent to:\n         //\n@@ -605,9 +582,9 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n                                -> Box<base::MacResult+'cx> {\n \n     match parse_args(ecx, sp, tts) {\n-        Some((efmt, args, order, names)) => {\n+        Some((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt,\n-                                                      args, order, names))\n+                                                      args, names))\n         }\n         None => DummyResult::expr(sp)\n     }\n@@ -618,8 +595,7 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt, sp: Span,\n pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n-                                    name_ordering: Vec<String>,\n-                                    names: HashMap<String, P<ast::Expr>>)\n+                                    names: HashMap<String, usize>)\n                                     -> P<ast::Expr> {\n     let arg_types: Vec<_> = (0..args.len()).map(|_| None).collect();\n     let macsp = ecx.call_site();\n@@ -632,9 +608,6 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n         args: args,\n         arg_types: arg_types,\n         names: names,\n-        name_positions: HashMap::new(),\n-        name_types: HashMap::new(),\n-        name_ordering: name_ordering,\n         curarg: 0,\n         literal: String::new(),\n         pieces: Vec::new(),\n@@ -655,9 +628,10 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n \n     loop {\n         match parser.next() {\n-            Some(piece) => {\n+            Some(mut piece) => {\n                 if !parser.errors.is_empty() { break }\n                 cx.verify_piece(&piece);\n+                cx.resolve_name_inplace(&mut piece);\n                 pieces.push(piece);\n             }\n             None => break\n@@ -683,14 +657,17 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n \n     // Make sure that all arguments were used and all arguments have types.\n+    let num_pos_args = cx.args.len() - cx.names.len();\n     for (i, ty) in cx.arg_types.iter().enumerate() {\n         if ty.is_none() {\n-            cx.ecx.span_err(cx.args[i].span, \"argument never used\");\n-        }\n-    }\n-    for (name, e) in &cx.names {\n-        if !cx.name_types.contains_key(name) {\n-            cx.ecx.span_err(e.span, \"named argument never used\");\n+            let msg = if i >= num_pos_args {\n+                // named argument\n+                \"named argument never used\"\n+            } else {\n+                // positional argument\n+                \"argument never used\"\n+            };\n+            cx.ecx.span_err(cx.args[i].span, msg);\n         }\n     }\n "}]}