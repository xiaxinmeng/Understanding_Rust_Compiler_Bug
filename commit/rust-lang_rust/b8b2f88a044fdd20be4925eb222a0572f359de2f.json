{"sha": "b8b2f88a044fdd20be4925eb222a0572f359de2f", "node_id": "C_kwDOAAsO6NoAKGI4YjJmODhhMDQ0ZmRkMjBiZTQ5MjVlYjIyMmEwNTcyZjM1OWRlMmY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-08-31T05:58:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-31T05:58:00Z"}, "message": "Rollup merge of #101100 - compiler-errors:generalize-call-suggestions, r=petrochenkov\n\nMake call suggestions more general and more accurate\n\nCleans up some suggestions that have to do with adding `()` to make typeck happy.\n\n1. Drive-by rename of `expr_t` to `base_ty` since it's the type of the `base_expr`\n1. Autoderef until we get to a callable type in `suggest_fn_call`.\n1. Don't erroneously suggest calling constructor when a method/field does not exist on it.\n1. Suggest calling a method receiver if its function output has a method (e.g. `fn.method()` => `fn().method()`)\n1. Extend call suggestions to type parameters, fn pointers, trait objects where possible\n1. Suggest calling in operators too (fixes #101054)\n1. Use `/* {ty} */` as argument placeholder instead of just `_`, which is confusing and makes suggestions look less like `if let` syntax.", "tree": {"sha": "02d970e49d571307c52d391ba951b72fbb1422f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02d970e49d571307c52d391ba951b72fbb1422f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8b2f88a044fdd20be4925eb222a0572f359de2f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjDvhoCRBK7hj4Ov3rIwAAUe4IAAN8Dx/TEbpEp4r2KYSgdDSP\nneb/xF34vn2IJu+Ch2B2Te1RiYUJ58EU1woDDpZaSNNjbFDG75HLaqwdTVCo4C6w\nk6U9OHiLdpPfMIk49vZoWH5A+Nbnq9gxkiCVhmvOdDqgUttPXYs5hWYx5+HJOpfU\nNwndCKhAZW4z5lVYjiXJmDnHmPMSLpYTGej8acWbVlFp3/awx9jBd3jzhU3U51k0\nBwBcgQ33HPOWVa0gvK23tD+eIwV5DhdXZl5Zi+MgqZbMl2FurwUThCoou3am74y+\n8jAacbEQ+0k4LGfaBVS61M4UOhN0hz0drx34oVuO5lVpUESAr0bXNARyr8+JaOY=\n=9/kD\n-----END PGP SIGNATURE-----\n", "payload": "tree 02d970e49d571307c52d391ba951b72fbb1422f3\nparent 78e5d05ea02565ee2ecc8c394137b0ba3e86372e\nparent 1256530643fdd4762de8de5a47041fc2cf700828\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1661925480 +0200\ncommitter GitHub <noreply@github.com> 1661925480 +0200\n\nRollup merge of #101100 - compiler-errors:generalize-call-suggestions, r=petrochenkov\n\nMake call suggestions more general and more accurate\n\nCleans up some suggestions that have to do with adding `()` to make typeck happy.\n\n1. Drive-by rename of `expr_t` to `base_ty` since it's the type of the `base_expr`\n1. Autoderef until we get to a callable type in `suggest_fn_call`.\n1. Don't erroneously suggest calling constructor when a method/field does not exist on it.\n1. Suggest calling a method receiver if its function output has a method (e.g. `fn.method()` => `fn().method()`)\n1. Extend call suggestions to type parameters, fn pointers, trait objects where possible\n1. Suggest calling in operators too (fixes #101054)\n1. Use `/* {ty} */` as argument placeholder instead of just `_`, which is confusing and makes suggestions look less like `if let` syntax.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b2f88a044fdd20be4925eb222a0572f359de2f", "html_url": "https://github.com/rust-lang/rust/commit/b8b2f88a044fdd20be4925eb222a0572f359de2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8b2f88a044fdd20be4925eb222a0572f359de2f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78e5d05ea02565ee2ecc8c394137b0ba3e86372e", "url": "https://api.github.com/repos/rust-lang/rust/commits/78e5d05ea02565ee2ecc8c394137b0ba3e86372e", "html_url": "https://github.com/rust-lang/rust/commit/78e5d05ea02565ee2ecc8c394137b0ba3e86372e"}, {"sha": "1256530643fdd4762de8de5a47041fc2cf700828", "url": "https://api.github.com/repos/rust-lang/rust/commits/1256530643fdd4762de8de5a47041fc2cf700828", "html_url": "https://github.com/rust-lang/rust/commit/1256530643fdd4762de8de5a47041fc2cf700828"}], "stats": {"total": 1025, "additions": 609, "deletions": 416}, "files": [{"sha": "68abdd0bad1ff06165317a28d1f20392b33ba96e", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -1249,9 +1249,13 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags\n-            .treat_err_as_bug\n-            .map_or(false, |c| self.err_count() + self.lint_err_count >= c.get())\n+        self.flags.treat_err_as_bug.map_or(false, |c| {\n+            self.err_count()\n+                + self.lint_err_count\n+                + self.delayed_span_bugs.len()\n+                + self.delayed_good_path_bugs.len()\n+                >= c.get()\n+        })\n     }\n \n     fn print_error_count(&mut self, registry: &Registry) {\n@@ -1407,7 +1411,14 @@ impl HandlerInner {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n-        if self.flags.treat_err_as_bug.map_or(false, |c| self.err_count() + 1 >= c.get()) {\n+        if self.flags.treat_err_as_bug.map_or(false, |c| {\n+            self.err_count()\n+                + self.lint_err_count\n+                + self.delayed_span_bugs.len()\n+                + self.delayed_good_path_bugs.len()\n+                + 1\n+                >= c.get()\n+        }) {\n             // FIXME: don't abort here if report_delayed_bugs is off\n             self.span_bug(sp, msg);\n         }"}, {"sha": "9c6530c8a08438e8afc2eaddced942affe1df3db", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -41,7 +41,8 @@ macro_rules! pluralize {\n /// All suggestions are marked with an `Applicability`. Tools use the applicability of a suggestion\n /// to determine whether it should be automatically applied or if the user should be consulted\n /// before applying the suggestion.\n-#[derive(Copy, Clone, Debug, PartialEq, Hash, Encodable, Decodable, Serialize, Deserialize)]\n+#[derive(Copy, Clone, Debug, Hash, Encodable, Decodable, Serialize, Deserialize)]\n+#[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub enum Applicability {\n     /// The suggestion is definitely what the user intended, or maintains the exact meaning of the code.\n     /// This suggestion should be automatically applied."}, {"sha": "57555433f55b745b54247219bbd1846116c16463", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -844,6 +844,12 @@ impl<'tcx, T: TypeVisitable<'tcx>> TypeVisitable<'tcx> for Vec<T> {\n     }\n }\n \n+impl<'tcx, T: TypeVisitable<'tcx>> TypeVisitable<'tcx> for &[T] {\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        self.iter().try_for_each(|t| t.visit_with(visitor))\n+    }\n+}\n+\n impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n     fn try_fold_with<F: FallibleTypeFolder<'tcx>>(self, folder: &mut F) -> Result<Self, F::Error> {\n         self.try_map_id(|t| t.try_fold_with(folder))"}, {"sha": "f6596950c2a0deb1588da939c3e868914c4dc4e6", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 42, "deletions": 60, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -21,7 +21,6 @@ use crate::errors::{\n };\n use crate::type_error_struct;\n \n-use super::suggest_call_constructor;\n use crate::errors::{AddressOfTemporaryTaken, ReturnStmtOutsideOfFnBody, StructExprNonExhaustive};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n@@ -44,7 +43,7 @@ use rustc_middle::middle::stability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase};\n use rustc_middle::ty::error::TypeError::FieldMisMatch;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, AdtKind, Ty, TypeVisitable};\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n@@ -2141,15 +2140,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         field: Ident,\n     ) -> Ty<'tcx> {\n         debug!(\"check_field(expr: {:?}, base: {:?}, field: {:?})\", expr, base, field);\n-        let expr_t = self.check_expr(base);\n-        let expr_t = self.structurally_resolved_type(base.span, expr_t);\n+        let base_ty = self.check_expr(base);\n+        let base_ty = self.structurally_resolved_type(base.span, base_ty);\n         let mut private_candidate = None;\n-        let mut autoderef = self.autoderef(expr.span, expr_t);\n-        while let Some((base_t, _)) = autoderef.next() {\n-            debug!(\"base_t: {:?}\", base_t);\n-            match base_t.kind() {\n+        let mut autoderef = self.autoderef(expr.span, base_ty);\n+        while let Some((deref_base_ty, _)) = autoderef.next() {\n+            debug!(\"deref_base_ty: {:?}\", deref_base_ty);\n+            match deref_base_ty.kind() {\n                 ty::Adt(base_def, substs) if !base_def.is_enum() => {\n-                    debug!(\"struct named {:?}\", base_t);\n+                    debug!(\"struct named {:?}\", deref_base_ty);\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident_and_get_scope(field, base_def.did(), self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n@@ -2197,23 +2196,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // (#90483) apply adjustments to avoid ExprUseVisitor from\n             // creating erroneous projection.\n             self.apply_adjustments(base, adjustments);\n-            self.ban_private_field_access(expr, expr_t, field, did);\n+            self.ban_private_field_access(expr, base_ty, field, did);\n             return field_ty;\n         }\n \n         if field.name == kw::Empty {\n-        } else if self.method_exists(field, expr_t, expr.hir_id, true) {\n-            self.ban_take_value_of_method(expr, expr_t, field);\n-        } else if !expr_t.is_primitive_ty() {\n-            self.ban_nonexisting_field(field, base, expr, expr_t);\n+        } else if self.method_exists(field, base_ty, expr.hir_id, true) {\n+            self.ban_take_value_of_method(expr, base_ty, field);\n+        } else if !base_ty.is_primitive_ty() {\n+            self.ban_nonexisting_field(field, base, expr, base_ty);\n         } else {\n             let field_name = field.to_string();\n             let mut err = type_error_struct!(\n                 self.tcx().sess,\n                 field.span,\n-                expr_t,\n+                base_ty,\n                 E0610,\n-                \"`{expr_t}` is a primitive type and therefore doesn't have fields\",\n+                \"`{base_ty}` is a primitive type and therefore doesn't have fields\",\n             );\n             let is_valid_suffix = |field: &str| {\n                 if field == \"f32\" || field == \"f64\" {\n@@ -2251,7 +2250,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     None\n                 }\n             };\n-            if let ty::Infer(ty::IntVar(_)) = expr_t.kind()\n+            if let ty::Infer(ty::IntVar(_)) = base_ty.kind()\n                 && let ExprKind::Lit(Spanned {\n                     node: ast::LitKind::Int(_, ast::LitIntType::Unsuffixed),\n                     ..\n@@ -2280,35 +2279,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.tcx().ty_error()\n     }\n \n-    fn check_call_constructor(\n-        &self,\n-        err: &mut Diagnostic,\n-        base: &'tcx hir::Expr<'tcx>,\n-        def_id: DefId,\n-    ) {\n-        if let Some(local_id) = def_id.as_local() {\n-            let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_id);\n-            let node = self.tcx.hir().get(hir_id);\n-\n-            if let Some(fields) = node.tuple_fields() {\n-                let kind = match self.tcx.opt_def_kind(local_id) {\n-                    Some(DefKind::Ctor(of, _)) => of,\n-                    _ => return,\n-                };\n-\n-                suggest_call_constructor(base.span, kind, fields.len(), err);\n-            }\n-        } else {\n-            // The logic here isn't smart but `associated_item_def_ids`\n-            // doesn't work nicely on local.\n-            if let DefKind::Ctor(of, _) = self.tcx.def_kind(def_id) {\n-                let parent_def_id = self.tcx.parent(def_id);\n-                let fields = self.tcx.associated_item_def_ids(parent_def_id);\n-                suggest_call_constructor(base.span, of, fields.len(), err);\n-            }\n-        }\n-    }\n-\n     fn suggest_await_on_field_access(\n         &self,\n         err: &mut Diagnostic,\n@@ -2351,40 +2321,52 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn ban_nonexisting_field(\n         &self,\n-        field: Ident,\n+        ident: Ident,\n         base: &'tcx hir::Expr<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n-        expr_t: Ty<'tcx>,\n+        base_ty: Ty<'tcx>,\n     ) {\n         debug!(\n-            \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, expr_ty={:?}\",\n-            field, base, expr, expr_t\n+            \"ban_nonexisting_field: field={:?}, base={:?}, expr={:?}, base_ty={:?}\",\n+            ident, base, expr, base_ty\n         );\n-        let mut err = self.no_such_field_err(field, expr_t, base.hir_id);\n+        let mut err = self.no_such_field_err(ident, base_ty, base.hir_id);\n \n-        match *expr_t.peel_refs().kind() {\n+        match *base_ty.peel_refs().kind() {\n             ty::Array(_, len) => {\n-                self.maybe_suggest_array_indexing(&mut err, expr, base, field, len);\n+                self.maybe_suggest_array_indexing(&mut err, expr, base, ident, len);\n             }\n             ty::RawPtr(..) => {\n-                self.suggest_first_deref_field(&mut err, expr, base, field);\n+                self.suggest_first_deref_field(&mut err, expr, base, ident);\n             }\n             ty::Adt(def, _) if !def.is_enum() => {\n-                self.suggest_fields_on_recordish(&mut err, def, field, expr.span);\n+                self.suggest_fields_on_recordish(&mut err, def, ident, expr.span);\n             }\n             ty::Param(param_ty) => {\n                 self.point_at_param_definition(&mut err, param_ty);\n             }\n             ty::Opaque(_, _) => {\n-                self.suggest_await_on_field_access(&mut err, field, base, expr_t.peel_refs());\n-            }\n-            ty::FnDef(def_id, _) => {\n-                self.check_call_constructor(&mut err, base, def_id);\n+                self.suggest_await_on_field_access(&mut err, ident, base, base_ty.peel_refs());\n             }\n             _ => {}\n         }\n \n-        if field.name == kw::Await {\n+        self.suggest_fn_call(&mut err, base, base_ty, |output_ty| {\n+            if let ty::Adt(def, _) = output_ty.kind() && !def.is_enum() {\n+                def.non_enum_variant().fields.iter().any(|field| {\n+                    field.ident(self.tcx) == ident\n+                        && field.vis.is_accessible_from(expr.hir_id.owner.to_def_id(), self.tcx)\n+                })\n+            } else if let ty::Tuple(tys) = output_ty.kind()\n+                && let Ok(idx) = ident.as_str().parse::<usize>()\n+            {\n+                idx < tys.len()\n+            } else {\n+                false\n+            }\n+        });\n+\n+        if ident.name == kw::Await {\n             // We know by construction that `<expr>.await` is either on Rust 2015\n             // or results in `ExprKind::Await`. Suggest switching the edition to 2018.\n             err.note(\"to `.await` a `Future`, switch to Rust 2018 or later\");"}, {"sha": "939f4612d44ef6688010343717549e3ce8a0d2a6", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 214, "deletions": 55, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -2,6 +2,7 @@ use super::FnCtxt;\n use crate::astconv::AstConv;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n+use hir::def_id::DefId;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n@@ -61,70 +62,51 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         pointing_at_return_type\n     }\n \n-    /// When encountering an fn-like ctor that needs to unify with a value, check whether calling\n-    /// the ctor would successfully solve the type mismatch and if so, suggest it:\n+    /// When encountering an fn-like type, try accessing the output of the type\n+    /// // and suggesting calling it if it satisfies a predicate (i.e. if the\n+    /// output has a method or a field):\n     /// ```compile_fail,E0308\n     /// fn foo(x: usize) -> usize { x }\n     /// let x: usize = foo;  // suggest calling the `foo` function: `foo(42)`\n     /// ```\n-    fn suggest_fn_call(\n+    pub(crate) fn suggest_fn_call(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'_>,\n-        expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n+        can_satisfy: impl FnOnce(Ty<'tcx>) -> bool,\n     ) -> bool {\n-        let (def_id, output, inputs) = match *found.kind() {\n-            ty::FnDef(def_id, _) => {\n-                let fn_sig = found.fn_sig(self.tcx);\n-                (def_id, fn_sig.output(), fn_sig.inputs().skip_binder().len())\n-            }\n-            ty::Closure(def_id, substs) => {\n-                let fn_sig = substs.as_closure().sig();\n-                (def_id, fn_sig.output(), fn_sig.inputs().skip_binder().len() - 1)\n-            }\n-            ty::Opaque(def_id, substs) => {\n-                let sig = self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n-                    // args tuple will always be substs[1]\n-                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                    {\n-                        Some((\n-                            pred.kind().rebind(proj.term.ty().unwrap()),\n-                            args.len(),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                });\n-                if let Some((output, inputs)) = sig {\n-                    (def_id, output, inputs)\n-                } else {\n-                    return false;\n-                }\n-            }\n-            _ => return false,\n-        };\n-\n-        let output = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, output);\n-        let output = self.normalize_associated_types_in(expr.span, output);\n-        if !output.is_ty_var() && self.can_coerce(output, expected) {\n-            let (sugg_call, mut applicability) = match inputs {\n+        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(expr, found)\n+            else { return false; };\n+        if can_satisfy(output) {\n+            let (sugg_call, mut applicability) = match inputs.len() {\n                 0 => (\"\".to_string(), Applicability::MachineApplicable),\n                 1..=4 => (\n-                    (0..inputs).map(|_| \"_\").collect::<Vec<_>>().join(\", \"),\n-                    Applicability::MachineApplicable,\n+                    inputs\n+                        .iter()\n+                        .map(|ty| {\n+                            if ty.is_suggestable(self.tcx, false) {\n+                                format!(\"/* {ty} */\")\n+                            } else {\n+                                \"\".to_string()\n+                            }\n+                        })\n+                        .collect::<Vec<_>>()\n+                        .join(\", \"),\n+                    Applicability::HasPlaceholders,\n                 ),\n-                _ => (\"...\".to_string(), Applicability::HasPlaceholders),\n+                _ => (\"/* ... */\".to_string(), Applicability::HasPlaceholders),\n             };\n \n-            let msg = match self.tcx.def_kind(def_id) {\n-                DefKind::Fn => \"call this function\",\n-                DefKind::Closure | DefKind::OpaqueTy => \"call this closure\",\n-                DefKind::Ctor(CtorOf::Struct, _) => \"instantiate this tuple struct\",\n-                DefKind::Ctor(CtorOf::Variant, _) => \"instantiate this tuple variant\",\n-                _ => \"call this function\",\n+            let msg = match def_id_or_name {\n+                DefIdOrName::DefId(def_id) => match self.tcx.def_kind(def_id) {\n+                    DefKind::Ctor(CtorOf::Struct, _) => \"instantiate this tuple struct\".to_string(),\n+                    DefKind::Ctor(CtorOf::Variant, _) => {\n+                        \"instantiate this tuple variant\".to_string()\n+                    }\n+                    kind => format!(\"call this {}\", kind.descr(def_id)),\n+                },\n+                DefIdOrName::Name(name) => format!(\"call this {name}\"),\n             };\n \n             let sugg = match expr.kind {\n@@ -161,6 +143,179 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         false\n     }\n \n+    fn extract_callable_info(\n+        &self,\n+        expr: &Expr<'_>,\n+        found: Ty<'tcx>,\n+    ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n+        // Autoderef is useful here because sometimes we box callables, etc.\n+        let Some((def_id_or_name, output, inputs)) = self.autoderef(expr.span, found).silence_errors().find_map(|(found, _)| {\n+            match *found.kind() {\n+                ty::FnPtr(fn_sig) =>\n+                    Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs())),\n+                ty::FnDef(def_id, _) => {\n+                    let fn_sig = found.fn_sig(self.tcx);\n+                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n+                }\n+                ty::Closure(def_id, substs) => {\n+                    let fn_sig = substs.as_closure().sig();\n+                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n+                }\n+                ty::Opaque(def_id, substs) => {\n+                    self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n+                        if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::DefId(def_id),\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                pred.kind().rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                ty::Dynamic(data, _) => {\n+                    data.iter().find_map(|pred| {\n+                        if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n+                        && Some(proj.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        // for existential projection, substs are shifted over by 1\n+                        && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::Name(\"trait object\"),\n+                                pred.rebind(proj.term.ty().unwrap()),\n+                                pred.rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                ty::Param(param) => {\n+                    let def_id = self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx).def_id;\n+                    self.tcx.predicates_of(self.body_id.owner).predicates.iter().find_map(|(pred, _)| {\n+                        if let ty::PredicateKind::Projection(proj) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.item_def_id) == self.tcx.lang_items().fn_once_output()\n+                        && proj.projection_ty.self_ty() == found\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::DefId(def_id),\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                pred.kind().rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                _ => None,\n+            }\n+        }) else { return None; };\n+\n+        let output = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, output);\n+        let inputs = inputs\n+            .skip_binder()\n+            .iter()\n+            .map(|ty| {\n+                self.replace_bound_vars_with_fresh_vars(\n+                    expr.span,\n+                    infer::FnCall,\n+                    inputs.rebind(*ty),\n+                )\n+            })\n+            .collect();\n+\n+        // We don't want to register any extra obligations, which should be\n+        // implied by wf, but also because that would possibly result in\n+        // erroneous errors later on.\n+        let infer::InferOk { value: output, obligations: _ } =\n+            self.normalize_associated_types_in_as_infer_ok(expr.span, output);\n+\n+        if output.is_ty_var() { None } else { Some((def_id_or_name, output, inputs)) }\n+    }\n+\n+    pub fn suggest_two_fn_call(\n+        &self,\n+        err: &mut Diagnostic,\n+        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        lhs_ty: Ty<'tcx>,\n+        rhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_ty: Ty<'tcx>,\n+        can_satisfy: impl FnOnce(Ty<'tcx>, Ty<'tcx>) -> bool,\n+    ) -> bool {\n+        let Some((_, lhs_output_ty, lhs_inputs)) = self.extract_callable_info(lhs_expr, lhs_ty)\n+            else { return false; };\n+        let Some((_, rhs_output_ty, rhs_inputs)) = self.extract_callable_info(rhs_expr, rhs_ty)\n+            else { return false; };\n+\n+        if can_satisfy(lhs_output_ty, rhs_output_ty) {\n+            let mut sugg = vec![];\n+            let mut applicability = Applicability::MachineApplicable;\n+\n+            for (expr, inputs) in [(lhs_expr, lhs_inputs), (rhs_expr, rhs_inputs)] {\n+                let (sugg_call, this_applicability) = match inputs.len() {\n+                    0 => (\"\".to_string(), Applicability::MachineApplicable),\n+                    1..=4 => (\n+                        inputs\n+                            .iter()\n+                            .map(|ty| {\n+                                if ty.is_suggestable(self.tcx, false) {\n+                                    format!(\"/* {ty} */\")\n+                                } else {\n+                                    \"/* value */\".to_string()\n+                                }\n+                            })\n+                            .collect::<Vec<_>>()\n+                            .join(\", \"),\n+                        Applicability::HasPlaceholders,\n+                    ),\n+                    _ => (\"/* ... */\".to_string(), Applicability::HasPlaceholders),\n+                };\n+\n+                applicability = applicability.max(this_applicability);\n+\n+                match expr.kind {\n+                    hir::ExprKind::Call(..)\n+                    | hir::ExprKind::Path(..)\n+                    | hir::ExprKind::Index(..)\n+                    | hir::ExprKind::Lit(..) => {\n+                        sugg.extend([(expr.span.shrink_to_hi(), format!(\"({sugg_call})\"))]);\n+                    }\n+                    hir::ExprKind::Closure { .. } => {\n+                        // Might be `{ expr } || { bool }`\n+                        applicability = Applicability::MaybeIncorrect;\n+                        sugg.extend([\n+                            (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                            (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n+                        ]);\n+                    }\n+                    _ => {\n+                        sugg.extend([\n+                            (expr.span.shrink_to_lo(), \"(\".to_string()),\n+                            (expr.span.shrink_to_hi(), format!(\")({sugg_call})\")),\n+                        ]);\n+                    }\n+                }\n+            }\n+\n+            err.multipart_suggestion_verbose(\n+                format!(\"use parentheses to call these\"),\n+                sugg,\n+                applicability,\n+            );\n+\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     pub fn suggest_deref_ref_or_into(\n         &self,\n         err: &mut Diagnostic,\n@@ -178,12 +333,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             } else {\n                 err.span_suggestion(sp, &msg, suggestion, applicability);\n             }\n-        } else if let (ty::FnDef(def_id, ..), true) =\n-            (&found.kind(), self.suggest_fn_call(err, expr, expected, found))\n+        } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n+            && let ty::FnDef(def_id, ..) = &found.kind()\n+            && let Some(sp) = self.tcx.hir().span_if_local(*def_id)\n         {\n-            if let Some(sp) = self.tcx.hir().span_if_local(*def_id) {\n-                err.span_label(sp, format!(\"{found} defined here\"));\n-            }\n+            err.span_label(sp, format!(\"{found} defined here\"));\n         } else if !self.check_for_cast(err, expr, found, expected, expected_ty_expr) {\n             let methods = self.get_conversion_methods(expr.span, expected, found, expr.hir_id);\n             if !methods.is_empty() {\n@@ -911,3 +1065,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n }\n+\n+enum DefIdOrName {\n+    DefId(DefId),\n+    Name(&'static str),\n+}"}, {"sha": "e99782fdc652c5e668064787420e8a96b4d70890", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -31,7 +31,7 @@ use std::cmp::Ordering;\n use std::iter;\n \n use super::probe::{Mode, ProbeScope};\n-use super::{super::suggest_call_constructor, CandidateSource, MethodError, NoMatchData};\n+use super::{CandidateSource, MethodError, NoMatchData};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn is_fn_ty(&self, ty: Ty<'tcx>, span: Span) -> bool {\n@@ -363,44 +363,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     );\n                 }\n \n-                if self.is_fn_ty(rcvr_ty, span) {\n-                    if let SelfSource::MethodCall(expr) = source {\n-                        let suggest = if let ty::FnDef(def_id, _) = rcvr_ty.kind() {\n-                            if let Some(local_id) = def_id.as_local() {\n-                                let hir_id = tcx.hir().local_def_id_to_hir_id(local_id);\n-                                let node = tcx.hir().get(hir_id);\n-                                let fields = node.tuple_fields();\n-                                if let Some(fields) = fields\n-                                    && let Some(DefKind::Ctor(of, _)) = self.tcx.opt_def_kind(local_id) {\n-                                        Some((fields.len(), of))\n-                                } else {\n-                                    None\n-                                }\n-                            } else {\n-                                // The logic here isn't smart but `associated_item_def_ids`\n-                                // doesn't work nicely on local.\n-                                if let DefKind::Ctor(of, _) = tcx.def_kind(def_id) {\n-                                    let parent_def_id = tcx.parent(*def_id);\n-                                    Some((tcx.associated_item_def_ids(parent_def_id).len(), of))\n-                                } else {\n-                                    None\n-                                }\n-                            }\n-                        } else {\n-                            None\n-                        };\n-\n-                        // If the function is a tuple constructor, we recommend that they call it\n-                        if let Some((fields, kind)) = suggest {\n-                            suggest_call_constructor(expr.span, kind, fields, &mut err);\n-                        } else {\n-                            // General case\n-                            err.span_label(\n-                                expr.span,\n-                                \"this is a function, perhaps you wish to call it\",\n-                            );\n-                        }\n-                    }\n+                if let SelfSource::MethodCall(rcvr_expr) = source {\n+                    self.suggest_fn_call(&mut err, rcvr_expr, rcvr_ty, |output_ty| {\n+                        let call_expr = self\n+                            .tcx\n+                            .hir()\n+                            .expect_expr(self.tcx.hir().get_parent_node(rcvr_expr.hir_id));\n+                        let probe = self.lookup_probe(\n+                            span,\n+                            item_name,\n+                            output_ty,\n+                            call_expr,\n+                            ProbeScope::AllTraits,\n+                        );\n+                        probe.is_ok()\n+                    });\n                 }\n \n                 let mut custom_span_label = false;"}, {"sha": "3281dd8298bc3000526cc5bb55fdd577e9235933", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -96,7 +96,6 @@ use check::{check_abi, check_fn, check_mod_item_types};\n pub use diverges::Diverges;\n pub use expectation::Expectation;\n pub use fn_ctxt::*;\n-use hir::def::CtorOf;\n pub use inherited::{Inherited, InheritedBuilder};\n \n use crate::astconv::AstConv;\n@@ -960,31 +959,3 @@ fn has_expected_num_generic_args<'tcx>(\n         generics.count() == expected + if generics.has_self { 1 } else { 0 }\n     })\n }\n-\n-/// Suggests calling the constructor of a tuple struct or enum variant\n-///\n-/// * `snippet` - The snippet of code that references the constructor\n-/// * `span` - The span of the snippet\n-/// * `params` - The number of parameters the constructor accepts\n-/// * `err` - A mutable diagnostic builder to add the suggestion to\n-fn suggest_call_constructor(span: Span, kind: CtorOf, params: usize, err: &mut Diagnostic) {\n-    // Note: tuple-structs don't have named fields, so just use placeholders\n-    let args = vec![\"_\"; params].join(\", \");\n-    let applicable = if params > 0 {\n-        Applicability::HasPlaceholders\n-    } else {\n-        // When n = 0, it's an empty-tuple struct/enum variant\n-        // so we trivially know how to construct it\n-        Applicability::MachineApplicable\n-    };\n-    let kind = match kind {\n-        CtorOf::Struct => \"a struct\",\n-        CtorOf::Variant => \"an enum variant\",\n-    };\n-    err.span_label(span, &format!(\"this is the constructor of {kind}\"));\n-    err.multipart_suggestion(\n-        \"call the constructor\",\n-        vec![(span.shrink_to_lo(), \"(\".to_string()), (span.shrink_to_hi(), format!(\")({args})\"))],\n-        applicable,\n-    );\n-}"}, {"sha": "952086e898fc70011fa22d1a19402c0bfab75bb5", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 40, "deletions": 88, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -410,26 +410,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n                         let mut err = struct_span_err!(self.tcx.sess, op.span, E0369, \"{message}\");\n                         if !lhs_expr.span.eq(&rhs_expr.span) {\n-                            self.add_type_neq_err_label(\n-                                &mut err,\n-                                lhs_expr.span,\n-                                lhs_ty,\n-                                rhs_ty,\n-                                rhs_expr,\n-                                op,\n-                                is_assign,\n-                                expected,\n-                            );\n-                            self.add_type_neq_err_label(\n-                                &mut err,\n-                                rhs_expr.span,\n-                                rhs_ty,\n-                                lhs_ty,\n-                                lhs_expr,\n-                                op,\n-                                is_assign,\n-                                expected,\n-                            );\n+                            err.span_label(lhs_expr.span, lhs_ty.to_string());\n+                            err.span_label(rhs_expr.span, rhs_ty.to_string());\n                         }\n                         self.note_unmet_impls_on_type(&mut err, errors);\n                         (err, missing_trait, use_output)\n@@ -468,17 +450,50 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 };\n \n+                let is_compatible = |lhs_ty, rhs_ty| {\n+                    self.lookup_op_method(\n+                        lhs_ty,\n+                        Some(rhs_ty),\n+                        Some(rhs_expr),\n+                        Op::Binary(op, is_assign),\n+                        expected,\n+                    )\n+                    .is_ok()\n+                };\n+\n                 // We should suggest `a + b` => `*a + b` if `a` is copy, and suggest\n                 // `a += b` => `*a += b` if a is a mut ref.\n-                if is_assign == IsAssign::Yes\n-                    && let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty) {\n-                        suggest_deref_binop(lhs_deref_ty);\n+                if !op.span.can_be_used_for_suggestions() {\n+                    // Suppress suggestions when lhs and rhs are not in the same span as the error\n+                } else if is_assign == IsAssign::Yes\n+                    && let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty)\n+                {\n+                    suggest_deref_binop(lhs_deref_ty);\n                 } else if is_assign == IsAssign::No\n-                    && let Ref(_, lhs_deref_ty, _) = lhs_ty.kind() {\n-                    if self.type_is_copy_modulo_regions(self.param_env, *lhs_deref_ty, lhs_expr.span) {\n+                    && let Ref(_, lhs_deref_ty, _) = lhs_ty.kind()\n+                {\n+                    if self.type_is_copy_modulo_regions(\n+                        self.param_env,\n+                        *lhs_deref_ty,\n+                        lhs_expr.span,\n+                    ) {\n                         suggest_deref_binop(*lhs_deref_ty);\n                     }\n+                } else if self.suggest_fn_call(&mut err, lhs_expr, lhs_ty, |lhs_ty| {\n+                    is_compatible(lhs_ty, rhs_ty)\n+                }) || self.suggest_fn_call(&mut err, rhs_expr, rhs_ty, |rhs_ty| {\n+                    is_compatible(lhs_ty, rhs_ty)\n+                }) || self.suggest_two_fn_call(\n+                    &mut err,\n+                    rhs_expr,\n+                    rhs_ty,\n+                    lhs_expr,\n+                    lhs_ty,\n+                    |lhs_ty, rhs_ty| is_compatible(lhs_ty, rhs_ty),\n+                ) {\n+                    // Cool\n                 }\n+\n                 if let Some(missing_trait) = missing_trait {\n                     let mut visitor = TypeParamVisitor(vec![]);\n                     visitor.visit_ty(lhs_ty);\n@@ -548,69 +563,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         (lhs_ty, rhs_ty, return_ty)\n     }\n \n-    /// If one of the types is an uncalled function and calling it would yield the other type,\n-    /// suggest calling the function. Returns `true` if suggestion would apply (even if not given).\n-    fn add_type_neq_err_label(\n-        &self,\n-        err: &mut Diagnostic,\n-        span: Span,\n-        ty: Ty<'tcx>,\n-        other_ty: Ty<'tcx>,\n-        other_expr: &'tcx hir::Expr<'tcx>,\n-        op: hir::BinOp,\n-        is_assign: IsAssign,\n-        expected: Expectation<'tcx>,\n-    ) -> bool /* did we suggest to call a function because of missing parentheses? */ {\n-        err.span_label(span, ty.to_string());\n-        if let FnDef(def_id, _) = *ty.kind() {\n-            if !self.tcx.has_typeck_results(def_id) {\n-                return false;\n-            }\n-            // FIXME: Instead of exiting early when encountering bound vars in\n-            // the function signature, consider keeping the binder here and\n-            // propagating it downwards.\n-            let Some(fn_sig) = self.tcx.fn_sig(def_id).no_bound_vars() else {\n-                return false;\n-            };\n-\n-            let other_ty = if let FnDef(def_id, _) = *other_ty.kind() {\n-                if !self.tcx.has_typeck_results(def_id) {\n-                    return false;\n-                }\n-                // We're emitting a suggestion, so we can just ignore regions\n-                self.tcx.fn_sig(def_id).skip_binder().output()\n-            } else {\n-                other_ty\n-            };\n-\n-            if self\n-                .lookup_op_method(\n-                    fn_sig.output(),\n-                    Some(other_ty),\n-                    Some(other_expr),\n-                    Op::Binary(op, is_assign),\n-                    expected,\n-                )\n-                .is_ok()\n-            {\n-                let (variable_snippet, applicability) = if !fn_sig.inputs().is_empty() {\n-                    (\"( /* arguments */ )\", Applicability::HasPlaceholders)\n-                } else {\n-                    (\"()\", Applicability::MaybeIncorrect)\n-                };\n-\n-                err.span_suggestion_verbose(\n-                    span.shrink_to_hi(),\n-                    \"you might have forgotten to call this function\",\n-                    variable_snippet,\n-                    applicability,\n-                );\n-                return true;\n-            }\n-        }\n-        false\n-    }\n-\n     /// Provide actionable suggestions when trying to add two strings with incorrect types,\n     /// like `&str + &str`, `String + String` and `&str + &String`.\n     ///"}, {"sha": "3f180cf4f1f891ca81f235cb4114acd427a24697", "filename": "src/test/ui/associated-types/substs-ppaux.normal.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.normal.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -11,7 +11,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<'static, 'static, u8>>::bar::<'static, char>}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>();\n    |                                                                         ++\n@@ -29,7 +29,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<'static, 'static>>::bar::<'static, char>}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>();\n    |                                                                          ++\n@@ -47,7 +47,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<'static, 'static, u8>>::baz}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz();\n    |                                                        ++"}, {"sha": "16dd29de2c5438d9a7f695f7656e94d88fc17bf7", "filename": "src/test/ui/associated-types/substs-ppaux.verbose.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.verbose.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.verbose.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fsubsts-ppaux.verbose.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -11,7 +11,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::bar::<ReStatic, char>}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::bar::<'static, char>();\n    |                                                                         ++\n@@ -29,7 +29,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<ReStatic, ReStatic>>::bar::<ReStatic, char>}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u32>>::bar::<'static, char>();\n    |                                                                          ++\n@@ -47,7 +47,7 @@ LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz;\n    |\n    = note: expected unit type `()`\n                 found fn item `fn() {<i8 as Foo<ReStatic, ReStatic, u8>>::baz}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n LL |     let x: () = <i8 as Foo<'static, 'static,  u8>>::baz();\n    |                                                        ++"}, {"sha": "a334bd8562593d9f4550968b107579a0d982a0f6", "filename": "src/test/ui/binop/issue-77910-2.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fissue-77910-2.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -5,6 +5,11 @@ LL |     if foo == y {}\n    |        --- ^^ - _\n    |        |\n    |        for<'r> fn(&'r i32) -> &'r i32 {foo}\n+   |\n+help: use parentheses to call this function\n+   |\n+LL |     if foo(/* &i32 */) == y {}\n+   |           ++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "df838cb11810578e8ec10274324269c48750cf43", "filename": "src/test/ui/fn/fn-compare-mismatch.stderr", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ffn%2Ffn-compare-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ffn%2Ffn-compare-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Ffn-compare-mismatch.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -6,14 +6,10 @@ LL |     let x = f == g;\n    |             |\n    |             fn() {f}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call these\n    |\n-LL |     let x = f() == g;\n-   |              ++\n-help: you might have forgotten to call this function\n-   |\n-LL |     let x = f == g();\n-   |                   ++\n+LL |     let x = f() == g();\n+   |              ++     ++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-compare-mismatch.rs:4:18"}, {"sha": "2a674d3c1d23dea4ee5f1859c779a48fd02bb183", "filename": "src/test/ui/fn/fn-trait-formatting.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ffn%2Ffn-trait-formatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ffn%2Ffn-trait-formatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn%2Ffn-trait-formatting.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -8,6 +8,10 @@ LL |     let _: () = Box::new(|_: isize| {}) as Box<dyn FnOnce(isize)>;\n    |\n    = note: expected unit type `()`\n                  found struct `Box<dyn FnOnce(isize)>`\n+help: use parentheses to call this trait object\n+   |\n+LL |     let _: () = (Box::new(|_: isize| {}) as Box<dyn FnOnce(isize)>)(/* isize */);\n+   |                 +                                                 ++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-trait-formatting.rs:10:17\n@@ -19,6 +23,10 @@ LL |     let _: () = Box::new(|_: isize, isize| {}) as Box<dyn Fn(isize, isize)>\n    |\n    = note: expected unit type `()`\n                  found struct `Box<dyn Fn(isize, isize)>`\n+help: use parentheses to call this trait object\n+   |\n+LL |     let _: () = (Box::new(|_: isize, isize| {}) as Box<dyn Fn(isize, isize)>)(/* isize */, /* isize */);\n+   |                 +                                                           +++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-trait-formatting.rs:14:17"}, {"sha": "49a514a8b4e3461007e609d85d42a5522cdb4a81", "filename": "src/test/ui/functions-closures/fn-help-with-err.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -1,16 +1,28 @@\n // This test case checks the behavior of typeck::check::method::suggest::is_fn on Ty::Error.\n+\n+struct Foo;\n+\n+trait Bar {\n+    //~^ NOTE `Bar` defines an item `bar`, perhaps you need to implement it\n+    //~| NOTE `Bar` defines an item `bar`, perhaps you need to implement it\n+    fn bar(&self) {}\n+}\n+\n+impl Bar for Foo {}\n+\n fn main() {\n     let arc = std::sync::Arc::new(oops);\n     //~^ ERROR cannot find value `oops` in this scope\n     //~| NOTE not found\n-    // The error \"note: this is a function, perhaps you wish to call it\" MUST NOT appear.\n-    arc.blablabla();\n-    //~^ ERROR no method named `blablabla`\n+    arc.bar();\n+    //~^ ERROR no method named `bar`\n     //~| NOTE method not found\n-    let arc2 = std::sync::Arc::new(|| 1);\n-    // The error \"note: this is a function, perhaps you wish to call it\" SHOULD appear\n-    arc2.blablabla();\n-    //~^ ERROR no method named `blablabla`\n+    //~| HELP items from traits can only be used if the trait is implemented and in scope\n+\n+    let arc2 = std::sync::Arc::new(|| Foo);\n+    arc2.bar();\n+    //~^ ERROR no method named `bar`\n     //~| NOTE method not found\n-    //~| NOTE this is a function, perhaps you wish to call it\n+    //~| HELP items from traits can only be used if the trait is implemented and in scope\n+    //~| HELP use parentheses to call this closure\n }"}, {"sha": "2296666219eef2fbb284e11e7699db91b4adb20d", "filename": "src/test/ui/functions-closures/fn-help-with-err.stderr", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Ffn-help-with-err.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -1,22 +1,38 @@\n error[E0425]: cannot find value `oops` in this scope\n-  --> $DIR/fn-help-with-err.rs:3:35\n+  --> $DIR/fn-help-with-err.rs:14:35\n    |\n LL |     let arc = std::sync::Arc::new(oops);\n    |                                   ^^^^ not found in this scope\n \n-error[E0599]: no method named `blablabla` found for struct `Arc<_>` in the current scope\n-  --> $DIR/fn-help-with-err.rs:7:9\n+error[E0599]: no method named `bar` found for struct `Arc<_>` in the current scope\n+  --> $DIR/fn-help-with-err.rs:17:9\n    |\n-LL |     arc.blablabla();\n-   |         ^^^^^^^^^ method not found in `Arc<_>`\n+LL |     arc.bar();\n+   |         ^^^ method not found in `Arc<_>`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+note: `Bar` defines an item `bar`, perhaps you need to implement it\n+  --> $DIR/fn-help-with-err.rs:5:1\n+   |\n+LL | trait Bar {\n+   | ^^^^^^^^^\n \n-error[E0599]: no method named `blablabla` found for struct `Arc<[closure@$DIR/fn-help-with-err.rs:10:36: 10:38]>` in the current scope\n-  --> $DIR/fn-help-with-err.rs:12:10\n+error[E0599]: no method named `bar` found for struct `Arc<[closure@$DIR/fn-help-with-err.rs:22:36: 22:38]>` in the current scope\n+  --> $DIR/fn-help-with-err.rs:23:10\n+   |\n+LL |     arc2.bar();\n+   |          ^^^ method not found in `Arc<[closure@$DIR/fn-help-with-err.rs:22:36: 22:38]>`\n+   |\n+   = help: items from traits can only be used if the trait is implemented and in scope\n+note: `Bar` defines an item `bar`, perhaps you need to implement it\n+  --> $DIR/fn-help-with-err.rs:5:1\n+   |\n+LL | trait Bar {\n+   | ^^^^^^^^^\n+help: use parentheses to call this closure\n    |\n-LL |     arc2.blablabla();\n-   |     ---- ^^^^^^^^^ method not found in `Arc<[closure@$DIR/fn-help-with-err.rs:10:36: 10:38]>`\n-   |     |\n-   |     this is a function, perhaps you wish to call it\n+LL |     arc2().bar();\n+   |         ++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c10a856d83ba8758303350e2694ff012f8445c3b", "filename": "src/test/ui/impl-trait/suggest-calling-rpit-closure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fsuggest-calling-rpit-closure.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -11,7 +11,7 @@ LL | fn opaque() -> impl Fn() -> i32 {\n    |\n    = note:     expected type `i32`\n            found opaque type `impl Fn() -> i32`\n-help: use parentheses to call this closure\n+help: use parentheses to call this opaque type\n    |\n LL |     opaque()()\n    |             ++"}, {"sha": "9ee7654a0885d836fb6c42292af24c1827807681", "filename": "src/test/ui/issues/issue-35241.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35241.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -13,8 +13,8 @@ LL | fn test() -> Foo { Foo }\n              found fn item `fn(u32) -> Foo {Foo}`\n help: use parentheses to instantiate this tuple struct\n    |\n-LL | fn test() -> Foo { Foo(_) }\n-   |                       +++\n+LL | fn test() -> Foo { Foo(/* u32 */) }\n+   |                       +++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "b10273f14bd0338c4a2a6c2c4831e7c92519af7d", "filename": "src/test/ui/issues/issue-57362-1.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57362-1.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -2,9 +2,7 @@ error[E0599]: no method named `f` found for fn pointer `fn(&u8)` in the current\n   --> $DIR/issue-57362-1.rs:20:7\n    |\n LL |     a.f();\n-   |     - ^ method not found in `fn(&u8)`\n-   |     |\n-   |     this is a function, perhaps you wish to call it\n+   |       ^ method not found in `fn(&u8)`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n note: `Trait` defines an item `f`, perhaps you need to implement it"}, {"sha": "e5368ddf1e5760b88b1b071a3319af0939110b6d", "filename": "src/test/ui/issues/issue-59488.stderr", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59488.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -6,7 +6,7 @@ LL |     foo > 12;\n    |     |\n    |     fn() -> i32 {foo}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call this function\n    |\n LL |     foo() > 12;\n    |        ++\n@@ -28,10 +28,10 @@ LL |     bar > 13;\n    |     |\n    |     fn(i64) -> i64 {bar}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call this function\n    |\n-LL |     bar( /* arguments */ ) > 13;\n-   |        +++++++++++++++++++\n+LL |     bar(/* i64 */) > 13;\n+   |        +++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/issue-59488.rs:18:11\n@@ -50,14 +50,10 @@ LL |     foo > foo;\n    |     |\n    |     fn() -> i32 {foo}\n    |\n-help: you might have forgotten to call this function\n+help: use parentheses to call these\n    |\n-LL |     foo() > foo;\n-   |        ++\n-help: you might have forgotten to call this function\n-   |\n-LL |     foo > foo();\n-   |              ++\n+LL |     foo() > foo();\n+   |        ++      ++\n \n error[E0369]: binary operation `>` cannot be applied to type `fn() -> i32 {foo}`\n   --> $DIR/issue-59488.rs:25:9"}, {"sha": "9239385e6436904b5235e8bc657dfa283c9b4077", "filename": "src/test/ui/issues/issue-70724-add_type_neq_err_label-unwrap.stderr", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-70724-add_type_neq_err_label-unwrap.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -8,11 +8,6 @@ LL |     assert_eq!(a, 0);\n    |     {integer}\n    |\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n-help: you might have forgotten to call this function\n-  --> $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-   |\n-LL |                 if !(*left_val() == *right_val) {\n-   |                               ++\n \n error[E0308]: mismatched types\n   --> $DIR/issue-70724-add_type_neq_err_label-unwrap.rs:6:5\n@@ -21,7 +16,7 @@ LL |     assert_eq!(a, 0);\n    |     ^^^^^^^^^^^^^^^^ expected fn item, found integer\n    |\n    = note: expected fn item `fn() -> i32 {a}`\n-                 found type `i32`\n+                 found type `{integer}`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0277]: `fn() -> i32 {a}` doesn't implement `Debug`"}, {"sha": "7cf32775a33ef3363aa23bcf53517798bd7be233", "filename": "src/test/ui/resolve/privacy-enum-ctor.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -329,8 +329,8 @@ LL |         let _: Z = Z::Fn;\n            found fn item `fn(u8) -> Z {Z::Fn}`\n help: use parentheses to instantiate this tuple variant\n    |\n-LL |         let _: Z = Z::Fn(_);\n-   |                         +++\n+LL |         let _: Z = Z::Fn(/* u8 */);\n+   |                         ++++++++++\n \n error[E0618]: expected function, found enum variant `Z::Unit`\n   --> $DIR/privacy-enum-ctor.rs:31:17\n@@ -364,8 +364,8 @@ LL |     let _: E = m::E::Fn;\n            found fn item `fn(u8) -> E {E::Fn}`\n help: use parentheses to instantiate this tuple variant\n    |\n-LL |     let _: E = m::E::Fn(_);\n-   |                        +++\n+LL |     let _: E = m::E::Fn(/* u8 */);\n+   |                        ++++++++++\n \n error[E0618]: expected function, found enum variant `m::E::Unit`\n   --> $DIR/privacy-enum-ctor.rs:47:16\n@@ -399,8 +399,8 @@ LL |     let _: E = E::Fn;\n            found fn item `fn(u8) -> E {E::Fn}`\n help: use parentheses to instantiate this tuple variant\n    |\n-LL |     let _: E = E::Fn(_);\n-   |                     +++\n+LL |     let _: E = E::Fn(/* u8 */);\n+   |                     ++++++++++\n \n error[E0618]: expected function, found enum variant `E::Unit`\n   --> $DIR/privacy-enum-ctor.rs:55:16"}, {"sha": "d19e4596a0cc1ba060c85b4e7757e6978ecea149", "filename": "src/test/ui/suggestions/call-boxed.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let mut x = 1i32;\n+    let y = Box::new(|| 1);\n+    x = y;\n+    //~^ ERROR mismatched types\n+    //~| HELP use parentheses to call this closure\n+}"}, {"sha": "9b619ac9a3f502fcc4983655dec8070c4362bd77", "filename": "src/test/ui/suggestions/call-boxed.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-boxed.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -0,0 +1,20 @@\n+error[E0308]: mismatched types\n+  --> $DIR/call-boxed.rs:4:9\n+   |\n+LL |     let mut x = 1i32;\n+   |                 ---- expected due to this value\n+LL |     let y = Box::new(|| 1);\n+   |                      -- the found closure\n+LL |     x = y;\n+   |         ^ expected `i32`, found struct `Box`\n+   |\n+   = note: expected type `i32`\n+            found struct `Box<[closure@$DIR/call-boxed.rs:3:22: 3:24]>`\n+help: use parentheses to call this closure\n+   |\n+LL |     x = y();\n+   |          ++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "25ced84dd3783e4bed2cc6a842d4f1ef55212142", "filename": "src/test/ui/suggestions/call-on-missing.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -0,0 +1,39 @@\n+struct Foo { i: i32 }\n+\n+impl Foo {\n+    fn bar(&self) {}\n+}\n+\n+fn foo() -> Foo {\n+    Foo { i: 1 }\n+}\n+\n+fn main() {\n+    foo.bar();\n+    //~^ ERROR no method named `bar`\n+    //~| HELP use parentheses to call this function\n+\n+    foo.i;\n+    //~^ ERROR no field `i`\n+    //~| HELP use parentheses to call this function\n+\n+    let callable = Box::new(|| Foo { i: 1 }) as Box<dyn Fn() -> Foo>;\n+\n+    callable.bar();\n+    //~^ ERROR no method named `bar`\n+    //~| HELP use parentheses to call this trait object\n+\n+    callable.i;\n+    //~^ ERROR no field `i`\n+    //~| HELP use parentheses to call this trait object\n+}\n+\n+fn type_param<T: Fn() -> Foo>(t: T) {\n+    t.bar();\n+    //~^ ERROR no method named `bar`\n+    //~| HELP use parentheses to call this type parameter\n+\n+    t.i;\n+    //~^ ERROR no field `i`\n+    //~| HELP use parentheses to call this type parameter\n+}"}, {"sha": "ca9abc7e906891513b16bc1d9e8a94eb0d5d41d2", "filename": "src/test/ui/suggestions/call-on-missing.stderr", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fcall-on-missing.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -0,0 +1,75 @@\n+error[E0599]: no method named `bar` found for fn item `fn() -> Foo {foo}` in the current scope\n+  --> $DIR/call-on-missing.rs:12:9\n+   |\n+LL |     foo.bar();\n+   |         ^^^ method not found in `fn() -> Foo {foo}`\n+   |\n+help: use parentheses to call this function\n+   |\n+LL |     foo().bar();\n+   |        ++\n+\n+error[E0609]: no field `i` on type `fn() -> Foo {foo}`\n+  --> $DIR/call-on-missing.rs:16:9\n+   |\n+LL |     foo.i;\n+   |         ^\n+   |\n+help: use parentheses to call this function\n+   |\n+LL |     foo().i;\n+   |        ++\n+\n+error[E0599]: no method named `bar` found for struct `Box<dyn Fn() -> Foo>` in the current scope\n+  --> $DIR/call-on-missing.rs:22:14\n+   |\n+LL |     callable.bar();\n+   |              ^^^ method not found in `Box<dyn Fn() -> Foo>`\n+   |\n+help: use parentheses to call this trait object\n+   |\n+LL |     callable().bar();\n+   |             ++\n+\n+error[E0609]: no field `i` on type `Box<dyn Fn() -> Foo>`\n+  --> $DIR/call-on-missing.rs:26:14\n+   |\n+LL |     callable.i;\n+   |              ^ unknown field\n+   |\n+help: use parentheses to call this trait object\n+   |\n+LL |     callable().i;\n+   |             ++\n+\n+error[E0599]: no method named `bar` found for type parameter `T` in the current scope\n+  --> $DIR/call-on-missing.rs:32:7\n+   |\n+LL | fn type_param<T: Fn() -> Foo>(t: T) {\n+   |               - method `bar` not found for this type parameter\n+LL |     t.bar();\n+   |       ^^^ method not found in `T`\n+   |\n+help: use parentheses to call this type parameter\n+   |\n+LL |     t().bar();\n+   |      ++\n+\n+error[E0609]: no field `i` on type `T`\n+  --> $DIR/call-on-missing.rs:36:7\n+   |\n+LL | fn type_param<T: Fn() -> Foo>(t: T) {\n+   |               - type parameter 'T' declared here\n+...\n+LL |     t.i;\n+   |       ^\n+   |\n+help: use parentheses to call this type parameter\n+   |\n+LL |     t().i;\n+   |      ++\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0599, E0609.\n+For more information about an error, try `rustc --explain E0599`."}, {"sha": "3c7b895e337e72c8ee20a9e38dbd4f964dcc2d52", "filename": "src/test/ui/suggestions/fn-or-tuple-struct-without-args.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-or-tuple-struct-without-args.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -33,8 +33,8 @@ LL |     let _: usize = foo;\n            found fn item `fn(usize, usize) -> usize {foo}`\n help: use parentheses to call this function\n    |\n-LL |     let _: usize = foo(_, _);\n-   |                       ++++++\n+LL |     let _: usize = foo(/* usize */, /* usize */);\n+   |                       ++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:30:16\n@@ -51,8 +51,8 @@ LL |     let _: S = S;\n              found fn item `fn(usize, usize) -> S {S}`\n help: use parentheses to instantiate this tuple struct\n    |\n-LL |     let _: S = S(_, _);\n-   |                 ++++++\n+LL |     let _: S = S(/* usize */, /* usize */);\n+   |                 ++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:31:20\n@@ -103,10 +103,10 @@ LL |     let _: usize = T::baz;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize, usize) -> usize {<_ as T>::baz}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = T::baz(_, _);\n-   |                          ++++++\n+LL |     let _: usize = T::baz(/* usize */, /* usize */);\n+   |                          ++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:34:20\n@@ -121,10 +121,10 @@ LL |     let _: usize = T::bat;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize) -> usize {<_ as T>::bat}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = T::bat(_);\n-   |                          +++\n+LL |     let _: usize = T::bat(/* usize */);\n+   |                          +++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:35:16\n@@ -141,8 +141,8 @@ LL |     let _: E = E::A;\n            found fn item `fn(usize) -> E {E::A}`\n help: use parentheses to instantiate this tuple variant\n    |\n-LL |     let _: E = E::A(_);\n-   |                    +++\n+LL |     let _: E = E::A(/* usize */);\n+   |                    +++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:37:20\n@@ -157,10 +157,10 @@ LL |     let _: usize = X::baz;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize, usize) -> usize {<X as T>::baz}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::baz(_, _);\n-   |                          ++++++\n+LL |     let _: usize = X::baz(/* usize */, /* usize */);\n+   |                          ++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:38:20\n@@ -175,10 +175,10 @@ LL |     let _: usize = X::bat;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize) -> usize {<X as T>::bat}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::bat(_);\n-   |                          +++\n+LL |     let _: usize = X::bat(/* usize */);\n+   |                          +++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:39:20\n@@ -193,10 +193,10 @@ LL |     let _: usize = X::bax;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize) -> usize {<X as T>::bax}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::bax(_);\n-   |                          +++\n+LL |     let _: usize = X::bax(/* usize */);\n+   |                          +++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:40:20\n@@ -211,10 +211,10 @@ LL |     let _: usize = X::bach;\n    |\n    = note: expected type `usize`\n            found fn item `fn(usize) -> usize {<X as T>::bach}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::bach(_);\n-   |                           +++\n+LL |     let _: usize = X::bach(/* usize */);\n+   |                           +++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:41:20\n@@ -229,10 +229,10 @@ LL |     let _: usize = X::ban;\n    |\n    = note: expected type `usize`\n            found fn item `for<'r> fn(&'r X) -> usize {<X as T>::ban}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::ban(_);\n-   |                          +++\n+LL |     let _: usize = X::ban(/* &X */);\n+   |                          ++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/fn-or-tuple-struct-without-args.rs:42:20\n@@ -247,10 +247,10 @@ LL |     let _: usize = X::bal;\n    |\n    = note: expected type `usize`\n            found fn item `for<'r> fn(&'r X) -> usize {<X as T>::bal}`\n-help: use parentheses to call this function\n+help: use parentheses to call this associated function\n    |\n-LL |     let _: usize = X::bal(_);\n-   |                          +++\n+LL |     let _: usize = X::bal(/* &X */);\n+   |                          ++++++++++\n \n error[E0615]: attempted to take value of method `ban` on type `X`\n   --> $DIR/fn-or-tuple-struct-without-args.rs:43:22"}, {"sha": "a837a7d2d62d178833e6607ad3e12b2ec53fecf5", "filename": "src/test/ui/typeck/issue-29124.stderr", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-29124.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-29124.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-29124.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -2,17 +2,13 @@ error[E0599]: no method named `x` found for fn item `fn() -> Ret {Obj::func}` in\n   --> $DIR/issue-29124.rs:15:15\n    |\n LL |     Obj::func.x();\n-   |     --------- ^ method not found in `fn() -> Ret {Obj::func}`\n-   |     |\n-   |     this is a function, perhaps you wish to call it\n+   |               ^ method not found in `fn() -> Ret {Obj::func}`\n \n error[E0599]: no method named `x` found for fn item `fn() -> Ret {func}` in the current scope\n   --> $DIR/issue-29124.rs:17:10\n    |\n LL |     func.x();\n-   |     ---- ^ method not found in `fn() -> Ret {func}`\n-   |     |\n-   |     this is a function, perhaps you wish to call it\n+   |          ^ method not found in `fn() -> Ret {func}`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "be68ad32ae55bb35e1b097361f86492acee30df5", "filename": "src/test/ui/typeck/issue-87181/empty-tuple-method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -4,7 +4,7 @@ struct Bar<T> {\n \n struct Foo();\n impl Foo {\n-    fn foo() { }\n+    fn foo(&self) { }\n }\n \n fn main() {"}, {"sha": "a18c54a29b52c0e875b580fa15e0b069b5acc6bb", "filename": "src/test/ui/typeck/issue-87181/empty-tuple-method.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fempty-tuple-method.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -2,11 +2,9 @@ error[E0599]: no method named `foo` found for fn item `fn() -> Foo {Foo}` in the\n   --> $DIR/empty-tuple-method.rs:12:15\n    |\n LL |     thing.bar.foo();\n-   |     --------- ^^^ method not found in `fn() -> Foo {Foo}`\n-   |     |\n-   |     this is the constructor of a struct\n+   |               ^^^ method not found in `fn() -> Foo {Foo}`\n    |\n-help: call the constructor\n+help: use parentheses to instantiate this tuple struct\n    |\n LL |     (thing.bar)().foo();\n    |     +         +++"}, {"sha": "d87f99c3c5a193dc3ba7f3382744d43bdf8dced4", "filename": "src/test/ui/typeck/issue-87181/enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.rs?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -6,7 +6,7 @@ enum Foo{\n     Tup()\n }\n impl Foo {\n-    fn foo() { }\n+    fn foo(&self) { }\n }\n \n fn main() {"}, {"sha": "90641410d8e967430f568da85b4507012eb2cd48", "filename": "src/test/ui/typeck/issue-87181/enum-variant.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Fenum-variant.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -2,11 +2,9 @@ error[E0599]: no method named `foo` found for fn item `fn() -> Foo {Foo::Tup}` i\n   --> $DIR/enum-variant.rs:14:15\n    |\n LL |     thing.bar.foo();\n-   |     --------- ^^^ method not found in `fn() -> Foo {Foo::Tup}`\n-   |     |\n-   |     this is the constructor of an enum variant\n+   |               ^^^ method not found in `fn() -> Foo {Foo::Tup}`\n    |\n-help: call the constructor\n+help: use parentheses to instantiate this tuple variant\n    |\n LL |     (thing.bar)().foo();\n    |     +         +++"}, {"sha": "c1ca26ee9af1dc84ca41784e4834b60c2b2f737f", "filename": "src/test/ui/typeck/issue-87181/tuple-field.stderr", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-field.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -2,14 +2,12 @@ error[E0609]: no field `0` on type `fn(char, u16) -> Foo {Foo}`\n   --> $DIR/tuple-field.rs:12:15\n    |\n LL |     thing.bar.0;\n-   |     --------- ^\n-   |     |\n-   |     this is the constructor of a struct\n+   |               ^\n    |\n-help: call the constructor\n+help: use parentheses to instantiate this tuple struct\n    |\n-LL |     (thing.bar)(_, _).0;\n-   |     +         +++++++\n+LL |     (thing.bar)(/* char */, /* u16 */).0;\n+   |     +         ++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "e27c41858d322e181021cf02313543d6a25264e2", "filename": "src/test/ui/typeck/issue-87181/tuple-method.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-87181%2Ftuple-method.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -2,14 +2,7 @@ error[E0599]: no method named `foo` found for fn item `fn(u8, i32) -> Foo {Foo}`\n   --> $DIR/tuple-method.rs:12:15\n    |\n LL |     thing.bar.foo();\n-   |     --------- ^^^ method not found in `fn(u8, i32) -> Foo {Foo}`\n-   |     |\n-   |     this is the constructor of a struct\n-   |\n-help: call the constructor\n-   |\n-LL |     (thing.bar)(_, _).foo();\n-   |     +         +++++++\n+   |               ^^^ method not found in `fn(u8, i32) -> Foo {Foo}`\n \n error: aborting due to previous error\n "}, {"sha": "0d4d87ef47e2b99db2886049828f3ee0ac59997b", "filename": "src/test/ui/typeck/issue-96738.stderr", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-96738.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -2,27 +2,13 @@ error[E0599]: no method named `nonexistent_method` found for fn item `fn(_) -> O\n   --> $DIR/issue-96738.rs:2:10\n    |\n LL |     Some.nonexistent_method();\n-   |     ---- ^^^^^^^^^^^^^^^^^^ method not found in `fn(_) -> Option<_> {Option::<_>::Some}`\n-   |     |\n-   |     this is the constructor of an enum variant\n-   |\n-help: call the constructor\n-   |\n-LL |     (Some)(_).nonexistent_method();\n-   |     +    ++++\n+   |          ^^^^^^^^^^^^^^^^^^ method not found in `fn(_) -> Option<_> {Option::<_>::Some}`\n \n error[E0609]: no field `nonexistent_field` on type `fn(_) -> Option<_> {Option::<_>::Some}`\n   --> $DIR/issue-96738.rs:3:10\n    |\n LL |     Some.nonexistent_field;\n-   |     ---- ^^^^^^^^^^^^^^^^^\n-   |     |\n-   |     this is the constructor of an enum variant\n-   |\n-help: call the constructor\n-   |\n-LL |     (Some)(_).nonexistent_field;\n-   |     +    ++++\n+   |          ^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "e5ca0edd7a91c62826aa111d4be9dada4161bb37", "filename": "src/test/ui/unboxed-closures/unboxed-closures-static-call-wrong-trait.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b8b2f88a044fdd20be4925eb222a0572f359de2f/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funboxed-closures%2Funboxed-closures-static-call-wrong-trait.stderr?ref=b8b2f88a044fdd20be4925eb222a0572f359de2f", "patch": "@@ -2,9 +2,7 @@ error[E0599]: no method named `call` found for closure `[closure@$DIR/unboxed-cl\n   --> $DIR/unboxed-closures-static-call-wrong-trait.rs:7:10\n    |\n LL |     mut_.call((0, ));\n-   |     ---- ^^^^ method not found in `[closure@$DIR/unboxed-closures-static-call-wrong-trait.rs:6:26: 6:29]`\n-   |     |\n-   |     this is a function, perhaps you wish to call it\n+   |          ^^^^ method not found in `[closure@$DIR/unboxed-closures-static-call-wrong-trait.rs:6:26: 6:29]`\n \n error: aborting due to previous error\n "}]}