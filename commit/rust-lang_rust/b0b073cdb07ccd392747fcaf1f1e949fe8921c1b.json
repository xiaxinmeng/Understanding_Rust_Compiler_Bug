{"sha": "b0b073cdb07ccd392747fcaf1f1e949fe8921c1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwYjA3M2NkYjA3Y2NkMzkyNzQ3ZmNhZjFmMWU5NDlmZTg5MjFjMWI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2019-09-27T12:03:09Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2019-09-30T11:30:47Z"}, "message": "Self-Profiling: Refactor SelfProfiler API to be RAII based where possible.", "tree": {"sha": "6e7195ff54e975c8f0779da5d4d84fb5fab3e4df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e7195ff54e975c8f0779da5d4d84fb5fab3e4df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b", "html_url": "https://github.com/rust-lang/rust/commit/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf8491e72ef0d5ea0ef683e9d149408a717545e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf8491e72ef0d5ea0ef683e9d149408a717545e4", "html_url": "https://github.com/rust-lang/rust/commit/bf8491e72ef0d5ea0ef683e9d149408a717545e4"}], "stats": {"total": 354, "additions": 244, "deletions": 110}, "files": [{"sha": "e52f2788e6b22c5b4dd74b1c69114c2abc8cb1b7", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=b0b073cdb07ccd392747fcaf1f1e949fe8921c1b", "patch": "@@ -32,7 +32,7 @@ use syntax::source_map;\n use syntax::parse::{self, ParseSess};\n use syntax::symbol::Symbol;\n use syntax_pos::{MultiSpan, Span};\n-use crate::util::profiling::SelfProfiler;\n+use crate::util::profiling::{SelfProfiler, SelfProfilerRef};\n \n use rustc_target::spec::{PanicStrategy, RelroLevel, Target, TargetTriple};\n use rustc_data_structures::flock;\n@@ -129,7 +129,7 @@ pub struct Session {\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n     /// Used by `-Z self-profile`.\n-    pub self_profiling: Option<Arc<SelfProfiler>>,\n+    pub prof: SelfProfilerRef,\n \n     /// Some measurements that are being gathered during compilation.\n     pub perf_stats: PerfStats,\n@@ -835,24 +835,6 @@ impl Session {\n         }\n     }\n \n-    #[inline(never)]\n-    #[cold]\n-    fn profiler_active<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n-        match &self.self_profiling {\n-            None => bug!(\"profiler_active() called but there was no profiler active\"),\n-            Some(profiler) => {\n-                f(&profiler);\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub fn profiler<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n-        if unlikely!(self.self_profiling.is_some()) {\n-            self.profiler_active(f)\n-        }\n-    }\n-\n     pub fn print_perf_stats(&self) {\n         println!(\n             \"Total time spent computing symbol hashes:      {}\",\n@@ -1257,7 +1239,7 @@ fn build_session_(\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n-        self_profiling: self_profiler,\n+        prof: SelfProfilerRef::new(self_profiler),\n         profile_channel: Lock::new(None),\n         perf_stats: PerfStats {\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),"}, {"sha": "467f4c84ab3df15bd7f491f93f9d3c2bc23da998", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b0b073cdb07ccd392747fcaf1f1e949fe8921c1b", "patch": "@@ -45,6 +45,7 @@ use crate::ty::CanonicalPolyFnSig;\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n+use crate::util::profiling::SelfProfilerRef;\n \n use errors::DiagnosticBuilder;\n use arena::SyncDroplessArena;\n@@ -995,6 +996,8 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub dep_graph: DepGraph,\n \n+    pub prof: SelfProfilerRef,\n+\n     /// Common objects.\n     pub common: Common<'tcx>,\n \n@@ -1225,6 +1228,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             arena: WorkerLocal::new(|_| Arena::default()),\n             interners,\n             dep_graph,\n+            prof: s.prof.clone(),\n             common,\n             types: common_types,\n             lifetimes: common_lifetimes,"}, {"sha": "bd02e7f5a14a16507e6b8b9444b83037d9fcb486", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 237, "deletions": 89, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b0b073cdb07ccd392747fcaf1f1e949fe8921c1b/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=b0b073cdb07ccd392747fcaf1f1e949fe8921c1b", "patch": "@@ -1,9 +1,9 @@\n-use std::borrow::Cow;\n use std::error::Error;\n use std::fs;\n use std::mem::{self, Discriminant};\n use std::path::Path;\n use std::process;\n+use std::sync::Arc;\n use std::thread::ThreadId;\n use std::u32;\n \n@@ -62,6 +62,206 @@ fn thread_id_to_u64(tid: ThreadId) -> u64 {\n     unsafe { mem::transmute::<ThreadId, u64>(tid) }\n }\n \n+\n+/// A reference to the SelfProfiler. It can be cloned and sent across thread\n+/// boundaries at will.\n+#[derive(Clone)]\n+pub struct SelfProfilerRef {\n+    // This field is `None` if self-profiling is disabled for the current\n+    // compilation session.\n+    profiler: Option<Arc<SelfProfiler>>,\n+\n+    // We store the filter mask directly in the reference because that doesn't\n+    // cost anything and allows for filtering with checking if the profiler is\n+    // actually enabled.\n+    event_filter_mask: EventFilter,\n+}\n+\n+impl SelfProfilerRef {\n+\n+    pub fn new(profiler: Option<Arc<SelfProfiler>>) -> SelfProfilerRef {\n+        // If there is no SelfProfiler then the filter mask is set to NONE,\n+        // ensuring that nothing ever tries to actually access it.\n+        let event_filter_mask = profiler\n+            .as_ref()\n+            .map(|p| p.event_filter_mask)\n+            .unwrap_or(EventFilter::NONE);\n+\n+        SelfProfilerRef {\n+            profiler,\n+            event_filter_mask,\n+        }\n+    }\n+\n+    // This shim makes sure that calls only get executed if the filter mask\n+    // lets them pass. It also contains some trickery to make sure that\n+    // code is optimized for non-profiling compilation sessions, i.e. anything\n+    // past the filter check is never inlined so it doesn't clutter the fast\n+    // path.\n+    #[inline(always)]\n+    fn exec<F>(&self, event_filter: EventFilter, f: F) -> TimingGuard<'_>\n+        where F: for<'a> FnOnce(&'a SelfProfiler) -> TimingGuard<'a>\n+    {\n+        #[inline(never)]\n+        fn cold_call<F>(profiler_ref: &SelfProfilerRef, f: F) -> TimingGuard<'_>\n+            where F: for<'a> FnOnce(&'a SelfProfiler) -> TimingGuard<'a>\n+        {\n+            let profiler = profiler_ref.profiler.as_ref().unwrap();\n+            f(&**profiler)\n+        }\n+\n+        if unlikely!(self.event_filter_mask.contains(event_filter)) {\n+            cold_call(self, f)\n+        } else {\n+            TimingGuard::none()\n+        }\n+    }\n+\n+    /// Start profiling a generic activity. Profiling continues until the\n+    /// TimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn generic_activity(&self, event_id: &str) -> TimingGuard<'_> {\n+        self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n+            let event_id = profiler.profiler.alloc_string(event_id);\n+            TimingGuard::start(\n+                profiler,\n+                profiler.generic_activity_event_kind,\n+                event_id\n+            )\n+        })\n+    }\n+\n+    /// Start profiling a generic activity. Profiling continues until\n+    /// `generic_activity_end` is called. The RAII-based `generic_activity`\n+    /// usually is the better alternative.\n+    #[inline(always)]\n+    pub fn generic_activity_start(&self, event_id: &str) {\n+        self.non_guard_generic_event(\n+            |profiler| profiler.generic_activity_event_kind,\n+            |profiler| profiler.profiler.alloc_string(event_id),\n+            EventFilter::GENERIC_ACTIVITIES,\n+            TimestampKind::Start,\n+        );\n+    }\n+\n+    /// End profiling a generic activity that was started with\n+    /// `generic_activity_start`. The RAII-based `generic_activity` usually is\n+    /// the better alternative.\n+    #[inline(always)]\n+    pub fn generic_activity_end(&self, event_id: &str) {\n+        self.non_guard_generic_event(\n+            |profiler| profiler.generic_activity_event_kind,\n+            |profiler| profiler.profiler.alloc_string(event_id),\n+            EventFilter::GENERIC_ACTIVITIES,\n+            TimestampKind::End,\n+        );\n+    }\n+\n+    /// Start profiling a query provider. Profiling continues until the\n+    /// TimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn query_provider(&self, query_name: QueryName) -> TimingGuard<'_> {\n+        self.exec(EventFilter::QUERY_PROVIDERS, |profiler| {\n+            let event_id = SelfProfiler::get_query_name_string_id(query_name);\n+            TimingGuard::start(profiler, profiler.query_event_kind, event_id)\n+        })\n+    }\n+\n+    /// Record a query in-memory cache hit.\n+    #[inline(always)]\n+    pub fn query_cache_hit(&self, query_name: QueryName) {\n+        self.non_guard_query_event(\n+            |profiler| profiler.query_cache_hit_event_kind,\n+            query_name,\n+            EventFilter::QUERY_CACHE_HITS,\n+            TimestampKind::Instant,\n+        );\n+    }\n+\n+    /// Start profiling a query being blocked on a concurrent execution.\n+    /// Profiling continues until `query_blocked_end` is called.\n+    #[inline(always)]\n+    pub fn query_blocked_start(&self, query_name: QueryName) {\n+        self.non_guard_query_event(\n+            |profiler| profiler.query_blocked_event_kind,\n+            query_name,\n+            EventFilter::QUERY_BLOCKED,\n+            TimestampKind::Start,\n+        );\n+    }\n+\n+    /// End profiling a query being blocked on a concurrent execution.\n+    #[inline(always)]\n+    pub fn query_blocked_end(&self, query_name: QueryName) {\n+        self.non_guard_query_event(\n+            |profiler| profiler.query_blocked_event_kind,\n+            query_name,\n+            EventFilter::QUERY_BLOCKED,\n+            TimestampKind::End,\n+        );\n+    }\n+\n+    /// Start profiling how long it takes to load a query result from the\n+    /// incremental compilation on-disk cache. Profiling continues until the\n+    /// TimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn incr_cache_loading(&self, query_name: QueryName) -> TimingGuard<'_> {\n+        self.exec(EventFilter::INCR_CACHE_LOADS, |profiler| {\n+            let event_id = SelfProfiler::get_query_name_string_id(query_name);\n+            TimingGuard::start(\n+                profiler,\n+                profiler.incremental_load_result_event_kind,\n+                event_id\n+            )\n+        })\n+    }\n+\n+    #[inline(always)]\n+    fn non_guard_query_event(\n+        &self,\n+        event_kind: fn(&SelfProfiler) -> StringId,\n+        query_name: QueryName,\n+        event_filter: EventFilter,\n+        timestamp_kind: TimestampKind\n+    ) {\n+        drop(self.exec(event_filter, |profiler| {\n+            let event_id = SelfProfiler::get_query_name_string_id(query_name);\n+            let thread_id = thread_id_to_u64(std::thread::current().id());\n+\n+            profiler.profiler.record_event(\n+                event_kind(profiler),\n+                event_id,\n+                thread_id,\n+                timestamp_kind,\n+            );\n+\n+            TimingGuard::none()\n+        }));\n+    }\n+\n+    #[inline(always)]\n+    fn non_guard_generic_event<F: FnOnce(&SelfProfiler) -> StringId>(\n+        &self,\n+        event_kind: fn(&SelfProfiler) -> StringId,\n+        event_id: F,\n+        event_filter: EventFilter,\n+        timestamp_kind: TimestampKind\n+    ) {\n+        drop(self.exec(event_filter, |profiler| {\n+            let thread_id = thread_id_to_u64(std::thread::current().id());\n+\n+            profiler.profiler.record_event(\n+                event_kind(profiler),\n+                event_id(profiler),\n+                thread_id,\n+                timestamp_kind,\n+            );\n+\n+            TimingGuard::none()\n+        }));\n+    }\n+}\n+\n pub struct SelfProfiler {\n     profiler: Profiler,\n     event_filter_mask: EventFilter,\n@@ -143,103 +343,51 @@ impl SelfProfiler {\n         let id = SelfProfiler::get_query_name_string_id(query_name);\n         self.profiler.alloc_string_with_reserved_id(id, query_name.as_str());\n     }\n+}\n \n-    #[inline]\n-    pub fn start_activity(\n-        &self,\n-        label: impl Into<Cow<'static, str>>,\n-    ) {\n-        if self.event_filter_mask.contains(EventFilter::GENERIC_ACTIVITIES) {\n-            self.record(&label.into(), self.generic_activity_event_kind, TimestampKind::Start);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn end_activity(\n-        &self,\n-        label: impl Into<Cow<'static, str>>,\n-    ) {\n-        if self.event_filter_mask.contains(EventFilter::GENERIC_ACTIVITIES) {\n-            self.record(&label.into(), self.generic_activity_event_kind, TimestampKind::End);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn record_query_hit(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::QUERY_CACHE_HITS) {\n-            self.record_query(query_name, self.query_cache_hit_event_kind, TimestampKind::Instant);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn start_query(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::QUERY_PROVIDERS) {\n-            self.record_query(query_name, self.query_event_kind, TimestampKind::Start);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn end_query(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::QUERY_PROVIDERS) {\n-            self.record_query(query_name, self.query_event_kind, TimestampKind::End);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn incremental_load_result_start(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::INCR_CACHE_LOADS) {\n-            self.record_query(\n-                query_name,\n-                self.incremental_load_result_event_kind,\n-                TimestampKind::Start\n-            );\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn incremental_load_result_end(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::INCR_CACHE_LOADS) {\n-            self.record_query(\n-                query_name,\n-                self.incremental_load_result_event_kind,\n-                TimestampKind::End\n-            );\n-        }\n-    }\n+#[must_use]\n+pub struct TimingGuard<'a>(Option<TimingGuardInternal<'a>>);\n \n-    #[inline]\n-    pub fn query_blocked_start(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::QUERY_BLOCKED) {\n-            self.record_query(query_name, self.query_blocked_event_kind, TimestampKind::Start);\n-        }\n-    }\n+struct TimingGuardInternal<'a> {\n+    raw_profiler: &'a Profiler,\n+    event_id: StringId,\n+    event_kind: StringId,\n+    thread_id: u64,\n+}\n \n+impl<'a> TimingGuard<'a> {\n     #[inline]\n-    pub fn query_blocked_end(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::QUERY_BLOCKED) {\n-            self.record_query(query_name, self.query_blocked_event_kind, TimestampKind::End);\n-        }\n+    pub fn start(\n+        profiler: &'a SelfProfiler,\n+        event_kind: StringId,\n+        event_id: StringId,\n+    ) -> TimingGuard<'a> {\n+        let thread_id = thread_id_to_u64(std::thread::current().id());\n+        let raw_profiler = &profiler.profiler;\n+        raw_profiler.record_event(event_kind, event_id, thread_id, TimestampKind::Start);\n+\n+        TimingGuard(Some(TimingGuardInternal {\n+            raw_profiler,\n+            event_kind,\n+            event_id,\n+            thread_id,\n+        }))\n     }\n \n     #[inline]\n-    fn record(&self, event_id: &str, event_kind: StringId, timestamp_kind: TimestampKind) {\n-        let thread_id = thread_id_to_u64(std::thread::current().id());\n-\n-        let event_id = self.profiler.alloc_string(event_id);\n-        self.profiler.record_event(event_kind, event_id, thread_id, timestamp_kind);\n+    pub fn none() -> TimingGuard<'a> {\n+        TimingGuard(None)\n     }\n+}\n \n+impl<'a> Drop for TimingGuardInternal<'a> {\n     #[inline]\n-    fn record_query(\n-        &self,\n-        query_name: QueryName,\n-        event_kind: StringId,\n-        timestamp_kind: TimestampKind,\n-    ) {\n-        let dep_node_name = SelfProfiler::get_query_name_string_id(query_name);\n-\n-        let thread_id = thread_id_to_u64(std::thread::current().id());\n-\n-        self.profiler.record_event(event_kind, dep_node_name, thread_id, timestamp_kind);\n+    fn drop(&mut self) {\n+        self.raw_profiler.record_event(\n+            self.event_kind,\n+            self.event_id,\n+            self.thread_id,\n+            TimestampKind::End\n+        );\n     }\n }"}]}