{"sha": "1062955b46950114ed3a0a71c043e9644afdce48", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwNjI5NTViNDY5NTAxMTRlZDNhMGE3MWMwNDNlOTY0NGFmZGNlNDg=", "commit": {"author": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-10-26T04:40:25Z"}, "committer": {"name": "Brian Koropoff", "email": "bkoropoff@gmail.com", "date": "2014-10-26T04:40:25Z"}, "message": "Tweak mem categorization of upvar mutability\n\n- Correctly categorize env pointer deref for `FnMut` as declared\n  rather than inherited.  This fixes an assert in borrowck.\n  Closes #18238\n- Categorize env pointer deref as mutable only if the closure is\n  `FnMut` *and* the original variable is declared mutable.  This\n  disallows capture-by-value `FnMut` closures from mutating captured\n  variables that aren't declared mutable.  This is a difference\n  from the equivalent desugared code which would permit it, but\n  it is consistent with the behavior of procs.  Closes #18335\n- Avoid computing info about the env pointer if there isn't one.", "tree": {"sha": "98a26fa761f05ba70a2504744697c71af9e4bec0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98a26fa761f05ba70a2504744697c71af9e4bec0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1062955b46950114ed3a0a71c043e9644afdce48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1062955b46950114ed3a0a71c043e9644afdce48", "html_url": "https://github.com/rust-lang/rust/commit/1062955b46950114ed3a0a71c043e9644afdce48", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1062955b46950114ed3a0a71c043e9644afdce48/comments", "author": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bkoropoff", "id": 2101303, "node_id": "MDQ6VXNlcjIxMDEzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/2101303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bkoropoff", "html_url": "https://github.com/bkoropoff", "followers_url": "https://api.github.com/users/bkoropoff/followers", "following_url": "https://api.github.com/users/bkoropoff/following{/other_user}", "gists_url": "https://api.github.com/users/bkoropoff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bkoropoff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bkoropoff/subscriptions", "organizations_url": "https://api.github.com/users/bkoropoff/orgs", "repos_url": "https://api.github.com/users/bkoropoff/repos", "events_url": "https://api.github.com/users/bkoropoff/events{/privacy}", "received_events_url": "https://api.github.com/users/bkoropoff/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2877e47ea7409ff4ea820b0a6668111baf441377", "url": "https://api.github.com/repos/rust-lang/rust/commits/2877e47ea7409ff4ea820b0a6668111baf441377", "html_url": "https://github.com/rust-lang/rust/commit/2877e47ea7409ff4ea820b0a6668111baf441377"}], "stats": {"total": 131, "additions": 69, "deletions": 62}, "files": [{"sha": "1dc5ce274c86b363a73a0ff94e1f30774a7f5664", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 69, "deletions": 62, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/1062955b46950114ed3a0a71c043e9644afdce48/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1062955b46950114ed3a0a71c043e9644afdce48/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1062955b46950114ed3a0a71c043e9644afdce48", "patch": "@@ -656,51 +656,54 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         // FnOnce         | copied               | upvar -> &'up bk\n         // old stack      | N/A                  | upvar -> &'env mut -> &'up bk\n         // old proc/once  | copied               | N/A\n+        let var_ty = if_ok!(self.node_ty(var_id));\n+\n         let upvar_id = ty::UpvarId { var_id: var_id,\n                                      closure_expr_id: fn_node_id };\n \n-        // Do we need to deref through an env reference?\n-        let has_env_deref = kind != ty::FnOnceUnboxedClosureKind;\n-\n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx(), var_id);\n \n-        // Mutability of environment dereference\n-        let env_mutbl = match kind {\n-            ty::FnOnceUnboxedClosureKind => var_mutbl,\n-            ty::FnMutUnboxedClosureKind => McInherited,\n-            ty::FnUnboxedClosureKind => McImmutable\n+        // Construct information about env pointer dereference, if any\n+        let mutbl = match kind {\n+            ty::FnOnceUnboxedClosureKind => None, // None, env is by-value\n+            ty::FnMutUnboxedClosureKind => match mode { // Depends on capture type\n+                ast::CaptureByValue => Some(var_mutbl), // Mutable if the original var is\n+                ast::CaptureByRef => Some(McDeclared) // Mutable regardless\n+            },\n+            ty::FnUnboxedClosureKind => Some(McImmutable) // Never mutable\n         };\n+        let env_info = mutbl.map(|env_mutbl| {\n+            // Look up the node ID of the closure body so we can construct\n+            // a free region within it\n+            let fn_body_id = {\n+                let fn_expr = match self.tcx().map.find(fn_node_id) {\n+                    Some(ast_map::NodeExpr(e)) => e,\n+                    _ => unreachable!()\n+                };\n \n-        // Look up the node ID of the closure body so we can construct\n-        // a free region within it\n-        let fn_body_id = {\n-            let fn_expr = match self.tcx().map.find(fn_node_id) {\n-                Some(ast_map::NodeExpr(e)) => e,\n-                _ => unreachable!()\n+                match fn_expr.node {\n+                    ast::ExprFnBlock(_, _, ref body) |\n+                    ast::ExprProc(_, ref body) |\n+                    ast::ExprUnboxedFn(_, _, _, ref body) => body.id,\n+                    _ => unreachable!()\n+                }\n             };\n \n-            match fn_expr.node {\n-                ast::ExprFnBlock(_, _, ref body) |\n-                ast::ExprProc(_, ref body) |\n-                ast::ExprUnboxedFn(_, _, _, ref body) => body.id,\n-                _ => unreachable!()\n-            }\n-        };\n+            // Region of environment pointer\n+            let env_region = ty::ReFree(ty::FreeRegion {\n+                scope_id: fn_body_id,\n+                bound_region: ty::BrEnv\n+            });\n \n-        // Region of environment pointer\n-        let env_region = ty::ReFree(ty::FreeRegion {\n-            scope_id: fn_body_id,\n-            bound_region: ty::BrEnv\n-        });\n-\n-        let env_ptr = BorrowedPtr(if env_mutbl.is_mutable() {\n-            ty::MutBorrow\n-        } else {\n-            ty::ImmBorrow\n-        }, env_region);\n+            let env_ptr = BorrowedPtr(if env_mutbl.is_mutable() {\n+                ty::MutBorrow\n+            } else {\n+                ty::ImmBorrow\n+            }, env_region);\n \n-        let var_ty = if_ok!(self.node_ty(var_id));\n+            (env_mutbl, env_ptr)\n+        });\n \n         // First, switch by capture mode\n         Ok(match mode {\n@@ -718,25 +721,27 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     note: NoteNone\n                 };\n \n-                if has_env_deref {\n-                    // We need to add the env deref.  This means that\n-                    // the above is actually immutable and has a ref\n-                    // type.  However, nothing should actually look at\n-                    // the type, so we can get away with stuffing a\n-                    // `ty_err` in there instead of bothering to\n-                    // construct a proper one.\n-                    base.mutbl = McImmutable;\n-                    base.ty = ty::mk_err();\n-                    Rc::new(cmt_ {\n-                        id: id,\n-                        span: span,\n-                        cat: cat_deref(Rc::new(base), 0, env_ptr),\n-                        mutbl: env_mutbl,\n-                        ty: var_ty,\n-                        note: NoteClosureEnv(upvar_id)\n-                    })\n-                } else {\n-                    Rc::new(base)\n+                match env_info {\n+                    Some((env_mutbl, env_ptr)) => {\n+                        // We need to add the env deref.  This means\n+                        // that the above is actually immutable and\n+                        // has a ref type.  However, nothing should\n+                        // actually look at the type, so we can get\n+                        // away with stuffing a `ty_err` in there\n+                        // instead of bothering to construct a proper\n+                        // one.\n+                        base.mutbl = McImmutable;\n+                        base.ty = ty::mk_err();\n+                        Rc::new(cmt_ {\n+                            id: id,\n+                            span: span,\n+                            cat: cat_deref(Rc::new(base), 0, env_ptr),\n+                            mutbl: env_mutbl,\n+                            ty: var_ty,\n+                            note: NoteClosureEnv(upvar_id)\n+                        })\n+                    }\n+                    None => Rc::new(base)\n                 }\n             },\n             ast::CaptureByRef => {\n@@ -756,16 +761,18 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     note: NoteNone\n                 };\n \n-                // As in the by-value case, add env deref if needed\n-                if has_env_deref {\n-                    base = cmt_ {\n-                        id: id,\n-                        span: span,\n-                        cat: cat_deref(Rc::new(base), 0, env_ptr),\n-                        mutbl: env_mutbl,\n-                        ty: ty::mk_err(),\n-                        note: NoteClosureEnv(upvar_id)\n-                    };\n+                match env_info {\n+                    Some((env_mutbl, env_ptr)) => {\n+                        base = cmt_ {\n+                            id: id,\n+                            span: span,\n+                            cat: cat_deref(Rc::new(base), 0, env_ptr),\n+                            mutbl: env_mutbl,\n+                            ty: ty::mk_err(),\n+                            note: NoteClosureEnv(upvar_id)\n+                        };\n+                    }\n+                    None => {}\n                 }\n \n                 // Look up upvar borrow so we can get its region"}]}