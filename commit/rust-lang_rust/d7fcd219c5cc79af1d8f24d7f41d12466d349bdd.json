{"sha": "d7fcd219c5cc79af1d8f24d7f41d12466d349bdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3ZmNkMjE5YzVjYzc5YWYxZDhmMjRkN2Y0MWQxMjQ2NmQzNDliZGQ=", "commit": {"author": {"name": "Christian", "email": "chris_veenman@hotmail.com", "date": "2019-03-21T17:49:12Z"}, "committer": {"name": "Christian", "email": "chris_veenman@hotmail.com", "date": "2019-03-21T17:49:12Z"}, "message": "Changed inline code by using a single quote.", "tree": {"sha": "33abcb546e0e32761bdca7e7643ae2ef7b45f92c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33abcb546e0e32761bdca7e7643ae2ef7b45f92c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7fcd219c5cc79af1d8f24d7f41d12466d349bdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7fcd219c5cc79af1d8f24d7f41d12466d349bdd", "html_url": "https://github.com/rust-lang/rust/commit/d7fcd219c5cc79af1d8f24d7f41d12466d349bdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7fcd219c5cc79af1d8f24d7f41d12466d349bdd/comments", "author": null, "committer": null, "parents": [{"sha": "a66fca459aeead957e0160b3bbe842c5d9951dfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a66fca459aeead957e0160b3bbe842c5d9951dfb", "html_url": "https://github.com/rust-lang/rust/commit/a66fca459aeead957e0160b3bbe842c5d9951dfb"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "4402dc2fa415d9d042d8ce5c5ea39e6bb7a830a0", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d7fcd219c5cc79af1d8f24d7f41d12466d349bdd/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7fcd219c5cc79af1d8f24d7f41d12466d349bdd/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=d7fcd219c5cc79af1d8f24d7f41d12466d349bdd", "patch": "@@ -101,7 +101,7 @@ pub const fn identity<T>(x: T) -> T { x }\n /// Used to do a cheap reference-to-reference conversion.\n /// This trait is similar to [`AsMut`] which is used for converting between mutable references.\n /// If you need to do a costly conversion it is better to implement [`From`] with type\n-/// ```&T``` or write a custom function.\n+/// `&T` or write a custom function.\n ///\n ///\n /// `AsRef` is very similar to, but serves a slightly different purpose than [`Borrow`]:\n@@ -126,8 +126,8 @@ pub const fn identity<T>(x: T) -> T { x }\n /// # Examples\n ///\n /// By using trait bounds we can accept arguments of different types as long as they can be\n-/// converted a the specified type ```T```.\n-/// For example: By creating a generic function that takes an ```AsRef<str>``` we express that we\n+/// converted a the specified type `T`.\n+/// For example: By creating a generic function that takes an `AsRef<str>` we express that we\n /// want to accept all references that can be converted to &str as an argument.\n /// Since both [`String`] and `&str` implement `AsRef<str>` we can accept both as input argument.\n ///\n@@ -155,7 +155,7 @@ pub trait AsRef<T: ?Sized> {\n /// Used to do a cheap mutable-to-mutable reference conversion.\n /// This trait is similar to [`AsRef`] but used for converting between mutable\n /// references. If you need to do a costly conversion it is better to\n-/// implement [`From`] with type ```&mut T``` or write a custom function.\n+/// implement [`From`] with type `&mut T` or write a custom function.\n ///\n /// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n@@ -171,11 +171,11 @@ pub trait AsRef<T: ?Sized> {\n ///\n /// # Examples\n ///\n-/// Using ```AsMut``` as trait bound for a generic function we can accept all mutable references\n-/// that can be converted to type ```&mut T```. Because [`Box<T>`] implements ```AsMut<T>``` we can\n-/// write a function ```add_one```that takes all arguments that can be converted to ```&mut u64```.\n-/// Because [`Box<T>`] implements ```AsMut<T>``` ```add_one``` accepts arguments of type\n-/// ```&mut Box<u64>``` as well:\n+/// Using `AsMut` as trait bound for a generic function we can accept all mutable references\n+/// that can be converted to type `&mut T`. Because [`Box<T>`] implements `AsMut<T>` we can\n+/// write a function `add_one`that takes all arguments that can be converted to `&mut u64`.\n+/// Because [`Box<T>`] implements `AsMut<T>` `add_one` accepts arguments of type\n+/// `&mut Box<u64>` as well:\n /// ```\n /// fn add_one<T: AsMut<u64>>(num: &mut T) {\n ///     *num.as_mut() += 1;\n@@ -236,20 +236,20 @@ pub trait AsMut<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// It is important to understand that ```Into``` does not provide a [`From`] implementation\n-/// (as [`From`] does with ```Into```). Therefore, you should always try to implement [`From`]\n+/// It is important to understand that `Into` does not provide a [`From`] implementation\n+/// (as [`From`] does with `Into`). Therefore, you should always try to implement [`From`]\n /// and then fall back to `Into` if [`From`] can't be implemented.\n-/// Prefer using ```Into``` over ```From``` when specifying trait bounds on a generic function\n-/// to ensure that types that only implement ```Into``` can be used as well.\n+/// Prefer using `Into` over [`From`] when specifying trait bounds on a generic function\n+/// to ensure that types that only implement `Into` can be used as well.\n ///\n /// # Examples\n ///\n /// [`String`] implements `Into<Vec<u8>>`:\n ///\n /// In order to express that we want a generic function to take all arguments that can be\n-/// converted to a specified type ```T```, we can use a trait bound of ```Into<T>```.\n-/// For example: The function ```is_hello``` takes all arguments that can be converted into a\n-/// ```Vec<u8>```.\n+/// converted to a specified type `T`, we can use a trait bound of `Into<T>`.\n+/// For example: The function `is_hello` takes all arguments that can be converted into a\n+/// `Vec<u8>`.\n ///\n /// ```\n /// fn is_hello<T: Into<Vec<u8>>>(s: T) {\n@@ -312,13 +312,13 @@ pub trait Into<T>: Sized {\n /// assert_eq!(string, other_string);\n /// ```\n ///\n-/// While performing error handling it is often useful to implement ```From```\n+/// While performing error handling it is often useful to implement `From`\n /// for your own error type. By converting underlying error types to our own custom error type\n /// that encapsulates the underlying error type, we can return a single error type\n /// without losing information on the underlying cause. The '?' operator automatically converts\n-/// the underlying error type to our custom error type by calling ```Into<CliError>::into```\n-/// which is automatically provided when implementing ```From```.\n-/// The compiler then infers which implementation of ```Into``` should be used.\n+/// the underlying error type to our custom error type by calling `Into<CliError>::into`\n+/// which is automatically provided when implementing `From`.\n+/// The compiler then infers which implementation of `Into` should be used.\n ///\n /// ```\n /// use std::fs;"}]}