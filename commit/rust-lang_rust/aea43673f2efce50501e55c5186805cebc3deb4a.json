{"sha": "aea43673f2efce50501e55c5186805cebc3deb4a", "node_id": "C_kwDOAAsO6NoAKGFlYTQzNjczZjJlZmNlNTA1MDFlNTVjNTE4NjgwNWNlYmMzZGViNGE", "commit": {"author": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-04-14T09:36:09Z"}, "committer": {"name": "Pietro Albini", "email": "pietro.albini@ferrous-systems.com", "date": "2023-04-14T09:39:59Z"}, "message": "refactor needs, validate them, and add ignore reasons", "tree": {"sha": "b13cb0cc88930a49ceb9822b3d2addba7e36ab3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b13cb0cc88930a49ceb9822b3d2addba7e36ab3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aea43673f2efce50501e55c5186805cebc3deb4a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEMycKYjxLY0eb13b7zXazX3c0dp4FAmQ5H3AACgkQzXazX3c0\ndp4wzg//bFIoV//30kHfaRy1Ybb37Efe/xUzCY7j3r+qftYN0TMRc36/JuZUWFW9\nwEByyknylf5MHlrsMvVpPqYA9B9UMY0EoZ6yQRlKnLEYyeHBPY+uZgU5Mcg7SUBp\nQBj1WeSIM+tilQ8lnBwRmrGw4Ck+IFQ4SghJ2q0+VuyCHYpaeQpDl+vxIgCJ92Pu\nKHUXCqN2tZr7QePrSK4Aiav64CM7DmfhAfsgkFSA+yhHkigBe6YihhfsYFrc/hNq\nmiAQ2GsNr2haQFikkYlxO8/OFZ9kj472zCBOpKiGjlkk1SCtKFDB5/RruCFI+1Es\nkjxEAUI2Y+0+SfOuyqhbqpEmDUmYLJSmEHVzg3CfOM1A97TZATg2Jzkat0zDA+C0\nneKcXNf5rbbLUt6DTmR0qeLpbdJfhKawWfYmphsmlBB/pfKyQivG4bMyDCEwqFu0\nr+PeX7M15wXnngRbaeSz7sDlagzNCPSfWyqz5Efsr9iupp+VxVH5OzFMcmlcdvue\n7xNN3bgL+Kpi5hRmZmzSi7UuINzYQWwtRV5d8EYxPlh8wwVRUg/508sQA8e5aJ5N\njeAIRzdSUcc+Bw2awCeROtZmu910YVCyaOjMiJHq3kNpWUGebmfhQ1OCfJhCL6pY\ni7Og6VO/+qzEk+dkutXyHbvBtYNQEWPXuxShjtYp+YHFQ70JG7Q=\n=Cj5i\n-----END PGP SIGNATURE-----", "payload": "tree b13cb0cc88930a49ceb9822b3d2addba7e36ab3c\nparent 89281b3aa49702f456aab1b2808c62fb37b9cce3\nauthor Pietro Albini <pietro.albini@ferrous-systems.com> 1681464969 +0200\ncommitter Pietro Albini <pietro.albini@ferrous-systems.com> 1681465199 +0200\n\nrefactor needs, validate them, and add ignore reasons\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aea43673f2efce50501e55c5186805cebc3deb4a", "html_url": "https://github.com/rust-lang/rust/commit/aea43673f2efce50501e55c5186805cebc3deb4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aea43673f2efce50501e55c5186805cebc3deb4a/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89281b3aa49702f456aab1b2808c62fb37b9cce3", "url": "https://api.github.com/repos/rust-lang/rust/commits/89281b3aa49702f456aab1b2808c62fb37b9cce3", "html_url": "https://github.com/rust-lang/rust/commit/89281b3aa49702f456aab1b2808c62fb37b9cce3"}], "stats": {"total": 354, "additions": 250, "deletions": 104}, "files": [{"sha": "7613508077f417acadb3ac37b6e4a9b57cd2bd85", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 24, "deletions": 104, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/aea43673f2efce50501e55c5186805cebc3deb4a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea43673f2efce50501e55c5186805cebc3deb4a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=aea43673f2efce50501e55c5186805cebc3deb4a", "patch": "@@ -11,10 +11,10 @@ use tracing::*;\n use crate::common::{Config, Debugger, FailMode, Mode, PassMode};\n use crate::header::cfg::parse_cfg_name_directive;\n use crate::header::cfg::MatchOutcome;\n-use crate::util;\n use crate::{extract_cdb_version, extract_gdb_version};\n \n mod cfg;\n+mod needs;\n #[cfg(test)]\n mod tests;\n \n@@ -660,14 +660,6 @@ impl Config {\n         }\n     }\n \n-    fn parse_needs_matching_clang(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"needs-matching-clang\")\n-    }\n-\n-    fn parse_needs_profiler_support(&self, line: &str) -> bool {\n-        self.parse_name_directive(line, \"needs-profiler-support\")\n-    }\n-\n     fn has_cfg_prefix(&self, line: &str, prefix: &str) -> bool {\n         // returns whether this line contains this prefix or not. For prefix\n         // \"ignore\", returns true if line says \"ignore-x86_64\", \"ignore-arch\",\n@@ -871,69 +863,13 @@ pub fn make_test_description<R: Read>(\n     let mut ignore_message = None;\n     let mut should_fail = false;\n \n-    let rustc_has_profiler_support = env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some();\n-    let rustc_has_sanitizer_support = env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some();\n-    let has_asm_support = config.has_asm_support();\n-    let has_asan = util::ASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_cfi = util::CFI_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_kcfi = util::KCFI_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_kasan = util::KASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_lsan = util::LSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_msan = util::MSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_tsan = util::TSAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_hwasan = util::HWASAN_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_memtag = util::MEMTAG_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_shadow_call_stack = util::SHADOWCALLSTACK_SUPPORTED_TARGETS.contains(&&*config.target);\n-    let has_xray = util::XRAY_SUPPORTED_TARGETS.contains(&&*config.target);\n-\n-    // For tests using the `needs-rust-lld` directive (e.g. for `-Zgcc-ld=lld`), we need to find\n-    // whether `rust-lld` is present in the compiler under test.\n-    //\n-    // The --compile-lib-path is the path to host shared libraries, but depends on the OS. For\n-    // example:\n-    // - on linux, it can be <sysroot>/lib\n-    // - on windows, it can be <sysroot>/bin\n-    //\n-    // However, `rust-lld` is only located under the lib path, so we look for it there.\n-    let has_rust_lld = config\n-        .compile_lib_path\n-        .parent()\n-        .expect(\"couldn't traverse to the parent of the specified --compile-lib-path\")\n-        .join(\"lib\")\n-        .join(\"rustlib\")\n-        .join(&config.target)\n-        .join(\"bin\")\n-        .join(if config.host.contains(\"windows\") { \"rust-lld.exe\" } else { \"rust-lld\" })\n-        .exists();\n-\n-    fn is_on_path(file: &'static str) -> impl Fn() -> bool {\n-        move || env::split_paths(&env::var_os(\"PATH\").unwrap()).any(|dir| dir.join(file).is_file())\n-    }\n-\n-    // On Windows, dlltool.exe is used for all architectures.\n-    #[cfg(windows)]\n-    let (has_i686_dlltool, has_x86_64_dlltool) =\n-        (is_on_path(\"dlltool.exe\"), is_on_path(\"dlltool.exe\"));\n-    // For non-Windows, there are architecture specific dlltool binaries.\n-    #[cfg(not(windows))]\n-    let (has_i686_dlltool, has_x86_64_dlltool) =\n-        (is_on_path(\"i686-w64-mingw32-dlltool\"), is_on_path(\"x86_64-w64-mingw32-dlltool\"));\n+    let needs_cache = needs::CachedNeedsConditions::load(config);\n \n     iter_header(path, src, &mut |revision, ln| {\n         if revision.is_some() && revision != cfg {\n             return;\n         }\n-        macro_rules! reason {\n-            ($e:expr) => {\n-                ignore |= match $e {\n-                    true => {\n-                        ignore_message = Some(stringify!($e));\n-                        true\n-                    }\n-                    false => ignore,\n-                }\n-            };\n-        }\n+\n         macro_rules! decision {\n             ($e:expr) => {\n                 match $e {\n@@ -944,6 +880,10 @@ pub fn make_test_description<R: Read>(\n                         // compiletest so it won't grow indefinitely.\n                         ignore_message = Some(Box::leak(Box::<str>::from(reason)));\n                     }\n+                    IgnoreDecision::Error { message } => {\n+                        eprintln!(\"error: {}: {message}\", path.display());\n+                        panic!();\n+                    }\n                     IgnoreDecision::Continue => {}\n                 }\n             };\n@@ -989,48 +929,27 @@ pub fn make_test_description<R: Read>(\n             };\n         }\n \n+        decision!(needs::handle_needs(&needs_cache, config, ln));\n         decision!(ignore_llvm(config, ln));\n         decision!(ignore_cdb(config, ln));\n         decision!(ignore_gdb(config, ln));\n         decision!(ignore_lldb(config, ln));\n \n-        reason!(\n-            config.run_clang_based_tests_with.is_none() && config.parse_needs_matching_clang(ln)\n-        );\n-        reason!(!has_asm_support && config.parse_name_directive(ln, \"needs-asm-support\"));\n-        reason!(!rustc_has_profiler_support && config.parse_needs_profiler_support(ln));\n-        reason!(!config.run_enabled() && config.parse_name_directive(ln, \"needs-run-enabled\"));\n-        reason!(\n-            !rustc_has_sanitizer_support\n-                && config.parse_name_directive(ln, \"needs-sanitizer-support\")\n-        );\n-        reason!(!has_asan && config.parse_name_directive(ln, \"needs-sanitizer-address\"));\n-        reason!(!has_cfi && config.parse_name_directive(ln, \"needs-sanitizer-cfi\"));\n-        reason!(!has_kcfi && config.parse_name_directive(ln, \"needs-sanitizer-kcfi\"));\n-        reason!(!has_kasan && config.parse_name_directive(ln, \"needs-sanitizer-kasan\"));\n-        reason!(!has_lsan && config.parse_name_directive(ln, \"needs-sanitizer-leak\"));\n-        reason!(!has_msan && config.parse_name_directive(ln, \"needs-sanitizer-memory\"));\n-        reason!(!has_tsan && config.parse_name_directive(ln, \"needs-sanitizer-thread\"));\n-        reason!(!has_hwasan && config.parse_name_directive(ln, \"needs-sanitizer-hwaddress\"));\n-        reason!(!has_memtag && config.parse_name_directive(ln, \"needs-sanitizer-memtag\"));\n-        reason!(\n-            !has_shadow_call_stack\n-                && config.parse_name_directive(ln, \"needs-sanitizer-shadow-call-stack\")\n-        );\n-        reason!(!config.can_unwind() && config.parse_name_directive(ln, \"needs-unwind\"));\n-        reason!(!has_xray && config.parse_name_directive(ln, \"needs-xray\"));\n-        reason!(\n-            config.target == \"wasm32-unknown-unknown\"\n-                && config.parse_name_directive(ln, directives::CHECK_RUN_RESULTS)\n-        );\n-        reason!(!has_rust_lld && config.parse_name_directive(ln, \"needs-rust-lld\"));\n-        reason!(config.parse_name_directive(ln, \"needs-i686-dlltool\") && !has_i686_dlltool());\n-        reason!(config.parse_name_directive(ln, \"needs-x86_64-dlltool\") && !has_x86_64_dlltool());\n-        reason!(\n-            config.parse_name_directive(ln, \"rust-lldb\")\n-                && config.debugger == Some(Debugger::Lldb)\n-                && !config.lldb_native_rust\n-        );\n+        if config.target == \"wasm32-unknown-unknown\" {\n+            if config.parse_name_directive(ln, directives::CHECK_RUN_RESULTS) {\n+                decision!(IgnoreDecision::Ignore {\n+                    reason: \"ignored when checking the run results on WASM\".into(),\n+                });\n+            }\n+        }\n+\n+        if config.debugger == Some(Debugger::Lldb) && !config.lldb_native_rust {\n+            if config.parse_name_directive(ln, \"rust-lldb\") {\n+                decision!(IgnoreDecision::Ignore {\n+                    reason: \"ignored on targets wihtout Rust's LLDB\".into()\n+                });\n+            }\n+        }\n \n         should_fail |= config.parse_name_directive(ln, \"should-fail\");\n     });\n@@ -1226,4 +1145,5 @@ fn ignore_llvm(config: &Config, line: &str) -> IgnoreDecision {\n enum IgnoreDecision {\n     Ignore { reason: String },\n     Continue,\n+    Error { message: String },\n }"}, {"sha": "9a7c4b86115ebb2e84ba94ca80e6194a53283620", "filename": "src/tools/compiletest/src/header/needs.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/aea43673f2efce50501e55c5186805cebc3deb4a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea43673f2efce50501e55c5186805cebc3deb4a/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader%2Fneeds.rs?ref=aea43673f2efce50501e55c5186805cebc3deb4a", "patch": "@@ -0,0 +1,226 @@\n+use crate::common::Config;\n+use crate::header::IgnoreDecision;\n+use crate::util;\n+\n+pub(super) fn handle_needs(\n+    cache: &CachedNeedsConditions,\n+    config: &Config,\n+    ln: &str,\n+) -> IgnoreDecision {\n+    // Note thet we intentionally still put the needs- prefix here to make the file show up when\n+    // grepping for a directive name, even though we could technically strip that.\n+    let needs = &[\n+        Need {\n+            name: \"needs-asm-support\",\n+            condition: config.has_asm_support(),\n+            ignore_reason: \"ignored on targets without inline assembly support\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-support\",\n+            condition: cache.sanitizer_support,\n+            ignore_reason: \"ignored on targets without sanitizers support\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-address\",\n+            condition: cache.sanitizer_address,\n+            ignore_reason: \"ignored on targets without address sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-cfi\",\n+            condition: cache.sanitizer_cfi,\n+            ignore_reason: \"ignored on targets without CFI sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-kcfi\",\n+            condition: cache.sanitizer_kcfi,\n+            ignore_reason: \"ignored on targets without kernel CFI sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-kasan\",\n+            condition: cache.sanitizer_kasan,\n+            ignore_reason: \"ignored on targets without kernel address sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-leak\",\n+            condition: cache.sanitizer_leak,\n+            ignore_reason: \"ignored on targets without leak sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-memory\",\n+            condition: cache.sanitizer_memory,\n+            ignore_reason: \"ignored on targets without memory sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-thread\",\n+            condition: cache.sanitizer_thread,\n+            ignore_reason: \"ignored on targets without thread sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-hwaddress\",\n+            condition: cache.sanitizer_hwaddress,\n+            ignore_reason: \"ignored on targets without hardware-assisted address sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-memtag\",\n+            condition: cache.sanitizer_memtag,\n+            ignore_reason: \"ignored on targets without memory tagging sanitizer\",\n+        },\n+        Need {\n+            name: \"needs-sanitizer-shadow-call-stack\",\n+            condition: cache.sanitizer_shadow_call_stack,\n+            ignore_reason: \"ignored on targets without shadow call stacks\",\n+        },\n+        Need {\n+            name: \"needs-run-enabled\",\n+            condition: config.run_enabled(),\n+            ignore_reason: \"ignored when running the resulting test binaries is disabled\",\n+        },\n+        Need {\n+            name: \"needs-unwind\",\n+            condition: config.can_unwind(),\n+            ignore_reason: \"ignored on targets without unwinding support\",\n+        },\n+        Need {\n+            name: \"needs-profiler-support\",\n+            condition: std::env::var_os(\"RUSTC_PROFILER_SUPPORT\").is_some(),\n+            ignore_reason: \"ignored when profiler support is disabled\",\n+        },\n+        Need {\n+            name: \"needs-matching-clang\",\n+            condition: config.run_clang_based_tests_with.is_some(),\n+            ignore_reason: \"ignored when the used clang does not match the built LLVM\",\n+        },\n+        Need {\n+            name: \"needs-xray\",\n+            condition: cache.xray,\n+            ignore_reason: \"ignored on targets without xray tracing\",\n+        },\n+        Need {\n+            name: \"needs-rust-lld\",\n+            condition: cache.rust_lld,\n+            ignore_reason: \"ignored on targets without Rust's LLD\",\n+        },\n+        Need {\n+            name: \"needs-i686-dlltool\",\n+            condition: cache.i686_dlltool,\n+            ignore_reason: \"ignored when dlltool for i686 is not present\",\n+        },\n+        Need {\n+            name: \"needs-x86_64-dlltool\",\n+            condition: cache.x86_64_dlltool,\n+            ignore_reason: \"ignored when dlltool for x86_64 is not present\",\n+        },\n+    ];\n+\n+    let (name, comment) = match ln.split_once([':', ' ']) {\n+        Some((name, comment)) => (name, Some(comment)),\n+        None => (ln, None),\n+    };\n+\n+    if !name.starts_with(\"needs-\") {\n+        return IgnoreDecision::Continue;\n+    }\n+\n+    let mut found_valid = false;\n+    for need in needs {\n+        if need.name == name {\n+            if need.condition {\n+                found_valid = true;\n+                break;\n+            } else {\n+                return IgnoreDecision::Ignore {\n+                    reason: if let Some(comment) = comment {\n+                        format!(\"{} ({comment})\", need.ignore_reason)\n+                    } else {\n+                        need.ignore_reason.into()\n+                    },\n+                };\n+            }\n+        }\n+    }\n+\n+    if found_valid {\n+        IgnoreDecision::Continue\n+    } else {\n+        IgnoreDecision::Error { message: format!(\"invalid needs directive: {name}\") }\n+    }\n+}\n+\n+struct Need {\n+    name: &'static str,\n+    condition: bool,\n+    ignore_reason: &'static str,\n+}\n+\n+pub(super) struct CachedNeedsConditions {\n+    sanitizer_support: bool,\n+    sanitizer_address: bool,\n+    sanitizer_cfi: bool,\n+    sanitizer_kcfi: bool,\n+    sanitizer_kasan: bool,\n+    sanitizer_leak: bool,\n+    sanitizer_memory: bool,\n+    sanitizer_thread: bool,\n+    sanitizer_hwaddress: bool,\n+    sanitizer_memtag: bool,\n+    sanitizer_shadow_call_stack: bool,\n+    xray: bool,\n+    rust_lld: bool,\n+    i686_dlltool: bool,\n+    x86_64_dlltool: bool,\n+}\n+\n+impl CachedNeedsConditions {\n+    pub(super) fn load(config: &Config) -> Self {\n+        let path = std::env::var_os(\"PATH\").expect(\"missing PATH environment variable\");\n+        let path = std::env::split_paths(&path).collect::<Vec<_>>();\n+\n+        let target = &&*config.target;\n+        Self {\n+            sanitizer_support: std::env::var_os(\"RUSTC_SANITIZER_SUPPORT\").is_some(),\n+            sanitizer_address: util::ASAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_cfi: util::CFI_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_kcfi: util::KCFI_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_kasan: util::KASAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_leak: util::LSAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_memory: util::MSAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_thread: util::TSAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_hwaddress: util::HWASAN_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_memtag: util::MEMTAG_SUPPORTED_TARGETS.contains(target),\n+            sanitizer_shadow_call_stack: util::SHADOWCALLSTACK_SUPPORTED_TARGETS.contains(target),\n+            xray: util::XRAY_SUPPORTED_TARGETS.contains(target),\n+\n+            // For tests using the `needs-rust-lld` directive (e.g. for `-Zgcc-ld=lld`), we need to find\n+            // whether `rust-lld` is present in the compiler under test.\n+            //\n+            // The --compile-lib-path is the path to host shared libraries, but depends on the OS. For\n+            // example:\n+            // - on linux, it can be <sysroot>/lib\n+            // - on windows, it can be <sysroot>/bin\n+            //\n+            // However, `rust-lld` is only located under the lib path, so we look for it there.\n+            rust_lld: config\n+                .compile_lib_path\n+                .parent()\n+                .expect(\"couldn't traverse to the parent of the specified --compile-lib-path\")\n+                .join(\"lib\")\n+                .join(\"rustlib\")\n+                .join(target)\n+                .join(\"bin\")\n+                .join(if config.host.contains(\"windows\") { \"rust-lld.exe\" } else { \"rust-lld\" })\n+                .exists(),\n+\n+            // On Windows, dlltool.exe is used for all architectures.\n+            #[cfg(windows)]\n+            i686_dlltool: path.iter().any(|dir| dir.join(\"dlltool.exe\").is_file()),\n+            #[cfg(windows)]\n+            x86_64_dlltool: path.iter().any(|dir| dir.join(\"dlltool.exe\").is_file()),\n+\n+            // For non-Windows, there are architecture specific dlltool binaries.\n+            #[cfg(not(windows))]\n+            i686_dlltool: path.iter().any(|dir| dir.join(\"i686-w64-mingw32-dlltool\").is_file()),\n+            #[cfg(not(windows))]\n+            x86_64_dlltool: path.iter().any(|dir| dir.join(\"x86_64-w64-mingw32-dlltool\").is_file()),\n+        }\n+    }\n+}"}]}