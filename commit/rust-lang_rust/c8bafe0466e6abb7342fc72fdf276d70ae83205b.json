{"sha": "c8bafe0466e6abb7342fc72fdf276d70ae83205b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YmFmZTA0NjZlNmFiYjczNDJmYzcyZmRmMjc2ZDcwYWU4MzIwNWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-24T03:25:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-24T03:25:44Z"}, "message": "auto merge of #17248 : jbcrail/rust/fix-rational-rounding, r=alexcrichton\n\nWhen I fixed the previous issue with rational rounding, I had introduced a regression. There was also an overflow bug introduced for fixed-precision rationals. This patch corrects both bugs.", "tree": {"sha": "0ad4d265a8bbad1cad9155e7a1dc68a8f5789fc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ad4d265a8bbad1cad9155e7a1dc68a8f5789fc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8bafe0466e6abb7342fc72fdf276d70ae83205b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8bafe0466e6abb7342fc72fdf276d70ae83205b", "html_url": "https://github.com/rust-lang/rust/commit/c8bafe0466e6abb7342fc72fdf276d70ae83205b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8bafe0466e6abb7342fc72fdf276d70ae83205b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c669411afa76bdc92369a3a193e9393364d42370", "url": "https://api.github.com/repos/rust-lang/rust/commits/c669411afa76bdc92369a3a193e9393364d42370", "html_url": "https://github.com/rust-lang/rust/commit/c669411afa76bdc92369a3a193e9393364d42370"}, {"sha": "363c264afa58e372a2973d37003d79b71f00ade4", "url": "https://api.github.com/repos/rust-lang/rust/commits/363c264afa58e372a2973d37003d79b71f00ade4", "html_url": "https://github.com/rust-lang/rust/commit/363c264afa58e372a2973d37003d79b71f00ade4"}], "stats": {"total": 49, "additions": 44, "deletions": 5}, "files": [{"sha": "2e13d5f0148d2dfeeec1f958d36c48d55a9f642a", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c8bafe0466e6abb7342fc72fdf276d70ae83205b/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8bafe0466e6abb7342fc72fdf276d70ae83205b/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=c8bafe0466e6abb7342fc72fdf276d70ae83205b", "patch": "@@ -139,12 +139,29 @@ impl<T: Clone + Integer + PartialOrd>\n     /// Rounds to the nearest integer. Rounds half-way cases away from zero.\n     #[inline]\n     pub fn round(&self) -> Ratio<T> {\n-        if *self < Zero::zero() {\n-            // a/b - 1/2 = (2*a - b)/(2*b)\n-            Ratio::from_integer((self.numer + self.numer - self.denom) / (self.denom + self.denom))\n+        let one: T = One::one();\n+        let two: T = one + one;\n+\n+        // Find unsigned fractional part of rational number\n+        let fractional = self.fract().abs();\n+\n+        // The algorithm compares the unsigned fractional part with 1/2, that\n+        // is, a/b >= 1/2, or a >= b/2. For odd denominators, we use\n+        // a >= (b/2)+1. This avoids overflow issues.\n+        let half_or_larger = if fractional.denom().is_even() {\n+            *fractional.numer() >= *fractional.denom() / two\n         } else {\n-            // a/b + 1/2 = (2*a + b)/(2*b)\n-            Ratio::from_integer((self.numer + self.numer + self.denom) / (self.denom + self.denom))\n+            *fractional.numer() >= (*fractional.denom() / two) + one\n+        };\n+\n+        if half_or_larger {\n+            if *self >= Zero::zero() {\n+                self.trunc() + One::one()\n+            } else {\n+                self.trunc() - One::one()\n+            }\n+        } else {\n+            self.trunc()\n         }\n     }\n \n@@ -382,6 +399,7 @@ mod test {\n     use std::from_str::FromStr;\n     use std::hash::hash;\n     use std::num;\n+    use std::i32;\n \n     pub static _0 : Rational = Ratio { numer: 0, denom: 1};\n     pub static _1 : Rational = Ratio { numer: 1, denom: 1};\n@@ -616,6 +634,27 @@ mod test {\n         assert_eq!(_1.floor(), _1);\n         assert_eq!(_1.round(), _1);\n         assert_eq!(_1.trunc(), _1);\n+\n+        // Overflow checks\n+\n+        let _neg1 = Ratio::from_integer(-1);\n+        let _large_rat1 = Ratio::new(i32::MAX, i32::MAX-1);\n+        let _large_rat2 = Ratio::new(i32::MAX-1, i32::MAX);\n+        let _large_rat3 = Ratio::new(i32::MIN+2, i32::MIN+1);\n+        let _large_rat4 = Ratio::new(i32::MIN+1, i32::MIN+2);\n+        let _large_rat5 = Ratio::new(i32::MIN+2, i32::MAX);\n+        let _large_rat6 = Ratio::new(i32::MAX, i32::MIN+2);\n+        let _large_rat7 = Ratio::new(1, i32::MIN+1);\n+        let _large_rat8 = Ratio::new(1, i32::MAX);\n+\n+        assert_eq!(_large_rat1.round(), One::one());\n+        assert_eq!(_large_rat2.round(), One::one());\n+        assert_eq!(_large_rat3.round(), One::one());\n+        assert_eq!(_large_rat4.round(), One::one());\n+        assert_eq!(_large_rat5.round(), _neg1);\n+        assert_eq!(_large_rat6.round(), _neg1);\n+        assert_eq!(_large_rat7.round(), Zero::zero());\n+        assert_eq!(_large_rat8.round(), Zero::zero());\n     }\n \n     #[test]"}]}