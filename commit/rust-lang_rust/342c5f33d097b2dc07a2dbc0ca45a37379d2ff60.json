{"sha": "342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM0MmM1ZjMzZDA5N2IyZGMwN2EyZGJjMGNhNDVhMzczNzlkMmZmNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-24T00:53:25Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-24T00:53:25Z"}, "message": "Auto merge of #70343 - Centril:rollup-94egfvs, r=Centril\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #67761 (Move the dep_graph construction to a dedicated crate.)\n - #69740 (Replace some desc logic in librustc_lint with article_and_desc)\n - #69981 (Evaluate repeat expression lengths as late as possible)\n - #70087 (Remove const eval loop detector)\n - #70242 (Improve E0308 error message wording)\n - #70264 (Fix invalid suggestion on `&mut` iterators yielding `&` references)\n - #70267 (get rid of ConstPropUnsupported; use ZST marker structs instead)\n - #70277 (Remove `ReClosureBound`)\n - #70283 (Add regression test for #70155.)\n - #70294 (Account for bad placeholder types in where clauses)\n - #70309 (Clean up E0452 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "dec00a25ca9ef0998971e97d3cc753460528c0d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dec00a25ca9ef0998971e97d3cc753460528c0d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "html_url": "https://github.com/rust-lang/rust/commit/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c55c682e9ba2be16d5de4264d1b626e70f00de9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c55c682e9ba2be16d5de4264d1b626e70f00de9d", "html_url": "https://github.com/rust-lang/rust/commit/c55c682e9ba2be16d5de4264d1b626e70f00de9d"}, {"sha": "3b8872d76de4def293b0bce5a5ad737ccaab7d3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b8872d76de4def293b0bce5a5ad737ccaab7d3d", "html_url": "https://github.com/rust-lang/rust/commit/3b8872d76de4def293b0bce5a5ad737ccaab7d3d"}], "stats": {"total": 3896, "additions": 1964, "deletions": 1932}, "files": [{"sha": "22a06151353bada202aa083bf39d34c2cab1d293", "filename": "Cargo.lock", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -3116,6 +3116,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_macros\",\n+ \"rustc_query_system\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\",\n@@ -4021,6 +4022,22 @@ dependencies = [\n  \"rustc_typeck\",\n ]\n \n+[[package]]\n+name = \"rustc_query_system\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"log\",\n+ \"parking_lot 0.9.0\",\n+ \"rustc_ast\",\n+ \"rustc_data_structures\",\n+ \"rustc_errors\",\n+ \"rustc_hir\",\n+ \"rustc_index\",\n+ \"rustc_macros\",\n+ \"serialize\",\n+ \"smallvec 1.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_resolve\"\n version = \"0.0.0\""}, {"sha": "39df803bbea3010cdc475133679ee97cebc24f30", "filename": "src/libcore/any.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -164,7 +164,7 @@ impl dyn Any {\n         // Get `TypeId` of the type this function is instantiated with.\n         let t = TypeId::of::<T>();\n \n-        // Get `TypeId` of the type in the trait object.\n+        // Get `TypeId` of the type in the trait object (`self`).\n         let concrete = self.type_id();\n \n         // Compare both `TypeId`s on equality."}, {"sha": "47b94a2f1a4b49947eef67613ecdd6a3de4cb3a1", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -25,6 +25,7 @@ rustc_hir = { path = \"../librustc_hir\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_query_system = { path = \"../librustc_query_system\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }"}, {"sha": "fdcc1a0db0538236e8ffd1ff2d07dea2c7512391", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 46, "deletions": 142, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -50,7 +50,7 @@\n //! fingerprint for a given set of node parameters.\n \n use crate::hir::map::DefPathHash;\n-use crate::ich::{Fingerprint, StableHashingContext};\n+use crate::ich::Fingerprint;\n use crate::mir;\n use crate::mir::interpret::{GlobalId, LitToConstInput};\n use crate::traits;\n@@ -62,13 +62,13 @@ use crate::traits::query::{\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::HirId;\n use rustc_span::symbol::Symbol;\n-use std::fmt;\n use std::hash::Hash;\n \n+pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n+\n // erase!() just makes tokens go away. It's used to specify which macro argument\n // is repeated (i.e., which sub-expression of the macro we are in) but don't need\n // to actually use any of the arguments.\n@@ -128,7 +128,7 @@ macro_rules! define_dep_nodes {\n \n                             // tuple args\n                             $({\n-                                return <$tuple_arg_ty as DepNodeParams>\n+                                return <$tuple_arg_ty as DepNodeParams<TyCtxt<'_>>>\n                                     ::CAN_RECONSTRUCT_QUERY_KEY;\n                             })*\n \n@@ -212,38 +212,46 @@ macro_rules! define_dep_nodes {\n             )*\n         }\n \n-        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n-                 RustcEncodable, RustcDecodable)]\n-        pub struct DepNode {\n-            pub kind: DepKind,\n-            pub hash: Fingerprint,\n+        pub type DepNode = rustc_query_system::dep_graph::DepNode<DepKind>;\n+\n+        pub trait DepNodeExt: Sized {\n+            /// Construct a DepNode from the given DepKind and DefPathHash. This\n+            /// method will assert that the given DepKind actually requires a\n+            /// single DefId/DefPathHash parameter.\n+            fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> Self;\n+\n+            /// Extracts the DefId corresponding to this DepNode. This will work\n+            /// if two conditions are met:\n+            ///\n+            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+            /// 2. the item that the DefPath refers to exists in the current tcx.\n+            ///\n+            /// Condition (1) is determined by the DepKind variant of the\n+            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+            /// refers to something from the previous compilation session that\n+            /// has been removed.\n+            fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId>;\n+\n+            /// Used in testing\n+            fn from_label_string(label: &str, def_path_hash: DefPathHash)\n+                -> Result<Self, ()>;\n+\n+            /// Used in testing\n+            fn has_label_string(label: &str) -> bool;\n         }\n \n-        impl DepNode {\n+        impl DepNodeExt for DepNode {\n             /// Construct a DepNode from the given DepKind and DefPathHash. This\n             /// method will assert that the given DepKind actually requires a\n             /// single DefId/DefPathHash parameter.\n-            pub fn from_def_path_hash(def_path_hash: DefPathHash,\n-                                      kind: DepKind)\n-                                      -> DepNode {\n+            fn from_def_path_hash(def_path_hash: DefPathHash, kind: DepKind) -> DepNode {\n                 debug_assert!(kind.can_reconstruct_query_key() && kind.has_params());\n                 DepNode {\n                     kind,\n                     hash: def_path_hash.0,\n                 }\n             }\n \n-            /// Creates a new, parameterless DepNode. This method will assert\n-            /// that the DepNode corresponding to the given DepKind actually\n-            /// does not require any parameters.\n-            pub fn new_no_params(kind: DepKind) -> DepNode {\n-                debug_assert!(!kind.has_params());\n-                DepNode {\n-                    kind,\n-                    hash: Fingerprint::ZERO,\n-                }\n-            }\n-\n             /// Extracts the DefId corresponding to this DepNode. This will work\n             /// if two conditions are met:\n             ///\n@@ -254,20 +262,17 @@ macro_rules! define_dep_nodes {\n             /// DepNode. Condition (2) might not be fulfilled if a DepNode\n             /// refers to something from the previous compilation session that\n             /// has been removed.\n-            pub fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n+            fn extract_def_id(&self, tcx: TyCtxt<'tcx>) -> Option<DefId> {\n                 if self.kind.can_reconstruct_query_key() {\n                     let def_path_hash = DefPathHash(self.hash);\n-                    tcx.def_path_hash_to_def_id.as_ref()?\n-                        .get(&def_path_hash).cloned()\n+                    tcx.def_path_hash_to_def_id.as_ref()?.get(&def_path_hash).cloned()\n                 } else {\n                     None\n                 }\n             }\n \n             /// Used in testing\n-            pub fn from_label_string(label: &str,\n-                                     def_path_hash: DefPathHash)\n-                                     -> Result<DepNode, ()> {\n+            fn from_label_string(label: &str, def_path_hash: DefPathHash) -> Result<DepNode, ()> {\n                 let kind = match label {\n                     $(\n                         stringify!($variant) => DepKind::$variant,\n@@ -287,7 +292,7 @@ macro_rules! define_dep_nodes {\n             }\n \n             /// Used in testing\n-            pub fn has_label_string(label: &str) -> bool {\n+            fn has_label_string(label: &str) -> bool {\n                 match label {\n                     $(\n                         stringify!($variant) => true,\n@@ -308,35 +313,6 @@ macro_rules! define_dep_nodes {\n     );\n }\n \n-impl fmt::Debug for DepNode {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.kind)?;\n-\n-        if !self.kind.has_params() && !self.kind.is_anon() {\n-            return Ok(());\n-        }\n-\n-        write!(f, \"(\")?;\n-\n-        crate::ty::tls::with_opt(|opt_tcx| {\n-            if let Some(tcx) = opt_tcx {\n-                if let Some(def_id) = self.extract_def_id(tcx) {\n-                    write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n-                } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*self) {\n-                    write!(f, \"{}\", s)?;\n-                } else {\n-                    write!(f, \"{}\", self.hash)?;\n-                }\n-            } else {\n-                write!(f, \"{}\", self.hash)?;\n-            }\n-            Ok(())\n-        })?;\n-\n-        write!(f, \")\")\n-    }\n-}\n-\n rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     // We use this for most things when incr. comp. is turned off.\n     [] Null,\n@@ -349,58 +325,10 @@ rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n     [] CompileCodegenUnit(Symbol),\n ]);\n \n-pub(crate) trait DepNodeParams<'tcx>: fmt::Debug + Sized {\n-    const CAN_RECONSTRUCT_QUERY_KEY: bool;\n-\n-    /// This method turns the parameters of a DepNodeConstructor into an opaque\n-    /// Fingerprint to be used in DepNode.\n-    /// Not all DepNodeParams support being turned into a Fingerprint (they\n-    /// don't need to if the corresponding DepNode is anonymous).\n-    fn to_fingerprint(&self, _: TyCtxt<'tcx>) -> Fingerprint {\n-        panic!(\"Not implemented. Accidentally called on anonymous node?\")\n-    }\n-\n-    fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n-        format!(\"{:?}\", self)\n-    }\n-\n-    /// This method tries to recover the query key from the given `DepNode`,\n-    /// something which is needed when forcing `DepNode`s during red-green\n-    /// evaluation. The query system will only call this method if\n-    /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n-    /// It is always valid to return `None` here, in which case incremental\n-    /// compilation will treat the query as having changed instead of forcing it.\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n-}\n-\n-impl<'tcx, T> DepNodeParams<'tcx> for T\n-where\n-    T: HashStable<StableHashingContext<'tcx>> + fmt::Debug,\n-{\n-    default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n-\n-    default fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-\n-        self.hash_stable(&mut hcx, &mut hasher);\n-\n-        hasher.finish()\n-    }\n-\n-    default fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n-        format!(\"{:?}\", *self)\n-    }\n-\n-    default fn recover(_: TyCtxt<'tcx>, _: &DepNode) -> Option<Self> {\n-        None\n-    }\n-}\n-\n-impl<'tcx> DepNodeParams<'tcx> for DefId {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for DefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         tcx.def_path_hash(*self).0\n     }\n \n@@ -413,10 +341,10 @@ impl<'tcx> DepNodeParams<'tcx> for DefId {\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for LocalDefId {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for LocalDefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         self.to_def_id().to_fingerprint(tcx)\n     }\n \n@@ -429,10 +357,10 @@ impl<'tcx> DepNodeParams<'tcx> for LocalDefId {\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for CrateNum {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         tcx.def_path_hash(def_id).0\n     }\n@@ -446,13 +374,13 @@ impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let (def_id_0, def_id_1) = *self;\n \n         let def_path_hash_0 = tcx.def_path_hash(def_id_0);\n@@ -468,13 +396,13 @@ impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for HirId {\n+impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n \n     // We actually would not need to specialize the implementation of this\n     // method but it's faster to combine the hashes than to instantiate a full\n     // hashing context and stable-hashing state.\n-    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+    fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let HirId { owner, local_id } = *self;\n \n         let def_path_hash = tcx.def_path_hash(owner.to_def_id());\n@@ -483,27 +411,3 @@ impl<'tcx> DepNodeParams<'tcx> for HirId {\n         def_path_hash.0.combine(local_id)\n     }\n }\n-\n-/// A \"work product\" corresponds to a `.o` (or other) file that we\n-/// save in between runs. These IDs do not have a `DefId` but rather\n-/// some independent path or string that persists between runs without\n-/// the need to be mapped or unmapped. (This ensures we can serialize\n-/// them even in the absence of a tcx.)\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-#[derive(HashStable)]\n-pub struct WorkProductId {\n-    hash: Fingerprint,\n-}\n-\n-impl WorkProductId {\n-    pub fn from_cgu_name(cgu_name: &str) -> WorkProductId {\n-        let mut hasher = StableHasher::new();\n-        cgu_name.len().hash(&mut hasher);\n-        cgu_name.hash(&mut hasher);\n-        WorkProductId { hash: hasher.finish() }\n-    }\n-\n-    pub fn from_fingerprint(fingerprint: Fingerprint) -> WorkProductId {\n-        WorkProductId { hash: fingerprint }\n-    }\n-}"}, {"sha": "3c39597584df50cffbde05897ee6f38ce58c4b06", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 189, "deletions": 15, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,17 +1,191 @@\n-pub mod debug;\n+use crate::ich::StableHashingContext;\n+use crate::ty::query::try_load_from_on_disk_cache;\n+use crate::ty::{self, TyCtxt};\n+use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_errors::Diagnostic;\n+use rustc_hir::def_id::DefId;\n+\n mod dep_node;\n-mod graph;\n-mod prev;\n-mod query;\n mod safe;\n-mod serialized;\n-\n-pub(crate) use self::dep_node::DepNodeParams;\n-pub use self::dep_node::{label_strs, DepConstructor, DepKind, DepNode, WorkProductId};\n-pub use self::graph::WorkProductFileKind;\n-pub use self::graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n-pub use self::prev::PreviousDepGraph;\n-pub use self::query::DepGraphQuery;\n-pub use self::safe::AssertDepGraphSafe;\n-pub use self::safe::DepGraphSafe;\n-pub use self::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+\n+pub(crate) use rustc_query_system::dep_graph::DepNodeParams;\n+pub use rustc_query_system::dep_graph::{\n+    debug, hash_result, DepContext, DepNodeColor, DepNodeIndex, SerializedDepNodeIndex,\n+    WorkProduct, WorkProductFileKind, WorkProductId,\n+};\n+\n+pub use dep_node::{label_strs, DepConstructor, DepKind, DepNode, DepNodeExt};\n+pub use safe::AssertDepGraphSafe;\n+pub use safe::DepGraphSafe;\n+\n+pub type DepGraph = rustc_query_system::dep_graph::DepGraph<DepKind>;\n+pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n+pub type DepGraphQuery = rustc_query_system::dep_graph::DepGraphQuery<DepKind>;\n+pub type PreviousDepGraph = rustc_query_system::dep_graph::PreviousDepGraph<DepKind>;\n+pub type SerializedDepGraph = rustc_query_system::dep_graph::SerializedDepGraph<DepKind>;\n+\n+impl rustc_query_system::dep_graph::DepKind for DepKind {\n+    fn is_eval_always(&self) -> bool {\n+        DepKind::is_eval_always(self)\n+    }\n+\n+    fn has_params(&self) -> bool {\n+        DepKind::has_params(self)\n+    }\n+\n+    fn debug_node(node: &DepNode, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"{:?}\", node.kind)?;\n+\n+        if !node.kind.has_params() && !node.kind.is_anon() {\n+            return Ok(());\n+        }\n+\n+        write!(f, \"(\")?;\n+\n+        ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                if let Some(def_id) = node.extract_def_id(tcx) {\n+                    write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n+                } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*node) {\n+                    write!(f, \"{}\", s)?;\n+                } else {\n+                    write!(f, \"{}\", node.hash)?;\n+                }\n+            } else {\n+                write!(f, \"{}\", node.hash)?;\n+            }\n+            Ok(())\n+        })?;\n+\n+        write!(f, \")\")\n+    }\n+\n+    fn with_deps<OP, R>(task_deps: Option<&Lock<TaskDeps>>, op: OP) -> R\n+    where\n+        OP: FnOnce() -> R,\n+    {\n+        ty::tls::with_context(|icx| {\n+            let icx = ty::tls::ImplicitCtxt { task_deps, ..icx.clone() };\n+\n+            ty::tls::enter_context(&icx, |_| op())\n+        })\n+    }\n+\n+    fn read_deps<OP>(op: OP) -> ()\n+    where\n+        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps>>) -> (),\n+    {\n+        ty::tls::with_context_opt(|icx| {\n+            let icx = if let Some(icx) = icx { icx } else { return };\n+            op(icx.task_deps)\n+        })\n+    }\n+}\n+\n+impl<'tcx> DepContext for TyCtxt<'tcx> {\n+    type DepKind = DepKind;\n+    type StableHashingContext = StableHashingContext<'tcx>;\n+\n+    fn create_stable_hashing_context(&self) -> Self::StableHashingContext {\n+        TyCtxt::create_stable_hashing_context(*self)\n+    }\n+\n+    fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n+        // FIXME: This match is just a workaround for incremental bugs and should\n+        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n+        // bug that must be fixed before removing this.\n+        match dep_node.kind {\n+            DepKind::hir_owner | DepKind::hir_owner_nodes | DepKind::CrateMetadata => {\n+                if let Some(def_id) = dep_node.extract_def_id(*self) {\n+                    if def_id_corresponds_to_hir_dep_node(*self, def_id) {\n+                        if dep_node.kind == DepKind::CrateMetadata {\n+                            // The `DefPath` has corresponding node,\n+                            // and that node should have been marked\n+                            // either red or green in `data.colors`.\n+                            bug!(\n+                                \"DepNode {:?} should have been \\\n+                             pre-marked as red or green but wasn't.\",\n+                                dep_node\n+                            );\n+                        }\n+                    } else {\n+                        // This `DefPath` does not have a\n+                        // corresponding `DepNode` (e.g. a\n+                        // struct field), and the ` DefPath`\n+                        // collided with the `DefPath` of a\n+                        // proper item that existed in the\n+                        // previous compilation session.\n+                        //\n+                        // Since the given `DefPath` does not\n+                        // denote the item that previously\n+                        // existed, we just fail to mark green.\n+                        return false;\n+                    }\n+                } else {\n+                    // If the node does not exist anymore, we\n+                    // just fail to mark green.\n+                    return false;\n+                }\n+            }\n+            _ => {\n+                // For other kinds of nodes it's OK to be\n+                // forced.\n+            }\n+        }\n+\n+        debug!(\"try_force_from_dep_node({:?}) --- trying to force\", dep_node);\n+        ty::query::force_from_dep_node(*self, dep_node)\n+    }\n+\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool {\n+        self.sess.has_errors_or_delayed_span_bugs()\n+    }\n+\n+    fn diagnostic(&self) -> &rustc_errors::Handler {\n+        self.sess.diagnostic()\n+    }\n+\n+    // Interactions with on_disk_cache\n+    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n+        try_load_from_on_disk_cache(*self, dep_node)\n+    }\n+\n+    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic> {\n+        self.queries.on_disk_cache.load_diagnostics(*self, prev_dep_node_index)\n+    }\n+\n+    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>) {\n+        self.queries.on_disk_cache.store_diagnostics(dep_node_index, diagnostics)\n+    }\n+\n+    fn profiler(&self) -> &SelfProfilerRef {\n+        &self.prof\n+    }\n+}\n+\n+fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    def_id.index == hir_id.owner.local_def_index\n+}\n+\n+impl rustc_query_system::HashStableContext for StableHashingContext<'_> {\n+    fn debug_dep_tasks(&self) -> bool {\n+        self.sess().opts.debugging_opts.dep_tasks\n+    }\n+}\n+\n+impl rustc_query_system::HashStableContextProvider<StableHashingContext<'tcx>> for TyCtxt<'tcx> {\n+    fn get_stable_hashing_context(&self) -> StableHashingContext<'tcx> {\n+        self.create_stable_hashing_context()\n+    }\n+}\n+\n+impl rustc_query_system::HashStableContextProvider<StableHashingContext<'a>>\n+    for StableHashingContext<'a>\n+{\n+    fn get_stable_hashing_context(&self) -> Self {\n+        self.clone()\n+    }\n+}"}, {"sha": "47a1c09672ff60aad8fa8c5f84b788d0e34b1b02", "filename": "src/librustc/dep_graph/safe.rs", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fsafe.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -2,56 +2,8 @@\n \n use crate::ty::TyCtxt;\n \n-use rustc_ast::ast::NodeId;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::BodyId;\n-\n-/// The `DepGraphSafe` trait is used to specify what kinds of values\n-/// are safe to \"leak\" into a task. The idea is that this should be\n-/// only be implemented for things like the tcx as well as various id\n-/// types, which will create reads in the dep-graph whenever the trait\n-/// loads anything that might depend on the input program.\n-pub trait DepGraphSafe {}\n-\n-/// A `BodyId` on its own doesn't give access to any particular state.\n-/// You must fetch the state from the various maps or generate\n-/// on-demand queries, all of which create reads.\n-impl DepGraphSafe for BodyId {}\n-\n-/// A `NodeId` on its own doesn't give access to any particular state.\n-/// You must fetch the state from the various maps or generate\n-/// on-demand queries, all of which create reads.\n-impl DepGraphSafe for NodeId {}\n-\n-/// A `DefId` on its own doesn't give access to any particular state.\n-/// You must fetch the state from the various maps or generate\n-/// on-demand queries, all of which create reads.\n-impl DepGraphSafe for DefId {}\n+pub use rustc_query_system::dep_graph::{AssertDepGraphSafe, DepGraphSafe};\n \n /// The type context itself can be used to access all kinds of tracked\n /// state, but those accesses should always generate read events.\n impl<'tcx> DepGraphSafe for TyCtxt<'tcx> {}\n-\n-/// Tuples make it easy to build up state.\n-impl<A, B> DepGraphSafe for (A, B)\n-where\n-    A: DepGraphSafe,\n-    B: DepGraphSafe,\n-{\n-}\n-\n-/// Shared ref to dep-graph-safe stuff should still be dep-graph-safe.\n-impl<'a, A> DepGraphSafe for &'a A where A: DepGraphSafe {}\n-\n-/// Mut ref to dep-graph-safe stuff should still be dep-graph-safe.\n-impl<'a, A> DepGraphSafe for &'a mut A where A: DepGraphSafe {}\n-\n-/// No data here! :)\n-impl DepGraphSafe for () {}\n-\n-/// A convenient override that lets you pass arbitrary state into a\n-/// task. Every use should be accompanied by a comment explaining why\n-/// it makes sense (or how it could be refactored away in the future).\n-pub struct AssertDepGraphSafe<T>(pub T);\n-\n-impl<T> DepGraphSafe for AssertDepGraphSafe<T> {}"}, {"sha": "433076bb8342c22b46b702d9c344136a65867157", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -92,9 +92,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n             ty::ReFree(ref free_region) => {\n                 free_region.hash_stable(hcx, hasher);\n             }\n-            ty::ReClosureBound(vid) => {\n-                vid.hash_stable(hcx, hasher);\n-            }\n             ty::ReVar(..) | ty::RePlaceholder(..) => {\n                 bug!(\"StableHasher: unexpected region {:?}\", *self)\n             }"}, {"sha": "8f06b9a69bd15abebdb7bb2599beaa42e743b079", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -14,7 +14,7 @@ use rustc_hir as hir;\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n use rustc_span::{def_id::DefId, Pos, Span};\n-use std::{any::Any, fmt};\n+use std::{any::Any, fmt, mem};\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n pub enum ErrorHandled {\n@@ -449,9 +449,6 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n pub enum UnsupportedOpInfo {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n-    /// When const-prop encounters a situation it does not support, it raises this error.\n-    /// This must not allocate for performance reasons (hence `str`, not `String`).\n-    ConstPropUnsupported(&'static str),\n     /// Accessing an unsupported foreign static.\n     ReadForeignStatic(DefId),\n     /// Could not find MIR for a function.\n@@ -470,9 +467,6 @@ impl fmt::Debug for UnsupportedOpInfo {\n         use UnsupportedOpInfo::*;\n         match self {\n             Unsupported(ref msg) => write!(f, \"{}\", msg),\n-            ConstPropUnsupported(ref msg) => {\n-                write!(f, \"Constant propagation encountered an unsupported situation: {}\", msg)\n-            }\n             ReadForeignStatic(did) => {\n                 write!(f, \"tried to read from foreign (extern) static {:?}\", did)\n             }\n@@ -494,8 +488,10 @@ impl fmt::Debug for UnsupportedOpInfo {\n pub enum ResourceExhaustionInfo {\n     /// The stack grew too big.\n     StackFrameLimitReached,\n-    /// The program ran into an infinite loop.\n-    InfiniteLoop,\n+    /// The program ran for too long.\n+    ///\n+    /// The exact limit is set by the `const_eval_limit` attribute.\n+    StepLimitReached,\n }\n \n impl fmt::Debug for ResourceExhaustionInfo {\n@@ -505,15 +501,36 @@ impl fmt::Debug for ResourceExhaustionInfo {\n             StackFrameLimitReached => {\n                 write!(f, \"reached the configured maximum number of stack frames\")\n             }\n-            InfiniteLoop => write!(\n-                f,\n-                \"duplicate interpreter state observed here, const evaluation will never \\\n-                    terminate\"\n-            ),\n+            StepLimitReached => {\n+                write!(f, \"exceeded interpreter step limit (see `#[const_eval_limit]`)\")\n+            }\n         }\n     }\n }\n \n+/// A trait to work around not having trait object upcasting.\n+pub trait AsAny: Any {\n+    fn as_any(&self) -> &dyn Any;\n+}\n+\n+impl<T: Any> AsAny for T {\n+    #[inline(always)]\n+    fn as_any(&self) -> &dyn Any {\n+        self\n+    }\n+}\n+\n+/// A trait for machine-specific errors (or other \"machine stop\" conditions).\n+pub trait MachineStopType: AsAny + fmt::Debug + Send {}\n+impl MachineStopType for String {}\n+\n+impl dyn MachineStopType {\n+    #[inline(always)]\n+    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {\n+        self.as_any().downcast_ref()\n+    }\n+}\n+\n pub enum InterpError<'tcx> {\n     /// The program caused undefined behavior.\n     UndefinedBehavior(UndefinedBehaviorInfo),\n@@ -527,7 +544,7 @@ pub enum InterpError<'tcx> {\n     ResourceExhaustion(ResourceExhaustionInfo),\n     /// Stop execution for a machine-controlled reason. This is never raised by\n     /// the core engine itself.\n-    MachineStop(Box<dyn Any + Send>),\n+    MachineStop(Box<dyn MachineStopType>),\n }\n \n pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n@@ -547,7 +564,7 @@ impl fmt::Debug for InterpError<'_> {\n             InvalidProgram(ref msg) => write!(f, \"{:?}\", msg),\n             UndefinedBehavior(ref msg) => write!(f, \"{:?}\", msg),\n             ResourceExhaustion(ref msg) => write!(f, \"{:?}\", msg),\n-            MachineStop(_) => bug!(\"unhandled MachineStop\"),\n+            MachineStop(ref msg) => write!(f, \"{:?}\", msg),\n         }\n     }\n }\n@@ -558,8 +575,9 @@ impl InterpError<'_> {\n     /// waste of resources.\n     pub fn allocates(&self) -> bool {\n         match self {\n-            InterpError::MachineStop(_)\n-            | InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n+            // Zero-sized boxes do not allocate.\n+            InterpError::MachineStop(b) => mem::size_of_val::<dyn MachineStopType>(&**b) > 0,\n+            InterpError::Unsupported(UnsupportedOpInfo::Unsupported(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::ValidationFailure(_))\n             | InterpError::UndefinedBehavior(UndefinedBehaviorInfo::Ub(_)) => true,\n             _ => false,"}, {"sha": "1b5fb4c9954cbcf859303b67c80f696cfca6c2bd", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -97,8 +97,8 @@ mod value;\n \n pub use self::error::{\n     struct_error, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled, FrameInfo,\n-    InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, ResourceExhaustionInfo,\n-    UndefinedBehaviorInfo, UnsupportedOpInfo,\n+    InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n+    ResourceExhaustionInfo, UndefinedBehaviorInfo, UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUndef};\n@@ -156,7 +156,7 @@ pub struct LitToConstInput<'tcx> {\n pub enum LitToConstError {\n     /// The literal's inferred type did not match the expected `ty` in the input.\n     /// This is used for graceful error handling (`delay_span_bug`) in\n-    /// type checking (`AstConv::ast_const_to_const`).\n+    /// type checking (`Const::from_anon_const`).\n     TypeError,\n     UnparseableFloat,\n     Reported,"}, {"sha": "1e47317cf1ace3580021a808a23286682f21185c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 23, "deletions": 332, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -45,6 +45,7 @@ pub mod mono;\n mod query;\n pub mod tcx;\n pub mod traversal;\n+mod type_foldable;\n pub mod visit;\n \n /// Types for locals\n@@ -2046,7 +2047,7 @@ pub enum Rvalue<'tcx> {\n     Use(Operand<'tcx>),\n \n     /// [x; 32]\n-    Repeat(Operand<'tcx>, u64),\n+    Repeat(Operand<'tcx>, &'tcx ty::Const<'tcx>),\n \n     /// &x or &mut x\n     Ref(Region<'tcx>, BorrowKind, Place<'tcx>),\n@@ -2174,7 +2175,11 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n         match *self {\n             Use(ref place) => write!(fmt, \"{:?}\", place),\n-            Repeat(ref a, ref b) => write!(fmt, \"[{:?}; {:?}]\", a, b),\n+            Repeat(ref a, ref b) => {\n+                write!(fmt, \"[{:?}; \", a)?;\n+                pretty_print_const(b, fmt, false)?;\n+                write!(fmt, \"]\")\n+            }\n             Len(ref a) => write!(fmt, \"Len({:?})\", a),\n             Cast(ref kind, ref place, ref ty) => {\n                 write!(fmt, \"{:?} as {:?} ({:?})\", place, ty, kind)\n@@ -2542,18 +2547,26 @@ impl<'tcx> Debug for Constant<'tcx> {\n \n impl<'tcx> Display for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        use crate::ty::print::PrettyPrinter;\n         write!(fmt, \"const \")?;\n-        ty::tls::with(|tcx| {\n-            let literal = tcx.lift(&self.literal).unwrap();\n-            let mut cx = FmtPrinter::new(tcx, fmt, Namespace::ValueNS);\n-            cx.print_alloc_ids = true;\n-            cx.pretty_print_const(literal, true)?;\n-            Ok(())\n-        })\n+        pretty_print_const(self.literal, fmt, true)\n     }\n }\n \n+fn pretty_print_const(\n+    c: &ty::Const<'tcx>,\n+    fmt: &mut Formatter<'_>,\n+    print_types: bool,\n+) -> fmt::Result {\n+    use crate::ty::print::PrettyPrinter;\n+    ty::tls::with(|tcx| {\n+        let literal = tcx.lift(&c).unwrap();\n+        let mut cx = FmtPrinter::new(tcx, fmt, Namespace::ValueNS);\n+        cx.print_alloc_ids = true;\n+        cx.pretty_print_const(literal, print_types)?;\n+        Ok(())\n+    })\n+}\n+\n impl<'tcx> graph::DirectedGraph for Body<'tcx> {\n     type Node = BasicBlock;\n }\n@@ -2651,325 +2664,3 @@ impl Location {\n         }\n     }\n }\n-\n-/*\n- * `TypeFoldable` implementations for MIR types\n-*/\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    BlockTailInfo,\n-    MirPhase,\n-    SourceInfo,\n-    FakeReadCause,\n-    RetagKind,\n-    SourceScope,\n-    SourceScopeData,\n-    SourceScopeLocalData,\n-    UserTypeAnnotationIndex,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        use crate::mir::TerminatorKind::*;\n-\n-        let kind = match self.kind {\n-            Goto { target } => Goto { target },\n-            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n-                discr: discr.fold_with(folder),\n-                switch_ty: switch_ty.fold_with(folder),\n-                values: values.clone(),\n-                targets: targets.clone(),\n-            },\n-            Drop { ref location, target, unwind } => {\n-                Drop { location: location.fold_with(folder), target, unwind }\n-            }\n-            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n-                location: location.fold_with(folder),\n-                value: value.fold_with(folder),\n-                target,\n-                unwind,\n-            },\n-            Yield { ref value, resume, ref resume_arg, drop } => Yield {\n-                value: value.fold_with(folder),\n-                resume,\n-                resume_arg: resume_arg.fold_with(folder),\n-                drop,\n-            },\n-            Call { ref func, ref args, ref destination, cleanup, from_hir_call } => {\n-                let dest =\n-                    destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n-\n-                Call {\n-                    func: func.fold_with(folder),\n-                    args: args.fold_with(folder),\n-                    destination: dest,\n-                    cleanup,\n-                    from_hir_call,\n-                }\n-            }\n-            Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                use AssertKind::*;\n-                let msg = match msg {\n-                    BoundsCheck { ref len, ref index } => {\n-                        BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n-                    }\n-                    Overflow(_)\n-                    | OverflowNeg\n-                    | DivisionByZero\n-                    | RemainderByZero\n-                    | ResumedAfterReturn(_)\n-                    | ResumedAfterPanic(_) => msg.clone(),\n-                };\n-                Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n-            }\n-            GeneratorDrop => GeneratorDrop,\n-            Resume => Resume,\n-            Abort => Abort,\n-            Return => Return,\n-            Unreachable => Unreachable,\n-            FalseEdges { real_target, imaginary_target } => {\n-                FalseEdges { real_target, imaginary_target }\n-            }\n-            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n-        };\n-        Terminator { source_info: self.source_info, kind }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use crate::mir::TerminatorKind::*;\n-\n-        match self.kind {\n-            SwitchInt { ref discr, switch_ty, .. } => {\n-                discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n-            }\n-            Drop { ref location, .. } => location.visit_with(visitor),\n-            DropAndReplace { ref location, ref value, .. } => {\n-                location.visit_with(visitor) || value.visit_with(visitor)\n-            }\n-            Yield { ref value, .. } => value.visit_with(visitor),\n-            Call { ref func, ref args, ref destination, .. } => {\n-                let dest = if let Some((ref loc, _)) = *destination {\n-                    loc.visit_with(visitor)\n-                } else {\n-                    false\n-                };\n-                dest || func.visit_with(visitor) || args.visit_with(visitor)\n-            }\n-            Assert { ref cond, ref msg, .. } => {\n-                if cond.visit_with(visitor) {\n-                    use AssertKind::*;\n-                    match msg {\n-                        BoundsCheck { ref len, ref index } => {\n-                            len.visit_with(visitor) || index.visit_with(visitor)\n-                        }\n-                        Overflow(_)\n-                        | OverflowNeg\n-                        | DivisionByZero\n-                        | RemainderByZero\n-                        | ResumedAfterReturn(_)\n-                        | ResumedAfterPanic(_) => false,\n-                    }\n-                } else {\n-                    false\n-                }\n-            }\n-            Goto { .. }\n-            | Resume\n-            | Abort\n-            | Return\n-            | GeneratorDrop\n-            | Unreachable\n-            | FalseEdges { .. }\n-            | FalseUnwind { .. } => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.local.visit_with(visitor) || self.projection.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>();\n-        folder.tcx().intern_place_elems(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        use crate::mir::Rvalue::*;\n-        match *self {\n-            Use(ref op) => Use(op.fold_with(folder)),\n-            Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n-            Ref(region, bk, ref place) => {\n-                Ref(region.fold_with(folder), bk, place.fold_with(folder))\n-            }\n-            AddressOf(mutability, ref place) => AddressOf(mutability, place.fold_with(folder)),\n-            Len(ref place) => Len(place.fold_with(folder)),\n-            Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n-            BinaryOp(op, ref rhs, ref lhs) => {\n-                BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n-            }\n-            CheckedBinaryOp(op, ref rhs, ref lhs) => {\n-                CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n-            }\n-            UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n-            Discriminant(ref place) => Discriminant(place.fold_with(folder)),\n-            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n-            Aggregate(ref kind, ref fields) => {\n-                let kind = box match **kind {\n-                    AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n-                    AggregateKind::Tuple => AggregateKind::Tuple,\n-                    AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n-                        def,\n-                        v,\n-                        substs.fold_with(folder),\n-                        user_ty.fold_with(folder),\n-                        n,\n-                    ),\n-                    AggregateKind::Closure(id, substs) => {\n-                        AggregateKind::Closure(id, substs.fold_with(folder))\n-                    }\n-                    AggregateKind::Generator(id, substs, movablity) => {\n-                        AggregateKind::Generator(id, substs.fold_with(folder), movablity)\n-                    }\n-                };\n-                Aggregate(kind, fields.fold_with(folder))\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use crate::mir::Rvalue::*;\n-        match *self {\n-            Use(ref op) => op.visit_with(visitor),\n-            Repeat(ref op, _) => op.visit_with(visitor),\n-            Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n-            AddressOf(_, ref place) => place.visit_with(visitor),\n-            Len(ref place) => place.visit_with(visitor),\n-            Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n-            BinaryOp(_, ref rhs, ref lhs) | CheckedBinaryOp(_, ref rhs, ref lhs) => {\n-                rhs.visit_with(visitor) || lhs.visit_with(visitor)\n-            }\n-            UnaryOp(_, ref val) => val.visit_with(visitor),\n-            Discriminant(ref place) => place.visit_with(visitor),\n-            NullaryOp(_, ty) => ty.visit_with(visitor),\n-            Aggregate(ref kind, ref fields) => {\n-                (match **kind {\n-                    AggregateKind::Array(ty) => ty.visit_with(visitor),\n-                    AggregateKind::Tuple => false,\n-                    AggregateKind::Adt(_, _, substs, user_ty, _) => {\n-                        substs.visit_with(visitor) || user_ty.visit_with(visitor)\n-                    }\n-                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n-                    AggregateKind::Generator(_, substs, _) => substs.visit_with(visitor),\n-                }) || fields.visit_with(visitor)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            Operand::Copy(ref place) => Operand::Copy(place.fold_with(folder)),\n-            Operand::Move(ref place) => Operand::Move(place.fold_with(folder)),\n-            Operand::Constant(ref c) => Operand::Constant(c.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            Operand::Copy(ref place) | Operand::Move(ref place) => place.visit_with(visitor),\n-            Operand::Constant(ref c) => c.visit_with(visitor),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        use crate::mir::ProjectionElem::*;\n-\n-        match *self {\n-            Deref => Deref,\n-            Field(f, ty) => Field(f, ty.fold_with(folder)),\n-            Index(v) => Index(v.fold_with(folder)),\n-            Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n-            ConstantIndex { offset, min_length, from_end } => {\n-                ConstantIndex { offset, min_length, from_end }\n-            }\n-            Subslice { from, to, from_end } => Subslice { from, to, from_end },\n-        }\n-    }\n-\n-    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n-        use crate::mir::ProjectionElem::*;\n-\n-        match self {\n-            Field(_, ty) => ty.visit_with(visitor),\n-            Index(v) => v.visit_with(visitor),\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Field {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        self.clone()\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Constant {\n-            span: self.span,\n-            user_ty: self.user_ty.fold_with(folder),\n-            literal: self.literal.fold_with(folder),\n-        }\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.literal.visit_with(visitor)\n-    }\n-}"}, {"sha": "8c81f5227d26099dddde2f9a3b7794aef1dcb424", "filename": "src/librustc/mir/query.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fquery.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -88,34 +88,35 @@ pub struct ConstQualifs {\n /// requirements are then verified and proved by the closure's\n /// creating function. This struct encodes those requirements.\n ///\n-/// The requirements are listed as being between various\n-/// `RegionVid`. The 0th region refers to `'static`; subsequent region\n-/// vids refer to the free regions that appear in the closure (or\n-/// generator's) type, in order of appearance. (This numbering is\n-/// actually defined by the `UniversalRegions` struct in the NLL\n-/// region checker. See for example\n-/// `UniversalRegions::closure_mapping`.) Note that we treat the free\n-/// regions in the closure's type \"as if\" they were erased, so their\n-/// precise identity is not important, only their position.\n+/// The requirements are listed as being between various `RegionVid`. The 0th\n+/// region refers to `'static`; subsequent region vids refer to the free\n+/// regions that appear in the closure (or generator's) type, in order of\n+/// appearance. (This numbering is actually defined by the `UniversalRegions`\n+/// struct in the NLL region checker. See for example\n+/// `UniversalRegions::closure_mapping`.) Note the free regions in the\n+/// closure's signature and captures are erased.\n ///\n /// Example: If type check produces a closure with the closure substs:\n ///\n /// ```text\n /// ClosureSubsts = [\n-///     i8,                                  // the \"closure kind\"\n-///     for<'x> fn(&'a &'x u32) -> &'x u32,  // the \"closure signature\"\n-///     &'a String,                          // some upvar\n+///     'a,                                         // From the parent.\n+///     'b,\n+///     i8,                                         // the \"closure kind\"\n+///     for<'x> fn(&'<erased> &'x u32) -> &'x u32,  // the \"closure signature\"\n+///     &'<erased> String,                          // some upvar\n /// ]\n /// ```\n ///\n-/// here, there is one unique free region (`'a`) but it appears\n-/// twice. We would \"renumber\" each occurrence to a unique vid, as follows:\n+/// We would \"renumber\" each free region to a unique vid, as follows:\n ///\n /// ```text\n /// ClosureSubsts = [\n-///     i8,                                  // the \"closure kind\"\n-///     for<'x> fn(&'1 &'x u32) -> &'x u32,  // the \"closure signature\"\n-///     &'2 String,                          // some upvar\n+///     '1,                                         // From the parent.\n+///     '2,\n+///     i8,                                         // the \"closure kind\"\n+///     for<'x> fn(&'3 &'x u32) -> &'x u32,         // the \"closure signature\"\n+///     &'4 String,                                 // some upvar\n /// ]\n /// ```\n ///\n@@ -124,14 +125,12 @@ pub struct ConstQualifs {\n /// can be extracted from its type and constrained to have the given\n /// outlives relationship.\n ///\n-/// In some cases, we have to record outlives requirements between\n-/// types and regions as well. In that case, if those types include\n-/// any regions, those regions are recorded as `ReClosureBound`\n-/// instances assigned one of these same indices. Those regions will\n-/// be substituted away by the creator. We use `ReClosureBound` in\n-/// that case because the regions must be allocated in the global\n-/// `TyCtxt`, and hence we cannot use `ReVar` (which is what we use\n-/// internally within the rest of the NLL code).\n+/// In some cases, we have to record outlives requirements between types and\n+/// regions as well. In that case, if those types include any regions, those\n+/// regions are recorded using their external names (`ReStatic`,\n+/// `ReEarlyBound`, `ReFree`). We use these because in a query response we\n+/// cannot use `ReVar` (which is what we use internally within the rest of the\n+/// NLL code).\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'tcx> {\n     /// The number of external regions defined on the closure. In our"}, {"sha": "feb663192671254004096cff7d5212f5099d80e8", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -149,7 +149,9 @@ impl<'tcx> Rvalue<'tcx> {\n     {\n         match *self {\n             Rvalue::Use(ref operand) => operand.ty(local_decls, tcx),\n-            Rvalue::Repeat(ref operand, count) => tcx.mk_array(operand.ty(local_decls, tcx), count),\n+            Rvalue::Repeat(ref operand, count) => {\n+                tcx.mk_ty(ty::Array(operand.ty(local_decls, tcx), count))\n+            }\n             Rvalue::Ref(reg, bk, ref place) => {\n                 let place_ty = place.ty(local_decls, tcx).ty;\n                 tcx.mk_ref(reg, ty::TypeAndMut { ty: place_ty, mutbl: bk.to_mutbl_lossy() })"}, {"sha": "9520f081b6bfbb28bc40f4e99428c3ab09ab21d7", "filename": "src/librustc/mir/type_foldable.rs", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftype_foldable.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -0,0 +1,322 @@\n+//! `TypeFoldable` implementations for MIR types\n+\n+use super::*;\n+use crate::ty;\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    BlockTailInfo,\n+    MirPhase,\n+    SourceInfo,\n+    FakeReadCause,\n+    RetagKind,\n+    SourceScope,\n+    SourceScopeData,\n+    SourceScopeLocalData,\n+    UserTypeAnnotationIndex,\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        use crate::mir::TerminatorKind::*;\n+\n+        let kind = match self.kind {\n+            Goto { target } => Goto { target },\n+            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n+                discr: discr.fold_with(folder),\n+                switch_ty: switch_ty.fold_with(folder),\n+                values: values.clone(),\n+                targets: targets.clone(),\n+            },\n+            Drop { ref location, target, unwind } => {\n+                Drop { location: location.fold_with(folder), target, unwind }\n+            }\n+            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n+                location: location.fold_with(folder),\n+                value: value.fold_with(folder),\n+                target,\n+                unwind,\n+            },\n+            Yield { ref value, resume, ref resume_arg, drop } => Yield {\n+                value: value.fold_with(folder),\n+                resume,\n+                resume_arg: resume_arg.fold_with(folder),\n+                drop,\n+            },\n+            Call { ref func, ref args, ref destination, cleanup, from_hir_call } => {\n+                let dest =\n+                    destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n+\n+                Call {\n+                    func: func.fold_with(folder),\n+                    args: args.fold_with(folder),\n+                    destination: dest,\n+                    cleanup,\n+                    from_hir_call,\n+                }\n+            }\n+            Assert { ref cond, expected, ref msg, target, cleanup } => {\n+                use AssertKind::*;\n+                let msg = match msg {\n+                    BoundsCheck { ref len, ref index } => {\n+                        BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n+                    }\n+                    Overflow(_)\n+                    | OverflowNeg\n+                    | DivisionByZero\n+                    | RemainderByZero\n+                    | ResumedAfterReturn(_)\n+                    | ResumedAfterPanic(_) => msg.clone(),\n+                };\n+                Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n+            }\n+            GeneratorDrop => GeneratorDrop,\n+            Resume => Resume,\n+            Abort => Abort,\n+            Return => Return,\n+            Unreachable => Unreachable,\n+            FalseEdges { real_target, imaginary_target } => {\n+                FalseEdges { real_target, imaginary_target }\n+            }\n+            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n+        };\n+        Terminator { source_info: self.source_info, kind }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use crate::mir::TerminatorKind::*;\n+\n+        match self.kind {\n+            SwitchInt { ref discr, switch_ty, .. } => {\n+                discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n+            }\n+            Drop { ref location, .. } => location.visit_with(visitor),\n+            DropAndReplace { ref location, ref value, .. } => {\n+                location.visit_with(visitor) || value.visit_with(visitor)\n+            }\n+            Yield { ref value, .. } => value.visit_with(visitor),\n+            Call { ref func, ref args, ref destination, .. } => {\n+                let dest = if let Some((ref loc, _)) = *destination {\n+                    loc.visit_with(visitor)\n+                } else {\n+                    false\n+                };\n+                dest || func.visit_with(visitor) || args.visit_with(visitor)\n+            }\n+            Assert { ref cond, ref msg, .. } => {\n+                if cond.visit_with(visitor) {\n+                    use AssertKind::*;\n+                    match msg {\n+                        BoundsCheck { ref len, ref index } => {\n+                            len.visit_with(visitor) || index.visit_with(visitor)\n+                        }\n+                        Overflow(_)\n+                        | OverflowNeg\n+                        | DivisionByZero\n+                        | RemainderByZero\n+                        | ResumedAfterReturn(_)\n+                        | ResumedAfterPanic(_) => false,\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+            Goto { .. }\n+            | Resume\n+            | Abort\n+            | Return\n+            | GeneratorDrop\n+            | Unreachable\n+            | FalseEdges { .. }\n+            | FalseUnwind { .. } => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.local.visit_with(visitor) || self.projection.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>();\n+        folder.tcx().intern_place_elems(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        use crate::mir::Rvalue::*;\n+        match *self {\n+            Use(ref op) => Use(op.fold_with(folder)),\n+            Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n+            Ref(region, bk, ref place) => {\n+                Ref(region.fold_with(folder), bk, place.fold_with(folder))\n+            }\n+            AddressOf(mutability, ref place) => AddressOf(mutability, place.fold_with(folder)),\n+            Len(ref place) => Len(place.fold_with(folder)),\n+            Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n+            BinaryOp(op, ref rhs, ref lhs) => {\n+                BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n+            }\n+            CheckedBinaryOp(op, ref rhs, ref lhs) => {\n+                CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n+            }\n+            UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n+            Discriminant(ref place) => Discriminant(place.fold_with(folder)),\n+            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n+            Aggregate(ref kind, ref fields) => {\n+                let kind = box match **kind {\n+                    AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n+                    AggregateKind::Tuple => AggregateKind::Tuple,\n+                    AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n+                        def,\n+                        v,\n+                        substs.fold_with(folder),\n+                        user_ty.fold_with(folder),\n+                        n,\n+                    ),\n+                    AggregateKind::Closure(id, substs) => {\n+                        AggregateKind::Closure(id, substs.fold_with(folder))\n+                    }\n+                    AggregateKind::Generator(id, substs, movablity) => {\n+                        AggregateKind::Generator(id, substs.fold_with(folder), movablity)\n+                    }\n+                };\n+                Aggregate(kind, fields.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use crate::mir::Rvalue::*;\n+        match *self {\n+            Use(ref op) => op.visit_with(visitor),\n+            Repeat(ref op, _) => op.visit_with(visitor),\n+            Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n+            AddressOf(_, ref place) => place.visit_with(visitor),\n+            Len(ref place) => place.visit_with(visitor),\n+            Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n+            BinaryOp(_, ref rhs, ref lhs) | CheckedBinaryOp(_, ref rhs, ref lhs) => {\n+                rhs.visit_with(visitor) || lhs.visit_with(visitor)\n+            }\n+            UnaryOp(_, ref val) => val.visit_with(visitor),\n+            Discriminant(ref place) => place.visit_with(visitor),\n+            NullaryOp(_, ty) => ty.visit_with(visitor),\n+            Aggregate(ref kind, ref fields) => {\n+                (match **kind {\n+                    AggregateKind::Array(ty) => ty.visit_with(visitor),\n+                    AggregateKind::Tuple => false,\n+                    AggregateKind::Adt(_, _, substs, user_ty, _) => {\n+                        substs.visit_with(visitor) || user_ty.visit_with(visitor)\n+                    }\n+                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n+                    AggregateKind::Generator(_, substs, _) => substs.visit_with(visitor),\n+                }) || fields.visit_with(visitor)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            Operand::Copy(ref place) => Operand::Copy(place.fold_with(folder)),\n+            Operand::Move(ref place) => Operand::Move(place.fold_with(folder)),\n+            Operand::Constant(ref c) => Operand::Constant(c.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            Operand::Copy(ref place) | Operand::Move(ref place) => place.visit_with(visitor),\n+            Operand::Constant(ref c) => c.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        use crate::mir::ProjectionElem::*;\n+\n+        match *self {\n+            Deref => Deref,\n+            Field(f, ty) => Field(f, ty.fold_with(folder)),\n+            Index(v) => Index(v.fold_with(folder)),\n+            Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n+            ConstantIndex { offset, min_length, from_end } => {\n+                ConstantIndex { offset, min_length, from_end }\n+            }\n+            Subslice { from, to, from_end } => Subslice { from, to, from_end },\n+        }\n+    }\n+\n+    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n+        use crate::mir::ProjectionElem::*;\n+\n+        match self {\n+            Field(_, ty) => ty.visit_with(visitor),\n+            Index(v) => v.visit_with(visitor),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Field {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        self.clone()\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Constant {\n+            span: self.span,\n+            user_ty: self.user_ty.fold_with(folder),\n+            literal: self.literal.fold_with(folder),\n+        }\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.literal.visit_with(visitor)\n+    }\n+}"}, {"sha": "58bff2f13eb70b9e62009e33a600f4f83d516927", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1574,7 +1574,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n             ty::ReVar(_) | ty::ReScope(_) | ty::ReErased => false,\n \n-            ty::ReStatic | ty::ReEmpty(_) | ty::ReClosureBound(_) => true,\n+            ty::ReStatic | ty::ReEmpty(_) => true,\n         }\n     }\n \n@@ -1686,12 +1686,6 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n                 p!(write(\"'<empty:{:?}>\", ui));\n                 return Ok(self);\n             }\n-\n-            // The user should never encounter these in unsubstituted form.\n-            ty::ReClosureBound(vid) => {\n-                p!(write(\"{:?}\", vid));\n-                return Ok(self);\n-            }\n         }\n \n         p!(write(\"'_\"));"}, {"sha": "b45b3b3f539eafeae96a7936036c8c8151eb90ee", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -150,8 +150,6 @@ rustc_query_append! { [define_queries!][<'tcx>] }\n /// add it to the \"We don't have enough information to reconstruct...\" group in\n /// the match below.\n pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool {\n-    use crate::dep_graph::DepKind;\n-\n     // We must avoid ever having to call `force_from_dep_node()` for a\n     // `DepNode::codegen_unit`:\n     // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n@@ -166,7 +164,7 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n     // hit the cache instead of having to go through `force_from_dep_node`.\n     // This assertion makes sure, we actually keep applying the solution above.\n     debug_assert!(\n-        dep_node.kind != DepKind::codegen_unit,\n+        dep_node.kind != crate::dep_graph::DepKind::codegen_unit,\n         \"calling force_from_dep_node() on DepKind::codegen_unit\"\n     );\n \n@@ -177,30 +175,21 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n         // should therefore always be red or green already.\n-        DepKind::CrateMetadata |\n+        crate::dep_graph::DepKind::CrateMetadata |\n \n         // These are anonymous nodes.\n-        DepKind::TraitSelect |\n+        crate::dep_graph::DepKind::TraitSelect |\n \n         // We don't have enough information to reconstruct the query key of\n         // these.\n-        DepKind::CompileCodegenUnit => {\n+        crate::dep_graph::DepKind::CompileCodegenUnit => {\n             bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n         }\n     );\n \n     false\n }\n \n-impl DepNode {\n-    /// Check whether the query invocation corresponding to the given\n-    /// DepNode is eligible for on-disk-caching. If so, this is method\n-    /// will execute the query corresponding to the given DepNode.\n-    /// Also, as a sanity check, it expects that the corresponding query\n-    /// invocation has been marked as green already.\n-    pub fn try_load_from_on_disk_cache<'tcx>(&self, tcx: TyCtxt<'tcx>) {\n-        use crate::dep_graph::DepKind;\n-\n-        rustc_dep_node_try_load_from_on_disk_cache!(self, tcx)\n-    }\n+pub(crate) fn try_load_from_on_disk_cache<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) {\n+    rustc_dep_node_try_load_from_on_disk_cache!(dep_node, tcx)\n }"}, {"sha": "81be5b11143afcc06be525ca310fb4255e4f1f39", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -81,8 +81,6 @@ impl fmt::Debug for ty::RegionKind {\n         match *self {\n             ty::ReEarlyBound(ref data) => write!(f, \"ReEarlyBound({}, {})\", data.index, data.name),\n \n-            ty::ReClosureBound(ref vid) => write!(f, \"ReClosureBound({:?})\", vid),\n-\n             ty::ReLateBound(binder_id, ref bound_region) => {\n                 write!(f, \"ReLateBound({:?}, {:?})\", binder_id, bound_region)\n             }"}, {"sha": "d440e84e15c457d02e083411ae7cba38c2e78a1b", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 87, "deletions": 12, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -8,7 +8,7 @@ use self::TyKind::*;\n use crate::infer::canonical::Canonical;\n use crate::middle::region;\n use crate::mir::interpret::ConstValue;\n-use crate::mir::interpret::Scalar;\n+use crate::mir::interpret::{LitToConstInput, Scalar};\n use crate::mir::Promoted;\n use crate::ty::layout::VariantIdx;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n@@ -20,7 +20,7 @@ use polonius_engine::Atom;\n use rustc_ast::ast::{self, Ident};\n use rustc_data_structures::captures::Captures;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::vec::Idx;\n use rustc_macros::HashStable;\n use rustc_span::symbol::{kw, Symbol};\n@@ -1352,12 +1352,6 @@ pub enum RegionKind {\n \n     /// Erased region, used by trait selection, in MIR and during codegen.\n     ReErased,\n-\n-    /// These are regions bound in the \"defining type\" for a\n-    /// closure. They are used ONLY as part of the\n-    /// `ClosureRegionRequirements` that are produced by MIR borrowck.\n-    /// See `ClosureRegionRequirements` for more details.\n-    ReClosureBound(RegionVid),\n }\n \n impl<'tcx> rustc_serialize::UseSpecializedDecodable for Region<'tcx> {}\n@@ -1567,7 +1561,6 @@ impl RegionKind {\n             RegionKind::RePlaceholder(placeholder) => placeholder.name.is_named(),\n             RegionKind::ReEmpty(_) => false,\n             RegionKind::ReErased => false,\n-            RegionKind::ReClosureBound(..) => false,\n         }\n     }\n \n@@ -1648,9 +1641,6 @@ impl RegionKind {\n             ty::ReEmpty(_) | ty::ReStatic => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n-            ty::ReClosureBound(..) => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-            }\n             ty::ReLateBound(..) => {\n                 flags = flags | TypeFlags::HAS_RE_LATE_BOUND;\n             }\n@@ -2275,17 +2265,92 @@ pub struct Const<'tcx> {\n static_assert_size!(Const<'_>, 48);\n \n impl<'tcx> Const<'tcx> {\n+    /// Literals and const generic parameters are eagerly converted to a constant, everything else\n+    /// becomes `Unevaluated`.\n+    pub fn from_anon_const(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx Self {\n+        debug!(\"Const::from_anon_const(id={:?})\", def_id);\n+\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+\n+        let body_id = match tcx.hir().get(hir_id) {\n+            hir::Node::AnonConst(ac) => ac.body,\n+            _ => span_bug!(\n+                tcx.def_span(def_id.to_def_id()),\n+                \"from_anon_const can only process anonymous constants\"\n+            ),\n+        };\n+\n+        let expr = &tcx.hir().body(body_id).value;\n+\n+        let ty = tcx.type_of(def_id.to_def_id());\n+\n+        let lit_input = match expr.kind {\n+            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n+            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => match expr.kind {\n+                hir::ExprKind::Lit(ref lit) => {\n+                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+\n+        if let Some(lit_input) = lit_input {\n+            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n+            // mir.\n+            if let Ok(c) = tcx.at(expr.span).lit_to_const(lit_input) {\n+                return c;\n+            } else {\n+                tcx.sess.delay_span_bug(expr.span, \"Const::from_anon_const: couldn't lit_to_const\");\n+            }\n+        }\n+\n+        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n+        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n+        let expr = match &expr.kind {\n+            hir::ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n+                block.expr.as_ref().unwrap()\n+            }\n+            _ => expr,\n+        };\n+\n+        use hir::{def::DefKind::ConstParam, def::Res, ExprKind, Path, QPath};\n+        let val = match expr.kind {\n+            ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n+                // Find the name and index of the const parameter by indexing the generics of\n+                // the parent item and construct a `ParamConst`.\n+                let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+                let item_id = tcx.hir().get_parent_node(hir_id);\n+                let item_def_id = tcx.hir().local_def_id(item_id);\n+                let generics = tcx.generics_of(item_def_id);\n+                let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id)];\n+                let name = tcx.hir().name(hir_id);\n+                ty::ConstKind::Param(ty::ParamConst::new(index, name))\n+            }\n+            _ => ty::ConstKind::Unevaluated(\n+                def_id.to_def_id(),\n+                InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n+                None,\n+            ),\n+        };\n+\n+        tcx.mk_const(ty::Const { val, ty })\n+    }\n+\n     #[inline]\n+    /// Interns the given value as a constant.\n     pub fn from_value(tcx: TyCtxt<'tcx>, val: ConstValue<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n         tcx.mk_const(Self { val: ConstKind::Value(val), ty })\n     }\n \n     #[inline]\n+    /// Interns the given scalar as a constant.\n     pub fn from_scalar(tcx: TyCtxt<'tcx>, val: Scalar, ty: Ty<'tcx>) -> &'tcx Self {\n         Self::from_value(tcx, ConstValue::Scalar(val), ty)\n     }\n \n     #[inline]\n+    /// Creates a constant with the given integer value and interns it.\n     pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> &'tcx Self {\n         let size = tcx\n             .layout_of(ty)\n@@ -2295,21 +2360,27 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n+    /// Creates an interned zst constant.\n     pub fn zero_sized(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n         Self::from_scalar(tcx, Scalar::zst(), ty)\n     }\n \n     #[inline]\n+    /// Creates an interned bool constant.\n     pub fn from_bool(tcx: TyCtxt<'tcx>, v: bool) -> &'tcx Self {\n         Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n     }\n \n     #[inline]\n+    /// Creates an interned usize constant.\n     pub fn from_usize(tcx: TyCtxt<'tcx>, n: u64) -> &'tcx Self {\n         Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n     }\n \n     #[inline]\n+    /// Attempts to evaluate the given constant to bits. Can fail to evaluate in the presence of\n+    /// generics (or erroneous code) or if the value can't be represented as bits (e.g. because it\n+    /// contains const generic parameters or pointers).\n     pub fn try_eval_bits(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -2323,6 +2394,8 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n+    /// Tries to evaluate the constant if it is `Unevaluated`. If that doesn't succeed, return the\n+    /// unevaluated constant.\n     pub fn eval(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> &Const<'tcx> {\n         let try_const_eval = |did, param_env: ParamEnv<'tcx>, substs, promoted| {\n             let param_env_and_substs = param_env.with_reveal_all().and(substs);\n@@ -2379,12 +2452,14 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n+    /// Panics if the value cannot be evaluated or doesn't contain a valid integer of the given type.\n     pub fn eval_bits(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>, ty: Ty<'tcx>) -> u128 {\n         self.try_eval_bits(tcx, param_env, ty)\n             .unwrap_or_else(|| bug!(\"expected bits of {:#?}, got {:#?}\", ty, self))\n     }\n \n     #[inline]\n+    /// Panics if the value cannot be evaluated or doesn't contain a valid `usize`.\n     pub fn eval_usize(&self, tcx: TyCtxt<'tcx>, param_env: ParamEnv<'tcx>) -> u64 {\n         self.eval_bits(tcx, param_env, tcx.types.usize) as u64\n     }"}, {"sha": "880bce7fde48787bae133261cedd815c411cfbc0", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -106,6 +106,9 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 }\n \n+                let count =\n+                    self.monomorphize(&count).eval_usize(bx.cx().tcx(), ty::ParamEnv::reveal_all());\n+\n                 bx.write_operand_repeatedly(cg_elem, count, dest)\n             }\n "}, {"sha": "b2c8437049001950fc5f8b16698c88076392788b", "filename": "src/librustc_error_codes/error_codes/E0308.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0308.md?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -13,7 +13,7 @@ let x: i32 = \"I am not a number!\";\n ```\n \n This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n+variable. It can happen in several cases, the most common being a mismatch\n+between the type that the compiler inferred for a variable based on its\n+initializing expression, on the one hand, and the type the author explicitly\n+assigned to the variable, on the other hand."}, {"sha": "429813a7cdd4ede67132e041df72ad0c4d0cb5ef", "filename": "src/librustc_error_codes/error_codes/E0452.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_error_codes%2Ferror_codes%2FE0452.md", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_error_codes%2Ferror_codes%2FE0452.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0452.md?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,4 +1,6 @@\n-An invalid lint attribute has been given. Erroneous code example:\n+An invalid lint attribute has been given.\n+\n+Erroneous code example:\n \n ```compile_fail,E0452\n #![allow(foo = \"\")] // error: malformed lint attribute"}, {"sha": "305e0fcc383ad260bfbece88eedeb9d79ae70361", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -35,7 +35,7 @@\n \n use graphviz as dot;\n use rustc::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n-use rustc::dep_graph::{DepGraphQuery, DepKind, DepNode};\n+use rustc::dep_graph::{DepGraphQuery, DepKind, DepNode, DepNodeExt};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n use rustc_ast::ast;"}, {"sha": "9ddd238afff2bb7e2d2d193817e085cb913f8299", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -13,7 +13,7 @@\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n \n-use rustc::dep_graph::{label_strs, DepNode};\n+use rustc::dep_graph::{label_strs, DepNode, DepNodeExt};\n use rustc::hir::map::Map;\n use rustc::ty::TyCtxt;\n use rustc_ast::ast::{self, Attribute, NestedMetaItem};"}, {"sha": "4d9a81d4406958339ba5cd785394e3a11e9eba7d", "filename": "src/librustc_infer/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -336,10 +336,6 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n             | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n             | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n-\n-            ty::ReClosureBound(..) => {\n-                bug!(\"closure bound region encountered during canonicalization\");\n-            }\n         }\n     }\n "}, {"sha": "0f5d4d30a2385282fce7b043444e990fcbf50d92", "filename": "src/librustc_infer/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fcombine.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -581,10 +581,6 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 return Ok(r);\n             }\n \n-            ty::ReClosureBound(..) => {\n-                span_bug!(self.span, \"encountered unexpected ReClosureBound: {:?}\", r,);\n-            }\n-\n             ty::RePlaceholder(..)\n             | ty::ReVar(..)\n             | ty::ReEmpty(_)"}, {"sha": "a2ae4f53fb8f2b11c666241fa423d7225d6bd4a7", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -152,11 +152,6 @@ pub(super) fn note_and_explain_region(\n         ty::ReVar(_) | ty::ReLateBound(..) | ty::ReErased => {\n             (format!(\"lifetime {:?}\", region), None)\n         }\n-\n-        // We shouldn't encounter an error message with ReClosureBound.\n-        ty::ReClosureBound(..) => {\n-            bug!(\"encountered unexpected ReClosureBound: {:?}\", region,);\n-        }\n     };\n \n     emit_msg_span(err, prefix, description, span, suffix);"}, {"sha": "fa28cf5b45464d2a0cac323b07179bb26fdcec36", "filename": "src/librustc_infer/infer/freshen.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffreshen.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -135,10 +135,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 // replace all free regions with 'erased\n                 self.tcx().lifetimes.re_erased\n             }\n-\n-            ty::ReClosureBound(..) => {\n-                bug!(\"encountered unexpected region: {:?}\", r,);\n-            }\n         }\n     }\n "}, {"sha": "d81c7454a0fe59538a8364c7a870ca7121109537", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -493,12 +493,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     /// term \"concrete regions\").\n     fn lub_concrete_regions(&self, a: Region<'tcx>, b: Region<'tcx>) -> Region<'tcx> {\n         let r = match (a, b) {\n-            (&ty::ReClosureBound(..), _)\n-            | (_, &ty::ReClosureBound(..))\n-            | (&ReLateBound(..), _)\n-            | (_, &ReLateBound(..))\n-            | (&ReErased, _)\n-            | (_, &ReErased) => {\n+            (&ReLateBound(..), _) | (_, &ReLateBound(..)) | (&ReErased, _) | (_, &ReErased) => {\n                 bug!(\"cannot relate region: LUB({:?}, {:?})\", a, b);\n             }\n "}, {"sha": "72637f4544a3531af430fe51c85afec21bb411d8", "filename": "src/librustc_infer/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fregion_constraints%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -798,7 +798,7 @@ impl<'tcx> RegionConstraintCollector<'tcx> {\n             | ty::ReEarlyBound(..) => ty::UniverseIndex::ROOT,\n             ty::ReEmpty(ui) => ui,\n             ty::RePlaceholder(placeholder) => placeholder.universe,\n-            ty::ReClosureBound(vid) | ty::ReVar(vid) => self.var_universe(vid),\n+            ty::ReVar(vid) => self.var_universe(vid),\n             ty::ReLateBound(..) => bug!(\"universe(): encountered bound region {:?}\", region),\n         }\n     }"}, {"sha": "66d9fe7e149882ba9cd86696ac9ee4ec4ea7ad6d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -349,6 +349,7 @@ impl MissingDoc {\n         id: Option<hir::HirId>,\n         attrs: &[ast::Attribute],\n         sp: Span,\n+        article: &'static str,\n         desc: &'static str,\n     ) {\n         // If we're building a test harness, then warning about\n@@ -374,7 +375,7 @@ impl MissingDoc {\n         let has_doc = attrs.iter().any(|a| has_doc(a));\n         if !has_doc {\n             cx.struct_span_lint(MISSING_DOCS, cx.tcx.sess.source_map().def_span(sp), |lint| {\n-                lint.build(&format!(\"missing documentation for {}\", desc)).emit()\n+                lint.build(&format!(\"missing documentation for {} {}\", article, desc)).emit()\n             });\n         }\n     }\n@@ -398,7 +399,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &LateContext<'_, '_>, krate: &hir::Crate<'_>) {\n-        self.check_missing_docs_attrs(cx, None, &krate.item.attrs, krate.item.span, \"crate\");\n+        self.check_missing_docs_attrs(cx, None, &krate.item.attrs, krate.item.span, \"the\", \"crate\");\n \n         for macro_def in krate.exported_macros {\n             let has_doc = macro_def.attrs.iter().any(|a| has_doc(a));\n@@ -413,12 +414,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item<'_>) {\n-        let desc = match it.kind {\n-            hir::ItemKind::Fn(..) => \"a function\",\n-            hir::ItemKind::Mod(..) => \"a module\",\n-            hir::ItemKind::Enum(..) => \"an enum\",\n-            hir::ItemKind::Struct(..) => \"a struct\",\n-            hir::ItemKind::Union(..) => \"a union\",\n+        match it.kind {\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 // Issue #11592: traits are always considered exported, even when private.\n                 if let hir::VisibilityKind::Inherited = it.vis.node {\n@@ -428,51 +424,55 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                     }\n                     return;\n                 }\n-                \"a trait\"\n             }\n-            hir::ItemKind::TyAlias(..) => \"a type alias\",\n             hir::ItemKind::Impl { of_trait: Some(ref trait_ref), items, .. } => {\n                 // If the trait is private, add the impl items to `private_traits` so they don't get\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n                 if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(real_trait) {\n-                    match cx.tcx.hir().find(hir_id) {\n-                        Some(Node::Item(item)) => {\n-                            if let hir::VisibilityKind::Inherited = item.vis.node {\n-                                for impl_item_ref in items {\n-                                    self.private_traits.insert(impl_item_ref.id.hir_id);\n-                                }\n+                    if let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) {\n+                        if let hir::VisibilityKind::Inherited = item.vis.node {\n+                            for impl_item_ref in items {\n+                                self.private_traits.insert(impl_item_ref.id.hir_id);\n                             }\n                         }\n-                        _ => {}\n                     }\n                 }\n                 return;\n             }\n-            hir::ItemKind::Const(..) => \"a constant\",\n-            hir::ItemKind::Static(..) => \"a static\",\n+\n+            hir::ItemKind::TyAlias(..)\n+            | hir::ItemKind::Fn(..)\n+            | hir::ItemKind::Mod(..)\n+            | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::Union(..)\n+            | hir::ItemKind::Const(..)\n+            | hir::ItemKind::Static(..) => {}\n+\n             _ => return,\n         };\n \n-        self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, desc);\n+        let def_id = cx.tcx.hir().local_def_id(it.hir_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id);\n+\n+        self.check_missing_docs_attrs(cx, Some(it.hir_id), &it.attrs, it.span, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, trait_item: &hir::TraitItem<'_>) {\n         if self.private_traits.contains(&trait_item.hir_id) {\n             return;\n         }\n \n-        let desc = match trait_item.kind {\n-            hir::TraitItemKind::Const(..) => \"an associated constant\",\n-            hir::TraitItemKind::Fn(..) => \"a trait method\",\n-            hir::TraitItemKind::Type(..) => \"an associated type\",\n-        };\n+        let def_id = cx.tcx.hir().local_def_id(trait_item.hir_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id);\n \n         self.check_missing_docs_attrs(\n             cx,\n             Some(trait_item.hir_id),\n             &trait_item.attrs,\n             trait_item.span,\n+            article,\n             desc,\n         );\n     }\n@@ -483,29 +483,33 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             return;\n         }\n \n-        let desc = match impl_item.kind {\n-            hir::ImplItemKind::Const(..) => \"an associated constant\",\n-            hir::ImplItemKind::Fn(..) => \"a method\",\n-            hir::ImplItemKind::TyAlias(_) => \"an associated type\",\n-            hir::ImplItemKind::OpaqueTy(_) => \"an associated `impl Trait` type\",\n-        };\n+        let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id);\n         self.check_missing_docs_attrs(\n             cx,\n             Some(impl_item.hir_id),\n             &impl_item.attrs,\n             impl_item.span,\n+            article,\n             desc,\n         );\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, sf: &hir::StructField<'_>) {\n         if !sf.is_positional() {\n-            self.check_missing_docs_attrs(cx, Some(sf.hir_id), &sf.attrs, sf.span, \"a struct field\")\n+            self.check_missing_docs_attrs(\n+                cx,\n+                Some(sf.hir_id),\n+                &sf.attrs,\n+                sf.span,\n+                \"a\",\n+                \"struct field\",\n+            )\n         }\n     }\n \n     fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant<'_>) {\n-        self.check_missing_docs_attrs(cx, Some(v.id), &v.attrs, v.span, \"a variant\");\n+        self.check_missing_docs_attrs(cx, Some(v.id), &v.attrs, v.span, \"a\", \"variant\");\n     }\n }\n "}, {"sha": "e7005f2f5ba775578e5fcd5ffa3c69f0d77246e9", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -429,14 +429,14 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 });\n \n                 try_load_from_on_disk_cache_stream.extend(quote! {\n-                    DepKind::#name => {\n-                        if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n+                    ::rustc::dep_graph::DepKind::#name => {\n+                        if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n                             debug_assert!($tcx.dep_graph\n                                             .node_color($dep_node)\n                                             .map(|c| c.is_green())\n                                             .unwrap_or(false));\n \n-                            let key = <#arg as DepNodeParams>::recover($tcx, $dep_node).unwrap();\n+                            let key = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node).unwrap();\n                             if queries::#name::cache_on_disk($tcx, key, None) {\n                                 let _ = $tcx.#name(key);\n                             }\n@@ -486,9 +486,9 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n             // Add a match arm to force the query given the dep node\n             dep_node_force_stream.extend(quote! {\n-                DepKind::#name => {\n-                    if <#arg as DepNodeParams>::CAN_RECONSTRUCT_QUERY_KEY {\n-                        if let Some(key) = <#arg as DepNodeParams>::recover($tcx, $dep_node) {\n+                ::rustc::dep_graph::DepKind::#name => {\n+                    if <#arg as DepNodeParams<TyCtxt<'_>>>::CAN_RECONSTRUCT_QUERY_KEY {\n+                        if let Some(key) = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node) {\n                             $tcx.force_query::<crate::ty::query::queries::#name<'_>>(\n                                 key,\n                                 DUMMY_SP,\n@@ -509,7 +509,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     }\n \n     dep_node_force_stream.extend(quote! {\n-        DepKind::Null => {\n+        ::rustc::dep_graph::DepKind::Null => {\n             bug!(\"Cannot force dep node: {:?}\", $dep_node)\n         }\n     });"}, {"sha": "4e086bcbb2d92e1b7a6c3c0c9cd9eed2a6993345", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -4,7 +4,7 @@ use crate::creader::CrateMetadataRef;\n use crate::rmeta::table::{FixedSizeEncoding, Table};\n use crate::rmeta::*;\n \n-use rustc::dep_graph::{self, DepNode, DepNodeIndex};\n+use rustc::dep_graph::{self, DepNode, DepNodeExt, DepNodeIndex};\n use rustc::hir::exports::Export;\n use rustc::middle::cstore::{CrateSource, ExternCrate};\n use rustc::middle::cstore::{ForeignModule, LinkagePreference, NativeLibrary};"}, {"sha": "ee654431d8892854458402238877bd066a13529e", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,9 +1,10 @@\n-use rustc::mir::{self, ClearCrossCrate, Local, LocalInfo, Location, ReadOnlyBodyAndCache};\n+use rustc::mir::{self, ClearCrossCrate, Local, LocalInfo, Location};\n use rustc::mir::{Mutability, Place, PlaceRef, ProjectionElem};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n use rustc_hir::Node;\n use rustc_index::vec::Idx;\n+use rustc_span::source_map::DesugaringKind;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n \n@@ -338,24 +339,53 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                 match self.local_names[local] {\n                     Some(name) if !local_decl.from_compiler_desugaring() => {\n-                        let suggestion = match local_decl.local_info {\n+                        let label = match local_decl.local_info {\n                             LocalInfo::User(ClearCrossCrate::Set(\n                                 mir::BindingForm::ImplicitSelf(_),\n-                            )) => Some(suggest_ampmut_self(self.infcx.tcx, local_decl)),\n+                            )) => {\n+                                let (span, suggestion) =\n+                                    suggest_ampmut_self(self.infcx.tcx, local_decl);\n+                                Some((true, span, suggestion))\n+                            }\n \n                             LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n                                 mir::VarBindingForm {\n                                     binding_mode: ty::BindingMode::BindByValue(_),\n                                     opt_ty_info,\n                                     ..\n                                 },\n-                            ))) => Some(suggest_ampmut(\n-                                self.infcx.tcx,\n-                                self.body,\n-                                local,\n-                                local_decl,\n-                                opt_ty_info,\n-                            )),\n+                            ))) => {\n+                                // check if the RHS is from desugaring\n+                                let locations = self.body.find_assignments(local);\n+                                let opt_assignment_rhs_span = locations\n+                                    .first()\n+                                    .map(|&location| self.body.source_info(location).span);\n+                                let opt_desugaring_kind =\n+                                    opt_assignment_rhs_span.and_then(|span| span.desugaring_kind());\n+                                match opt_desugaring_kind {\n+                                    // on for loops, RHS points to the iterator part\n+                                    Some(DesugaringKind::ForLoop) => Some((\n+                                        false,\n+                                        opt_assignment_rhs_span.unwrap(),\n+                                        format!(\n+                                            \"this iterator yields `{SIGIL}` {DESC}s\",\n+                                            SIGIL = pointer_sigil,\n+                                            DESC = pointer_desc\n+                                        ),\n+                                    )),\n+                                    // don't create labels for compiler-generated spans\n+                                    Some(_) => None,\n+                                    None => {\n+                                        let (span, suggestion) = suggest_ampmut(\n+                                            self.infcx.tcx,\n+                                            local_decl,\n+                                            opt_assignment_rhs_span,\n+                                            opt_ty_info,\n+                                        );\n+                                        Some((true, span, suggestion))\n+                                    }\n+                                }\n+                            }\n \n                             LocalInfo::User(ClearCrossCrate::Set(mir::BindingForm::Var(\n                                 mir::VarBindingForm {\n@@ -365,7 +395,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             ))) => {\n                                 let pattern_span = local_decl.source_info.span;\n                                 suggest_ref_mut(self.infcx.tcx, pattern_span)\n-                                    .map(|replacement| (pattern_span, replacement))\n+                                    .map(|replacement| (true, pattern_span, replacement))\n                             }\n \n                             LocalInfo::User(ClearCrossCrate::Clear) => {\n@@ -375,13 +405,22 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             _ => unreachable!(),\n                         };\n \n-                        if let Some((err_help_span, suggested_code)) = suggestion {\n-                            err.span_suggestion(\n-                                err_help_span,\n-                                &format!(\"consider changing this to be a mutable {}\", pointer_desc),\n-                                suggested_code,\n-                                Applicability::MachineApplicable,\n-                            );\n+                        match label {\n+                            Some((true, err_help_span, suggested_code)) => {\n+                                err.span_suggestion(\n+                                    err_help_span,\n+                                    &format!(\n+                                        \"consider changing this to be a mutable {}\",\n+                                        pointer_desc\n+                                    ),\n+                                    suggested_code,\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                            Some((false, err_label_span, message)) => {\n+                                err.span_label(err_label_span, &message);\n+                            }\n+                            None => {}\n                         }\n                         err.span_label(\n                             span,\n@@ -581,14 +620,11 @@ fn suggest_ampmut_self<'tcx>(\n // by trying (3.), then (2.) and finally falling back on (1.).\n fn suggest_ampmut<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    body: ReadOnlyBodyAndCache<'_, 'tcx>,\n-    local: Local,\n     local_decl: &mir::LocalDecl<'tcx>,\n+    opt_assignment_rhs_span: Option<Span>,\n     opt_ty_info: Option<Span>,\n ) -> (Span, String) {\n-    let locations = body.find_assignments(local);\n-    if !locations.is_empty() {\n-        let assignment_rhs_span = body.source_info(locations[0]).span;\n+    if let Some(assignment_rhs_span) = opt_assignment_rhs_span {\n         if let Ok(src) = tcx.sess.source_map().span_to_snippet(assignment_rhs_span) {\n             if let (true, Some(ws_pos)) =\n                 (src.starts_with(\"&'\"), src.find(|c: char| -> bool { c.is_whitespace() }))"}, {"sha": "6756f476f6155733506acd2d051f6b5e32adfef0", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -292,8 +292,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)\n-            | ty::ReErased\n-            | ty::ReClosureBound(..) => None,\n+            | ty::ReErased => None,\n         }\n     }\n "}, {"sha": "c8b0e59ebb11700ff3f69d2ac8fff5e87fcc9361", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 7, "deletions": 34, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -940,8 +940,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// inference variables with some region from the closure\n     /// signature -- this is not always possible, so this is a\n     /// fallible process. Presuming we do find a suitable region, we\n-    /// will represent it with a `ReClosureBound`, which is a\n-    /// `RegionKind` variant that can be allocated in the gcx.\n+    /// will use it's *external name*, which will be a `RegionKind`\n+    /// variant that can be used in query responses such as\n+    /// `ReEarlyBound`.\n     fn try_promote_type_test_subject(\n         &self,\n         infcx: &InferCtxt<'_, 'tcx>,\n@@ -991,14 +992,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // find an equivalent.\n             let upper_bound = self.non_local_universal_upper_bound(region_vid);\n             if self.region_contains(region_vid, upper_bound) {\n-                tcx.mk_region(ty::ReClosureBound(upper_bound))\n+                self.definitions[upper_bound].external_name.unwrap_or(r)\n             } else {\n-                // In the case of a failure, use a `ReVar`\n-                // result. This will cause the `lift` later on to\n-                // fail.\n+                // In the case of a failure, use a `ReVar` result. This will\n+                // cause the `has_local_value` later on to return `None`.\n                 r\n             }\n         });\n+\n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n \n         // `has_local_value` will only be true if we failed to promote some region.\n@@ -2029,15 +2030,6 @@ pub trait ClosureRegionRequirementsExt<'tcx> {\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n     ) -> Vec<QueryOutlivesConstraint<'tcx>>;\n-\n-    fn subst_closure_mapping<T>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n-        value: &T,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>;\n }\n \n impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx> {\n@@ -2094,7 +2086,6 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n                     }\n \n                     ClosureOutlivesSubject::Ty(ty) => {\n-                        let ty = self.subst_closure_mapping(tcx, closure_mapping, &ty);\n                         debug!(\n                             \"apply_requirements: ty={:?} \\\n                              outlived_region={:?} \\\n@@ -2107,22 +2098,4 @@ impl<'tcx> ClosureRegionRequirementsExt<'tcx> for ClosureRegionRequirements<'tcx\n             })\n             .collect()\n     }\n-\n-    fn subst_closure_mapping<T>(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        closure_mapping: &IndexVec<RegionVid, ty::Region<'tcx>>,\n-        value: &T,\n-    ) -> T\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        tcx.fold_regions(value, &mut false, |r, _depth| {\n-            if let ty::ReClosureBound(vid) = r {\n-                closure_mapping[*vid]\n-            } else {\n-                bug!(\"subst_closure_mapping: encountered non-closure bound free region {:?}\", r)\n-            }\n-        })\n-    }\n }"}, {"sha": "f94160cc08a19ee4027a020cedb87e632952184a", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1986,7 +1986,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             }\n \n             Rvalue::Repeat(operand, len) => {\n-                if *len > 1 {\n+                // If the length cannot be evaluated we must assume that the length can be larger\n+                // than 1.\n+                // If the length is larger than 1, the repeat expression will need to copy the\n+                // element, so we require the `Copy` trait.\n+                if len.try_eval_usize(tcx, self.param_env).map_or(true, |len| len > 1) {\n                     if let Operand::Move(_) = operand {\n                         // While this is located in `nll::typeck` this error is not an NLL error, it's\n                         // a required check to make sure that repeated elements implement `Copy`."}, {"sha": "ab88a92ea7bc210bae9d1cd76f9bd61d7a4a9e8a", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 20, "deletions": 47, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -3,7 +3,6 @@ use rustc::ty::layout::HasTyCtxt;\n use rustc::ty::{self, Ty};\n use std::borrow::{Borrow, Cow};\n use std::collections::hash_map::Entry;\n-use std::convert::TryFrom;\n use std::hash::Hash;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -13,13 +12,13 @@ use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n \n use crate::interpret::{\n-    self, snapshot, AllocId, Allocation, GlobalId, ImmTy, InterpCx, InterpResult, Memory,\n-    MemoryKind, OpTy, PlaceTy, Pointer, Scalar,\n+    self, AllocId, Allocation, GlobalId, ImmTy, InterpCx, InterpResult, Memory, MemoryKind, OpTy,\n+    PlaceTy, Pointer, Scalar,\n };\n \n use super::error::*;\n \n-impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n+impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter> {\n     /// Evaluate a const function where all arguments (if any) are zero-sized types.\n     /// The evaluation is memoized thanks to the query system.\n     ///\n@@ -86,22 +85,13 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n     }\n }\n \n-/// The number of steps between loop detector snapshots.\n-/// Should be a power of two for performance reasons.\n-const DETECTOR_SNAPSHOT_PERIOD: isize = 256;\n-\n-// Extra machine state for CTFE, and the Machine instance\n-pub struct CompileTimeInterpreter<'mir, 'tcx> {\n-    /// When this value is negative, it indicates the number of interpreter\n-    /// steps *until* the loop detector is enabled. When it is positive, it is\n-    /// the number of steps after the detector has been enabled modulo the loop\n-    /// detector period.\n-    pub(super) steps_since_detector_enabled: isize,\n-\n-    pub(super) is_detector_enabled: bool,\n-\n-    /// Extra state to detect loops.\n-    pub(super) loop_detector: snapshot::InfiniteLoopDetector<'mir, 'tcx>,\n+/// Extra machine state for CTFE, and the Machine instance\n+pub struct CompileTimeInterpreter {\n+    /// For now, the number of terminators that can be evaluated before we throw a resource\n+    /// exhuastion error.\n+    ///\n+    /// Setting this to `0` disables the limit and allows the interpreter to run forever.\n+    pub steps_remaining: usize,\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -110,16 +100,9 @@ pub struct MemoryExtra {\n     pub(super) can_access_statics: bool,\n }\n \n-impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n+impl CompileTimeInterpreter {\n     pub(super) fn new(const_eval_limit: usize) -> Self {\n-        let steps_until_detector_enabled =\n-            isize::try_from(const_eval_limit).unwrap_or(std::isize::MAX);\n-\n-        CompileTimeInterpreter {\n-            loop_detector: Default::default(),\n-            steps_since_detector_enabled: -steps_until_detector_enabled,\n-            is_detector_enabled: const_eval_limit != 0,\n-        }\n+        CompileTimeInterpreter { steps_remaining: const_eval_limit }\n     }\n }\n \n@@ -173,8 +156,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n     }\n }\n \n-crate type CompileTimeEvalContext<'mir, 'tcx> =\n-    InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>;\n+crate type CompileTimeEvalContext<'mir, 'tcx> = InterpCx<'mir, 'tcx, CompileTimeInterpreter>;\n \n impl interpret::MayLeak for ! {\n     #[inline(always)]\n@@ -184,7 +166,7 @@ impl interpret::MayLeak for ! {\n     }\n }\n \n-impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n+impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n     type MemoryKinds = !;\n     type PointerTag = ();\n     type ExtraFnVal = !;\n@@ -345,26 +327,17 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        if !ecx.machine.is_detector_enabled {\n+        // The step limit has already been hit in a previous call to `before_terminator`.\n+        if ecx.machine.steps_remaining == 0 {\n             return Ok(());\n         }\n \n-        {\n-            let steps = &mut ecx.machine.steps_since_detector_enabled;\n-\n-            *steps += 1;\n-            if *steps < 0 {\n-                return Ok(());\n-            }\n-\n-            *steps %= DETECTOR_SNAPSHOT_PERIOD;\n-            if *steps != 0 {\n-                return Ok(());\n-            }\n+        ecx.machine.steps_remaining -= 1;\n+        if ecx.machine.steps_remaining == 0 {\n+            throw_exhaust!(StepLimitReached)\n         }\n \n-        let span = ecx.frame().span;\n-        ecx.machine.loop_detector.observe_and_analyze(*ecx.tcx, span, &ecx.memory, &ecx.stack[..])\n+        Ok(())\n     }\n \n     #[inline(always)]"}, {"sha": "277a77af3fd56efc5d448ef179bda2c2ef173cc2", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -112,25 +112,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M>\n     }\n }\n \n-// FIXME: Really we shouldn't clone memory, ever. Snapshot machinery should instead\n-// carefully copy only the reachable parts.\n-impl<'mir, 'tcx, M> Clone for Memory<'mir, 'tcx, M>\n-where\n-    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = ()>,\n-    M::MemoryExtra: Copy,\n-    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n-{\n-    fn clone(&self) -> Self {\n-        Memory {\n-            alloc_map: self.alloc_map.clone(),\n-            extra_fn_ptr_map: self.extra_fn_ptr_map.clone(),\n-            dead_alloc_map: self.dead_alloc_map.clone(),\n-            extra: self.extra,\n-            tcx: self.tcx,\n-        }\n-    }\n-}\n-\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'tcx>, extra: M::MemoryExtra) -> Self {\n         Memory {"}, {"sha": "3063a99886b7bdb76a917614b5d339ac6b4bc472", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -9,7 +9,6 @@ mod memory;\n mod operand;\n mod operator;\n mod place;\n-pub(crate) mod snapshot; // for const_eval\n mod step;\n mod terminator;\n mod traits;"}, {"sha": "ee45179fd8b316bd53ad98280f33079d2ed3d063", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "removed", "additions": 0, "deletions": 420, "changes": 420, "blob_url": "https://github.com/rust-lang/rust/blob/c55c682e9ba2be16d5de4264d1b626e70f00de9d/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c55c682e9ba2be16d5de4264d1b626e70f00de9d/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=c55c682e9ba2be16d5de4264d1b626e70f00de9d", "patch": "@@ -1,420 +0,0 @@\n-//! This module contains the machinery necessary to detect infinite loops\n-//! during const-evaluation by taking snapshots of the state of the interpreter\n-//! at regular intervals.\n-\n-// This lives in `interpret` because it needs access to all sots of private state.  However,\n-// it is not used by the general miri engine, just by CTFE.\n-\n-use std::hash::{Hash, Hasher};\n-\n-use rustc::ich::StableHashingContextProvider;\n-use rustc::mir;\n-use rustc::mir::interpret::{\n-    AllocId, Allocation, InterpResult, Pointer, Relocations, Scalar, UndefMask,\n-};\n-\n-use rustc::ty::layout::{Align, Size};\n-use rustc::ty::{self, TyCtxt};\n-use rustc_ast::ast::Mutability;\n-use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_index::vec::IndexVec;\n-use rustc_macros::HashStable;\n-use rustc_span::source_map::Span;\n-\n-use super::eval_context::{LocalState, StackPopCleanup};\n-use super::{\n-    Frame, Immediate, LocalValue, MemPlace, MemPlaceMeta, Memory, Operand, Place, ScalarMaybeUndef,\n-};\n-use crate::const_eval::CompileTimeInterpreter;\n-\n-#[derive(Default)]\n-pub(crate) struct InfiniteLoopDetector<'mir, 'tcx> {\n-    /// The set of all `InterpSnapshot` *hashes* observed by this detector.\n-    ///\n-    /// When a collision occurs in this table, we store the full snapshot in\n-    /// `snapshots`.\n-    hashes: FxHashSet<u64>,\n-\n-    /// The set of all `InterpSnapshot`s observed by this detector.\n-    ///\n-    /// An `InterpSnapshot` will only be fully cloned once it has caused a\n-    /// collision in `hashes`. As a result, the detector must observe at least\n-    /// *two* full cycles of an infinite loop before it triggers.\n-    snapshots: FxHashSet<InterpSnapshot<'mir, 'tcx>>,\n-}\n-\n-impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n-    pub fn observe_and_analyze(\n-        &mut self,\n-        tcx: TyCtxt<'tcx>,\n-        span: Span,\n-        memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-        stack: &[Frame<'mir, 'tcx>],\n-    ) -> InterpResult<'tcx, ()> {\n-        // Compute stack's hash before copying anything\n-        let mut hcx = tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-        stack.hash_stable(&mut hcx, &mut hasher);\n-        let hash = hasher.finish::<u64>();\n-\n-        // Check if we know that hash already\n-        if self.hashes.is_empty() {\n-            // FIXME(#49980): make this warning a lint\n-            tcx.sess.span_warn(\n-                span,\n-                \"Constant evaluating a complex constant, this might take some time\",\n-            );\n-        }\n-        if self.hashes.insert(hash) {\n-            // No collision\n-            return Ok(());\n-        }\n-\n-        // We need to make a full copy. NOW things that to get really expensive.\n-        info!(\"snapshotting the state of the interpreter\");\n-\n-        if self.snapshots.insert(InterpSnapshot::new(memory, stack)) {\n-            // Spurious collision or first cycle\n-            return Ok(());\n-        }\n-\n-        // Second cycle\n-        throw_exhaust!(InfiniteLoop)\n-    }\n-}\n-\n-trait SnapshotContext<'a> {\n-    fn resolve(&'a self, id: &AllocId) -> Option<&'a Allocation>;\n-}\n-\n-/// Taking a snapshot of the evaluation context produces a view of\n-/// the state of the interpreter that is invariant to `AllocId`s.\n-trait Snapshot<'a, Ctx: SnapshotContext<'a>> {\n-    type Item;\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item;\n-}\n-\n-macro_rules! __impl_snapshot_field {\n-    ($field:ident, $ctx:expr) => {\n-        $field.snapshot($ctx)\n-    };\n-    ($field:ident, $ctx:expr, $delegate:expr) => {\n-        $delegate\n-    };\n-}\n-\n-// This assumes the type has two type parameters, first for the tag (set to `()`),\n-// then for the id\n-macro_rules! impl_snapshot_for {\n-    (enum $enum_name:ident {\n-        $( $variant:ident $( ( $($field:ident $(-> $delegate:expr)?),* ) )? ),* $(,)?\n-    }) => {\n-\n-        impl<'a, Ctx> self::Snapshot<'a, Ctx> for $enum_name\n-            where Ctx: self::SnapshotContext<'a>,\n-        {\n-            type Item = $enum_name<(), AllocIdSnapshot<'a>>;\n-\n-            #[inline]\n-            fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n-                match *self {\n-                    $(\n-                        $enum_name::$variant $( ( $(ref $field),* ) )? => {\n-                            $enum_name::$variant $(\n-                                ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),* )\n-                            )?\n-                        }\n-                    )*\n-                }\n-            }\n-        }\n-    };\n-\n-    (struct $struct_name:ident { $($field:ident $(-> $delegate:expr)?),*  $(,)? }) => {\n-        impl<'a, Ctx> self::Snapshot<'a, Ctx> for $struct_name\n-            where Ctx: self::SnapshotContext<'a>,\n-        {\n-            type Item = $struct_name<(), AllocIdSnapshot<'a>>;\n-\n-            #[inline]\n-            fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n-                let $struct_name {\n-                    $(ref $field),*\n-                } = *self;\n-\n-                $struct_name {\n-                    $( $field: __impl_snapshot_field!($field, __ctx $(, $delegate)?) ),*\n-                }\n-            }\n-        }\n-    };\n-}\n-\n-impl<'a, Ctx, T> Snapshot<'a, Ctx> for Option<T>\n-where\n-    Ctx: SnapshotContext<'a>,\n-    T: Snapshot<'a, Ctx>,\n-{\n-    type Item = Option<<T as Snapshot<'a, Ctx>>::Item>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Some(x) => Some(x.snapshot(ctx)),\n-            None => None,\n-        }\n-    }\n-}\n-\n-#[derive(Eq, PartialEq)]\n-struct AllocIdSnapshot<'a>(Option<AllocationSnapshot<'a>>);\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for AllocId\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = AllocIdSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        AllocIdSnapshot(ctx.resolve(self).map(|alloc| alloc.snapshot(ctx)))\n-    }\n-}\n-\n-impl_snapshot_for!(struct Pointer {\n-    alloc_id,\n-    offset -> *offset, // just copy offset verbatim\n-    tag -> *tag, // just copy tag\n-});\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = Scalar<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Scalar::Ptr(p) => Scalar::Ptr(p.snapshot(ctx)),\n-            Scalar::Raw { size, data } => Scalar::Raw { data: *data, size: *size },\n-        }\n-    }\n-}\n-\n-impl_snapshot_for!(\n-    enum ScalarMaybeUndef {\n-        Scalar(s),\n-        Undef,\n-    }\n-);\n-\n-impl_snapshot_for!(\n-    enum MemPlaceMeta {\n-        Meta(s),\n-        None,\n-        Poison,\n-    }\n-);\n-\n-impl_snapshot_for!(struct MemPlace {\n-    ptr,\n-    meta,\n-    align -> *align, // just copy alignment verbatim\n-});\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = Place<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Place::Ptr(p) => Place::Ptr(p.snapshot(ctx)),\n-\n-            Place::Local { frame, local } => Place::Local { frame: *frame, local: *local },\n-        }\n-    }\n-}\n-\n-impl_snapshot_for!(\n-    enum Immediate {\n-        Scalar(s),\n-        ScalarPair(s, t),\n-    }\n-);\n-\n-impl_snapshot_for!(\n-    enum Operand {\n-        Immediate(v),\n-        Indirect(m),\n-    }\n-);\n-\n-impl_snapshot_for!(\n-    enum LocalValue {\n-        Dead,\n-        Uninitialized,\n-        Live(v),\n-    }\n-);\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Relocations\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = Relocations<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        Relocations::from_presorted(\n-            self.iter().map(|(size, ((), id))| (*size, ((), id.snapshot(ctx)))).collect(),\n-        )\n-    }\n-}\n-\n-#[derive(Eq, PartialEq)]\n-struct AllocationSnapshot<'a> {\n-    bytes: &'a [u8],\n-    relocations: Relocations<(), AllocIdSnapshot<'a>>,\n-    undef_mask: &'a UndefMask,\n-    align: &'a Align,\n-    size: &'a Size,\n-    mutability: &'a Mutability,\n-}\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = AllocationSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Allocation { size, align, mutability, extra: (), .. } = self;\n-\n-        let all_bytes = 0..self.len();\n-        // This 'inspect' is okay since following access respects undef and relocations. This does\n-        // influence interpreter exeuction, but only to detect the error of cycles in evaluation\n-        // dependencies.\n-        let bytes = self.inspect_with_undef_and_ptr_outside_interpreter(all_bytes);\n-\n-        let undef_mask = self.undef_mask();\n-        let relocations = self.relocations();\n-\n-        AllocationSnapshot {\n-            bytes,\n-            undef_mask,\n-            align,\n-            size,\n-            mutability,\n-            relocations: relocations.snapshot(ctx),\n-        }\n-    }\n-}\n-\n-#[derive(Eq, PartialEq)]\n-struct FrameSnapshot<'a, 'tcx> {\n-    instance: ty::Instance<'tcx>,\n-    span: Span,\n-    return_to_block: &'a StackPopCleanup,\n-    return_place: Option<Place<(), AllocIdSnapshot<'a>>>,\n-    locals: IndexVec<mir::Local, LocalValue<(), AllocIdSnapshot<'a>>>,\n-    block: Option<mir::BasicBlock>,\n-    stmt: usize,\n-}\n-\n-impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = FrameSnapshot<'a, 'tcx>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Frame {\n-            body: _,\n-            instance,\n-            span,\n-            return_to_block,\n-            return_place,\n-            locals,\n-            block,\n-            stmt,\n-            extra: _,\n-        } = self;\n-\n-        FrameSnapshot {\n-            instance: *instance,\n-            span: *span,\n-            return_to_block,\n-            block: *block,\n-            stmt: *stmt,\n-            return_place: return_place.map(|r| r.snapshot(ctx)),\n-            locals: locals.iter().map(|local| local.snapshot(ctx)).collect(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalState<'tcx>\n-where\n-    Ctx: SnapshotContext<'a>,\n-{\n-    type Item = LocalValue<(), AllocIdSnapshot<'a>>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let LocalState { value, layout: _ } = self;\n-        value.snapshot(ctx)\n-    }\n-}\n-\n-impl<'b, 'mir, 'tcx> SnapshotContext<'b>\n-    for Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>\n-{\n-    fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n-        self.get_raw(*id).ok()\n-    }\n-}\n-\n-/// The virtual machine state during const-evaluation at a given point in time.\n-/// We assume the `CompileTimeInterpreter` has no interesting extra state that\n-/// is worth considering here.\n-#[derive(HashStable)]\n-struct InterpSnapshot<'mir, 'tcx> {\n-    // Not hashing memory: Avoid hashing memory all the time during execution\n-    #[stable_hasher(ignore)]\n-    memory: Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-    stack: Vec<Frame<'mir, 'tcx>>,\n-}\n-\n-impl InterpSnapshot<'mir, 'tcx> {\n-    fn new(\n-        memory: &Memory<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>>,\n-        stack: &[Frame<'mir, 'tcx>],\n-    ) -> Self {\n-        InterpSnapshot { memory: memory.clone(), stack: stack.into() }\n-    }\n-\n-    // Used to compare two snapshots\n-    fn snapshot(&'b self) -> Vec<FrameSnapshot<'b, 'tcx>> {\n-        // Start with the stack, iterate and recursively snapshot\n-        self.stack.iter().map(|frame| frame.snapshot(&self.memory)).collect()\n-    }\n-}\n-\n-impl<'mir, 'tcx> Hash for InterpSnapshot<'mir, 'tcx> {\n-    fn hash<H: Hasher>(&self, state: &mut H) {\n-        // Implement in terms of hash stable, so that k1 == k2 -> hash(k1) == hash(k2)\n-        let mut hcx = self.memory.tcx.get_stable_hashing_context();\n-        let mut hasher = StableHasher::new();\n-        self.hash_stable(&mut hcx, &mut hasher);\n-        hasher.finish::<u64>().hash(state)\n-    }\n-}\n-\n-impl<'mir, 'tcx> Eq for InterpSnapshot<'mir, 'tcx> {}\n-\n-impl<'mir, 'tcx> PartialEq for InterpSnapshot<'mir, 'tcx> {\n-    fn eq(&self, other: &Self) -> bool {\n-        // FIXME: This looks to be a *ridiculously expensive* comparison operation.\n-        // Doesn't this make tons of copies?  Either `snapshot` is very badly named,\n-        // or it does!\n-        self.snapshot() == other.snapshot()\n-    }\n-}"}, {"sha": "8899f12b15361fc5aad9ed59098661e3db0df16d", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -39,6 +39,24 @@ use crate::transform::{MirPass, MirSource};\n /// The maximum number of bytes that we'll allocate space for a return value.\n const MAX_ALLOC_LIMIT: u64 = 1024;\n \n+/// Macro for machine-specific `InterpError` without allocation.\n+/// (These will never be shown to the user, but they help diagnose ICEs.)\n+macro_rules! throw_machine_stop_str {\n+    ($($tt:tt)*) => {{\n+        // We make a new local type for it. The type itself does not carry any information,\n+        // but its vtable (for the `MachineStopType` trait) does.\n+        struct Zst;\n+        // Debug-printing this type shows the desired string.\n+        impl std::fmt::Debug for Zst {\n+            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+                write!(f, $($tt)*)\n+            }\n+        }\n+        impl rustc::mir::interpret::MachineStopType for Zst {}\n+        throw_machine_stop!(Zst)\n+    }};\n+}\n+\n pub struct ConstProp;\n \n impl<'tcx> MirPass<'tcx> for ConstProp {\n@@ -192,7 +210,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ret: Option<(PlaceTy<'tcx>, BasicBlock)>,\n         _unwind: Option<BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        throw_unsup!(ConstPropUnsupported(\"calling intrinsics isn't supported in ConstProp\"))\n+        throw_machine_stop_str!(\"calling intrinsics isn't supported in ConstProp\")\n     }\n \n     fn assert_panic(\n@@ -204,7 +222,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     }\n \n     fn ptr_to_int(_mem: &Memory<'mir, 'tcx, Self>, _ptr: Pointer) -> InterpResult<'tcx, u64> {\n-        throw_unsup!(ConstPropUnsupported(\"ptr-to-int casts aren't supported in ConstProp\"))\n+        throw_unsup!(ReadPointerAsBytes)\n     }\n \n     fn binary_ptr_op(\n@@ -214,10 +232,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _right: ImmTy<'tcx>,\n     ) -> InterpResult<'tcx, (Scalar, bool, Ty<'tcx>)> {\n         // We can't do this because aliasing of memory can differ between const eval and llvm\n-        throw_unsup!(ConstPropUnsupported(\n-            \"pointer arithmetic or comparisons aren't supported \\\n-            in ConstProp\"\n-        ))\n+        throw_machine_stop_str!(\"pointer arithmetic or comparisons aren't supported in ConstProp\")\n     }\n \n     #[inline(always)]\n@@ -238,7 +253,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> InterpResult<'tcx> {\n-        throw_unsup!(ConstPropUnsupported(\"can't const prop `box` keyword\"))\n+        throw_machine_stop_str!(\"can't const prop heap allocations\")\n     }\n \n     fn access_local(\n@@ -249,7 +264,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         let l = &frame.locals[local];\n \n         if l.value == LocalValue::Uninitialized {\n-            throw_unsup!(ConstPropUnsupported(\"tried to access an uninitialized local\"));\n+            throw_machine_stop_str!(\"tried to access an uninitialized local\")\n         }\n \n         l.access()\n@@ -262,7 +277,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         // if the static allocation is mutable or if it has relocations (it may be legal to mutate\n         // the memory behind that in the future), then we can't const prop it\n         if allocation.mutability == Mutability::Mut || allocation.relocations().len() > 0 {\n-            throw_unsup!(ConstPropUnsupported(\"can't eval mutable statics in ConstProp\"));\n+            throw_machine_stop_str!(\"can't eval mutable statics in ConstProp\")\n         }\n \n         Ok(())"}, {"sha": "9f93b817e38d8a555d69b6cb07ed08c62c421abc", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 29, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -3,7 +3,7 @@ use crate::hair::cx::to_ref::ToRef;\n use crate::hair::cx::Cx;\n use crate::hair::util::UserAnnotatedTyHelpers;\n use crate::hair::*;\n-use rustc::mir::interpret::{ErrorHandled, Scalar};\n+use rustc::mir::interpret::Scalar;\n use rustc::mir::BorrowKind;\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow, AutoBorrowMutability, PointerCast};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n@@ -406,34 +406,8 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n \n         // Now comes the rote stuff:\n         hir::ExprKind::Repeat(ref v, ref count) => {\n-            let def_id = cx.tcx.hir().local_def_id(count.hir_id);\n-            let substs = InternalSubsts::identity_for_item(cx.tcx, def_id);\n-            let span = cx.tcx.def_span(def_id);\n-            let count = match cx.tcx.const_eval_resolve(\n-                ty::ParamEnv::reveal_all(),\n-                def_id,\n-                substs,\n-                None,\n-                Some(span),\n-            ) {\n-                Ok(cv) => {\n-                    if let Some(count) = cv.try_to_bits_for_ty(\n-                        cx.tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        cx.tcx.types.usize,\n-                    ) {\n-                        count as u64\n-                    } else {\n-                        bug!(\"repeat count constant value can't be converted to usize\");\n-                    }\n-                }\n-                Err(ErrorHandled::Reported) => 0,\n-                Err(ErrorHandled::TooGeneric) => {\n-                    let span = cx.tcx.def_span(def_id);\n-                    cx.tcx.sess.span_err(span, \"array lengths can't depend on generic parameters\");\n-                    0\n-                }\n-            };\n+            let count_def_id = cx.tcx.hir().local_def_id(count.hir_id).expect_local();\n+            let count = ty::Const::from_anon_const(cx.tcx, count_def_id);\n \n             ExprKind::Repeat { value: v.to_ref(), count }\n         }"}, {"sha": "77042240acf32fde0a82136cdf6c2a2f1c937abb", "filename": "src/librustc_mir_build/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -229,7 +229,7 @@ crate enum ExprKind<'tcx> {\n     },\n     Repeat {\n         value: ExprRef<'tcx>,\n-        count: u64,\n+        count: &'tcx Const<'tcx>,\n     },\n     Array {\n         fields: Vec<ExprRef<'tcx>>,"}, {"sha": "a01bb5e5ea30dbc2a341b5120a26de8bc3326a49", "filename": "src/librustc_query_system/Cargo.toml", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2FCargo.toml?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -0,0 +1,22 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_query_system\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_query_system\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n+rustc_ast = { path = \"../librustc_ast\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n+rustc_hir = { path = \"../librustc_hir\" }\n+rustc_index = { path = \"../librustc_index\" }\n+rustc_macros = { path = \"../librustc_macros\" }\n+rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n+parking_lot = \"0.9\"\n+smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "b9d91cd35a8ddf6ce799b94d488bffc955b2efde", "filename": "src/librustc_query_system/dep_graph/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2FREADME.md?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "previous_filename": "src/librustc/dep_graph/README.md"}, {"sha": "718a2f1039a4df8576fb3ac2cc842c322fbd573f", "filename": "src/librustc_query_system/dep_graph/debug.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,6 +1,6 @@\n //! Code for debugging the dep-graph.\n \n-use super::dep_node::DepNode;\n+use super::{DepKind, DepNode};\n use std::error::Error;\n \n /// A dep-node filter goes from a user-defined string to a query over\n@@ -26,7 +26,7 @@ impl DepNodeFilter {\n     }\n \n     /// Tests whether `node` meets the filter, returning true if so.\n-    pub fn test(&self, node: &DepNode) -> bool {\n+    pub fn test<K: DepKind>(&self, node: &DepNode<K>) -> bool {\n         let debug_str = format!(\"{:?}\", node);\n         self.text.split('&').map(|s| s.trim()).all(|f| debug_str.contains(f))\n     }\n@@ -52,7 +52,7 @@ impl EdgeFilter {\n         }\n     }\n \n-    pub fn test(&self, source: &DepNode, target: &DepNode) -> bool {\n+    pub fn test<K: DepKind>(&self, source: &DepNode<K>, target: &DepNode<K>) -> bool {\n         self.source.test(source) && self.target.test(target)\n     }\n }", "previous_filename": "src/librustc/dep_graph/debug.rs"}, {"sha": "c6fff2f01643addd479c5d3f1d00b1c1d508b58d", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -0,0 +1,146 @@\n+//! This module defines the `DepNode` type which the compiler uses to represent\n+//! nodes in the dependency graph. A `DepNode` consists of a `DepKind` (which\n+//! specifies the kind of thing it represents, like a piece of HIR, MIR, etc)\n+//! and a `Fingerprint`, a 128 bit hash value the exact meaning of which\n+//! depends on the node's `DepKind`. Together, the kind and the fingerprint\n+//! fully identify a dependency node, even across multiple compilation sessions.\n+//! In other words, the value of the fingerprint does not depend on anything\n+//! that is specific to a given compilation session, like an unpredictable\n+//! interning key (e.g., NodeId, DefId, Symbol) or the numeric value of a\n+//! pointer. The concept behind this could be compared to how git commit hashes\n+//! uniquely identify a given commit and has a few advantages:\n+//!\n+//! * A `DepNode` can simply be serialized to disk and loaded in another session\n+//!   without the need to do any \"rebasing (like we have to do for Spans and\n+//!   NodeIds) or \"retracing\" like we had to do for `DefId` in earlier\n+//!   implementations of the dependency graph.\n+//! * A `Fingerprint` is just a bunch of bits, which allows `DepNode` to\n+//!   implement `Copy`, `Sync`, `Send`, `Freeze`, etc.\n+//! * Since we just have a bit pattern, `DepNode` can be mapped from disk into\n+//!   memory without any post-processing (e.g., \"abomination-style\" pointer\n+//!   reconstruction).\n+//! * Because a `DepNode` is self-contained, we can instantiate `DepNodes` that\n+//!   refer to things that do not exist anymore. In previous implementations\n+//!   `DepNode` contained a `DefId`. A `DepNode` referring to something that\n+//!   had been removed between the previous and the current compilation session\n+//!   could not be instantiated because the current compilation session\n+//!   contained no `DefId` for thing that had been removed.\n+//!\n+//! `DepNode` definition happens in `librustc` with the `define_dep_nodes!()` macro.\n+//! This macro defines the `DepKind` enum and a corresponding `DepConstructor` enum. The\n+//! `DepConstructor` enum links a `DepKind` to the parameters that are needed at runtime in order\n+//! to construct a valid `DepNode` fingerprint.\n+//!\n+//! Because the macro sees what parameters a given `DepKind` requires, it can\n+//! \"infer\" some properties for each kind of `DepNode`:\n+//!\n+//! * Whether a `DepNode` of a given kind has any parameters at all. Some\n+//!   `DepNode`s could represent global concepts with only one value.\n+//! * Whether it is possible, in principle, to reconstruct a query key from a\n+//!   given `DepNode`. Many `DepKind`s only require a single `DefId` parameter,\n+//!   in which case it is possible to map the node's fingerprint back to the\n+//!   `DefId` it was computed from. In other cases, too much information gets\n+//!   lost during fingerprint computation.\n+\n+use super::{DepContext, DepKind};\n+\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_macros::HashStable_Generic;\n+\n+use std::fmt;\n+use std::hash::Hash;\n+\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub struct DepNode<K> {\n+    pub kind: K,\n+    pub hash: Fingerprint,\n+}\n+\n+impl<K: DepKind> DepNode<K> {\n+    /// Creates a new, parameterless DepNode. This method will assert\n+    /// that the DepNode corresponding to the given DepKind actually\n+    /// does not require any parameters.\n+    pub fn new_no_params(kind: K) -> DepNode<K> {\n+        debug_assert!(!kind.has_params());\n+        DepNode { kind, hash: Fingerprint::ZERO }\n+    }\n+}\n+\n+impl<K: DepKind> fmt::Debug for DepNode<K> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        K::debug_node(self, f)\n+    }\n+}\n+\n+pub trait DepNodeParams<Ctxt: DepContext>: fmt::Debug + Sized {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool;\n+\n+    /// This method turns the parameters of a DepNodeConstructor into an opaque\n+    /// Fingerprint to be used in DepNode.\n+    /// Not all DepNodeParams support being turned into a Fingerprint (they\n+    /// don't need to if the corresponding DepNode is anonymous).\n+    fn to_fingerprint(&self, _: Ctxt) -> Fingerprint {\n+        panic!(\"Not implemented. Accidentally called on anonymous node?\")\n+    }\n+\n+    fn to_debug_str(&self, _: Ctxt) -> String {\n+        format!(\"{:?}\", self)\n+    }\n+\n+    /// This method tries to recover the query key from the given `DepNode`,\n+    /// something which is needed when forcing `DepNode`s during red-green\n+    /// evaluation. The query system will only call this method if\n+    /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n+    /// It is always valid to return `None` here, in which case incremental\n+    /// compilation will treat the query as having changed instead of forcing it.\n+    fn recover(tcx: Ctxt, dep_node: &DepNode<Ctxt::DepKind>) -> Option<Self>;\n+}\n+\n+impl<Ctxt: DepContext, T> DepNodeParams<Ctxt> for T\n+where\n+    T: HashStable<Ctxt::StableHashingContext> + fmt::Debug,\n+{\n+    default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+\n+    default fn to_fingerprint(&self, tcx: Ctxt) -> Fingerprint {\n+        let mut hcx = tcx.create_stable_hashing_context();\n+        let mut hasher = StableHasher::new();\n+\n+        self.hash_stable(&mut hcx, &mut hasher);\n+\n+        hasher.finish()\n+    }\n+\n+    default fn to_debug_str(&self, _: Ctxt) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+\n+    default fn recover(_: Ctxt, _: &DepNode<Ctxt::DepKind>) -> Option<Self> {\n+        None\n+    }\n+}\n+\n+/// A \"work product\" corresponds to a `.o` (or other) file that we\n+/// save in between runs. These IDs do not have a `DefId` but rather\n+/// some independent path or string that persists between runs without\n+/// the need to be mapped or unmapped. (This ensures we can serialize\n+/// them even in the absence of a tcx.)\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(HashStable_Generic)]\n+pub struct WorkProductId {\n+    hash: Fingerprint,\n+}\n+\n+impl WorkProductId {\n+    pub fn from_cgu_name(cgu_name: &str) -> WorkProductId {\n+        let mut hasher = StableHasher::new();\n+        cgu_name.len().hash(&mut hasher);\n+        cgu_name.hash(&mut hasher);\n+        WorkProductId { hash: hasher.finish() }\n+    }\n+\n+    pub fn from_fingerprint(fingerprint: Fingerprint) -> WorkProductId {\n+        WorkProductId { hash: fingerprint }\n+    }\n+}"}, {"sha": "7352551559cf4835c4eb32288b51d4e114ac5e8f", "filename": "src/librustc_query_system/dep_graph/graph.rs", "status": "renamed", "additions": 116, "deletions": 164, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,32 +1,33 @@\n-use crate::ty::{self, TyCtxt};\n-use parking_lot::{Condvar, Mutex};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::QueryInvocationId;\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n+use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n-use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n-use smallvec::SmallVec;\n+\n+use parking_lot::{Condvar, Mutex};\n+use smallvec::{smallvec, SmallVec};\n use std::collections::hash_map::Entry;\n use std::env;\n use std::hash::Hash;\n+use std::marker::PhantomData;\n use std::mem;\n use std::sync::atomic::Ordering::Relaxed;\n \n-use crate::ich::{Fingerprint, StableHashingContext, StableHashingContextProvider};\n-\n use super::debug::EdgeFilter;\n-use super::dep_node::{DepKind, DepNode, WorkProductId};\n use super::prev::PreviousDepGraph;\n use super::query::DepGraphQuery;\n use super::safe::DepGraphSafe;\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+use super::{DepContext, DepKind, DepNode, WorkProductId};\n+use crate::{HashStableContext, HashStableContextProvider};\n \n #[derive(Clone)]\n-pub struct DepGraph {\n-    data: Option<Lrc<DepGraphData>>,\n+pub struct DepGraph<K: DepKind> {\n+    data: Option<Lrc<DepGraphData<K>>>,\n \n     /// This field is used for assigning DepNodeIndices when running in\n     /// non-incremental mode. Even in non-incremental mode we make sure that\n@@ -65,16 +66,16 @@ impl DepNodeColor {\n     }\n }\n \n-struct DepGraphData {\n+struct DepGraphData<K: DepKind> {\n     /// The new encoding of the dependency graph, optimized for red/green\n     /// tracking. The `current` field is the dependency graph of only the\n     /// current compilation session: We don't merge the previous dep-graph into\n     /// current one anymore.\n-    current: CurrentDepGraph,\n+    current: CurrentDepGraph<K>,\n \n     /// The dep-graph from the previous compilation session. It contains all\n     /// nodes and edges as well as all fingerprints of nodes that have them.\n-    previous: PreviousDepGraph,\n+    previous: PreviousDepGraph<K>,\n \n     colors: DepNodeColorMap,\n \n@@ -90,24 +91,24 @@ struct DepGraphData {\n     /// this map. We can later look for and extract that data.\n     previous_work_products: FxHashMap<WorkProductId, WorkProduct>,\n \n-    dep_node_debug: Lock<FxHashMap<DepNode, String>>,\n+    dep_node_debug: Lock<FxHashMap<DepNode<K>, String>>,\n }\n \n-pub fn hash_result<R>(hcx: &mut StableHashingContext<'_>, result: &R) -> Option<Fingerprint>\n+pub fn hash_result<HashCtxt, R>(hcx: &mut HashCtxt, result: &R) -> Option<Fingerprint>\n where\n-    R: for<'a> HashStable<StableHashingContext<'a>>,\n+    R: HashStable<HashCtxt>,\n {\n     let mut stable_hasher = StableHasher::new();\n     result.hash_stable(hcx, &mut stable_hasher);\n \n     Some(stable_hasher.finish())\n }\n \n-impl DepGraph {\n+impl<K: DepKind> DepGraph<K> {\n     pub fn new(\n-        prev_graph: PreviousDepGraph,\n+        prev_graph: PreviousDepGraph<K>,\n         prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n-    ) -> DepGraph {\n+    ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n         DepGraph {\n@@ -124,7 +125,7 @@ impl DepGraph {\n         }\n     }\n \n-    pub fn new_disabled() -> DepGraph {\n+    pub fn new_disabled() -> DepGraph<K> {\n         DepGraph { data: None, virtual_dep_node_index: Lrc::new(AtomicU32::new(0)) }\n     }\n \n@@ -134,7 +135,7 @@ impl DepGraph {\n         self.data.is_some()\n     }\n \n-    pub fn query(&self) -> DepGraphQuery {\n+    pub fn query(&self) -> DepGraphQuery<K> {\n         let data = self.data.as_ref().unwrap().current.data.lock();\n         let nodes: Vec<_> = data.iter().map(|n| n.node).collect();\n         let mut edges = Vec::new();\n@@ -150,9 +151,8 @@ impl DepGraph {\n \n     pub fn assert_ignored(&self) {\n         if let Some(..) = self.data {\n-            ty::tls::with_context_opt(|icx| {\n-                let icx = if let Some(icx) = icx { icx } else { return };\n-                assert!(icx.task_deps.is_none(), \"expected no task dependency tracking\");\n+            K::read_deps(|task_deps| {\n+                assert!(task_deps.is_none(), \"expected no task dependency tracking\");\n             })\n         }\n     }\n@@ -161,11 +161,7 @@ impl DepGraph {\n     where\n         OP: FnOnce() -> R,\n     {\n-        ty::tls::with_context(|icx| {\n-            let icx = ty::tls::ImplicitCtxt { task_deps: None, ..icx.clone() };\n-\n-            ty::tls::enter_context(&icx, |_| op())\n-        })\n+        K::with_deps(None, op)\n     }\n \n     /// Starts a new dep-graph task. Dep-graph tasks are specified\n@@ -195,16 +191,17 @@ impl DepGraph {\n     ///   `arg` parameter.\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/incremental-compilation.html\n-    pub fn with_task<'a, C, A, R>(\n+    pub fn with_task<H, C, A, R>(\n         &self,\n-        key: DepNode,\n+        key: DepNode<K>,\n         cx: C,\n         arg: A,\n         task: fn(C, A) -> R,\n-        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'a>,\n+        C: DepGraphSafe + HashStableContextProvider<H>,\n+        H: HashStableContext,\n     {\n         self.with_task_impl(\n             key,\n@@ -218,31 +215,33 @@ impl DepGraph {\n                     node: Some(_key),\n                     reads: SmallVec::new(),\n                     read_set: Default::default(),\n+                    phantom_data: PhantomData,\n                 })\n             },\n             |data, key, fingerprint, task| data.complete_task(key, task.unwrap(), fingerprint),\n             hash_result,\n         )\n     }\n \n-    fn with_task_impl<'a, C, A, R>(\n+    fn with_task_impl<H, C, A, R>(\n         &self,\n-        key: DepNode,\n+        key: DepNode<K>,\n         cx: C,\n         arg: A,\n         no_tcx: bool,\n         task: fn(C, A) -> R,\n-        create_task: fn(DepNode) -> Option<TaskDeps>,\n+        create_task: fn(DepNode<K>) -> Option<TaskDeps<K>>,\n         finish_task_and_alloc_depnode: fn(\n-            &CurrentDepGraph,\n-            DepNode,\n+            &CurrentDepGraph<K>,\n+            DepNode<K>,\n             Fingerprint,\n-            Option<TaskDeps>,\n+            Option<TaskDeps<K>>,\n         ) -> DepNodeIndex,\n-        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'a>,\n+        C: DepGraphSafe + HashStableContextProvider<H>,\n+        H: HashStableContext,\n     {\n         if let Some(ref data) = self.data {\n             let task_deps = create_task(key).map(Lock::new);\n@@ -257,12 +256,7 @@ impl DepGraph {\n             let result = if no_tcx {\n                 task(cx, arg)\n             } else {\n-                ty::tls::with_context(|icx| {\n-                    let icx =\n-                        ty::tls::ImplicitCtxt { task_deps: task_deps.as_ref(), ..icx.clone() };\n-\n-                    ty::tls::enter_context(&icx, |_| task(cx, arg))\n-                })\n+                K::with_deps(task_deps.as_ref(), || task(cx, arg))\n             };\n \n             let current_fingerprint = hash_result(&mut hcx, &result);\n@@ -274,7 +268,7 @@ impl DepGraph {\n                 task_deps.map(|lock| lock.into_inner()),\n             );\n \n-            let print_status = cfg!(debug_assertions) && hcx.sess().opts.debugging_opts.dep_tasks;\n+            let print_status = cfg!(debug_assertions) && hcx.debug_dep_tasks();\n \n             // Determine the color of the new DepNode.\n             if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n@@ -322,22 +316,16 @@ impl DepGraph {\n \n     /// Executes something within an \"anonymous\" task, that is, a task the\n     /// `DepNode` of which is determined by the list of inputs it read from.\n-    pub fn with_anon_task<OP, R>(&self, dep_kind: DepKind, op: OP) -> (R, DepNodeIndex)\n+    pub fn with_anon_task<OP, R>(&self, dep_kind: K, op: OP) -> (R, DepNodeIndex)\n     where\n         OP: FnOnce() -> R,\n     {\n         if let Some(ref data) = self.data {\n-            let (result, task_deps) = ty::tls::with_context(|icx| {\n-                let task_deps = Lock::new(TaskDeps::default());\n-\n-                let r = {\n-                    let icx = ty::tls::ImplicitCtxt { task_deps: Some(&task_deps), ..icx.clone() };\n+            let task_deps = Lock::new(TaskDeps::default());\n \n-                    ty::tls::enter_context(&icx, |_| op())\n-                };\n+            let result = K::with_deps(Some(&task_deps), op);\n+            let task_deps = task_deps.into_inner();\n \n-                (r, task_deps.into_inner())\n-            });\n             let dep_node_index = data.current.complete_anon_task(dep_kind, task_deps);\n             (result, dep_node_index)\n         } else {\n@@ -347,16 +335,17 @@ impl DepGraph {\n \n     /// Executes something within an \"eval-always\" task which is a task\n     /// that runs whenever anything changes.\n-    pub fn with_eval_always_task<'a, C, A, R>(\n+    pub fn with_eval_always_task<H, C, A, R>(\n         &self,\n-        key: DepNode,\n+        key: DepNode<K>,\n         cx: C,\n         arg: A,\n         task: fn(C, A) -> R,\n-        hash_result: impl FnOnce(&mut StableHashingContext<'_>, &R) -> Option<Fingerprint>,\n+        hash_result: impl FnOnce(&mut H, &R) -> Option<Fingerprint>,\n     ) -> (R, DepNodeIndex)\n     where\n-        C: DepGraphSafe + StableHashingContextProvider<'a>,\n+        C: DepGraphSafe + HashStableContextProvider<H>,\n+        H: HashStableContext,\n     {\n         self.with_task_impl(\n             key,\n@@ -371,14 +360,14 @@ impl DepGraph {\n     }\n \n     #[inline]\n-    pub fn read(&self, v: DepNode) {\n+    pub fn read(&self, v: DepNode<K>) {\n         if let Some(ref data) = self.data {\n             let map = data.current.node_to_node_index.get_shard_by_value(&v).lock();\n             if let Some(dep_node_index) = map.get(&v).copied() {\n                 std::mem::drop(map);\n                 data.read_index(dep_node_index);\n             } else {\n-                bug!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n+                panic!(\"DepKind {:?} should be pre-allocated but isn't.\", v.kind)\n             }\n         }\n     }\n@@ -391,7 +380,7 @@ impl DepGraph {\n     }\n \n     #[inline]\n-    pub fn dep_node_index_of(&self, dep_node: &DepNode) -> DepNodeIndex {\n+    pub fn dep_node_index_of(&self, dep_node: &DepNode<K>) -> DepNodeIndex {\n         self.data\n             .as_ref()\n             .unwrap()\n@@ -405,7 +394,7 @@ impl DepGraph {\n     }\n \n     #[inline]\n-    pub fn dep_node_exists(&self, dep_node: &DepNode) -> bool {\n+    pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n         if let Some(ref data) = self.data {\n             data.current\n                 .node_to_node_index\n@@ -423,12 +412,12 @@ impl DepGraph {\n         data[dep_node_index].fingerprint\n     }\n \n-    pub fn prev_fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n+    pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n \n     #[inline]\n-    pub fn prev_dep_node_index_of(&self, dep_node: &DepNode) -> SerializedDepNodeIndex {\n+    pub fn prev_dep_node_index_of(&self, dep_node: &DepNode<K>) -> SerializedDepNodeIndex {\n         self.data.as_ref().unwrap().previous.node_to_index(dep_node)\n     }\n \n@@ -445,7 +434,7 @@ impl DepGraph {\n     }\n \n     #[inline(always)]\n-    pub fn register_dep_node_debug_str<F>(&self, dep_node: DepNode, debug_str_gen: F)\n+    pub fn register_dep_node_debug_str<F>(&self, dep_node: DepNode<K>, debug_str_gen: F)\n     where\n         F: FnOnce() -> String,\n     {\n@@ -458,7 +447,7 @@ impl DepGraph {\n         dep_node_debug.borrow_mut().insert(dep_node, debug_str);\n     }\n \n-    pub(super) fn dep_node_debug_str(&self, dep_node: DepNode) -> Option<String> {\n+    pub fn dep_node_debug_str(&self, dep_node: DepNode<K>) -> Option<String> {\n         self.data.as_ref()?.dep_node_debug.borrow().get(&dep_node).cloned()\n     }\n \n@@ -475,7 +464,7 @@ impl DepGraph {\n         }\n     }\n \n-    pub fn serialize(&self) -> SerializedDepGraph {\n+    pub fn serialize(&self) -> SerializedDepGraph<K> {\n         let data = self.data.as_ref().unwrap().current.data.lock();\n \n         let fingerprints: IndexVec<SerializedDepNodeIndex, _> =\n@@ -503,7 +492,7 @@ impl DepGraph {\n         SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data }\n     }\n \n-    pub fn node_color(&self, dep_node: &DepNode) -> Option<DepNodeColor> {\n+    pub fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n         if let Some(ref data) = self.data {\n             if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n                 return data.colors.get(prev_index);\n@@ -521,10 +510,10 @@ impl DepGraph {\n     /// A node will have an index, when it's already been marked green, or when we can mark it\n     /// green. This function will mark the current task as a reader of the specified node, when\n     /// a node index can be found for that node.\n-    pub fn try_mark_green_and_read(\n+    pub fn try_mark_green_and_read<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'_>,\n-        dep_node: &DepNode,\n+        tcx: Ctxt,\n+        dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         self.try_mark_green(tcx, dep_node).map(|(prev_index, dep_node_index)| {\n             debug_assert!(self.is_green(&dep_node));\n@@ -533,10 +522,10 @@ impl DepGraph {\n         })\n     }\n \n-    pub fn try_mark_green(\n+    pub fn try_mark_green<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'_>,\n-        dep_node: &DepNode,\n+        tcx: Ctxt,\n+        dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n         debug_assert!(!dep_node.kind.is_eval_always());\n \n@@ -561,12 +550,12 @@ impl DepGraph {\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    fn try_mark_previous_green<'tcx>(\n+    fn try_mark_previous_green<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n-        data: &DepGraphData,\n+        tcx: Ctxt,\n+        data: &DepGraphData<K>,\n         prev_dep_node_index: SerializedDepNodeIndex,\n-        dep_node: &DepNode,\n+        dep_node: &DepNode<K>,\n     ) -> Option<DepNodeIndex> {\n         debug!(\"try_mark_previous_green({:?}) - BEGIN\", dep_node);\n \n@@ -648,50 +637,6 @@ impl DepGraph {\n                             current_deps.push(node_index);\n                             continue;\n                         }\n-                    } else {\n-                        // FIXME: This match is just a workaround for incremental bugs and should\n-                        // be removed. https://github.com/rust-lang/rust/issues/62649 is one such\n-                        // bug that must be fixed before removing this.\n-                        match dep_dep_node.kind {\n-                            DepKind::hir_owner\n-                            | DepKind::hir_owner_nodes\n-                            | DepKind::CrateMetadata => {\n-                                if let Some(def_id) = dep_dep_node.extract_def_id(tcx) {\n-                                    if def_id_corresponds_to_hir_dep_node(tcx, def_id) {\n-                                        if dep_dep_node.kind == DepKind::CrateMetadata {\n-                                            // The `DefPath` has corresponding node,\n-                                            // and that node should have been marked\n-                                            // either red or green in `data.colors`.\n-                                            bug!(\n-                                                \"DepNode {:?} should have been \\\n-                                             pre-marked as red or green but wasn't.\",\n-                                                dep_dep_node\n-                                            );\n-                                        }\n-                                    } else {\n-                                        // This `DefPath` does not have a\n-                                        // corresponding `DepNode` (e.g. a\n-                                        // struct field), and the ` DefPath`\n-                                        // collided with the `DefPath` of a\n-                                        // proper item that existed in the\n-                                        // previous compilation session.\n-                                        //\n-                                        // Since the given `DefPath` does not\n-                                        // denote the item that previously\n-                                        // existed, we just fail to mark green.\n-                                        return None;\n-                                    }\n-                                } else {\n-                                    // If the node does not exist anymore, we\n-                                    // just fail to mark green.\n-                                    return None;\n-                                }\n-                            }\n-                            _ => {\n-                                // For other kinds of nodes it's OK to be\n-                                // forced.\n-                            }\n-                        }\n                     }\n \n                     // We failed to mark it green, so we try to force the query.\n@@ -700,7 +645,7 @@ impl DepGraph {\n                             dependency {:?}\",\n                         dep_node, dep_dep_node\n                     );\n-                    if crate::ty::query::force_from_dep_node(tcx, dep_dep_node) {\n+                    if tcx.try_force_from_dep_node(dep_dep_node) {\n                         let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n                         match dep_dep_node_color {\n@@ -721,8 +666,8 @@ impl DepGraph {\n                                 return None;\n                             }\n                             None => {\n-                                if !tcx.sess.has_errors_or_delayed_span_bugs() {\n-                                    bug!(\n+                                if !tcx.has_errors_or_delayed_span_bugs() {\n+                                    panic!(\n                                         \"try_mark_previous_green() - Forcing the DepNode \\\n                                           should have set its color\"\n                                     )\n@@ -779,7 +724,7 @@ impl DepGraph {\n \n         // FIXME: Store the fact that a node has diagnostics in a bit in the dep graph somewhere\n         // Maybe store a list on disk and encode this fact in the DepNodeState\n-        let diagnostics = tcx.queries.on_disk_cache.load_diagnostics(tcx, prev_dep_node_index);\n+        let diagnostics = tcx.load_diagnostics(prev_dep_node_index);\n \n         #[cfg(not(parallel_compiler))]\n         debug_assert!(\n@@ -805,10 +750,10 @@ impl DepGraph {\n     /// This may be called concurrently on multiple threads for the same dep node.\n     #[cold]\n     #[inline(never)]\n-    fn emit_diagnostics<'tcx>(\n+    fn emit_diagnostics<Ctxt: DepContext<DepKind = K>>(\n         &self,\n-        tcx: TyCtxt<'tcx>,\n-        data: &DepGraphData,\n+        tcx: Ctxt,\n+        data: &DepGraphData<K>,\n         dep_node_index: DepNodeIndex,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         diagnostics: Vec<Diagnostic>,\n@@ -827,9 +772,9 @@ impl DepGraph {\n             mem::drop(emitting);\n \n             // Promote the previous diagnostics to the current session.\n-            tcx.queries.on_disk_cache.store_diagnostics(dep_node_index, diagnostics.clone().into());\n+            tcx.store_diagnostics(dep_node_index, diagnostics.clone().into());\n \n-            let handle = tcx.sess.diagnostic();\n+            let handle = tcx.diagnostic();\n \n             for diagnostic in diagnostics {\n                 handle.emit_diagnostic(&diagnostic);\n@@ -858,7 +803,7 @@ impl DepGraph {\n \n     // Returns true if the given node has been marked as green during the\n     // current compilation session. Used in various assertions\n-    pub fn is_green(&self, dep_node: &DepNode) -> bool {\n+    pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n         self.node_color(dep_node).map(|c| c.is_green()).unwrap_or(false)\n     }\n \n@@ -870,15 +815,15 @@ impl DepGraph {\n     //\n     // This method will only load queries that will end up in the disk cache.\n     // Other queries will not be executed.\n-    pub fn exec_cache_promotions(&self, tcx: TyCtxt<'_>) {\n-        let _prof_timer = tcx.prof.generic_activity(\"incr_comp_query_cache_promotion\");\n+    pub fn exec_cache_promotions<Ctxt: DepContext<DepKind = K>>(&self, tcx: Ctxt) {\n+        let _prof_timer = tcx.profiler().generic_activity(\"incr_comp_query_cache_promotion\");\n \n         let data = self.data.as_ref().unwrap();\n         for prev_index in data.colors.values.indices() {\n             match data.colors.get(prev_index) {\n                 Some(DepNodeColor::Green(_)) => {\n                     let dep_node = data.previous.index_to_node(prev_index);\n-                    dep_node.try_load_from_on_disk_cache(tcx);\n+                    tcx.try_load_from_on_disk_cache(&dep_node);\n                 }\n                 None | Some(DepNodeColor::Red) => {\n                     // We can skip red nodes because a node can only be marked\n@@ -895,11 +840,6 @@ impl DepGraph {\n     }\n }\n \n-fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    def_id.index == hir_id.owner.local_def_index\n-}\n-\n /// A \"work product\" is an intermediate result that we save into the\n /// incremental directory for later re-use. The primary example are\n /// the object files that we save for each partition at code\n@@ -946,8 +886,8 @@ pub enum WorkProductFileKind {\n }\n \n #[derive(Clone)]\n-struct DepNodeData {\n-    node: DepNode,\n+struct DepNodeData<K> {\n+    node: DepNode<K>,\n     edges: EdgesVec,\n     fingerprint: Fingerprint,\n }\n@@ -967,9 +907,9 @@ struct DepNodeData {\n /// The only operation that must manipulate both locks is adding new nodes, in which case\n /// we first acquire the `node_to_node_index` lock and then, once a new node is to be inserted,\n /// acquire the lock on `data.`\n-pub(super) struct CurrentDepGraph {\n-    data: Lock<IndexVec<DepNodeIndex, DepNodeData>>,\n-    node_to_node_index: Sharded<FxHashMap<DepNode, DepNodeIndex>>,\n+pub(super) struct CurrentDepGraph<K> {\n+    data: Lock<IndexVec<DepNodeIndex, DepNodeData<K>>>,\n+    node_to_node_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n@@ -995,8 +935,8 @@ pub(super) struct CurrentDepGraph {\n     total_duplicate_read_count: AtomicU64,\n }\n \n-impl CurrentDepGraph {\n-    fn new(prev_graph_node_count: usize) -> CurrentDepGraph {\n+impl<K: DepKind> CurrentDepGraph<K> {\n+    fn new(prev_graph_node_count: usize) -> CurrentDepGraph<K> {\n         use std::time::{SystemTime, UNIX_EPOCH};\n \n         let duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n@@ -1008,7 +948,7 @@ impl CurrentDepGraph {\n             match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n                 Ok(s) => match EdgeFilter::new(&s) {\n                     Ok(f) => Some(f),\n-                    Err(err) => bug!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+                    Err(err) => panic!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n                 },\n                 Err(_) => None,\n             }\n@@ -1039,14 +979,14 @@ impl CurrentDepGraph {\n \n     fn complete_task(\n         &self,\n-        node: DepNode,\n-        task_deps: TaskDeps,\n+        node: DepNode<K>,\n+        task_deps: TaskDeps<K>,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n         self.alloc_node(node, task_deps.reads, fingerprint)\n     }\n \n-    fn complete_anon_task(&self, kind: DepKind, task_deps: TaskDeps) -> DepNodeIndex {\n+    fn complete_anon_task(&self, kind: K, task_deps: TaskDeps<K>) -> DepNodeIndex {\n         debug_assert!(!kind.is_eval_always());\n \n         let mut hasher = StableHasher::new();\n@@ -1072,7 +1012,7 @@ impl CurrentDepGraph {\n \n     fn alloc_node(\n         &self,\n-        dep_node: DepNode,\n+        dep_node: DepNode<K>,\n         edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n@@ -1084,7 +1024,7 @@ impl CurrentDepGraph {\n \n     fn intern_node(\n         &self,\n-        dep_node: DepNode,\n+        dep_node: DepNode<K>,\n         edges: EdgesVec,\n         fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n@@ -1101,12 +1041,11 @@ impl CurrentDepGraph {\n     }\n }\n \n-impl DepGraphData {\n+impl<K: DepKind> DepGraphData<K> {\n     #[inline(never)]\n     fn read_index(&self, source: DepNodeIndex) {\n-        ty::tls::with_context_opt(|icx| {\n-            let icx = if let Some(icx) = icx { icx } else { return };\n-            if let Some(task_deps) = icx.task_deps {\n+        K::read_deps(|task_deps| {\n+            if let Some(task_deps) = task_deps {\n                 let mut task_deps = task_deps.lock();\n                 let task_deps = &mut *task_deps;\n                 if cfg!(debug_assertions) {\n@@ -1135,7 +1074,7 @@ impl DepGraphData {\n                             if let Some(ref forbidden_edge) = self.current.forbidden_edge {\n                                 let source = data[source].node;\n                                 if forbidden_edge.test(&source, &target) {\n-                                    bug!(\"forbidden edge {:?} -> {:?} created\", source, target)\n+                                    panic!(\"forbidden edge {:?} -> {:?} created\", source, target)\n                                 }\n                             }\n                         }\n@@ -1151,12 +1090,25 @@ impl DepGraphData {\n /// The capacity of the `reads` field `SmallVec`\n const TASK_DEPS_READS_CAP: usize = 8;\n type EdgesVec = SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>;\n-#[derive(Default)]\n-pub struct TaskDeps {\n+\n+pub struct TaskDeps<K> {\n     #[cfg(debug_assertions)]\n-    node: Option<DepNode>,\n+    node: Option<DepNode<K>>,\n     reads: EdgesVec,\n     read_set: FxHashSet<DepNodeIndex>,\n+    phantom_data: PhantomData<DepNode<K>>,\n+}\n+\n+impl<K> Default for TaskDeps<K> {\n+    fn default() -> Self {\n+        Self {\n+            #[cfg(debug_assertions)]\n+            node: None,\n+            reads: EdgesVec::new(),\n+            read_set: FxHashSet::default(),\n+            phantom_data: PhantomData,\n+        }\n+    }\n }\n \n // A data structure that stores Option<DepNodeColor> values as a contiguous", "previous_filename": "src/librustc/dep_graph/graph.rs"}, {"sha": "825b341cd146d51889bcc71bb1ffd7727204d5c0", "filename": "src/librustc_query_system/dep_graph/mod.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -0,0 +1,75 @@\n+pub mod debug;\n+mod dep_node;\n+mod graph;\n+mod prev;\n+mod query;\n+mod safe;\n+mod serialized;\n+\n+pub use dep_node::{DepNode, DepNodeParams, WorkProductId};\n+pub use graph::WorkProductFileKind;\n+pub use graph::{hash_result, DepGraph, DepNodeColor, DepNodeIndex, TaskDeps, WorkProduct};\n+pub use prev::PreviousDepGraph;\n+pub use query::DepGraphQuery;\n+pub use safe::AssertDepGraphSafe;\n+pub use safe::DepGraphSafe;\n+pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n+\n+use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::sync::Lock;\n+use rustc_data_structures::thin_vec::ThinVec;\n+use rustc_errors::Diagnostic;\n+\n+use std::fmt;\n+use std::hash::Hash;\n+\n+pub trait DepContext: Copy {\n+    type DepKind: self::DepKind;\n+    type StableHashingContext: crate::HashStableContext;\n+\n+    /// Create a hashing context for hashing new results.\n+    fn create_stable_hashing_context(&self) -> Self::StableHashingContext;\n+\n+    /// Try to force a dep node to execute and see if it's green.\n+    fn try_force_from_dep_node(&self, dep_node: &DepNode<Self::DepKind>) -> bool;\n+\n+    /// Return whether the current session is tainted by errors.\n+    fn has_errors_or_delayed_span_bugs(&self) -> bool;\n+\n+    /// Return the diagnostic handler.\n+    fn diagnostic(&self) -> &rustc_errors::Handler;\n+\n+    /// Load data from the on-disk cache.\n+    fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);\n+\n+    /// Load diagnostics associated to the node in the previous session.\n+    fn load_diagnostics(&self, prev_dep_node_index: SerializedDepNodeIndex) -> Vec<Diagnostic>;\n+\n+    /// Register diagnostics for the given node, for use in next session.\n+    fn store_diagnostics(&self, dep_node_index: DepNodeIndex, diagnostics: ThinVec<Diagnostic>);\n+\n+    /// Access the profiler.\n+    fn profiler(&self) -> &SelfProfilerRef;\n+}\n+\n+/// Describe the different families of dependency nodes.\n+pub trait DepKind: Copy + fmt::Debug + Eq + Ord + Hash {\n+    /// Return whether this kind always require evaluation.\n+    fn is_eval_always(&self) -> bool;\n+\n+    /// Return whether this kind requires additional parameters to be executed.\n+    fn has_params(&self) -> bool;\n+\n+    /// Implementation of `std::fmt::Debug` for `DepNode`.\n+    fn debug_node(node: &DepNode<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result;\n+\n+    /// Execute the operation with provided dependencies.\n+    fn with_deps<OP, R>(deps: Option<&Lock<TaskDeps<Self>>>, op: OP) -> R\n+    where\n+        OP: FnOnce() -> R;\n+\n+    /// Access dependencies from current implicit context.\n+    fn read_deps<OP>(op: OP) -> ()\n+    where\n+        OP: for<'a> FnOnce(Option<&'a Lock<TaskDeps<Self>>>) -> ();\n+}"}, {"sha": "5cba64cac4b3449eb26eddc6c053c460444f6aea", "filename": "src/librustc_query_system/dep_graph/prev.rs", "status": "renamed", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,16 +1,22 @@\n-use super::dep_node::DepNode;\n use super::serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n-use crate::ich::Fingerprint;\n+use super::{DepKind, DepNode};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n \n-#[derive(Debug, RustcEncodable, RustcDecodable, Default)]\n-pub struct PreviousDepGraph {\n-    data: SerializedDepGraph,\n-    index: FxHashMap<DepNode, SerializedDepNodeIndex>,\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct PreviousDepGraph<K: DepKind> {\n+    data: SerializedDepGraph<K>,\n+    index: FxHashMap<DepNode<K>, SerializedDepNodeIndex>,\n }\n \n-impl PreviousDepGraph {\n-    pub fn new(data: SerializedDepGraph) -> PreviousDepGraph {\n+impl<K: DepKind> Default for PreviousDepGraph<K> {\n+    fn default() -> Self {\n+        PreviousDepGraph { data: Default::default(), index: Default::default() }\n+    }\n+}\n+\n+impl<K: DepKind> PreviousDepGraph<K> {\n+    pub fn new(data: SerializedDepGraph<K>) -> PreviousDepGraph<K> {\n         let index: FxHashMap<_, _> =\n             data.nodes.iter_enumerated().map(|(idx, &dep_node)| (dep_node, idx)).collect();\n         PreviousDepGraph { data, index }\n@@ -25,22 +31,22 @@ impl PreviousDepGraph {\n     }\n \n     #[inline]\n-    pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode {\n+    pub fn index_to_node(&self, dep_node_index: SerializedDepNodeIndex) -> DepNode<K> {\n         self.data.nodes[dep_node_index]\n     }\n \n     #[inline]\n-    pub fn node_to_index(&self, dep_node: &DepNode) -> SerializedDepNodeIndex {\n+    pub fn node_to_index(&self, dep_node: &DepNode<K>) -> SerializedDepNodeIndex {\n         self.index[dep_node]\n     }\n \n     #[inline]\n-    pub fn node_to_index_opt(&self, dep_node: &DepNode) -> Option<SerializedDepNodeIndex> {\n+    pub fn node_to_index_opt(&self, dep_node: &DepNode<K>) -> Option<SerializedDepNodeIndex> {\n         self.index.get(dep_node).cloned()\n     }\n \n     #[inline]\n-    pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n+    pub fn fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n         self.index.get(dep_node).map(|&node_index| self.data.fingerprints[node_index])\n     }\n ", "previous_filename": "src/librustc/dep_graph/prev.rs"}, {"sha": "4a4283b2a0cbbd05f8083fdb4ba5e038db37019b", "filename": "src/librustc_query_system/dep_graph/query.rs", "status": "renamed", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -3,15 +3,15 @@ use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n \n-use super::DepNode;\n+use super::{DepKind, DepNode};\n \n-pub struct DepGraphQuery {\n-    pub graph: Graph<DepNode, ()>,\n-    pub indices: FxHashMap<DepNode, NodeIndex>,\n+pub struct DepGraphQuery<K> {\n+    pub graph: Graph<DepNode<K>, ()>,\n+    pub indices: FxHashMap<DepNode<K>, NodeIndex>,\n }\n \n-impl DepGraphQuery {\n-    pub fn new(nodes: &[DepNode], edges: &[(DepNode, DepNode)]) -> DepGraphQuery {\n+impl<K: DepKind> DepGraphQuery<K> {\n+    pub fn new(nodes: &[DepNode<K>], edges: &[(DepNode<K>, DepNode<K>)]) -> DepGraphQuery<K> {\n         let mut graph = Graph::with_capacity(nodes.len(), edges.len());\n         let mut indices = FxHashMap::default();\n         for node in nodes {\n@@ -27,15 +27,15 @@ impl DepGraphQuery {\n         DepGraphQuery { graph, indices }\n     }\n \n-    pub fn contains_node(&self, node: &DepNode) -> bool {\n+    pub fn contains_node(&self, node: &DepNode<K>) -> bool {\n         self.indices.contains_key(&node)\n     }\n \n-    pub fn nodes(&self) -> Vec<&DepNode> {\n+    pub fn nodes(&self) -> Vec<&DepNode<K>> {\n         self.graph.all_nodes().iter().map(|n| &n.data).collect()\n     }\n \n-    pub fn edges(&self) -> Vec<(&DepNode, &DepNode)> {\n+    pub fn edges(&self) -> Vec<(&DepNode<K>, &DepNode<K>)> {\n         self.graph\n             .all_edges()\n             .iter()\n@@ -44,7 +44,7 @@ impl DepGraphQuery {\n             .collect()\n     }\n \n-    fn reachable_nodes(&self, node: &DepNode, direction: Direction) -> Vec<&DepNode> {\n+    fn reachable_nodes(&self, node: &DepNode<K>, direction: Direction) -> Vec<&DepNode<K>> {\n         if let Some(&index) = self.indices.get(node) {\n             self.graph.depth_traverse(index, direction).map(|s| self.graph.node_data(s)).collect()\n         } else {\n@@ -54,17 +54,17 @@ impl DepGraphQuery {\n \n     /// All nodes reachable from `node`. In other words, things that\n     /// will have to be recomputed if `node` changes.\n-    pub fn transitive_successors(&self, node: &DepNode) -> Vec<&DepNode> {\n+    pub fn transitive_successors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         self.reachable_nodes(node, OUTGOING)\n     }\n \n     /// All nodes that can reach `node`.\n-    pub fn transitive_predecessors(&self, node: &DepNode) -> Vec<&DepNode> {\n+    pub fn transitive_predecessors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         self.reachable_nodes(node, INCOMING)\n     }\n \n     /// Just the outgoing edges from `node`.\n-    pub fn immediate_successors(&self, node: &DepNode) -> Vec<&DepNode> {\n+    pub fn immediate_successors(&self, node: &DepNode<K>) -> Vec<&DepNode<K>> {\n         if let Some(&index) = self.indices.get(&node) {\n             self.graph.successor_nodes(index).map(|s| self.graph.node_data(s)).collect()\n         } else {", "previous_filename": "src/librustc/dep_graph/query.rs"}, {"sha": "7bba348f8841f70c46019f9aa8ba64612f9c3190", "filename": "src/librustc_query_system/dep_graph/safe.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -0,0 +1,51 @@\n+//! The `DepGraphSafe` trait\n+\n+use rustc_ast::ast::NodeId;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::BodyId;\n+\n+/// The `DepGraphSafe` trait is used to specify what kinds of values\n+/// are safe to \"leak\" into a task. The idea is that this should be\n+/// only be implemented for things like the tcx as well as various id\n+/// types, which will create reads in the dep-graph whenever the trait\n+/// loads anything that might depend on the input program.\n+pub trait DepGraphSafe {}\n+\n+/// A `BodyId` on its own doesn't give access to any particular state.\n+/// You must fetch the state from the various maps or generate\n+/// on-demand queries, all of which create reads.\n+impl DepGraphSafe for BodyId {}\n+\n+/// A `NodeId` on its own doesn't give access to any particular state.\n+/// You must fetch the state from the various maps or generate\n+/// on-demand queries, all of which create reads.\n+impl DepGraphSafe for NodeId {}\n+\n+/// A `DefId` on its own doesn't give access to any particular state.\n+/// You must fetch the state from the various maps or generate\n+/// on-demand queries, all of which create reads.\n+impl DepGraphSafe for DefId {}\n+\n+/// Tuples make it easy to build up state.\n+impl<A, B> DepGraphSafe for (A, B)\n+where\n+    A: DepGraphSafe,\n+    B: DepGraphSafe,\n+{\n+}\n+\n+/// Shared ref to dep-graph-safe stuff should still be dep-graph-safe.\n+impl<'a, A> DepGraphSafe for &'a A where A: DepGraphSafe {}\n+\n+/// Mut ref to dep-graph-safe stuff should still be dep-graph-safe.\n+impl<'a, A> DepGraphSafe for &'a mut A where A: DepGraphSafe {}\n+\n+/// No data here! :)\n+impl DepGraphSafe for () {}\n+\n+/// A convenient override that lets you pass arbitrary state into a\n+/// task. Every use should be accompanied by a comment explaining why\n+/// it makes sense (or how it could be refactored away in the future).\n+pub struct AssertDepGraphSafe<T>(pub T);\n+\n+impl<T> DepGraphSafe for AssertDepGraphSafe<T> {}"}, {"sha": "4a89da23ea6a59239ff9a99834d9bc029e51d2bf", "filename": "src/librustc_query_system/dep_graph/serialized.rs", "status": "renamed", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,18 +1,18 @@\n //! The data that we will serialize and deserialize.\n \n-use crate::dep_graph::DepNode;\n-use crate::ich::Fingerprint;\n+use super::{DepKind, DepNode};\n+use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_index::vec::IndexVec;\n \n rustc_index::newtype_index! {\n     pub struct SerializedDepNodeIndex { .. }\n }\n \n /// Data for use when recompiling the **current crate**.\n-#[derive(Debug, RustcEncodable, RustcDecodable, Default)]\n-pub struct SerializedDepGraph {\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedDepGraph<K: DepKind> {\n     /// The set of all DepNodes in the graph\n-    pub nodes: IndexVec<SerializedDepNodeIndex, DepNode>,\n+    pub nodes: IndexVec<SerializedDepNodeIndex, DepNode<K>>,\n     /// The set of all Fingerprints in the graph. Each Fingerprint corresponds to\n     /// the DepNode at the same index in the nodes vector.\n     pub fingerprints: IndexVec<SerializedDepNodeIndex, Fingerprint>,\n@@ -25,7 +25,18 @@ pub struct SerializedDepGraph {\n     pub edge_list_data: Vec<SerializedDepNodeIndex>,\n }\n \n-impl SerializedDepGraph {\n+impl<K: DepKind> Default for SerializedDepGraph<K> {\n+    fn default() -> Self {\n+        SerializedDepGraph {\n+            nodes: Default::default(),\n+            fingerprints: Default::default(),\n+            edge_list_indices: Default::default(),\n+            edge_list_data: Default::default(),\n+        }\n+    }\n+}\n+\n+impl<K: DepKind> SerializedDepGraph<K> {\n     #[inline]\n     pub fn edge_targets_from(&self, source: SerializedDepNodeIndex) -> &[SerializedDepNodeIndex] {\n         let targets = self.edge_list_indices[source];", "previous_filename": "src/librustc/dep_graph/serialized.rs"}, {"sha": "ef4886828c41167dc5358c8dafcfe52ed831e750", "filename": "src/librustc_query_system/lib.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_query_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Flib.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -0,0 +1,32 @@\n+#![feature(const_fn)]\n+#![feature(const_if_match)]\n+#![feature(const_panic)]\n+#![feature(core_intrinsics)]\n+#![feature(specialization)]\n+#![feature(stmt_expr_attributes)]\n+\n+#[macro_use]\n+extern crate log;\n+\n+pub mod dep_graph;\n+\n+pub trait HashStableContext {\n+    fn debug_dep_tasks(&self) -> bool;\n+}\n+\n+/// Something that can provide a stable hashing context.\n+pub trait HashStableContextProvider<Ctxt> {\n+    fn get_stable_hashing_context(&self) -> Ctxt;\n+}\n+\n+impl<Ctxt, T: HashStableContextProvider<Ctxt>> HashStableContextProvider<Ctxt> for &T {\n+    fn get_stable_hashing_context(&self) -> Ctxt {\n+        (**self).get_stable_hashing_context()\n+    }\n+}\n+\n+impl<Ctxt, T: HashStableContextProvider<Ctxt>> HashStableContextProvider<Ctxt> for &mut T {\n+    fn get_stable_hashing_context(&self) -> Ctxt {\n+        (**self).get_stable_hashing_context()\n+    }\n+}"}, {"sha": "30189d189f2edfe81ea7e31476d591d9de86d5ca", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -816,11 +816,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n             // The regions that we expect from borrow checking.\n             ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n \n-            ty::ReEmpty(_)\n-            | ty::RePlaceholder(_)\n-            | ty::ReVar(_)\n-            | ty::ReScope(_)\n-            | ty::ReClosureBound(_) => {\n+            ty::ReEmpty(_) | ty::RePlaceholder(_) | ty::ReVar(_) | ty::ReScope(_) => {\n                 // All of the regions in the type should either have been\n                 // erased by writeback, or mapped back to named regions by\n                 // borrow checking."}, {"sha": "6f558ec9b9508a4578bbd5d6e977fb33dbdba322", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 19, "deletions": 94, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -20,9 +20,9 @@ use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::Visitor;\n+use rustc_hir::intravisit::{walk_generics, Visitor};\n use rustc_hir::print;\n-use rustc_hir::{Constness, ExprKind, GenericArg, GenericArgs};\n+use rustc_hir::{Constness, GenericArg, GenericArgs};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, LATE_BOUND_LIFETIME_ARGUMENTS};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n@@ -39,8 +39,6 @@ use std::collections::BTreeSet;\n use std::iter;\n use std::slice;\n \n-use rustc::mir::interpret::LitToConstInput;\n-\n #[derive(Debug)]\n pub struct PathSeg(pub DefId, pub usize);\n \n@@ -782,7 +780,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     }\n                 }\n                 (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                    self.ast_const_to_const(&ct.value, tcx.type_of(param.def_id)).into()\n+                    let ct_def_id = tcx.hir().local_def_id(ct.value.hir_id).expect_local();\n+                    ty::Const::from_anon_const(tcx, ct_def_id).into()\n                 }\n                 _ => unreachable!(),\n             },\n@@ -838,18 +837,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n             },\n         );\n-        if !inferred_params.is_empty() {\n-            // We always collect the spans for placeholder types when evaluating `fn`s, but we\n-            // only want to emit an error complaining about them if infer types (`_`) are not\n-            // allowed. `allow_ty_infer` gates this behavior.\n-            crate::collect::placeholder_type_error(\n-                tcx,\n-                inferred_params[0],\n-                &[],\n-                inferred_params,\n-                false,\n-            );\n-        }\n \n         self.complain_about_missing_type_params(\n             missing_type_params,\n@@ -2747,7 +2734,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::BareFn(ref bf) => {\n                 require_c_abi_if_c_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-                tcx.mk_fn_ptr(self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl, &[], None))\n+                tcx.mk_fn_ptr(self.ty_of_fn(\n+                    bf.unsafety,\n+                    bf.abi,\n+                    &bf.decl,\n+                    &hir::Generics::empty(),\n+                    None,\n+                ))\n             }\n             hir::TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n@@ -2775,7 +2768,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .unwrap_or(tcx.types.err)\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n-                let length = self.ast_const_to_const(length, tcx.types.usize);\n+                let length_def_id = tcx.hir().local_def_id(length.hir_id).expect_local();\n+                let length = ty::Const::from_anon_const(tcx, length_def_id);\n                 let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }\n@@ -2807,75 +2801,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         result_ty\n     }\n \n-    /// Returns the `DefId` of the constant parameter that the provided expression is a path to.\n-    pub fn const_param_def_id(&self, expr: &hir::Expr<'_>) -> Option<DefId> {\n-        // Unwrap a block, so that e.g. `{ P }` is recognised as a parameter. Const arguments\n-        // currently have to be wrapped in curly brackets, so it's necessary to special-case.\n-        let expr = match &expr.kind {\n-            ExprKind::Block(block, _) if block.stmts.is_empty() && block.expr.is_some() => {\n-                block.expr.as_ref().unwrap()\n-            }\n-            _ => expr,\n-        };\n-\n-        match &expr.kind {\n-            ExprKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n-                Res::Def(DefKind::ConstParam, did) => Some(did),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn ast_const_to_const(\n-        &self,\n-        ast_const: &hir::AnonConst,\n-        ty: Ty<'tcx>,\n-    ) -> &'tcx ty::Const<'tcx> {\n-        debug!(\"ast_const_to_const(id={:?}, ast_const={:?})\", ast_const.hir_id, ast_const);\n-\n-        let tcx = self.tcx();\n-        let def_id = tcx.hir().local_def_id(ast_const.hir_id);\n-\n-        let expr = &tcx.hir().body(ast_const.body).value;\n-\n-        let lit_input = match expr.kind {\n-            hir::ExprKind::Lit(ref lit) => Some(LitToConstInput { lit: &lit.node, ty, neg: false }),\n-            hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => match expr.kind {\n-                hir::ExprKind::Lit(ref lit) => {\n-                    Some(LitToConstInput { lit: &lit.node, ty, neg: true })\n-                }\n-                _ => None,\n-            },\n-            _ => None,\n-        };\n-\n-        if let Some(lit_input) = lit_input {\n-            // If an error occurred, ignore that it's a literal and leave reporting the error up to\n-            // mir.\n-            if let Ok(c) = tcx.at(expr.span).lit_to_const(lit_input) {\n-                return c;\n-            } else {\n-                tcx.sess.delay_span_bug(expr.span, \"ast_const_to_const: couldn't lit_to_const\");\n-            }\n-        }\n-\n-        let kind = if let Some(def_id) = self.const_param_def_id(expr) {\n-            // Find the name and index of the const parameter by indexing the generics of the\n-            // parent item and construct a `ParamConst`.\n-            let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-            let item_id = tcx.hir().get_parent_node(hir_id);\n-            let item_def_id = tcx.hir().local_def_id(item_id);\n-            let generics = tcx.generics_of(item_def_id);\n-            let index = generics.param_def_id_to_index[&tcx.hir().local_def_id(hir_id)];\n-            let name = tcx.hir().name(hir_id);\n-            ty::ConstKind::Param(ty::ParamConst::new(index, name))\n-        } else {\n-            ty::ConstKind::Unevaluated(def_id, InternalSubsts::identity_for_item(tcx, def_id), None)\n-        };\n-        tcx.mk_const(ty::Const { val: kind, ty })\n-    }\n-\n     pub fn impl_trait_ty_to_ty(\n         &self,\n         def_id: DefId,\n@@ -2930,7 +2855,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         unsafety: hir::Unsafety,\n         abi: abi::Abi,\n         decl: &hir::FnDecl<'_>,\n-        generic_params: &[hir::GenericParam<'_>],\n+        generics: &hir::Generics<'_>,\n         ident_span: Option<Span>,\n     ) -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n@@ -2942,6 +2867,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         for ty in decl.inputs {\n             visitor.visit_ty(ty);\n         }\n+        walk_generics(&mut visitor, generics);\n+\n         let input_tys = decl.inputs.iter().map(|a| self.ty_of_arg(a, None));\n         let output_ty = match decl.output {\n             hir::FnRetTy::Return(ref output) => {\n@@ -2963,7 +2890,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             crate::collect::placeholder_type_error(\n                 tcx,\n                 ident_span.map(|sp| sp.shrink_to_hi()).unwrap_or(DUMMY_SP),\n-                generic_params,\n+                &generics.params[..],\n                 visitor.0,\n                 ident_span.is_some(),\n             );\n@@ -2989,8 +2916,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 tcx.sess,\n                 decl.output.span(),\n                 E0581,\n-                \"return type references {} \\\n-                                            which is not constrained by the fn input types\",\n+                \"return type references {} which is not constrained by the fn input types\",\n                 lifetime_name\n             );\n             if let ty::BrAnon(_) = *br {\n@@ -3001,8 +2927,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // though we can easily give a hint that ought to be\n                 // relevant.\n                 err.note(\n-                    \"lifetimes appearing in an associated type \\\n-                          are not considered constrained\",\n+                    \"lifetimes appearing in an associated type are not considered constrained\",\n                 );\n             }\n             err.emit();"}, {"sha": "dffed9a836c216a5c5bcbbbd764ad57f7a66fb5d", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -18,7 +18,6 @@ use crate::type_error_struct;\n use crate::util::common::ErrorReported;\n \n use rustc::middle::lang_items;\n-use rustc::mir::interpret::ErrorHandled;\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::Ty;\n@@ -1008,13 +1007,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         _expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let count_def_id = tcx.hir().local_def_id(count.hir_id);\n-        let count = if self.const_param_def_id(count).is_some() {\n-            Ok(self.to_const(count, tcx.type_of(count_def_id)))\n-        } else {\n-            tcx.const_eval_poly(count_def_id)\n-                .map(|val| ty::Const::from_value(tcx, val, tcx.type_of(count_def_id)))\n-        };\n+        let count = self.to_const(count);\n \n         let uty = match expected {\n             ExpectHasType(uty) => match uty.kind {\n@@ -1042,17 +1035,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if element_ty.references_error() {\n             return tcx.types.err;\n         }\n-        match count {\n-            Ok(count) => tcx.mk_ty(ty::Array(t, count)),\n-            Err(ErrorHandled::TooGeneric) => {\n-                self.tcx.sess.span_err(\n-                    tcx.def_span(count_def_id),\n-                    \"array lengths can't depend on generic parameters\",\n-                );\n-                tcx.types.err\n-            }\n-            Err(ErrorHandled::Reported) => tcx.types.err,\n-        }\n+\n+        tcx.mk_ty(ty::Array(t, count))\n     }\n \n     fn check_expr_tuple("}, {"sha": "d340d6ff5c27174576aa5eaa771c76b983b7da45", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                 }\n                 (GenericParamDefKind::Type { .. }, GenericArg::Type(ty)) => self.to_ty(ty).into(),\n                 (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                    self.to_const(&ct.value, self.tcx.type_of(param.def_id)).into()\n+                    self.to_const(&ct.value).into()\n                 }\n                 _ => unreachable!(),\n             },"}, {"sha": "085510452c47ee6738fb3bc6b1260533c5c0308b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1003,7 +1003,14 @@ fn typeck_tables_of_with_fallback<'tcx>(\n         let fcx = if let (Some(header), Some(decl)) = (fn_header, fn_decl) {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n                 let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n-                AstConv::ty_of_fn(&fcx, header.unsafety, header.abi, decl, &[], None)\n+                AstConv::ty_of_fn(\n+                    &fcx,\n+                    header.unsafety,\n+                    header.abi,\n+                    decl,\n+                    &hir::Generics::empty(),\n+                    None,\n+                )\n             } else {\n                 tcx.fn_sig(def_id)\n             };\n@@ -3279,13 +3286,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty\n     }\n \n-    /// Returns the `DefId` of the constant parameter that the provided expression is a path to.\n-    pub fn const_param_def_id(&self, hir_c: &hir::AnonConst) -> Option<DefId> {\n-        AstConv::const_param_def_id(self, &self.tcx.hir().body(hir_c.body).value)\n-    }\n-\n-    pub fn to_const(&self, ast_c: &hir::AnonConst, ty: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        AstConv::ast_const_to_const(self, ast_c, ty)\n+    pub fn to_const(&self, ast_c: &hir::AnonConst) -> &'tcx ty::Const<'tcx> {\n+        let c = self.tcx.hir().local_def_id(ast_c.hir_id).expect_local();\n+        ty::Const::from_anon_const(self.tcx, c)\n     }\n \n     // If the type given by the user has free regions, save it for later, since\n@@ -5512,7 +5515,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         self.to_ty(ty).into()\n                     }\n                     (GenericParamDefKind::Const, GenericArg::Const(ct)) => {\n-                        self.to_const(&ct.value, self.tcx.type_of(param.def_id)).into()\n+                        self.to_const(&ct.value).into()\n                     }\n                     _ => unreachable!(),\n                 },"}, {"sha": "8136417de03871701ee6362c9a21ee7e53ea8e16", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1486,7 +1486,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     sig.header.unsafety,\n                     sig.header.abi,\n                     &sig.decl,\n-                    &generics.params[..],\n+                    &generics,\n                     Some(ident.span),\n                 ),\n             }\n@@ -1497,14 +1497,9 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             ident,\n             generics,\n             ..\n-        }) => AstConv::ty_of_fn(\n-            &icx,\n-            header.unsafety,\n-            header.abi,\n-            decl,\n-            &generics.params[..],\n-            Some(ident.span),\n-        ),\n+        }) => {\n+            AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl, &generics, Some(ident.span))\n+        }\n \n         ForeignItem(&hir::ForeignItem { kind: ForeignItemKind::Fn(ref fn_decl, _, _), .. }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n@@ -2127,7 +2122,14 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     } else {\n         hir::Unsafety::Unsafe\n     };\n-    let fty = AstConv::ty_of_fn(&ItemCtxt::new(tcx, def_id), unsafety, abi, decl, &[], None);\n+    let fty = AstConv::ty_of_fn(\n+        &ItemCtxt::new(tcx, def_id),\n+        unsafety,\n+        abi,\n+        decl,\n+        &hir::Generics::empty(),\n+        None,\n+    );\n \n     // Feature gate SIMD types in FFI, since I am not sure that the\n     // ABIs are handled at all correctly. -huonw"}, {"sha": "e1bd78e5113d1058f077381b19fabb78e09bf8a0", "filename": "src/librustc_typeck/outlives/utils.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Futils.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -170,7 +170,6 @@ fn is_free_region(tcx: TyCtxt<'_>, region: Region<'_>) -> bool {\n \n         // These regions don't appear in types from type declarations:\n         RegionKind::ReErased\n-        | RegionKind::ReClosureBound(..)\n         | RegionKind::ReScope(..)\n         | RegionKind::ReVar(..)\n         | RegionKind::RePlaceholder(..)"}, {"sha": "11612066d44b26d7027cf82eb85f58b37e6ee1db", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -449,7 +449,6 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ReFree(..)\n-            | ty::ReClosureBound(..)\n             | ty::ReScope(..)\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)"}, {"sha": "7dfcf0a637eb30142232022b40f3b28b1cd1531b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -450,7 +450,6 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n             | ty::ReVar(..)\n             | ty::RePlaceholder(..)\n             | ty::ReEmpty(_)\n-            | ty::ReClosureBound(_)\n             | ty::ReErased => {\n                 debug!(\"cannot clean region {:?}\", self);\n                 None"}, {"sha": "3a022230b39a782c3eff49a0844b8b47324ce2f5", "filename": "src/test/compile-fail/issue-52443.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-52443.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -7,10 +7,5 @@ fn main() {\n     //~^ ERROR `while` is not allowed in a `const`\n     //~| WARN denote infinite loops with\n     [(); { for _ in 0usize.. {}; 0}];\n-    //~^ ERROR calls in constants are limited to constant functions\n-    //~| ERROR calls in constants are limited to constant functions\n-    //~| ERROR `for` is not allowed in a `const`\n-    //~| ERROR references in constants may only refer to immutable values\n-    //~| ERROR evaluation of constant value failed\n-    //~| ERROR constant contains unimplemented expression type\n+    //~^ ERROR `for` is not allowed in a `const`\n }"}, {"sha": "821e6b99f7b8fe8f2b49b4da8662ccc63c28f506", "filename": "src/test/rustdoc-ui/deny-missing-docs-crate.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdeny-missing-docs-crate.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,4 +1,4 @@\n-error: missing documentation for crate\n+error: missing documentation for the crate\n   --> $DIR/deny-missing-docs-crate.rs:1:1\n    |\n LL | / #![deny(missing_docs)]"}, {"sha": "f6d0e9e04d3212472f07cf9eeae7f9a49fae6144", "filename": "src/test/ui/borrowck/issue-69789-iterator-mut-suggestion.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fborrowck%2Fissue-69789-iterator-mut-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fborrowck%2Fissue-69789-iterator-mut-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-69789-iterator-mut-suggestion.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -0,0 +1,11 @@\n+// Regression test for #69789: rustc generated an invalid suggestion\n+// when `&` reference from `&mut` iterator is mutated.\n+\n+fn main() {\n+    for item in &mut std::iter::empty::<&'static ()>() {\n+        //~^ NOTE this iterator yields `&` references\n+        *item = ();\n+        //~^ ERROR cannot assign\n+        //~| NOTE  cannot be written\n+    }\n+}"}, {"sha": "d2865ffd196a50f67d4dd910c772982a975504a2", "filename": "src/test/ui/borrowck/issue-69789-iterator-mut-suggestion.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fborrowck%2Fissue-69789-iterator-mut-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fborrowck%2Fissue-69789-iterator-mut-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-69789-iterator-mut-suggestion.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -0,0 +1,12 @@\n+error[E0594]: cannot assign to `*item` which is behind a `&` reference\n+  --> $DIR/issue-69789-iterator-mut-suggestion.rs:7:9\n+   |\n+LL |     for item in &mut std::iter::empty::<&'static ()>() {\n+   |                 -------------------------------------- this iterator yields `&` references\n+LL |\n+LL |         *item = ();\n+   |         ^^^^^^^^^^ `item` is a `&` reference, so the data it refers to cannot be written\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "634638e1335b327576797cf90a7a99f672d203f6", "filename": "src/test/ui/closures/issue-52437.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -3,4 +3,5 @@ fn main() {\n     //~^ ERROR: invalid label name `'static`\n     //~| ERROR: `loop` is not allowed in a `const`\n     //~| ERROR: type annotations needed\n+    //~| ERROR mismatched types\n }"}, {"sha": "acb59c7b02d1b584c0da3fa2acfed9e95913c3ea", "filename": "src/test/ui/closures/issue-52437.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2Fissue-52437.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -19,7 +19,15 @@ error[E0282]: type annotations needed\n LL |     [(); &(&'static: loop { |x| {}; }) as *const _ as usize]\n    |                              ^ consider giving this closure parameter a type\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-52437.rs:2:5\n+   |\n+LL | fn main() {\n+   |           - expected `()` because of default return type\n+LL |     [(); &(&'static: loop { |x| {}; }) as *const _ as usize]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found array `[(); _]`\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0282, E0658.\n+Some errors have detailed explanations: E0282, E0308, E0658.\n For more information about an error, try `rustc --explain E0282`."}, {"sha": "165d3e1c2e60169af4f1b669ae0c63a6646005f4", "filename": "src/test/ui/const-generics/issues/issue-61336-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,9 +1,10 @@\n #![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n+// build-pass\n+\n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; N]\n-    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn main() {"}, {"sha": "d48d8ff689462b330d554f55734754998b1b903d", "filename": "src/test/ui/const-generics/issues/issue-61336-1.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-1.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -6,11 +6,3 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-61336-1.rs:5:9\n-   |\n-LL |     [x; N]\n-   |         ^\n-\n-error: aborting due to previous error\n-"}, {"sha": "c5bf6b6ce94a8a4ae4ab532663bb070c94bf494e", "filename": "src/test/ui/const-generics/issues/issue-61336-2.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -2,13 +2,12 @@\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n-    [x; {N}]\n-    //~^ ERROR array lengths can't depend on generic parameters\n+    [x; { N }]\n }\n \n fn g<T, const N: usize>(x: T) -> [T; N] {\n-    [x; {N}]\n-    //~^ ERROR array lengths can't depend on generic parameters\n+    [x; { N }]\n+    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied\n }\n \n fn main() {"}, {"sha": "9ced427b93c6589046893e785b9887ef8639d2ca", "filename": "src/test/ui/const-generics/issues/issue-61336-2.stderr", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336-2.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -6,17 +6,19 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-61336-2.rs:5:9\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-61336-2.rs:9:5\n    |\n-LL |     [x; {N}]\n-   |         ^^^\n-\n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-61336-2.rs:10:9\n+LL |     [x; { N }]\n+   |     ^^^^^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n+   |\n+help: consider restricting this type parameter with `T: std::marker::Copy`\n+  --> $DIR/issue-61336-2.rs:8:6\n    |\n-LL |     [x; {N}]\n-   |         ^^^\n+LL | fn g<T, const N: usize>(x: T) -> [T; N] {\n+   |      ^\n+   = note: the `Copy` trait is required because the repeated element will be copied\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7e84e62d8be421f9e33f44b4b8a7af1407a616b4", "filename": "src/test/ui/const-generics/issues/issue-61336.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -3,12 +3,11 @@\n \n fn f<T: Copy, const N: usize>(x: T) -> [T; N] {\n     [x; N]\n-    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn g<T, const N: usize>(x: T) -> [T; N] {\n     [x; N]\n-    //~^ ERROR array lengths can't depend on generic parameters\n+    //~^ ERROR the trait bound `T: std::marker::Copy` is not satisfied\n }\n \n fn main() {"}, {"sha": "ace7955fbdd77ffd1b0d9f24940a65e767152e9f", "filename": "src/test/ui/const-generics/issues/issue-61336.stderr", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-61336.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -6,17 +6,19 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-61336.rs:5:9\n+error[E0277]: the trait bound `T: std::marker::Copy` is not satisfied\n+  --> $DIR/issue-61336.rs:9:5\n    |\n LL |     [x; N]\n-   |         ^\n-\n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-61336.rs:10:9\n+   |     ^^^^^^ the trait `std::marker::Copy` is not implemented for `T`\n    |\n-LL |     [x; N]\n-   |         ^\n+help: consider restricting this type parameter with `T: std::marker::Copy`\n+  --> $DIR/issue-61336.rs:8:6\n+   |\n+LL | fn g<T, const N: usize>(x: T) -> [T; N] {\n+   |      ^\n+   = note: the `Copy` trait is required because the repeated element will be copied\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "14b1190df0f995caf09f4d72513d15ef56484d93", "filename": "src/test/ui/const-generics/issues/issue-62456.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,9 +1,10 @@\n #![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n+// build-pass\n+\n fn foo<const N: usize>() {\n     let _ = [0u64; N + 1];\n-    //~^ ERROR array lengths can't depend on generic parameters\n }\n \n fn main() {}"}, {"sha": "47dd3c01fa9e003f57c36b1e4c9d132fe75aaf59", "filename": "src/test/ui/const-generics/issues/issue-62456.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62456.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -6,11 +6,3 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-62456.rs:5:20\n-   |\n-LL |     let _ = [0u64; N + 1];\n-   |                    ^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "cd3cfaac3b95b81f8ad2fdb22f160718dc26574b", "filename": "src/test/ui/const-generics/issues/issue-62504.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -16,7 +16,7 @@ struct ArrayHolder<const X: usize>([u32; X]);\n impl<const X: usize> ArrayHolder<{ X }> {\n     pub const fn new() -> Self {\n         ArrayHolder([0; Self::SIZE])\n-        //~^ ERROR: array lengths can't depend on generic parameters\n+        //~^ ERROR: mismatched types\n     }\n }\n "}, {"sha": "4482389bbdd4954c88abca5ff4774f3050247f88", "filename": "src/test/ui/const-generics/issues/issue-62504.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,8 +1,12 @@\n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-62504.rs:18:25\n+error[E0308]: mismatched types\n+  --> $DIR/issue-62504.rs:18:21\n    |\n LL |         ArrayHolder([0; Self::SIZE])\n-   |                         ^^^^^^^^^^\n+   |                     ^^^^^^^^^^^^^^^ expected `X`, found `Self::SIZE`\n+   |\n+   = note: expected array `[u32; _]`\n+              found array `[u32; _]`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3d657b0947b18f28a0eab91ec3d6f3bdefbd48ba", "filename": "src/test/ui/const-generics/issues/issue-67739.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,5 +1,7 @@\n // Regression test for #67739\n \n+// check-pass\n+\n #![allow(incomplete_features)]\n #![feature(const_generics)]\n \n@@ -10,7 +12,6 @@ pub trait Trait {\n \n     fn associated_size(&self) -> usize {\n         [0u8; mem::size_of::<Self::Associated>()];\n-        //~^ ERROR: array lengths can't depend on generic parameters\n         0\n     }\n }"}, {"sha": "a31b556c086f8301a3f476670300907c2fe608df", "filename": "src/test/ui/const-generics/issues/issue-67739.stderr", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c55c682e9ba2be16d5de4264d1b626e70f00de9d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c55c682e9ba2be16d5de4264d1b626e70f00de9d/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-67739.stderr?ref=c55c682e9ba2be16d5de4264d1b626e70f00de9d", "patch": "@@ -1,8 +0,0 @@\n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-67739.rs:12:15\n-   |\n-LL |         [0u8; mem::size_of::<Self::Associated>()];\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-"}, {"sha": "6d56fe0d7b8e3b150c24c71b0ddd1d6ecdcc477a", "filename": "src/test/ui/const-generics/std/const-generics-range.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fstd%2Fconst-generics-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconst-generics%2Fstd%2Fconst-generics-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fstd%2Fconst-generics-range.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -0,0 +1,30 @@\n+// check-pass\n+#![allow(incomplete_features)]\n+#![feature(const_generics)]\n+\n+// `Range` should be usable within const generics:\n+struct _Range<const R: std::ops::Range<usize>>;\n+const RANGE : _Range<{ 0 .. 1000 }> = _Range;\n+\n+// `RangeFrom` should be usable within const generics:\n+struct _RangeFrom<const R: std::ops::RangeFrom<usize>>;\n+const RANGE_FROM : _RangeFrom<{ 0 .. }> = _RangeFrom;\n+\n+// `RangeFull` should be usable within const generics:\n+struct _RangeFull<const R: std::ops::RangeFull>;\n+const RANGE_FULL : _RangeFull<{ .. }> = _RangeFull;\n+\n+// Regression test for #70155\n+// `RangeInclusive` should be usable within const generics:\n+struct _RangeInclusive<const R: std::ops::RangeInclusive<usize>>;\n+const RANGE_INCLUSIVE : _RangeInclusive<{ 0 ..= 999 }> = _RangeInclusive;\n+\n+// `RangeTo` should be usable within const generics:\n+struct _RangeTo<const R: std::ops::RangeTo<usize>>;\n+const RANGE_TO : _RangeTo<{ .. 1000 }> = _RangeTo;\n+\n+// `RangeToInclusive` should be usable within const generics:\n+struct _RangeToInclusive<const R: std::ops::RangeToInclusive<usize>>;\n+const RANGE_TO_INCLUSIVE : _RangeToInclusive<{ ..= 999 }> = _RangeToInclusive;\n+\n+pub fn main() {}"}, {"sha": "3ae55ebdbaf357c211dcced4d6658820afef99da", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -19,6 +19,7 @@ const A_I8_I\n     : [u32; (i8::MAX as usize) + 1]\n     = [0; (i8::MAX + 1) as usize];\n //~^ ERROR evaluation of constant value failed\n+//~| ERROR mismatched types\n \n fn main() {\n     foo(&A_I8_I[..]);"}, {"sha": "94b7c12fc1a8b138763a7d8602fe91eea7d2875b", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -4,6 +4,16 @@ error[E0080]: evaluation of constant value failed\n LL |     = [0; (i8::MAX + 1) as usize];\n    |           ^^^^^^^^^^^^^ attempt to add with overflow\n \n-error: aborting due to previous error\n+error[E0308]: mismatched types\n+  --> $DIR/const-eval-overflow-3.rs:20:7\n+   |\n+LL |     = [0; (i8::MAX + 1) as usize];\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `128usize`, found `(i8::MAX + 1) as usize`\n+   |\n+   = note: expected array `[u32; 128]`\n+              found array `[u32; _]`\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0080`.\n+Some errors have detailed explanations: E0080, E0308.\n+For more information about an error, try `rustc --explain E0080`."}, {"sha": "e7b88e00febaa3a94230171974667ee02d6c2e5e", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3b.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -18,6 +18,7 @@ const A_I8_I\n     = [0; (i8::MAX + 1u8) as usize];\n //~^ ERROR mismatched types\n //~| ERROR cannot add `u8` to `i8`\n+//~| ERROR mismatched types\n \n fn main() {\n     foo(&A_I8_I[..]);"}, {"sha": "aebe4feef8d5f7931ff932b18c879d635e50bd2d", "filename": "src/test/ui/consts/const-eval/const-eval-overflow-3b.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fconst-eval-overflow-3b.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -12,7 +12,16 @@ LL |     = [0; (i8::MAX + 1u8) as usize];\n    |\n    = help: the trait `std::ops::Add<u8>` is not implemented for `i8`\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/const-eval-overflow-3b.rs:18:7\n+   |\n+LL |     = [0; (i8::MAX + 1u8) as usize];\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `128usize`, found `(i8::MAX + 1u8) as usize`\n+   |\n+   = note: expected array `[u32; 128]`\n+              found array `[u32; _]`\n+\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0277, E0308.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "c8de259354eac03f0d79f73d45b5a4a2bbe79238", "filename": "src/test/ui/consts/const-eval/infinite_loop.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -2,7 +2,6 @@ fn main() {\n     // Tests the Collatz conjecture with an incorrect base case (0 instead of 1).\n     // The value of `n` will loop indefinitely (4 - 2 - 1 - 4).\n     let _ = [(); {\n-        //~^ WARNING Constant evaluating a complex constant, this might take some time\n         let mut n = 113383; // #20 in https://oeis.org/A006884\n         while n != 0 {\n         //~^ ERROR `while` is not allowed in a `const`"}, {"sha": "ebdb73c44679150fd2299e20740fba318d9f62d8", "filename": "src/test/ui/consts/const-eval/infinite_loop.stderr", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Finfinite_loop.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: `while` is not allowed in a `const`\n-  --> $DIR/infinite_loop.rs:7:9\n+  --> $DIR/infinite_loop.rs:6:9\n    |\n LL | /         while n != 0 {\n LL | |\n@@ -14,32 +14,19 @@ LL | |         }\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n error[E0658]: `if` is not allowed in a `const`\n-  --> $DIR/infinite_loop.rs:9:17\n+  --> $DIR/infinite_loop.rs:8:17\n    |\n LL |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #49146 <https://github.com/rust-lang/rust/issues/49146> for more information\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n-warning: Constant evaluating a complex constant, this might take some time\n-  --> $DIR/infinite_loop.rs:4:18\n-   |\n-LL |       let _ = [(); {\n-   |  __________________^\n-LL | |\n-LL | |         let mut n = 113383; // #20 in https://oeis.org/A006884\n-LL | |         while n != 0 {\n-...  |\n-LL | |         n\n-LL | |     }];\n-   | |_____^\n-\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/infinite_loop.rs:9:20\n+  --> $DIR/infinite_loop.rs:8:20\n    |\n LL |             n = if n % 2 == 0 { n/2 } else { 3*n + 1 };\n-   |                    ^^^^^^^^^^ duplicate interpreter state observed here, const evaluation will never terminate\n+   |                    ^^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n \n error: aborting due to 3 previous errors\n "}, {"sha": "df4cc8e3026778177bb0098fdad8c05a4d9a4098", "filename": "src/test/ui/consts/const-eval/issue-52442.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,6 +1,4 @@\n fn main() {\n     [();  { &loop { break } as *const _ as usize } ];\n-    //~^ ERROR casting pointers to integers in constants is unstable\n-    //~| ERROR `loop` is not allowed in a `const`\n-    //~| ERROR evaluation of constant value failed\n+    //~^ ERROR `loop` is not allowed in a `const`\n }"}, {"sha": "0ea974f1f66662e85aaafbbf8347ae493cced1fb", "filename": "src/test/ui/consts/const-eval/issue-52442.stderr", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52442.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -7,22 +7,6 @@ LL |     [();  { &loop { break } as *const _ as usize } ];\n    = note: see issue #52000 <https://github.com/rust-lang/rust/issues/52000> for more information\n    = help: add `#![feature(const_loop)]` to the crate attributes to enable\n \n-error[E0658]: casting pointers to integers in constants is unstable\n-  --> $DIR/issue-52442.rs:2:13\n-   |\n-LL |     [();  { &loop { break } as *const _ as usize } ];\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #51910 <https://github.com/rust-lang/rust/issues/51910> for more information\n-   = help: add `#![feature(const_raw_ptr_to_usize_cast)]` to the crate attributes to enable\n-\n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-52442.rs:2:13\n-   |\n-LL |     [();  { &loop { break } as *const _ as usize } ];\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0080, E0658.\n-For more information about an error, try `rustc --explain E0080`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "869f0b981af7d881e4dce06fc6f4cd9fe531b727", "filename": "src/test/ui/consts/const-eval/issue-52475.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,6 +1,5 @@\n fn main() {\n     let _ = [(); {\n-        //~^ WARNING Constant evaluating a complex constant, this might take some time\n         let mut x = &0;\n         let mut n = 0;\n         while n < 5 {"}, {"sha": "b069537ead9637a63df6bf2bb80b8dcfe92a601e", "filename": "src/test/ui/consts/const-eval/issue-52475.stderr", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-52475.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: `while` is not allowed in a `const`\n-  --> $DIR/issue-52475.rs:6:9\n+  --> $DIR/issue-52475.rs:5:9\n    |\n LL | /         while n < 5 {\n LL | |\n@@ -12,24 +12,11 @@ LL | |         }\n    = help: add `#![feature(const_loop)]` to the crate attributes to enable\n    = help: add `#![feature(const_if_match)]` to the crate attributes to enable\n \n-warning: Constant evaluating a complex constant, this might take some time\n-  --> $DIR/issue-52475.rs:2:18\n-   |\n-LL |       let _ = [(); {\n-   |  __________________^\n-LL | |\n-LL | |         let mut x = &0;\n-LL | |         let mut n = 0;\n-...  |\n-LL | |         0\n-LL | |     }];\n-   | |_____^\n-\n error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-52475.rs:8:17\n+  --> $DIR/issue-52475.rs:7:17\n    |\n LL |             n = (n + 1) % 5;\n-   |                 ^^^^^^^^^^^ duplicate interpreter state observed here, const evaluation will never terminate\n+   |                 ^^^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5cfe36f57e6478e915b75934496aca77ab257d26", "filename": "src/test/ui/consts/const-eval/match-test-ptr-null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -2,7 +2,7 @@ fn main() {\n     // Make sure match uses the usual pointer comparison code path -- i.e., it should complain\n     // that pointer comparison is disallowed, not that parts of a pointer are accessed as raw\n     // bytes.\n-    let _: [u8; 0] = [4; {\n+    let _: [u8; 0] = [4; { //~ ERROR mismatched types\n         match &1 as *const i32 as usize {\n             //~^ ERROR casting pointers to integers in constants\n             //~| ERROR `match` is not allowed in a `const`"}, {"sha": "7c4da5e7d86cab11cf94175b6a0d0c1d2b00bab9", "filename": "src/test/ui/consts/const-eval/match-test-ptr-null.stderr", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fmatch-test-ptr-null.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -28,7 +28,30 @@ error[E0080]: evaluation of constant value failed\n LL |         match &1 as *const i32 as usize {\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/match-test-ptr-null.rs:5:22\n+   |\n+LL |       let _: [u8; 0] = [4; {\n+   |  ____________-------___^\n+   | |            |\n+   | |            expected due to this\n+LL | |         match &1 as *const i32 as usize {\n+LL | |\n+LL | |\n+...  |\n+LL | |         }\n+LL | |     }];\n+   | |______^ expected `0usize`, found `{\n+        match &1 as *const i32 as usize {\n+            0 => 42,\n+            n => n,\n+        }\n+    }`\n+   |\n+   = note: expected array `[u8; 0]`\n+              found array `[u8; _]`\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0080, E0658.\n+Some errors have detailed explanations: E0080, E0308, E0658.\n For more information about an error, try `rustc --explain E0080`."}, {"sha": "34abcdf08dae0e2cf6159f5a3af2e04ae2b8b79a", "filename": "src/test/ui/consts/const_limit/const_eval_limit_not_reached.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_not_reached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_not_reached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_not_reached.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,15 +1,21 @@\n // check-pass\n+\n #![feature(const_eval_limit)]\n-#![const_eval_limit=\"1000\"]\n+#![feature(const_loop, const_if_match)]\n \n-const CONSTANT: usize = limit();\n+// This needs to be higher than the number of loop iterations since each pass through the loop may\n+// hit more than one terminator.\n+#![const_eval_limit=\"4000\"]\n \n-fn main() {\n-    assert_eq!(CONSTANT, 1764);\n-}\n+const X: usize = {\n+    let mut x = 0;\n+    while x != 1000 {\n+        x += 1;\n+    }\n \n-const fn limit() -> usize {\n-    let x = 42;\n+    x\n+};\n \n-    x * 42\n+fn main() {\n+    assert_eq!(X, 1000);\n }"}, {"sha": "b45aca0b13e42f51a1f2f7299555cfdb76530cab", "filename": "src/test/ui/consts/const_limit/const_eval_limit_reached.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,21 +1,18 @@\n-// ignore-tidy-linelength\n-// only-x86_64\n-// check-pass\n-// NOTE: We always compile this test with -Copt-level=0 because higher opt-levels\n-//       optimize away the const function\n-// compile-flags:-Copt-level=0\n #![feature(const_eval_limit)]\n-#![const_eval_limit=\"2\"]\n+#![feature(const_loop, const_if_match)]\n \n-const CONSTANT: usize = limit();\n-//~^ WARNING Constant evaluating a complex constant, this might take some time\n+#![const_eval_limit=\"500\"]\n \n-fn main() {\n-    assert_eq!(CONSTANT, 1764);\n-}\n+const X: usize = {\n+    let mut x = 0;\n+    while x != 1000 {\n+        //~^ ERROR any use of this value will cause an error\n+        x += 1;\n+    }\n \n-const fn limit() -> usize { //~ WARNING Constant evaluating a complex constant, this might take some time\n-    let x = 42;\n+    x\n+};\n \n-    x * 42\n+fn main() {\n+    assert_eq!(X, 1000);\n }"}, {"sha": "be522dd6d5d5a53d942222f468201939fa5e7c29", "filename": "src/test/ui/consts/const_limit/const_eval_limit_reached.stderr", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_limit%2Fconst_eval_limit_reached.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,16 +1,17 @@\n-warning: Constant evaluating a complex constant, this might take some time\n-  --> $DIR/const_eval_limit_reached.rs:17:1\n+error: any use of this value will cause an error\n+  --> $DIR/const_eval_limit_reached.rs:8:11\n    |\n-LL | / const fn limit() -> usize {\n-LL | |     let x = 42;\n+LL | / const X: usize = {\n+LL | |     let mut x = 0;\n+LL | |     while x != 1000 {\n+   | |           ^^^^^^^^^ exceeded interpreter step limit (see `#[const_eval_limit]`)\n LL | |\n-LL | |     x * 42\n-LL | | }\n-   | |_^\n-\n-warning: Constant evaluating a complex constant, this might take some time\n-  --> $DIR/const_eval_limit_reached.rs:10:1\n+...  |\n+LL | |     x\n+LL | | };\n+   | |__-\n    |\n-LL | const CONSTANT: usize = limit();\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: aborting due to previous error\n "}, {"sha": "ded79458e637f12167d27608a15c1ea7e83d5ce0", "filename": "src/test/ui/consts/issue-52432.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -6,5 +6,4 @@ fn main() {\n     //~| ERROR: type annotations needed\n     [(); &(static || {}) as *const _ as usize];\n     //~^ ERROR: closures cannot be static\n-    //~| ERROR: evaluation of constant value failed\n }"}, {"sha": "d25c11138f4003288adef7229b8792047d968f3e", "filename": "src/test/ui/consts/issue-52432.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-52432.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -16,13 +16,7 @@ error[E0282]: type annotations needed\n LL |     [(); &(static |x| {}) as *const _ as usize];\n    |                    ^ consider giving this closure parameter a type\n \n-error[E0080]: evaluation of constant value failed\n-  --> $DIR/issue-52432.rs:7:10\n-   |\n-LL |     [(); &(static || {}) as *const _ as usize];\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0080, E0282, E0697.\n-For more information about an error, try `rustc --explain E0080`.\n+Some errors have detailed explanations: E0282, E0697.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "f0d5fea8e023925e7b4f47cc6ea55cd0da2570e5", "filename": "src/test/ui/consts/issue-69310-array-size-lit-wrong-ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fissue-69310-array-size-lit-wrong-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Fissue-69310-array-size-lit-wrong-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-69310-array-size-lit-wrong-ty.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -3,7 +3,7 @@\n // we call the query `lit_to_const(input);`.\n // However, the literal `input.lit` would not be of the type expected by `input.ty`.\n // As a result, we immediately called `bug!(...)` instead of bubbling up the problem\n-// so that it could be handled by the caller of `lit_to_const` (`ast_const_to_const`).\n+// so that it could be handled by the caller of `lit_to_const` (`from_anon_const`).\n \n fn main() {}\n "}, {"sha": "7e4d4dbe44610a7f0a9d45d428f9cf1e850cac34", "filename": "src/test/ui/consts/too_generic_eval_ice.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -7,6 +7,7 @@ impl<A, B> Foo<A, B> {\n         [5; Self::HOST_SIZE] == [6; 0] //~ ERROR no associated item named `HOST_SIZE`\n         //~^ the size for values of type `A` cannot be known\n         //~| the size for values of type `B` cannot be known\n+        //~| binary operation `==` cannot be applied to type `[{integer}; _]`\n     }\n }\n "}, {"sha": "ffa28225b79c65ca7250af558a61e8ae118fcfd2", "filename": "src/test/ui/consts/too_generic_eval_ice.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Ftoo_generic_eval_ice.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -41,7 +41,15 @@ LL |         [5; Self::HOST_SIZE] == [6; 0]\n    = help: the trait `std::marker::Sized` is not implemented for `B`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n \n-error: aborting due to 3 previous errors\n+error[E0369]: binary operation `==` cannot be applied to type `[{integer}; _]`\n+  --> $DIR/too_generic_eval_ice.rs:7:30\n+   |\n+LL |         [5; Self::HOST_SIZE] == [6; 0]\n+   |         -------------------- ^^ ------ [{integer}; 0]\n+   |         |\n+   |         [{integer}; _]\n+\n+error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0277, E0599.\n+Some errors have detailed explanations: E0277, E0369, E0599.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "e66b432ede20c5b00399a399f04e104d0313c7ae", "filename": "src/test/ui/did_you_mean/bad-assoc-ty.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -49,4 +49,36 @@ trait K<A, B> {}\n fn foo<X: K<_, _>>(x: X) {}\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n \n+fn bar<F>(_: F) where F: Fn() -> _ {}\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+\n+fn baz<F: Fn() -> _>(_: F) {}\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+\n+struct L<F>(F) where F: Fn() -> _;\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+struct M<F> where F: Fn() -> _ {\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    a: F,\n+}\n+enum N<F> where F: Fn() -> _ {\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    Foo(F),\n+}\n+\n+union O<F> where F: Fn() -> _ {\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+//~| ERROR unions with non-`Copy` fields are unstable\n+    foo: F,\n+}\n+\n+trait P<F> where F: Fn() -> _ {\n+//~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+}\n+\n+trait Q {\n+    fn foo<F>(_: F) where F: Fn() -> _ {}\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+}\n+\n fn main() {}"}, {"sha": "875c02bae4ae01ac71a859ce5644b9a71bb35349", "filename": "src/test/ui/did_you_mean/bad-assoc-ty.stderr", "status": "modified", "additions": 108, "deletions": 2, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fbad-assoc-ty.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -57,6 +57,19 @@ LL | type J = ty!(u8);\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+error[E0658]: unions with non-`Copy` fields are unstable\n+  --> $DIR/bad-assoc-ty.rs:69:1\n+   |\n+LL | / union O<F> where F: Fn() -> _ {\n+LL | |\n+LL | |\n+LL | |     foo: F,\n+LL | | }\n+   | |_^\n+   |\n+   = note: see issue #55149 <https://github.com/rust-lang/rust/issues/55149> for more information\n+   = help: add `#![feature(untagged_unions)]` to the crate attributes to enable\n+\n error[E0223]: ambiguous associated type\n   --> $DIR/bad-assoc-ty.rs:1:10\n    |\n@@ -129,8 +142,101 @@ LL | fn foo<X: K<_, _>>(x: X) {}\n    |             ^  ^ not allowed in type signatures\n    |             |\n    |             not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | fn foo<X, T: K<T, T>>(x: X) {}\n+   |         ^^^    ^  ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/bad-assoc-ty.rs:52:34\n+   |\n+LL | fn bar<F>(_: F) where F: Fn() -> _ {}\n+   |                                  ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | fn bar<F, T>(_: F) where F: Fn() -> T {}\n+   |         ^^^                         ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/bad-assoc-ty.rs:55:19\n+   |\n+LL | fn baz<F: Fn() -> _>(_: F) {}\n+   |                   ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | fn baz<F, T: Fn() -> T>(_: F) {}\n+   |         ^^^          ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/bad-assoc-ty.rs:58:33\n+   |\n+LL | struct L<F>(F) where F: Fn() -> _;\n+   |                                 ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | struct L<F, T>(F) where F: Fn() -> T;\n+   |           ^^^                      ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/bad-assoc-ty.rs:60:30\n+   |\n+LL | struct M<F> where F: Fn() -> _ {\n+   |                              ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | struct M<F, T> where F: Fn() -> T {\n+   |           ^^^                   ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/bad-assoc-ty.rs:64:28\n+   |\n+LL | enum N<F> where F: Fn() -> _ {\n+   |                            ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | enum N<F, T> where F: Fn() -> T {\n+   |         ^^^                   ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/bad-assoc-ty.rs:69:29\n+   |\n+LL | union O<F> where F: Fn() -> _ {\n+   |                             ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | union O<F, T> where F: Fn() -> T {\n+   |          ^^^                   ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/bad-assoc-ty.rs:75:29\n+   |\n+LL | trait P<F> where F: Fn() -> _ {\n+   |                             ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL | trait P<F, T> where F: Fn() -> T {\n+   |          ^^^                   ^\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/bad-assoc-ty.rs:80:38\n+   |\n+LL |     fn foo<F>(_: F) where F: Fn() -> _ {}\n+   |                                      ^ not allowed in type signatures\n+   |\n+help: use type parameters instead\n+   |\n+LL |     fn foo<F, T>(_: F) where F: Fn() -> T {}\n+   |             ^^^                         ^\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 29 previous errors\n \n-Some errors have detailed explanations: E0121, E0223.\n+Some errors have detailed explanations: E0121, E0223, E0658.\n For more information about an error, try `rustc --explain E0121`."}, {"sha": "250c4bc442f98b916adbe93e13f9e94330ad26f9", "filename": "src/test/ui/issues/issue-10656.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-10656.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-10656.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10656.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,3 +1,3 @@\n #![deny(missing_docs)]\n #![crate_type=\"lib\"]\n-//~^^ ERROR missing documentation for crate\n+//~^^ ERROR missing documentation for the crate"}, {"sha": "2e4365f1ed76b21c6ea64e8529a98c0873d76bd0", "filename": "src/test/ui/issues/issue-10656.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-10656.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-10656.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10656.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,4 +1,4 @@\n-error: missing documentation for crate\n+error: missing documentation for the crate\n   --> $DIR/issue-10656.rs:1:1\n    |\n LL | / #![deny(missing_docs)]"}, {"sha": "ec0275b2d6c1274f89d2506e8f264888af1ac3e5", "filename": "src/test/ui/issues/issue-39559-2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -17,4 +17,5 @@ fn main() {\n         = [0; Dim3::dim()];\n         //~^ ERROR E0015\n         //~| ERROR E0080\n+        //~| ERROR mismatched types\n }"}, {"sha": "7cbf63c2da0a96336162f1ea61b1e54f624f34fa", "filename": "src/test/ui/issues/issue-39559-2.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -22,7 +22,19 @@ error[E0080]: evaluation of constant value failed\n LL |         = [0; Dim3::dim()];\n    |               ^^^^^^^^^^^ calling non-const function `<Dim3 as Dim>::dim`\n \n-error: aborting due to 4 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-39559-2.rs:17:11\n+   |\n+LL |     let array: [usize; Dim3::dim()]\n+   |                -------------------- expected due to this\n+...\n+LL |         = [0; Dim3::dim()];\n+   |           ^^^^^^^^^^^^^^^^ expected `Dim3::dim()`, found `Dim3::dim()`\n+   |\n+   = note: expected array `[usize; _]`\n+              found array `[usize; _]`\n+\n+error: aborting due to 5 previous errors\n \n-Some errors have detailed explanations: E0015, E0080.\n+Some errors have detailed explanations: E0015, E0080, E0308.\n For more information about an error, try `rustc --explain E0015`."}, {"sha": "2688049fcc9ffa357d5c23a1efddc87e2668f600", "filename": "src/test/ui/issues/issue-52060.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-52060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-52060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52060.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -4,5 +4,6 @@ static A: &'static [u32] = &[1];\n static B: [u32; 1] = [0; A.len()];\n //~^ ERROR [E0013]\n //~| ERROR evaluation of constant value failed\n+//~| ERROR mismatched types\n \n fn main() {}"}, {"sha": "e076e183937f2539b016b1142151057094b38462", "filename": "src/test/ui/issues/issue-52060.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -12,7 +12,16 @@ error[E0080]: evaluation of constant value failed\n LL | static B: [u32; 1] = [0; A.len()];\n    |                          ^ constant accesses static\n \n-error: aborting due to 2 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-52060.rs:4:22\n+   |\n+LL | static B: [u32; 1] = [0; A.len()];\n+   |                      ^^^^^^^^^^^^ expected `1usize`, found `A.len()`\n+   |\n+   = note: expected array `[u32; 1]`\n+              found array `[u32; _]`\n+\n+error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0013, E0080.\n+Some errors have detailed explanations: E0013, E0080, E0308.\n For more information about an error, try `rustc --explain E0013`."}, {"sha": "2c5257ce063cb525897cd2c19a1b4380f1d0c37d", "filename": "src/test/ui/issues/issue-69602-type-err-during-codegen-ice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -19,5 +19,4 @@ impl TraitB for B { //~ ERROR not all trait items implemented, missing: `MyA`\n \n fn main() {\n     let _ = [0; B::VALUE];\n-    //~^ ERROR array lengths can't depend on generic parameters\n }"}, {"sha": "8ae0f8b804c93e822b6b5f97fa81105cb3215dcc", "filename": "src/test/ui/issues/issue-69602-type-err-during-codegen-ice.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69602-type-err-during-codegen-ice.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -13,13 +13,7 @@ LL |     type MyA: TraitA;\n LL | impl TraitB for B {\n    | ^^^^^^^^^^^^^^^^^ missing `MyA` in implementation\n \n-error: array lengths can't depend on generic parameters\n-  --> $DIR/issue-69602-type-err-during-codegen-ice.rs:21:17\n-   |\n-LL |     let _ = [0; B::VALUE];\n-   |                 ^^^^^^^^\n-\n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n Some errors have detailed explanations: E0046, E0437.\n For more information about an error, try `rustc --explain E0046`."}, {"sha": "99f91cc881617f53537a03cc8cbdc392fa0077ec", "filename": "src/test/ui/json-bom-plus-crlf-multifile.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf-multifile.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -13,10 +13,10 @@ let x: i32 = \\\"I am not a number!\\\";\n ```\n \n This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n+variable. It can happen in several cases, the most common being a mismatch\n+between the type that the compiler inferred for a variable based on its\n+initializing expression, on the one hand, and the type the author explicitly\n+assigned to the variable, on the other hand.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":612,\"byte_end\":618,\"line_start\":17,\"line_end\":17,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":621,\"byte_end\":622,\"line_start\":17,\"line_end\":17,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:17:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -34,10 +34,10 @@ let x: i32 = \\\"I am not a number!\\\";\n ```\n \n This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n+variable. It can happen in several cases, the most common being a mismatch\n+between the type that the compiler inferred for a variable based on its\n+initializing expression, on the one hand, and the type the author explicitly\n+assigned to the variable, on the other hand.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":672,\"byte_end\":678,\"line_start\":19,\"line_end\":19,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":681,\"byte_end\":682,\"line_start\":19,\"line_end\":19,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:19:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -55,10 +55,10 @@ let x: i32 = \\\"I am not a number!\\\";\n ```\n \n This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n+variable. It can happen in several cases, the most common being a mismatch\n+between the type that the compiler inferred for a variable based on its\n+initializing expression, on the one hand, and the type the author explicitly\n+assigned to the variable, on the other hand.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":735,\"byte_end\":741,\"line_start\":22,\"line_end\":22,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String =\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":745,\"byte_end\":746,\"line_start\":23,\"line_end\":23,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:23:1: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -76,10 +76,10 @@ let x: i32 = \\\"I am not a number!\\\";\n ```\n \n This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n+variable. It can happen in several cases, the most common being a mismatch\n+between the type that the compiler inferred for a variable based on its\n+initializing expression, on the one hand, and the type the author explicitly\n+assigned to the variable, on the other hand.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":801,\"byte_end\":809,\"line_start\":25,\"line_end\":26,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found `()`\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs\",\"byte_start\":792,\"byte_end\":798,\"line_start\":25,\"line_end\":25,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"$DIR/json-bom-plus-crlf-multifile-aux.rs:25:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors"}, {"sha": "3e84f5ef54d2c14e7ecb0223fc04cdd809a1cb61", "filename": "src/test/ui/json-bom-plus-crlf.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-bom-plus-crlf.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -13,10 +13,10 @@ let x: i32 = \\\"I am not a number!\\\";\n ```\n \n This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n+variable. It can happen in several cases, the most common being a mismatch\n+between the type that the compiler inferred for a variable based on its\n+initializing expression, on the one hand, and the type the author explicitly\n+assigned to the variable, on the other hand.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":606,\"byte_end\":607,\"line_start\":16,\"line_end\":16,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":597,\"byte_end\":603,\"line_start\":16,\"line_end\":16,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":606,\"byte_end\":607,\"line_start\":16,\"line_end\":16,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1;  // Error in the middle of line.\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:16:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -34,10 +34,10 @@ let x: i32 = \\\"I am not a number!\\\";\n ```\n \n This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n+variable. It can happen in several cases, the most common being a mismatch\n+between the type that the compiler inferred for a variable based on its\n+initializing expression, on the one hand, and the type the author explicitly\n+assigned to the variable, on the other hand.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":666,\"byte_end\":667,\"line_start\":18,\"line_end\":18,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":657,\"byte_end\":663,\"line_start\":18,\"line_end\":18,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":666,\"byte_end\":667,\"line_start\":18,\"line_end\":18,\"column_start\":22,\"column_end\":23,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = 1\",\"highlight_start\":22,\"highlight_end\":23}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:18:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -55,10 +55,10 @@ let x: i32 = \\\"I am not a number!\\\";\n ```\n \n This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n+variable. It can happen in several cases, the most common being a mismatch\n+between the type that the compiler inferred for a variable based on its\n+initializing expression, on the one hand, and the type the author explicitly\n+assigned to the variable, on the other hand.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":730,\"byte_end\":731,\"line_start\":22,\"line_end\":22,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":\"expected struct `std::string::String`, found integer\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":720,\"byte_end\":726,\"line_start\":21,\"line_end\":21,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String =\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[{\"message\":\"try using a conversion method\",\"code\":null,\"level\":\"help\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":730,\"byte_end\":731,\"line_start\":22,\"line_end\":22,\"column_start\":1,\"column_end\":2,\"is_primary\":true,\"text\":[{\"text\":\"1;  // Error after the newline.\",\"highlight_start\":1,\"highlight_end\":2}],\"label\":null,\"suggested_replacement\":\"1.to_string()\",\"suggestion_applicability\":\"MaybeIncorrect\",\"expansion\":null}],\"children\":[],\"rendered\":null}],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:22:1: error[E0308]: mismatched types\n \"}\n {\"message\":\"mismatched types\",\"code\":{\"code\":\"E0308\",\"explanation\":\"Expected type did not match the received type.\n@@ -76,10 +76,10 @@ let x: i32 = \\\"I am not a number!\\\";\n ```\n \n This error occurs when the compiler was unable to infer the concrete type of a\n-variable. It can occur for several cases, the most common of which is a\n-mismatch in the expected type that the compiler inferred for a variable's\n-initializing expression, and the actual type explicitly assigned to the\n-variable.\n+variable. It can happen in several cases, the most common being a mismatch\n+between the type that the compiler inferred for a variable based on its\n+initializing expression, on the one hand, and the type the author explicitly\n+assigned to the variable, on the other hand.\n \"},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":786,\"byte_end\":794,\"line_start\":24,\"line_end\":25,\"column_start\":22,\"column_end\":6,\"is_primary\":true,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":22,\"highlight_end\":23},{\"text\":\"    );  // Error spanning the newline.\",\"highlight_start\":1,\"highlight_end\":6}],\"label\":\"expected struct `std::string::String`, found `()`\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null},{\"file_name\":\"$DIR/json-bom-plus-crlf.rs\",\"byte_start\":777,\"byte_end\":783,\"line_start\":24,\"line_end\":24,\"column_start\":13,\"column_end\":19,\"is_primary\":false,\"text\":[{\"text\":\"    let s : String = (\",\"highlight_start\":13,\"highlight_end\":19}],\"label\":\"expected due to this\",\"suggested_replacement\":null,\"suggestion_applicability\":null,\"expansion\":null}],\"children\":[],\"rendered\":\"$DIR/json-bom-plus-crlf.rs:24:22: error[E0308]: mismatched types\n \"}\n {\"message\":\"aborting due to 4 previous errors\",\"code\":null,\"level\":\"error\",\"spans\":[],\"children\":[],\"rendered\":\"error: aborting due to 4 previous errors"}, {"sha": "bab6f4e9e5e155835c5ed232f2ac4de8799cbab4", "filename": "src/test/ui/lint/lint-missing-doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -50,8 +50,8 @@ trait B {\n }\n \n pub trait C { //~ ERROR: missing documentation for a trait\n-    fn foo(&self); //~ ERROR: missing documentation for a trait method\n-    fn foo_with_impl(&self) {} //~ ERROR: missing documentation for a trait method\n+    fn foo(&self); //~ ERROR: missing documentation for an associated function\n+    fn foo_with_impl(&self) {} //~ ERROR: missing documentation for an associated function\n }\n \n #[allow(missing_docs)]\n@@ -78,7 +78,7 @@ impl Foo {\n }\n \n impl PubFoo {\n-    pub fn foo() {} //~ ERROR: missing documentation for a method\n+    pub fn foo() {} //~ ERROR: missing documentation for an associated function\n     /// dox\n     pub fn foo1() {}\n     fn foo2() {}"}, {"sha": "21da4fae4c161246f6a0ec7446eb27f84b8f43cc", "filename": "src/test/ui/lint/lint-missing-doc.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -40,13 +40,13 @@ error: missing documentation for a trait\n LL | pub trait C {\n    | ^^^^^^^^^^^\n \n-error: missing documentation for a trait method\n+error: missing documentation for an associated function\n   --> $DIR/lint-missing-doc.rs:53:5\n    |\n LL |     fn foo(&self);\n    |     ^^^^^^^^^^^^^^\n \n-error: missing documentation for a trait method\n+error: missing documentation for an associated function\n   --> $DIR/lint-missing-doc.rs:54:5\n    |\n LL |     fn foo_with_impl(&self) {}\n@@ -64,7 +64,7 @@ error: missing documentation for an associated type\n LL |     type AssociatedTypeDef = Self;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: missing documentation for a method\n+error: missing documentation for an associated function\n   --> $DIR/lint-missing-doc.rs:81:5\n    |\n LL |     pub fn foo() {}"}, {"sha": "1e8b6788a60bb4663370cd5751c444e576f29b2a", "filename": "src/test/ui/lint/lints-in-foreign-macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Flint%2Flints-in-foreign-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Flint%2Flints-in-foreign-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flints-in-foreign-macros.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -1,7 +1,7 @@\n // aux-build:lints-in-foreign-macros.rs\n // check-pass\n \n-#![warn(unused_imports)] //~ missing documentation for crate [missing_docs]\n+#![warn(unused_imports)] //~ missing documentation for the crate [missing_docs]\n #![warn(missing_docs)]\n \n #[macro_use]"}, {"sha": "dcea5adb863f664c69ca25c1876619e6dd664b37", "filename": "src/test/ui/lint/lints-in-foreign-macros.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Flint%2Flints-in-foreign-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Flint%2Flints-in-foreign-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flints-in-foreign-macros.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -26,7 +26,7 @@ warning: unused import: `std::string::ToString`\n LL | mod d { baz2!(use std::string::ToString;); }\n    |                   ^^^^^^^^^^^^^^^^^^^^^\n \n-warning: missing documentation for crate\n+warning: missing documentation for the crate\n   --> $DIR/lints-in-foreign-macros.rs:4:1\n    |\n LL | / #![warn(unused_imports)]"}, {"sha": "d551ccf9cf6696522e71882e67be5b341dc20372", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -111,7 +111,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 4\n-   = note: where <T as Anything<ReClosureBound('_#2r)>>::AssocType: '_#3r\n+   = note: where <T as Anything<ReEarlyBound(1, 'b)>>::AssocType: '_#3r\n \n note: no external requirements\n   --> $DIR/projection-one-region-closure.rs:62:1"}, {"sha": "3e17de1bf0f56060596590baaa8c955371060700", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -93,7 +93,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 4\n-   = note: where <T as Anything<ReClosureBound('_#2r)>>::AssocType: '_#3r\n+   = note: where <T as Anything<ReEarlyBound(1, 'b)>>::AssocType: '_#3r\n \n note: no external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:52:1"}, {"sha": "e354f1b5f7e6380a6ae9d1bbf551d71a7a8f689f", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -11,7 +11,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n            ]\n    = note: late-bound region is '_#4r\n    = note: number of external vids: 5\n-   = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n+   = note: where <T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(1, 'c)>>::AssocType: '_#3r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:34:1\n@@ -27,13 +27,13 @@ LL | | }\n    |\n    = note: defining type: no_relationships_late::<'_#1r, '_#2r, T>\n \n-error[E0309]: the associated type `<T as Anything<'_#5r, '_#6r>>::AssocType` may not live long enough\n+error[E0309]: the associated type `<T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(1, 'c)>>::AssocType` may not live long enough\n   --> $DIR/projection-two-region-trait-bound-closure.rs:38:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: consider adding an explicit lifetime bound `<T as Anything<'_#5r, '_#6r>>::AssocType: 'a`...\n+   = help: consider adding an explicit lifetime bound `<T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(1, 'c)>>::AssocType: 'a`...\n \n note: external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:48:29\n@@ -47,7 +47,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 5\n-   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+   = note: where <T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: '_#4r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:43:1\n@@ -63,13 +63,13 @@ LL | | }\n    |\n    = note: defining type: no_relationships_early::<'_#1r, '_#2r, '_#3r, T>\n \n-error[E0309]: the associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n+error[E0309]: the associated type `<T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType` may not live long enough\n   --> $DIR/projection-two-region-trait-bound-closure.rs:48:29\n    |\n LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: consider adding an explicit lifetime bound `<T as Anything<'_#6r, '_#7r>>::AssocType: 'a`...\n+   = help: consider adding an explicit lifetime bound `<T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: 'a`...\n \n note: external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:61:29\n@@ -83,7 +83,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 5\n-   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+   = note: where <T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: '_#4r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:53:1\n@@ -111,7 +111,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 5\n-   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+   = note: where <T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: '_#4r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:65:1\n@@ -139,7 +139,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 5\n-   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n+   = note: where <T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(2, 'c)>>::AssocType: '_#4r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:74:1\n@@ -168,7 +168,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n            ]\n    = note: late-bound region is '_#3r\n    = note: number of external vids: 4\n-   = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n+   = note: where <T as Anything<ReEarlyBound(0, 'b), ReEarlyBound(0, 'b)>>::AssocType: '_#2r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:83:1\n@@ -209,7 +209,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 4\n-   = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n+   = note: where <T as Anything<ReEarlyBound(1, 'b), ReEarlyBound(1, 'b)>>::AssocType: '_#3r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:92:1\n@@ -237,7 +237,7 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n                (),\n            ]\n    = note: number of external vids: 3\n-   = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n+   = note: where <T as Anything<ReEarlyBound(0, 'a), ReEarlyBound(0, 'a)>>::AssocType: '_#2r\n \n note: no external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:101:1"}, {"sha": "b306849ac8e5eba746ce1b4cbb9d4402cde57b7d", "filename": "src/test/ui/privacy/private-in-public-non-principal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -10,7 +10,7 @@ pub fn leak_dyn_nonprincipal() -> Box<dyn PubPrincipal + PrivNonPrincipal> { loo\n #[deny(missing_docs)]\n fn container() {\n     impl dyn PubPrincipal {\n-        pub fn check_doc_lint() {} //~ ERROR missing documentation for a method\n+        pub fn check_doc_lint() {} //~ ERROR missing documentation for an associated function\n     }\n     impl dyn PubPrincipal + PrivNonPrincipal {\n         pub fn check_doc_lint() {} // OK, no missing doc lint"}, {"sha": "778c98671ad4d423e86926ef541fc2b8f8d6659a", "filename": "src/test/ui/privacy/private-in-public-non-principal.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -8,7 +8,7 @@ LL | pub fn leak_dyn_nonprincipal() -> Box<dyn PubPrincipal + PrivNonPrincipal>\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n-error: missing documentation for a method\n+error: missing documentation for an associated function\n   --> $DIR/private-in-public-non-principal.rs:13:9\n    |\n LL |         pub fn check_doc_lint() {}"}, {"sha": "4a2d1d9f921cb97985e5d5c348bff30253696799", "filename": "src/test/ui/repeat_count.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Frepeat_count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Frepeat_count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepeat_count.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -28,6 +28,12 @@ error[E0308]: mismatched types\n LL |     let e = [0; \"foo\"];\n    |                 ^^^^^ expected `usize`, found `&str`\n \n+error[E0308]: mismatched types\n+  --> $DIR/repeat_count.rs:28:17\n+   |\n+LL |     let g = [0; G { g: () }];\n+   |                 ^^^^^^^^^^^ expected `usize`, found struct `main::G`\n+\n error[E0308]: mismatched types\n   --> $DIR/repeat_count.rs:19:17\n    |\n@@ -50,12 +56,6 @@ help: you can convert an `isize` to `usize` and panic if the converted value wou\n LL |     let f = [0_usize; (-1_isize).try_into().unwrap()];\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0308]: mismatched types\n-  --> $DIR/repeat_count.rs:28:17\n-   |\n-LL |     let g = [0; G { g: () }];\n-   |                 ^^^^^^^^^^^ expected `usize`, found struct `main::G`\n-\n error: aborting due to 8 previous errors\n \n Some errors have detailed explanations: E0308, E0435."}, {"sha": "708d72a2df756e1681429cf66c23d2cae9315de1", "filename": "src/test/ui/resolve/issue-65035-static-with-parent-generics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -24,6 +24,7 @@ fn i<const N: usize>() {\n     static a: [u8; N] = [0; N];\n     //~^ ERROR can't use generic parameters from outer function\n     //~^^ ERROR can't use generic parameters from outer function\n+    //~| ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "97c60c72298372cc250e4fa0721c84a7f6e496cd", "filename": "src/test/ui/resolve/issue-65035-static-with-parent-generics.stderr", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-65035-static-with-parent-generics.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -48,6 +48,16 @@ LL | #![feature(const_generics)]\n    |\n    = note: `#[warn(incomplete_features)]` on by default\n \n-error: aborting due to 5 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/issue-65035-static-with-parent-generics.rs:24:25\n+   |\n+LL |     static a: [u8; N] = [0; N];\n+   |                         ^^^^^^ expected `N`, found `N`\n+   |\n+   = note: expected array `[u8; _]`\n+              found array `[u8; _]`\n+\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0401`.\n+Some errors have detailed explanations: E0308, E0401.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "5444fc62d82118c5779d4abd37ff70562663773e", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -158,12 +158,9 @@ trait BadTrait<_> {}\n //~^ ERROR expected identifier, found reserved identifier `_`\n impl BadTrait<_> for BadStruct<_> {}\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n-//~| ERROR the type placeholder `_` is not allowed within types on item signatures\n-//~| ERROR the type placeholder `_` is not allowed within types on item signatures\n \n fn impl_trait() -> impl BadTrait<_> {\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n-//~| ERROR the type placeholder `_` is not allowed within types on item signatures\n     unimplemented!()\n }\n \n@@ -178,14 +175,12 @@ struct BadStruct2<_, T>(_, T);\n \n type X = Box<_>;\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n-//~| ERROR the type placeholder `_` is not allowed within types on item signatures\n \n struct Struct;\n trait Trait<T> {}\n impl Trait<usize> for Struct {}\n type Y = impl Trait<_>;\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n-//~| ERROR the type placeholder `_` is not allowed within types on item signatures\n fn foo() -> Y {\n     Struct\n }"}, {"sha": "955765e1175cef3210d892720fec89567ea6389c", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 18, "deletions": 48, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/342c5f33d097b2dc07a2dbc0ca45a37379d2ff60/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=342c5f33d097b2dc07a2dbc0ca45a37379d2ff60", "patch": "@@ -11,33 +11,33 @@ LL | trait BadTrait<_> {}\n    |                ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/typeck_type_placeholder_item.rs:170:19\n+  --> $DIR/typeck_type_placeholder_item.rs:167:19\n    |\n LL | struct BadStruct1<_, _>(_);\n    |                   ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/typeck_type_placeholder_item.rs:170:22\n+  --> $DIR/typeck_type_placeholder_item.rs:167:22\n    |\n LL | struct BadStruct1<_, _>(_);\n    |                      ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/typeck_type_placeholder_item.rs:175:19\n+  --> $DIR/typeck_type_placeholder_item.rs:172:19\n    |\n LL | struct BadStruct2<_, T>(_, T);\n    |                   ^ expected identifier, found reserved identifier\n \n error: associated constant in `impl` without body\n-  --> $DIR/typeck_type_placeholder_item.rs:208:5\n+  --> $DIR/typeck_type_placeholder_item.rs:203:5\n    |\n LL |     const C: _;\n    |     ^^^^^^^^^^-\n    |               |\n    |               help: provide a definition for the constant: `= <expr>;`\n \n error[E0403]: the name `_` is already used for a generic parameter in this item's generic parameters\n-  --> $DIR/typeck_type_placeholder_item.rs:170:22\n+  --> $DIR/typeck_type_placeholder_item.rs:167:22\n    |\n LL | struct BadStruct1<_, _>(_);\n    |                   -  ^ already used\n@@ -351,18 +351,6 @@ help: use type parameters instead\n LL | struct BadStruct<T>(T);\n    |                  ^  ^\n \n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:159:32\n-   |\n-LL | impl BadTrait<_> for BadStruct<_> {}\n-   |                                ^ not allowed in type signatures\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:159:15\n-   |\n-LL | impl BadTrait<_> for BadStruct<_> {}\n-   |               ^ not allowed in type signatures\n-\n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n   --> $DIR/typeck_type_placeholder_item.rs:159:15\n    |\n@@ -377,13 +365,13 @@ LL | impl<T> BadTrait<T> for BadStruct<T> {}\n    |     ^^^          ^                ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:164:34\n+  --> $DIR/typeck_type_placeholder_item.rs:162:34\n    |\n LL | fn impl_trait() -> impl BadTrait<_> {\n    |                                  ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:170:25\n+  --> $DIR/typeck_type_placeholder_item.rs:167:25\n    |\n LL | struct BadStruct1<_, _>(_);\n    |                         ^ not allowed in type signatures\n@@ -394,7 +382,7 @@ LL | struct BadStruct1<T, _>(T);\n    |                   ^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:175:25\n+  --> $DIR/typeck_type_placeholder_item.rs:172:25\n    |\n LL | struct BadStruct2<_, T>(_, T);\n    |                         ^ not allowed in type signatures\n@@ -405,13 +393,7 @@ LL | struct BadStruct2<K, T>(K, T);\n    |                   ^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:179:14\n-   |\n-LL | type X = Box<_>;\n-   |              ^ not allowed in type signatures\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:179:14\n+  --> $DIR/typeck_type_placeholder_item.rs:176:14\n    |\n LL | type X = Box<_>;\n    |              ^ not allowed in type signatures\n@@ -531,37 +513,25 @@ LL |         fn clone_from<T>(&mut self, other: T) { *self = FnTest9; }\n    |                      ^^^                   ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:164:34\n-   |\n-LL | fn impl_trait() -> impl BadTrait<_> {\n-   |                                  ^ not allowed in type signatures\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:186:21\n-   |\n-LL | type Y = impl Trait<_>;\n-   |                     ^ not allowed in type signatures\n-\n-error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:186:21\n+  --> $DIR/typeck_type_placeholder_item.rs:182:21\n    |\n LL | type Y = impl Trait<_>;\n    |                     ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:195:14\n+  --> $DIR/typeck_type_placeholder_item.rs:190:14\n    |\n LL |     type B = _;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:197:14\n+  --> $DIR/typeck_type_placeholder_item.rs:192:14\n    |\n LL |     const C: _;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:199:14\n+  --> $DIR/typeck_type_placeholder_item.rs:194:14\n    |\n LL |     const D: _ = 42;\n    |              ^\n@@ -606,33 +576,33 @@ LL |         fn clone(&self) -> _ { FnTest9 }\n    |                            help: replace with the correct return type: `main::FnTest9`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:204:14\n+  --> $DIR/typeck_type_placeholder_item.rs:199:14\n    |\n LL |     type A = _;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:206:14\n+  --> $DIR/typeck_type_placeholder_item.rs:201:14\n    |\n LL |     type B = _;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:208:14\n+  --> $DIR/typeck_type_placeholder_item.rs:203:14\n    |\n LL |     const C: _;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:211:14\n+  --> $DIR/typeck_type_placeholder_item.rs:206:14\n    |\n LL |     const D: _ = 42;\n    |              ^\n    |              |\n    |              not allowed in type signatures\n    |              help: replace `_` with the correct type: `i32`\n \n-error: aborting due to 71 previous errors\n+error: aborting due to 66 previous errors\n \n Some errors have detailed explanations: E0121, E0282, E0403.\n For more information about an error, try `rustc --explain E0121`."}]}