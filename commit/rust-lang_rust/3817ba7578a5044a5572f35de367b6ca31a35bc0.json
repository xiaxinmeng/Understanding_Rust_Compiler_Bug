{"sha": "3817ba7578a5044a5572f35de367b6ca31a35bc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MTdiYTc1NzhhNTA0NGE1NTcyZjM1ZGUzNjdiNmNhMzFhMzViYzA=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-03-16T04:42:07Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-06T22:35:48Z"}, "message": "adding uv::direct and beginning to work out tcp request case\n\nlots of changes, here.. should've commited sooner.\n- added uv::direct module that contains rust fns that map, neatly, to\nthe libuv c library as much as possible. they operate on ptrs to libuv\nstructs mapped in rust, as much as possible (there are some notable\nexceptions). these uv::direct fns should only take inputs from rust and,\nas neccesary, translate them into C-friendly types and then pass to the\nC functions. We want to them to return ints, as the libuv functions do,\nso we can start tracking status.\n- the notable exceptions for structs above is due to ref gh-1402, which\nprevents us from passing structs, by value, across the Rust<->C barrier\n(they turn to garbage, pretty much). So in the cases where we get back\nby-val structs from C (uv_buf_init(), uv_ip4_addr(), uv_err_t in callbacks)\n, we're going to use *ctypes::void (or just errnum ints for uv_err_t) until\ngh-1402 is resolved.\n- using crust functions, in these uv::direct fns, for callbacks from libuv,\nwill eschew uv_err_t, if possible, in favor a struct int.. if at all\npossible (probably isn't.. hm.. i know libuv wants to eventually move to\nreplace uv_err_t with an int, as well.. so hm).\n- started flushing out a big, gnarly test case to exercise the tcp request\nside of the uv::direct functions. I'm at the point where, after the\nconnection is established, we write to the stream... when the writing is\ndone, we will read from it, then tear the whole thing down.\n\noverall, it turns out that doing \"close to the metal\" interaction with\nc libraries is painful (and more chatty) when orchestrated from rust. My\nunderstanding is that not much, at all, is written in this fashion in the\nexistant core/std codebase.. malloc'ing in C has been preferred, from what\nI've gathered. So we're treading new ground, here!", "tree": {"sha": "95ef3041fd93b73c1930daed9407454b0275bec6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95ef3041fd93b73c1930daed9407454b0275bec6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3817ba7578a5044a5572f35de367b6ca31a35bc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3817ba7578a5044a5572f35de367b6ca31a35bc0", "html_url": "https://github.com/rust-lang/rust/commit/3817ba7578a5044a5572f35de367b6ca31a35bc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3817ba7578a5044a5572f35de367b6ca31a35bc0/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d274ec5f2eb4b572aca99e98eb9a042882f999e", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d274ec5f2eb4b572aca99e98eb9a042882f999e", "html_url": "https://github.com/rust-lang/rust/commit/9d274ec5f2eb4b572aca99e98eb9a042882f999e"}], "stats": {"total": 586, "additions": 585, "deletions": 1}, "files": [{"sha": "67508df49169874bdc0471019b5d7c7d65fa385b", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 485, "deletions": 1, "changes": 486, "blob_url": "https://github.com/rust-lang/rust/blob/3817ba7578a5044a5572f35de367b6ca31a35bc0/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3817ba7578a5044a5572f35de367b6ca31a35bc0/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=3817ba7578a5044a5572f35de367b6ca31a35bc0", "patch": "@@ -2,6 +2,7 @@ import map::hashmap;\n export loop_new, loop_delete, run, close, run_in_bg;\n export async_init, async_send;\n export timer_init, timer_start, timer_stop;\n+export uv_ip4_addr, uv_ip6_addr;\n \n // these are processed solely in the\n // process_operation() crust fn below\n@@ -16,7 +17,7 @@ enum uv_operation {\n \n enum uv_handle {\n     uv_async([u8], uv_loop),\n-    uv_timer([u8], uv_loop)\n+    uv_timer([u8], uv_loop),\n }\n \n enum uv_msg {\n@@ -50,6 +51,191 @@ enum uv_loop {\n     uv_loop_new(comm::chan<uv_msg>, *libc::c_void)\n }\n \n+// libuv struct mappings\n+type uv_ip4_addr = {\n+    ip: [u8],\n+    port: int\n+};\n+type uv_ip6_addr = uv_ip4_addr;\n+\n+enum uv_handle_type {\n+    UNKNOWN_HANDLE = 0,\n+    UV_TCP,\n+    UV_UDP,\n+    UV_NAMED_PIPE,\n+    UV_TTY,\n+    UV_FILE,\n+    UV_TIMER,\n+    UV_PREPARE,\n+    UV_CHECK,\n+    UV_IDLE,\n+    UV_ASYNC,\n+    UV_ARES_TASK,\n+    UV_ARES_EVENT,\n+    UV_PROCESS,\n+    UV_FS_EVENT\n+}\n+\n+type handle_type = ctypes::enum;\n+\n+type uv_handle_fields = {\n+   loop_handle: *ctypes::void,\n+   type_: handle_type,\n+   close_cb: *u8,\n+   mutable data: *ctypes::void,\n+};\n+\n+// unix size: 8\n+type uv_err_t = {\n+    code: ctypes::c_int,\n+    sys_errno_: ctypes::c_int\n+};\n+\n+// don't create one of these directly. instead,\n+// count on it appearing in libuv callbacks or embedded\n+// in other types as a pointer to be used in other\n+// operations (so mostly treat it as opaque, once you\n+// have it in this form..)\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+type uv_stream_t = {\n+    fields: uv_handle_fields\n+};\n+\n+// unix size: 272\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+type uv_tcp_t = {\n+    fields: uv_handle_fields,\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n+    a12: *u8, a13: *u8, a14: *u8, a15: *u8,\n+    a16: *u8, a17: *u8, a18: *u8, a19: *u8,\n+    a20: *u8, a21: *u8, a22: *u8, a23: *u8,\n+    a24: *u8, a25: *u8, a26: *u8, a27: *u8,\n+    a28: *u8, a29: *u8\n+};\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n+    ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    mutable data: ptr::null() },\n+        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n+        a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n+        a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8, a11: 0 as *u8,\n+        a12: 0 as *u8, a13: 0 as *u8, a14: 0 as *u8, a15: 0 as *u8,\n+        a16: 0 as *u8, a17: 0 as *u8, a18: 0 as *u8, a19: 0 as *u8,\n+        a20: 0 as *u8, a21: 0 as *u8, a22: 0 as *u8, a23: 0 as *u8,\n+        a24: 0 as *u8, a25: 0 as *u8, a26: 0 as *u8, a27: 0 as *u8,\n+        a28: 0 as *u8, a29: 0 as *u8\n+    };\n+}\n+\n+#[cfg(target_os = \"win32\")]\n+type uv_tcp_t = {\n+    loop_handle: *ctypes::void\n+};\n+#[cfg(target_os = \"win32\")]\n+fn gen_stub_uv_tcp_t() -> uv_tcp_t {\n+    ret { loop_handle: ptr::null() };\n+}\n+\n+// unix size: 48\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+type uv_connect_t = {\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8\n+};\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+fn gen_stub_uv_connect_t() -> uv_connect_t {\n+    ret { \n+        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n+        a04: 0 as *u8, a05: 0 as *u8\n+    };\n+}\n+\n+// ref #1402 .. don't use this, like sockaddr_in \n+// unix size: 16\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+type uv_buf_t = {\n+    base: *u8,\n+    len: ctypes::size_t\n+};\n+// no gen stub method.. should create\n+// it via uv::direct::buf_init()\n+\n+#[cfg(target_os = \"win32\")]\n+type uv_connect_t = {\n+    loop_handle: *ctypes::void\n+};\n+#[cfg(target_os = \"win32\")]\n+fn gen_stub_uv_connect_t() -> uv_connect_t {\n+    ret { loop_handle: ptr::null() };\n+}\n+\n+// unix size: 144\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+type uv_write_t = {\n+    fields: uv_handle_fields,\n+    a00: *u8, a01: *u8, a02: *u8, a03: *u8,\n+    a04: *u8, a05: *u8, a06: *u8, a07: *u8,\n+    a08: *u8, a09: *u8, a10: *u8, a11: *u8,\n+    a12: *u8, a13: *u8\n+};\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+fn gen_stub_uv_write_t() -> uv_write_t {\n+    ret { fields: { loop_handle: ptr::null(), type_: 0u32,\n+                    close_cb: ptr::null(),\n+                    mutable data: ptr::null() },\n+        a00: 0 as *u8, a01: 0 as *u8, a02: 0 as *u8, a03: 0 as *u8,\n+        a04: 0 as *u8, a05: 0 as *u8, a06: 0 as *u8, a07: 0 as *u8,\n+        a08: 0 as *u8, a09: 0 as *u8, a10: 0 as *u8, a11: 0 as *u8,\n+        a12: 0 as *u8, a13: 0 as *u8\n+    };\n+}\n+#[cfg(target_os = \"win32\")]\n+type uv_write_t = {\n+    loop_handle: *ctypes::void\n+};\n+#[cfg(target_os = \"win32\")]\n+fn gen_stub_uv_write_t() -> uv_write_t {\n+    ret { loop_handle: ptr::null() };\n+}\n+\n+// not going to use this type, for now, because of\n+// github issue #1402\n+// unix size: 16\n+#[cfg(target_os = \"linux\")]\n+#[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"freebsd\")]\n+type sockaddr_in = {\n+    sin_family: u16,\n+    sin_port: u16,\n+    sin_addr: u32, // in_addr: this is an opaque, per-platform struct\n+    sin_zero: *u8\n+};\n+\n+// unix size: 28 .. make due w/ 32\n+type sockaddr_in6 = {\n+    a0: *u8, a1: *u8,\n+    a2: *u8, a3: *u8\n+};\n+\n #[nolink]\n native mod rustrt {\n     fn rust_uv_loop_new() -> *libc::c_void;\n@@ -78,6 +264,130 @@ native mod rustrt {\n         timeout: libc::c_uint,\n         repeat: libc::c_uint);\n     fn rust_uv_timer_stop(handle: *libc::c_void);\n+\n+    ////////////\n+    // NOT IN rustrt.def.in\n+    ////////////\n+    fn rust_uv_free(ptr: *ctypes::void);\n+    fn rust_uv_tcp_init(\n+        loop_handle: *ctypes::void,\n+        handle_ptr: *uv_tcp_t) -> ctypes::c_int;\n+    fn rust_uv_buf_init(base: *u8, len: ctypes::size_t)\n+        -> uv_buf_t;\n+    fn rust_uv_last_error(loop_handle: *ctypes::void) -> uv_err_t;\n+    fn rust_uv_ip4_addr(ip: *u8, port: ctypes::c_int)\n+        -> *ctypes::void;\n+    fn rust_uv_tcp_connect(connect_ptr: *uv_connect_t,\n+                           tcp_handle_ptr: *uv_tcp_t,\n+                           addr: *ctypes::void,\n+                           after_cb: *u8) -> ctypes::c_int;\n+\n+    // sizeof testing helpers\n+    fn rust_uv_helper_uv_tcp_t_size() -> ctypes::c_uint;\n+    fn rust_uv_helper_uv_connect_t_size() -> ctypes::c_uint;\n+    fn rust_uv_helper_uv_buf_t_size() -> ctypes::c_uint;\n+    fn rust_uv_helper_uv_write_t_size() -> ctypes::c_uint;\n+    fn rust_uv_helper_uv_err_t_size() -> ctypes::c_uint;\n+    fn rust_uv_helper_sockaddr_in_size() -> ctypes::c_uint;\n+\n+    // data accessors for rust-mapped uv structs\n+    fn rust_uv_get_stream_handle_for_connect(connect: *uv_connect_t)\n+        -> *uv_stream_t;\n+    fn rust_uv_get_loop_for_uv_handle(handle: *ctypes::void)\n+        -> *ctypes::void;\n+    fn rust_uv_get_data_for_uv_handle(handle: *ctypes::void)\n+        -> *ctypes::void;\n+    fn rust_uv_set_data_for_uv_handle(handle: *ctypes::void,\n+                                      data: *ctypes::void);\n+    fn rust_uv_get_data_for_req(req: *ctypes::void) -> *ctypes::void;\n+    fn rust_uv_set_data_for_req(req: *ctypes::void,\n+                                data: *ctypes::void);\n+}\n+\n+// this module is structured around functions that directly\n+// expose libuv functionality and data structures. for use\n+// in higher level mappings\n+mod direct {\n+    unsafe fn loop_new() -> *ctypes::void {\n+        ret rustrt::rust_uv_loop_new();\n+    }\n+\n+    unsafe fn loop_delete(loop_handle: *ctypes::void) {\n+        rustrt::rust_uv_loop_delete(loop_handle);\n+    }\n+\n+    unsafe fn run(loop_handle: *ctypes::void) {\n+        rustrt::rust_uv_run(loop_handle);\n+    }\n+\n+    unsafe fn tcp_init(loop_handle: *ctypes::void, handle: *uv_tcp_t)\n+        -> ctypes::c_int {\n+        ret rustrt::rust_uv_tcp_init(loop_handle, handle);\n+    }\n+    unsafe fn tcp_connect(connect_ptr: *uv_connect_t,\n+                          tcp_handle_ptr: *uv_tcp_t,\n+                          address: *ctypes::void,\n+                          after_connect_cb: *u8)\n+    -> ctypes::c_int {\n+        ret rustrt::rust_uv_tcp_connect(connect_ptr, tcp_handle_ptr,\n+                                    address, after_connect_cb);\n+    }\n+\n+    unsafe fn write(req: *ctypes::void, stream: *ctypes::void,\n+             buf: *[uv_buf_t], cb: *u8) -> ctypes::c_int {\n+        ret rustrt::rust_uv_write(\n+    }\n+\n+    unsafe fn uv_last_error(loop_handle: *ctypes::void) -> uv_err_t {\n+        ret rustrt::rust_uv_last_error(loop_handle);\n+    }\n+\n+    // libuv struct initializers\n+    unsafe fn tcp_t() -> uv_tcp_t {\n+        ret gen_stub_uv_tcp_t();\n+    }\n+    unsafe fn connect_t() -> uv_connect_t {\n+        ret gen_stub_uv_connect_t();\n+    }\n+    unsafe fn write_t() -> uv_write_t {\n+        ret gen_stub_uv_write_t();\n+    }\n+    // FIXME: see github issue #1402\n+    unsafe fn buf_init(input: *u8, len: uint) -> *ctypes::void {\n+        ret rustrt::rust_uv_buf_init(input, len);\n+    }\n+    unsafe fn get_loop_for_uv_handle(handle: *ctypes::void)\n+        -> *ctypes::void {\n+        ret rustrt::rust_uv_get_loop_for_uv_handle(handle);\n+    }\n+    unsafe fn get_stream_handle_for_connect(connect: *uv_connect_t)\n+        -> *uv_stream_t {\n+        ret rustrt::rust_uv_get_stream_handle_for_connect(connect);\n+    }\n+\n+    unsafe fn get_data_for_req(req: *ctypes::void) -> *ctypes::void {\n+        ret rustrt::rust_uv_get_data_for_req(req);\n+    }\n+    unsafe fn set_data_for_req(req: *ctypes::void,\n+                        data: *ctypes::void) {\n+        rustrt::rust_uv_set_data_for_req(req, data);\n+    }\n+    // FIXME: see github issue #1402\n+    unsafe fn ip4_addr(ip: str, port: ctypes::c_int)\n+    -> *ctypes::void {\n+        let addr_vec = str::bytes(ip);\n+        addr_vec += [0u8]; // add null terminator\n+        let addr_vec_ptr = vec::unsafe::to_ptr(addr_vec);\n+        let ip_back = str::from_bytes(addr_vec);\n+        io::println(#fmt(\"vec val: '%s' length: %u\",ip_back, vec::len(addr_vec)));\n+        ret rustrt::rust_uv_ip4_addr(addr_vec_ptr, port);\n+    }\n+\n+    // this is lame.\n+    // FIXME: see github issue #1402\n+    unsafe fn ip4_addr_free(ptr: *ctypes::void) {\n+        rustrt::rust_uv_free(ptr);\n+    }\n }\n \n // public functions\n@@ -626,3 +936,177 @@ fn test_uv_timer() {\n     assert comm::recv(exit_port);\n     uv::loop_delete(test_loop);\n }\n+\n+// BEGIN TCP REQUEST TEST SUITE\n+\n+type request_wrapper = {\n+    write_req: *uv_write_t,\n+    req_buf: *[uv_buf_t]\n+};\n+\n+crust fn on_alloc(handle: *ctypes::void,\n+                  suggested_size: ctypes::size_t) -> uv_buf_t\n+    unsafe {\n+    io::println(\"beginning on_alloc...\");\n+    io::println(\"ending on_alloc...\");\n+    let new_vec: @[u8] = @[];\n+    let ptr = vec::unsafe::to_ptr(*new_vec);\n+    ret direct::buf_init(ptr, vec::len(*new_vec));\n+}\n+\n+crust fn on_write_complete_cb(write_handle: *uv_write_t,\n+                              status: ctypes::c_int) unsafe {\n+    io::println(\"beginning on_write_complete_cb\");\n+    io::println(\"ending on_write_complete_cb\");\n+}\n+\n+crust fn on_connect_cb(connect_handle_ptr: *uv_connect_t,\n+                             status: ctypes::c_int) unsafe {\n+    io::println(#fmt(\"beginning on_connect_cb .. status: %d\",\n+                     status as int));\n+    let stream = direct::get_stream_handle_for_connect(connect_handle_ptr);\n+    if (status == 0i32) {\n+        io::println(\"on_connect_cb: in status=0 if..\");\n+        let data = direct::get_data_for_req(\n+            connect_handle_ptr as *ctypes::void)\n+            as *request_wrapper;\n+        let write_handle = (*data).write_req as *ctypes::void;\n+        io::println(#fmt(\"on_connect_cb: tcp stream: %d write_handle addr %d\",\n+                        stream as int, write_handle as int));\n+        direct::write(write_handle,\n+                          stream as *ctypes::void,\n+                          (*data).req_buf,\n+                          on_write_complete_cb);\n+        io::println(\"on_connect_cb: after direct::write()\");\n+    }\n+    else {\n+        let loop_handle = direct::get_loop_for_uv_handle(\n+            stream as *ctypes::void);\n+        let err = direct::uv_last_error(loop_handle);\n+    }\n+    io::println(\"finishing on_connect_cb\");\n+}\n+\n+fn impl_uv_tcp_request() unsafe {\n+    let test_loop = direct::loop_new();\n+    let tcp_handle = direct::tcp_t();\n+    let tcp_handle_ptr = ptr::addr_of(tcp_handle);\n+    let connect_handle = direct::connect_t();\n+    let connect_handle_ptr = ptr::addr_of(connect_handle);\n+\n+    // this is the persistent payload of data that we\n+    // need to pass around to get this example to work.\n+    // In C, this would be a malloc'd or stack-allocated\n+    // struct that we'd cast to a void* and store as the\n+    // data field in our uv_connect_t struct\n+    let req_str = str::bytes(\"GET / HTTP/1.1\\r\\nHost: google.com\"\n+                                + \"\\r\\n\\r\\n\\r\\n\");\n+    let req_msg_ptr: *u8 = vec::unsafe::to_ptr(req_str);\n+    let req_msg = [\n+        direct::buf_init(req_msg_ptr, vec::len(req_str))\n+    ];\n+    // this is the enclosing record, we'll pass a ptr to\n+    // this to C..\n+    let write_handle = direct::write_t();\n+    let write_handle_ptr = ptr::addr_of(write_handle);\n+    io::println(#fmt(\"tcp req setup: tcp stream: %d write_handle addr %d\",\n+                    tcp_handle_ptr as int, write_handle_ptr as int));\n+    let req = { writer_handle: write_handle_ptr,\n+                req_buf: ptr::addr_of(req_msg) };\n+    io::println(\"building addr...\");\n+    let addr = direct::ip4_addr(\"173.194.33.40\", 80i32);\n+    \n+    let tcp_init_result = direct::tcp_init(\n+        test_loop as *ctypes::void, tcp_handle_ptr);\n+    if (tcp_init_result == 0i32) {\n+        io::println(\"sucessful tcp_init_result\");\n+        // this should set up the connection request..\n+        let tcp_connect_result = direct::tcp_connect(\n+            connect_handle_ptr, tcp_handle_ptr,\n+            addr, on_connect_cb);\n+        if (tcp_connect_result == 0i32) {\n+            // not set the data on the connect_req until its initialized\n+            direct::set_data_for_req(\n+                connect_handle_ptr as *ctypes::void,\n+                ptr::addr_of(req) as *ctypes::void);\n+            io::println(\"before run tcp req loop\");\n+            direct::run(test_loop);\n+            io::println(\"after run tcp req loop\");\n+            // FIXME: see github issue #1402\n+            direct::ip4_addr_free(addr);\n+        }\n+        else {\n+           io::println(\"direct::tcp_connect() failure\");\n+           assert false;\n+        }\n+    }\n+    else {\n+        io::println(\"direct::tcp_init() failure\");\n+        assert false;\n+    }\n+    \n+}\n+// START HERE AND WORK YOUR WAY UP VIA CALLBACKS\n+#[test]\n+#[ignore(cfg(target_os = \"freebsd\"))]\n+fn test_uv_tcp_request() unsafe {\n+    impl_uv_tcp_request();\n+}\n+// END TCP REQUEST TEST SUITE\n+\n+// struct size tests\n+#[test]\n+#[ignore(cfg(target_os = \"freebsd\"))]\n+fn test_uv_struct_size_uv_tcp_t() {\n+    let native_handle_size = rustrt::rust_uv_helper_uv_tcp_t_size();\n+    let rust_handle_size = sys::size_of::<uv_tcp_t>();\n+    let output = #fmt(\"uv_tcp_t -- native: %u rust: %u\",\n+                      native_handle_size as uint, rust_handle_size);\n+    io::println(output);\n+    assert native_handle_size as uint == rust_handle_size;\n+}\n+#[test]\n+#[ignore(cfg(target_os = \"freebsd\"))]\n+fn test_uv_struct_size_uv_connect_t() {\n+    let native_handle_size =\n+        rustrt::rust_uv_helper_uv_connect_t_size();\n+    let rust_handle_size = sys::size_of::<uv_connect_t>();\n+    let output = #fmt(\"uv_connect_t -- native: %u rust: %u\",\n+                      native_handle_size as uint, rust_handle_size);\n+    io::println(output);\n+    assert native_handle_size as uint == rust_handle_size;\n+}\n+#[test]\n+#[ignore(cfg(target_os = \"freebsd\"))]\n+fn test_uv_struct_size_uv_buf_t() {\n+    let native_handle_size =\n+        rustrt::rust_uv_helper_uv_buf_t_size();\n+    let rust_handle_size = sys::size_of::<uv_buf_t>();\n+    let output = #fmt(\"uv_buf_t -- native: %u rust: %u\",\n+                      native_handle_size as uint, rust_handle_size);\n+    io::println(output);\n+    assert native_handle_size as uint == rust_handle_size;\n+}\n+#[test]\n+#[ignore(cfg(target_os = \"freebsd\"))]\n+fn test_uv_struct_size_uv_write_t() {\n+    let native_handle_size =\n+        rustrt::rust_uv_helper_uv_write_t_size();\n+    let rust_handle_size = sys::size_of::<uv_write_t>();\n+    let output = #fmt(\"uv_write_t -- native: %u rust: %u\",\n+                      native_handle_size as uint, rust_handle_size);\n+    io::println(output);\n+    assert native_handle_size as uint == rust_handle_size;\n+}\n+\n+#[test]\n+#[ignore(cfg(target_os = \"freebsd\"))]\n+fn test_uv_struct_size_sockaddr_in() {\n+    let native_handle_size =\n+        rustrt::rust_uv_helper_sockaddr_in_size();\n+    let rust_handle_size = sys::size_of::<sockaddr_in>();\n+    let output = #fmt(\"sockaddr_in -- native: %u rust: %u\",\n+                      native_handle_size as uint, rust_handle_size);\n+    io::println(output);\n+    assert native_handle_size as uint == rust_handle_size;\n+}"}, {"sha": "2a575bd00e387fe3b8786c0e4fe3bfedb3abb14c", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/3817ba7578a5044a5572f35de367b6ca31a35bc0/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3817ba7578a5044a5572f35de367b6ca31a35bc0/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=3817ba7578a5044a5572f35de367b6ca31a35bc0", "patch": "@@ -80,6 +80,10 @@ native_close_op_cb(uv_handle_t* op_handle) {\n }\n \n // native fns bound in rust\n+extern \"C\" void\n+rust_uv_free(void* ptr) {\n+  current_kernel_free(ptr);\n+}\n extern \"C\" void*\n rust_uv_loop_new() {\n     return (void*)uv_loop_new();\n@@ -195,3 +199,99 @@ rust_uv_timer_stop(uv_timer_t* the_timer) {\n   uv_timer_stop(the_timer);\n }\n \n+extern \"C\" int\n+rust_uv_tcp_init(uv_loop_t* loop, uv_tcp_t* handle) {\n+  return uv_tcp_init(loop, handle);\n+}\n+\n+extern \"C\" size_t\n+rust_uv_helper_uv_tcp_t_size() {\n+  return sizeof(uv_tcp_t);\n+}\n+extern \"C\" size_t\n+rust_uv_helper_uv_connect_t_size() {\n+  return sizeof(uv_connect_t);\n+}\n+extern \"C\" size_t\n+rust_uv_helper_uv_buf_t_size() {\n+  return sizeof(uv_buf_t);\n+}\n+extern \"C\" size_t\n+rust_uv_helper_uv_write_t_size() {\n+  return sizeof(uv_write_t);\n+}\n+extern \"C\" size_t\n+rust_uv_helper_uv_err_t_size() {\n+  return sizeof(uv_err_t);\n+}\n+extern \"C\" size_t\n+rust_uv_helper_sockaddr_in_size() {\n+  return sizeof(sockaddr_in);\n+}\n+\n+extern \"C\" uv_stream_t*\n+rust_uv_get_stream_handle_for_connect(uv_connect_t* connect) {\n+  return connect->handle;\n+}\n+\n+extern \"C\" uv_buf_t\n+rust_uv_buf_init(char* base, size_t len) {\n+  return uv_buf_init(base, len);\n+}\n+\n+extern \"C\" uv_loop_t*\n+rust_uv_get_loop_for_uv_handle(uv_handle_t* handle) {\n+  return handle->loop;\n+}\n+\n+extern \"C\" void*\n+rust_uv_get_data_for_uv_handle(uv_handle_t* handle) {\n+  return handle->data;\n+}\n+\n+extern \"C\" void\n+rust_uv_set_data_for_uv_handle(uv_handle_t* handle,\n+\t\t\t\t\t\t\t   void* data) {\n+  handle->data = data;\n+}\n+\n+extern \"C\" void*\n+rust_uv_get_data_for_req(uv_req_t* req) {\n+  return req->data;\n+}\n+\n+extern \"C\" void\n+rust_uv_set_data_for_req(uv_req_t* req, void* data) {\n+  req->data = data;\n+}\n+\n+extern \"C\" uv_err_t\n+rust_uv_last_error(uv_loop_t* loop) {\n+  return uv_last_error(loop);\n+}\n+\n+extern \"C\" int\n+rust_uv_tcp_connect(uv_connect_t* connect_ptr,\n+\t\t\t\t\tuv_tcp_t* tcp_ptr,\n+\t\t\t\t\tvoid* addr_ptr,\n+\t\t\t\t\tuv_connect_cb cb) {\n+  //return uv_tcp_connect(connect_ptr, tcp_ptr, addr, cb);\n+  printf(\"inside rust_uv_tcp_connect\\n\");\n+  sockaddr_in addr_tmp = *((sockaddr_in*)addr_ptr);\n+  sockaddr_in addr = addr_tmp;\n+  printf(\"before tcp_connect .. port: %d\\n\", addr.sin_port);\n+  int result = uv_tcp_connect(connect_ptr, tcp_ptr, addr, cb);\n+  printf (\"leaving rust_uv_tcp_connect.. and result: %d\\n\", result);\n+  return result;\n+}\n+\n+extern \"C\" void*\n+rust_uv_ip4_addr(const char* ip, int port) {\n+  sockaddr_in* addr_ptr = (sockaddr_in*)current_kernel_malloc(\n+\t\t\t\t\t\t\t  sizeof(sockaddr_in),\n+\t\t\t\t\t\t\t  \"sockaddr_in\");\n+  printf(\"before creating addr_ptr.. ip %s port %d\\n\", ip, port);\n+  *addr_ptr = uv_ip4_addr(\"173.194.33.40\", 80);\n+  printf(\"after creating .. port: %d\\n\", addr_ptr->sin_port);\n+  return (void*)addr_ptr;\n+}"}]}