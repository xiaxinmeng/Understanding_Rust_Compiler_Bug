{"sha": "f629eb35950ef32a909a98548840f4645bb0f862", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2MjllYjM1OTUwZWYzMmE5MDlhOTg1NDg4NDBmNDY0NWJiMGY4NjI=", "commit": {"author": {"name": "Meade Kincke", "email": "thedarkula2049@gmail.com", "date": "2018-07-06T22:23:12Z"}, "committer": {"name": "Meade Kincke", "email": "thedarkula2049@gmail.com", "date": "2018-07-07T00:09:09Z"}, "message": "General fixes and cleanup.", "tree": {"sha": "f643a2b3edd662bef6c1ed1401640149e950fec0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f643a2b3edd662bef6c1ed1401640149e950fec0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f629eb35950ef32a909a98548840f4645bb0f862", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f629eb35950ef32a909a98548840f4645bb0f862", "html_url": "https://github.com/rust-lang/rust/commit/f629eb35950ef32a909a98548840f4645bb0f862", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f629eb35950ef32a909a98548840f4645bb0f862/comments", "author": null, "committer": null, "parents": [{"sha": "75bc0649b8aca2728b151c4de39af77e291cf007", "url": "https://api.github.com/repos/rust-lang/rust/commits/75bc0649b8aca2728b151c4de39af77e291cf007", "html_url": "https://github.com/rust-lang/rust/commit/75bc0649b8aca2728b151c4de39af77e291cf007"}], "stats": {"total": 55, "additions": 24, "deletions": 31}, "files": [{"sha": "c3ee98039f3f6fb197d959b07dcf9ba9f905f27f", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f629eb35950ef32a909a98548840f4645bb0f862/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f629eb35950ef32a909a98548840f4645bb0f862/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=f629eb35950ef32a909a98548840f4645bb0f862", "patch": "@@ -40,7 +40,6 @@ use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n use syntax::attr;\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n@@ -169,12 +168,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n     }\n }\n \n-impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        // note that we *do* visit nested bodies, because we override `visit_nested_body` below\n-        NestedVisitorMap::None\n-    }\n-\n+impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n         let item_id = self.tcx.hir.body_owner(body_id);\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n@@ -206,8 +200,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         euv::ExprUseVisitor::new(self, tcx, param_env, &region_scope_tree, self.tables, None)\n             .consume_body(body);\n \n-        self.visit_body(body);\n-\n+        self.visit_expr(&body.value);\n         self.in_fn = outer_in_fn;\n         self.tables = outer_tables;\n         self.param_env = outer_param_env;\n@@ -216,27 +209,29 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n \n     fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt) {\n         match stmt.node {\n-            hir::StmtDecl(ref decl, node_id) => {\n-                self.visit_id(node_id);\n-                self.visit_decl(decl);\n+            hir::StmtDecl(ref decl, _node_id) => {\n                 match &decl.node {\n                     hir::DeclLocal(local) => {\n                         self.promotable = false;\n-\n                         if self.remove_mut_rvalue_borrow(&local.pat) {\n                             if let Some(init) = &local.init {\n                                 self.mut_rvalue_borrows.insert(init.id);\n                             }\n                         }\n+\n+                        match local.init {\n+                            Some(ref expr) => self.visit_expr(&expr),\n+                            None => {},\n+                        }\n                     }\n                     // Item statements are allowed\n                     hir::DeclItem(_) => {}\n                 }\n             }\n-            hir::StmtExpr(ref box_expr, node_id) |\n-            hir::StmtSemi(ref box_expr, node_id) => {\n+            hir::StmtExpr(ref box_expr, _node_id) |\n+            hir::StmtSemi(ref box_expr, _node_id) => {\n                 self.visit_expr(box_expr);\n-                self.visit_id(node_id);\n+                self.promotable = false;\n             }\n         }\n     }\n@@ -293,12 +288,18 @@ fn check_expr<'a, 'tcx>(\n             v.promotable = false;\n         }\n         hir::ExprUnary(op, ref expr) => {\n-            v.visit_expr(expr);\n+            if v.tables.is_method_call(e) {\n+                v.promotable = false;\n+            }\n             if op == hir::UnDeref {\n                 v.promotable = false;\n             }\n+            v.visit_expr(expr);\n         }\n         hir::ExprBinary(op, ref lhs, ref rhs) => {\n+            if v.tables.is_method_call(e) {\n+                v.promotable = false;\n+            }\n             v.visit_expr(lhs);\n             v.visit_expr(rhs);\n             match v.tables.node_id_to_type(lhs.hir_id).sty {\n@@ -324,7 +325,6 @@ fn check_expr<'a, 'tcx>(\n             }\n         }\n         hir::ExprPath(ref qpath) => {\n-            v.visit_qpath(qpath, e.id, e.span);\n             let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n@@ -450,11 +450,8 @@ fn check_expr<'a, 'tcx>(\n \n         hir::ExprLit(_) => {}\n \n-        hir::ExprAddrOf(ref _mutability, ref expr) => {\n-            v.visit_expr(expr);\n-        }\n-\n-        hir::ExprRepeat(ref expr, ref _anon_cast) => {\n+        hir::ExprAddrOf(_, ref expr) |\n+        hir::ExprRepeat(ref expr, _) => {\n             v.visit_expr(expr);\n         }\n \n@@ -520,14 +517,10 @@ fn check_expr<'a, 'tcx>(\n \n             v.visit_expr(expr);\n             for index in hirvec_arm.iter() {\n-                match *index {\n-                    ref arm => {\n-                        v.visit_expr(&*arm.body);\n-                        match arm.guard {\n-                            Some(ref expr) => v.visit_expr(&expr),\n-                            None => {},\n-                        }\n-                    }\n+                v.visit_expr(&*index.body);\n+                match index.guard {\n+                    Some(ref expr) => v.visit_expr(&expr),\n+                    None => {},\n                 }\n             }\n             v.promotable = false;"}]}