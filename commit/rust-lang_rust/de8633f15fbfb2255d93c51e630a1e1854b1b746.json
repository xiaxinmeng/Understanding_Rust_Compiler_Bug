{"sha": "de8633f15fbfb2255d93c51e630a1e1854b1b746", "node_id": "C_kwDOAAsO6NoAKGRlODYzM2YxNWZiZmIyMjU1ZDkzYzUxZTYzMGExZTE4NTRiMWI3NDY", "commit": {"author": {"name": "Chayim Refael Friedman", "email": "chayimfr@gmail.com", "date": "2022-01-23T02:21:09Z"}, "committer": {"name": "Chayim Refael Friedman", "email": "chayimfr@gmail.com", "date": "2022-02-21T06:34:34Z"}, "message": "Parse `let` expressions in order to support `let` chains\n\nWe still need to reject freestanding `let` expressions: see https://github.com/rust-analyzer/rust-analyzer/issues/11320#issuecomment-1018212465.", "tree": {"sha": "afec7fe5dcaaeb628768c737478e21c281923261", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afec7fe5dcaaeb628768c737478e21c281923261"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de8633f15fbfb2255d93c51e630a1e1854b1b746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de8633f15fbfb2255d93c51e630a1e1854b1b746", "html_url": "https://github.com/rust-lang/rust/commit/de8633f15fbfb2255d93c51e630a1e1854b1b746", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de8633f15fbfb2255d93c51e630a1e1854b1b746/comments", "author": {"login": "ChayimFriedman2", "id": 24700207, "node_id": "MDQ6VXNlcjI0NzAwMjA3", "avatar_url": "https://avatars.githubusercontent.com/u/24700207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChayimFriedman2", "html_url": "https://github.com/ChayimFriedman2", "followers_url": "https://api.github.com/users/ChayimFriedman2/followers", "following_url": "https://api.github.com/users/ChayimFriedman2/following{/other_user}", "gists_url": "https://api.github.com/users/ChayimFriedman2/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChayimFriedman2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChayimFriedman2/subscriptions", "organizations_url": "https://api.github.com/users/ChayimFriedman2/orgs", "repos_url": "https://api.github.com/users/ChayimFriedman2/repos", "events_url": "https://api.github.com/users/ChayimFriedman2/events{/privacy}", "received_events_url": "https://api.github.com/users/ChayimFriedman2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChayimFriedman2", "id": 24700207, "node_id": "MDQ6VXNlcjI0NzAwMjA3", "avatar_url": "https://avatars.githubusercontent.com/u/24700207?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChayimFriedman2", "html_url": "https://github.com/ChayimFriedman2", "followers_url": "https://api.github.com/users/ChayimFriedman2/followers", "following_url": "https://api.github.com/users/ChayimFriedman2/following{/other_user}", "gists_url": "https://api.github.com/users/ChayimFriedman2/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChayimFriedman2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChayimFriedman2/subscriptions", "organizations_url": "https://api.github.com/users/ChayimFriedman2/orgs", "repos_url": "https://api.github.com/users/ChayimFriedman2/repos", "events_url": "https://api.github.com/users/ChayimFriedman2/events{/privacy}", "received_events_url": "https://api.github.com/users/ChayimFriedman2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6ed146a1caa41c65a831efbc80d79067c8f5955", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ed146a1caa41c65a831efbc80d79067c8f5955", "html_url": "https://github.com/rust-lang/rust/commit/d6ed146a1caa41c65a831efbc80d79067c8f5955"}], "stats": {"total": 166, "additions": 99, "deletions": 67}, "files": [{"sha": "a40db15049de2bb1a9cd0a77ecc1a1e7d8e78eae", "filename": "crates/parser/src/grammar/expressions.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=de8633f15fbfb2255d93c51e630a1e1854b1b746", "patch": "@@ -29,6 +29,15 @@ fn expr_no_struct(p: &mut Parser) {\n     expr_bp(p, None, r, 1);\n }\n \n+/// Parses the expression in `let pattern = expression`.\n+/// It needs to be parsed with lower precedence than `&&`, so that\n+/// `if let true = true && false` is parsed as `if (let true = true) && (true)`\n+/// and not `if let true = (true && true)`.\n+fn expr_let(p: &mut Parser) {\n+    let r = Restrictions { forbid_structs: true, prefer_stmt: false };\n+    expr_bp(p, None, r, 5);\n+}\n+\n pub(super) fn stmt(p: &mut Parser, semicolon: Semicolon) {\n     if p.eat(T![;]) {\n         return;\n@@ -185,6 +194,7 @@ fn current_op(p: &Parser) -> (u8, SyntaxKind) {\n         T![%] if p.at(T![%=])  => (1,  T![%=]),\n         T![%]                  => (11, T![%]),\n         T![&] if p.at(T![&=])  => (1,  T![&=]),\n+        // If you update this, remember to update `expr_let()` too.\n         T![&] if p.at(T![&&])  => (4,  T![&&]),\n         T![&]                  => (8,  T![&]),\n         T![/] if p.at(T![/=])  => (1,  T![/=]),"}, {"sha": "e2c1b1fec579ce7358aef88a16b30f1d9d0f43d5", "filename": "crates/parser/src/grammar/expressions/atom.rs", "status": "modified", "additions": 13, "deletions": 20, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=de8633f15fbfb2255d93c51e630a1e1854b1b746", "patch": "@@ -79,6 +79,7 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<(CompletedMar\n             closure_expr(p)\n         }\n         T![if] => if_expr(p),\n+        T![let] => let_expr(p),\n \n         T![loop] => loop_expr(p, None),\n         T![box] => box_expr(p, None),\n@@ -286,7 +287,7 @@ fn if_expr(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![if]));\n     let m = p.start();\n     p.bump(T![if]);\n-    condition(p);\n+    expr_no_struct(p);\n     block_expr(p);\n     if p.at(T![else]) {\n         p.bump(T![else]);\n@@ -335,7 +336,7 @@ fn while_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     assert!(p.at(T![while]));\n     let m = m.unwrap_or_else(|| p.start());\n     p.bump(T![while]);\n-    condition(p);\n+    expr_no_struct(p);\n     block_expr(p);\n     m.complete(p, WHILE_EXPR)\n }\n@@ -355,22 +356,18 @@ fn for_expr(p: &mut Parser, m: Option<Marker>) -> CompletedMarker {\n     m.complete(p, FOR_EXPR)\n }\n \n-// test cond\n-// fn foo() { if let Some(_) = None {} }\n-// fn bar() {\n-//     if let Some(_) | Some(_) = None {}\n-//     if let | Some(_) = None {}\n-//     while let Some(_) | Some(_) = None {}\n-//     while let | Some(_) = None {}\n+// test let_expr\n+// fn foo() {\n+//     if let Some(_) = None && true {}\n+//     while 1 == 5 && (let None = None) {}\n // }\n-fn condition(p: &mut Parser) {\n+fn let_expr(p: &mut Parser) -> CompletedMarker {\n     let m = p.start();\n-    if p.eat(T![let]) {\n-        patterns::pattern_top(p);\n-        p.expect(T![=]);\n-    }\n-    expr_no_struct(p);\n-    m.complete(p, CONDITION);\n+    p.bump(T![let]);\n+    patterns::pattern_top(p);\n+    p.expect(T![=]);\n+    expr_let(p);\n+    m.complete(p, LET_EXPR)\n }\n \n // test match_expr\n@@ -482,10 +479,6 @@ fn match_guard(p: &mut Parser) -> CompletedMarker {\n     assert!(p.at(T![if]));\n     let m = p.start();\n     p.bump(T![if]);\n-    if p.eat(T![let]) {\n-        patterns::pattern_top(p);\n-        p.expect(T![=]);\n-    }\n     expr(p);\n     m.complete(p, MATCH_GUARD)\n }"}, {"sha": "d04b5dbf0087b08fc6efc8c754d5f005af6a8345", "filename": "crates/parser/src/syntax_kind/generated.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fparser%2Fsrc%2Fsyntax_kind%2Fgenerated.rs?ref=de8633f15fbfb2255d93c51e630a1e1854b1b746", "patch": "@@ -178,7 +178,6 @@ pub enum SyntaxKind {\n     CLOSURE_EXPR,\n     IF_EXPR,\n     WHILE_EXPR,\n-    CONDITION,\n     LOOP_EXPR,\n     FOR_EXPR,\n     CONTINUE_EXPR,\n@@ -188,6 +187,7 @@ pub enum SyntaxKind {\n     STMT_LIST,\n     RETURN_EXPR,\n     YIELD_EXPR,\n+    LET_EXPR,\n     MATCH_EXPR,\n     MATCH_ARM_LIST,\n     MATCH_ARM,"}, {"sha": "6c4729ef3656ce0cbb159dd9b5e043115d17fe98", "filename": "crates/syntax/src/ast/generated/nodes.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fgenerated%2Fnodes.rs?ref=de8633f15fbfb2255d93c51e630a1e1854b1b746", "patch": "@@ -884,7 +884,7 @@ pub struct IfExpr {\n impl ast::HasAttrs for IfExpr {}\n impl IfExpr {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n-    pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n+    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }\n     pub fn else_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![else]) }\n }\n \n@@ -1038,7 +1038,7 @@ impl ast::HasAttrs for WhileExpr {}\n impl ast::HasLoopBody for WhileExpr {}\n impl WhileExpr {\n     pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }\n-    pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }\n+    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1051,6 +1051,18 @@ impl YieldExpr {\n     pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LetExpr {\n+    pub(crate) syntax: SyntaxNode,\n+}\n+impl ast::HasAttrs for LetExpr {}\n+impl LetExpr {\n+    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }\n+    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n+    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n+    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct StmtList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1106,17 +1118,6 @@ impl ArgList {\n     pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Condition {\n-    pub(crate) syntax: SyntaxNode,\n-}\n-impl Condition {\n-    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MatchArmList {\n     pub(crate) syntax: SyntaxNode,\n@@ -1147,10 +1148,7 @@ pub struct MatchGuard {\n }\n impl MatchGuard {\n     pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }\n-    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }\n-    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }\n-    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }\n-    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }\n+    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -1524,6 +1522,7 @@ pub enum Expr {\n     TupleExpr(TupleExpr),\n     WhileExpr(WhileExpr),\n     YieldExpr(YieldExpr),\n+    LetExpr(LetExpr),\n }\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n@@ -2664,6 +2663,17 @@ impl AstNode for YieldExpr {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n+impl AstNode for LetExpr {\n+    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_EXPR }\n+    fn cast(syntax: SyntaxNode) -> Option<Self> {\n+        if Self::can_cast(syntax.kind()) {\n+            Some(Self { syntax })\n+        } else {\n+            None\n+        }\n+    }\n+    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n+}\n impl AstNode for StmtList {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == STMT_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -2719,17 +2729,6 @@ impl AstNode for ArgList {\n     }\n     fn syntax(&self) -> &SyntaxNode { &self.syntax }\n }\n-impl AstNode for Condition {\n-    fn can_cast(kind: SyntaxKind) -> bool { kind == CONDITION }\n-    fn cast(syntax: SyntaxNode) -> Option<Self> {\n-        if Self::can_cast(syntax.kind()) {\n-            Some(Self { syntax })\n-        } else {\n-            None\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxNode { &self.syntax }\n-}\n impl AstNode for MatchArmList {\n     fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM_LIST }\n     fn cast(syntax: SyntaxNode) -> Option<Self> {\n@@ -3336,6 +3335,9 @@ impl From<WhileExpr> for Expr {\n impl From<YieldExpr> for Expr {\n     fn from(node: YieldExpr) -> Expr { Expr::YieldExpr(node) }\n }\n+impl From<LetExpr> for Expr {\n+    fn from(node: LetExpr) -> Expr { Expr::LetExpr(node) }\n+}\n impl AstNode for Expr {\n     fn can_cast(kind: SyntaxKind) -> bool {\n         match kind {\n@@ -3344,7 +3346,7 @@ impl AstNode for Expr {\n             | INDEX_EXPR | LITERAL | LOOP_EXPR | MACRO_CALL | MACRO_STMTS | MATCH_EXPR\n             | METHOD_CALL_EXPR | PAREN_EXPR | PATH_EXPR | PREFIX_EXPR | RANGE_EXPR\n             | RECORD_EXPR | REF_EXPR | RETURN_EXPR | TRY_EXPR | TUPLE_EXPR | WHILE_EXPR\n-            | YIELD_EXPR => true,\n+            | YIELD_EXPR | LET_EXPR => true,\n             _ => false,\n         }\n     }\n@@ -3381,6 +3383,7 @@ impl AstNode for Expr {\n             TUPLE_EXPR => Expr::TupleExpr(TupleExpr { syntax }),\n             WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),\n             YIELD_EXPR => Expr::YieldExpr(YieldExpr { syntax }),\n+            LET_EXPR => Expr::LetExpr(LetExpr { syntax }),\n             _ => return None,\n         };\n         Some(res)\n@@ -3418,6 +3421,7 @@ impl AstNode for Expr {\n             Expr::TupleExpr(it) => &it.syntax,\n             Expr::WhileExpr(it) => &it.syntax,\n             Expr::YieldExpr(it) => &it.syntax,\n+            Expr::LetExpr(it) => &it.syntax,\n         }\n     }\n }\n@@ -3883,6 +3887,7 @@ impl AstNode for AnyHasAttrs {\n             | TUPLE_EXPR\n             | WHILE_EXPR\n             | YIELD_EXPR\n+            | LET_EXPR\n             | STMT_LIST\n             | RECORD_EXPR_FIELD_LIST\n             | RECORD_EXPR_FIELD\n@@ -4537,6 +4542,11 @@ impl std::fmt::Display for YieldExpr {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n+impl std::fmt::Display for LetExpr {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        std::fmt::Display::fmt(self.syntax(), f)\n+    }\n+}\n impl std::fmt::Display for StmtList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)\n@@ -4562,11 +4572,6 @@ impl std::fmt::Display for ArgList {\n         std::fmt::Display::fmt(self.syntax(), f)\n     }\n }\n-impl std::fmt::Display for Condition {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        std::fmt::Display::fmt(self.syntax(), f)\n-    }\n-}\n impl std::fmt::Display for MatchArmList {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         std::fmt::Display::fmt(self.syntax(), f)"}, {"sha": "1a754ef46097dc719062b4b0aec80498b22c4bee", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=de8633f15fbfb2255d93c51e630a1e1854b1b746", "patch": "@@ -397,7 +397,7 @@ pub fn expr_match(expr: ast::Expr, match_arm_list: ast::MatchArmList) -> ast::Ex\n     expr_from_text(&format!(\"match {} {}\", expr, match_arm_list))\n }\n pub fn expr_if(\n-    condition: ast::Condition,\n+    condition: ast::Expr,\n     then_branch: ast::BlockExpr,\n     else_branch: Option<ast::ElseBranch>,\n ) -> ast::Expr {\n@@ -456,14 +456,8 @@ pub fn expr_assignment(lhs: ast::Expr, rhs: ast::Expr) -> ast::Expr {\n fn expr_from_text(text: &str) -> ast::Expr {\n     ast_from_text(&format!(\"const C: () = {};\", text))\n }\n-\n-pub fn condition(expr: ast::Expr, pattern: Option<ast::Pat>) -> ast::Condition {\n-    match pattern {\n-        None => ast_from_text(&format!(\"const _: () = while {} {{}};\", expr)),\n-        Some(pattern) => {\n-            ast_from_text(&format!(\"const _: () = while let {} = {} {{}};\", pattern, expr))\n-        }\n-    }\n+pub fn expr_let(pattern: ast::Pat, expr: ast::Expr) -> ast::LetExpr {\n+    ast_from_text(&format!(\"const _: () = while let {} = {} {{}};\", pattern, expr))\n }\n \n pub fn arg_list(args: impl IntoIterator<Item = ast::Expr>) -> ast::ArgList {"}, {"sha": "2915e7aab1a984a8023f30700a1aef842185489a", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=de8633f15fbfb2255d93c51e630a1e1854b1b746", "patch": "@@ -528,9 +528,39 @@ impl ast::Item {\n     }\n }\n \n-impl ast::Condition {\n+impl ast::Expr {\n+    /// Returns the `let` only if there is exactly one (that is, `let pat = expr`\n+    /// or `((let pat = expr))`, but not `let pat = expr && expr` or `non_let_expr`).\n+    pub fn single_let(&self) -> Option<ast::LetExpr> {\n+        return get_pat(self.clone());\n+\n+        fn get_pat(expr: ast::Expr) -> Option<ast::LetExpr> {\n+            match expr {\n+                ast::Expr::ParenExpr(expr) => expr.expr().and_then(get_pat),\n+                ast::Expr::LetExpr(expr) => Some(expr),\n+                _ => None,\n+            }\n+        }\n+    }\n+\n     pub fn is_pattern_cond(&self) -> bool {\n-        self.let_token().is_some()\n+        return contains_let(self.clone());\n+\n+        fn contains_let(expr: ast::Expr) -> bool {\n+            match expr {\n+                ast::Expr::BinExpr(expr)\n+                    if expr.op_kind() == Some(ast::BinaryOp::LogicOp(ast::LogicOp::And)) =>\n+                {\n+                    expr.lhs()\n+                        .map(contains_let)\n+                        .or_else(|| expr.rhs().map(contains_let))\n+                        .unwrap_or(false)\n+                }\n+                ast::Expr::ParenExpr(expr) => expr.expr().map_or(false, contains_let),\n+                ast::Expr::LetExpr(_) => true,\n+                _ => false,\n+            }\n+        }\n     }\n }\n "}, {"sha": "aeff851ce4d21200140bc704be67c0c989042dbb", "filename": "crates/syntax/src/tests/ast_src.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fsyntax%2Fsrc%2Ftests%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de8633f15fbfb2255d93c51e630a1e1854b1b746/crates%2Fsyntax%2Fsrc%2Ftests%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Ftests%2Fast_src.rs?ref=de8633f15fbfb2255d93c51e630a1e1854b1b746", "patch": "@@ -133,7 +133,6 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n         \"CLOSURE_EXPR\",\n         \"IF_EXPR\",\n         \"WHILE_EXPR\",\n-        \"CONDITION\",\n         \"LOOP_EXPR\",\n         \"FOR_EXPR\",\n         \"CONTINUE_EXPR\",\n@@ -143,6 +142,7 @@ pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {\n         \"STMT_LIST\",\n         \"RETURN_EXPR\",\n         \"YIELD_EXPR\",\n+        \"LET_EXPR\",\n         \"MATCH_EXPR\",\n         \"MATCH_ARM_LIST\",\n         \"MATCH_ARM\","}]}