{"sha": "f7be314579db29f64ef660aef1896da33d420ad6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YmUzMTQ1NzlkYjI5ZjY0ZWY2NjBhZWYxODk2ZGEzM2Q0MjBhZDY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-03-21T19:05:38Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-03-21T19:05:38Z"}, "message": "Align Canonical more with Chalk's version\n\nIn particular, use chalk_ir::CanonicalVarKinds.", "tree": {"sha": "24208e3429e80d578aed09b03ea0275820a13973", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24208e3429e80d578aed09b03ea0275820a13973"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7be314579db29f64ef660aef1896da33d420ad6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7be314579db29f64ef660aef1896da33d420ad6", "html_url": "https://github.com/rust-lang/rust/commit/f7be314579db29f64ef660aef1896da33d420ad6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7be314579db29f64ef660aef1896da33d420ad6/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d5c4a77fb33cab7bf8f9d2edc6dd26b09ef65f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5c4a77fb33cab7bf8f9d2edc6dd26b09ef65f3", "html_url": "https://github.com/rust-lang/rust/commit/1d5c4a77fb33cab7bf8f9d2edc6dd26b09ef65f3"}], "stats": {"total": 206, "additions": 125, "deletions": 81}, "files": [{"sha": "b7ab03edf831a525c7d8be2b26aa98949a261070", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=f7be314579db29f64ef660aef1896da33d420ad6", "patch": "@@ -56,9 +56,9 @@ use hir_ty::{\n     primitive::UintTy,\n     to_assoc_type_id,\n     traits::{FnTrait, Solution, SolutionVariables},\n-    AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, Cast, DebruijnIndex,\n-    InEnvironment, Interner, ProjectionTy, QuantifiedWhereClause, Scalar, Substitution, Ty,\n-    TyDefId, TyKind, TyVariableKind, WhereClause,\n+    AliasEq, AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast,\n+    DebruijnIndex, InEnvironment, Interner, ProjectionTy, QuantifiedWhereClause, Scalar,\n+    Substitution, Ty, TyDefId, TyKind, TyVariableKind, WhereClause,\n };\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n@@ -1723,7 +1723,10 @@ impl Type {\n             None => return false,\n         };\n \n-        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        let canonical_ty = Canonical {\n+            value: self.ty.value.clone(),\n+            binders: CanonicalVarKinds::empty(&Interner),\n+        };\n         method_resolution::implements_trait(\n             &canonical_ty,\n             db,\n@@ -1745,7 +1748,10 @@ impl Type {\n             None => return false,\n         };\n \n-        let canonical_ty = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        let canonical_ty = Canonical {\n+            value: self.ty.value.clone(),\n+            binders: CanonicalVarKinds::empty(&Interner),\n+        };\n         method_resolution::implements_trait_unique(\n             &canonical_ty,\n             db,\n@@ -1769,7 +1775,7 @@ impl Type {\n                 self.ty.environment.clone(),\n                 trait_ref.cast(&Interner),\n             ),\n-            kinds: Arc::new([]),\n+            binders: CanonicalVarKinds::empty(&Interner),\n         };\n \n         db.trait_solve(self.krate, goal).is_some()\n@@ -1786,8 +1792,8 @@ impl Type {\n             .push(self.ty.value.clone())\n             .fill(args.iter().map(|t| t.ty.value.clone()))\n             .build();\n-        let goal = Canonical {\n-            value: InEnvironment::new(\n+        let goal = Canonical::new(\n+            InEnvironment::new(\n                 self.ty.environment.clone(),\n                 AliasEq {\n                     alias: AliasTy::Projection(ProjectionTy {\n@@ -1799,8 +1805,8 @@ impl Type {\n                 }\n                 .cast(&Interner),\n             ),\n-            kinds: Arc::new([TyVariableKind::General]),\n-        };\n+            [TyVariableKind::General].iter().copied(),\n+        );\n \n         match db.trait_solve(self.krate, goal)? {\n             Solution::Unique(SolutionVariables(subst)) => {\n@@ -1911,7 +1917,10 @@ impl Type {\n     pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n-        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        let canonical = Canonical {\n+            value: self.ty.value.clone(),\n+            binders: CanonicalVarKinds::empty(&Interner),\n+        };\n         let environment = self.ty.environment.clone();\n         let ty = InEnvironment { value: canonical, environment };\n         autoderef(db, Some(self.krate), ty)\n@@ -1962,7 +1971,10 @@ impl Type {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        let canonical = Canonical {\n+            value: self.ty.value.clone(),\n+            binders: CanonicalVarKinds::empty(&Interner),\n+        };\n \n         let env = self.ty.environment.clone();\n         let krate = krate.id;\n@@ -1993,7 +2005,10 @@ impl Type {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = Canonical { value: self.ty.value.clone(), kinds: Arc::new([]) };\n+        let canonical = Canonical {\n+            value: self.ty.value.clone(),\n+            binders: CanonicalVarKinds::empty(&Interner),\n+        };\n \n         let env = self.ty.environment.clone();\n         let krate = krate.id;"}, {"sha": "d6f0553b16657c52597633ffa12257eb6983272d", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=f7be314579db29f64ef660aef1896da33d420ad6", "patch": "@@ -16,8 +16,8 @@ use crate::{\n     to_assoc_type_id, to_chalk_trait_id,\n     traits::{InEnvironment, Solution},\n     utils::generics,\n-    AliasEq, AliasTy, BoundVar, Canonical, DebruijnIndex, Interner, ProjectionTy, Substitution,\n-    TraitRef, Ty, TyKind,\n+    AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex, Interner,\n+    ProjectionTy, Substitution, TraitRef, Ty, TyKind,\n };\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n@@ -40,7 +40,7 @@ pub(crate) fn deref(\n     ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n     if let Some(derefed) = ty.value.value.builtin_deref() {\n-        Some(Canonical { value: derefed, kinds: ty.value.kinds.clone() })\n+        Some(Canonical { value: derefed, binders: ty.value.binders.clone() })\n     } else {\n         deref_by_trait(db, krate, ty)\n     }\n@@ -73,7 +73,7 @@ fn deref_by_trait(\n     let trait_ref =\n         TraitRef { trait_id: to_chalk_trait_id(deref_trait), substitution: parameters.clone() };\n     let implements_goal = Canonical {\n-        kinds: ty.value.kinds.clone(),\n+        binders: ty.value.binders.clone(),\n         value: InEnvironment {\n             value: trait_ref.cast(&Interner),\n             environment: ty.environment.clone(),\n@@ -89,18 +89,27 @@ fn deref_by_trait(\n             associated_ty_id: to_assoc_type_id(target),\n             substitution: parameters,\n         }),\n-        ty: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.kinds.len()))\n-            .intern(&Interner),\n+        ty: TyKind::BoundVar(BoundVar::new(\n+            DebruijnIndex::INNERMOST,\n+            ty.value.binders.len(&Interner),\n+        ))\n+        .intern(&Interner),\n     };\n \n     let obligation = projection.cast(&Interner);\n \n     let in_env = InEnvironment { value: obligation, environment: ty.environment };\n \n-    let canonical = Canonical::new(\n-        in_env,\n-        ty.value.kinds.iter().copied().chain(Some(chalk_ir::TyVariableKind::General)),\n-    );\n+    let canonical = Canonical {\n+        value: in_env,\n+        binders: CanonicalVarKinds::from_iter(\n+            &Interner,\n+            ty.value.binders.iter(&Interner).cloned().chain(Some(chalk_ir::WithKind::new(\n+                chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+                chalk_ir::UniverseIndex::ROOT,\n+            ))),\n+        ),\n+    };\n \n     let solution = db.trait_solve(krate, canonical)?;\n \n@@ -121,7 +130,7 @@ fn deref_by_trait(\n             // assumptions will be broken. We would need to properly introduce\n             // new variables in that case\n \n-            for i in 1..vars.0.kinds.len() {\n+            for i in 1..vars.0.binders.len(&Interner) {\n                 if vars.0.value[i - 1].interned(&Interner)\n                     != &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {\n@@ -131,7 +140,7 @@ fn deref_by_trait(\n             }\n             Some(Canonical {\n                 value: vars.0.value[vars.0.value.len() - 1].clone(),\n-                kinds: vars.0.kinds.clone(),\n+                binders: vars.0.binders.clone(),\n             })\n         }\n         Solution::Ambig(_) => {"}, {"sha": "7595b46cf299f363145e7b1175f0dbf21f13bc61", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=f7be314579db29f64ef660aef1896da33d420ad6", "patch": "@@ -2,13 +2,13 @@\n \n use std::borrow::Cow;\n \n-use chalk_ir::{FloatTy, IntTy, TyVariableKind};\n+use chalk_ir::{FloatTy, IntTy, TyVariableKind, UniverseIndex, VariableKind};\n use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n \n use super::{DomainGoal, InferenceContext};\n use crate::{\n-    AliasEq, AliasTy, BoundVar, Canonical, DebruijnIndex, FnPointer, InEnvironment, InferenceVar,\n-    Interner, Scalar, Substitution, Ty, TyKind, TypeWalk, WhereClause,\n+    AliasEq, AliasTy, BoundVar, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer,\n+    InEnvironment, InferenceVar, Interner, Scalar, Substitution, Ty, TyKind, TypeWalk, WhereClause,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -76,8 +76,17 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n     }\n \n     fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n-        let kinds = self.free_vars.iter().map(|&(_, k)| k).collect();\n-        Canonicalized { value: Canonical { value: result, kinds }, free_vars: self.free_vars }\n+        let kinds = self\n+            .free_vars\n+            .iter()\n+            .map(|&(_, k)| chalk_ir::WithKind::new(VariableKind::Ty(k), UniverseIndex::ROOT));\n+        Canonicalized {\n+            value: Canonical {\n+                value: result,\n+                binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n+            },\n+            free_vars: self.free_vars,\n+        }\n     }\n \n     pub(crate) fn canonicalize_ty(mut self, ty: Ty) -> Canonicalized<Ty> {\n@@ -125,12 +134,19 @@ impl<T> Canonicalized<T> {\n         // the solution may contain new variables, which we need to convert to new inference vars\n         let new_vars = Substitution(\n             solution\n-                .kinds\n-                .iter()\n-                .map(|k| match k {\n-                    TyVariableKind::General => ctx.table.new_type_var(),\n-                    TyVariableKind::Integer => ctx.table.new_integer_var(),\n-                    TyVariableKind::Float => ctx.table.new_float_var(),\n+                .binders\n+                .iter(&Interner)\n+                .map(|k| match k.kind {\n+                    VariableKind::Ty(TyVariableKind::General) => ctx.table.new_type_var(),\n+                    VariableKind::Ty(TyVariableKind::Integer) => ctx.table.new_integer_var(),\n+                    VariableKind::Ty(TyVariableKind::Float) => ctx.table.new_float_var(),\n+                    // HACK: Chalk can sometimes return new lifetime variables. We\n+                    // want to just skip them, but to not mess up the indices of\n+                    // other variables, we'll just create a new type variable in\n+                    // their place instead. This should not matter (we never see the\n+                    // actual *uses* of the lifetime variable).\n+                    VariableKind::Lifetime => ctx.table.new_type_var(),\n+                    _ => panic!(\"const variable in solution\"),\n                 })\n                 .collect(),\n         );\n@@ -147,8 +163,8 @@ impl<T> Canonicalized<T> {\n pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n     let mut table = InferenceTable::new();\n     let vars = Substitution(\n-        tys.kinds\n-            .iter()\n+        tys.binders\n+            .iter(&Interner)\n             // we always use type vars here because we want everything to\n             // fallback to Unknown in the end (kind of hacky, as below)\n             .map(|_| table.new_type_var())\n@@ -170,7 +186,7 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substitution> {\n         }\n     }\n     Some(\n-        Substitution::builder(tys.kinds.len())\n+        Substitution::builder(tys.binders.len(&Interner))\n             .fill(vars.iter().map(|v| table.resolve_ty_completely(v.clone())))\n             .build(),\n     )"}, {"sha": "0f49dd39b5d6a715f34229f50888e0b7420f6de4", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=f7be314579db29f64ef660aef1896da33d420ad6", "patch": "@@ -61,6 +61,8 @@ pub type ClosureId = chalk_ir::ClosureId<Interner>;\n pub type OpaqueTyId = chalk_ir::OpaqueTyId<Interner>;\n pub type PlaceholderIndex = chalk_ir::PlaceholderIndex;\n \n+pub type CanonicalVarKinds = chalk_ir::CanonicalVarKinds<Interner>;\n+\n pub type ChalkTraitId = chalk_ir::TraitId<Interner>;\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n@@ -662,12 +664,18 @@ impl QuantifiedWhereClauses {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Canonical<T> {\n     pub value: T,\n-    pub kinds: Arc<[TyVariableKind]>,\n+    pub binders: CanonicalVarKinds,\n }\n \n impl<T> Canonical<T> {\n     pub fn new(value: T, kinds: impl IntoIterator<Item = TyVariableKind>) -> Self {\n-        Self { value, kinds: kinds.into_iter().collect() }\n+        let kinds = kinds.into_iter().map(|tk| {\n+            chalk_ir::CanonicalVarKind::new(\n+                chalk_ir::VariableKind::Ty(tk),\n+                chalk_ir::UniverseIndex::ROOT,\n+            )\n+        });\n+        Self { value, binders: chalk_ir::CanonicalVarKinds::from_iter(&Interner, kinds) }\n     }\n }\n "}, {"sha": "0abe8f0a334dec56ce9325dfa81cff056441a270", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=f7be314579db29f64ef660aef1896da33d420ad6", "patch": "@@ -6,7 +6,7 @@ use std::{iter, sync::Arc};\n \n use arrayvec::ArrayVec;\n use base_db::CrateId;\n-use chalk_ir::{cast::Cast, Mutability};\n+use chalk_ir::{cast::Cast, Mutability, UniverseIndex};\n use hir_def::{\n     lang_item::LangItemTarget, AssocContainerId, AssocItemId, FunctionId, GenericDefId, HasModule,\n     ImplId, Lookup, ModuleId, TraitId,\n@@ -21,8 +21,9 @@ use crate::{\n     primitive::{self, FloatTy, IntTy, UintTy},\n     to_chalk_trait_id,\n     utils::all_super_traits,\n-    AdtId, Canonical, DebruijnIndex, FnPointer, FnSig, ForeignDefId, InEnvironment, Interner,\n-    Scalar, Substitution, TraitEnvironment, TraitRef, Ty, TyKind, TypeWalk,\n+    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, FnPointer, FnSig, ForeignDefId,\n+    InEnvironment, Interner, Scalar, Substitution, TraitEnvironment, TraitRef, Ty, TyKind,\n+    TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -443,7 +444,7 @@ fn iterate_method_candidates_with_autoref(\n         return true;\n     }\n     let refed = Canonical {\n-        kinds: deref_chain[0].kinds.clone(),\n+        binders: deref_chain[0].binders.clone(),\n         value: TyKind::Ref(Mutability::Not, deref_chain[0].value.clone()).intern(&Interner),\n     };\n     if iterate_method_candidates_by_receiver(\n@@ -459,7 +460,7 @@ fn iterate_method_candidates_with_autoref(\n         return true;\n     }\n     let ref_muted = Canonical {\n-        kinds: deref_chain[0].kinds.clone(),\n+        binders: deref_chain[0].binders.clone(),\n         value: TyKind::Ref(Mutability::Mut, deref_chain[0].value.clone()).intern(&Interner),\n     };\n     if iterate_method_candidates_by_receiver(\n@@ -677,19 +678,28 @@ pub(crate) fn inherent_impl_substs(\n     // we create a var for each type parameter of the impl; we need to keep in\n     // mind here that `self_ty` might have vars of its own\n     let vars = Substitution::build_for_def(db, impl_id)\n-        .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty.kinds.len())\n+        .fill_with_bound_vars(DebruijnIndex::INNERMOST, self_ty.binders.len(&Interner))\n         .build();\n     let self_ty_with_vars = db.impl_self_ty(impl_id).subst(&vars);\n-    let mut kinds = self_ty.kinds.to_vec();\n-    kinds.extend(iter::repeat(chalk_ir::TyVariableKind::General).take(vars.len()));\n-    let tys = Canonical { kinds: kinds.into(), value: (self_ty_with_vars, self_ty.value.clone()) };\n+    let mut kinds = self_ty.binders.interned().to_vec();\n+    kinds.extend(\n+        iter::repeat(chalk_ir::WithKind::new(\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+            UniverseIndex::ROOT,\n+        ))\n+        .take(vars.len()),\n+    );\n+    let tys = Canonical {\n+        binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n+        value: (self_ty_with_vars, self_ty.value.clone()),\n+    };\n     let substs = super::infer::unify(&tys);\n     // We only want the substs for the vars we added, not the ones from self_ty.\n     // Also, if any of the vars we added are still in there, we replace them by\n     // Unknown. I think this can only really happen if self_ty contained\n     // Unknown, and in that case we want the result to contain Unknown in those\n     // places again.\n-    substs.map(|s| fallback_bound_vars(s.suffix(vars.len()), self_ty.kinds.len()))\n+    substs.map(|s| fallback_bound_vars(s.suffix(vars.len()), self_ty.binders.len(&Interner)))\n }\n \n /// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n@@ -768,15 +778,24 @@ fn generic_implements_goal(\n     trait_: TraitId,\n     self_ty: Canonical<Ty>,\n ) -> Canonical<InEnvironment<super::DomainGoal>> {\n-    let mut kinds = self_ty.kinds.to_vec();\n+    let mut kinds = self_ty.binders.interned().to_vec();\n     let substs = super::Substitution::build_for_def(db, trait_)\n         .push(self_ty.value)\n         .fill_with_bound_vars(DebruijnIndex::INNERMOST, kinds.len())\n         .build();\n-    kinds.extend(iter::repeat(chalk_ir::TyVariableKind::General).take(substs.len() - 1));\n+    kinds.extend(\n+        iter::repeat(chalk_ir::WithKind::new(\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+            UniverseIndex::ROOT,\n+        ))\n+        .take(substs.len() - 1),\n+    );\n     let trait_ref = TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs };\n     let obligation = trait_ref.cast(&Interner);\n-    Canonical { kinds: kinds.into(), value: InEnvironment::new(env, obligation) }\n+    Canonical {\n+        binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n+        value: InEnvironment::new(env, obligation),\n+    }\n }\n \n fn autoderef_method_receiver(\n@@ -789,9 +808,9 @@ fn autoderef_method_receiver(\n     if let Some(TyKind::Array(parameters)) =\n         deref_chain.last().map(|ty| ty.value.interned(&Interner))\n     {\n-        let kinds = deref_chain.last().unwrap().kinds.clone();\n+        let kinds = deref_chain.last().unwrap().binders.clone();\n         let unsized_ty = TyKind::Slice(parameters.clone()).intern(&Interner);\n-        deref_chain.push(Canonical { value: unsized_ty, kinds })\n+        deref_chain.push(Canonical { value: unsized_ty, binders: kinds })\n     }\n     deref_chain\n }"}, {"sha": "58d8f28940a5b7ec575e6edda2a7709748cbe48d", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7be314579db29f64ef660aef1896da33d420ad6/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=f7be314579db29f64ef660aef1896da33d420ad6", "patch": "@@ -439,35 +439,12 @@ where\n     type Chalk = chalk_ir::Canonical<T::Chalk>;\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Canonical<T::Chalk> {\n-        let kinds = self.kinds.iter().map(|&tk| {\n-            chalk_ir::CanonicalVarKind::new(\n-                chalk_ir::VariableKind::Ty(tk),\n-                chalk_ir::UniverseIndex::ROOT,\n-            )\n-        });\n         let value = self.value.to_chalk(db);\n-        chalk_ir::Canonical {\n-            value,\n-            binders: chalk_ir::CanonicalVarKinds::from_iter(&Interner, kinds),\n-        }\n+        chalk_ir::Canonical { value, binders: self.binders }\n     }\n \n     fn from_chalk(db: &dyn HirDatabase, canonical: chalk_ir::Canonical<T::Chalk>) -> Canonical<T> {\n-        let kinds = canonical\n-            .binders\n-            .iter(&Interner)\n-            .map(|k| match k.kind {\n-                chalk_ir::VariableKind::Ty(tk) => tk,\n-                // HACK: Chalk can sometimes return new lifetime variables. We\n-                // want to just skip them, but to not mess up the indices of\n-                // other variables, we'll just create a new type variable in\n-                // their place instead. This should not matter (we never see the\n-                // actual *uses* of the lifetime variable).\n-                chalk_ir::VariableKind::Lifetime => chalk_ir::TyVariableKind::General,\n-                chalk_ir::VariableKind::Const(_) => panic!(\"unexpected const from Chalk\"),\n-            })\n-            .collect();\n-        Canonical { kinds, value: from_chalk(db, canonical.value) }\n+        Canonical { binders: canonical.binders, value: from_chalk(db, canonical.value) }\n     }\n }\n "}]}