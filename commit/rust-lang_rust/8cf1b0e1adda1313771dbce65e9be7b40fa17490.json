{"sha": "8cf1b0e1adda1313771dbce65e9be7b40fa17490", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZjFiMGUxYWRkYTEzMTM3NzFkYmNlNjVlOWJlN2I0MGZhMTc0OTA=", "commit": {"author": {"name": "Nathan Whitaker", "email": "nathan.whitaker01@gmail.com", "date": "2020-08-18T15:25:21Z"}, "committer": {"name": "Nathan Whitaker", "email": "nathan.whitaker01@gmail.com", "date": "2020-10-26T22:19:40Z"}, "message": "Uplift temporary-cstring-as-ptr into rustc", "tree": {"sha": "5aea160df91cc490d96b4b8fc02e7fe12adb1786", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5aea160df91cc490d96b4b8fc02e7fe12adb1786"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cf1b0e1adda1313771dbce65e9be7b40fa17490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf1b0e1adda1313771dbce65e9be7b40fa17490", "html_url": "https://github.com/rust-lang/rust/commit/8cf1b0e1adda1313771dbce65e9be7b40fa17490", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cf1b0e1adda1313771dbce65e9be7b40fa17490/comments", "author": {"login": "nathanwhit", "id": 17734409, "node_id": "MDQ6VXNlcjE3NzM0NDA5", "avatar_url": "https://avatars.githubusercontent.com/u/17734409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nathanwhit", "html_url": "https://github.com/nathanwhit", "followers_url": "https://api.github.com/users/nathanwhit/followers", "following_url": "https://api.github.com/users/nathanwhit/following{/other_user}", "gists_url": "https://api.github.com/users/nathanwhit/gists{/gist_id}", "starred_url": "https://api.github.com/users/nathanwhit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nathanwhit/subscriptions", "organizations_url": "https://api.github.com/users/nathanwhit/orgs", "repos_url": "https://api.github.com/users/nathanwhit/repos", "events_url": "https://api.github.com/users/nathanwhit/events{/privacy}", "received_events_url": "https://api.github.com/users/nathanwhit/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nathanwhit", "id": 17734409, "node_id": "MDQ6VXNlcjE3NzM0NDA5", "avatar_url": "https://avatars.githubusercontent.com/u/17734409?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nathanwhit", "html_url": "https://github.com/nathanwhit", "followers_url": "https://api.github.com/users/nathanwhit/followers", "following_url": "https://api.github.com/users/nathanwhit/following{/other_user}", "gists_url": "https://api.github.com/users/nathanwhit/gists{/gist_id}", "starred_url": "https://api.github.com/users/nathanwhit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nathanwhit/subscriptions", "organizations_url": "https://api.github.com/users/nathanwhit/orgs", "repos_url": "https://api.github.com/users/nathanwhit/repos", "events_url": "https://api.github.com/users/nathanwhit/events{/privacy}", "received_events_url": "https://api.github.com/users/nathanwhit/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c96e11c781af319199af77347d55f08085e15453", "url": "https://api.github.com/repos/rust-lang/rust/commits/c96e11c781af319199af77347d55f08085e15453", "html_url": "https://github.com/rust-lang/rust/commit/c96e11c781af319199af77347d55f08085e15453"}], "stats": {"total": 105, "additions": 105, "deletions": 0}, "files": [{"sha": "c8990842d32e695fbcdd7f85d442444fbf81cc46", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8cf1b0e1adda1313771dbce65e9be7b40fa17490/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf1b0e1adda1313771dbce65e9be7b40fa17490/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=8cf1b0e1adda1313771dbce65e9be7b40fa17490", "patch": "@@ -49,6 +49,7 @@ mod early;\n mod internal;\n mod late;\n mod levels;\n+mod methods;\n mod non_ascii_idents;\n mod nonstandard_style;\n mod passes;\n@@ -73,6 +74,7 @@ use rustc_span::Span;\n use array_into_iter::ArrayIntoIter;\n use builtin::*;\n use internal::*;\n+use methods::*;\n use non_ascii_idents::*;\n use nonstandard_style::*;\n use redundant_semicolon::*;\n@@ -160,6 +162,7 @@ macro_rules! late_lint_passes {\n                 ArrayIntoIter: ArrayIntoIter,\n                 ClashingExternDeclarations: ClashingExternDeclarations::new(),\n                 DropTraitConstraints: DropTraitConstraints,\n+                TemporaryCStringAsPtr: TemporaryCStringAsPtr,\n             ]\n         );\n     };"}, {"sha": "910e07154a7ec03be96745baa5dab836639b196a", "filename": "compiler/rustc_lint/src/methods.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8cf1b0e1adda1313771dbce65e9be7b40fa17490/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf1b0e1adda1313771dbce65e9be7b40fa17490/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fmethods.rs?ref=8cf1b0e1adda1313771dbce65e9be7b40fa17490", "patch": "@@ -0,0 +1,102 @@\n+use crate::LateContext;\n+use crate::LateLintPass;\n+use crate::LintContext;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_middle::ty;\n+use rustc_span::{\n+    symbol::{sym, Symbol, SymbolStr},\n+    ExpnKind, Span,\n+};\n+\n+declare_lint! {\n+    pub TEMPORARY_CSTRING_AS_PTR,\n+    Deny,\n+    \"detects getting the inner pointer of a temporary `CString`\"\n+}\n+\n+declare_lint_pass!(TemporaryCStringAsPtr => [TEMPORARY_CSTRING_AS_PTR]);\n+\n+/// Returns the method names and argument list of nested method call expressions that make up\n+/// `expr`. method/span lists are sorted with the most recent call first.\n+pub fn method_calls<'tcx>(\n+    expr: &'tcx Expr<'tcx>,\n+    max_depth: usize,\n+) -> (Vec<Symbol>, Vec<&'tcx [Expr<'tcx>]>, Vec<Span>) {\n+    let mut method_names = Vec::with_capacity(max_depth);\n+    let mut arg_lists = Vec::with_capacity(max_depth);\n+    let mut spans = Vec::with_capacity(max_depth);\n+\n+    let mut current = expr;\n+    for _ in 0..max_depth {\n+        if let ExprKind::MethodCall(path, span, args, _) = &current.kind {\n+            if args.iter().any(|e| e.span.from_expansion()) {\n+                break;\n+            }\n+            method_names.push(path.ident.name);\n+            arg_lists.push(&**args);\n+            spans.push(*span);\n+            current = &args[0];\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    (method_names, arg_lists, spans)\n+}\n+\n+fn in_macro(span: Span) -> bool {\n+    if span.from_expansion() {\n+        !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n+    } else {\n+        false\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for TemporaryCStringAsPtr {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if in_macro(expr.span) {\n+            return;\n+        }\n+\n+        let (method_names, arg_lists, _) = method_calls(expr, 2);\n+        let method_names: Vec<SymbolStr> = method_names.iter().map(|s| s.as_str()).collect();\n+        let method_names: Vec<&str> = method_names.iter().map(|s| &**s).collect();\n+\n+        if let [\"as_ptr\", \"unwrap\" | \"expect\"] = method_names.as_slice() {\n+            lint_cstring_as_ptr(cx, expr, &arg_lists[1][0], &arg_lists[0][0]);\n+        }\n+    }\n+}\n+\n+fn lint_cstring_as_ptr(\n+    cx: &LateContext<'_>,\n+    expr: &rustc_hir::Expr<'_>,\n+    source: &rustc_hir::Expr<'_>,\n+    unwrap: &rustc_hir::Expr<'_>,\n+) {\n+    let source_type = cx.typeck_results().expr_ty(source);\n+    if let ty::Adt(def, substs) = source_type.kind {\n+        if cx.tcx.is_diagnostic_item(Symbol::intern(\"result_type\"), def.did) {\n+            if let ty::Adt(adt, _) = substs.type_at(0).kind {\n+                let path = [\n+                    sym::std,\n+                    Symbol::intern(\"ffi\"),\n+                    Symbol::intern(\"c_str\"),\n+                    Symbol::intern(\"CString\"),\n+                ];\n+                if cx.match_def_path(adt.did, &path) {\n+                    cx.struct_span_lint(TEMPORARY_CSTRING_AS_PTR, expr.span, |diag| {\n+                        let mut diag = diag\n+                            .build(\"you are getting the inner pointer of a temporary `CString`\");\n+                        diag.note(\"that pointer will be invalid outside this expression\");\n+                        diag.span_help(\n+                            unwrap.span,\n+                            \"assign the `CString` to a variable to extend its lifetime\",\n+                        );\n+                        diag.emit();\n+                    });\n+                }\n+            }\n+        }\n+    }\n+}"}]}