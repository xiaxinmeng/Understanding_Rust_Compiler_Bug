{"sha": "16b8a41531bb0054f05be7a19e0867b8174c83b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2YjhhNDE1MzFiYjAwNTRmMDViZTdhMTllMDg2N2I4MTc0YzgzYjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-27T16:51:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-27T16:51:21Z"}, "message": "auto merge of #10026 : luqmana/rust/mut-pat, r=pcwalton\n\nFixes #9792.", "tree": {"sha": "6f41d27ea27c9b34e54a58875131e6a19c16e7cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f41d27ea27c9b34e54a58875131e6a19c16e7cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16b8a41531bb0054f05be7a19e0867b8174c83b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16b8a41531bb0054f05be7a19e0867b8174c83b1", "html_url": "https://github.com/rust-lang/rust/commit/16b8a41531bb0054f05be7a19e0867b8174c83b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16b8a41531bb0054f05be7a19e0867b8174c83b1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "950add4e49cc2ac5d60abd6da969392123ddcce0", "url": "https://api.github.com/repos/rust-lang/rust/commits/950add4e49cc2ac5d60abd6da969392123ddcce0", "html_url": "https://github.com/rust-lang/rust/commit/950add4e49cc2ac5d60abd6da969392123ddcce0"}, {"sha": "523a28decc9b165cccded3db754f645ce10c2040", "url": "https://api.github.com/repos/rust-lang/rust/commits/523a28decc9b165cccded3db754f645ce10c2040", "html_url": "https://github.com/rust-lang/rust/commit/523a28decc9b165cccded3db754f645ce10c2040"}], "stats": {"total": 392, "additions": 224, "deletions": 168}, "files": [{"sha": "36a49de87783bf2e39ca5d98ece20c499de24b81", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -730,7 +730,7 @@ impl<'self> GatherLoanCtxt<'self> {\n                                          loan_mutability,\n                                          scope_r);\n                   }\n-                  ast::BindInfer => {\n+                  ast::BindByValue(_) => {\n                       // No borrows here, but there may be moves\n                       if self.bccx.is_move(pat.id) {\n                           gather_moves::gather_move_from_pat("}, {"sha": "482ba43ae259ddbba93ea3ba8f7aee7a4eadbb99", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -884,7 +884,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                 BindByRef(_) => {\n                     by_ref_span = Some(span);\n                 }\n-                BindInfer => {\n+                BindByValue(_) => {\n                     if cx.moves_map.contains(&id) {\n                         any_by_move = true;\n                     }"}, {"sha": "fd5114889fddbe98045a60547db3936367d055d3", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -432,14 +432,12 @@ fn is_nullary_variant(cx: &Context, ex: @Expr) -> bool {\n \n fn check_imm_free_var(cx: &Context, def: Def, sp: Span) {\n     match def {\n-        DefLocal(_, is_mutbl) => {\n-            if is_mutbl {\n-                cx.tcx.sess.span_err(\n-                    sp,\n-                    \"mutable variables cannot be implicitly captured\");\n-            }\n+        DefLocal(_, BindByValue(MutMutable)) => {\n+            cx.tcx.sess.span_err(\n+                sp,\n+                \"mutable variables cannot be implicitly captured\");\n         }\n-        DefArg(*) => { /* ok */ }\n+        DefLocal(*) | DefArg(*) => { /* ok */ }\n         DefUpvar(_, def1, _, _) => { check_imm_free_var(cx, *def1, sp); }\n         DefBinding(*) | DefSelf(*) => { /*ok*/ }\n         _ => {"}, {"sha": "1ac14dfc4b1e5d35fa425fa88f13491146c1c2d0", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 19, "deletions": 41, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -813,27 +813,24 @@ fn check_unused_unsafe(cx: &Context, e: &ast::Expr) {\n }\n \n fn check_unused_mut_pat(cx: &Context, p: @ast::Pat) {\n-    let mut used = false;\n-    let mut bindings = 0;\n-    do pat_util::pat_bindings(cx.tcx.def_map, p) |_, id, _, _| {\n-        used = used || cx.tcx.used_mut_nodes.contains(&id);\n-        bindings += 1;\n-    }\n-    if !used {\n-        let msg = if bindings == 1 {\n-            \"variable does not need to be mutable\"\n-        } else {\n-            \"variables do not need to be mutable\"\n-        };\n-        cx.span_lint(unused_mut, p.span, msg);\n-    }\n-}\n-\n-fn check_unused_mut_fn_decl(cx: &Context, fd: &ast::fn_decl) {\n-    for arg in fd.inputs.iter() {\n-        if arg.is_mutbl {\n-            check_unused_mut_pat(cx, arg.pat);\n+    match p.node {\n+        ast::PatIdent(ast::BindByValue(ast::MutMutable), _, _) => {\n+            let mut used = false;\n+            let mut bindings = 0;\n+            do pat_util::pat_bindings(cx.tcx.def_map, p) |_, id, _, _| {\n+                used = used || cx.tcx.used_mut_nodes.contains(&id);\n+                bindings += 1;\n+            }\n+            if !used {\n+                let msg = if bindings == 1 {\n+                    \"variable does not need to be mutable\"\n+                } else {\n+                    \"variables do not need to be mutable\"\n+                };\n+                cx.span_lint(unused_mut, p.span, msg);\n+            }\n         }\n+        _ => ()\n     }\n }\n \n@@ -1075,6 +1072,8 @@ impl Visitor<()> for Context {\n \n     fn visit_pat(&mut self, p: @ast::Pat, _: ()) {\n         check_pat_non_uppercase_statics(self, p);\n+        check_unused_mut_pat(self, p);\n+\n         visit::walk_pat(self, p, ());\n     }\n \n@@ -1095,30 +1094,9 @@ impl Visitor<()> for Context {\n         visit::walk_stmt(self, s, ());\n     }\n \n-    fn visit_ty_method(&mut self, tm: &ast::TypeMethod, _: ()) {\n-        check_unused_mut_fn_decl(self, &tm.decl);\n-        visit::walk_ty_method(self, tm, ());\n-    }\n-\n-    fn visit_trait_method(&mut self, tm: &ast::trait_method, _: ()) {\n-        match *tm {\n-            ast::required(ref m) => check_unused_mut_fn_decl(self, &m.decl),\n-            ast::provided(ref m) => check_unused_mut_fn_decl(self, &m.decl)\n-        }\n-        visit::walk_trait_method(self, tm, ());\n-    }\n-\n-    fn visit_local(&mut self, l: @ast::Local, _: ()) {\n-        if l.is_mutbl {\n-            check_unused_mut_pat(self, l.pat);\n-        }\n-        visit::walk_local(self, l, ());\n-    }\n-\n     fn visit_fn(&mut self, fk: &visit::fn_kind, decl: &ast::fn_decl,\n                 body: &ast::Block, span: Span, id: ast::NodeId, _: ()) {\n         let recurse = |this: &mut Context| {\n-            check_unused_mut_fn_decl(this, decl);\n             visit::walk_fn(this, fk, decl, body, span, id, ());\n         };\n "}, {"sha": "e9e416124af9fb08fa42ca1634b31024c5b6bfbd", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -429,18 +429,22 @@ fn visit_fn(v: &mut LivenessVisitor,\n \n fn visit_local(v: &mut LivenessVisitor, local: @Local, this: @mut IrMaps) {\n     let def_map = this.tcx.def_map;\n-    do pat_util::pat_bindings(def_map, local.pat) |_bm, p_id, sp, path| {\n+    do pat_util::pat_bindings(def_map, local.pat) |bm, p_id, sp, path| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = ast_util::path_to_ident(path);\n         this.add_live_node_for_node(p_id, VarDefNode(sp));\n         let kind = match local.init {\n           Some(_) => FromLetWithInitializer,\n           None => FromLetNoInitializer\n         };\n+        let mutbl = match bm {\n+            BindByValue(MutMutable) => true,\n+            _ => false\n+        };\n         this.add_variable(Local(LocalInfo {\n           id: p_id,\n           ident: name,\n-          is_mutbl: local.is_mutbl,\n+          is_mutbl: mutbl,\n           kind: kind\n         }));\n     }\n@@ -454,11 +458,15 @@ fn visit_arm(v: &mut LivenessVisitor, arm: &Arm, this: @mut IrMaps) {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = ast_util::path_to_ident(path);\n+            let mutbl = match bm {\n+                BindByValue(MutMutable) => true,\n+                _ => false\n+            };\n             this.add_live_node_for_node(p_id, VarDefNode(sp));\n             this.add_variable(Local(LocalInfo {\n                 id: p_id,\n                 ident: name,\n-                is_mutbl: false,\n+                is_mutbl: mutbl,\n                 kind: FromMatch(bm)\n             }));\n         }"}, {"sha": "5e26201522c4111d44d5d570d83c8d7b689f983e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -473,12 +473,15 @@ impl mem_categorization_ctxt {\n               }\n           }\n \n-          ast::DefArg(vid, mutbl) => {\n+          ast::DefArg(vid, binding_mode) => {\n             // Idea: make this could be rewritten to model by-ref\n             // stuff as `&const` and `&mut`?\n \n             // m: mutability of the argument\n-            let m = if mutbl {McDeclared} else {McImmutable};\n+            let m = match binding_mode {\n+                ast::BindByValue(ast::MutMutable) => McDeclared,\n+                _ => McImmutable\n+            };\n             @cmt_ {\n                 id: id,\n                 span: span,\n@@ -548,25 +551,20 @@ impl mem_categorization_ctxt {\n               }\n           }\n \n-          ast::DefLocal(vid, mutbl) => {\n-            let m = if mutbl {McDeclared} else {McImmutable};\n-            @cmt_ {\n-                id:id,\n-                span:span,\n-                cat:cat_local(vid),\n-                mutbl:m,\n-                ty:expr_ty\n-            }\n-          }\n-\n-          ast::DefBinding(vid, _) => {\n+          ast::DefLocal(vid, binding_mode) |\n+          ast::DefBinding(vid, binding_mode) => {\n             // by-value/by-ref bindings are local variables\n+            let m = match binding_mode {\n+                ast::BindByValue(ast::MutMutable) => McDeclared,\n+                _ => McImmutable\n+            };\n+\n             @cmt_ {\n-                id:id,\n-                span:span,\n-                cat:cat_local(vid),\n-                mutbl:McImmutable,\n-                ty:expr_ty\n+                id: id,\n+                span: span,\n+                cat: cat_local(vid),\n+                mutbl: m,\n+                ty: expr_ty\n             }\n           }\n         }"}, {"sha": "d4dce789192d7195c8697b194ff88baa47b08f16", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -618,7 +618,7 @@ impl VisitContext {\n         do pat_bindings(self.tcx.def_map, pat) |bm, id, _span, path| {\n             let binding_moves = match bm {\n                 BindByRef(_) => false,\n-                BindInfer => {\n+                BindByValue(_) => {\n                     let pat_ty = ty::node_id_to_type(self.tcx, id);\n                     debug!(\"pattern {:?} {} type is {}\",\n                            id,"}, {"sha": "c16c39b5a09bab2bf7ddb444f5ba75d2a45a85ca", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -3817,11 +3817,8 @@ impl Resolver {\n                 Some(declaration) => {\n                     for argument in declaration.inputs.iter() {\n                         let binding_mode = ArgumentIrrefutableMode;\n-                        let mutability =\n-                            if argument.is_mutbl {Mutable} else {Immutable};\n                         this.resolve_pattern(argument.pat,\n                                              binding_mode,\n-                                             mutability,\n                                              None);\n \n                         this.resolve_type(&argument.ty);\n@@ -4036,8 +4033,6 @@ impl Resolver {\n     }\n \n     fn resolve_local(&mut self, local: @Local) {\n-        let mutability = if local.is_mutbl {Mutable} else {Immutable};\n-\n         // Resolve the type.\n         self.resolve_type(&local.ty);\n \n@@ -4052,7 +4047,7 @@ impl Resolver {\n         }\n \n         // Resolve the pattern.\n-        self.resolve_pattern(local.pat, LocalIrrefutableMode, mutability, None);\n+        self.resolve_pattern(local.pat, LocalIrrefutableMode, None);\n     }\n \n     // build a map from pattern identifiers to binding-info's.\n@@ -4116,8 +4111,7 @@ impl Resolver {\n \n         let bindings_list = @mut HashMap::new();\n         for pattern in arm.pats.iter() {\n-            self.resolve_pattern(*pattern, RefutableMode, Immutable,\n-                                 Some(bindings_list));\n+            self.resolve_pattern(*pattern, RefutableMode, Some(bindings_list));\n         }\n \n         // This has to happen *after* we determine which\n@@ -4261,7 +4255,6 @@ impl Resolver {\n     fn resolve_pattern(&mut self,\n                        pattern: @Pat,\n                        mode: PatternBindingMode,\n-                       mutability: Mutability,\n                        // Maps idents to the node ID for the (outermost)\n                        // pattern that binds them\n                        bindings_list: Option<@mut HashMap<Name,NodeId>>) {\n@@ -4324,8 +4317,6 @@ impl Resolver {\n                             debug!(\"(resolving pattern) binding `{}`\",\n                                    interner_get(renamed));\n \n-                            let is_mutable = mutability == Mutable;\n-\n                             let def = match mode {\n                                 RefutableMode => {\n                                     // For pattern arms, we must use\n@@ -4335,11 +4326,11 @@ impl Resolver {\n                                 }\n                                 LocalIrrefutableMode => {\n                                     // But for locals, we use `def_local`.\n-                                    DefLocal(pattern.id, is_mutable)\n+                                    DefLocal(pattern.id, binding_mode)\n                                 }\n                                 ArgumentIrrefutableMode => {\n                                     // And for function arguments, `def_arg`.\n-                                    DefArg(pattern.id, is_mutable)\n+                                    DefArg(pattern.id, binding_mode)\n                                 }\n                             };\n \n@@ -5361,7 +5352,7 @@ impl Resolver {\n                                         pat_binding_mode: BindingMode,\n                                         descr: &str) {\n         match pat_binding_mode {\n-            BindInfer => {}\n+            BindByValue(_) => {}\n             BindByRef(*) => {\n                 self.resolve_error(\n                     pat.span,"}, {"sha": "a36d938052a9175b7b2736b29218248fe2da30ae", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -1842,7 +1842,7 @@ fn create_bindings_map(bcx: @mut Block, pat: @ast::Pat) -> BindingsMap {\n         let llmatch;\n         let trmode;\n         match bm {\n-            ast::BindInfer => {\n+            ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n@@ -2130,7 +2130,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                     bcx, pat.id, path, binding_mode,\n                     |bcx, variable_ty, llvariable_val| {\n                         match pat_binding_mode {\n-                            ast::BindInfer => {\n+                            ast::BindByValue(_) => {\n                                 // By value binding: move the value that `val`\n                                 // points at into the binding's stack slot.\n                                 let datum = Datum {val: val,\n@@ -2241,7 +2241,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n \n fn simple_identifier<'a>(pat: &'a ast::Pat) -> Option<&'a ast::Path> {\n     match pat.node {\n-        ast::PatIdent(ast::BindInfer, ref path, None) => {\n+        ast::PatIdent(ast::BindByValue(_), ref path, None) => {\n             Some(path)\n         }\n         _ => {"}, {"sha": "74f9e2114e10c26140a23191ba83777d5505218c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -2065,7 +2065,6 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     // Translate variant arguments to function arguments.\n     let fn_args = do args.map |varg| {\n         ast::arg {\n-            is_mutbl: false,\n             ty: (*varg.ty()).clone(),\n             pat: ast_util::ident_to_pat(\n                 ccx.tcx.sess.next_node_id(),"}, {"sha": "93c3d94f5dc69b7a661d47e4b1f448d3fac4f137", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -476,7 +476,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n             demand::eqtype(fcx, pat.span, region_ty, typ);\n           }\n           // otherwise the type of x is the expected type T\n-          ast::BindInfer => {\n+          ast::BindByValue(_) => {\n             demand::eqtype(fcx, pat.span, expected, typ);\n           }\n         }"}, {"sha": "6647c4c811ec36386f3d1ec58d7a5f4e7c2d908f", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -232,8 +232,8 @@ pub enum Def {\n     DefMod(DefId),\n     DefForeignMod(DefId),\n     DefStatic(DefId, bool /* is_mutbl */),\n-    DefArg(NodeId, bool /* is_mutbl */),\n-    DefLocal(NodeId, bool /* is_mutbl */),\n+    DefArg(NodeId, BindingMode),\n+    DefLocal(NodeId, BindingMode),\n     DefVariant(DefId /* enum */, DefId /* variant */, bool /* is_structure */),\n     DefTy(DefId),\n     DefTrait(DefId),\n@@ -324,7 +324,7 @@ pub struct FieldPat {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum BindingMode {\n     BindByRef(Mutability),\n-    BindInfer\n+    BindByValue(Mutability),\n }\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n@@ -445,7 +445,6 @@ pub enum Stmt_ {\n // a refinement on pat.\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct Local {\n-    is_mutbl: bool,\n     ty: Ty,\n     pat: @Pat,\n     init: Option<@Expr>,\n@@ -880,7 +879,6 @@ pub struct inline_asm {\n \n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub struct arg {\n-    is_mutbl: bool,\n     ty: Ty,\n     pat: @Pat,\n     id: NodeId,"}, {"sha": "3ec87dbdd26fba67871318acdb821c5071b9e8b7", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -234,7 +234,7 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n \n pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> @Pat {\n     @ast::Pat { id: id,\n-                node: PatIdent(BindInfer, ident_to_path(s, i), None),\n+                node: PatIdent(BindByValue(MutImmutable), ident_to_path(s, i), None),\n                 span: s }\n }\n "}, {"sha": "4c3ab840b440f314d2ad034431cd8ad283914795", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -399,9 +399,12 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::Expr) -> @ast::Stmt {\n-        let pat = self.pat_ident(sp, ident);\n+        let pat = if mutbl {\n+            self.pat_ident_binding_mode(sp, ident, ast::BindByValue(ast::MutMutable))\n+        } else {\n+            self.pat_ident(sp, ident)\n+        };\n         let local = @ast::Local {\n-            is_mutbl: mutbl,\n             ty: self.ty_infer(sp),\n             pat: pat,\n             init: Some(ex),\n@@ -419,9 +422,12 @@ impl AstBuilder for @ExtCtxt {\n                       typ: ast::Ty,\n                       ex: @ast::Expr)\n                       -> @ast::Stmt {\n-        let pat = self.pat_ident(sp, ident);\n+        let pat = if mutbl {\n+            self.pat_ident_binding_mode(sp, ident, ast::BindByValue(ast::MutMutable))\n+        } else {\n+            self.pat_ident(sp, ident)\n+        };\n         let local = @ast::Local {\n-            is_mutbl: mutbl,\n             ty: typ,\n             pat: pat,\n             init: Some(ex),\n@@ -624,7 +630,7 @@ impl AstBuilder for @ExtCtxt {\n         self.pat(span, ast::PatLit(expr))\n     }\n     fn pat_ident(&self, span: Span, ident: ast::Ident) -> @ast::Pat {\n-        self.pat_ident_binding_mode(span, ident, ast::BindInfer)\n+        self.pat_ident_binding_mode(span, ident, ast::BindByValue(ast::MutImmutable))\n     }\n \n     fn pat_ident_binding_mode(&self,\n@@ -710,7 +716,6 @@ impl AstBuilder for @ExtCtxt {\n     fn arg(&self, span: Span, ident: ast::Ident, ty: ast::Ty) -> ast::arg {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::arg {\n-            is_mutbl: false,\n             ty: ty,\n             pat: arg_pat,\n             id: ast::DUMMY_NODE_ID"}, {"sha": "82a779546fcea0020bf5a9dadd6585bdccbea6d6", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -922,7 +922,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n     if struct_def.fields.is_empty() {\n         return (\n             cx.pat_ident_binding_mode(\n-                span, struct_ident, ast::BindInfer),\n+                span, struct_ident, ast::BindByValue(ast::MutImmutable)),\n             ~[]);\n     }\n \n@@ -985,7 +985,7 @@ fn create_enum_variant_pattern(cx: @ExtCtxt,\n         ast::tuple_variant_kind(ref variant_args) => {\n             if variant_args.is_empty() {\n                 return (cx.pat_ident_binding_mode(\n-                    span, variant_ident, ast::BindInfer), ~[]);\n+                    span, variant_ident, ast::BindByValue(ast::MutImmutable)), ~[]);\n             }\n \n             let matching_path = cx.path_ident(span, variant_ident);"}, {"sha": "9526357f9ae8e7bc952d2ec60f2cd139e342f33b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -551,13 +551,13 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n             let pending_renames = block_info.pending_renames;\n \n             // take it apart:\n-            let @Local{is_mutbl:is_mutbl,\n-                       ty:_,\n-                       pat:pat,\n-                       init:init,\n-                       id:id,\n-                       span:span\n-                      } = *local;\n+            let @Local {\n+                ty: _,\n+                pat: pat,\n+                init: init,\n+                id: id,\n+                span: span\n+            } = *local;\n             // types can't be copied automatically because of the owned ptr in ty_tup...\n             let ty = local.ty.clone();\n             // expand the pat (it might contain exprs... #:(o)>\n@@ -585,7 +585,6 @@ fn expand_non_macro_stmt(exts: SyntaxEnv, s: &Stmt, fld: &MacroExpander)\n             let new_init_opt = init.map(|e| fld.fold_expr(e));\n             let rewritten_local =\n                 @Local {\n-                    is_mutbl: is_mutbl,\n                     ty: ty,\n                     pat: rewritten_pat,\n                     init: new_init_opt,"}, {"sha": "e9ecb95c54530038ea2fac1ea76a7f437ed21dba", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -356,7 +356,6 @@ pub trait ast_fold {\n \n     fn fold_local(&self, l: @Local) -> @Local {\n         @Local {\n-            is_mutbl: l.is_mutbl,\n             ty: self.fold_ty(&l.ty),\n             pat: self.fold_pat(l.pat),\n             init: l.init.map(|e| self.fold_expr(e)),\n@@ -426,7 +425,6 @@ fn fold_attribute_<T:ast_fold>(at: Attribute, fld: &T) -> Attribute {\n //used in noop_fold_foreign_item and noop_fold_fn_decl\n fn fold_arg_<T:ast_fold>(a: &arg, fld: &T) -> arg {\n     ast::arg {\n-        is_mutbl: a.is_mutbl,\n         ty: fld.fold_ty(&a.ty),\n         pat: fld.fold_pat(a.pat),\n         id: fld.new_id(a.id),"}, {"sha": "0de571978a0e42b64e8f4931732490b0ec1047d7", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -639,7 +639,7 @@ mod test {\n         assert_eq!(parser.parse_pat(),\n                    @ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent(\n-                                ast::BindInfer,\n+                                ast::BindByValue(ast::MutImmutable),\n                                 ast::Path {\n                                     span:sp(0,1),\n                                     global:false,\n@@ -666,7 +666,6 @@ mod test {\n                             id: ast::DUMMY_NODE_ID,\n                             node: ast::item_fn(ast::fn_decl{\n                                 inputs: ~[ast::arg{\n-                                    is_mutbl: false,\n                                     ty: ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ty_path(ast::Path{\n                                         span:sp(10,13),\n@@ -685,7 +684,7 @@ mod test {\n                                     pat: @ast::Pat {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: ast::PatIdent(\n-                                            ast::BindInfer,\n+                                            ast::BindByValue(ast::MutImmutable),\n                                             ast::Path {\n                                                 span:sp(6,7),\n                                                 global:false,"}, {"sha": "20ad13dace61cac672a05f330d7519b7ed8d32a9", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -34,7 +34,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteBareFnType,\n     ObsoleteNamedExternModule,\n     ObsoleteMultipleLocalDecl,\n-    ObsoleteMutWithMultipleBindings,\n     ObsoleteUnsafeExternFn,\n     ObsoleteTraitFuncVisibility,\n     ObsoleteConstPointer,\n@@ -91,11 +90,6 @@ impl ParserObsoleteMethods for Parser {\n                 \"instead of e.g. `let a = 1, b = 2`, write \\\n                  `let (a, b) = (1, 2)`.\"\n             ),\n-            ObsoleteMutWithMultipleBindings => (\n-                \"`mut` with multiple bindings\",\n-                \"use multiple local declarations instead of e.g. `let mut \\\n-                 (x, y) = ...`.\"\n-            ),\n             ObsoleteUnsafeExternFn => (\n                 \"unsafe external function\",\n                 \"external functions are always unsafe; remove the `unsafe` \\"}, {"sha": "5a5e310e56f43c4a75e6abe79b3d9383fdf36065", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 35, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -17,7 +17,7 @@ use ast::{CallSugar, NoSugar, DoSugar};\n use ast::{TyBareFn, TyClosure};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, purity};\n-use ast::{_mod, BiAdd, arg, Arm, Attribute, BindByRef, BindInfer};\n+use ast::{_mod, BiAdd, arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, Block};\n use ast::{BlockCheckMode, UnBox};\n use ast::{Crate, CrateConfig, Decl, DeclItem};\n@@ -1184,15 +1184,8 @@ impl Parser {\n     pub fn is_named_argument(&self) -> bool {\n         let offset = match *self.token {\n             token::BINOP(token::AND) => 1,\n-            token::BINOP(token::MINUS) => 1,\n             token::ANDAND => 1,\n-            token::BINOP(token::PLUS) => {\n-                if self.look_ahead(1, |t| *t == token::BINOP(token::PLUS)) {\n-                    2\n-                } else {\n-                    1\n-                }\n-            },\n+            _ if token::is_keyword(keywords::Mut, self.token) => 1,\n             _ => 0\n         };\n \n@@ -1210,16 +1203,11 @@ impl Parser {\n     // This version of parse arg doesn't necessarily require\n     // identifier names.\n     pub fn parse_arg_general(&self, require_name: bool) -> arg {\n-        let is_mutbl = self.eat_keyword(keywords::Mut);\n         let pat = if require_name || self.is_named_argument() {\n             debug!(\"parse_arg_general parse_pat (require_name:{:?})\",\n                    require_name);\n             let pat = self.parse_pat();\n \n-            if is_mutbl && !ast_util::pat_is_ident(pat) {\n-                self.obsolete(*self.span, ObsoleteMutWithMultipleBindings)\n-            }\n-\n             self.expect(&token::COLON);\n             pat\n         } else {\n@@ -1232,7 +1220,6 @@ impl Parser {\n         let t = self.parse_ty(false);\n \n         ast::arg {\n-            is_mutbl: is_mutbl,\n             ty: t,\n             pat: pat,\n             id: ast::DUMMY_NODE_ID,\n@@ -1246,7 +1233,6 @@ impl Parser {\n \n     // parse an argument in a lambda header e.g. |arg, arg|\n     pub fn parse_fn_block_arg(&self) -> arg {\n-        let is_mutbl = self.eat_keyword(keywords::Mut);\n         let pat = self.parse_pat();\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n@@ -1258,7 +1244,6 @@ impl Parser {\n             }\n         };\n         ast::arg {\n-            is_mutbl: is_mutbl,\n             ty: t,\n             pat: pat,\n             id: ast::DUMMY_NODE_ID\n@@ -1809,7 +1794,7 @@ impl Parser {\n                 return self.mk_mac_expr(lo, hi, mac_invoc_tt(pth, tts, EMPTY_CTXT));\n             } else if *self.token == token::LBRACE {\n                 // This might be a struct literal.\n-                if self.looking_at_record_literal() {\n+                if self.looking_at_struct_literal() {\n                     // It's a struct literal.\n                     self.bump();\n                     let mut fields = ~[];\n@@ -2520,12 +2505,11 @@ impl Parser {\n         }\n     }\n \n-    // For distingishing between record literals and blocks\n-    fn looking_at_record_literal(&self) -> bool {\n+    // For distingishing between struct literals and blocks\n+    fn looking_at_struct_literal(&self) -> bool {\n         *self.token == token::LBRACE &&\n-            (self.look_ahead(1, |t| token::is_keyword(keywords::Mut, t)) ||\n-             (self.look_ahead(1, |t| token::is_plain_ident(t)) &&\n-              self.look_ahead(2, |t| *t == token::COLON)))\n+        (self.look_ahead(1, |t| token::is_plain_ident(t)) &&\n+         self.look_ahead(2, |t| *t == token::COLON))\n     }\n \n     fn parse_match_expr(&self) -> @Expr {\n@@ -2681,7 +2665,7 @@ impl Parser {\n             } else {\n                 subpat = @ast::Pat {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: PatIdent(BindInfer, fieldpath, None),\n+                    node: PatIdent(BindByValue(MutImmutable), fieldpath, None),\n                     span: *self.last_span\n                 };\n             }\n@@ -2863,6 +2847,8 @@ impl Parser {\n             } else {\n                 pat = PatLit(val);\n             }\n+        } else if self.eat_keyword(keywords::Mut) {\n+            pat = self.parse_pat_ident(BindByValue(MutMutable));\n         } else if self.eat_keyword(keywords::Ref) {\n             // parse ref pat\n             let mutbl = self.parse_mutability();\n@@ -2891,7 +2877,7 @@ impl Parser {\n                     // or just foo\n                     sub = None;\n                 }\n-                pat = PatIdent(BindInfer, name, sub);\n+                pat = PatIdent(BindByValue(MutImmutable), name, sub);\n             } else {\n                 // parse an enum pat\n                 let enum_path = self.parse_path(LifetimeAndTypesWithColons)\n@@ -2935,7 +2921,7 @@ impl Parser {\n                                   // it could still be either an enum\n                                   // or an identifier pattern, resolve\n                                   // will sort it out:\n-                                  pat = PatIdent(BindInfer,\n+                                  pat = PatIdent(BindByValue(MutImmutable),\n                                                   enum_path,\n                                                   None);\n                               } else {\n@@ -2989,14 +2975,10 @@ impl Parser {\n     }\n \n     // parse a local variable declaration\n-    fn parse_local(&self, is_mutbl: bool) -> @Local {\n+    fn parse_local(&self) -> @Local {\n         let lo = self.span.lo;\n         let pat = self.parse_pat();\n \n-        if is_mutbl && !ast_util::pat_is_ident(pat) {\n-            self.obsolete(*self.span, ObsoleteMutWithMultipleBindings)\n-        }\n-\n         let mut ty = Ty {\n             id: ast::DUMMY_NODE_ID,\n             node: ty_infer,\n@@ -3005,7 +2987,6 @@ impl Parser {\n         if self.eat(&token::COLON) { ty = self.parse_ty(false); }\n         let init = self.parse_initializer();\n         @ast::Local {\n-            is_mutbl: is_mutbl,\n             ty: ty,\n             pat: pat,\n             init: init,\n@@ -3016,11 +2997,10 @@ impl Parser {\n \n     // parse a \"let\" stmt\n     fn parse_let(&self) -> @Decl {\n-        let is_mutbl = self.eat_keyword(keywords::Mut);\n         let lo = self.span.lo;\n-        let local = self.parse_local(is_mutbl);\n+        let local = self.parse_local();\n         while self.eat(&token::COMMA) {\n-            let _ = self.parse_local(is_mutbl);\n+            let _ = self.parse_local();\n             self.obsolete(*self.span, ObsoleteMultipleLocalDecl);\n         }\n         return @spanned(lo, self.last_span.hi, DeclLocal(local));"}, {"sha": "121934119107e56e217fbbfeeab63c40886e75b5", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -1476,10 +1476,6 @@ pub fn print_decl(s: @ps, decl: &ast::Decl) {\n         ibox(s, indent_unit);\n         word_nbsp(s, \"let\");\n \n-        if loc.is_mutbl {\n-            word_nbsp(s, \"mut\");\n-        }\n-\n         fn print_local(s: @ps, loc: &ast::Local) {\n             ibox(s, indent_unit);\n             print_local_decl(s, loc);\n@@ -1589,7 +1585,10 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n                   word_nbsp(s, \"ref\");\n                   print_mutability(s, mutbl);\n               }\n-              ast::BindInfer => {}\n+              ast::BindByValue(ast::MutImmutable) => {}\n+              ast::BindByValue(ast::MutMutable) => {\n+                  word_nbsp(s, \"mut\");\n+              }\n           }\n           print_path(s, path, true);\n           match sub {\n@@ -1932,9 +1931,6 @@ pub fn print_mt(s: @ps, mt: &ast::mt) {\n \n pub fn print_arg(s: @ps, input: &ast::arg) {\n     ibox(s, indent_unit);\n-    if input.is_mutbl {\n-        word_space(s, \"mut\");\n-    }\n     match input.ty.node {\n       ast::ty_infer => print_pat(s, input.pat),\n       _ => {"}, {"sha": "4b382a3116a6bb23817c1692279bc5342a721efc", "filename": "src/test/compile-fail/lint-unused-mut-variables.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-mut-variables.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -20,6 +20,14 @@ fn main() {\n     let mut a = 2; //~ ERROR: variable does not need to be mutable\n     let mut b = 3; //~ ERROR: variable does not need to be mutable\n     let mut a = ~[3]; //~ ERROR: variable does not need to be mutable\n+    let (mut a, b) = (1, 2); //~ ERROR: variable does not need to be mutable\n+\n+    match 30 {\n+        mut x => {} //~ ERROR: variable does not need to be mutable\n+    }\n+\n+    let x = |mut y: int| 10; //~ ERROR: variable does not need to be mutable\n+    fn what(mut foo: int) {} //~ ERROR: variable does not need to be mutable\n \n     // positive cases\n     let mut a = 2;\n@@ -30,6 +38,17 @@ fn main() {\n     do callback {\n         a.push(3);\n     }\n+    let (mut a, b) = (1, 2);\n+    a = 34;\n+\n+    match 30 {\n+        mut x => {\n+            x = 21;\n+        }\n+    }\n+\n+    let x = |mut y: int| y = 32;\n+    fn nothing(mut foo: int) { foo = 37; }\n }\n \n fn callback(f: &fn()) {}"}, {"sha": "d9cdae4a4995fd5b5a6ebd780aab635f184c65e7", "filename": "src/test/compile-fail/mut-patterns.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Ftest%2Fcompile-fail%2Fmut-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Ftest%2Fcompile-fail%2Fmut-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmut-patterns.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Can't put mut in non-ident pattern\n+\n+pub fn main() {\n+    struct Foo { x: int }\n+    let mut Foo { x: x } = Foo { x: 3 }; //~ ERROR: expected `;` but found `{`\n+}"}, {"sha": "13303e7b108819481e33435615df81405530b6c7", "filename": "src/test/run-pass/mut-in-ident-patterns.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Ftest%2Frun-pass%2Fmut-in-ident-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16b8a41531bb0054f05be7a19e0867b8174c83b1/src%2Ftest%2Frun-pass%2Fmut-in-ident-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmut-in-ident-patterns.rs?ref=16b8a41531bb0054f05be7a19e0867b8174c83b1", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Foo {\n+    fn foo(&self, mut x: int) -> int {\n+        let val = x;\n+        x = 37 * x;\n+        val + x\n+    }\n+}\n+\n+struct X;\n+impl Foo for X {}\n+\n+pub fn main() {\n+    let (a, mut b) = (23, 4);\n+    assert_eq!(a, 23);\n+    assert_eq!(b, 4);\n+    b = a + b;\n+    assert_eq!(b, 27);\n+\n+\n+    assert_eq!(X.foo(2), 76);\n+\n+    enum Bar {\n+       Foo(int),\n+       Baz(f32, u8)\n+    }\n+\n+    let (x, mut y) = (32, Foo(21));\n+\n+    match x {\n+        mut z @ 32 => {\n+            assert_eq!(z, 32);\n+            z = 34;\n+            assert_eq!(z, 34);\n+        }\n+        _ => {}\n+    }\n+\n+    check_bar(&y);\n+    y = Baz(10.0, 3);\n+    check_bar(&y);\n+\n+    fn check_bar(y: &Bar) {\n+        match y {\n+            &Foo(a) => {\n+                assert_eq!(a, 21);\n+            }\n+            &Baz(a, b) => {\n+                assert_eq!(a, 10.0);\n+                assert_eq!(b, 3);\n+            }\n+        }\n+    }\n+\n+    fn foo1((x, mut y): (f64, int), mut z: int) -> int {\n+        y = 2 * 6;\n+        z = y + (x as int);\n+        y - z\n+    }\n+\n+    struct A {\n+        x: int\n+    }\n+    let A { x: mut x } = A { x: 10 };\n+    assert_eq!(x, 10);\n+    x = 30;\n+    assert_eq!(x, 30);\n+\n+    (|A { x: mut t }: A| { t = t+1; t })(A { x: 34 });\n+\n+}"}]}