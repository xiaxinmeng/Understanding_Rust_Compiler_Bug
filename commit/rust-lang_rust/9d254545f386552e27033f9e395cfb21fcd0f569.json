{"sha": "9d254545f386552e27033f9e395cfb21fcd0f569", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMjU0NTQ1ZjM4NjU1MmUyNzAzM2Y5ZTM5NWNmYjIxZmNkMGY1Njk=", "commit": {"author": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2020-02-14T05:42:10Z"}, "committer": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2020-02-19T18:21:18Z"}, "message": "Migrate to generic dataflow", "tree": {"sha": "9620ee738c140c07685a1e9cc8d23f2191e165b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9620ee738c140c07685a1e9cc8d23f2191e165b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d254545f386552e27033f9e395cfb21fcd0f569", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d254545f386552e27033f9e395cfb21fcd0f569", "html_url": "https://github.com/rust-lang/rust/commit/9d254545f386552e27033f9e395cfb21fcd0f569", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d254545f386552e27033f9e395cfb21fcd0f569/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c5c054e4cb59fe05f574ae6322794f93569dd8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c5c054e4cb59fe05f574ae6322794f93569dd8b", "html_url": "https://github.com/rust-lang/rust/commit/1c5c054e4cb59fe05f574ae6322794f93569dd8b"}], "stats": {"total": 81, "additions": 36, "deletions": 45}, "files": [{"sha": "e419ae09a3f96edbf698db9b7cbef8bebe006c66", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9d254545f386552e27033f9e395cfb21fcd0f569/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d254545f386552e27033f9e395cfb21fcd0f569/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=9d254545f386552e27033f9e395cfb21fcd0f569", "patch": "@@ -15,9 +15,8 @@ use rustc_hir::intravisit::FnKind;\n use rustc_hir::{def_id, Body, FnDecl, HirId};\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_mir::dataflow::{\n-    do_dataflow, BitDenotation, BottomValue, DataflowResults, DataflowResultsCursor, DebugFormatted, GenKillSet,\n-};\n+use rustc_mir::dataflow::generic::{Analysis, AnalysisDomain, GenKill, GenKillAnalysis, ResultsCursor};\n+use rustc_mir::dataflow::BottomValue;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{BytePos, Span};\n use std::convert::TryFrom;\n@@ -83,16 +82,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n         let mir = cx.tcx.optimized_mir(def_id);\n         let mir_read_only = mir.unwrap_read_only();\n \n-        let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n-        let maybe_storage_live_result = do_dataflow(\n-            cx.tcx,\n-            mir,\n-            def_id,\n-            &[],\n-            &dead_unwinds,\n-            MaybeStorageLive::new(mir),\n-            |bd, p| DebugFormatted::new(&bd.body.local_decls[p]),\n-        );\n+        let maybe_storage_live_result = MaybeStorageLive\n+            .into_engine(cx.tcx, mir, def_id)\n+            .iterate_to_fixpoint()\n+            .into_results_cursor(mir);\n         let mut possible_borrower = {\n             let mut vis = PossibleBorrowerVisitor::new(cx, mir);\n             vis.visit_body(mir_read_only);\n@@ -377,55 +370,53 @@ impl<'tcx> mir::visit::Visitor<'tcx> for LocalUseVisitor {\n \n /// Determines liveness of each local purely based on `StorageLive`/`Dead`.\n #[derive(Copy, Clone)]\n-struct MaybeStorageLive<'a, 'tcx> {\n-    body: &'a mir::Body<'tcx>,\n-}\n-\n-impl<'a, 'tcx> MaybeStorageLive<'a, 'tcx> {\n-    fn new(body: &'a mir::Body<'tcx>) -> Self {\n-        MaybeStorageLive { body }\n-    }\n-}\n+struct MaybeStorageLive;\n \n-impl<'a, 'tcx> BitDenotation<'tcx> for MaybeStorageLive<'a, 'tcx> {\n+impl<'tcx> AnalysisDomain<'tcx> for MaybeStorageLive {\n     type Idx = mir::Local;\n-    fn name() -> &'static str {\n-        \"maybe_storage_live\"\n-    }\n-    fn bits_per_block(&self) -> usize {\n-        self.body.local_decls.len()\n+    const NAME: &'static str = \"maybe_storage_live\";\n+\n+    fn bits_per_block(&self, body: &mir::Body<'tcx>) -> usize {\n+        body.local_decls.len()\n     }\n \n-    fn start_block_effect(&self, on_entry: &mut BitSet<mir::Local>) {\n-        for arg in self.body.args_iter() {\n-            on_entry.insert(arg);\n+    fn initialize_start_block(&self, body: &mir::Body<'tcx>, state: &mut BitSet<Self::Idx>) {\n+        for arg in body.args_iter() {\n+            state.insert(arg);\n         }\n     }\n+}\n \n-    fn statement_effect(&self, trans: &mut GenKillSet<mir::Local>, loc: mir::Location) {\n-        let stmt = &self.body[loc.block].statements[loc.statement_index];\n-\n+impl<'tcx> GenKillAnalysis<'tcx> for MaybeStorageLive {\n+    fn statement_effect(&self, trans: &mut impl GenKill<Self::Idx>, stmt: &mir::Statement<'tcx>, _: mir::Location) {\n         match stmt.kind {\n             mir::StatementKind::StorageLive(l) => trans.gen(l),\n             mir::StatementKind::StorageDead(l) => trans.kill(l),\n             _ => (),\n         }\n     }\n \n-    fn terminator_effect(&self, _trans: &mut GenKillSet<mir::Local>, _loc: mir::Location) {}\n+    fn terminator_effect(\n+        &self,\n+        _trans: &mut impl GenKill<Self::Idx>,\n+        _terminator: &mir::Terminator<'tcx>,\n+        _loc: mir::Location,\n+    ) {\n+    }\n \n-    fn propagate_call_return(\n+    fn call_return_effect(\n         &self,\n-        _in_out: &mut BitSet<mir::Local>,\n-        _call_bb: mir::BasicBlock,\n-        _dest_bb: mir::BasicBlock,\n-        _dest_place: &mir::Place<'tcx>,\n+        _in_out: &mut impl GenKill<Self::Idx>,\n+        _block: mir::BasicBlock,\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n+        _return_place: &mir::Place<'tcx>,\n     ) {\n         // Nothing to do when a call returns successfully\n     }\n }\n \n-impl<'a, 'tcx> BottomValue for MaybeStorageLive<'a, 'tcx> {\n+impl BottomValue for MaybeStorageLive {\n     /// bottom = dead\n     const BOTTOM_VALUE: bool = false;\n }\n@@ -451,7 +442,7 @@ impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n     fn into_map(\n         self,\n         cx: &LateContext<'a, 'tcx>,\n-        maybe_live: DataflowResults<'tcx, MaybeStorageLive<'a, 'tcx>>,\n+        maybe_live: ResultsCursor<'tcx, 'tcx, MaybeStorageLive>,\n     ) -> PossibleBorrowerMap<'a, 'tcx> {\n         let mut map = FxHashMap::default();\n         for row in (1..self.body.local_decls.len()).map(mir::Local::from_usize) {\n@@ -477,7 +468,7 @@ impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n         let bs = BitSet::new_empty(self.body.local_decls.len());\n         PossibleBorrowerMap {\n             map,\n-            maybe_live: DataflowResultsCursor::new(maybe_live, self.body),\n+            maybe_live,\n             bitset: (bs.clone(), bs),\n         }\n     }\n@@ -560,15 +551,15 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n struct PossibleBorrowerMap<'a, 'tcx> {\n     /// Mapping `Local -> its possible borrowers`\n     map: FxHashMap<mir::Local, HybridBitSet<mir::Local>>,\n-    maybe_live: DataflowResultsCursor<'a, 'tcx, MaybeStorageLive<'a, 'tcx>>,\n+    maybe_live: ResultsCursor<'a, 'tcx, MaybeStorageLive>,\n     // Caches to avoid allocation of `BitSet` on every query\n     bitset: (BitSet<mir::Local>, BitSet<mir::Local>),\n }\n \n impl PossibleBorrowerMap<'_, '_> {\n     /// Returns true if the set of borrowers of `borrowed` living at `at` matches with `borrowers`.\n     fn only_borrowers(&mut self, borrowers: &[mir::Local], borrowed: mir::Local, at: mir::Location) -> bool {\n-        self.maybe_live.seek(at);\n+        self.maybe_live.seek_after(at);\n \n         self.bitset.0.clear();\n         let maybe_live = &mut self.maybe_live;"}]}