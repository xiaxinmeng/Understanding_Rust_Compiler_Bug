{"sha": "ebe9682a25a4aa35b1c95ff73fb297209a8becd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZTk2ODJhMjVhNGFhMzViMWM5NWZmNzNmYjI5NzIwOWE4YmVjZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-14T22:00:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-01-14T22:00:43Z"}, "message": "Auto merge of #39020 - michaelwoerister:dep-graph-dfs-caching, r=nikomatsakis\n\nincr.comp.: Add some caching to Predecessors construction.\n\nThis speeds up the \"serialize dep graph\" pass for libsyntax from 45 secs to 15 secs on my machine. Still far from ideal, but things will get better when we change the metadata hashing strategy.\n\nThe `CACHING_THRESHOLD` value of 60 has been arrived at experimentally. It seemed to give the best speedup.\n\nr? @nikomatsakis", "tree": {"sha": "b4069e117ef78fa064dde0c9272716a9b813bb09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4069e117ef78fa064dde0c9272716a9b813bb09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebe9682a25a4aa35b1c95ff73fb297209a8becd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebe9682a25a4aa35b1c95ff73fb297209a8becd7", "html_url": "https://github.com/rust-lang/rust/commit/ebe9682a25a4aa35b1c95ff73fb297209a8becd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebe9682a25a4aa35b1c95ff73fb297209a8becd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93e70ecb7fbe05caa74dfb2bf3c29315edc2b3e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/93e70ecb7fbe05caa74dfb2bf3c29315edc2b3e6", "html_url": "https://github.com/rust-lang/rust/commit/93e70ecb7fbe05caa74dfb2bf3c29315edc2b3e6"}, {"sha": "482fa0f932df50f8fadc2e59289c42153f162657", "url": "https://api.github.com/repos/rust-lang/rust/commits/482fa0f932df50f8fadc2e59289c42153f162657", "html_url": "https://github.com/rust-lang/rust/commit/482fa0f932df50f8fadc2e59289c42153f162657"}], "stats": {"total": 326, "additions": 317, "deletions": 9}, "files": [{"sha": "3700d46c3462abd32a343e50797d95f3fe07d87d", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ebe9682a25a4aa35b1c95ff73fb297209a8becd7/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe9682a25a4aa35b1c95ff73fb297209a8becd7/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=ebe9682a25a4aa35b1c95ff73fb297209a8becd7", "patch": "@@ -17,23 +17,27 @@ pub struct BitVector {\n }\n \n impl BitVector {\n+    #[inline]\n     pub fn new(num_bits: usize) -> BitVector {\n         let num_words = u64s(num_bits);\n         BitVector { data: vec![0; num_words] }\n     }\n \n+    #[inline]\n     pub fn clear(&mut self) {\n         for p in &mut self.data {\n             *p = 0;\n         }\n     }\n \n+    #[inline]\n     pub fn contains(&self, bit: usize) -> bool {\n         let (word, mask) = word_mask(bit);\n         (self.data[word] & mask) != 0\n     }\n \n     /// Returns true if the bit has changed.\n+    #[inline]\n     pub fn insert(&mut self, bit: usize) -> bool {\n         let (word, mask) = word_mask(bit);\n         let data = &mut self.data[word];\n@@ -43,6 +47,7 @@ impl BitVector {\n         new_value != value\n     }\n \n+    #[inline]\n     pub fn insert_all(&mut self, all: &BitVector) -> bool {\n         assert!(self.data.len() == all.data.len());\n         let mut changed = false;\n@@ -56,6 +61,7 @@ impl BitVector {\n         changed\n     }\n \n+    #[inline]\n     pub fn grow(&mut self, num_bits: usize) {\n         let num_words = u64s(num_bits);\n         if self.data.len() < num_words {\n@@ -64,6 +70,7 @@ impl BitVector {\n     }\n \n     /// Iterates over indexes of set bits in a sorted order\n+    #[inline]\n     pub fn iter<'a>(&'a self) -> BitVectorIter<'a> {\n         BitVectorIter {\n             iter: self.data.iter(),\n@@ -226,10 +233,12 @@ impl BitMatrix {\n     }\n }\n \n+#[inline]\n fn u64s(elements: usize) -> usize {\n     (elements + 63) / 64\n }\n \n+#[inline]\n fn word_mask(index: usize) -> (usize, u64) {\n     let word = index / 64;\n     let mask = 1 << (index % 64);"}, {"sha": "b2a4a2772ec263effe995f25d2c88e0ee4bf4acc", "filename": "src/librustc_incremental/persist/preds.rs", "status": "modified", "additions": 297, "deletions": 9, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/ebe9682a25a4aa35b1c95ff73fb297209a8becd7/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe9682a25a4aa35b1c95ff73fb297209a8becd7/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=ebe9682a25a4aa35b1c95ff73fb297209a8becd7", "patch": "@@ -11,7 +11,8 @@\n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::graph::{DepthFirstTraversal, INCOMING, NodeIndex};\n+use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::graph::{NodeIndex, Graph};\n \n use super::hash::*;\n use ich::Fingerprint;\n@@ -33,11 +34,21 @@ pub struct Predecessors<'query> {\n impl<'q> Predecessors<'q> {\n     pub fn new(query: &'q DepGraphQuery<DefId>, hcx: &mut HashContext) -> Self {\n         // Find nodes for which we want to know the full set of preds\n-        let mut dfs = DepthFirstTraversal::new(&query.graph, INCOMING);\n-        let all_nodes = query.graph.all_nodes();\n         let tcx = hcx.tcx;\n+        let node_count = query.graph.len_nodes();\n \n-        let inputs: FxHashMap<_, _> = all_nodes.iter()\n+        // Set up some data structures the cache predecessor search needs:\n+        let mut visit_counts: Vec<u32> = Vec::new();\n+        let mut node_cache: Vec<Option<Box<[u32]>>> = Vec::new();\n+        visit_counts.resize(node_count, 0);\n+        node_cache.resize(node_count, None);\n+        let mut dfs_workspace1 = DfsWorkspace::new(node_count);\n+        let mut dfs_workspace2 = DfsWorkspace::new(node_count);\n+\n+        let inputs: FxHashMap<_, _> = query\n+            .graph\n+            .all_nodes()\n+            .iter()\n             .enumerate()\n             .filter(|&(_, node)| match node.data {\n                 DepNode::WorkProduct(_) => true,\n@@ -51,11 +62,18 @@ impl<'q> Predecessors<'q> {\n                 _ => false,\n             })\n             .map(|(node_index, node)| {\n-                dfs.reset(NodeIndex(node_index));\n-                let inputs: Vec<_> = dfs.by_ref()\n-                    .map(|i| &all_nodes[i.node_id()].data)\n-                    .filter(|d| HashContext::is_hashable(d))\n-                    .collect();\n+                find_roots(&query.graph,\n+                           node_index as u32,\n+                           &mut visit_counts,\n+                           &mut node_cache[..],\n+                           HashContext::is_hashable,\n+                           &mut dfs_workspace1,\n+                           Some(&mut dfs_workspace2));\n+\n+                let inputs: Vec<_> = dfs_workspace1.output.nodes.iter().map(|&i| {\n+                    query.graph.node_data(NodeIndex(i as usize))\n+                }).collect();\n+\n                 (&node.data, inputs)\n             })\n             .collect();\n@@ -72,3 +90,273 @@ impl<'q> Predecessors<'q> {\n         }\n     }\n }\n+\n+const CACHING_THRESHOLD: u32 = 60;\n+\n+// Starting at `start_node`, this function finds this node's \"roots\", that is,\n+// anything that is hashable, in the dep-graph. It uses a simple depth-first\n+// search to achieve that. However, since some sub-graphs are traversed over\n+// and over again, the function also some caching built into it: Each time it\n+// visits a node it increases a counter for that node. If a node has been\n+// visited more often than CACHING_THRESHOLD, the function will allocate a\n+// cache entry in the `cache` array. This cache entry contains a flat list of\n+// all roots reachable from the given node. The next time the node is visited,\n+// the search can just add the contents of this array to the output instead of\n+// recursing further.\n+//\n+// The function takes two `DfsWorkspace` arguments. These contains some data\n+// structures that would be expensive to re-allocate all the time, so they are\n+// allocated once up-front. There are two of them because building a cache entry\n+// requires a recursive invocation of this function. Two are enough though,\n+// since function never recurses more than once.\n+fn find_roots<T, F>(graph: &Graph<T, ()>,\n+                    start_node: u32,\n+                    visit_counts: &mut [u32],\n+                    cache: &mut [Option<Box<[u32]>>],\n+                    is_root: F,\n+                    workspace: &mut DfsWorkspace,\n+                    mut sub_workspace: Option<&mut DfsWorkspace>)\n+    where F: Copy + Fn(&T) -> bool,\n+          T: ::std::fmt::Debug,\n+{\n+    workspace.visited.clear();\n+    workspace.output.clear();\n+    workspace.stack.clear();\n+    workspace.stack.push(start_node);\n+\n+    loop {\n+        let node = match workspace.stack.pop() {\n+            Some(node) => node,\n+            None => return,\n+        };\n+\n+        if !workspace.visited.insert(node as usize) {\n+            continue\n+        }\n+\n+        if is_root(graph.node_data(NodeIndex(node as usize))) {\n+            // If this is a root, just add it to the output.\n+            workspace.output.insert(node);\n+        } else {\n+            if let Some(ref cached) = cache[node as usize] {\n+                for &n in &cached[..] {\n+                    workspace.output.insert(n);\n+                }\n+                // No need to recurse further from this node\n+                continue\n+            }\n+\n+            visit_counts[node as usize] += 1;\n+\n+            // If this node has been visited often enough to be cached ...\n+            if visit_counts[node as usize] > CACHING_THRESHOLD {\n+                // ... we are actually allowed to cache something, do so:\n+                if let Some(ref mut sub_workspace) = sub_workspace {\n+                    // Note that the following recursive invocation does never\n+                    // write to the cache (since we pass None as sub_workspace).\n+                    // This is intentional: The graph we are working with\n+                    // contains cycles and this prevent us from simply building\n+                    // our caches recursively on-demand.\n+                    // However, we can just do a regular, non-caching DFS to\n+                    // yield the set of roots and cache that.\n+                    find_roots(graph,\n+                               node,\n+                               visit_counts,\n+                               cache,\n+                               is_root,\n+                               sub_workspace,\n+                               None);\n+\n+                    for &n in &sub_workspace.output.nodes {\n+                        workspace.output.insert(n);\n+                    }\n+\n+                    cache[node as usize] = Some(sub_workspace.output\n+                                                             .nodes\n+                                                             .clone()\n+                                                             .into_boxed_slice());\n+                    // No need to recurse further from this node\n+                    continue\n+                }\n+            }\n+\n+            for pred in graph.predecessor_nodes(NodeIndex(node as usize)) {\n+                workspace.stack.push(pred.node_id() as u32);\n+            }\n+        }\n+    }\n+}\n+\n+struct DfsWorkspace {\n+    stack: Vec<u32>,\n+    visited: BitVector,\n+    output: NodeIndexSet,\n+}\n+\n+impl DfsWorkspace {\n+    fn new(total_node_count: usize) -> DfsWorkspace {\n+        DfsWorkspace {\n+            stack: Vec::new(),\n+            visited: BitVector::new(total_node_count),\n+            output: NodeIndexSet::new(total_node_count),\n+        }\n+    }\n+}\n+\n+struct NodeIndexSet {\n+    bitset: BitVector,\n+    nodes: Vec<u32>,\n+}\n+\n+impl NodeIndexSet {\n+    fn new(total_node_count: usize) -> NodeIndexSet {\n+        NodeIndexSet {\n+            bitset: BitVector::new(total_node_count),\n+            nodes: Vec::new(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn clear(&mut self) {\n+        self.bitset.clear();\n+        self.nodes.clear();\n+    }\n+\n+    #[inline]\n+    fn insert(&mut self, node: u32) {\n+        if self.bitset.insert(node as usize) {\n+            self.nodes.push(node)\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_cached_dfs_acyclic() {\n+\n+    //     0     1   2\n+    //     |      \\ /\n+    //     3---+   |\n+    //     |   |   |\n+    //     |   |   |\n+    //     4   5   6\n+    //      \\ / \\ / \\\n+    //       |   |   |\n+    //       7   8   9\n+\n+    let mut g: Graph<bool, ()> = Graph::new();\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(true);\n+    g.add_node(true);\n+    g.add_node(true);\n+\n+    g.add_edge(NodeIndex(3), NodeIndex(0), ());\n+    g.add_edge(NodeIndex(4), NodeIndex(3), ());\n+    g.add_edge(NodeIndex(7), NodeIndex(4), ());\n+    g.add_edge(NodeIndex(5), NodeIndex(3), ());\n+    g.add_edge(NodeIndex(7), NodeIndex(5), ());\n+    g.add_edge(NodeIndex(8), NodeIndex(5), ());\n+    g.add_edge(NodeIndex(8), NodeIndex(6), ());\n+    g.add_edge(NodeIndex(9), NodeIndex(6), ());\n+    g.add_edge(NodeIndex(6), NodeIndex(1), ());\n+    g.add_edge(NodeIndex(6), NodeIndex(2), ());\n+\n+    let mut ws1 = DfsWorkspace::new(g.len_nodes());\n+    let mut ws2 = DfsWorkspace::new(g.len_nodes());\n+    let mut visit_counts: Vec<_> = g.all_nodes().iter().map(|_| 0u32).collect();\n+    let mut cache: Vec<Option<Box<[u32]>>> = g.all_nodes().iter().map(|_| None).collect();\n+\n+    fn is_root(x: &bool) -> bool { *x }\n+\n+    for _ in 0 .. CACHING_THRESHOLD + 1 {\n+        find_roots(&g, 5, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![7, 8]);\n+\n+        find_roots(&g, 6, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![8, 9]);\n+\n+        find_roots(&g, 0, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![7, 8]);\n+\n+        find_roots(&g, 1, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![8, 9]);\n+\n+        find_roots(&g, 2, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![8, 9]);\n+\n+        find_roots(&g, 3, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![7, 8]);\n+\n+        find_roots(&g, 4, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![7]);\n+    }\n+}\n+\n+#[test]\n+fn test_cached_dfs_cyclic() {\n+\n+    //    0       1 <---- 2       3\n+    //    ^       |       ^       ^\n+    //    |       v       |       |\n+    //    4 ----> 5 ----> 6 ----> 7\n+    //    ^       ^       ^       ^\n+    //    |       |       |       |\n+    //    8       9      10      11\n+\n+\n+    let mut g: Graph<bool, ()> = Graph::new();\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(true);\n+    g.add_node(true);\n+    g.add_node(true);\n+    g.add_node(true);\n+\n+    g.add_edge(NodeIndex( 4), NodeIndex(0), ());\n+    g.add_edge(NodeIndex( 8), NodeIndex(4), ());\n+    g.add_edge(NodeIndex( 4), NodeIndex(5), ());\n+    g.add_edge(NodeIndex( 1), NodeIndex(5), ());\n+    g.add_edge(NodeIndex( 9), NodeIndex(5), ());\n+    g.add_edge(NodeIndex( 5), NodeIndex(6), ());\n+    g.add_edge(NodeIndex( 6), NodeIndex(2), ());\n+    g.add_edge(NodeIndex( 2), NodeIndex(1), ());\n+    g.add_edge(NodeIndex(10), NodeIndex(6), ());\n+    g.add_edge(NodeIndex( 6), NodeIndex(7), ());\n+    g.add_edge(NodeIndex(11), NodeIndex(7), ());\n+    g.add_edge(NodeIndex( 7), NodeIndex(3), ());\n+\n+    let mut ws1 = DfsWorkspace::new(g.len_nodes());\n+    let mut ws2 = DfsWorkspace::new(g.len_nodes());\n+    let mut visit_counts: Vec<_> = g.all_nodes().iter().map(|_| 0u32).collect();\n+    let mut cache: Vec<Option<Box<[u32]>>> = g.all_nodes().iter().map(|_| None).collect();\n+\n+    fn is_root(x: &bool) -> bool { *x }\n+\n+    for _ in 0 .. CACHING_THRESHOLD + 1 {\n+        find_roots(&g, 2, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![8, 9, 10]);\n+\n+        find_roots(&g, 3, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![8, 9, 10, 11]);\n+    }\n+}"}, {"sha": "14f1e222755f056001a4074bc5a45df2c5ab30a9", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ebe9682a25a4aa35b1c95ff73fb297209a8becd7/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebe9682a25a4aa35b1c95ff73fb297209a8becd7/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=ebe9682a25a4aa35b1c95ff73fb297209a8becd7", "patch": "@@ -44,6 +44,12 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let mut builder = DefIdDirectoryBuilder::new(tcx);\n     let query = tcx.dep_graph.query();\n+\n+    if tcx.sess.opts.debugging_opts.incremental_info {\n+        println!(\"incremental: {} nodes in dep-graph\", query.graph.len_nodes());\n+        println!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n+    }\n+\n     let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let preds = Predecessors::new(&query, &mut hcx);\n     let mut current_metadata_hashes = FxHashMap();\n@@ -179,6 +185,11 @@ pub fn encode_dep_graph(preds: &Predecessors,\n             .collect(),\n     };\n \n+    if tcx.sess.opts.debugging_opts.incremental_info {\n+        println!(\"incremental: {} edges in serialized dep-graph\", graph.edges.len());\n+        println!(\"incremental: {} hashes in serialized dep-graph\", graph.hashes.len());\n+    }\n+\n     debug!(\"graph = {:#?}\", graph);\n \n     // Encode the directory and then the graph data."}]}