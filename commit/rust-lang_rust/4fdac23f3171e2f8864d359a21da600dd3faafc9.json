{"sha": "4fdac23f3171e2f8864d359a21da600dd3faafc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZGFjMjNmMzE3MWUyZjg4NjRkMzU5YTIxZGE2MDBkZDNmYWFmYzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T18:06:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T18:06:06Z"}, "message": "Auto merge of #76814 - jackh726:binder-refactor, r=nikomatsakis\n\nRefactor `Binder` to track bound vars\n\nc.c. `@rust-lang/wg-traits`\n\nThis is super early (and might just get closed at some point), but want to get at least an initial idea of the perf impact.\n\nr? `@ghost`", "tree": {"sha": "124e089444740f2ac65eef217e221cd832033ef7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/124e089444740f2ac65eef217e221cd832033ef7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4fdac23f3171e2f8864d359a21da600dd3faafc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4fdac23f3171e2f8864d359a21da600dd3faafc9", "html_url": "https://github.com/rust-lang/rust/commit/4fdac23f3171e2f8864d359a21da600dd3faafc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4fdac23f3171e2f8864d359a21da600dd3faafc9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5029ac0ab372aec515db2e718da6d7787f3d122", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5029ac0ab372aec515db2e718da6d7787f3d122", "html_url": "https://github.com/rust-lang/rust/commit/a5029ac0ab372aec515db2e718da6d7787f3d122"}, {"sha": "7108918db6f59fca6656849c3e360045354e8a42", "url": "https://api.github.com/repos/rust-lang/rust/commits/7108918db6f59fca6656849c3e360045354e8a42", "html_url": "https://github.com/rust-lang/rust/commit/7108918db6f59fca6656849c3e360045354e8a42"}], "stats": {"total": 2565, "additions": 1851, "deletions": 714}, "files": [{"sha": "6317808e7fbe0b87e6b6ed288322c17b7d3f008f", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -402,7 +402,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, HashStable_Generic)]\n pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     // FIXME(davidtwco): Introduce `PolyTraitRef::LangItem`\n@@ -2556,7 +2556,7 @@ pub enum UseKind {\n /// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, HashStable_Generic)]\n pub struct TraitRef<'hir> {\n     pub path: &'hir Path<'hir>,\n     // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n@@ -2575,7 +2575,7 @@ impl TraitRef<'_> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, HashStable_Generic)]\n pub struct PolyTraitRef<'hir> {\n     /// The `'a` in `for<'a> Foo<&'a T>`.\n     pub bound_generic_params: &'hir [GenericParam<'hir>],"}, {"sha": "c68705da413f829401cb03eb7b78d9346d04a16c", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -293,7 +293,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T>(&mut self, t: ty::Binder<T>) -> ty::Binder<T>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -621,7 +621,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         let var = self.canonical_var(info, r.into());\n-        let br = ty::BoundRegion { kind: ty::BrAnon(var.as_u32()) };\n+        let br = ty::BoundRegion { var, kind: ty::BrAnon(var.as_u32()) };\n         let region = ty::ReLateBound(self.binder_index, br);\n         self.tcx().mk_region(region)\n     }"}, {"sha": "b8ecc949588fb0658d3e79b7c416018d220773c1", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -439,7 +439,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n                         // We only allow a `ty::INNERMOST` index in substitutions.\n                         assert_eq!(debruijn, ty::INNERMOST);\n-                        opt_values[br.assert_bound_var()] = Some(*original_value);\n+                        opt_values[br.var] = Some(*original_value);\n                     }\n                 }\n                 GenericArgKind::Const(result_value) => {"}, {"sha": "553a11d4393f94ba0f3e1e14fdd1e8463745265a", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -71,11 +71,10 @@ where\n     if var_values.var_values.is_empty() {\n         value\n     } else {\n-        let fld_r =\n-            |br: ty::BoundRegion| match var_values.var_values[br.assert_bound_var()].unpack() {\n-                GenericArgKind::Lifetime(l) => l,\n-                r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n-            };\n+        let fld_r = |br: ty::BoundRegion| match var_values.var_values[br.var].unpack() {\n+            GenericArgKind::Lifetime(l) => l,\n+            r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n+        };\n \n         let fld_t = |bound_ty: ty::BoundTy| match var_values.var_values[bound_ty.var].unpack() {\n             GenericArgKind::Type(ty) => ty,"}, {"sha": "debf108253793964800bbadce78277f02d66ca06", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -545,9 +545,9 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -840,9 +840,9 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "45ba50bb6349cc9d177d81f6534601508bebdf87", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -124,9 +124,9 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "a91bd9ce2ff7474c085d5e189401fcc9e76f9e6f", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -514,7 +514,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             fn print_dyn_existential(\n                 self,\n-                _predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+                _predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Err(NonTrivialPath)\n             }"}, {"sha": "58eb1e9aa12cb0aa4e61980155ace21c0ca33b8b", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -115,7 +115,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n                     (\n-                        Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)),\n+                        Some(rl::Region::LateBoundAnon(debruijn_index, _, anon_index)),\n                         ty::BrAnon(br_index),\n                     ) => {\n                         debug!(\n@@ -143,7 +143,7 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                     // error. We will then search the function parameters for a bound\n                     // region at the right depth with the same index\n                     (\n-                        Some(rl::Region::LateBound(debruijn_index, id, _)),\n+                        Some(rl::Region::LateBound(debruijn_index, _, id, _)),\n                         ty::BrNamed(def_id, _),\n                     ) => {\n                         debug!(\n@@ -162,8 +162,8 @@ impl Visitor<'tcx> for FindNestedTypeVisitor<'tcx> {\n                             rl::Region::Static\n                             | rl::Region::Free(_, _)\n                             | rl::Region::EarlyBound(_, _, _)\n-                            | rl::Region::LateBound(_, _, _)\n-                            | rl::Region::LateBoundAnon(_, _),\n+                            | rl::Region::LateBound(_, _, _, _)\n+                            | rl::Region::LateBoundAnon(_, _, _),\n                         )\n                         | None,\n                         _,\n@@ -217,7 +217,10 @@ impl Visitor<'tcx> for TyPathVisitor<'tcx> {\n     fn visit_lifetime(&mut self, lifetime: &hir::Lifetime) {\n         match (self.tcx.named_region(lifetime.hir_id), self.bound_region) {\n             // the lifetime of the TyPath!\n-            (Some(rl::Region::LateBoundAnon(debruijn_index, anon_index)), ty::BrAnon(br_index)) => {\n+            (\n+                Some(rl::Region::LateBoundAnon(debruijn_index, _, anon_index)),\n+                ty::BrAnon(br_index),\n+            ) => {\n                 if debruijn_index == self.current_index && anon_index == br_index {\n                     self.found_it = true;\n                     return;\n@@ -232,7 +235,7 @@ impl Visitor<'tcx> for TyPathVisitor<'tcx> {\n                 }\n             }\n \n-            (Some(rl::Region::LateBound(debruijn_index, id, _)), ty::BrNamed(def_id, _)) => {\n+            (Some(rl::Region::LateBound(debruijn_index, _, id, _)), ty::BrNamed(def_id, _)) => {\n                 debug!(\"FindNestedTypeVisitor::visit_ty: LateBound depth = {:?}\", debruijn_index,);\n                 debug!(\"id={:?}\", id);\n                 debug!(\"def_id={:?}\", def_id);\n@@ -246,8 +249,8 @@ impl Visitor<'tcx> for TyPathVisitor<'tcx> {\n                 Some(\n                     rl::Region::Static\n                     | rl::Region::EarlyBound(_, _, _)\n-                    | rl::Region::LateBound(_, _, _)\n-                    | rl::Region::LateBoundAnon(_, _)\n+                    | rl::Region::LateBound(_, _, _, _)\n+                    | rl::Region::LateBoundAnon(_, _, _)\n                     | rl::Region::Free(_, _),\n                 )\n                 | None,"}, {"sha": "02662043dba798088284696de403c25f30476984", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -85,9 +85,9 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "d460222df8ad0f82508f7ae52cdd6fa9f63c029d", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -11,10 +11,10 @@ use rustc_middle::ty::{self, Binder, TypeFoldable};\n impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n     pub fn higher_ranked_sub<T>(\n         &mut self,\n-        a: Binder<T>,\n-        b: Binder<T>,\n+        a: Binder<'tcx, T>,\n+        b: Binder<'tcx, T>,\n         a_is_expected: bool,\n-    ) -> RelateResult<'tcx, Binder<T>>\n+    ) -> RelateResult<'tcx, Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -50,7 +50,10 @@ impl<'a, 'tcx> CombineFields<'a, 'tcx> {\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n-            Ok(ty::Binder::bind(result))\n+            // We related `a_prime` and `b_prime`, which just had any bound vars\n+            // replaced with placeholders or infer vars, respectively. Relating\n+            // them should not introduce new bound vars.\n+            Ok(ty::Binder::dummy(result))\n         })\n     }\n }\n@@ -66,7 +69,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// the [rustc dev guide].\n     ///\n     /// [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/traits/hrtb.html\n-    pub fn replace_bound_vars_with_placeholders<T>(&self, binder: ty::Binder<T>) -> T\n+    pub fn replace_bound_vars_with_placeholders<T>(&self, binder: ty::Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "4fa8f2f1a6a426c82ec5bb6f9348a54a2e23f164", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -85,9 +85,9 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "eaec6b46bcd1456c30b15262808f3c684e1a0b7a", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1406,7 +1406,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n-        value: ty::Binder<T>,\n+        value: ty::Binder<'tcx, T>,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n     where\n         T: TypeFoldable<'tcx>,"}, {"sha": "fc9ea07866c214bdb1c56a4a2e23563f9c478dce", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -157,7 +157,7 @@ where\n \n     fn create_scope(\n         &mut self,\n-        value: ty::Binder<impl Relate<'tcx>>,\n+        value: ty::Binder<'tcx, impl Relate<'tcx>>,\n         universally_quantified: UniversallyQuantified,\n     ) -> BoundRegionScope<'tcx> {\n         let mut scope = BoundRegionScope::default();\n@@ -608,9 +608,9 @@ where\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {\n@@ -744,7 +744,7 @@ struct ScopeInstantiator<'me, 'tcx> {\n impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n-        t: &ty::Binder<T>,\n+        t: &ty::Binder<'tcx, T>,\n     ) -> ControlFlow<Self::BreakTy> {\n         self.target_index.shift_in(1);\n         t.super_visit_with(self);\n@@ -997,9 +997,9 @@ where\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        _: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        _: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "bf5f328233dfd7832ba421924214d53fec58df8d", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -162,9 +162,9 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "a33234a91faff47333f0c07dd49e7e7398d5ab52", "filename": "compiler/rustc_infer/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> FulfillmentError<'tcx> {\n }\n \n impl<'tcx> TraitObligation<'tcx> {\n-    pub fn self_ty(&self) -> ty::Binder<Ty<'tcx>> {\n+    pub fn self_ty(&self) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.predicate.map_bound(|p| p.self_ty())\n     }\n }"}, {"sha": "14bd823ea226662059f5a449fa13287a0c21d05e", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -909,7 +909,7 @@ impl<'tcx> LateContext<'tcx> {\n \n             fn print_dyn_existential(\n                 self,\n-                _predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+                _predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n             ) -> Result<Self::DynExistential, Self::Error> {\n                 Ok(())\n             }"}, {"sha": "8e53e4ba948058bdd4351b7a93227ddf27aea74a", "filename": "compiler/rustc_middle/src/ich/impls_ty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -70,16 +70,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n             ty::ReEmpty(universe) => {\n                 universe.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrAnon(i) }) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrAnon(i), .. }) => {\n                 db.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrNamed(def_id, name) }) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrNamed(def_id, name), .. }) => {\n                 db.hash_stable(hcx, hasher);\n                 def_id.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrEnv }) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrEnv, .. }) => {\n                 db.hash_stable(hcx, hasher);\n             }\n             ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }) => {\n@@ -118,12 +118,13 @@ impl<'tcx> HashStable<StableHashingContext<'tcx>> for ty::BoundVar {\n     }\n }\n \n-impl<'a, T> HashStable<StableHashingContext<'a>> for ty::Binder<T>\n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a>> for ty::Binder<'tcx, T>\n where\n     T: HashStable<StableHashingContext<'a>>,\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.as_ref().skip_binder().hash_stable(hcx, hasher);\n+        self.bound_vars().hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "5df2f91f09fff253a70b0179873d7a35631dd988", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -277,7 +277,7 @@ impl<'tcx, V> Canonical<'tcx, V> {\n }\n \n pub type QueryOutlivesConstraint<'tcx> =\n-    ty::Binder<ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n+    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n \n TrivialTypeFoldableAndLiftImpls! {\n     for <'tcx> {\n@@ -314,7 +314,8 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                         tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n                     }\n                     GenericArgKind::Lifetime(..) => {\n-                        let br = ty::BoundRegion { kind: ty::BrAnon(i) };\n+                        let br =\n+                            ty::BoundRegion { var: ty::BoundVar::from_u32(i), kind: ty::BrAnon(i) };\n                         tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n                     }\n                     GenericArgKind::Const(ct) => tcx"}, {"sha": "aa6488b329eba76cb14311993556a37c8102d42e", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -39,8 +39,13 @@ impl LifetimeDefOrigin {\n pub enum Region {\n     Static,\n     EarlyBound(/* index */ u32, /* lifetime decl */ DefId, LifetimeDefOrigin),\n-    LateBound(ty::DebruijnIndex, /* lifetime decl */ DefId, LifetimeDefOrigin),\n-    LateBoundAnon(ty::DebruijnIndex, /* anon index */ u32),\n+    LateBound(\n+        ty::DebruijnIndex,\n+        /* late-bound index */ u32,\n+        /* lifetime decl */ DefId,\n+        LifetimeDefOrigin,\n+    ),\n+    LateBoundAnon(ty::DebruijnIndex, /* late-bound index */ u32, /* anon index */ u32),\n     Free(DefId, /* lifetime decl */ DefId),\n }\n \n@@ -78,4 +83,6 @@ pub struct ResolveLifetimes {\n     /// be late-bound if (a) it does NOT appear in a where-clause and\n     /// (b) it DOES appear in the arguments.\n     pub late_bound: FxHashMap<LocalDefId, FxHashSet<ItemLocalId>>,\n+\n+    pub late_bound_vars: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>>,\n }"}, {"sha": "99d063c7eeafb57b2d935c4f777b4521d15fed83", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1290,6 +1290,10 @@ rustc_queries! {\n         -> Option<Vec<ObjectLifetimeDefault>> {\n         desc { \"looking up lifetime defaults for a region on an item\" }\n     }\n+    query late_bound_vars_map(_: LocalDefId)\n+        -> Option<&'tcx FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>> {\n+        desc { \"looking up late bound vars\" }\n+    }\n \n     query visibility(def_id: DefId) -> ty::Visibility {\n         eval_always"}, {"sha": "922d14bc2f574c2c3908c3c8f995062ef59b5efd", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -341,7 +341,7 @@ impl ObligationCauseCode<'_> {\n \n // `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(ObligationCauseCode<'_>, 32);\n+static_assert_size!(ObligationCauseCode<'_>, 40);\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum StatementAsExpression {"}, {"sha": "8e2c79701af90d76d48d6979e23a08c4f7fd35ea", "filename": "compiler/rustc_middle/src/ty/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2F_match.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -112,9 +112,9 @@ impl TypeRelation<'tcx> for Match<'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "d7767dc39cb32a6f9db613fb345d708fea963606", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 33, "deletions": 18, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -120,8 +120,9 @@ impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<ty::PredicateKind<'tcx>> {\n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        self.bound_vars().encode(e)?;\n         encode_with_shorthand(e, &self.skip_binder(), TyEncoder::predicate_shorthands)\n     }\n }\n@@ -226,18 +227,22 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<ty::PredicateKind<'tcx>> {\n-    fn decode(decoder: &mut D) -> Result<ty::Binder<ty::PredicateKind<'tcx>>, D::Error> {\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n+    fn decode(decoder: &mut D) -> Result<ty::Binder<'tcx, ty::PredicateKind<'tcx>>, D::Error> {\n+        let bound_vars = Decodable::decode(decoder)?;\n         // Handle shorthands first, if we have an usize > 0x80.\n-        Ok(ty::Binder::bind(if decoder.positioned_at_shorthand() {\n-            let pos = decoder.read_usize()?;\n-            assert!(pos >= SHORTHAND_OFFSET);\n-            let shorthand = pos - SHORTHAND_OFFSET;\n-\n-            decoder.with_position(shorthand, ty::PredicateKind::decode)?\n-        } else {\n-            ty::PredicateKind::decode(decoder)?\n-        }))\n+        Ok(ty::Binder::bind_with_vars(\n+            if decoder.positioned_at_shorthand() {\n+                let pos = decoder.read_usize()?;\n+                assert!(pos >= SHORTHAND_OFFSET);\n+                let shorthand = pos - SHORTHAND_OFFSET;\n+\n+                decoder.with_position(shorthand, ty::PredicateKind::decode)?\n+            } else {\n+                ty::PredicateKind::decode(decoder)?\n+            },\n+            bound_vars,\n+        ))\n     }\n }\n \n@@ -319,7 +324,7 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<Ty<'tcx>> {\n }\n \n impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D>\n-    for ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>\n+    for ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n {\n     fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n         let len = decoder.read_usize()?;\n@@ -379,15 +384,23 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::N\n     }\n }\n \n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<ty::BoundVariableKind> {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        let len = decoder.read_usize()?;\n+        Ok(decoder.tcx().mk_bound_variable_kinds((0..len).map(|_| Decodable::decode(decoder)))?)\n+    }\n+}\n+\n impl_decodable_via_ref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     &'tcx ty::List<Ty<'tcx>>,\n-    &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+    &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     &'tcx Allocation,\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,\n     &'tcx mir::BorrowCheckResult<'tcx>,\n-    &'tcx mir::coverage::CodeRegion\n+    &'tcx mir::coverage::CodeRegion,\n+    &'tcx ty::List<ty::BoundVariableKind>\n }\n \n #[macro_export]\n@@ -488,14 +501,16 @@ macro_rules! implement_ty_decoder {\n macro_rules! impl_binder_encode_decode {\n     ($($t:ty),+ $(,)?) => {\n         $(\n-            impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<$t> {\n+            impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<'tcx, $t> {\n                 fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+                    self.bound_vars().encode(e)?;\n                     self.as_ref().skip_binder().encode(e)\n                 }\n             }\n-            impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<$t> {\n+            impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, $t> {\n                 fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n-                    Ok(ty::Binder::bind(Decodable::decode(decoder)?))\n+                    let bound_vars = Decodable::decode(decoder)?;\n+                    Ok(ty::Binder::bind_with_vars(Decodable::decode(decoder)?, bound_vars))\n                 }\n             }\n         )*"}, {"sha": "bb2b00cbaea818bc3c794ec20bca334f873d40f9", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -87,14 +87,16 @@ pub struct CtxtInterners<'tcx> {\n     substs: InternedSet<'tcx, InternalSubsts<'tcx>>,\n     canonical_var_infos: InternedSet<'tcx, List<CanonicalVarInfo<'tcx>>>,\n     region: InternedSet<'tcx, RegionKind>,\n-    poly_existential_predicates: InternedSet<'tcx, List<ty::Binder<ExistentialPredicate<'tcx>>>>,\n+    poly_existential_predicates:\n+        InternedSet<'tcx, List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>>,\n     predicate: InternedSet<'tcx, PredicateInner<'tcx>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n     projs: InternedSet<'tcx, List<ProjectionKind>>,\n     place_elems: InternedSet<'tcx, List<PlaceElem<'tcx>>>,\n     const_: InternedSet<'tcx, Const<'tcx>>,\n     /// Const allocations.\n     allocation: InternedSet<'tcx, Allocation>,\n+    bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -113,6 +115,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             place_elems: Default::default(),\n             const_: Default::default(),\n             allocation: Default::default(),\n+            bound_variable_kinds: Default::default(),\n         }\n     }\n \n@@ -136,7 +139,10 @@ impl<'tcx> CtxtInterners<'tcx> {\n     }\n \n     #[inline(never)]\n-    fn intern_predicate(&self, kind: Binder<PredicateKind<'tcx>>) -> &'tcx PredicateInner<'tcx> {\n+    fn intern_predicate(\n+        &self,\n+        kind: Binder<'tcx, PredicateKind<'tcx>>,\n+    ) -> &'tcx PredicateInner<'tcx> {\n         self.predicate\n             .intern(kind, |kind| {\n                 let flags = super::flags::FlagComputation::for_predicate(kind);\n@@ -449,7 +455,7 @@ pub struct TypeckResults<'tcx> {\n \n     /// Stores the type, expression, span and optional scope span of all types\n     /// that are live across the yield of this generator (if a generator).\n-    pub generator_interior_types: ty::Binder<Vec<GeneratorInteriorTypeCause<'tcx>>>,\n+    pub generator_interior_types: ty::Binder<'tcx, Vec<GeneratorInteriorTypeCause<'tcx>>>,\n \n     /// We sometimes treat byte string literals (which are of type `&[u8; N]`)\n     /// as `&[u8]`, depending on the pattern  in which they are used.\n@@ -804,7 +810,7 @@ impl CanonicalUserType<'tcx> {\n                             ty::ReLateBound(debruijn, br) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(*debruijn, ty::INNERMOST);\n-                                cvar == br.assert_bound_var()\n+                                cvar == br.var\n                             }\n                             _ => false,\n                         },\n@@ -1616,10 +1622,11 @@ nop_lift! {allocation; &'a Allocation => &'tcx Allocation}\n nop_lift! {predicate; &'a PredicateInner<'a> => &'tcx PredicateInner<'tcx>}\n \n nop_list_lift! {type_list; Ty<'a> => Ty<'tcx>}\n-nop_list_lift! {poly_existential_predicates; ty::Binder<ExistentialPredicate<'a>> => ty::Binder<ExistentialPredicate<'tcx>>}\n+nop_list_lift! {poly_existential_predicates; ty::Binder<'a, ExistentialPredicate<'a>> => ty::Binder<'tcx, ExistentialPredicate<'tcx>>}\n nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n nop_list_lift! {canonical_var_infos; CanonicalVarInfo<'a> => CanonicalVarInfo<'tcx>}\n nop_list_lift! {projs; ProjectionKind => ProjectionKind}\n+nop_list_lift! {bound_variable_kinds; ty::BoundVariableKind => ty::BoundVariableKind}\n \n // This is the impl for `&'a InternalSubsts<'a>`.\n nop_list_lift! {substs; GenericArg<'a> => GenericArg<'tcx>}\n@@ -1965,8 +1972,8 @@ impl<'tcx> Hash for Interned<'tcx, PredicateInner<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<Binder<PredicateKind<'tcx>>> for Interned<'tcx, PredicateInner<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a Binder<PredicateKind<'tcx>> {\n+impl<'tcx> Borrow<Binder<'tcx, PredicateKind<'tcx>>> for Interned<'tcx, PredicateInner<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a Binder<'tcx, PredicateKind<'tcx>> {\n         &self.0.kind\n     }\n }\n@@ -2072,10 +2079,11 @@ slice_interners!(\n     substs: _intern_substs(GenericArg<'tcx>),\n     canonical_var_infos: _intern_canonical_var_infos(CanonicalVarInfo<'tcx>),\n     poly_existential_predicates:\n-        _intern_poly_existential_predicates(ty::Binder<ExistentialPredicate<'tcx>>),\n+        _intern_poly_existential_predicates(ty::Binder<'tcx, ExistentialPredicate<'tcx>>),\n     predicates: _intern_predicates(Predicate<'tcx>),\n     projs: _intern_projs(ProjectionKind),\n     place_elems: _intern_place_elems(PlaceElem<'tcx>),\n+    bound_variable_kinds: _intern_bound_variable_kinds(ty::BoundVariableKind),\n );\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -2158,7 +2166,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_predicate(self, binder: Binder<PredicateKind<'tcx>>) -> Predicate<'tcx> {\n+    pub fn mk_predicate(self, binder: Binder<'tcx, PredicateKind<'tcx>>) -> Predicate<'tcx> {\n         let inner = self.interners.intern_predicate(binder);\n         Predicate { inner }\n     }\n@@ -2167,7 +2175,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn reuse_or_mk_predicate(\n         self,\n         pred: Predicate<'tcx>,\n-        binder: Binder<PredicateKind<'tcx>>,\n+        binder: Binder<'tcx, PredicateKind<'tcx>>,\n     ) -> Predicate<'tcx> {\n         if pred.kind() != binder { self.mk_predicate(binder) } else { pred }\n     }\n@@ -2334,7 +2342,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[inline]\n     pub fn mk_dynamic(\n         self,\n-        obj: &'tcx List<ty::Binder<ExistentialPredicate<'tcx>>>,\n+        obj: &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>,\n         reg: ty::Region<'tcx>,\n     ) -> Ty<'tcx> {\n         self.mk_ty(Dynamic(obj, reg))\n@@ -2361,7 +2369,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_generator_witness(self, types: ty::Binder<&'tcx List<Ty<'tcx>>>) -> Ty<'tcx> {\n+    pub fn mk_generator_witness(self, types: ty::Binder<'tcx, &'tcx List<Ty<'tcx>>>) -> Ty<'tcx> {\n         self.mk_ty(GeneratorWitness(types))\n     }\n \n@@ -2466,8 +2474,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn intern_poly_existential_predicates(\n         self,\n-        eps: &[ty::Binder<ExistentialPredicate<'tcx>>],\n-    ) -> &'tcx List<ty::Binder<ExistentialPredicate<'tcx>>> {\n+        eps: &[ty::Binder<'tcx, ExistentialPredicate<'tcx>>],\n+    ) -> &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n         assert!(!eps.is_empty());\n         assert!(\n             eps.array_windows()\n@@ -2512,6 +2520,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.is_empty() { List::empty() } else { self._intern_canonical_var_infos(ts) }\n     }\n \n+    pub fn intern_bound_variable_kinds(\n+        self,\n+        ts: &[ty::BoundVariableKind],\n+    ) -> &'tcx List<ty::BoundVariableKind> {\n+        if ts.is_empty() { List::empty() } else { self._intern_bound_variable_kinds(ts) }\n+    }\n+\n     pub fn mk_fn_sig<I>(\n         self,\n         inputs: I,\n@@ -2533,8 +2548,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn mk_poly_existential_predicates<\n         I: InternAs<\n-            [ty::Binder<ExistentialPredicate<'tcx>>],\n-            &'tcx List<ty::Binder<ExistentialPredicate<'tcx>>>,\n+            [ty::Binder<'tcx, ExistentialPredicate<'tcx>>],\n+            &'tcx List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>>,\n         >,\n     >(\n         self,\n@@ -2572,6 +2587,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))\n     }\n \n+    pub fn mk_bound_variable_kinds<\n+        I: InternAs<[ty::BoundVariableKind], &'tcx List<ty::BoundVariableKind>>,\n+    >(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n+        iter.intern_with(|xs| self.intern_bound_variable_kinds(xs))\n+    }\n+\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n     pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n@@ -2648,6 +2672,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn object_lifetime_defaults(self, id: HirId) -> Option<Vec<ObjectLifetimeDefault>> {\n         self.object_lifetime_defaults_map(id.owner)\n     }\n+\n+    pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n+        self.mk_bound_variable_kinds(\n+            self.late_bound_vars_map(id.owner)\n+                .and_then(|map| map.get(&id.local_id).cloned())\n+                .unwrap_or_else(|| {\n+                    bug!(\"No bound vars found for {:?} ({:?})\", self.hir().node_to_string(id), id)\n+                })\n+                .iter(),\n+        )\n+    }\n }\n \n impl TyCtxtAt<'tcx> {"}, {"sha": "79e88662f652d6966bedca0402c6cf3004408812", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -43,7 +43,7 @@ impl TypeFolder<'tcx> for RegionEraserVisitor<'tcx> {\n         if ty.needs_infer() { ty.super_fold_with(self) } else { self.tcx.erase_regions_ty(ty) }\n     }\n \n-    fn fold_binder<T>(&mut self, t: ty::Binder<T>) -> ty::Binder<T>\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "4767e5743c22e4dc9e2dae017b86132c4ce06762", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -57,7 +57,9 @@ pub enum TypeError<'tcx> {\n     CyclicTy(Ty<'tcx>),\n     CyclicConst(&'tcx ty::Const<'tcx>),\n     ProjectionMismatched(ExpectedFound<DefId>),\n-    ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>>),\n+    ExistentialMismatch(\n+        ExpectedFound<&'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>>,\n+    ),\n     ObjectUnsafeCoercion(DefId),\n     ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n "}, {"sha": "01bc5cc761ca67275c4fe9bf64e23cf6982b570d", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -22,7 +22,7 @@ impl FlagComputation {\n         result\n     }\n \n-    pub fn for_predicate(binder: ty::Binder<ty::PredicateKind<'_>>) -> FlagComputation {\n+    pub fn for_predicate(binder: ty::Binder<'tcx, ty::PredicateKind<'_>>) -> FlagComputation {\n         let mut result = FlagComputation::new();\n         result.add_predicate(binder);\n         result\n@@ -53,7 +53,7 @@ impl FlagComputation {\n \n     /// Adds the flags/depth from a set of types that appear within the current type, but within a\n     /// region binder.\n-    fn bound_computation<T, F>(&mut self, value: ty::Binder<T>, f: F)\n+    fn bound_computation<T, F>(&mut self, value: ty::Binder<'_, T>, f: F)\n     where\n         F: FnOnce(&mut Self, T),\n     {\n@@ -204,7 +204,7 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_predicate(&mut self, binder: ty::Binder<ty::PredicateKind<'_>>) {\n+    fn add_predicate(&mut self, binder: ty::Binder<'tcx, ty::PredicateKind<'_>>) {\n         self.bound_computation(binder, |computation, atom| computation.add_predicate_atom(atom));\n     }\n "}, {"sha": "70f3ac3004042708a5d548bbf1187ca4773f7b91", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 265, "deletions": 21, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -35,6 +35,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sso::SsoHashSet;\n use std::collections::BTreeMap;\n use std::fmt;\n use std::ops::ControlFlow;\n@@ -161,7 +162,7 @@ impl TypeFoldable<'tcx> for hir::Constness {\n pub trait TypeFolder<'tcx>: Sized {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n-    fn fold_binder<T>(&mut self, t: Binder<T>) -> Binder<T>\n+    fn fold_binder<T>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -184,7 +185,10 @@ pub trait TypeFolder<'tcx>: Sized {\n pub trait TypeVisitor<'tcx>: Sized {\n     type BreakTy = !;\n \n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n         t.super_visit_with(self)\n     }\n \n@@ -322,7 +326,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             fn visit_binder<T: TypeFoldable<'tcx>>(\n                 &mut self,\n-                t: &Binder<T>,\n+                t: &Binder<'tcx, T>,\n             ) -> ControlFlow<Self::BreakTy> {\n                 self.outer_index.shift_in(1);\n                 let result = t.as_ref().skip_binder().visit_with(self);\n@@ -400,7 +404,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n@@ -460,7 +467,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n@@ -538,7 +548,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// contain escaping bound types.\n     pub fn replace_late_bound_regions<T, F>(\n         self,\n-        value: Binder<T>,\n+        value: Binder<'tcx, T>,\n         mut fld_r: F,\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n     where\n@@ -588,7 +598,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// types.\n     pub fn replace_bound_vars<T, F, G, H>(\n         self,\n-        value: Binder<T>,\n+        value: Binder<'tcx, T>,\n         mut fld_r: F,\n         fld_t: G,\n         fld_c: H,\n@@ -607,7 +617,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Replaces any late-bound regions bound in `value` with\n     /// free variants attached to `all_outlive_scope`.\n-    pub fn liberate_late_bound_regions<T>(self, all_outlive_scope: DefId, value: ty::Binder<T>) -> T\n+    pub fn liberate_late_bound_regions<T>(\n+        self,\n+        all_outlive_scope: DefId,\n+        value: ty::Binder<'tcx, T>,\n+    ) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -620,13 +634,49 @@ impl<'tcx> TyCtxt<'tcx> {\n         .0\n     }\n \n+    pub fn shift_bound_var_indices<T>(self, bound_vars: usize, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.replace_escaping_bound_vars(\n+            value,\n+            |r| {\n+                self.mk_region(ty::ReLateBound(\n+                    ty::INNERMOST,\n+                    ty::BoundRegion {\n+                        var: ty::BoundVar::from_usize(r.var.as_usize() + bound_vars),\n+                        kind: r.kind,\n+                    },\n+                ))\n+            },\n+            |t| {\n+                self.mk_ty(ty::Bound(\n+                    ty::INNERMOST,\n+                    ty::BoundTy {\n+                        var: ty::BoundVar::from_usize(t.var.as_usize() + bound_vars),\n+                        kind: t.kind,\n+                    },\n+                ))\n+            },\n+            |c, ty| {\n+                self.mk_const(ty::Const {\n+                    val: ty::ConstKind::Bound(\n+                        ty::INNERMOST,\n+                        ty::BoundVar::from_usize(c.as_usize() + bound_vars),\n+                    ),\n+                    ty,\n+                })\n+            },\n+        )\n+    }\n+\n     /// Returns a set of all late-bound regions that are constrained\n     /// by `value`, meaning that if we instantiate those LBR with\n     /// variables and equate `value` with something else, those\n     /// variables will also be equated.\n     pub fn collect_constrained_late_bound_regions<T>(\n         self,\n-        value: &Binder<T>,\n+        value: &Binder<'tcx, T>,\n     ) -> FxHashSet<ty::BoundRegionKind>\n     where\n         T: TypeFoldable<'tcx>,\n@@ -637,7 +687,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns a set of all late-bound regions that appear in `value` anywhere.\n     pub fn collect_referenced_late_bound_regions<T>(\n         self,\n-        value: &Binder<T>,\n+        value: &Binder<'tcx, T>,\n     ) -> FxHashSet<ty::BoundRegionKind>\n     where\n         T: TypeFoldable<'tcx>,\n@@ -647,7 +697,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     fn collect_late_bound_regions<T>(\n         self,\n-        value: &Binder<T>,\n+        value: &Binder<'tcx, T>,\n         just_constraint: bool,\n     ) -> FxHashSet<ty::BoundRegionKind>\n     where\n@@ -661,7 +711,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Replaces any late-bound regions bound in `value` with `'erased`. Useful in codegen but also\n     /// method lookup and a few other places where precise region relationships are not required.\n-    pub fn erase_late_bound_regions<T>(self, value: Binder<T>) -> T\n+    pub fn erase_late_bound_regions<T>(self, value: Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n@@ -676,20 +726,205 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n     /// structurally identical. For example, `for<'a, 'b> fn(&'a isize, &'b isize)` and\n     /// `for<'a, 'b> fn(&'b isize, &'a isize)` will become identical after anonymization.\n-    pub fn anonymize_late_bound_regions<T>(self, sig: Binder<T>) -> Binder<T>\n+    pub fn anonymize_late_bound_regions<T>(self, sig: Binder<'tcx, T>) -> Binder<'tcx, T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         let mut counter = 0;\n-        Binder::bind(\n-            self.replace_late_bound_regions(sig, |_| {\n-                let br = ty::BoundRegion { kind: ty::BrAnon(counter) };\n+        let inner = self\n+            .replace_late_bound_regions(sig, |_| {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_u32(counter),\n+                    kind: ty::BrAnon(counter),\n+                };\n                 let r = self.mk_region(ty::ReLateBound(ty::INNERMOST, br));\n                 counter += 1;\n                 r\n             })\n-            .0,\n-        )\n+            .0;\n+        let bound_vars = self.mk_bound_variable_kinds(\n+            (0..counter).map(|i| ty::BoundVariableKind::Region(ty::BrAnon(i))),\n+        );\n+        Binder::bind_with_vars(inner, bound_vars)\n+    }\n+}\n+\n+pub struct BoundVarsCollector<'tcx> {\n+    binder_index: ty::DebruijnIndex,\n+    vars: BTreeMap<u32, ty::BoundVariableKind>,\n+    // We may encounter the same variable at different levels of binding, so\n+    // this can't just be `Ty`\n+    visited: SsoHashSet<(ty::DebruijnIndex, Ty<'tcx>)>,\n+}\n+\n+impl<'tcx> BoundVarsCollector<'tcx> {\n+    pub fn new() -> Self {\n+        BoundVarsCollector {\n+            binder_index: ty::INNERMOST,\n+            vars: BTreeMap::new(),\n+            visited: SsoHashSet::default(),\n+        }\n+    }\n+\n+    pub fn into_vars(self, tcx: TyCtxt<'tcx>) -> &'tcx ty::List<ty::BoundVariableKind> {\n+        let max = self.vars.iter().map(|(k, _)| *k).max().unwrap_or_else(|| 0);\n+        for i in 0..max {\n+            if let None = self.vars.get(&i) {\n+                panic!(\"Unknown variable: {:?}\", i);\n+            }\n+        }\n+\n+        tcx.mk_bound_variable_kinds(self.vars.into_iter().map(|(_, v)| v))\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n+    type BreakTy = ();\n+\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if t.outer_exclusive_binder < self.binder_index\n+            || !self.visited.insert((self.binder_index, t))\n+        {\n+            return ControlFlow::CONTINUE;\n+        }\n+        use std::collections::btree_map::Entry;\n+        match *t.kind() {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                match self.vars.entry(bound_ty.var.as_u32()) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(ty::BoundVariableKind::Ty(bound_ty.kind));\n+                    }\n+                    Entry::Occupied(entry) => match entry.get() {\n+                        ty::BoundVariableKind::Ty(_) => {}\n+                        _ => bug!(\"Conflicting bound vars\"),\n+                    },\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match r {\n+            ty::ReLateBound(index, _br) if *index == self.binder_index => {\n+                // If you hit this, you should be using `Binder::bind_with_vars` or `Binder::rebind`\n+                bug!(\"Trying to collect bound vars with a bound region: {:?} {:?}\", index, _br)\n+            }\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+pub struct ValidateBoundVars<'tcx> {\n+    bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n+    binder_index: ty::DebruijnIndex,\n+    // We may encounter the same variable at different levels of binding, so\n+    // this can't just be `Ty`\n+    visited: SsoHashSet<(ty::DebruijnIndex, Ty<'tcx>)>,\n+}\n+\n+impl<'tcx> ValidateBoundVars<'tcx> {\n+    pub fn new(bound_vars: &'tcx ty::List<ty::BoundVariableKind>) -> Self {\n+        ValidateBoundVars {\n+            bound_vars,\n+            binder_index: ty::INNERMOST,\n+            visited: SsoHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for ValidateBoundVars<'tcx> {\n+    type BreakTy = ();\n+\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if t.outer_exclusive_binder < self.binder_index\n+            || !self.visited.insert((self.binder_index, t))\n+        {\n+            return ControlFlow::BREAK;\n+        }\n+        match *t.kind() {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                if self.bound_vars.len() <= bound_ty.var.as_usize() {\n+                    bug!(\"Not enough bound vars: {:?} not found in {:?}\", t, self.bound_vars);\n+                }\n+                let list_var = self.bound_vars[bound_ty.var.as_usize()];\n+                match list_var {\n+                    ty::BoundVariableKind::Ty(kind) => {\n+                        if kind != bound_ty.kind {\n+                            bug!(\n+                                \"Mismatched type kinds: {:?} doesn't var in list {:?}\",\n+                                bound_ty.kind,\n+                                list_var\n+                            );\n+                        }\n+                    }\n+                    _ => {\n+                        bug!(\"Mismatched bound variable kinds! Expected type, found {:?}\", list_var)\n+                    }\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => {\n+                if self.bound_vars.len() <= br.var.as_usize() {\n+                    bug!(\"Not enough bound vars: {:?} not found in {:?}\", *br, self.bound_vars);\n+                }\n+                let list_var = self.bound_vars[br.var.as_usize()];\n+                match list_var {\n+                    ty::BoundVariableKind::Region(kind) => {\n+                        if kind != br.kind {\n+                            bug!(\n+                                \"Mismatched region kinds: {:?} doesn't match var ({:?}) in list ({:?})\",\n+                                br.kind,\n+                                list_var,\n+                                self.bound_vars\n+                            );\n+                        }\n+                    }\n+                    _ => bug!(\n+                        \"Mismatched bound variable kinds! Expected region, found {:?}\",\n+                        list_var\n+                    ),\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n     }\n }\n \n@@ -719,7 +954,10 @@ impl TypeFolder<'tcx> for Shifter<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n         self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n         self.current_index.shift_out(1);\n@@ -828,7 +1066,10 @@ struct HasEscapingVarsVisitor {\n impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     type BreakTy = FoundEscapingVars;\n \n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n         self.outer_index.shift_in(1);\n         let result = t.super_visit_with(self);\n         self.outer_index.shift_out(1);\n@@ -974,7 +1215,10 @@ impl LateBoundRegionsCollector {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n         self.current_index.shift_in(1);\n         let result = t.super_visit_with(self);\n         self.current_index.shift_out(1);"}, {"sha": "e7bbdc3ccebdf4adfd4e2c3554488109a5a0b59e", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n use crate::ich::StableHashingContext;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n@@ -2481,21 +2482,42 @@ impl<'tcx> ty::Instance<'tcx> {\n             ty::Closure(def_id, substs) => {\n                 let sig = substs.as_closure().sig();\n \n-                let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-                sig.map_bound(|sig| {\n+                let bound_vars = tcx.mk_bound_variable_kinds(\n+                    sig.bound_vars()\n+                        .iter()\n+                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+                );\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    kind: ty::BoundRegionKind::BrEnv,\n+                };\n+                let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+                let env_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n+\n+                let sig = sig.skip_binder();\n+                ty::Binder::bind_with_vars(\n                     tcx.mk_fn_sig(\n-                        iter::once(env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n+                        iter::once(env_ty).chain(sig.inputs().iter().cloned()),\n                         sig.output(),\n                         sig.c_variadic,\n                         sig.unsafety,\n                         sig.abi,\n-                    )\n-                })\n+                    ),\n+                    bound_vars,\n+                )\n             }\n             ty::Generator(_, substs, _) => {\n                 let sig = substs.as_generator().poly_sig();\n \n-                let br = ty::BoundRegion { kind: ty::BrEnv };\n+                let bound_vars = tcx.mk_bound_variable_kinds(\n+                    sig.bound_vars()\n+                        .iter()\n+                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+                );\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    kind: ty::BoundRegionKind::BrEnv,\n+                };\n                 let env_region = ty::ReLateBound(ty::INNERMOST, br);\n                 let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n \n@@ -2504,21 +2526,21 @@ impl<'tcx> ty::Instance<'tcx> {\n                 let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n                 let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n \n-                sig.map_bound(|sig| {\n-                    let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n-                    let state_adt_ref = tcx.adt_def(state_did);\n-                    let state_substs =\n-                        tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n-                    let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n-\n+                let sig = sig.skip_binder();\n+                let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n+                let state_adt_ref = tcx.adt_def(state_did);\n+                let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n+                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+                ty::Binder::bind_with_vars(\n                     tcx.mk_fn_sig(\n                         [env_ty, sig.resume_ty].iter(),\n                         &ret_ty,\n                         false,\n                         hir::Unsafety::Normal,\n                         rustc_target::spec::abi::Abi::Rust,\n-                    )\n-                })\n+                    ),\n+                    bound_vars,\n+                )\n             }\n             _ => bug!(\"unexpected type {:?} in Instance::fn_sig\", ty),\n         }"}, {"sha": "6574c9382604b1ec894007c6a265f4081bcf0c56", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 51, "deletions": 28, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -67,12 +67,12 @@ pub use self::sty::BoundRegionKind::*;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TyKind::*;\n pub use self::sty::{\n-    Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar, CanonicalPolyFnSig,\n-    ClosureSubsts, ClosureSubstsParts, ConstVid, EarlyBoundRegion, ExistentialPredicate,\n-    ExistentialProjection, ExistentialTraitRef, FnSig, FreeRegion, GenSig, GeneratorSubsts,\n-    GeneratorSubstsParts, ParamConst, ParamTy, PolyExistentialProjection, PolyExistentialTraitRef,\n-    PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind, RegionVid, TraitRef,\n-    TyKind, TypeAndMut, UpvarSubsts,\n+    Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar, BoundVariableKind,\n+    CanonicalPolyFnSig, ClosureSubsts, ClosureSubstsParts, ConstVid, EarlyBoundRegion,\n+    ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, FnSig, FreeRegion, GenSig,\n+    GeneratorSubsts, GeneratorSubstsParts, ParamConst, ParamTy, PolyExistentialProjection,\n+    PolyExistentialTraitRef, PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind,\n+    RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts,\n };\n pub use self::trait_def::TraitDef;\n \n@@ -302,7 +302,7 @@ impl<'tcx> TyS<'tcx> {\n \n // `TyS` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(TyS<'_>, 32);\n+static_assert_size!(TyS<'_>, 40);\n \n impl<'tcx> Ord for TyS<'tcx> {\n     fn cmp(&self, other: &TyS<'tcx>) -> Ordering {\n@@ -359,14 +359,14 @@ impl ty::EarlyBoundRegion {\n \n #[derive(Debug)]\n crate struct PredicateInner<'tcx> {\n-    kind: Binder<PredicateKind<'tcx>>,\n+    kind: Binder<'tcx, PredicateKind<'tcx>>,\n     flags: TypeFlags,\n     /// See the comment for the corresponding field of [TyS].\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(PredicateInner<'_>, 40);\n+static_assert_size!(PredicateInner<'_>, 48);\n \n #[derive(Clone, Copy, Lift)]\n pub struct Predicate<'tcx> {\n@@ -389,9 +389,9 @@ impl Hash for Predicate<'_> {\n impl<'tcx> Eq for Predicate<'tcx> {}\n \n impl<'tcx> Predicate<'tcx> {\n-    /// Gets the inner `Binder<PredicateKind<'tcx>>`.\n+    /// Gets the inner `Binder<'tcx, PredicateKind<'tcx>>`.\n     #[inline]\n-    pub fn kind(self) -> Binder<PredicateKind<'tcx>> {\n+    pub fn kind(self) -> Binder<'tcx, PredicateKind<'tcx>> {\n         self.inner.kind\n     }\n }\n@@ -543,10 +543,33 @@ impl<'tcx> Predicate<'tcx> {\n         // substitution code expects equal binding levels in the values\n         // from the substitution and the value being substituted into, and\n         // this trick achieves that).\n-        let substs = trait_ref.skip_binder().substs;\n-        let pred = self.kind().skip_binder();\n-        let new = pred.subst(tcx, substs);\n-        tcx.reuse_or_mk_predicate(self, ty::Binder::bind(new))\n+\n+        // Working through the second example:\n+        // trait_ref: for<'x> T: Foo1<'^0.0>; substs: [T, '^0.0]\n+        // predicate: for<'b> Self: Bar1<'a, '^0.0>; substs: [Self, 'a, '^0.0]\n+        // We want to end up with:\n+        //     for<'x, 'b> T: Bar1<'^0.0, '^0.1>\n+        // To do this:\n+        // 1) We must shift all bound vars in predicate by the length\n+        //    of trait ref's bound vars. So, we would end up with predicate like\n+        //    Self: Bar1<'a, '^0.1>\n+        // 2) We can then apply the trait substs to this, ending up with\n+        //    T: Bar1<'^0.0, '^0.1>\n+        // 3) Finally, to create the final bound vars, we concatenate the bound\n+        //    vars of the trait ref with those of the predicate:\n+        //    ['x, 'b]\n+        let bound_pred = self.kind();\n+        let pred_bound_vars = bound_pred.bound_vars();\n+        let trait_bound_vars = trait_ref.bound_vars();\n+        // 1) Self: Bar1<'a, '^0.0> -> Self: Bar1<'a, '^0.1>\n+        let shifted_pred =\n+            tcx.shift_bound_var_indices(trait_bound_vars.len(), bound_pred.skip_binder());\n+        // 2) Self: Bar1<'a, '^0.1> -> T: Bar1<'^0.0, '^0.1>\n+        let new = shifted_pred.subst(tcx, trait_ref.skip_binder().substs);\n+        // 3) ['x] + ['b] -> ['x, 'b]\n+        let bound_vars =\n+            tcx.mk_bound_variable_kinds(trait_bound_vars.iter().chain(pred_bound_vars));\n+        tcx.reuse_or_mk_predicate(self, ty::Binder::bind_with_vars(new, bound_vars))\n     }\n }\n \n@@ -556,7 +579,7 @@ pub struct TraitPredicate<'tcx> {\n     pub trait_ref: TraitRef<'tcx>,\n }\n \n-pub type PolyTraitPredicate<'tcx> = ty::Binder<TraitPredicate<'tcx>>;\n+pub type PolyTraitPredicate<'tcx> = ty::Binder<'tcx, TraitPredicate<'tcx>>;\n \n impl<'tcx> TraitPredicate<'tcx> {\n     pub fn def_id(self) -> DefId {\n@@ -574,7 +597,7 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n         self.skip_binder().def_id()\n     }\n \n-    pub fn self_ty(self) -> ty::Binder<Ty<'tcx>> {\n+    pub fn self_ty(self) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.map_bound(|trait_ref| trait_ref.self_ty())\n     }\n }\n@@ -584,8 +607,8 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n pub struct OutlivesPredicate<A, B>(pub A, pub B); // `A: B`\n pub type RegionOutlivesPredicate<'tcx> = OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>;\n pub type TypeOutlivesPredicate<'tcx> = OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>;\n-pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<RegionOutlivesPredicate<'tcx>>;\n-pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<TypeOutlivesPredicate<'tcx>>;\n+pub type PolyRegionOutlivesPredicate<'tcx> = ty::Binder<'tcx, RegionOutlivesPredicate<'tcx>>;\n+pub type PolyTypeOutlivesPredicate<'tcx> = ty::Binder<'tcx, TypeOutlivesPredicate<'tcx>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n@@ -594,7 +617,7 @@ pub struct SubtypePredicate<'tcx> {\n     pub a: Ty<'tcx>,\n     pub b: Ty<'tcx>,\n }\n-pub type PolySubtypePredicate<'tcx> = ty::Binder<SubtypePredicate<'tcx>>;\n+pub type PolySubtypePredicate<'tcx> = ty::Binder<'tcx, SubtypePredicate<'tcx>>;\n \n /// This kind of predicate has no *direct* correspondent in the\n /// syntax, but it roughly corresponds to the syntactic forms:\n@@ -615,7 +638,7 @@ pub struct ProjectionPredicate<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-pub type PolyProjectionPredicate<'tcx> = Binder<ProjectionPredicate<'tcx>>;\n+pub type PolyProjectionPredicate<'tcx> = Binder<'tcx, ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n     /// Returns the `DefId` of the trait of the associated item being projected.\n@@ -637,7 +660,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n         self.map_bound(|predicate| predicate.projection_ty.trait_ref(tcx))\n     }\n \n-    pub fn ty(&self) -> Binder<Ty<'tcx>> {\n+    pub fn ty(&self) -> Binder<'tcx, Ty<'tcx>> {\n         self.map_bound(|predicate| predicate.ty)\n     }\n \n@@ -671,7 +694,7 @@ pub trait ToPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx>;\n }\n \n-impl ToPredicate<'tcx> for Binder<PredicateKind<'tcx>> {\n+impl ToPredicate<'tcx> for Binder<'tcx, PredicateKind<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         tcx.mk_predicate(self)\n@@ -694,11 +717,11 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        ConstnessAnd {\n-            value: self.value.map_bound(|trait_ref| ty::TraitPredicate { trait_ref }),\n-            constness: self.constness,\n-        }\n-        .to_predicate(tcx)\n+        self.value\n+            .map_bound(|trait_ref| {\n+                PredicateKind::Trait(ty::TraitPredicate { trait_ref }, self.constness)\n+            })\n+            .to_predicate(tcx)\n     }\n }\n "}, {"sha": "3b0cb8d421551702c3ca55393af89220c0c03ef5", "filename": "compiler/rustc_middle/src/ty/normalize_erasing_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fnormalize_erasing_regions.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// If you have a `Binder<T>`, you can do this to strip out the\n+    /// If you have a `Binder<'tcx, T>`, you can do this to strip out the\n     /// late-bound regions and then normalize the result, yielding up\n     /// a `T` (with regions erased). This is appropriate when the\n     /// binder is being instantiated at the call site.\n@@ -49,7 +49,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn normalize_erasing_late_bound_regions<T>(\n         self,\n         param_env: ty::ParamEnv<'tcx>,\n-        value: ty::Binder<T>,\n+        value: ty::Binder<'tcx, T>,\n     ) -> T\n     where\n         T: TypeFoldable<'tcx>,"}, {"sha": "13e2122a619dcf3bd097c8ad56cfd207c385c5bc", "filename": "compiler/rustc_middle/src/ty/print/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -63,7 +63,7 @@ pub trait Printer<'tcx>: Sized {\n \n     fn print_dyn_existential(\n         self,\n-        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error>;\n \n     fn print_const(self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error>;\n@@ -346,7 +346,7 @@ impl<'tcx, P: Printer<'tcx>> Print<'tcx, P> for Ty<'tcx> {\n }\n \n impl<'tcx, P: Printer<'tcx>> Print<'tcx, P>\n-    for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>\n+    for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n {\n     type Output = P::DynExistential;\n     type Error = P::Error;"}, {"sha": "b8f39fce21d656fe4bff1eeed78124944426692c", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -202,7 +202,7 @@ pub trait PrettyPrinter<'tcx>:\n         self.print_def_path(def_id, substs)\n     }\n \n-    fn in_binder<T>(self, value: &ty::Binder<T>) -> Result<Self, Self::Error>\n+    fn in_binder<T>(self, value: &ty::Binder<'tcx, T>) -> Result<Self, Self::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n     {\n@@ -211,7 +211,7 @@ pub trait PrettyPrinter<'tcx>:\n \n     fn wrap_binder<T, F: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n         self,\n-        value: &ty::Binder<T>,\n+        value: &ty::Binder<'tcx, T>,\n         f: F,\n     ) -> Result<Self, Self::Error>\n     where\n@@ -765,7 +765,7 @@ pub trait PrettyPrinter<'tcx>:\n \n     fn pretty_print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         // Generate the main trait ref, including associated types.\n         let mut first = true;\n@@ -1432,7 +1432,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n     fn print_dyn_existential(\n         self,\n-        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         self.pretty_print_dyn_existential(predicates)\n     }\n@@ -1571,7 +1571,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         Ok(self)\n     }\n \n-    fn in_binder<T>(self, value: &ty::Binder<T>) -> Result<Self, Self::Error>\n+    fn in_binder<T>(self, value: &ty::Binder<'tcx, T>) -> Result<Self, Self::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = Self::Error> + TypeFoldable<'tcx>,\n     {\n@@ -1580,7 +1580,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n     fn wrap_binder<T, C: Fn(&T, Self) -> Result<Self, Self::Error>>(\n         self,\n-        value: &ty::Binder<T>,\n+        value: &ty::Binder<'tcx, T>,\n         f: C,\n     ) -> Result<Self, Self::Error>\n     where\n@@ -1636,7 +1636,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n                 data.name != kw::Empty && data.name != kw::UnderscoreLifetime\n             }\n \n-            ty::ReLateBound(_, ty::BoundRegion { kind: br })\n+            ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n             | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n@@ -1715,7 +1715,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n                     return Ok(self);\n                 }\n             }\n-            ty::ReLateBound(_, ty::BoundRegion { kind: br })\n+            ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n             | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n@@ -1763,7 +1763,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n     pub fn name_all_regions<T>(\n         mut self,\n-        value: &ty::Binder<T>,\n+        value: &ty::Binder<'tcx, T>,\n     ) -> Result<(Self, (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)), fmt::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>,\n@@ -1821,7 +1821,8 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n                     ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n                 }\n             };\n-            self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind }))\n+            self.tcx\n+                .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { var: br.var, kind }))\n         });\n         start_or_continue(&mut self, \"\", \"> \")?;\n \n@@ -1830,7 +1831,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         Ok((self, new_value))\n     }\n \n-    pub fn pretty_in_binder<T>(self, value: &ty::Binder<T>) -> Result<Self, fmt::Error>\n+    pub fn pretty_in_binder<T>(self, value: &ty::Binder<'tcx, T>) -> Result<Self, fmt::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = fmt::Error> + TypeFoldable<'tcx>,\n     {\n@@ -1844,7 +1845,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n \n     pub fn pretty_wrap_binder<T, C: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n         self,\n-        value: &ty::Binder<T>,\n+        value: &ty::Binder<'tcx, T>,\n         f: C,\n     ) -> Result<Self, fmt::Error>\n     where\n@@ -1858,14 +1859,14 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         Ok(inner)\n     }\n \n-    fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<T>)\n+    fn prepare_late_bound_region_info<T>(&mut self, value: &ty::Binder<'tcx, T>)\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<Symbol>);\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name) }) = *r {\n+                if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) = *r {\n                     self.0.insert(name);\n                 }\n                 r.super_visit_with(self)\n@@ -1879,7 +1880,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n     }\n }\n \n-impl<'tcx, T, P: PrettyPrinter<'tcx>> Print<'tcx, P> for ty::Binder<T>\n+impl<'tcx, T, P: PrettyPrinter<'tcx>> Print<'tcx, P> for ty::Binder<'tcx, T>\n where\n     T: Print<'tcx, P, Output = P, Error = P::Error> + TypeFoldable<'tcx>,\n {\n@@ -1966,28 +1967,28 @@ impl ty::TraitRef<'tcx> {\n     }\n }\n \n-impl ty::Binder<ty::TraitRef<'tcx>> {\n-    pub fn print_only_trait_path(self) -> ty::Binder<TraitRefPrintOnlyTraitPath<'tcx>> {\n+impl ty::Binder<'tcx, ty::TraitRef<'tcx>> {\n+    pub fn print_only_trait_path(self) -> ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>> {\n         self.map_bound(|tr| tr.print_only_trait_path())\n     }\n }\n \n forward_display_to_print! {\n     Ty<'tcx>,\n-    &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+    &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     &'tcx ty::Const<'tcx>,\n \n     // HACK(eddyb) these are exhaustive instead of generic,\n     // because `for<'tcx>` isn't possible yet.\n-    ty::Binder<ty::ExistentialPredicate<'tcx>>,\n-    ty::Binder<ty::TraitRef<'tcx>>,\n-    ty::Binder<TraitRefPrintOnlyTraitPath<'tcx>>,\n-    ty::Binder<ty::FnSig<'tcx>>,\n-    ty::Binder<ty::TraitPredicate<'tcx>>,\n-    ty::Binder<ty::SubtypePredicate<'tcx>>,\n-    ty::Binder<ty::ProjectionPredicate<'tcx>>,\n-    ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n-    ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>,\n+    ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>,\n+    ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+    ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n+    ty::Binder<'tcx, ty::FnSig<'tcx>>,\n+    ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n+    ty::Binder<'tcx, ty::SubtypePredicate<'tcx>>,\n+    ty::Binder<'tcx, ty::ProjectionPredicate<'tcx>>,\n+    ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n+    ty::Binder<'tcx, ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>,\n \n     ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>,\n     ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>"}, {"sha": "ca60339da0d00b9d138030dcf8c444994e52eba8", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -93,9 +93,9 @@ pub trait TypeRelation<'tcx>: Sized {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>;\n }\n@@ -594,7 +594,7 @@ fn check_const_value_eq<R: TypeRelation<'tcx>>(\n     })\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>> {\n+impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n         a: Self,\n@@ -619,10 +619,9 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'\n         let v = iter::zip(a_v, b_v).map(|(ep_a, ep_b)| {\n             use crate::ty::ExistentialPredicate::*;\n             match (ep_a.skip_binder(), ep_b.skip_binder()) {\n-                (Trait(a), Trait(b)) => Ok(ty::Binder::bind(Trait(\n-                    relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),\n-                ))),\n-                (Projection(a), Projection(b)) => Ok(ty::Binder::bind(Projection(\n+                (Trait(a), Trait(b)) => Ok(ep_a\n+                    .rebind(Trait(relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder()))),\n+                (Projection(a), Projection(b)) => Ok(ep_a.rebind(Projection(\n                     relation.relate(ep_a.rebind(a), ep_b.rebind(b))?.skip_binder(),\n                 ))),\n                 (AutoTrait(a), AutoTrait(b)) if a == b => Ok(ep_a.rebind(AutoTrait(a))),\n@@ -685,12 +684,12 @@ impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n     }\n }\n \n-impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<T> {\n+impl<'tcx, T: Relate<'tcx>> Relate<'tcx> for ty::Binder<'tcx, T> {\n     fn relate<R: TypeRelation<'tcx>>(\n         relation: &mut R,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>> {\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>> {\n         relation.binders(a, b)\n     }\n }"}, {"sha": "a969626b370f5d2dc6320f245d05112343aa60e8", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -454,10 +454,16 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n     }\n }\n \n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n-    type Lifted = ty::Binder<T::Lifted>;\n+impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<'a, T>\n+where\n+    <T as Lift<'tcx>>::Lifted: TypeFoldable<'tcx>,\n+{\n+    type Lifted = ty::Binder<'tcx, T::Lifted>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        self.map_bound(|v| tcx.lift(v)).transpose()\n+        let bound_vars = tcx.lift(self.bound_vars());\n+        tcx.lift(self.skip_binder())\n+            .zip(bound_vars)\n+            .map(|(value, vars)| ty::Binder::bind_with_vars(value, vars))\n     }\n }\n \n@@ -749,7 +755,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Box<[T]> {\n     }\n }\n \n-impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<'tcx, T> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         self.map_bound(|ty| ty.fold_with(folder))\n     }\n@@ -767,7 +773,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         ty::util::fold_list(self, folder, |tcx, v| tcx.intern_poly_existential_predicates(v))\n     }"}, {"sha": "e352d0bc756976d039daa460450ac0e10a6aa19c", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 91, "deletions": 70, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -5,6 +5,8 @@\n use self::TyKind::*;\n \n use crate::infer::canonical::Canonical;\n+use crate::ty::fold::BoundVarsCollector;\n+use crate::ty::fold::ValidateBoundVars;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::InferTy::{self, *};\n use crate::ty::{\n@@ -62,22 +64,10 @@ pub enum BoundRegionKind {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub struct BoundRegion {\n+    pub var: BoundVar,\n     pub kind: BoundRegionKind,\n }\n \n-impl BoundRegion {\n-    /// When canonicalizing, we replace unbound inference variables and free\n-    /// regions with anonymous late bound regions. This method asserts that\n-    /// we have an anonymous late bound region, which hence may refer to\n-    /// a canonical variable.\n-    pub fn assert_bound_var(&self) -> BoundVar {\n-        match self.kind {\n-            BoundRegionKind::BrAnon(var) => BoundVar::from_u32(var),\n-            _ => bug!(\"bound region is not anonymous\"),\n-        }\n-    }\n-}\n-\n impl BoundRegionKind {\n     pub fn is_named(&self) -> bool {\n         match *self {\n@@ -161,7 +151,7 @@ pub enum TyKind<'tcx> {\n     FnPtr(PolyFnSig<'tcx>),\n \n     /// A trait object. Written as `dyn for<'b> Trait<'b, Assoc = u32> + Send + 'a`.\n-    Dynamic(&'tcx List<Binder<ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n+    Dynamic(&'tcx List<Binder<'tcx, ExistentialPredicate<'tcx>>>, ty::Region<'tcx>),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -173,7 +163,7 @@ pub enum TyKind<'tcx> {\n \n     /// A type representing the types stored inside a generator.\n     /// This should only appear in GeneratorInteriors.\n-    GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n+    GeneratorWitness(Binder<'tcx, &'tcx List<Ty<'tcx>>>),\n \n     /// The never type `!`.\n     Never,\n@@ -232,7 +222,7 @@ impl TyKind<'tcx> {\n \n // `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(TyKind<'_>, 24);\n+static_assert_size!(TyKind<'_>, 32);\n \n /// A closure can be modeled as a struct that looks like:\n ///\n@@ -747,7 +737,7 @@ impl<'tcx> ExistentialPredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n+impl<'tcx> Binder<'tcx, ExistentialPredicate<'tcx>> {\n     pub fn with_self_ty(&self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ty::Predicate<'tcx> {\n         use crate::ty::ToPredicate;\n         match self.skip_binder() {\n@@ -768,7 +758,7 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n     }\n }\n \n-impl<'tcx> List<ty::Binder<ExistentialPredicate<'tcx>>> {\n+impl<'tcx> List<ty::Binder<'tcx, ExistentialPredicate<'tcx>>> {\n     /// Returns the \"principal `DefId`\" of this set of existential predicates.\n     ///\n     /// A Rust trait object type consists (in addition to a lifetime bound)\n@@ -794,7 +784,7 @@ impl<'tcx> List<ty::Binder<ExistentialPredicate<'tcx>>> {\n     /// is `{Send, Sync}`, while there is no principal. These trait objects\n     /// have a \"trivial\" vtable consisting of just the size, alignment,\n     /// and destructor.\n-    pub fn principal(&self) -> Option<ty::Binder<ExistentialTraitRef<'tcx>>> {\n+    pub fn principal(&self) -> Option<ty::Binder<'tcx, ExistentialTraitRef<'tcx>>> {\n         self[0]\n             .map_bound(|this| match this {\n                 ExistentialPredicate::Trait(tr) => Some(tr),\n@@ -810,7 +800,7 @@ impl<'tcx> List<ty::Binder<ExistentialPredicate<'tcx>>> {\n     #[inline]\n     pub fn projection_bounds<'a>(\n         &'a self,\n-    ) -> impl Iterator<Item = ty::Binder<ExistentialProjection<'tcx>>> + 'a {\n+    ) -> impl Iterator<Item = ty::Binder<'tcx, ExistentialProjection<'tcx>>> + 'a {\n         self.iter().filter_map(|predicate| {\n             predicate\n                 .map_bound(|pred| match pred {\n@@ -875,10 +865,10 @@ impl<'tcx> TraitRef<'tcx> {\n     }\n }\n \n-pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n+pub type PolyTraitRef<'tcx> = Binder<'tcx, TraitRef<'tcx>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {\n-    pub fn self_ty(&self) -> Binder<Ty<'tcx>> {\n+    pub fn self_ty(&self) -> Binder<'tcx, Ty<'tcx>> {\n         self.map_bound_ref(|tr| tr.self_ty())\n     }\n \n@@ -931,7 +921,7 @@ impl<'tcx> ExistentialTraitRef<'tcx> {\n     }\n }\n \n-pub type PolyExistentialTraitRef<'tcx> = Binder<ExistentialTraitRef<'tcx>>;\n+pub type PolyExistentialTraitRef<'tcx> = Binder<'tcx, ExistentialTraitRef<'tcx>>;\n \n impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     pub fn def_id(&self) -> DefId {\n@@ -947,36 +937,56 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n+#[derive(HashStable)]\n+pub enum BoundVariableKind {\n+    Ty(BoundTyKind),\n+    Region(BoundRegionKind),\n+    Const,\n+}\n+\n /// Binder is a binder for higher-ranked lifetimes or types. It is part of the\n /// compiler's representation for things like `for<'a> Fn(&'a isize)`\n /// (which would be represented by the type `PolyTraitRef ==\n-/// Binder<TraitRef>`). Note that when we instantiate,\n+/// Binder<'tcx, TraitRef>`). Note that when we instantiate,\n /// erase, or otherwise \"discharge\" these bound vars, we change the\n-/// type from `Binder<T>` to just `T` (see\n+/// type from `Binder<'tcx, T>` to just `T` (see\n /// e.g., `liberate_late_bound_regions`).\n ///\n /// `Decodable` and `Encodable` are implemented for `Binder<T>` using the `impl_binder_encode_decode!` macro.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-pub struct Binder<T>(T);\n+pub struct Binder<'tcx, T>(T, &'tcx List<BoundVariableKind>);\n \n-impl<T> Binder<T> {\n+impl<'tcx, T> Binder<'tcx, T>\n+where\n+    T: TypeFoldable<'tcx>,\n+{\n     /// Wraps `value` in a binder, asserting that `value` does not\n     /// contain any bound vars that would be bound by the\n     /// binder. This is commonly used to 'inject' a value T into a\n     /// different binding level.\n-    pub fn dummy<'tcx>(value: T) -> Binder<T>\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n+    pub fn dummy(value: T) -> Binder<'tcx, T> {\n         debug_assert!(!value.has_escaping_bound_vars());\n-        Binder(value)\n+        Binder(value, ty::List::empty())\n     }\n \n     /// Wraps `value` in a binder, binding higher-ranked vars (if any).\n-    pub fn bind(value: T) -> Binder<T> {\n-        Binder(value)\n+    pub fn bind(value: T, tcx: TyCtxt<'tcx>) -> Binder<'tcx, T> {\n+        let mut collector = BoundVarsCollector::new();\n+        value.visit_with(&mut collector);\n+        Binder(value, collector.into_vars(tcx))\n+    }\n+\n+    pub fn bind_with_vars(value: T, vars: &'tcx List<BoundVariableKind>) -> Binder<'tcx, T> {\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(vars);\n+            value.visit_with(&mut validator);\n+        }\n+        Binder(value, vars)\n     }\n+}\n \n+impl<'tcx, T> Binder<'tcx, T> {\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// De Bruijn indices and the like. It is usually better to\n@@ -997,22 +1007,39 @@ impl<T> Binder<T> {\n         self.0\n     }\n \n-    pub fn as_ref(&self) -> Binder<&T> {\n-        Binder(&self.0)\n+    pub fn bound_vars(&self) -> &'tcx List<BoundVariableKind> {\n+        self.1\n+    }\n+\n+    pub fn as_ref(&self) -> Binder<'tcx, &T> {\n+        Binder(&self.0, self.1)\n     }\n \n-    pub fn map_bound_ref<F, U>(&self, f: F) -> Binder<U>\n+    pub fn map_bound_ref_unchecked<F, U>(&self, f: F) -> Binder<'tcx, U>\n+    where\n+        F: FnOnce(&T) -> U,\n+    {\n+        let value = f(&self.0);\n+        Binder(value, self.1)\n+    }\n+\n+    pub fn map_bound_ref<F, U: TypeFoldable<'tcx>>(&self, f: F) -> Binder<'tcx, U>\n     where\n         F: FnOnce(&T) -> U,\n     {\n         self.as_ref().map_bound(f)\n     }\n \n-    pub fn map_bound<F, U>(self, f: F) -> Binder<U>\n+    pub fn map_bound<F, U: TypeFoldable<'tcx>>(self, f: F) -> Binder<'tcx, U>\n     where\n         F: FnOnce(T) -> U,\n     {\n-        Binder(f(self.0))\n+        let value = f(self.0);\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(self.1);\n+            value.visit_with(&mut validator);\n+        }\n+        Binder(value, self.1)\n     }\n \n     /// Wraps a `value` in a binder, using the same bound variables as the\n@@ -1024,8 +1051,15 @@ impl<T> Binder<T> {\n     /// don't actually track bound vars. However, semantically, it is different\n     /// because bound vars aren't allowed to change here, whereas they are\n     /// in `bind`. This may be (debug) asserted in the future.\n-    pub fn rebind<U>(&self, value: U) -> Binder<U> {\n-        Binder(value)\n+    pub fn rebind<U>(&self, value: U) -> Binder<'tcx, U>\n+    where\n+        U: TypeFoldable<'tcx>,\n+    {\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(self.bound_vars());\n+            value.visit_with(&mut validator);\n+        }\n+        Binder(value, self.1)\n     }\n \n     /// Unwraps and returns the value within, but only if it contains\n@@ -1038,45 +1072,32 @@ impl<T> Binder<T> {\n     /// binders, but that would require adjusting the debruijn\n     /// indices, and given the shallow binding structure we often use,\n     /// would not be that useful.)\n-    pub fn no_bound_vars<'tcx>(self) -> Option<T>\n+    pub fn no_bound_vars(self) -> Option<T>\n     where\n         T: TypeFoldable<'tcx>,\n     {\n         if self.0.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }\n     }\n \n-    /// Given two things that have the same binder level,\n-    /// and an operation that wraps on their contents, executes the operation\n-    /// and then wraps its result.\n-    ///\n-    /// `f` should consider bound regions at depth 1 to be free, and\n-    /// anything it produces with bound regions at depth 1 will be\n-    /// bound in the resulting return value.\n-    pub fn fuse<U, F, R>(self, u: Binder<U>, f: F) -> Binder<R>\n-    where\n-        F: FnOnce(T, U) -> R,\n-    {\n-        Binder(f(self.0, u.0))\n-    }\n-\n     /// Splits the contents into two things that share the same binder\n     /// level as the original, returning two distinct binders.\n     ///\n     /// `f` should consider bound regions at depth 1 to be free, and\n     /// anything it produces with bound regions at depth 1 will be\n     /// bound in the resulting return values.\n-    pub fn split<U, V, F>(self, f: F) -> (Binder<U>, Binder<V>)\n+    pub fn split<U, V, F>(self, f: F) -> (Binder<'tcx, U>, Binder<'tcx, V>)\n     where\n         F: FnOnce(T) -> (U, V),\n     {\n         let (u, v) = f(self.0);\n-        (Binder(u), Binder(v))\n+        (Binder(u, self.1), Binder(v, self.1))\n     }\n }\n \n-impl<T> Binder<Option<T>> {\n-    pub fn transpose(self) -> Option<Binder<T>> {\n-        self.0.map(Binder)\n+impl<'tcx, T> Binder<'tcx, Option<T>> {\n+    pub fn transpose(self) -> Option<Binder<'tcx, T>> {\n+        let bound_vars = self.1;\n+        self.0.map(|v| Binder(v, bound_vars))\n     }\n }\n \n@@ -1139,7 +1160,7 @@ pub struct GenSig<'tcx> {\n     pub return_ty: Ty<'tcx>,\n }\n \n-pub type PolyGenSig<'tcx> = Binder<GenSig<'tcx>>;\n+pub type PolyGenSig<'tcx> = Binder<'tcx, GenSig<'tcx>>;\n \n /// Signature of a function type, which we have arbitrarily\n /// decided to use to refer to the input/output types.\n@@ -1177,22 +1198,22 @@ impl<'tcx> FnSig<'tcx> {\n     }\n }\n \n-pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n+pub type PolyFnSig<'tcx> = Binder<'tcx, FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n     #[inline]\n-    pub fn inputs(&self) -> Binder<&'tcx [Ty<'tcx>]> {\n-        self.map_bound_ref(|fn_sig| fn_sig.inputs())\n+    pub fn inputs(&self) -> Binder<'tcx, &'tcx [Ty<'tcx>]> {\n+        self.map_bound_ref_unchecked(|fn_sig| fn_sig.inputs())\n     }\n     #[inline]\n-    pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n+    pub fn input(&self, index: usize) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n     }\n-    pub fn inputs_and_output(&self) -> ty::Binder<&'tcx List<Ty<'tcx>>> {\n+    pub fn inputs_and_output(&self) -> ty::Binder<'tcx, &'tcx List<Ty<'tcx>>> {\n         self.map_bound_ref(|fn_sig| fn_sig.inputs_and_output)\n     }\n     #[inline]\n-    pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n+    pub fn output(&self) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.map_bound_ref(|fn_sig| fn_sig.output())\n     }\n     pub fn c_variadic(&self) -> bool {\n@@ -1206,7 +1227,7 @@ impl<'tcx> PolyFnSig<'tcx> {\n     }\n }\n \n-pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n+pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<'tcx, FnSig<'tcx>>>;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n@@ -1450,7 +1471,7 @@ pub struct ExistentialProjection<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-pub type PolyExistentialProjection<'tcx> = Binder<ExistentialProjection<'tcx>>;\n+pub type PolyExistentialProjection<'tcx> = Binder<'tcx, ExistentialProjection<'tcx>>;\n \n impl<'tcx> ExistentialProjection<'tcx> {\n     /// Extracts the underlying existential trait reference from this projection."}, {"sha": "8352e8b4918f0db45e8ba9095b5d5947e2088ffd", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -448,7 +448,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: ty::Binder<T>) -> ty::Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: ty::Binder<'tcx, T>,\n+    ) -> ty::Binder<'tcx, T> {\n         self.binders_passed += 1;\n         let t = t.super_fold_with(self);\n         self.binders_passed -= 1;"}, {"sha": "7d09ca5152ffe51220243af0fe977162a9894fc5", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -499,18 +499,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n-    ) -> Option<ty::Binder<Ty<'tcx>>> {\n+        env_region: ty::RegionKind,\n+    ) -> Option<Ty<'tcx>> {\n         let closure_ty = self.mk_closure(closure_def_id, closure_substs);\n-        let br = ty::BoundRegion { kind: ty::BrEnv };\n-        let env_region = ty::ReLateBound(ty::INNERMOST, br);\n         let closure_kind_ty = closure_substs.as_closure().kind_ty();\n         let closure_kind = closure_kind_ty.to_opt_closure_kind()?;\n         let env_ty = match closure_kind {\n             ty::ClosureKind::Fn => self.mk_imm_ref(self.mk_region(env_region), closure_ty),\n             ty::ClosureKind::FnMut => self.mk_mut_ref(self.mk_region(env_region), closure_ty),\n             ty::ClosureKind::FnOnce => closure_ty,\n         };\n-        Some(ty::Binder::bind(env_ty))\n+        Some(env_ty)\n     }\n \n     /// Returns `true` if the node pointed to by `def_id` is a `static` item."}, {"sha": "6ea0ba0a8e1ba517de570897e6751c083259c8ae", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -502,7 +502,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // lifetimes without names with the value `'0`.\n         match ty.kind() {\n             ty::Ref(\n-                ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br })\n+                ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n                 | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n                 _,\n                 _,\n@@ -523,7 +523,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let region = match ty.kind() {\n             ty::Ref(region, _, _) => {\n                 match region {\n-                    ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br })\n+                    ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n                     | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n                         printer.region_highlight_mode.highlighting_bound_region(*br, counter)\n                     }"}, {"sha": "3248554e2042744efe4b5b4eebe0bac611cbd672", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -2028,7 +2028,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                             traits::ObligationCauseCode::RepeatVec(is_const_fn),\n                                         ),\n                                         self.param_env,\n-                                        ty::Binder::bind(ty::TraitRef::new(\n+                                        ty::Binder::dummy(ty::TraitRef::new(\n                                             self.tcx().require_lang_item(\n                                                 LangItem::Copy,\n                                                 Some(self.last_span),"}, {"sha": "c2ac1e289ce4e1d1a0451600f3bd9434a73b9afb", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -589,31 +589,45 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         &self,\n         indices: &UniversalRegionIndices<'tcx>,\n         defining_ty: DefiningTy<'tcx>,\n-    ) -> ty::Binder<&'tcx ty::List<Ty<'tcx>>> {\n+    ) -> ty::Binder<'tcx, &'tcx ty::List<Ty<'tcx>>> {\n         let tcx = self.infcx.tcx;\n         match defining_ty {\n             DefiningTy::Closure(def_id, substs) => {\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n-                let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-                ty::Binder::fuse(closure_ty, inputs_and_output, |closure_ty, inputs_and_output| {\n-                    // The \"inputs\" of the closure in the\n-                    // signature appear as a tuple.  The MIR side\n-                    // flattens this tuple.\n-                    let (&output, tuplized_inputs) = inputs_and_output.split_last().unwrap();\n-                    assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n-                    let inputs = match tuplized_inputs[0].kind() {\n-                        ty::Tuple(inputs) => inputs,\n-                        _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n-                    };\n+                let bound_vars = tcx.mk_bound_variable_kinds(\n+                    inputs_and_output\n+                        .bound_vars()\n+                        .iter()\n+                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+                );\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    kind: ty::BrEnv,\n+                };\n+                let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+                let closure_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n+\n+                // The \"inputs\" of the closure in the\n+                // signature appear as a tuple.  The MIR side\n+                // flattens this tuple.\n+                let (&output, tuplized_inputs) =\n+                    inputs_and_output.skip_binder().split_last().unwrap();\n+                assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n+                let inputs = match tuplized_inputs[0].kind() {\n+                    ty::Tuple(inputs) => inputs,\n+                    _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n+                };\n \n+                ty::Binder::bind_with_vars(\n                     tcx.mk_type_list(\n                         iter::once(closure_ty)\n                             .chain(inputs.iter().map(|k| k.expect_ty()))\n                             .chain(iter::once(output)),\n-                    )\n-                })\n+                    ),\n+                    bound_vars,\n+                )\n             }\n \n             DefiningTy::Generator(def_id, substs, movability) => {\n@@ -657,7 +671,7 @@ trait InferCtxtExt<'tcx> {\n         &self,\n         origin: NllRegionVariableOrigin,\n         all_outlive_scope: LocalDefId,\n-        value: ty::Binder<T>,\n+        value: ty::Binder<'tcx, T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n     where\n@@ -686,7 +700,7 @@ impl<'cx, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'cx, 'tcx> {\n         &self,\n         origin: NllRegionVariableOrigin,\n         all_outlive_scope: LocalDefId,\n-        value: ty::Binder<T>,\n+        value: ty::Binder<'tcx, T>,\n         indices: &mut UniversalRegionIndices<'tcx>,\n     ) -> T\n     where"}, {"sha": "ae5e78ee33f472ef04eec379c512cb5997154fea", "filename": "compiler/rustc_mir/src/interpret/intrinsics/type_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics%2Ftype_name.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n \n     fn print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         let mut first = true;\n         for p in predicates {"}, {"sha": "9ca4b6687f1b54b934eaf0319653cb4c39d1c735", "filename": "compiler/rustc_mir/src/monomorphize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -8,14 +8,14 @@ pub mod collector;\n pub mod partitioning;\n pub mod polymorphize;\n \n-pub fn custom_coerce_unsize_info<'tcx>(\n+fn custom_coerce_unsize_info<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     source_ty: Ty<'tcx>,\n     target_ty: Ty<'tcx>,\n ) -> CustomCoerceUnsized {\n     let def_id = tcx.require_lang_item(LangItem::CoerceUnsized, None);\n \n-    let trait_ref = ty::Binder::bind(ty::TraitRef {\n+    let trait_ref = ty::Binder::dummy(ty::TraitRef {\n         def_id,\n         substs: tcx.mk_substs_trait(source_ty, &[target_ty.into()]),\n     });"}, {"sha": "ce5e41d3e7c866289896035965f68414bea0f1f6", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -850,9 +850,12 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                     let obligation = Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        Binder::bind(TraitPredicate {\n-                            trait_ref: TraitRef::from_method(tcx, trait_id, substs),\n-                        }),\n+                        Binder::bind(\n+                            TraitPredicate {\n+                                trait_ref: TraitRef::from_method(tcx, trait_id, substs),\n+                            },\n+                            tcx,\n+                        ),\n                     );\n \n                     let implsrc = tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "c90f94c6d63fbc3e547dc952afc0bfea2bdb3b1d", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -252,8 +252,13 @@ fn liberated_closure_env_ty(\n         _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty),\n     };\n \n-    let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs).unwrap();\n-    tcx.erase_late_bound_regions(closure_env_ty)\n+    let bound_vars =\n+        tcx.mk_bound_variable_kinds(std::iter::once(ty::BoundVariableKind::Region(ty::BrEnv)));\n+    let br =\n+        ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind: ty::BrEnv };\n+    let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+    let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs, env_region).unwrap();\n+    tcx.erase_late_bound_regions(ty::Binder::bind_with_vars(closure_env_ty, bound_vars))\n }\n \n #[derive(Debug, PartialEq, Eq)]"}, {"sha": "b89ad867f46ee82507d88c0509f94b47e6a26ce2", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 653, "deletions": 115, "changes": 768, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -30,7 +30,7 @@ use std::cell::Cell;\n use std::fmt;\n use std::mem::take;\n \n-use tracing::debug;\n+use tracing::{debug, span, Level};\n \n // This counts the no of times a lifetime is used\n #[derive(Clone, Copy, Debug)]\n@@ -42,9 +42,9 @@ pub enum LifetimeUseSet<'tcx> {\n trait RegionExt {\n     fn early(hir_map: &Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region);\n \n-    fn late(hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn late(index: u32, hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region);\n \n-    fn late_anon(index: &Cell<u32>) -> Region;\n+    fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region;\n \n     fn id(&self) -> Option<DefId>;\n \n@@ -67,53 +67,56 @@ impl RegionExt for Region {\n         (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id.to_def_id(), origin))\n     }\n \n-    fn late(hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn late(idx: u32, hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n         let depth = ty::INNERMOST;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n             param, depth, def_id, origin,\n         );\n-        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, def_id.to_def_id(), origin))\n+        (\n+            param.name.normalize_to_macros_2_0(),\n+            Region::LateBound(depth, idx, def_id.to_def_id(), origin),\n+        )\n     }\n \n-    fn late_anon(index: &Cell<u32>) -> Region {\n+    fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region {\n         let i = index.get();\n         index.set(i + 1);\n         let depth = ty::INNERMOST;\n-        Region::LateBoundAnon(depth, i)\n+        Region::LateBoundAnon(depth, named_late_bound_vars + i, i)\n     }\n \n     fn id(&self) -> Option<DefId> {\n         match *self {\n             Region::Static | Region::LateBoundAnon(..) => None,\n \n-            Region::EarlyBound(_, id, _) | Region::LateBound(_, id, _) | Region::Free(_, id) => {\n+            Region::EarlyBound(_, id, _) | Region::LateBound(_, _, id, _) | Region::Free(_, id) => {\n                 Some(id)\n             }\n         }\n     }\n \n     fn shifted(self, amount: u32) -> Region {\n         match self {\n-            Region::LateBound(debruijn, id, origin) => {\n-                Region::LateBound(debruijn.shifted_in(amount), id, origin)\n+            Region::LateBound(debruijn, idx, id, origin) => {\n+                Region::LateBound(debruijn.shifted_in(amount), idx, id, origin)\n             }\n-            Region::LateBoundAnon(debruijn, index) => {\n-                Region::LateBoundAnon(debruijn.shifted_in(amount), index)\n+            Region::LateBoundAnon(debruijn, index, anon_index) => {\n+                Region::LateBoundAnon(debruijn.shifted_in(amount), index, anon_index)\n             }\n             _ => self,\n         }\n     }\n \n     fn shifted_out_to_binder(self, binder: ty::DebruijnIndex) -> Region {\n         match self {\n-            Region::LateBound(debruijn, id, origin) => {\n-                Region::LateBound(debruijn.shifted_out_to_binder(binder), id, origin)\n+            Region::LateBound(debruijn, index, id, origin) => {\n+                Region::LateBound(debruijn.shifted_out_to_binder(binder), index, id, origin)\n             }\n-            Region::LateBoundAnon(debruijn, index) => {\n-                Region::LateBoundAnon(debruijn.shifted_out_to_binder(binder), index)\n+            Region::LateBoundAnon(debruijn, index, anon_index) => {\n+                Region::LateBoundAnon(debruijn.shifted_out_to_binder(binder), index, anon_index)\n             }\n             _ => self,\n         }\n@@ -147,6 +150,14 @@ struct NamedRegionMap {\n     // be late-bound if (a) it does NOT appear in a where-clause and\n     // (b) it DOES appear in the arguments.\n     late_bound: HirIdSet,\n+\n+    // Maps relevant hir items to the bound vars on them. These include:\n+    // - function defs\n+    // - function pointers\n+    // - closures\n+    // - trait refs\n+    // - bound types (like `T` in `for<'a> T<'a>: Foo`)\n+    late_bound_vars: HirIdMap<Vec<ty::BoundVariableKind>>,\n }\n \n crate struct LifetimeContext<'a, 'tcx> {\n@@ -161,13 +172,21 @@ crate struct LifetimeContext<'a, 'tcx> {\n     /// correct when representing these constraints, we should only introduce one\n     /// scope. However, we want to support both locations for the quantifier and\n     /// during lifetime resolution we want precise information (so we can't\n-    /// desugar in an earlier phase).\n+    /// desugar in an earlier phase). Moreso, an error here doesn't cause a bail\n+    /// from type checking, so we need to be extra careful that we don't lose\n+    /// any bound var information.\n     ///\n     /// So, if we encounter a quantifier at the outer scope, we set\n-    /// `trait_ref_hack` to `true` (and introduce a scope), and then if we encounter\n-    /// a quantifier at the inner scope, we error. If `trait_ref_hack` is `false`,\n-    /// then we introduce the scope at the inner quantifier.\n-    trait_ref_hack: bool,\n+    /// `trait_ref_hack` to the hir id of the bounded type (and introduce a scope).\n+    /// Then, if we encounter a quantifier at the inner scope, then we know to\n+    /// emit an error. Importantly though, we do have to track the lifetimes\n+    /// defined on the outer scope (i.e. the bounded ty), since we continue\n+    /// to type check after emitting an error; we therefore assume that the bound\n+    /// vars on the inner trait refs come from both quantifiers.\n+    ///\n+    /// If we encounter a quantifier in the inner scope `trait_ref_hack` being\n+    /// `None`, then we just introduce the scope at the inner quantifier as normal.\n+    trait_ref_hack: Option<hir::HirId>,\n \n     /// Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n     is_in_fn_syntax: bool,\n@@ -225,6 +244,17 @@ enum Scope<'a> {\n         /// of the resulting opaque type.\n         opaque_type_parent: bool,\n \n+        /// True only if this `Binder` scope is from the quantifiers on a\n+        /// `PolyTraitRef`. This is necessary for `assocated_type_bounds`, which\n+        /// requires binders of nested trait refs to be merged.\n+        from_poly_trait_ref: bool,\n+\n+        /// The late bound vars for a given item are stored by `HirId` to be\n+        /// queried later. However, if we enter an elision scope, we have to\n+        /// later append the elided bound vars to the list and need to know what\n+        /// to append to.\n+        hir_id: hir::HirId,\n+\n         s: ScopeRef<'a>,\n     },\n \n@@ -252,6 +282,50 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n+    /// This is a particularly interesting consequence of how we handle poly\n+    /// trait refs. See `trait_ref_hack` for additional info. This bit is\n+    /// important w.r.t. querying late-bound vars.\n+    ///\n+    /// To completely understand why this is necessary, first it's important to\n+    /// realize that `T: for<'a> U + for<'a, 'b> V` is actually two separate\n+    /// trait refs: `T: for<'a> U` and `T: for<'b> V` and as such, the late\n+    /// bound vars on each needs to be tracked separately. Also, in this case,\n+    /// are *three* relevant `HirId`s: one for the entire bound and one\n+    /// for each separate one.\n+    ///\n+    /// Next, imagine three different poly trait refs:\n+    ///   1) `for<'a, 'b> T: U<'a, 'b>`\n+    ///   2) `T: for<'a, 'b> U<'a, 'b>`\n+    ///   3) `for<'a> T: for<'b> U<'a, 'b>`\n+    ///\n+    /// First, note that the third example is semantically invalid and an error,\n+    /// but we *must* handle it as valid, since type checking isn't bailed out\n+    /// of. Other than that, if ask for bound vars for each, we expect\n+    /// `['a, 'b]`. If we *didn't* allow binders before `T`, then we would\n+    /// always introduce a binder scope at the inner trait ref. This is great,\n+    /// becauase later on during type-checking, we will ask \"what are the late\n+    /// bound vars on this trait ref\". However, because we allow bound vars on\n+    /// the bound itself, we have to have some way of keeping track of the fact\n+    /// that we actually want to store the late bound vars as being associated\n+    /// with the trait ref; this is that.\n+    ///\n+    /// One alternative way to handle this would be to just introduce a new\n+    /// `Binder` scope, but that's semantically a bit different, since bound\n+    /// vars from both `for<...>`s *do* share the same binder level.\n+    TraitRefHackInner {\n+        hir_id: hir::HirId,\n+        s: ScopeRef<'a>,\n+    },\n+\n+    /// When we have nested trait refs, we concanetate late bound vars for inner\n+    /// trait refs from outer ones. But we also need to include any HRTB\n+    /// lifetimes encountered when identifying the trait that an associated type\n+    /// is declared on.\n+    Supertrait {\n+        lifetimes: Vec<ty::BoundVariableKind>,\n+        s: ScopeRef<'a>,\n+    },\n+\n     Root,\n }\n \n@@ -266,13 +340,17 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 next_early_index,\n                 track_lifetime_uses,\n                 opaque_type_parent,\n+                from_poly_trait_ref,\n+                hir_id,\n                 s: _,\n             } => f\n                 .debug_struct(\"Binder\")\n                 .field(\"lifetimes\", lifetimes)\n                 .field(\"next_early_index\", next_early_index)\n                 .field(\"track_lifetime_uses\", track_lifetime_uses)\n                 .field(\"opaque_type_parent\", opaque_type_parent)\n+                .field(\"from_poly_trait_ref\", from_poly_trait_ref)\n+                .field(\"hir_id\", hir_id)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::Body { id, s: _ } => {\n@@ -286,6 +364,16 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetime\", lifetime)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n+            Scope::TraitRefHackInner { hir_id, s: _ } => f\n+                .debug_struct(\"TraitRefHackInner\")\n+                .field(\"hir_id\", hir_id)\n+                .field(\"s\", &\"..\")\n+                .finish(),\n+            Scope::Supertrait { lifetimes, s: _ } => f\n+                .debug_struct(\"Supertrait\")\n+                .field(\"lifetimes\", lifetimes)\n+                .field(\"s\", &\"..\")\n+                .finish(),\n             Scope::Root => f.debug_struct(\"Root\").finish(),\n         }\n     }\n@@ -294,8 +382,9 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n #[derive(Clone, Debug)]\n enum Elide {\n     /// Use a fresh anonymous late-bound lifetime each time, by\n-    /// incrementing the counter to generate sequential indices.\n-    FreshLateAnon(Cell<u32>),\n+    /// incrementing the counter to generate sequential indices. All\n+    /// anonymous lifetimes must start *after* named bound vars.\n+    FreshLateAnon(u32, Cell<u32>),\n     /// Always use this one lifetime.\n     Exact(Region),\n     /// Less or more than one lifetime were found, error on unspecified.\n@@ -334,6 +423,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n                 _ => None,\n             }\n         },\n+        late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n \n         ..*providers\n     };\n@@ -391,13 +481,16 @@ fn do_resolve(\n     trait_definition_only: bool,\n ) -> ResolveLifetimes {\n     let item = tcx.hir().expect_item(tcx.hir().local_def_id_to_hir_id(local_def_id));\n-    let mut named_region_map =\n-        NamedRegionMap { defs: Default::default(), late_bound: Default::default() };\n+    let mut named_region_map = NamedRegionMap {\n+        defs: Default::default(),\n+        late_bound: Default::default(),\n+        late_bound_vars: Default::default(),\n+    };\n     let mut visitor = LifetimeContext {\n         tcx,\n         map: &mut named_region_map,\n         scope: ROOT_SCOPE,\n-        trait_ref_hack: false,\n+        trait_ref_hack: None,\n         is_in_fn_syntax: false,\n         is_in_const_generic: false,\n         trait_definition_only,\n@@ -418,6 +511,10 @@ fn do_resolve(\n         let map = rl.late_bound.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id);\n     }\n+    for (hir_id, v) in named_region_map.late_bound_vars {\n+        let map = rl.late_bound_vars.entry(hir_id.owner).or_default();\n+        map.insert(hir_id.local_id, v);\n+    }\n \n     debug!(?rl.defs);\n     rl\n@@ -503,6 +600,19 @@ fn sub_items_have_self_param(node: &hir::ItemKind<'_>) -> bool {\n     matches!(*node, hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..))\n }\n \n+fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::BoundVariableKind {\n+    match region {\n+        Region::LateBound(_, _, def_id, _) => {\n+            let name = tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n+            ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n+        }\n+        Region::LateBoundAnon(_, _, anon_idx) => {\n+            ty::BoundVariableKind::Region(ty::BrAnon(*anon_idx))\n+        }\n+        _ => bug!(\"{:?} is not a late region\", region),\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n@@ -530,11 +640,58 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         self.labels_in_fn = saved;\n     }\n \n+    fn visit_fn(\n+        &mut self,\n+        fk: intravisit::FnKind<'tcx>,\n+        fd: &'tcx hir::FnDecl<'tcx>,\n+        b: hir::BodyId,\n+        s: rustc_span::Span,\n+        hir_id: hir::HirId,\n+    ) {\n+        let name = match fk {\n+            intravisit::FnKind::ItemFn(id, _, _, _) => id.as_str(),\n+            intravisit::FnKind::Method(id, _, _) => id.as_str(),\n+            intravisit::FnKind::Closure => Symbol::intern(\"closure\").as_str(),\n+        };\n+        let name: &str = &name;\n+        let span = span!(Level::DEBUG, \"visit_fn\", name);\n+        let _enter = span.enter();\n+        match fk {\n+            // Any `Binders` are handled elsewhere\n+            intravisit::FnKind::ItemFn(..) | intravisit::FnKind::Method(..) => {\n+                intravisit::walk_fn(self, fk, fd, b, s, hir_id)\n+            }\n+            intravisit::FnKind::Closure => {\n+                self.map.late_bound_vars.insert(hir_id, vec![]);\n+                let scope = Scope::Binder {\n+                    hir_id,\n+                    lifetimes: FxHashMap::default(),\n+                    next_early_index: self.next_early_index(),\n+                    s: self.scope,\n+                    track_lifetime_uses: true,\n+                    opaque_type_parent: false,\n+                    from_poly_trait_ref: false,\n+                };\n+                self.with(scope, move |_old_scope, this| {\n+                    intravisit::walk_fn(this, fk, fd, b, s, hir_id)\n+                });\n+            }\n+        }\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n+        match &item.kind {\n+            hir::ItemKind::Impl(hir::Impl { of_trait, .. }) => {\n+                if let Some(of_trait) = of_trait {\n+                    self.map.late_bound_vars.insert(of_trait.hir_ref_id, Vec::default());\n+                }\n+            }\n+            _ => {}\n+        }\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, ref generics, _) => {\n                 self.missing_named_lifetime_spots.push(generics.into());\n-                self.visit_early_late(None, &sig.decl, generics, |this| {\n+                self.visit_early_late(None, item.hir_id(), &sig.decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n                 self.missing_named_lifetime_spots.pop();\n@@ -582,6 +739,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                     self.map.late_bound.insert(hir::HirId { owner, local_id });\n                                 });\n                             }\n+                            for (&owner, late_bound_vars) in\n+                                resolved_lifetimes.late_bound_vars.iter()\n+                            {\n+                                late_bound_vars.iter().for_each(|(&local_id, late_bound_vars)| {\n+                                    self.map.late_bound_vars.insert(\n+                                        hir::HirId { owner, local_id },\n+                                        late_bound_vars.clone(),\n+                                    );\n+                                });\n+                            }\n                             break;\n                         }\n                         hir::Node::Crate(_) => bug!(\"No Item about an OpaqueTy\"),\n@@ -621,11 +788,14 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         }\n                     })\n                     .collect();\n+                self.map.late_bound_vars.insert(item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n+                    hir_id: item.hir_id(),\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n                     opaque_type_parent: true,\n                     track_lifetime_uses,\n+                    from_poly_trait_ref: false,\n                     s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -640,7 +810,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n             hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n-                self.visit_early_late(None, decl, generics, |this| {\n+                self.visit_early_late(None, item.hir_id(), decl, generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n@@ -672,21 +842,29 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.missing_named_lifetime_spots\n                     .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n+                let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) = c\n+                    .generic_params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => Some(param),\n+                        _ => None,\n+                    })\n+                    .enumerate()\n+                    .map(|(late_bound_idx, param)| {\n+                        let pair = Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n+                        let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                        (pair, r)\n+                    })\n+                    .unzip();\n+                self.map.late_bound_vars.insert(ty.hir_id, binders);\n                 let scope = Scope::Binder {\n-                    lifetimes: c\n-                        .generic_params\n-                        .iter()\n-                        .filter_map(|param| match param.kind {\n-                            GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::late(&self.tcx.hir(), param))\n-                            }\n-                            _ => None,\n-                        })\n-                        .collect(),\n+                    hir_id: ty.hir_id,\n+                    lifetimes,\n                     s: self.scope,\n                     next_early_index,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n+                    from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -721,7 +899,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // resolved the same as the `'_` in `&'_ Foo`.\n                         //\n                         // cc #48468\n-                        self.resolve_elided_lifetimes(vec![lifetime])\n+                        self.resolve_elided_lifetimes(&[lifetime])\n                     }\n                     LifetimeName::Param(_) | LifetimeName::Static => {\n                         // If the user wrote an explicit name, use that.\n@@ -784,7 +962,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // well-supported at the moment, so this doesn't work.\n                         // In the future, this should be fixed and this error should be removed.\n                         let def = self.map.defs.get(&lifetime.hir_id).cloned();\n-                        if let Some(Region::LateBound(_, def_id, _)) = def {\n+                        if let Some(Region::LateBound(_, _, def_id, _)) = def {\n                             if let Some(def_id) = def_id.as_local() {\n                                 let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                                 // Ensure that the parent of the def is an item, not HRTB\n@@ -863,17 +1041,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                 }\n                 let next_early_index = index + non_lifetime_count;\n+                self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n \n                 if let Some(elision_region) = elision {\n                     let scope =\n                         Scope::Elision { elide: Elide::Exact(elision_region), s: self.scope };\n                     self.with(scope, |_old_scope, this| {\n                         let scope = Scope::Binder {\n+                            hir_id: ty.hir_id,\n                             lifetimes,\n                             next_early_index,\n                             s: this.scope,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n+                            from_poly_trait_ref: false,\n                         };\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n@@ -884,11 +1065,13 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     });\n                 } else {\n                     let scope = Scope::Binder {\n+                        hir_id: ty.hir_id,\n                         lifetimes,\n                         next_early_index,\n                         s: self.scope,\n                         track_lifetime_uses: true,\n                         opaque_type_parent: false,\n+                        from_poly_trait_ref: false,\n                     };\n                     self.with(scope, |_old_scope, this| {\n                         this.visit_generics(generics);\n@@ -910,6 +1093,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n+                    trait_item.hir_id(),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n@@ -935,12 +1119,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         }\n                     })\n                     .collect();\n+                self.map.late_bound_vars.insert(trait_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n+                    hir_id: trait_item.hir_id(),\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n+                    from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n@@ -972,6 +1159,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n+                    impl_item.hir_id(),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n@@ -984,7 +1172,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut non_lifetime_count = 0;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics\n+                let lifetimes: FxHashMap<hir::ParamName, Region> = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n@@ -997,12 +1185,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         }\n                     })\n                     .collect();\n+                self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n                 let scope = Scope::Binder {\n+                    hir_id: ty.hir_id,\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n+                    from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n@@ -1024,7 +1215,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         if lifetime_ref.is_elided() {\n-            self.resolve_elided_lifetimes(vec![lifetime_ref]);\n+            self.resolve_elided_lifetimes(&[lifetime_ref]);\n             return;\n         }\n         if lifetime_ref.is_static() {\n@@ -1085,30 +1276,39 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ref bound_generic_params,\n                     ..\n                 }) => {\n-                    let lifetimes: FxHashMap<_, _> = bound_generic_params\n-                        .iter()\n-                        .filter_map(|param| match param.kind {\n-                            GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::late(&self.tcx.hir(), param))\n-                            }\n-                            _ => None,\n-                        })\n-                        .collect();\n+                    let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) =\n+                        bound_generic_params\n+                            .iter()\n+                            .filter_map(|param| match param.kind {\n+                                GenericParamKind::Lifetime { .. } => Some(param),\n+                                _ => None,\n+                            })\n+                            .enumerate()\n+                            .map(|(late_bound_idx, param)| {\n+                                let pair =\n+                                    Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n+                                let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                                (pair, r)\n+                            })\n+                            .unzip();\n+                    self.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n                     if !lifetimes.is_empty() {\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n+                            hir_id: bounded_ty.hir_id,\n                             lifetimes,\n                             s: self.scope,\n                             next_early_index,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n+                            from_poly_trait_ref: true,\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n                             this.visit_ty(&bounded_ty);\n-                            this.trait_ref_hack = true;\n+                            this.trait_ref_hack = Some(bounded_ty.hir_id);\n                             walk_list!(this, visit_param_bound, bounds);\n-                            this.trait_ref_hack = false;\n+                            this.trait_ref_hack = None;\n                         });\n                         result\n                     } else {\n@@ -1138,13 +1338,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_param_bound(&mut self, bound: &'tcx hir::GenericBound<'tcx>) {\n         match bound {\n-            hir::GenericBound::LangItemTrait { .. } if !self.trait_ref_hack => {\n+            hir::GenericBound::LangItemTrait(_, _, hir_id, _) if self.trait_ref_hack.is_none() => {\n+                self.map.late_bound_vars.insert(*hir_id, vec![]);\n                 let scope = Scope::Binder {\n+                    hir_id: *hir_id,\n                     lifetimes: FxHashMap::default(),\n                     s: self.scope,\n                     next_early_index: self.next_early_index(),\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n+                    from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |_, this| {\n                     intravisit::walk_param_bound(this, bound);\n@@ -1163,46 +1366,140 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n         let should_pop_missing_lt = self.is_trait_ref_fn_scope(trait_ref);\n \n-        let trait_ref_hack = take(&mut self.trait_ref_hack);\n-        if !trait_ref_hack\n-            || trait_ref\n+        let trait_ref_hack = self.trait_ref_hack.take();\n+        let next_early_index = self.next_early_index();\n+        // See note on `trait_ref_hack`. If `for<..>` has been defined in both\n+        // the outer and inner part of the trait ref, emit an error.\n+        let has_lifetimes = trait_ref.bound_generic_params.iter().any(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => true,\n+            _ => false,\n+        });\n+        if trait_ref_hack.is_some() && has_lifetimes {\n+            struct_span_err!(\n+                self.tcx.sess,\n+                trait_ref.span,\n+                E0316,\n+                \"nested quantification of lifetimes\"\n+            )\n+            .emit();\n+        }\n+\n+        let (binders, lifetimes) = if let Some(hir_id) = trait_ref_hack {\n+            let mut binders = self.map.late_bound_vars.entry(hir_id).or_default().clone();\n+            let initial_bound_vars = binders.len() as u32;\n+            let mut lifetimes: FxHashMap<hir::ParamName, Region> = FxHashMap::default();\n+            let binders_iter = trait_ref\n                 .bound_generic_params\n                 .iter()\n-                .any(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n-        {\n-            if trait_ref_hack {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    trait_ref.span,\n-                    E0316,\n-                    \"nested quantification of lifetimes\"\n-                )\n-                .emit();\n-            }\n-            let next_early_index = self.next_early_index();\n-            let scope = Scope::Binder {\n-                lifetimes: trait_ref\n-                    .bound_generic_params\n-                    .iter()\n-                    .filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::late(&self.tcx.hir(), param))\n+                .filter_map(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => Some(param),\n+                    _ => None,\n+                })\n+                .enumerate()\n+                .map(|(late_bound_idx, param)| {\n+                    let pair = Region::late(\n+                        initial_bound_vars + late_bound_idx as u32,\n+                        &self.tcx.hir(),\n+                        param,\n+                    );\n+                    let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                    lifetimes.insert(pair.0, pair.1);\n+                    r\n+                });\n+            binders.extend(binders_iter);\n+\n+            (binders, lifetimes)\n+        } else {\n+            let mut supertrait_lifetimes = vec![];\n+            let mut scope = self.scope;\n+            let mut outer_binders = loop {\n+                match scope {\n+                    Scope::Body { .. } | Scope::Root => {\n+                        break vec![];\n+                    }\n+\n+                    Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                        scope = s;\n+                    }\n+\n+                    Scope::TraitRefHackInner { hir_id, .. } => {\n+                        // Nested poly trait refs have the binders concatenated\n+                        // If we reach `TraitRefHackInner`, then there is only one more `Binder` above us,\n+                        // over all the bounds. We don't want this, since all the lifetimes we care about\n+                        // are here anyways.\n+                        let mut full_binders =\n+                            self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                        full_binders.extend(supertrait_lifetimes.into_iter());\n+                        break full_binders;\n+                    }\n+\n+                    Scope::Supertrait { s, lifetimes } => {\n+                        supertrait_lifetimes = lifetimes.clone();\n+                        scope = s;\n+                    }\n+\n+                    Scope::Binder { hir_id, from_poly_trait_ref, .. } => {\n+                        if !from_poly_trait_ref {\n+                            // We should only see super trait lifetimes if there is a `Binder` above\n+                            assert!(supertrait_lifetimes.is_empty());\n+                            break vec![];\n                         }\n-                        _ => None,\n-                    })\n-                    .collect(),\n+                        // Nested poly trait refs have the binders concatenated\n+                        let mut full_binders =\n+                            self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                        full_binders.extend(supertrait_lifetimes.into_iter());\n+                        break full_binders;\n+                    }\n+                }\n+            };\n+            let (lifetimes, local_binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) = trait_ref\n+                .bound_generic_params\n+                .iter()\n+                .filter_map(|param| match param.kind {\n+                    GenericParamKind::Lifetime { .. } => Some(param),\n+                    _ => None,\n+                })\n+                .enumerate()\n+                .map(|(late_bound_idx, param)| {\n+                    let pair = Region::late(\n+                        outer_binders.len() as u32 + late_bound_idx as u32,\n+                        &self.tcx.hir(),\n+                        param,\n+                    );\n+                    let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                    (pair, r)\n+                })\n+                .unzip();\n+\n+            outer_binders.extend(local_binders.into_iter());\n+\n+            (outer_binders, lifetimes)\n+        };\n+\n+        debug!(?binders);\n+        self.map.late_bound_vars.insert(trait_ref.trait_ref.hir_ref_id, binders);\n+\n+        if trait_ref_hack.is_none() || has_lifetimes {\n+            let scope = Scope::Binder {\n+                hir_id: trait_ref.trait_ref.hir_ref_id,\n+                lifetimes,\n                 s: self.scope,\n                 next_early_index,\n                 track_lifetime_uses: true,\n                 opaque_type_parent: false,\n+                from_poly_trait_ref: true,\n             };\n             self.with(scope, |old_scope, this| {\n                 this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n                 walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n                 this.visit_trait_ref(&trait_ref.trait_ref);\n             });\n         } else {\n-            self.visit_trait_ref(&trait_ref.trait_ref);\n+            let scope =\n+                Scope::TraitRefHackInner { hir_id: trait_ref.trait_ref.hir_ref_id, s: self.scope };\n+            self.with(scope, |_old_scope, this| {\n+                this.visit_trait_ref(&trait_ref.trait_ref);\n+            });\n         }\n         self.trait_ref_hack = trait_ref_hack;\n         if should_pop_missing_lt {\n@@ -1354,7 +1651,9 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n             match *scope {\n                 Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. } => {\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => {\n                     scope = s;\n                 }\n \n@@ -1543,11 +1842,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let labels_in_fn = take(&mut self.labels_in_fn);\n         let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let missing_named_lifetime_spots = take(&mut self.missing_named_lifetime_spots);\n+        let trait_ref_hack = take(&mut self.trait_ref_hack);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map,\n             scope: &wrap_scope,\n-            trait_ref_hack: self.trait_ref_hack,\n+            trait_ref_hack,\n             is_in_fn_syntax: self.is_in_fn_syntax,\n             is_in_const_generic: self.is_in_const_generic,\n             trait_definition_only: self.trait_definition_only,\n@@ -1567,6 +1867,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.labels_in_fn = this.labels_in_fn;\n         self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n         self.missing_named_lifetime_spots = this.missing_named_lifetime_spots;\n+        self.trait_ref_hack = this.trait_ref_hack;\n     }\n \n     /// helper method to determine the span to remove when suggesting the\n@@ -1715,7 +2016,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .values()\n             .flat_map(|region| match region {\n                 Region::EarlyBound(_, def_id, _)\n-                | Region::LateBound(_, def_id, _)\n+                | Region::LateBound(_, _, def_id, _)\n                 | Region::Free(_, def_id) => Some(*def_id),\n \n                 Region::LateBoundAnon(..) | Region::Static => None,\n@@ -1861,6 +2162,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn visit_early_late<F>(\n         &mut self,\n         parent_id: Option<hir::HirId>,\n+        hir_id: hir::HirId,\n         decl: &'tcx hir::FnDecl<'tcx>,\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n@@ -1870,31 +2172,34 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         insert_late_bound_lifetimes(self.map, decl, generics);\n \n         // Find the start of nested early scopes, e.g., in methods.\n-        let mut index = 0;\n+        let mut next_early_index = 0;\n         if let Some(parent_id) = parent_id {\n             let parent = self.tcx.hir().expect_item(parent_id);\n             if sub_items_have_self_param(&parent.kind) {\n-                index += 1; // Self comes before lifetimes\n+                next_early_index += 1; // Self comes before lifetimes\n             }\n             match parent.kind {\n                 hir::ItemKind::Trait(_, _, ref generics, ..)\n                 | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n-                    index += generics.params.len() as u32;\n+                    next_early_index += generics.params.len() as u32;\n                 }\n                 _ => {}\n             }\n         }\n \n         let mut non_lifetime_count = 0;\n-        let lifetimes = generics\n+        let mut named_late_bound_vars = 0;\n+        let lifetimes: FxHashMap<hir::ParamName, Region> = generics\n             .params\n             .iter()\n             .filter_map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n                     if self.map.late_bound.contains(&param.hir_id) {\n-                        Some(Region::late(&self.tcx.hir(), param))\n+                        let late_bound_idx = named_late_bound_vars;\n+                        named_late_bound_vars += 1;\n+                        Some(Region::late(late_bound_idx, &self.tcx.hir(), param))\n                     } else {\n-                        Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                        Some(Region::early(&self.tcx.hir(), &mut next_early_index, param))\n                     }\n                 }\n                 GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n@@ -1903,14 +2208,35 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             })\n             .collect();\n-        let next_early_index = index + non_lifetime_count;\n+        let next_early_index = next_early_index + non_lifetime_count;\n \n+        let binders: Vec<_> = generics\n+            .params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. }\n+                    if self.map.late_bound.contains(&param.hir_id) =>\n+                {\n+                    Some(param)\n+                }\n+                _ => None,\n+            })\n+            .enumerate()\n+            .map(|(late_bound_idx, param)| {\n+                let pair = Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n+                let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                r\n+            })\n+            .collect();\n+        self.map.late_bound_vars.insert(hir_id, binders);\n         let scope = Scope::Binder {\n+            hir_id,\n             lifetimes,\n             next_early_index,\n             s: self.scope,\n             opaque_type_parent: true,\n             track_lifetime_uses: false,\n+            from_poly_trait_ref: false,\n         };\n         self.with(scope, move |old_scope, this| {\n             this.check_lifetime_params(old_scope, &generics.params);\n@@ -1933,7 +2259,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder { s, .. }\n                 | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => scope = s,\n             }\n         }\n     }\n@@ -1965,6 +2293,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // given name or we run out of scopes.\n         // search.\n         let mut late_depth = 0;\n+        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let mut outermost_body = None;\n         let result = loop {\n@@ -1982,7 +2311,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, s, .. } => {\n+                Scope::Binder { ref lifetimes, from_poly_trait_ref, s, .. } => {\n                     match lifetime_ref.name {\n                         LifetimeName::Param(param_name) => {\n                             if let Some(&def) = lifetimes.get(&param_name.normalize_to_macros_2_0())\n@@ -1993,11 +2322,35 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         _ => bug!(\"expected LifetimeName::Param\"),\n                     }\n \n-                    late_depth += 1;\n+                    match (from_poly_trait_ref, in_poly_trait_ref) {\n+                        // This is the first binder we see that is a poly trait ref; add one to the\n+                        // late depth and mark that we're potentially in nested trait refs.\n+                        (true, false) => {\n+                            in_poly_trait_ref = true;\n+                            late_depth += 1;\n+                        }\n+                        // We've already seen a binder that is a poly trait ref and this one is too,\n+                        // that means that they are nested and we are concatenating the bound vars;\n+                        // don't increase the late depth.\n+                        (true, true) => {}\n+                        // We've exited nested poly trait refs; add one to the late depth and mark\n+                        // that we are no longer in nested trait refs\n+                        (false, true) => {\n+                            in_poly_trait_ref = false;\n+                            late_depth += 1;\n+                        }\n+                        // Any other kind of nested binders: just increase late depth.\n+                        (false, false) => {\n+                            late_depth += 1;\n+                        }\n+                    }\n                     scope = s;\n                 }\n \n-                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -2025,7 +2378,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             if !self.trait_definition_only && self.is_in_fn_syntax {\n                 match def {\n                     Region::EarlyBound(_, _, LifetimeDefOrigin::InBand)\n-                    | Region::LateBound(_, _, LifetimeDefOrigin::InBand) => {\n+                    | Region::LateBound(_, _, _, LifetimeDefOrigin::InBand) => {\n                         struct_span_err!(\n                             self.tcx.sess,\n                             lifetime_ref.span,\n@@ -2044,6 +2397,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         LifetimeDefOrigin::ExplicitOrElided | LifetimeDefOrigin::Error,\n                     )\n                     | Region::LateBound(\n+                        _,\n                         _,\n                         _,\n                         LifetimeDefOrigin::ExplicitOrElided | LifetimeDefOrigin::Error,\n@@ -2079,7 +2433,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n \n         let mut elide_lifetimes = true;\n-        let lifetimes = generic_args\n+        let lifetimes: Vec<_> = generic_args\n             .args\n             .iter()\n             .filter_map(|arg| match arg {\n@@ -2092,8 +2446,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 _ => None,\n             })\n             .collect();\n+        // We short-circuit here if all are elided in order to pluralize\n+        // possible errors\n         if elide_lifetimes {\n-            self.resolve_elided_lifetimes(lifetimes);\n+            self.resolve_elided_lifetimes(&lifetimes);\n         } else {\n             lifetimes.iter().for_each(|lt| self.visit_lifetime(lt));\n         }\n@@ -2146,7 +2502,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                         Scope::Binder { s, .. }\n                         | Scope::Elision { s, .. }\n-                        | Scope::ObjectLifetimeDefault { s, .. } => {\n+                        | Scope::ObjectLifetimeDefault { s, .. }\n+                        | Scope::TraitRefHackInner { s, .. }\n+                        | Scope::Supertrait { s, .. } => {\n                             scope = s;\n                         }\n                     }\n@@ -2245,13 +2603,84 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let has_lifetime_parameter =\n             generic_args.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)));\n \n-        // Resolve lifetimes found in the type `XX` from `Item = XX` bindings.\n-        for b in generic_args.bindings {\n+        // Resolve lifetimes found in the bindings, so either in the type `XX` in `Item = XX` or\n+        // in the trait ref `YY<...>` in `Item: YY<...>`.\n+        for binding in generic_args.bindings {\n             let scope = Scope::ObjectLifetimeDefault {\n                 lifetime: if has_lifetime_parameter { None } else { Some(Region::Static) },\n                 s: self.scope,\n             };\n-            self.with(scope, |_, this| this.visit_assoc_type_binding(b));\n+            if let Some(type_def_id) = type_def_id {\n+                let lifetimes = LifetimeContext::supertrait_hrtb_lifetimes(\n+                    self.tcx,\n+                    type_def_id,\n+                    binding.ident,\n+                );\n+                self.with(scope, |_, this| {\n+                    let scope =\n+                        Scope::Supertrait { lifetimes: lifetimes.unwrap_or(vec![]), s: this.scope };\n+                    this.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n+                });\n+            } else {\n+                self.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n+            }\n+        }\n+    }\n+\n+    /// Returns all the late-bound vars that come into scope from supertrait HRTBs, based on the\n+    /// associated type name and starting trait.\n+    /// For example, imagine we have\n+    /// ```rust\n+    /// trait Foo<'a, 'b> {\n+    ///   type As;\n+    /// }\n+    /// trait Bar<'b>: for<'a> Foo<'a, 'b> {}\n+    /// trait Bar: for<'b> Bar<'b> {}\n+    /// ```\n+    /// In this case, if we wanted to the supertrait HRTB lifetimes for `As` on\n+    /// the starting trait `Bar`, we would return `Some(['b, 'a])`.\n+    fn supertrait_hrtb_lifetimes(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        assoc_name: Ident,\n+    ) -> Option<Vec<ty::BoundVariableKind>> {\n+        let trait_defines_associated_type_named = |trait_def_id: DefId| {\n+            tcx.associated_items(trait_def_id)\n+                .find_by_name_and_kind(tcx, assoc_name, ty::AssocKind::Type, trait_def_id)\n+                .is_some()\n+        };\n+\n+        use smallvec::{smallvec, SmallVec};\n+        let mut stack: SmallVec<[(DefId, SmallVec<[ty::BoundVariableKind; 8]>); 8]> =\n+            smallvec![(def_id, smallvec![])];\n+        let mut visited: FxHashSet<DefId> = FxHashSet::default();\n+        loop {\n+            let (def_id, bound_vars) = match stack.pop() {\n+                Some(next) => next,\n+                None => break None,\n+            };\n+            if trait_defines_associated_type_named(def_id) {\n+                break Some(bound_vars.into_iter().collect());\n+            }\n+            let predicates =\n+                tcx.super_predicates_that_define_assoc_type((def_id, Some(assoc_name)));\n+            let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n+                let bound_predicate = pred.kind();\n+                match bound_predicate.skip_binder() {\n+                    ty::PredicateKind::Trait(data, _) => {\n+                        // The order here needs to match what we would get from `subst_supertrait`\n+                        let pred_bound_vars = bound_predicate.bound_vars();\n+                        let mut all_bound_vars = bound_vars.clone();\n+                        all_bound_vars.extend(pred_bound_vars.iter());\n+                        let super_def_id = data.trait_ref.def_id;\n+                        Some((super_def_id, all_bound_vars))\n+                    }\n+                    _ => None,\n+                }\n+            });\n+\n+            let obligations = obligations.filter(|o| visited.insert(o.0));\n+            stack.extend(obligations);\n         }\n     }\n \n@@ -2261,7 +2690,37 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         inputs: &'tcx [hir::Ty<'tcx>],\n         output: Option<&'tcx hir::Ty<'tcx>>,\n     ) {\n-        let arg_scope = Scope::Elision { elide: Elide::FreshLateAnon(Cell::new(0)), s: self.scope };\n+        debug!(\"visit_fn_like_elision: enter\");\n+        let mut scope = &*self.scope;\n+        let hir_id = loop {\n+            match scope {\n+                Scope::Binder { hir_id, .. } | Scope::TraitRefHackInner { hir_id, .. } => {\n+                    break *hir_id;\n+                }\n+                Scope::Body { id, .. } => break id.hir_id,\n+                Scope::ObjectLifetimeDefault { ref s, .. }\n+                | Scope::Elision { ref s, .. }\n+                | Scope::Supertrait { ref s, .. } => {\n+                    scope = *s;\n+                }\n+                Scope::Root => bug!(\"In fn_like_elision without appropriate scope above\"),\n+            }\n+        };\n+        // While not strictly necessary, we gather anon lifetimes *before* actually\n+        // visiting the argument types.\n+        let mut gather = GatherAnonLifetimes { anon_count: 0 };\n+        for input in inputs {\n+            gather.visit_ty(input);\n+        }\n+        let late_bound_vars = self.map.late_bound_vars.entry(hir_id).or_default();\n+        let named_late_bound_vars = late_bound_vars.len() as u32;\n+        late_bound_vars.extend(\n+            (0..gather.anon_count).map(|var| ty::BoundVariableKind::Region(ty::BrAnon(var))),\n+        );\n+        let arg_scope = Scope::Elision {\n+            elide: Elide::FreshLateAnon(named_late_bound_vars, Cell::new(0)),\n+            s: self.scope,\n+        };\n         self.with(arg_scope, |_, this| {\n             for input in inputs {\n                 this.visit_ty(input);\n@@ -2516,7 +2975,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n                 if let Some(&lifetime) = self.map.defs.get(&lifetime_ref.hir_id) {\n                     match lifetime {\n-                        Region::LateBound(debruijn, _, _) | Region::LateBoundAnon(debruijn, _)\n+                        Region::LateBound(debruijn, _, _, _)\n+                        | Region::LateBoundAnon(debruijn, _, _)\n                             if debruijn < self.outer_index =>\n                         {\n                             self.have_bound_regions = true;\n@@ -2528,9 +2988,46 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n         }\n+\n+        struct GatherAnonLifetimes {\n+            anon_count: u32,\n+        }\n+        impl<'v> Visitor<'v> for GatherAnonLifetimes {\n+            type Map = intravisit::ErasedMap<'v>;\n+\n+            fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+                NestedVisitorMap::None\n+            }\n+\n+            fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+                // If we enter a `BareFn`, then we enter a *new* binding scope\n+                if let hir::TyKind::BareFn(_) = ty.kind {\n+                    return;\n+                }\n+                intravisit::walk_ty(self, ty);\n+            }\n+\n+            fn visit_generic_args(\n+                &mut self,\n+                path_span: Span,\n+                generic_args: &'v hir::GenericArgs<'v>,\n+            ) {\n+                // parenthesized args enter a new elison scope\n+                if generic_args.parenthesized {\n+                    return;\n+                }\n+                intravisit::walk_generic_args(self, path_span, generic_args)\n+            }\n+\n+            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n+                if lifetime_ref.is_elided() {\n+                    self.anon_count += 1;\n+                }\n+            }\n+        }\n     }\n \n-    fn resolve_elided_lifetimes(&mut self, lifetime_refs: Vec<&'tcx hir::Lifetime>) {\n+    fn resolve_elided_lifetimes(&mut self, lifetime_refs: &[&'tcx hir::Lifetime]) {\n         debug!(\"resolve_elided_lifetimes(lifetime_refs={:?})\", lifetime_refs);\n \n         if lifetime_refs.is_empty() {\n@@ -2539,6 +3036,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let span = lifetime_refs[0].span;\n         let mut late_depth = 0;\n+        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n         let mut lifetime_spans = vec![];\n@@ -2549,23 +3047,39 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Root => break None,\n \n-                Scope::Binder { s, ref lifetimes, .. } => {\n+                Scope::Binder { s, ref lifetimes, from_poly_trait_ref, .. } => {\n                     // collect named lifetimes for suggestions\n                     for name in lifetimes.keys() {\n                         if let hir::ParamName::Plain(name) = name {\n                             lifetime_names.insert(name.name);\n                             lifetime_spans.push(name.span);\n                         }\n                     }\n-                    late_depth += 1;\n+                    // See comments in `resolve_lifetime_ref`\n+                    match (from_poly_trait_ref, in_poly_trait_ref) {\n+                        (true, false) => {\n+                            in_poly_trait_ref = true;\n+                            late_depth += 1;\n+                        }\n+                        (true, true) => {}\n+                        (false, true) => {\n+                            in_poly_trait_ref = false;\n+                            late_depth += 1;\n+                        }\n+                        (false, false) => {\n+                            late_depth += 1;\n+                        }\n+                    }\n                     scope = s;\n                 }\n \n                 Scope::Elision { ref elide, ref s, .. } => {\n                     let lifetime = match *elide {\n-                        Elide::FreshLateAnon(ref counter) => {\n+                        Elide::FreshLateAnon(named_late_bound_vars, ref counter) => {\n                             for lifetime_ref in lifetime_refs {\n-                                let lifetime = Region::late_anon(counter).shifted(late_depth);\n+                                let lifetime = Region::late_anon(named_late_bound_vars, counter)\n+                                    .shifted(late_depth);\n+\n                                 self.insert_lifetime(lifetime_ref, lifetime);\n                             }\n                             return;\n@@ -2602,7 +3116,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                Scope::ObjectLifetimeDefault { s, .. } => {\n+                Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -2708,11 +3224,25 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         debug!(\"resolve_object_lifetime_default(lifetime_ref={:?})\", lifetime_ref);\n         let mut late_depth = 0;\n+        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let lifetime = loop {\n             match *scope {\n-                Scope::Binder { s, .. } => {\n-                    late_depth += 1;\n+                Scope::Binder { s, from_poly_trait_ref, .. } => {\n+                    match (from_poly_trait_ref, in_poly_trait_ref) {\n+                        (true, false) => {\n+                            in_poly_trait_ref = true;\n+                            late_depth += 1;\n+                        }\n+                        (true, true) => {}\n+                        (false, true) => {\n+                            in_poly_trait_ref = false;\n+                            late_depth += 1;\n+                        }\n+                        (false, false) => {\n+                            late_depth += 1;\n+                        }\n+                    }\n                     scope = s;\n                 }\n \n@@ -2721,6 +3251,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n                 Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n+\n+                Scope::TraitRefHackInner { s, .. } | Scope::Supertrait { s, .. } => {\n+                    scope = s;\n+                }\n             }\n         };\n         self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n@@ -2844,7 +3378,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             match *old_scope {\n                 Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. } => {\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => {\n                     old_scope = s;\n                 }\n \n@@ -2890,7 +3426,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 // A lifetime only used in a fn argument could as well\n                 // be replaced with `'_`, as that would generate a\n                 // fresh name, too.\n-                Scope::Elision { elide: Elide::FreshLateAnon(_), .. } => break true,\n+                Scope::Elision { elide: Elide::FreshLateAnon(..), .. } => break true,\n \n                 // In the return type or other such place, `'_` is not\n                 // going to make a fresh name, so we cannot\n@@ -2900,7 +3436,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     elide: Elide::Exact(_) | Elide::Error(_) | Elide::Forbid, ..\n                 } => break false,\n \n-                Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n+                Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => scope = s,\n             }\n         }\n     }\n@@ -2919,7 +3457,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             Region::Free(_, def_id)\n-            | Region::LateBound(_, def_id, _)\n+            | Region::LateBound(_, _, def_id, _)\n             | Region::EarlyBound(_, def_id, _) => {\n                 // A lifetime declared by the user.\n                 let track_lifetime_uses = self.track_lifetime_uses();"}, {"sha": "7d186c330ba3f51ad6eab2970ec77afed2771c1c", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -230,7 +230,7 @@ impl Printer<'tcx> for SymbolPrinter<'tcx> {\n \n     fn print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         let mut first = true;\n         for p in predicates {"}, {"sha": "37a834043f624ba5b0474bc91ad2a62fac03e192", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -181,7 +181,7 @@ impl SymbolMangler<'tcx> {\n \n     fn in_binder<T>(\n         mut self,\n-        value: &ty::Binder<T>,\n+        value: &ty::Binder<'tcx, T>,\n         print_value: impl FnOnce(Self, &T) -> Result<Self, !>,\n     ) -> Result<Self, !>\n     where\n@@ -318,7 +318,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n             // Late-bound lifetimes use indices starting at 1,\n             // see `BinderLevel` for more details.\n-            ty::ReLateBound(debruijn, ty::BoundRegion { kind: ty::BrAnon(i) }) => {\n+            ty::ReLateBound(debruijn, ty::BoundRegion { kind: ty::BrAnon(i), .. }) => {\n                 let binder = &self.binders[self.binders.len() - 1 - debruijn.index()];\n                 let depth = binder.lifetime_depths.start + i;\n \n@@ -483,7 +483,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n     fn print_dyn_existential(\n         mut self,\n-        predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Result<Self::DynExistential, Self::Error> {\n         for predicate in predicates {\n             self = self.in_binder(&predicate, |mut cx, predicate| {"}, {"sha": "b6c3768d8876a3a4e1cbbfccdd97eeb66c180971", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -697,7 +697,7 @@ where\n {\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n-        t: &ty::Binder<T>,\n+        t: &ty::Binder<'tcx, T>,\n     ) -> ControlFlow<Self::BreakTy> {\n         t.as_ref().skip_binder().visit_with(self);\n         ControlFlow::CONTINUE"}, {"sha": "f54eb0914a5a7b1500bfcc228e190280b38f4786", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n \n         let trait_ref = ty::TraitRef { def_id: trait_did, substs: tcx.mk_substs_trait(ty, &[]) };\n \n-        let trait_pred = ty::Binder::bind(trait_ref);\n+        let trait_pred = ty::Binder::dummy(trait_ref);\n \n         let bail_out = tcx.infer_ctxt().enter(|infcx| {\n             let mut selcx = SelectionContext::with_negative(&infcx, true);\n@@ -280,7 +280,7 @@ impl AutoTraitFinder<'tcx> {\n \n         let mut already_visited = FxHashSet::default();\n         let mut predicates = VecDeque::new();\n-        predicates.push_back(ty::Binder::bind(ty::TraitPredicate {\n+        predicates.push_back(ty::Binder::dummy(ty::TraitPredicate {\n             trait_ref: ty::TraitRef {\n                 def_id: trait_did,\n                 substs: infcx.tcx.mk_substs_trait(ty, &[]),"}, {"sha": "326b85e1013d66c39fb2d2c5fb4105f519b80be6", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -65,15 +65,15 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     );\n \n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: &ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n         has_custom_message: bool,\n     ) -> bool;\n@@ -82,14 +82,14 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n     );\n \n     fn suggest_change_mut(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     );\n \n@@ -98,7 +98,7 @@ pub trait InferCtxtExt<'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n     );\n \n     fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span>;\n@@ -108,7 +108,7 @@ pub trait InferCtxtExt<'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n     ) -> bool;\n \n     fn point_at_returns_when_relevant(\n@@ -170,7 +170,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n         span: Span,\n     );\n }\n@@ -583,7 +583,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     ) {\n         let self_ty = match trait_ref.self_ty().no_bound_vars() {\n@@ -676,7 +676,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: &ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n         has_custom_message: bool,\n     ) -> bool {\n@@ -761,7 +761,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n     ) {\n         let span = obligation.cause.span;\n \n@@ -824,7 +824,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n         points_at_arg: bool,\n     ) {\n         let span = obligation.cause.span;\n@@ -896,10 +896,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n     ) {\n         let is_empty_tuple =\n-            |ty: ty::Binder<Ty<'_>>| *ty.skip_binder().kind() == ty::Tuple(ty::List::empty());\n+            |ty: ty::Binder<'tcx, Ty<'_>>| *ty.skip_binder().kind() == ty::Tuple(ty::List::empty());\n \n         let hir = self.tcx.hir();\n         let parent_node = hir.get_parent_node(obligation.cause.body_id);\n@@ -948,7 +948,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n     ) -> bool {\n         match obligation.cause.code.peel_derives() {\n             // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n@@ -2190,7 +2190,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<ty::TraitRef<'tcx>>,\n+        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n         span: Span,\n     ) {\n         debug!("}, {"sha": "fc9739f70d40d6aadf4a885f26cea7f688a92336", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -684,7 +684,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n /// Returns the set of inference variables contained in `substs`.\n fn substs_infer_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n-    substs: ty::Binder<SubstsRef<'tcx>>,\n+    substs: ty::Binder<'tcx, SubstsRef<'tcx>>,\n ) -> impl Iterator<Item = TyOrConstInferVar<'tcx>> {\n     selcx\n         .infcx()"}, {"sha": "b5a458db6075fd72b88230d9f34b650b8e982bb1", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -757,7 +757,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n     struct IllegalSelfTypeVisitor<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         trait_def_id: DefId,\n-        supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>>,\n+        supertraits: Option<Vec<DefId>>,\n     }\n \n     impl<'tcx> TypeVisitor<'tcx> for IllegalSelfTypeVisitor<'tcx> {\n@@ -778,8 +778,10 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                     // Compute supertraits of current trait lazily.\n                     if self.supertraits.is_none() {\n                         let trait_ref =\n-                            ty::Binder::bind(ty::TraitRef::identity(self.tcx, self.trait_def_id));\n-                        self.supertraits = Some(traits::supertraits(self.tcx, trait_ref).collect());\n+                            ty::Binder::dummy(ty::TraitRef::identity(self.tcx, self.trait_def_id));\n+                        self.supertraits = Some(\n+                            traits::supertraits(self.tcx, trait_ref).map(|t| t.def_id()).collect(),\n+                        );\n                     }\n \n                     // Determine whether the trait reference `Foo as\n@@ -790,9 +792,11 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                     // direct equality here because all of these types\n                     // are part of the formal parameter listing, and\n                     // hence there should be no inference variables.\n-                    let projection_trait_ref = ty::Binder::bind(data.trait_ref(self.tcx));\n-                    let is_supertrait_of_current_trait =\n-                        self.supertraits.as_ref().unwrap().contains(&projection_trait_ref);\n+                    let is_supertrait_of_current_trait = self\n+                        .supertraits\n+                        .as_ref()\n+                        .unwrap()\n+                        .contains(&data.trait_ref(self.tcx).def_id);\n \n                     if is_supertrait_of_current_trait {\n                         ControlFlow::CONTINUE // do not walk contained types, do not report error, do collect $200"}, {"sha": "b3e5df4da0a9fa8254dd5e38de95e66848ce09c5", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1275,6 +1275,9 @@ fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n     let tcx = selcx.tcx();\n \n     let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n+    // We get here from `poly_project_and_unify_type` which replaces bound vars\n+    // with placeholders\n+    debug_assert!(!self_ty.has_escaping_bound_vars());\n     let substs = tcx.mk_substs([self_ty.into()].iter());\n \n     let discriminant_def_id = tcx.require_lang_item(LangItem::Discriminant, None);\n@@ -1306,7 +1309,7 @@ fn confirm_pointee_candidate<'cx, 'tcx>(\n         ty: self_ty.ptr_metadata_ty(tcx),\n     };\n \n-    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate), false)\n+    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate, tcx), false)\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'tcx>("}, {"sha": "31685a012ca2f03dd290c9be9c93b1a6d524a9a4", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -272,7 +272,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         trait_def_id: DefId,\n-        nested: ty::Binder<Vec<Ty<'tcx>>>,\n+        nested: ty::Binder<'tcx, Vec<Ty<'tcx>>>,\n     ) -> ImplSourceAutoImplData<PredicateObligation<'tcx>> {\n         debug!(?nested, \"vtable_auto_impl\");\n         ensure_sufficient_stack(|| {\n@@ -748,7 +748,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     cause,\n                     obligation.recursion_depth + 1,\n                     obligation.param_env,\n-                    ty::Binder::bind(outlives).to_predicate(tcx),\n+                    obligation.predicate.rebind(outlives).to_predicate(tcx),\n                 ));\n             }\n "}, {"sha": "1c51597fff2a86f90a1207ed4646638f35a73673", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -204,7 +204,7 @@ struct EvaluatedCandidate<'tcx> {\n /// When does the builtin impl for `T: Trait` apply?\n enum BuiltinImplConditions<'tcx> {\n     /// The impl is conditional on `T1, T2, ...: Trait`.\n-    Where(ty::Binder<Vec<Ty<'tcx>>>),\n+    Where(ty::Binder<'tcx, Vec<Ty<'tcx>>>),\n     /// There is no built-in impl. There may be some other\n     /// candidate (a where-clause or user-defined impl).\n     None,\n@@ -1673,7 +1673,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Bar<i32> where struct Bar<T> { x: T, y: u32 } -> [i32, u32]\n     /// Zed<i32> where enum Zed { A(T), B(u32) } -> [i32, u32]\n     /// ```\n-    fn constituent_types_for_ty(&self, t: ty::Binder<Ty<'tcx>>) -> ty::Binder<Vec<Ty<'tcx>>> {\n+    fn constituent_types_for_ty(\n+        &self,\n+        t: ty::Binder<'tcx, Ty<'tcx>>,\n+    ) -> ty::Binder<'tcx, Vec<Ty<'tcx>>> {\n         match *t.skip_binder().kind() {\n             ty::Uint(_)\n             | ty::Int(_)\n@@ -1746,7 +1749,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         cause: ObligationCause<'tcx>,\n         recursion_depth: usize,\n         trait_def_id: DefId,\n-        types: ty::Binder<Vec<Ty<'tcx>>>,\n+        types: ty::Binder<'tcx, Vec<Ty<'tcx>>>,\n     ) -> Vec<PredicateObligation<'tcx>> {\n         // Because the types were potentially derived from\n         // higher-ranked obligations they may reference late-bound\n@@ -1767,7 +1770,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .skip_binder() // binder moved -\\\n             .iter()\n             .flat_map(|ty| {\n-                let ty: ty::Binder<Ty<'tcx>> = types.rebind(ty); // <----/\n+                let ty: ty::Binder<'tcx, Ty<'tcx>> = types.rebind(ty); // <----/\n \n                 self.infcx.commit_unconditionally(|_| {\n                     let placeholder_ty = self.infcx.replace_bound_vars_with_placeholders(ty);"}, {"sha": "fd94f9f799847496580e1d330d1349555a195308", "filename": "compiler/rustc_trait_selection/src/traits/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Futil.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -328,7 +328,7 @@ pub fn closure_trait_ref_and_return_type(\n     self_ty: Ty<'tcx>,\n     sig: ty::PolyFnSig<'tcx>,\n     tuple_arguments: TupleArgumentsFlag,\n-) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)> {\n+) -> ty::Binder<'tcx, (ty::TraitRef<'tcx>, Ty<'tcx>)> {\n     let arguments_tuple = match tuple_arguments {\n         TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n         TupleArgumentsFlag::Yes => tcx.intern_tup(sig.skip_binder().inputs()),\n@@ -346,7 +346,7 @@ pub fn generator_trait_ref_and_outputs(\n     fn_trait_def_id: DefId,\n     self_ty: Ty<'tcx>,\n     sig: ty::PolyGenSig<'tcx>,\n-) -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)> {\n+) -> ty::Binder<'tcx, (ty::TraitRef<'tcx>, Ty<'tcx>, Ty<'tcx>)> {\n     debug_assert!(!self_ty.has_escaping_bound_vars());\n     let trait_ref = ty::TraitRef {\n         def_id: fn_trait_def_id,"}, {"sha": "f592cf1cd249d0169a63c3fa8cebdc9c931811b1", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -704,7 +704,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n     fn from_object_ty(\n         &mut self,\n         ty: Ty<'tcx>,\n-        data: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        data: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n         region: ty::Region<'tcx>,\n     ) {\n         // Imagine a type like this:\n@@ -767,7 +767,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n /// `infer::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    existential_predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+    existential_predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n ) -> Vec<ty::Region<'tcx>> {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically"}, {"sha": "8c97e606c569ff0279fd7b5b3f85a2349e232f17", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -735,7 +735,10 @@ fn bound_vars_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n             .into(),\n \n         ty::GenericParamDefKind::Lifetime => {\n-            let br = ty::BoundRegion { kind: ty::BrAnon(substs.len() as u32) };\n+            let br = ty::BoundRegion {\n+                var: ty::BoundVar::from_usize(substs.len()),\n+                kind: ty::BrAnon(substs.len() as u32),\n+            };\n             tcx.mk_region(ty::RegionKind::ReLateBound(ty::INNERMOST, br)).into()\n         }\n "}, {"sha": "39890fd5b0574a2a0b98cb5f6393d5b3920c4e51", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -434,17 +434,11 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n             ReEarlyBound(_) => {\n                 panic!(\"Should have already been substituted.\");\n             }\n-            ReLateBound(db, br) => match br.kind {\n-                ty::BoundRegionKind::BrAnon(var) => {\n-                    chalk_ir::LifetimeData::BoundVar(chalk_ir::BoundVar::new(\n-                        chalk_ir::DebruijnIndex::new(db.as_u32()),\n-                        var as usize,\n-                    ))\n-                    .intern(interner)\n-                }\n-                ty::BoundRegionKind::BrNamed(_def_id, _name) => unimplemented!(),\n-                ty::BrEnv => unimplemented!(),\n-            },\n+            ReLateBound(db, br) => chalk_ir::LifetimeData::BoundVar(chalk_ir::BoundVar::new(\n+                chalk_ir::DebruijnIndex::new(db.as_u32()),\n+                br.var.as_usize(),\n+            ))\n+            .intern(interner),\n             ReFree(_) => unimplemented!(),\n             ReStatic => chalk_ir::LifetimeData::Static.intern(interner),\n             ReVar(_) => unimplemented!(),\n@@ -467,7 +461,10 @@ impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'t\n         let kind = match self.data(interner) {\n             chalk_ir::LifetimeData::BoundVar(var) => ty::RegionKind::ReLateBound(\n                 ty::DebruijnIndex::from_u32(var.debruijn.depth()),\n-                ty::BoundRegion { kind: ty::BrAnon(var.index as u32) },\n+                ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(var.index),\n+                    kind: ty::BrAnon(var.index as u32),\n+                },\n             ),\n             chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n             chalk_ir::LifetimeData::Placeholder(p) => {\n@@ -606,7 +603,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n }\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<RustInterner<'tcx>>>>\n-    for &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>\n+    for &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>\n {\n     fn lower_into(\n         self,\n@@ -677,7 +674,9 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n     }\n }\n \n-impl<'tcx> LowerInto<'tcx, chalk_ir::FnSig<RustInterner<'tcx>>> for ty::Binder<ty::FnSig<'tcx>> {\n+impl<'tcx> LowerInto<'tcx, chalk_ir::FnSig<RustInterner<'tcx>>>\n+    for ty::Binder<'tcx, ty::FnSig<'tcx>>\n+{\n     fn lower_into(self, _interner: &RustInterner<'_>) -> FnSig<RustInterner<'tcx>> {\n         chalk_ir::FnSig {\n             abi: self.abi(),\n@@ -801,7 +800,7 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>\n crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n     interner: &RustInterner<'tcx>,\n     tcx: TyCtxt<'tcx>,\n-    ty: Binder<T>,\n+    ty: Binder<'tcx, T>,\n ) -> (T, chalk_ir::VariableKinds<RustInterner<'tcx>>, BTreeMap<DefId, u32>) {\n     let mut bound_vars_collector = BoundVarsCollector::new();\n     ty.as_ref().skip_binder().visit_with(&mut bound_vars_collector);\n@@ -849,7 +848,10 @@ impl<'tcx> BoundVarsCollector<'tcx> {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &Binder<T>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n         self.binder_index.shift_in(1);\n         let result = t.super_visit_with(self);\n         self.binder_index.shift_out(1);\n@@ -895,7 +897,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n                     },\n                 },\n \n-                ty::BrEnv => unimplemented!(),\n+                ty::BoundRegionKind::BrEnv => unimplemented!(),\n             },\n \n             ty::ReEarlyBound(_re) => {\n@@ -931,7 +933,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<T>) -> Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T> {\n         self.binder_index.shift_in(1);\n         let result = t.super_fold_with(self);\n         self.binder_index.shift_out(1);\n@@ -943,7 +945,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n             ty::ReLateBound(index, br) if *index == self.binder_index => match br.kind {\n                 ty::BrNamed(def_id, _name) => match self.named_parameters.get(&def_id) {\n                     Some(idx) => {\n-                        let new_br = ty::BoundRegion { kind: ty::BrAnon(*idx) };\n+                        let new_br = ty::BoundRegion { var: br.var, kind: ty::BrAnon(*idx) };\n                         return self.tcx.mk_region(RegionKind::ReLateBound(*index, new_br));\n                     }\n                     None => panic!(\"Missing `BrNamed`.\"),\n@@ -987,7 +989,7 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n         self.tcx\n     }\n \n-    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<T>) -> Binder<T> {\n+    fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: Binder<'tcx, T>) -> Binder<'tcx, T> {\n         self.binder_index.shift_in(1);\n         let result = t.super_fold_with(self);\n         self.binder_index.shift_out(1);\n@@ -1026,12 +1028,16 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n             // This covers any region variables in a goal, right?\n             ty::ReEarlyBound(_re) => match self.named_regions.get(&_re.def_id) {\n                 Some(idx) => {\n-                    let br = ty::BoundRegion { kind: ty::BrAnon(*idx) };\n+                    let br = ty::BoundRegion {\n+                        var: ty::BoundVar::from_u32(*idx),\n+                        kind: ty::BrAnon(*idx),\n+                    };\n                     self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n                 }\n                 None => {\n                     let idx = self.named_regions.len() as u32;\n-                    let br = ty::BoundRegion { kind: ty::BrAnon(idx) };\n+                    let br =\n+                        ty::BoundRegion { var: ty::BoundVar::from_u32(idx), kind: ty::BrAnon(idx) };\n                     self.named_regions.insert(_re.def_id, idx);\n                     self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n                 }"}, {"sha": "874289d02938d038817129714215a78e8453b1ef", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -115,7 +115,7 @@ fn resolve_associated_item<'tcx>(\n     );\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.codegen_fulfill_obligation((param_env, ty::Binder::bind(trait_ref)))?;\n+    let vtbl = tcx.codegen_fulfill_obligation((param_env, ty::Binder::bind(trait_ref, tcx)))?;\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:"}, {"sha": "845375f3e322b71e3908157315e8e6a5417c21ac", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -166,7 +166,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n-        arg_count: GenericArgCountResult,\n+        arg_count: &GenericArgCountResult,\n         ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n     ) -> SubstsRef<'tcx> {\n         // Collect the segments of the path; we need to substitute arguments"}, {"sha": "b6de491911ab7c260c5d48bb40fd0dbd21e1c257", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 120, "deletions": 98, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -210,14 +210,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let r = match tcx.named_region(lifetime.hir_id) {\n             Some(rl::Region::Static) => tcx.lifetimes.re_static,\n \n-            Some(rl::Region::LateBound(debruijn, id, _)) => {\n-                let name = lifetime_name(id.expect_local());\n-                let br = ty::BoundRegion { kind: ty::BrNamed(id, name) };\n+            Some(rl::Region::LateBound(debruijn, index, def_id, _)) => {\n+                let name = lifetime_name(def_id.expect_local());\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_u32(index),\n+                    kind: ty::BrNamed(def_id, name),\n+                };\n                 tcx.mk_region(ty::ReLateBound(debruijn, br))\n             }\n \n-            Some(rl::Region::LateBoundAnon(debruijn, index)) => {\n-                let br = ty::BoundRegion { kind: ty::BrAnon(index) };\n+            Some(rl::Region::LateBoundAnon(debruijn, index, anon_index)) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_u32(index),\n+                    kind: ty::BrAnon(anon_index),\n+                };\n                 tcx.mk_region(ty::ReLateBound(debruijn, br))\n             }\n \n@@ -266,7 +272,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         def_id: DefId,\n         item_segment: &hir::PathSegment<'_>,\n     ) -> SubstsRef<'tcx> {\n-        let (substs, assoc_bindings, _) = self.create_substs_for_ast_path(\n+        let (substs, _) = self.create_substs_for_ast_path(\n             span,\n             def_id,\n             &[],\n@@ -275,6 +281,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.infer_args,\n             None,\n         );\n+        let assoc_bindings = self.create_assoc_bindings_for_generic_args(item_segment.args());\n \n         if let Some(b) = assoc_bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n@@ -314,6 +321,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// `[Vec<u8>, u8]` and `generic_args` are the arguments for the associated\n     /// type itself: `['a]`. The returned `SubstsRef` concatenates these two\n     /// lists: `[Vec<u8>, u8, 'a]`.\n+    #[tracing::instrument(level = \"debug\", skip(self, span))]\n     fn create_substs_for_ast_path<'a>(\n         &self,\n         span: Span,\n@@ -323,15 +331,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, GenericArgCountResult) {\n+    ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n-        debug!(\n-            \"create_substs_for_ast_path(def_id={:?}, self_ty={:?}, \\\n-                generic_args={:?})\",\n-            def_id, self_ty, generic_args\n-        );\n \n         let tcx = self.tcx();\n         let generics = tcx.generics_of(def_id);\n@@ -367,7 +370,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // here and so associated type bindings will be handled regardless of whether there are any\n         // non-`Self` generic parameters.\n         if generics.params.len() == 0 {\n-            return (tcx.intern_substs(&[]), vec![], arg_count);\n+            return (tcx.intern_substs(&[]), arg_count);\n         }\n \n         let is_object = self_ty.map_or(false, |ty| ty == self.tcx().types.trait_object_dummy_self);\n@@ -540,7 +543,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             parent_substs,\n             self_ty.is_some(),\n             self_ty,\n-            arg_count.clone(),\n+            &arg_count,\n             &mut substs_ctx,\n         );\n \n@@ -551,6 +554,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             generic_args.args.is_empty(),\n         );\n \n+        debug!(\n+            \"create_substs_for_ast_path(generic_params={:?}, self_ty={:?}) -> {:?}\",\n+            generics, self_ty, substs\n+        );\n+\n+        (substs, arg_count)\n+    }\n+\n+    fn create_assoc_bindings_for_generic_args<'a>(\n+        &self,\n+        generic_args: &'a hir::GenericArgs<'_>,\n+    ) -> Vec<ConvertedBinding<'a, 'tcx>> {\n         // Convert associated-type bindings or constraints into a separate vector.\n         // Example: Given this:\n         //\n@@ -581,12 +596,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             })\n             .collect();\n \n-        debug!(\n-            \"create_substs_for_ast_path(generic_params={:?}, self_ty={:?}) -> {:?}\",\n-            generics, self_ty, substs\n-        );\n-\n-        (substs, assoc_bindings, arg_count)\n+        assoc_bindings\n     }\n \n     crate fn create_substs_for_associated_item(\n@@ -636,8 +646,27 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         )\n     }\n \n-    /// The given trait-ref must actually be a trait.\n-    pub(super) fn instantiate_poly_trait_ref_inner(\n+    /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n+    /// a full trait reference. The resulting trait reference is returned. This may also generate\n+    /// auxiliary bounds, which are added to `bounds`.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```\n+    /// poly_trait_ref = Iterator<Item = u32>\n+    /// self_ty = Foo\n+    /// ```\n+    ///\n+    /// this would return `Foo: Iterator` and add `<Foo as Iterator>::Item = u32` into `bounds`.\n+    ///\n+    /// **A note on binders:** against our usual convention, there is an implied bounder around\n+    /// the `self_ty` and `poly_trait_ref` parameters here. So they may reference bound regions.\n+    /// If for example you had `for<'a> Foo<'a>: Bar<'a>`, then the `self_ty` would be `Foo<'a>`\n+    /// where `'a` is a bound region at depth 0. Similarly, the `poly_trait_ref` would be\n+    /// `Bar<'a>`. The returned poly-trait-ref will have this binder instantiated explicitly,\n+    /// however.\n+    #[tracing::instrument(level = \"debug\", skip(self, span, constness, bounds, speculative))]\n+    pub fn instantiate_poly_trait_ref(\n         &self,\n         trait_ref: &hir::TraitRef<'_>,\n         span: Span,\n@@ -648,18 +677,25 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) -> GenericArgCountResult {\n         let trait_def_id = trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise());\n \n-        debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n-\n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n-        let (substs, assoc_bindings, arg_count) = self.create_substs_for_ast_trait_ref(\n+        let tcx = self.tcx();\n+        let bound_vars = tcx.late_bound_vars(trait_ref.hir_ref_id);\n+        debug!(?bound_vars);\n+\n+        let (substs, arg_count) = self.create_substs_for_ast_trait_ref(\n             trait_ref.path.span,\n             trait_def_id,\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n         );\n-        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n+        let assoc_bindings = self\n+            .create_assoc_bindings_for_generic_args(trait_ref.path.segments.last().unwrap().args());\n \n+        let poly_trait_ref =\n+            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n+\n+        debug!(?poly_trait_ref, ?assoc_bindings);\n         bounds.trait_bounds.push((poly_trait_ref, span, constness));\n \n         let mut dup_bindings = FxHashMap::default();\n@@ -677,50 +713,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // Okay to ignore `Err` because of `ErrorReported` (see above).\n         }\n \n-        debug!(\n-            \"instantiate_poly_trait_ref({:?}, bounds={:?}) -> {:?}\",\n-            trait_ref, bounds, poly_trait_ref\n-        );\n-\n         arg_count\n     }\n \n-    /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n-    /// a full trait reference. The resulting trait reference is returned. This may also generate\n-    /// auxiliary bounds, which are added to `bounds`.\n-    ///\n-    /// Example:\n-    ///\n-    /// ```\n-    /// poly_trait_ref = Iterator<Item = u32>\n-    /// self_ty = Foo\n-    /// ```\n-    ///\n-    /// this would return `Foo: Iterator` and add `<Foo as Iterator>::Item = u32` into `bounds`.\n-    ///\n-    /// **A note on binders:** against our usual convention, there is an implied bounder around\n-    /// the `self_ty` and `poly_trait_ref` parameters here. So they may reference bound regions.\n-    /// If for example you had `for<'a> Foo<'a>: Bar<'a>`, then the `self_ty` would be `Foo<'a>`\n-    /// where `'a` is a bound region at depth 0. Similarly, the `poly_trait_ref` would be\n-    /// `Bar<'a>`. The returned poly-trait-ref will have this binder instantiated explicitly,\n-    /// however.\n-    pub fn instantiate_poly_trait_ref(\n-        &self,\n-        poly_trait_ref: &hir::PolyTraitRef<'_>,\n-        constness: Constness,\n-        self_ty: Ty<'tcx>,\n-        bounds: &mut Bounds<'tcx>,\n-    ) -> GenericArgCountResult {\n-        self.instantiate_poly_trait_ref_inner(\n-            &poly_trait_ref.trait_ref,\n-            poly_trait_ref.span,\n-            constness,\n-            self_ty,\n-            bounds,\n-            false,\n-        )\n-    }\n-\n     pub fn instantiate_lang_item_trait_ref(\n         &self,\n         lang_item: hir::LangItem,\n@@ -732,7 +727,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) {\n         let trait_def_id = self.tcx().require_lang_item(lang_item, Some(span));\n \n-        let (substs, assoc_bindings, _) = self.create_substs_for_ast_path(\n+        let (substs, _) = self.create_substs_for_ast_path(\n             span,\n             trait_def_id,\n             &[],\n@@ -741,7 +736,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             false,\n             Some(self_ty),\n         );\n-        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n+        let assoc_bindings = self.create_assoc_bindings_for_generic_args(args);\n+        let tcx = self.tcx();\n+        let bound_vars = tcx.late_bound_vars(hir_id);\n+        let poly_trait_ref =\n+            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n         bounds.trait_bounds.push((poly_trait_ref, span, Constness::NotConst));\n \n         let mut dup_bindings = FxHashMap::default();\n@@ -765,23 +764,23 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         trait_segment: &hir::PathSegment<'_>,\n     ) -> ty::TraitRef<'tcx> {\n-        let (substs, assoc_bindings, _) =\n+        let (substs, _) =\n             self.create_substs_for_ast_trait_ref(span, trait_def_id, self_ty, trait_segment);\n+        let assoc_bindings = self.create_assoc_bindings_for_generic_args(trait_segment.args());\n         if let Some(b) = assoc_bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self, span))]\n     fn create_substs_for_ast_trait_ref<'a>(\n         &self,\n         span: Span,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, GenericArgCountResult) {\n-        debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n-\n+    ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n \n         self.create_substs_for_ast_path(\n@@ -803,7 +802,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     // Returns `true` if a bounds list includes `?Sized`.\n-    pub fn is_unsized(&self, ast_bounds: &[&hir::GenericBound<'_>], span: Span) -> bool {\n+    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound<'_>], span: Span) -> bool {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n@@ -858,29 +857,46 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// **A note on binders:** there is an implied binder around\n     /// `param_ty` and `ast_bounds`. See `instantiate_poly_trait_ref`\n     /// for more details.\n+    #[tracing::instrument(level = \"debug\", skip(self, bounds))]\n     fn add_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[&hir::GenericBound<'_>],\n+        ast_bounds: &[hir::GenericBound<'_>],\n         bounds: &mut Bounds<'tcx>,\n+        bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n     ) {\n         let constness = self.default_constness_for_trait_bounds();\n         for ast_bound in ast_bounds {\n             match *ast_bound {\n                 hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) => {\n-                    self.instantiate_poly_trait_ref(b, constness, param_ty, bounds);\n+                    self.instantiate_poly_trait_ref(\n+                        &b.trait_ref,\n+                        b.span,\n+                        constness,\n+                        param_ty,\n+                        bounds,\n+                        false,\n+                    );\n                 }\n                 hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::MaybeConst) => {\n-                    self.instantiate_poly_trait_ref(b, Constness::NotConst, param_ty, bounds);\n+                    self.instantiate_poly_trait_ref(\n+                        &b.trait_ref,\n+                        b.span,\n+                        Constness::NotConst,\n+                        param_ty,\n+                        bounds,\n+                        false,\n+                    );\n                 }\n                 hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n                 hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => self\n                     .instantiate_lang_item_trait_ref(\n-                        *lang_item, *span, *hir_id, args, param_ty, bounds,\n+                        lang_item, span, hir_id, args, param_ty, bounds,\n                     ),\n-                hir::GenericBound::Outlives(ref l) => bounds\n-                    .region_bounds\n-                    .push((ty::Binder::bind(self.ast_region_to_region(l, None)), l.span)),\n+                hir::GenericBound::Outlives(ref l) => bounds.region_bounds.push((\n+                    ty::Binder::bind_with_vars(self.ast_region_to_region(l, None), bound_vars),\n+                    l.span,\n+                )),\n             }\n         }\n     }\n@@ -908,7 +924,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         sized_by_default: SizedByDefault,\n         span: Span,\n     ) -> Bounds<'tcx> {\n-        let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n         self.compute_bounds_inner(param_ty, &ast_bounds, sized_by_default, span)\n     }\n \n@@ -928,7 +943,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             if let Some(trait_ref) = ast_bound.trait_ref() {\n                 if let Some(trait_did) = trait_ref.trait_def_id() {\n                     if self.tcx().trait_may_define_assoc_type(trait_did, assoc_name) {\n-                        result.push(ast_bound);\n+                        result.push(ast_bound.clone());\n                     }\n                 }\n             }\n@@ -940,13 +955,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn compute_bounds_inner(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[&hir::GenericBound<'_>],\n+        ast_bounds: &[hir::GenericBound<'_>],\n         sized_by_default: SizedByDefault,\n         span: Span,\n     ) -> Bounds<'tcx> {\n         let mut bounds = Bounds::default();\n \n-        self.add_bounds(param_ty, ast_bounds, &mut bounds);\n+        self.add_bounds(param_ty, ast_bounds, &mut bounds, ty::List::empty());\n \n         bounds.implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n             if !self.is_unsized(ast_bounds, span) { Some(span) } else { None }\n@@ -963,6 +978,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// **A note on binders:** given something like `T: for<'a> Iterator<Item = &'a u32>`, the\n     /// `trait_ref` here will be `for<'a> T: Iterator`. The `binding` data however is from *inside*\n     /// the binder (e.g., `&'a u32`) and hence may reference bound regions.\n+    #[tracing::instrument(\n+        level = \"debug\",\n+        skip(self, bounds, speculative, dup_bindings, path_span)\n+    )]\n     fn add_predicates_for_ast_type_binding(\n         &self,\n         hir_ref_id: hir::HirId,\n@@ -989,7 +1008,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         //\n         // We want to produce `<B as SuperTrait<i32>>::T == foo`.\n \n-        debug!(?hir_ref_id, ?trait_ref, ?binding, ?bounds, \"add_predicates_for_ast_type_binding\",);\n         let tcx = self.tcx();\n \n         let candidate =\n@@ -1090,7 +1108,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 let late_bound_in_trait_ref =\n                     tcx.collect_constrained_late_bound_regions(&projection_ty);\n                 let late_bound_in_ty =\n-                    tcx.collect_referenced_late_bound_regions(&ty::Binder::bind(ty));\n+                    tcx.collect_referenced_late_bound_regions(&trait_ref.rebind(ty));\n                 debug!(\"late_bound_in_trait_ref = {:?}\", late_bound_in_trait_ref);\n                 debug!(\"late_bound_in_ty = {:?}\", late_bound_in_ty);\n \n@@ -1139,10 +1157,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 //\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n-                let param_ty =\n-                    tcx.mk_projection(assoc_ty.def_id, projection_ty.skip_binder().substs);\n-                let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n-                self.add_bounds(param_ty, &ast_bounds, bounds);\n+                let param_ty = tcx.mk_ty(ty::Projection(projection_ty.skip_binder()));\n+                self.add_bounds(param_ty, ast_bounds, bounds, candidate.bound_vars());\n             }\n         }\n         Ok(())\n@@ -1176,10 +1192,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     Err(GenericArgCountMismatch { invalid_args: cur_potential_assoc_types, .. }),\n                 ..\n             } = self.instantiate_poly_trait_ref(\n-                trait_bound,\n+                &trait_bound.trait_ref,\n+                trait_bound.span,\n                 Constness::NotConst,\n                 dummy_self,\n                 &mut bounds,\n+                false,\n             ) {\n                 potential_assoc_types.extend(cur_potential_assoc_types);\n             }\n@@ -1664,7 +1682,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 };\n \n                 self.one_bound_for_assoc_type(\n-                    || traits::supertraits(tcx, ty::Binder::bind(trait_ref)),\n+                    || traits::supertraits(tcx, ty::Binder::bind(trait_ref, tcx)),\n                     || \"Self\".to_string(),\n                     assoc_ident,\n                     span,\n@@ -2199,6 +2217,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 require_c_abi_if_c_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n \n                 tcx.mk_fn_ptr(self.ty_of_fn(\n+                    ast_ty.hir_id,\n                     bf.unsafety,\n                     bf.abi,\n                     &bf.decl,\n@@ -2241,7 +2260,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::Path(hir::QPath::LangItem(lang_item, span)) => {\n                 let def_id = tcx.require_lang_item(lang_item, Some(span));\n-                let (substs, _, _) = self.create_substs_for_ast_path(\n+                let (substs, _) = self.create_substs_for_ast_path(\n                     span,\n                     def_id,\n                     &[],\n@@ -2278,7 +2297,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         result_ty\n     }\n \n-    pub fn impl_trait_ty_to_ty(\n+    fn impl_trait_ty_to_ty(\n         &self,\n         def_id: DefId,\n         lifetimes: &[hir::GenericArg<'_>],\n@@ -2339,6 +2358,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     pub fn ty_of_fn(\n         &self,\n+        hir_id: hir::HirId,\n         unsafety: hir::Unsafety,\n         abi: abi::Abi,\n         decl: &hir::FnDecl<'_>,\n@@ -2349,6 +2369,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         debug!(\"ty_of_fn\");\n \n         let tcx = self.tcx();\n+        let bound_vars = tcx.late_bound_vars(hir_id);\n+        debug!(?bound_vars);\n \n         // We proactively collect all the inferred type params to emit a single error per fn def.\n         let mut visitor = PlaceholderHirTyCollector::default();\n@@ -2368,8 +2390,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n-        let bare_fn_ty =\n-            ty::Binder::bind(tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi));\n+        let fn_ty = tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi);\n+        let bare_fn_ty = ty::Binder::bind_with_vars(fn_ty, bound_vars);\n \n         if !self.allow_ty_infer() {\n             // We always collect the spans for placeholder types when evaluating `fn`s, but we\n@@ -2450,7 +2472,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn compute_object_lifetime_bound(\n         &self,\n         span: Span,\n-        existential_predicates: &'tcx ty::List<ty::Binder<ty::ExistentialPredicate<'tcx>>>,\n+        existential_predicates: &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n     ) -> Option<ty::Region<'tcx>> // if None, use the default\n     {\n         let tcx = self.tcx();"}, {"sha": "5d2006407226304530509df458aa6819b374beb8", "filename": "compiler/rustc_typeck/src/bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fbounds.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -26,7 +26,7 @@ pub struct Bounds<'tcx> {\n     /// A list of region bounds on the (implicit) self type. So if you\n     /// had `T: 'a + 'b` this might would be a list `['a, 'b]` (but\n     /// the `T` is not explicitly included).\n-    pub region_bounds: Vec<(ty::Binder<ty::Region<'tcx>>, Span)>,\n+    pub region_bounds: Vec<(ty::Binder<'tcx, ty::Region<'tcx>>, Span)>,\n \n     /// A list of trait bounds. So if you had `T: Debug` this would be\n     /// `T: Debug`. Note that the self-type is explicit here.\n@@ -57,7 +57,7 @@ impl<'tcx> Bounds<'tcx> {\n         // If it could be sized, and is, add the `Sized` predicate.\n         let sized_predicate = self.implicitly_sized.and_then(|span| {\n             tcx.lang_items().sized_trait().map(|sized| {\n-                let trait_ref = ty::Binder::bind(ty::TraitRef {\n+                let trait_ref = ty::Binder::dummy(ty::TraitRef {\n                     def_id: sized,\n                     substs: tcx.mk_substs_trait(param_ty, &[]),\n                 });"}, {"sha": "22d3dc6bdc0c0b7f31b0da7f6d2116658117d379", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 31, "deletions": 15, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expr_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n \n         let ClosureSignatures { bound_sig, liberated_sig } =\n-            self.sig_of_closure(expr_def_id.to_def_id(), decl, body, expected_sig);\n+            self.sig_of_closure(expr.hir_id, expr_def_id.to_def_id(), decl, body, expected_sig);\n \n         debug!(\"check_closure: ty_of_closure returns {:?}\", liberated_sig);\n \n@@ -288,29 +288,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn sig_of_closure(\n         &self,\n+        hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> ClosureSignatures<'tcx> {\n         if let Some(e) = expected_sig {\n-            self.sig_of_closure_with_expectation(expr_def_id, decl, body, e)\n+            self.sig_of_closure_with_expectation(hir_id, expr_def_id, decl, body, e)\n         } else {\n-            self.sig_of_closure_no_expectation(expr_def_id, decl, body)\n+            self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body)\n         }\n     }\n \n     /// If there is no expected signature, then we will convert the\n     /// types that the user gave into a signature.\n     fn sig_of_closure_no_expectation(\n         &self,\n+        hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n     ) -> ClosureSignatures<'tcx> {\n         debug!(\"sig_of_closure_no_expectation()\");\n \n-        let bound_sig = self.supplied_sig_of_closure(expr_def_id, decl, body);\n+        let bound_sig = self.supplied_sig_of_closure(hir_id, expr_def_id, decl, body);\n \n         self.closure_sigs(expr_def_id, body, bound_sig)\n     }\n@@ -364,6 +366,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///   regions with depth 1, which are bound then by the closure.\n     fn sig_of_closure_with_expectation(\n         &self,\n+        hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n@@ -375,7 +378,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // expectation if things don't see to match up with what we\n         // expect.\n         if expected_sig.sig.c_variadic() != decl.c_variadic {\n-            return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n+            return self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body);\n         } else if expected_sig.sig.skip_binder().inputs_and_output.len() != decl.inputs.len() + 1 {\n             return self.sig_of_closure_with_mismatched_number_of_arguments(\n                 expr_def_id,\n@@ -411,9 +414,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Along the way, it also writes out entries for types that the user\n         // wrote into our typeck results, which are then later used by the privacy\n         // check.\n-        match self.check_supplied_sig_against_expectation(expr_def_id, decl, body, &closure_sigs) {\n+        match self.check_supplied_sig_against_expectation(\n+            hir_id,\n+            expr_def_id,\n+            decl,\n+            body,\n+            &closure_sigs,\n+        ) {\n             Ok(infer_ok) => self.register_infer_ok_obligations(infer_ok),\n-            Err(_) => return self.sig_of_closure_no_expectation(expr_def_id, decl, body),\n+            Err(_) => return self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body),\n         }\n \n         closure_sigs\n@@ -460,6 +469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// strategy.\n     fn check_supplied_sig_against_expectation(\n         &self,\n+        hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n@@ -469,7 +479,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // (See comment on `sig_of_closure_with_expectation` for the\n         // meaning of these letters.)\n-        let supplied_sig = self.supplied_sig_of_closure(expr_def_id, decl, body);\n+        let supplied_sig = self.supplied_sig_of_closure(hir_id, expr_def_id, decl, body);\n \n         debug!(\"check_supplied_sig_against_expectation: supplied_sig={:?}\", supplied_sig);\n \n@@ -534,6 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Also, record this closure signature for later.\n     fn supplied_sig_of_closure(\n         &self,\n+        hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n@@ -545,6 +556,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             decl, body.generator_kind,\n         );\n \n+        let bound_vars = self.tcx.late_bound_vars(hir_id);\n+\n         // First, convert the types that the user supplied (if any).\n         let supplied_arguments = decl.inputs.iter().map(|a| astconv.ast_ty_to_ty(a));\n         let supplied_return = match decl.output {\n@@ -571,13 +584,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         };\n \n-        let result = ty::Binder::bind(self.tcx.mk_fn_sig(\n-            supplied_arguments,\n-            supplied_return,\n-            decl.c_variadic,\n-            hir::Unsafety::Normal,\n-            Abi::RustCall,\n-        ));\n+        let result = ty::Binder::bind_with_vars(\n+            self.tcx.mk_fn_sig(\n+                supplied_arguments,\n+                supplied_return,\n+                decl.c_variadic,\n+                hir::Unsafety::Normal,\n+                Abi::RustCall,\n+            ),\n+            bound_vars,\n+        );\n \n         debug!(\"supplied_sig_of_closure: result={:?}\", result);\n "}, {"sha": "68a923a55eb0f8ad20091271ee6f9544dac2f40f", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1487,7 +1487,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         if let (Some((expr, _)), Some((fn_decl, _, _))) =\n             (expression, fcx.get_node_fn_decl(parent_item))\n         {\n-            fcx.suggest_missing_return_expr(&mut err, expr, fn_decl, expected, found);\n+            fcx.suggest_missing_return_expr(&mut err, expr, fn_decl, expected, found, parent_id);\n         }\n \n         if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.get(), fn_output) {"}, {"sha": "f044daa4509186c676629caa8a9bf20a670da719", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -225,7 +225,7 @@ fn compare_predicate_entailment<'tcx>(\n         let (impl_m_own_bounds, _) = infcx.replace_bound_vars_with_fresh_vars(\n             impl_m_span,\n             infer::HigherRankedType,\n-            ty::Binder::bind(impl_m_own_bounds.predicates),\n+            ty::Binder::bind(impl_m_own_bounds.predicates, tcx),\n         );\n         for predicate in impl_m_own_bounds {\n             let traits::Normalized { value: predicate, obligations } =\n@@ -258,14 +258,14 @@ fn compare_predicate_entailment<'tcx>(\n         );\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, impl_sig);\n-        let impl_fty = tcx.mk_fn_ptr(ty::Binder::bind(impl_sig));\n+        let impl_fty = tcx.mk_fn_ptr(ty::Binder::bind(impl_sig, tcx));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n         let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, tcx.fn_sig(trait_m.def_id));\n         let trait_sig = trait_sig.subst(tcx, trait_to_placeholder_substs);\n         let trait_sig =\n             inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, trait_sig);\n-        let trait_fty = tcx.mk_fn_ptr(ty::Binder::bind(trait_sig));\n+        let trait_fty = tcx.mk_fn_ptr(ty::Binder::bind(trait_sig, tcx));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n "}, {"sha": "de6336b254b3f49c643b3a3dae72a387d076a1a2", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -354,9 +354,9 @@ impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n \n     fn binders<T>(\n         &mut self,\n-        a: ty::Binder<T>,\n-        b: ty::Binder<T>,\n-    ) -> RelateResult<'tcx, ty::Binder<T>>\n+        a: ty::Binder<'tcx, T>,\n+        b: ty::Binder<'tcx, T>,\n+    ) -> RelateResult<'tcx, ty::Binder<'tcx, T>>\n     where\n         T: Relate<'tcx>,\n     {"}, {"sha": "9ace455042103559b738507ab3009ada6ebe0143", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1462,7 +1462,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &[][..],\n                 has_self,\n                 self_ty,\n-                arg_count,\n+                &arg_count,\n                 &mut CreateCtorSubstsContext {\n                     fcx: self,\n                     span,"}, {"sha": "6112a5fdc91d6e9ef01a31d5ae8c5828b7e67c1d", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -55,7 +55,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some((fn_decl, can_suggest)) = self.get_fn_decl(blk_id) {\n             pointing_at_return_type =\n                 self.suggest_missing_return_type(err, &fn_decl, expected, found, can_suggest);\n-            self.suggest_missing_return_expr(err, expr, &fn_decl, expected, found);\n+            let fn_id = self.tcx.hir().get_return_block(blk_id).unwrap();\n+            self.suggest_missing_return_expr(err, expr, &fn_decl, expected, found, fn_id);\n         }\n         pointing_at_return_type\n     }\n@@ -479,14 +480,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fn_decl: &hir::FnDecl<'_>,\n         expected: Ty<'tcx>,\n         found: Ty<'tcx>,\n+        id: hir::HirId,\n     ) {\n         if !expected.is_unit() {\n             return;\n         }\n         let found = self.resolve_vars_with_obligations(found);\n         if let hir::FnRetTy::Return(ty) = fn_decl.output {\n             let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n-            let ty = self.tcx.erase_late_bound_regions(Binder::bind(ty));\n+            let bound_vars = self.tcx.late_bound_vars(id);\n+            let ty = self.tcx.erase_late_bound_regions(Binder::bind_with_vars(ty, bound_vars));\n             let ty = self.normalize_associated_types_in(expr.span, ty);\n             if self.can_coerce(found, ty) {\n                 err.multipart_suggestion("}, {"sha": "e40aa914858586b6ec7814307e8addd43c048acf", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -186,7 +186,10 @@ pub fn resolve_interior<'a, 'tcx>(\n                 // which means that none of the regions inside relate to any other, even if\n                 // typeck had previously found constraints that would cause them to be related.\n                 let folded = fcx.tcx.fold_regions(erased, &mut false, |_, current_depth| {\n-                    let br = ty::BoundRegion { kind: ty::BrAnon(counter) };\n+                    let br = ty::BoundRegion {\n+                        var: ty::BoundVar::from_u32(counter),\n+                        kind: ty::BrAnon(counter),\n+                    };\n                     let r = fcx.tcx.mk_region(ty::ReLateBound(current_depth, br));\n                     counter += 1;\n                     r\n@@ -202,11 +205,15 @@ pub fn resolve_interior<'a, 'tcx>(\n \n     // Extract type components to build the witness type.\n     let type_list = fcx.tcx.mk_type_list(type_causes.iter().map(|cause| cause.ty));\n-    let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind(type_list));\n+    let bound_vars = fcx.tcx.mk_bound_variable_kinds(\n+        (0..counter).map(|i| ty::BoundVariableKind::Region(ty::BrAnon(i))),\n+    );\n+    let witness =\n+        fcx.tcx.mk_generator_witness(ty::Binder::bind_with_vars(type_list, bound_vars.clone()));\n \n     // Store the generator types and spans into the typeck results for this generator.\n     visitor.fcx.inh.typeck_results.borrow_mut().generator_interior_types =\n-        ty::Binder::bind(type_causes);\n+        ty::Binder::bind_with_vars(type_causes, bound_vars);\n \n     debug!(\n         \"types in generator after region replacement {:?}, span = {:?}\","}, {"sha": "303a77507cf7bc84a3fc1e1a341e0e1d828e44c2", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -101,12 +101,21 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let intrinsic_name = tcx.item_name(it.def_id.to_def_id());\n     let name_str = intrinsic_name.as_str();\n \n+    let bound_vars = tcx.mk_bound_variable_kinds(\n+        [ty::BoundVariableKind::Region(ty::BrAnon(0)), ty::BoundVariableKind::Region(ty::BrEnv)]\n+            .iter()\n+            .copied(),\n+    );\n     let mk_va_list_ty = |mutbl| {\n         tcx.lang_items().va_list().map(|did| {\n-            let region = tcx\n-                .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind: ty::BrAnon(0) }));\n-            let env_region =\n-                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind: ty::BrEnv }));\n+            let region = tcx.mk_region(ty::ReLateBound(\n+                ty::INNERMOST,\n+                ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) },\n+            ));\n+            let env_region = tcx.mk_region(ty::ReLateBound(\n+                ty::INNERMOST,\n+                ty::BoundRegion { var: ty::BoundVar::from_u32(1), kind: ty::BrEnv },\n+            ));\n             let va_list_ty = tcx.type_of(did).subst(tcx, &[region.into()]);\n             (tcx.mk_ref(env_region, ty::TypeAndMut { ty: va_list_ty, mutbl }), va_list_ty)\n         })\n@@ -305,7 +314,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                     tcx.associated_items(tcx.lang_items().discriminant_kind_trait().unwrap());\n                 let discriminant_def_id = assoc_items.in_definition_order().next().unwrap().def_id;\n \n-                let br = ty::BoundRegion { kind: ty::BrAnon(0) };\n+                let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) };\n                 (\n                     1,\n                     vec![\n@@ -366,7 +375,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         (n_tps, inputs, output, unsafety)\n     };\n     let sig = tcx.mk_fn_sig(inputs.into_iter(), output, false, unsafety, Abi::RustIntrinsic);\n-    let sig = ty::Binder::bind(sig);\n+    let sig = ty::Binder::bind_with_vars(sig, bound_vars);\n     equate_intrinsic_type(tcx, it, n_tps, sig)\n }\n "}, {"sha": "f546a0d8963544883282aa0140b2783663681ee1", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // We won't add these if we encountered an illegal sized bound, so that we can use\n         // a custom error in that case.\n         if illegal_sized_bound.is_none() {\n-            let method_ty = self.tcx.mk_fn_ptr(ty::Binder::bind(method_sig));\n+            let method_ty = self.tcx.mk_fn_ptr(ty::Binder::bind(method_sig, self.tcx));\n             self.add_obligations(method_ty, all_substs, method_predicates);\n         }\n \n@@ -381,7 +381,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             parent_substs,\n             false,\n             None,\n-            arg_count_correct,\n+            &arg_count_correct,\n             &mut MethodSubstsCtxt { cfcx: self, pick, seg },\n         )\n     }\n@@ -550,7 +550,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         upcast_trait_refs.into_iter().next().unwrap()\n     }\n \n-    fn replace_bound_vars_with_fresh_vars<T>(&self, value: ty::Binder<T>) -> T\n+    fn replace_bound_vars_with_fresh_vars<T>(&self, value: ty::Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "bd7ffd057b466f9038fcd70f17eb40d4778c8248", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.extend(traits::predicates_for_generics(cause.clone(), self.param_env, bounds));\n \n         // Also add an obligation for the method type being well-formed.\n-        let method_ty = tcx.mk_fn_ptr(ty::Binder::bind(fn_sig));\n+        let method_ty = tcx.mk_fn_ptr(ty::Binder::bind(fn_sig, tcx));\n         debug!(\n             \"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n             method_ty, obligation"}, {"sha": "bfaf36e702fdbcbcca1f4b17e845a26abe52fe22", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1753,7 +1753,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     ///    region got replaced with the same variable, which requires a bit more coordination\n     ///    and/or tracking the substitution and\n     ///    so forth.\n-    fn erase_late_bound_regions<T>(&self, value: ty::Binder<T>) -> T\n+    fn erase_late_bound_regions<T>(&self, value: ty::Binder<'tcx, T>) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {"}, {"sha": "0760d59875c701ace0864a9cddea7a98e7783dd6", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -497,6 +497,7 @@ fn typeck_with_fallback<'tcx>(\n                 let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n                 <dyn AstConv<'_>>::ty_of_fn(\n                     &fcx,\n+                    id,\n                     header.unsafety,\n                     header.abi,\n                     decl,"}, {"sha": "887cc42a1dd272bb058f5c5eac78be86cc141a1b", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1067,13 +1067,14 @@ fn check_method_receiver<'fcx, 'tcx>(\n     debug!(\"check_method_receiver: sig={:?}\", sig);\n \n     let self_ty = fcx.normalize_associated_types_in(span, self_ty);\n-    let self_ty = fcx.tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(self_ty));\n+    let self_ty =\n+        fcx.tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(self_ty, fcx.tcx));\n \n     let receiver_ty = sig.inputs()[0];\n \n     let receiver_ty = fcx.normalize_associated_types_in(span, receiver_ty);\n     let receiver_ty =\n-        fcx.tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(receiver_ty));\n+        fcx.tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(receiver_ty, fcx.tcx));\n \n     if fcx.tcx.features().arbitrary_self_types {\n         if !receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {"}, {"sha": "afe52c977334d5414cec747e3fe875f9650db7d8", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1244,7 +1244,8 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             match self.tcx.named_region(lt.hir_id) {\n                 Some(rl::Region::Static | rl::Region::EarlyBound(..)) => {}\n                 Some(\n-                    rl::Region::LateBound(debruijn, _, _) | rl::Region::LateBoundAnon(debruijn, _),\n+                    rl::Region::LateBound(debruijn, _, _, _)\n+                    | rl::Region::LateBoundAnon(debruijn, _, _),\n                 ) if debruijn < self.outer_index => {}\n                 Some(\n                     rl::Region::LateBound(..)\n@@ -1707,10 +1708,11 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     }\n                     diag.emit();\n \n-                    ty::Binder::bind(fn_sig)\n+                    ty::Binder::bind(fn_sig, tcx)\n                 }\n                 None => <dyn AstConv<'_>>::ty_of_fn(\n                     &icx,\n+                    hir_id,\n                     sig.header.unsafety,\n                     sig.header.abi,\n                     &sig.decl,\n@@ -1728,6 +1730,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             ..\n         }) => <dyn AstConv<'_>>::ty_of_fn(\n             &icx,\n+            hir_id,\n             header.unsafety,\n             header.abi,\n             decl,\n@@ -1749,13 +1752,10 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             let ty = tcx.type_of(tcx.hir().get_parent_did(hir_id).to_def_id());\n             let inputs =\n                 data.fields().iter().map(|f| tcx.type_of(tcx.hir().local_def_id(f.hir_id)));\n-            ty::Binder::bind(tcx.mk_fn_sig(\n-                inputs,\n-                ty,\n-                false,\n-                hir::Unsafety::Normal,\n-                abi::Abi::Rust,\n-            ))\n+            ty::Binder::bind(\n+                tcx.mk_fn_sig(inputs, ty, false, hir::Unsafety::Normal, abi::Abi::Rust),\n+                tcx,\n+            )\n         }\n \n         Expr(&hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n@@ -2039,7 +2039,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 param.bounds.iter().for_each(|bound| match bound {\n                     hir::GenericBound::Outlives(lt) => {\n                         let bound = <dyn AstConv<'_>>::ast_region_to_region(&icx, &lt, None);\n-                        let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound));\n+                        let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound), tcx);\n                         predicates.insert((outlives.to_predicate(tcx), lt.span));\n                     }\n                     _ => bug!(),\n@@ -2084,6 +2084,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         match predicate {\n             hir::WherePredicate::BoundPredicate(bound_pred) => {\n                 let ty = icx.to_ty(&bound_pred.bounded_ty);\n+                let bound_vars = icx.tcx.late_bound_vars(bound_pred.bounded_ty.hir_id);\n \n                 // Keep the type around in a dummy predicate, in case of no bounds.\n                 // That way, `where Ty:` is not a complete noop (see #53696) and `Ty`\n@@ -2099,9 +2100,13 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n-                        let predicate = ty::Binder::bind(ty::PredicateKind::TypeOutlives(\n-                            ty::OutlivesPredicate(ty, re_root_empty),\n-                        ));\n+                        let predicate = ty::Binder::bind_with_vars(\n+                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n+                                ty,\n+                                re_root_empty,\n+                            )),\n+                            bound_vars,\n+                        );\n                         predicates.insert((predicate.to_predicate(tcx), span));\n                     }\n                 }\n@@ -2118,10 +2123,12 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                             let mut bounds = Bounds::default();\n                             let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref(\n                                 &icx,\n-                                &poly_trait_ref,\n+                                &poly_trait_ref.trait_ref,\n+                                poly_trait_ref.span,\n                                 constness,\n                                 ty,\n                                 &mut bounds,\n+                                false,\n                             );\n                             predicates.extend(bounds.predicates(tcx, ty));\n                         }\n@@ -2144,9 +2151,12 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                             let region =\n                                 <dyn AstConv<'_>>::ast_region_to_region(&icx, lifetime, None);\n                             predicates.insert((\n-                                ty::Binder::bind(ty::PredicateKind::TypeOutlives(\n-                                    ty::OutlivesPredicate(ty, region),\n-                                ))\n+                                ty::Binder::bind_with_vars(\n+                                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n+                                        ty, region,\n+                                    )),\n+                                    bound_vars,\n+                                )\n                                 .to_predicate(tcx),\n                                 lifetime.span,\n                             ));\n@@ -2368,7 +2378,14 @@ fn predicates_from_bound<'tcx>(\n             };\n \n             let mut bounds = Bounds::default();\n-            let _ = astconv.instantiate_poly_trait_ref(tr, constness, param_ty, &mut bounds);\n+            let _ = astconv.instantiate_poly_trait_ref(\n+                &tr.trait_ref,\n+                tr.span,\n+                constness,\n+                param_ty,\n+                &mut bounds,\n+                false,\n+            );\n             bounds.predicates(astconv.tcx(), param_ty)\n         }\n         hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n@@ -2404,8 +2421,10 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     } else {\n         hir::Unsafety::Unsafe\n     };\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let fty = <dyn AstConv<'_>>::ty_of_fn(\n         &ItemCtxt::new(tcx, def_id),\n+        hir_id,\n         unsafety,\n         abi,\n         decl,"}, {"sha": "190744fe6f1d81d79376c7793c1292cbbe7bd035", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -430,7 +430,7 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     let env_node_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let env_def_id = tcx.hir().local_def_id(env_node_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n-    item_cx.to_ty(hir_ty)\n+    <dyn AstConv<'_>>::ast_ty_to_ty(&item_cx, hir_ty)\n }\n \n pub fn hir_trait_to_predicates<'tcx>(\n@@ -445,7 +445,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n     let env_def_id = tcx.hir().local_def_id(env_hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     let mut bounds = Bounds::default();\n-    let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref_inner(\n+    let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref(\n         &item_cx,\n         hir_trait,\n         DUMMY_SP,"}, {"sha": "217e899001ef9b23fef5b6797b76bfee48c1a0d2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -352,7 +352,7 @@ impl Clean<Lifetime> for hir::Lifetime {\n         match def {\n             Some(\n                 rl::Region::EarlyBound(_, node_id, _)\n-                | rl::Region::LateBound(_, node_id, _)\n+                | rl::Region::LateBound(_, _, node_id, _)\n                 | rl::Region::Free(_, node_id),\n             ) => {\n                 if let Some(lt) = cx.lt_substs.get(&node_id).cloned() {\n@@ -411,7 +411,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n     fn clean(&self, _cx: &mut DocContext<'_>) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n-            ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name) }) => {\n+            ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) => {\n                 Some(Lifetime(name))\n             }\n             ty::ReEarlyBound(ref data) => Some(Lifetime(data.name)),"}, {"sha": "60cbe9f376f01542f79debe868a8893a1cc13189", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -97,7 +97,7 @@ fn external_generic_args(\n         .iter()\n         .filter_map(|kind| match kind.unpack() {\n             GenericArgKind::Lifetime(lt) => match lt {\n-                ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrAnon(_) }) => {\n+                ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrAnon(_), .. }) => {\n                     Some(GenericArg::Lifetime(Lifetime::elided()))\n                 }\n                 _ => lt.clean(cx).map(GenericArg::Lifetime),"}, {"sha": "c8530c70f78d2086e9ae31de93e8d8e1ab3738ec", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -118,7 +118,7 @@ pub fn type_parameter<T>() {}\n pub fn lifetime_parameter() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, generics_of\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, generics_of,fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn lifetime_parameter<'a>() {}\n \n@@ -150,7 +150,7 @@ pub fn lifetime_bound<'a, T>() {}\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg = \"cfail2\",\n-    except = \"hir_owner, hir_owner_nodes, generics_of, type_of, predicates_of\"\n+    except = \"hir_owner, hir_owner_nodes, generics_of, type_of, predicates_of,fn_sig\"\n )]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn lifetime_bound<'a, T: 'a>() {}\n@@ -183,7 +183,7 @@ pub fn second_lifetime_bound<'a, 'b, T: 'a>() {}\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg = \"cfail2\",\n-    except = \"hir_owner, hir_owner_nodes, generics_of, type_of, predicates_of\"\n+    except = \"hir_owner, hir_owner_nodes, generics_of, type_of, predicates_of,fn_sig\"\n )]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn second_lifetime_bound<'a, 'b, T: 'a + 'b>() {}"}, {"sha": "ee7b258cec4edc71b764eeb017dff81404b15982", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -312,7 +312,7 @@ impl Foo {\n     // if we lower generics before the body, then the `HirId` for\n     // things in the body will be affected. So if you start to see\n     // `typeck` appear dirty, that might be the cause. -nmatsakis\n-    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,fn_sig\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_parameter_to_method<'a>(&self) { }\n }\n@@ -360,7 +360,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of,type_of\"\n+        except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of,type_of,fn_sig\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_bound_to_lifetime_param_of_method<'a, 'b: 'a>(&self) { }\n@@ -388,7 +388,7 @@ impl Foo {\n     // body will be affected. So if you start to see `typeck`\n     // appear dirty, that might be the cause. -nmatsakis\n     #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of,\\\n-                                        type_of\")]\n+                                        type_of,fn_sig\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_bound_to_type_param_of_method<'a, T: 'a>(&self) { }\n }"}, {"sha": "7ab3836493b01ce546bec90266e0e8080fd223a2", "filename": "src/test/ui/associated-type-bounds/hrtb.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhrtb.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -0,0 +1,65 @@\n+// check-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+trait A<'a> {}\n+trait B<'b> {}\n+fn foo<T>()\n+where\n+    for<'a> T: A<'a> + 'a,\n+{\n+}\n+trait C<'c>: for<'a> A<'a> + for<'b> B<'b> {\n+    type As;\n+}\n+struct D<T>\n+where\n+    T: for<'c> C<'c, As: A<'c>>,\n+{\n+    t: std::marker::PhantomData<T>,\n+}\n+\n+trait E<'e> {\n+    type As;\n+}\n+trait F<'f>: for<'a> A<'a> + for<'e> E<'e> {}\n+struct G<T>\n+where\n+    for<'f> T: F<'f, As: E<'f>> + 'f,\n+{\n+    t: std::marker::PhantomData<T>,\n+}\n+\n+trait I<'a, 'b, 'c> {\n+    type As;\n+}\n+trait H<'d, 'e>: for<'f> I<'d, 'f, 'e> + 'd {}\n+fn foo2<T>()\n+where\n+    T: for<'g> H<'g, 'g, As: for<'h> H<'h, 'g> + 'g>,\n+{\n+}\n+\n+fn foo3<T>()\n+where\n+    T: for<'i> H<'i, 'i, As: for<'j> H<'j, 'i, As: for<'k> I<'i, 'k, 'j> + 'j> + 'i>,\n+{\n+}\n+fn foo4<T>()\n+where\n+    T: for<'l, 'i> H<'l, 'i, As: for<'j> H<'j, 'i, As: for<'k> I<'l, 'k, 'j> + 'j> + 'i>,\n+{\n+}\n+\n+struct X<'x, 'y> {\n+    x: std::marker::PhantomData<&'x ()>,\n+    y: std::marker::PhantomData<&'y ()>,\n+}\n+\n+fn foo5<T>()\n+where\n+    T: for<'l, 'i> H<'l, 'i, As: for<'j> H<'j, 'i, As: for<'k> H<'j, 'k, As = X<'j, 'k>> + 'j> + 'i>\n+{\n+}\n+\n+fn main() {}"}, {"sha": "8cdfe247e025e7b17626f8976fbaaeb2ff781f81", "filename": "src/test/ui/hrtb/complex.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fhrtb%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fhrtb%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fcomplex.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+\n+trait A<'a> {}\n+trait B<'b> {}\n+fn foo<T>() where for<'a> T: A<'a> + 'a {}\n+trait C<'c>: for<'a> A<'a> + for<'b> B<'b> {\n+    type As;\n+}\n+struct D<T> where T: for<'c> C<'c, As=&'c ()> {\n+    t: std::marker::PhantomData<T>,\n+}\n+trait E<'e, 'g> {\n+    type As;\n+}\n+trait F<'f>: for<'a> A<'a> + for<'e> E<'e, 'f> {}\n+struct G<T> where T: for<'f> F<'f, As=&'f ()> {\n+    t: std::marker::PhantomData<T>,\n+}\n+trait H<'a, 'b> {\n+    type As;\n+}\n+trait I<'a>: for<'b> H<'a, 'b> {}\n+\n+struct J<T> where T: for<'i> I<'i, As=&'i ()> {\n+    t: std::marker::PhantomData<T>,\n+}\n+\n+fn main() {}"}, {"sha": "c1c40afdbab55ac014b138dd3c8bc9abc2740463", "filename": "src/test/ui/in-band-lifetimes/no_introducing_in_band_in_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -7,7 +7,7 @@ fn foo(x: &u32) {\n \n fn foo2(x: &u32) {}\n fn bar() {\n-    let y: fn(&'test u32) = foo2;\n+    let y: fn(&'test u32) = foo2; //~ ERROR use of undeclared lifetime\n }\n \n fn main() {}"}, {"sha": "a43b49041ec2aa4fc0cb391cf3ebc305b9d33a3e", "filename": "src/test/ui/in-band-lifetimes/no_introducing_in_band_in_locals.stderr", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fno_introducing_in_band_in_locals.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -6,6 +6,22 @@ LL | fn foo(x: &u32) {\n LL |     let y: &'test u32 = x;\n    |             ^^^^^ undeclared lifetime\n \n-error: aborting due to previous error\n+error[E0261]: use of undeclared lifetime name `'test`\n+  --> $DIR/no_introducing_in_band_in_locals.rs:10:16\n+   |\n+LL |     let y: fn(&'test u32) = foo2;\n+   |                ^^^^^ undeclared lifetime\n+   |\n+   = note: for more information on higher-ranked polymorphism, visit https://doc.rust-lang.org/nomicon/hrtb.html\n+help: consider introducing lifetime `'test` here\n+   |\n+LL | fn bar<'test>() {\n+   |       ^^^^^^^\n+help: consider making the type lifetime-generic with a new `'test` lifetime\n+   |\n+LL |     let y: for<'test> fn(&'test u32) = foo2;\n+   |            ^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0261`."}, {"sha": "d16ba3df47b63de0fa78d120adab7aa840d5b8cd", "filename": "src/test/ui/methods/method-call-lifetime-args-unresolved.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1,5 +1,3 @@\n fn main() {\n     0.clone::<'a>(); //~ ERROR use of undeclared lifetime name `'a`\n-    //~^ WARNING cannot specify lifetime arguments\n-    //~| WARNING this was previously accepted\n }"}, {"sha": "93c0384fcc2663fa8ff82c4170ba356e85814022", "filename": "src/test/ui/methods/method-call-lifetime-args-unresolved.stderr", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-call-lifetime-args-unresolved.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1,18 +1,3 @@\n-warning: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n-  --> $DIR/method-call-lifetime-args-unresolved.rs:2:15\n-   |\n-LL |     0.clone::<'a>();\n-   |               ^^\n-   | \n-  ::: $SRC_DIR/core/src/clone.rs:LL:COL\n-   |\n-LL |     fn clone(&self) -> Self;\n-   |              - the late bound lifetime parameter is introduced here\n-   |\n-   = note: `#[warn(late_bound_lifetime_arguments)]` on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n-\n error[E0261]: use of undeclared lifetime name `'a`\n   --> $DIR/method-call-lifetime-args-unresolved.rs:2:15\n    |\n@@ -23,6 +8,6 @@ LL |     0.clone::<'a>();\n    |\n    = help: if you want to experiment with in-band lifetime bindings, add `#![feature(in_band_lifetimes)]` to the crate attributes\n \n-error: aborting due to previous error; 1 warning emitted\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0261`."}, {"sha": "ff16bf0e078fc191aac6f4729b705846003415f8", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -6,7 +6,7 @@ LL |         let mut closure = expect_sig(|p, y| *p = y);\n    |\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) mut &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) i32)),\n+               for<'r, 's, 't0> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) mut &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) i32)),\n                (),\n            ]\n "}, {"sha": "22398f085725507c5e1ae43553800bba666ba2c9", "filename": "src/test/ui/nll/closure-requirements/escape-argument.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -6,7 +6,7 @@ LL |         let mut closure = expect_sig(|p, y| *p = y);\n    |\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) mut &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) i32)),\n+               for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) mut &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) i32)),\n                (),\n            ]\n "}, {"sha": "11420efaa066eeecb1bdf521159525930ac5e63d", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -10,7 +10,7 @@ LL | |         },\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) &'_#3r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>)),\n+               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) &'_#3r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#4r"}, {"sha": "98c3c28fb43ff8382ee5c02e9dca9a78ff75f405", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -11,7 +11,7 @@ LL | |     });\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) u32>)),\n+               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 4, kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 5, kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#3r"}, {"sha": "30ef343b26123268780e197fb52d6bdb75b0f2b8", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -10,7 +10,7 @@ LL | |     })\n    |\n    = note: defining type: case1::{closure#0} with closure substs [\n                i32,\n-               for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>)),\n+               for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>)),\n                (),\n            ]\n \n@@ -49,7 +49,7 @@ LL | |     })\n    |\n    = note: defining type: case2::{closure#0} with closure substs [\n                i32,\n-               for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>)),\n+               for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>)),\n                (),\n            ]\n    = note: number of external vids: 2"}, {"sha": "29993b129c71ae869caa89b193ab4c460d814f15", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -12,7 +12,7 @@ LL | |     });\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t2) }) u32>)),\n+               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 4, kind: BrNamed('t2) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#2r"}, {"sha": "cb505d8b1eceb501faaa1b74b72232886926042e", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -12,7 +12,7 @@ LL | |     });\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) u32>)),\n+               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 4, kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 5, kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#3r"}, {"sha": "2ec9d4d8db1a6aa4d3b133b8bf171292bc1ce56e", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -11,7 +11,7 @@ LL | |     });\n    |\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>)),\n+               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#3r"}, {"sha": "21e4232c788fb928c4a64b2e1fe3b0d1c6ab327d", "filename": "src/test/ui/nll/closure-requirements/propagate-despite-same-free-region.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -10,7 +10,7 @@ LL | |         },\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>)),\n+               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#3r"}, {"sha": "8b9b0435420573c0dc5e7ec7f65c67bc3d50c4cc", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -11,7 +11,7 @@ LL | |     });\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>)),\n+               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 4, kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#2r"}, {"sha": "060ce690f0306ac492a5d366b9318869cb07be52", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -11,7 +11,7 @@ LL | |     });\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) u32>)),\n+               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 4, kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 5, kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#3r"}, {"sha": "5fc1d5c43618154f55ac5fc9644402799d72a4cd", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -6,7 +6,7 @@ LL |     expect_sig(|a, b| b); // ought to return `a`\n    |\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) i32)) -> &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) i32,\n+               for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) i32)) -> &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) i32,\n                (),\n            ]\n "}, {"sha": "baf223b786b080709fd7ba3629f507d1f96f3d36", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -6,7 +6,7 @@ LL |     twice(cell, value, |a, b| invoke(a, b));\n    |\n    = note: defining type: generic::<T>::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) ()>>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) T)),\n+               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) ()>>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) T)),\n                (),\n            ]\n    = note: number of external vids: 2\n@@ -31,7 +31,7 @@ LL |     twice(cell, value, |a, b| invoke(a, b));\n    |\n    = note: defining type: generic_fail::<T>::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) ()>>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) T)),\n+               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) ()>>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) T)),\n                (),\n            ]\n    = note: late-bound region is '_#2r"}, {"sha": "fa59d7a031397530d9114219be96e3c8097302f9", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1,4 +1,4 @@\n-error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id::This) }, (I,)))`\n+error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id::This) }, (I,)), [])`\n   --> $DIR/repeated_projection_type.rs:19:1\n    |\n LL | / impl<I, V: Id<This = (I,)>> X for V {"}, {"sha": "3dd2b19fbf987f9cc290979b09f0988ac9c06fd5", "filename": "src/test/ui/symbol-names/basic.legacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1,10 +1,10 @@\n-error: symbol-name(_ZN5basic4main17hfcf1daab33c43a6aE)\n+error: symbol-name(_ZN5basic4main17h6c535bbea2051f85E)\n   --> $DIR/basic.rs:8:1\n    |\n LL | #[rustc_symbol_name]\n    | ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(basic::main::hfcf1daab33c43a6a)\n+error: demangling(basic::main::h6c535bbea2051f85)\n   --> $DIR/basic.rs:8:1\n    |\n LL | #[rustc_symbol_name]"}, {"sha": "65cc62b4d1dd6948889297f4de7083d58f58de44", "filename": "src/test/ui/symbol-names/issue-60925.legacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -1,10 +1,10 @@\n-error: symbol-name(_ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3foo17hb8ca3eb2682b1b51E)\n+error: symbol-name(_ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3foo17h6244e5288326926aE)\n   --> $DIR/issue-60925.rs:22:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo::hb8ca3eb2682b1b51)\n+error: demangling(issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo::h6244e5288326926a)\n   --> $DIR/issue-60925.rs:22:9\n    |\n LL |         #[rustc_symbol_name]"}, {"sha": "4c13941f66599b28d3532e1f5ff2ff96ac20aff0", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4fdac23f3171e2f8864d359a21da600dd3faafc9/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=4fdac23f3171e2f8864d359a21da600dd3faafc9", "patch": "@@ -44,7 +44,7 @@ fn get_trait_predicates_for_trait_id<'tcx>(\n     for (pred, _) in generics.predicates {\n         if_chain! {\n             if let PredicateKind::Trait(poly_trait_pred, _) = pred.kind().skip_binder();\n-            let trait_pred = cx.tcx.erase_late_bound_regions(ty::Binder::bind(poly_trait_pred));\n+            let trait_pred = cx.tcx.erase_late_bound_regions(pred.kind().rebind(poly_trait_pred));\n             if let Some(trait_def_id) = trait_id;\n             if trait_def_id == trait_pred.trait_ref.def_id;\n             then {\n@@ -58,12 +58,12 @@ fn get_trait_predicates_for_trait_id<'tcx>(\n fn get_projection_pred<'tcx>(\n     cx: &LateContext<'tcx>,\n     generics: GenericPredicates<'tcx>,\n-    pred: TraitPredicate<'tcx>,\n+    trait_pred: TraitPredicate<'tcx>,\n ) -> Option<ProjectionPredicate<'tcx>> {\n     generics.predicates.iter().find_map(|(proj_pred, _)| {\n-        if let ty::PredicateKind::Projection(proj_pred) = proj_pred.kind().skip_binder() {\n-            let projection_pred = cx.tcx.erase_late_bound_regions(ty::Binder::bind(proj_pred));\n-            if projection_pred.projection_ty.substs == pred.trait_ref.substs {\n+        if let ty::PredicateKind::Projection(pred) = proj_pred.kind().skip_binder() {\n+            let projection_pred = cx.tcx.erase_late_bound_regions(proj_pred.kind().rebind(pred));\n+            if projection_pred.projection_ty.substs == trait_pred.trait_ref.substs {\n                 return Some(projection_pred);\n             }\n         }"}]}