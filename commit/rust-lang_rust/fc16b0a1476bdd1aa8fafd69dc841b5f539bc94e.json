{"sha": "fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjMTZiMGExNDc2YmRkMWFhOGZhZmQ2OWRjODQxYjVmNTM5YmM5NGU=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-03-18T20:55:19Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-01T22:11:19Z"}, "message": "Fix rebase from LazyConst removal", "tree": {"sha": "0df29039e27938079356b38c5f1c6c8b46eb80b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0df29039e27938079356b38c5f1c6c8b46eb80b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "html_url": "https://github.com/rust-lang/rust/commit/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c888af52be46ed87bb14043da02df486288701c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c888af52be46ed87bb14043da02df486288701c6", "html_url": "https://github.com/rust-lang/rust/commit/c888af52be46ed87bb14043da02df486288701c6"}], "stats": {"total": 726, "additions": 337, "deletions": 389}, "files": [{"sha": "1bf1163c4abcb6e0441c84976d5f7f7240e5fd86", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 50, "deletions": 56, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -15,6 +15,7 @@ use std::sync::atomic::Ordering;\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::subst::Kind;\n use crate::ty::{self, BoundVar, InferConst, Lift, List, Ty, TyCtxt, TypeFlags};\n+use crate::ty::flags::FlagComputation;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -434,59 +435,58 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Canonicalizer<'cx, 'gcx, 'tcx>\n         }\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n-        if let ty::LazyConst::Evaluated(ct) = c {\n-            match ct.val {\n-                ConstValue::Infer(InferConst::Var(vid)) => {\n-                    debug!(\"canonical: const var found with vid {:?}\", vid);\n-                    match self.infcx.unwrap().probe_const_var(vid) {\n-                        Ok(c) => {\n-                            debug!(\"(resolved to {:?})\", c);\n-                            return self.fold_const(c);\n-                        }\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        match ct.val {\n+            ConstValue::Infer(InferConst::Var(vid)) => {\n+                debug!(\"canonical: const var found with vid {:?}\", vid);\n+                match self.infcx.unwrap().probe_const_var(vid) {\n+                    Ok(c) => {\n+                        debug!(\"(resolved to {:?})\", c);\n+                        return self.fold_const(c);\n+                    }\n \n-                        // `ConstVar(vid)` is unresolved, track its universe index in the\n-                        // canonicalized result\n-                        Err(mut ui) => {\n-                            if !self.infcx.unwrap().tcx.sess.opts.debugging_opts.chalk {\n-                                // FIXME: perf problem described in #55921.\n-                                ui = ty::UniverseIndex::ROOT;\n-                            }\n-                            return self.canonicalize_const_var(\n-                                CanonicalVarInfo {\n-                                    kind: CanonicalVarKind::Const(ui),\n-                                },\n-                                c,\n-                            );\n+                    // `ConstVar(vid)` is unresolved, track its universe index in the\n+                    // canonicalized result\n+                    Err(mut ui) => {\n+                        if !self.infcx.unwrap().tcx.sess.opts.debugging_opts.chalk {\n+                            // FIXME: perf problem described in #55921.\n+                            ui = ty::UniverseIndex::ROOT;\n                         }\n+                        return self.canonicalize_const_var(\n+                            CanonicalVarInfo {\n+                                kind: CanonicalVarKind::Const(ui),\n+                            },\n+                            ct,\n+                        );\n                     }\n                 }\n-                ConstValue::Infer(InferConst::Fresh(_)) => {\n-                    bug!(\"encountered a fresh const during canonicalization\")\n-                }\n-                ConstValue::Infer(InferConst::Canonical(debruijn, _)) => {\n-                    if debruijn >= self.binder_index {\n-                        bug!(\"escaping bound type during canonicalization\")\n-                    } else {\n-                        return c;\n-                    }\n-                }\n-                ConstValue::Placeholder(placeholder) => {\n-                    return self.canonicalize_const_var(\n-                        CanonicalVarInfo {\n-                            kind: CanonicalVarKind::PlaceholderConst(placeholder),\n-                        },\n-                        c,\n-                    );\n+            }\n+            ConstValue::Infer(InferConst::Fresh(_)) => {\n+                bug!(\"encountered a fresh const during canonicalization\")\n+            }\n+            ConstValue::Infer(InferConst::Canonical(debruijn, _)) => {\n+                if debruijn >= self.binder_index {\n+                    bug!(\"escaping bound type during canonicalization\")\n+                } else {\n+                    return ct;\n                 }\n-                _ => {}\n             }\n+            ConstValue::Placeholder(placeholder) => {\n+                return self.canonicalize_const_var(\n+                    CanonicalVarInfo {\n+                        kind: CanonicalVarKind::PlaceholderConst(placeholder),\n+                    },\n+                    ct,\n+                );\n+            }\n+            _ => {}\n         }\n \n-        if c.type_flags().intersects(self.needs_canonical_flags) {\n-            c.super_fold_with(self)\n+        let flags = FlagComputation::for_const(ct);\n+        if flags.intersects(self.needs_canonical_flags) {\n+            ct.super_fold_with(self)\n         } else {\n-            c\n+            ct\n         }\n     }\n }\n@@ -700,25 +700,19 @@ impl<'cx, 'gcx, 'tcx> Canonicalizer<'cx, 'gcx, 'tcx> {\n     fn canonicalize_const_var(\n         &mut self,\n         info: CanonicalVarInfo,\n-        const_var: &'tcx ty::LazyConst<'tcx>\n-    ) -> &'tcx ty::LazyConst<'tcx> {\n+        const_var: &'tcx ty::Const<'tcx>\n+    ) -> &'tcx ty::Const<'tcx> {\n         let infcx = self.infcx.expect(\"encountered const-var without infcx\");\n         let bound_to = infcx.resolve_const_var(const_var);\n         if bound_to != const_var {\n             self.fold_const(bound_to)\n         } else {\n-            let ty = match const_var {\n-                ty::LazyConst::Unevaluated(def_id, _) => {\n-                    self.tcx.type_of(*def_id)\n-                }\n-                ty::LazyConst::Evaluated(ty::Const { ty, .. }) => ty,\n-            };\n             let var = self.canonical_var(info, const_var.into());\n-            self.tcx().mk_lazy_const(\n-                ty::LazyConst::Evaluated(ty::Const {\n+            self.tcx().mk_const(\n+                ty::Const {\n                     val: ConstValue::Infer(InferConst::Canonical(self.binder_index, var.into())),\n-                    ty,\n-                })\n+                    ty: const_var.ty,\n+                }\n             )\n         }\n     }"}, {"sha": "7c61db21e613a3a27babc95a0e7b1009e9748d50", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -419,12 +419,12 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     universe: universe_mapped,\n                     name,\n                 };\n-                self.tcx.mk_lazy_const(ty::LazyConst::Evaluated(\n+                self.tcx.mk_const(\n                     ty::Const {\n                         val: ConstValue::Placeholder(placeholder_mapped),\n                         ty: self.tcx.types.err, // FIXME(const_generics)\n                     }\n-                )).into()\n+                ).into()\n             }\n         }\n     }\n@@ -482,18 +482,12 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                         ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i))\n                     ).into(),\n                     UnpackedKind::Const(ct) => {\n-                        let ty = match ct {\n-                            ty::LazyConst::Unevaluated(def_id, _) => {\n-                                tcx.type_of(*def_id)\n-                            }\n-                            ty::LazyConst::Evaluated(ty::Const { ty, .. }) => ty,\n-                        };\n-                        tcx.mk_lazy_const(ty::LazyConst::Evaluated(ty::Const {\n-                            ty: ty,\n+                        tcx.mk_const(ty::Const {\n+                            ty: ct.ty,\n                             val: ConstValue::Infer(\n                                 InferConst::Canonical(ty::INNERMOST, ty::BoundVar::from_u32(i))\n                             ),\n-                        })).into()\n+                        }).into()\n                     }\n                 })\n                 .collect()"}, {"sha": "8225ed70c5827b283f06748bf8ff21a71f1b03bd", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -481,10 +481,10 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n                 UnpackedKind::Const(result_value) => {\n-                    if let ty::LazyConst::Evaluated(ty::Const {\n+                    if let ty::Const {\n                         val: ConstValue::Infer(InferConst::Canonical(debrujin, b)),\n                         ..\n-                    }) = result_value {\n+                    } = result_value {\n                         // ...in which case we would set `canonical_vars[0]` to `Some(const X)`.\n \n                         // We only allow a `ty::INNERMOST` index in substitutions."}, {"sha": "048c0a7a8fd0a5cdba566f6ad5df6d0b967f55d1", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -33,7 +33,7 @@ use super::unify_key::{ConstVarValue, ConstVariableValue, ConstVariableOrigin};\n use crate::hir::def_id::DefId;\n use crate::mir::interpret::ConstValue;\n use crate::ty::{IntType, UintType};\n-use crate::ty::{self, Ty, TyCtxt, InferConst, LazyConst};\n+use crate::ty::{self, Ty, TyCtxt, InferConst};\n use crate::ty::error::TypeError;\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use crate::ty::subst::SubstsRef;\n@@ -118,41 +118,39 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n     pub fn super_combine_consts<R>(\n         &self,\n         relation: &mut R,\n-        a: &'tcx LazyConst<'tcx>,\n-        b: &'tcx LazyConst<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx LazyConst<'tcx>>\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n     where\n         R: TypeRelation<'infcx, 'gcx, 'tcx>,\n     {\n         let a_is_expected = relation.a_is_expected();\n \n-        if let (&ty::LazyConst::Evaluated(a_eval), &ty::LazyConst::Evaluated(b_eval)) = (a, b) {\n-            match (a_eval.val, b_eval.val) {\n-                (ConstValue::Infer(InferConst::Var(a_vid)),\n-                 ConstValue::Infer(InferConst::Var(b_vid))) => {\n-                    self.const_unification_table\n-                        .borrow_mut()\n-                        .unify_var_var(a_vid, b_vid)\n-                        .map_err(|e| const_unification_error(a_is_expected, e))?;\n-                    return Ok(a);\n-                }\n-\n-                // All other cases of inference with other variables are errors.\n-                (ConstValue::Infer(InferConst::Var(_)), ConstValue::Infer(_)) |\n-                (ConstValue::Infer(_), ConstValue::Infer(InferConst::Var(_))) => {\n-                    bug!(\"tried to combine ConstValue::Infer/ConstValue::Infer(InferConst::Var)\")\n-                }\n+        match (a.val, b.val) {\n+            (ConstValue::Infer(InferConst::Var(a_vid)),\n+                ConstValue::Infer(InferConst::Var(b_vid))) => {\n+                self.const_unification_table\n+                    .borrow_mut()\n+                    .unify_var_var(a_vid, b_vid)\n+                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n+                return Ok(a);\n+            }\n \n-                (ConstValue::Infer(InferConst::Var(vid)), _) => {\n-                    return self.unify_const_variable(a_is_expected, vid, b);\n-                }\n+            // All other cases of inference with other variables are errors.\n+            (ConstValue::Infer(InferConst::Var(_)), ConstValue::Infer(_)) |\n+            (ConstValue::Infer(_), ConstValue::Infer(InferConst::Var(_))) => {\n+                bug!(\"tried to combine ConstValue::Infer/ConstValue::Infer(InferConst::Var)\")\n+            }\n \n-                (_, ConstValue::Infer(InferConst::Var(vid))) => {\n-                    return self.unify_const_variable(!a_is_expected, vid, a);\n-                }\n+            (ConstValue::Infer(InferConst::Var(vid)), _) => {\n+                return self.unify_const_variable(a_is_expected, vid, b);\n+            }\n \n-                _ => {}\n+            (_, ConstValue::Infer(InferConst::Var(vid))) => {\n+                return self.unify_const_variable(!a_is_expected, vid, a);\n             }\n+\n+            _ => {}\n         }\n \n         ty::relate::super_relate_consts(relation, a, b)\n@@ -162,8 +160,8 @@ impl<'infcx, 'gcx, 'tcx> InferCtxt<'infcx, 'gcx, 'tcx> {\n         &self,\n         vid_is_expected: bool,\n         vid: ty::ConstVid<'tcx>,\n-        value: &'tcx LazyConst<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx LazyConst<'tcx>> {\n+        value: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         self.const_unification_table\n             .borrow_mut()\n             .unify_var_value(vid, ConstVarValue {\n@@ -582,16 +580,13 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n \n     fn consts(\n         &mut self,\n-        c: &'tcx ty::LazyConst<'tcx>,\n-        c2: &'tcx ty::LazyConst<'tcx>\n-    ) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>> {\n+        c: &'tcx ty::Const<'tcx>,\n+        c2: &'tcx ty::Const<'tcx>\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         assert_eq!(c, c2); // we are abusing TypeRelation here; both LHS and RHS ought to be ==\n \n         match c {\n-            LazyConst::Evaluated(ty::Const {\n-                val: ConstValue::Infer(InferConst::Var(vid)),\n-                ..\n-            }) => {\n+            ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } => {\n                 let mut variable_table = self.infcx.const_unification_table.borrow_mut();\n                 match variable_table.probe_value(*vid).val.known() {\n                     Some(u) => {\n@@ -628,7 +623,7 @@ impl<'tcx, T:Clone + PartialEq> RelateResultCompare<'tcx, T> for RelateResult<'t\n \n pub fn const_unification_error<'tcx>(\n     a_is_expected: bool,\n-    (a, b): (&'tcx LazyConst<'tcx>, &'tcx LazyConst<'tcx>),\n+    (a, b): (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>),\n ) -> TypeError<'tcx> {\n     TypeError::ConstMismatch(ty::relate::expected_found_bool(a_is_expected, &a, &b))\n }"}, {"sha": "f61408696ecbff8606da4aba221fd15760757851", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -104,39 +104,38 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::LazyConst<'tcx>,\n-        b: &'tcx ty::LazyConst<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>> {\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n         let a = replace_if_possible(infcx.const_unification_table.borrow_mut(), a);\n         let b = replace_if_possible(infcx.const_unification_table.borrow_mut(), b);\n         let a_is_expected = self.a_is_expected();\n-        if let (&ty::LazyConst::Evaluated(a_eval), &ty::LazyConst::Evaluated(b_eval)) = (a, b) {\n-            match (a_eval.val, b_eval.val) {\n-                (ConstValue::Infer(InferConst::Var(a_vid)),\n-                 ConstValue::Infer(InferConst::Var(b_vid))) => {\n-                    infcx.const_unification_table\n-                        .borrow_mut()\n-                        .unify_var_var(a_vid, b_vid)\n-                        .map_err(|e| const_unification_error(a_is_expected, e))?;\n-                    return Ok(a);\n-                }\n-\n-                (ConstValue::Infer(InferConst::Var(a_id)), _) => {\n-                    self.fields.infcx.unify_const_variable(a_is_expected, a_id, b)?;\n-                    return Ok(a);\n-                }\n-\n-                (_, ConstValue::Infer(InferConst::Var(b_id))) => {\n-                    self.fields.infcx.unify_const_variable(!a_is_expected, b_id, a)?;\n-                    return Ok(a);\n-                }\n-\n-                _ => {}\n+\n+        match (a.val, b.val) {\n+            (ConstValue::Infer(InferConst::Var(a_vid)),\n+                ConstValue::Infer(InferConst::Var(b_vid))) => {\n+                infcx.const_unification_table\n+                    .borrow_mut()\n+                    .unify_var_var(a_vid, b_vid)\n+                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n+                return Ok(a);\n+            }\n+\n+            (ConstValue::Infer(InferConst::Var(a_id)), _) => {\n+                self.fields.infcx.unify_const_variable(a_is_expected, a_id, b)?;\n+                return Ok(a);\n             }\n+\n+            (_, ConstValue::Infer(InferConst::Var(b_id))) => {\n+                self.fields.infcx.unify_const_variable(!a_is_expected, b_id, a)?;\n+                return Ok(a);\n+            }\n+\n+            _ => {}\n         }\n \n         self.fields.infcx.super_combine_consts(self, a, b)?;"}, {"sha": "679635bef13e5623436aab23f846427c4ad59306", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -46,7 +46,7 @@ pub struct TypeFreshener<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ty_freshen_count: u32,\n     const_freshen_count: u32,\n     ty_freshen_map: FxHashMap<ty::InferTy, Ty<'tcx>>,\n-    const_freshen_map: FxHashMap<ty::InferConst<'tcx>, &'tcx ty::LazyConst<'tcx>>,\n+    const_freshen_map: FxHashMap<ty::InferConst<'tcx>, &'tcx ty::Const<'tcx>>,\n }\n \n impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n@@ -88,11 +88,11 @@ impl<'a, 'gcx, 'tcx> TypeFreshener<'a, 'gcx, 'tcx> {\n \n     fn freshen_const<F>(\n         &mut self,\n-        opt_ct: Option<&'tcx ty::LazyConst<'tcx>>,\n+        opt_ct: Option<&'tcx ty::Const<'tcx>>,\n         key: ty::InferConst<'tcx>,\n         freshener: F,\n         ty: Ty<'tcx>,\n-    ) -> &'tcx ty::LazyConst<'tcx>\n+    ) -> &'tcx ty::Const<'tcx>\n     where\n         F: FnOnce(u32) -> ty::InferConst<'tcx>,\n     {\n@@ -226,44 +226,43 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n-        if let ty::LazyConst::Evaluated(ty::Const{ val, ty }) = ct {\n-            match val {\n-                ConstValue::Infer(ty::InferConst::Var(v)) => {\n-                    let opt_ct = self.infcx.const_unification_table\n-                        .borrow_mut()\n-                        .probe_value(*v)\n-                        .val\n-                        .known();\n-                    return self.freshen_const(\n-                        opt_ct,\n-                        ty::InferConst::Var(*v),\n-                        ty::InferConst::Fresh,\n-                        ty,\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        match ct.val {\n+            ConstValue::Infer(ty::InferConst::Var(v)) => {\n+                let opt_ct = self.infcx.const_unification_table\n+                    .borrow_mut()\n+                    .probe_value(v)\n+                    .val\n+                    .known();\n+                return self.freshen_const(\n+                    opt_ct,\n+                    ty::InferConst::Var(v),\n+                    ty::InferConst::Fresh,\n+                    ct.ty,\n+                );\n+            }\n+            ConstValue::Infer(ty::InferConst::Fresh(i)) => {\n+                if i >= self.const_freshen_count {\n+                    bug!(\n+                        \"Encountered a freshend const with id {} \\\n+                            but our counter is only at {}\",\n+                        i,\n+                        self.const_freshen_count,\n                     );\n                 }\n-                ConstValue::Infer(ty::InferConst::Fresh(i)) => {\n-                    if *i >= self.const_freshen_count {\n-                        bug!(\n-                            \"Encountered a freshend const with id {} \\\n-                                but our counter is only at {}\",\n-                            i,\n-                            self.const_freshen_count,\n-                        );\n-                    }\n-                    return ct;\n-                }\n-\n-                ConstValue::Infer(ty::InferConst::Canonical(..)) |\n-                ConstValue::Placeholder(_) => {\n-                    bug!(\"unexpected const {:?}\", ct)\n-                }\n+                return ct;\n+            }\n \n-                ConstValue::Param(_) |\n-                ConstValue::Scalar(_) |\n-                ConstValue::Slice(..) |\n-                ConstValue::ByRef(..) => {}\n+            ConstValue::Infer(ty::InferConst::Canonical(..)) |\n+            ConstValue::Placeholder(_) => {\n+                bug!(\"unexpected const {:?}\", ct)\n             }\n+\n+            ConstValue::Param(_) |\n+            ConstValue::Scalar(_) |\n+            ConstValue::Slice(..) |\n+            ConstValue::ByRef(..) |\n+            ConstValue::Unevaluated(..) => {}\n         }\n \n         ct.super_fold_with(self)"}, {"sha": "5a9ba64659edc3173f1d3554611a714f8d1545dc", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -176,11 +176,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for InferenceFudger<'a, 'gcx, 'tcx>\n         r\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n-        if let ty::LazyConst::Evaluated(ty::Const {\n-            val: ConstValue::Infer(ty::InferConst::Var(vid)),\n-            ty,\n-        }) = *ct {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const { val: ConstValue::Infer(ty::InferConst::Var(vid)), ty } = *ct {\n             if self.const_variables.contains(&vid) {\n                 // This variable was created during the\n                 // fudging. Recreate it with a fresh variable"}, {"sha": "63a8f17398a0460bf994dc4e74a6553053dfd12c", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -62,9 +62,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::LazyConst<'tcx>,\n-        b: &'tcx ty::LazyConst<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>> {\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);"}, {"sha": "fcec820cbb92ae844f7e2cdc8de66dc4674e4bb0", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -101,15 +101,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         let fld_c = |bound_var: ty::BoundVar, ty| {\n-            self.tcx.mk_lazy_const(ty::LazyConst::Evaluated(\n+            self.tcx.mk_const(\n                 ty::Const {\n                     val: ConstValue::Placeholder(ty::PlaceholderConst {\n                         universe: next_universe,\n                         name: bound_var,\n                     }),\n                     ty,\n                 }\n-            ))\n+            )\n         };\n \n         let (result, map) = self.tcx.replace_bound_vars(binder, fld_r, fld_t, fld_c);"}, {"sha": "29b319ef8f5ff5ed8086cdb3fa6e129f8a27db36", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -62,9 +62,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::LazyConst<'tcx>,\n-        b: &'tcx ty::LazyConst<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>> {\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);"}, {"sha": "0f603a6c77785fd5e6d4487f2b4d2e87d3dc40f2", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -1004,7 +1004,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n         origin: ConstVariableOrigin\n-    ) -> &'tcx ty::LazyConst<'tcx> {\n+    ) -> &'tcx ty::Const<'tcx> {\n         self.tcx.mk_const_var(self.next_const_var_id(origin), ty)\n     }\n \n@@ -1013,7 +1013,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         origin: ConstVariableOrigin,\n         universe: ty::UniverseIndex,\n-    ) -> &'tcx ty::LazyConst<'tcx> {\n+    ) -> &'tcx ty::Const<'tcx> {\n         let vid = self.const_unification_table\n             .borrow_mut()\n             .new_key(ConstVarValue {\n@@ -1367,7 +1367,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn probe_const_var(\n         &self,\n         vid: ty::ConstVid<'tcx>\n-    ) -> Result<&'tcx ty::LazyConst<'tcx>, ty::UniverseIndex> {\n+    ) -> Result<&'tcx ty::Const<'tcx>, ty::UniverseIndex> {\n         use self::unify_key::ConstVariableValue;\n \n         match self.const_unification_table.borrow_mut().probe_value(vid).val {\n@@ -1378,12 +1378,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn resolve_const_var(\n         &self,\n-        ct: &'tcx ty::LazyConst<'tcx>\n-    ) -> &'tcx ty::LazyConst<'tcx> {\n-        if let ty::LazyConst::Evaluated(ty::Const {\n-            val: ConstValue::Infer(InferConst::Var(v)),\n-            ..\n-        }) = ct {\n+        ct: &'tcx ty::Const<'tcx>\n+    ) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const { val: ConstValue::Infer(InferConst::Var(v)), .. } = ct {\n             self.const_unification_table\n                 .borrow_mut()\n                 .probe_value(*v)\n@@ -1398,13 +1395,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn shallow_resolve_const(\n         &self,\n-        ct: &'tcx ty::LazyConst<'tcx>\n-    ) -> &'tcx ty::LazyConst<'tcx> {\n+        ct: &'tcx ty::Const<'tcx>\n+    ) -> &'tcx ty::Const<'tcx> {\n         match ct {\n-            ty::LazyConst::Evaluated(ty::Const {\n-                val: ConstValue::Infer(InferConst::Var(vid)),\n-                ..\n-            }) => {\n+            ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } => {\n                 self.const_unification_table\n                     .borrow_mut()\n                     .probe_value(*vid)"}, {"sha": "8d3a86a8dc3296d7316fa37fd3b3d92b81986dd2", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -610,13 +610,10 @@ where\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::LazyConst<'tcx>,\n-        b: &'tcx ty::LazyConst<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>> {\n-        if let ty::LazyConst::Evaluated(ty::Const {\n-            val: ConstValue::Infer(InferConst::Canonical(_, _)),\n-            ..\n-        }) = a {\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        if let ty::Const { val: ConstValue::Infer(InferConst::Canonical(_, _)), .. } = a {\n             // FIXME(const_generics): I'm unsure how this branch should actually be handled,\n             // so this is probably not correct.\n             self.infcx.super_combine_consts(self, a, b)\n@@ -983,15 +980,12 @@ where\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::LazyConst<'tcx>,\n-        _: &'tcx ty::LazyConst<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>> {\n+        a: &'tcx ty::Const<'tcx>,\n+        _: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         debug!(\"TypeGeneralizer::consts(a={:?})\", a);\n \n-        if let ty::LazyConst::Evaluated(ty::Const {\n-            val: ConstValue::Infer(InferConst::Canonical(_, _)),\n-            ..\n-        }) = a {\n+        if let ty::Const { val: ConstValue::Infer(InferConst::Canonical(_, _)), .. } = a {\n             bug!(\n                 \"unexpected inference variable encountered in NLL generalization: {:?}\",\n                 a"}, {"sha": "831ed302147ed387a1c0c25e08d6a19a0d9de2a4", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for OpportunisticTypeAndRegionResolv\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if !ct.needs_infer() {\n             ct // micro-optimize -- if there is nothing in this const that this fold affects...\n         } else {\n@@ -210,25 +210,20 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n         }\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         if !c.needs_infer() && !ty::keep_local(&c) {\n             c // micro-optimize -- if there is nothing in this const that this fold affects...\n               // ^ we need to have the `keep_local` check to un-default\n               // defaulted tuples.\n         } else {\n             let c = self.infcx.shallow_resolve_const(c);\n-            match c {\n-                ty::LazyConst::Evaluated(ty::Const { val, .. }) => {\n-                    match val {\n-                        ConstValue::Infer(InferConst::Var(vid)) => {\n-                            self.err = Some(FixupError::UnresolvedConst(*vid));\n-                            return self.tcx().types.ct_err;\n-                        }\n-                        ConstValue::Infer(InferConst::Fresh(_)) => {\n-                            bug!(\"Unexpected const in full const resolver: {:?}\", c);\n-                        }\n-                        _ => {}\n-                    }\n+            match c.val {\n+                ConstValue::Infer(InferConst::Var(vid)) => {\n+                    self.err = Some(FixupError::UnresolvedConst(vid));\n+                    return self.tcx().types.ct_err;\n+                }\n+                ConstValue::Infer(InferConst::Fresh(_)) => {\n+                    bug!(\"Unexpected const in full const resolver: {:?}\", c);\n                 }\n                 _ => {}\n             }"}, {"sha": "f2f36d59cbef6b6bb8d466e45762c98e03beab05", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -137,9 +137,9 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::LazyConst<'tcx>,\n-        b: &'tcx ty::LazyConst<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>> {\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n         if a == b { return Ok(a); }\n \n@@ -150,29 +150,27 @@ impl<'combine, 'infcx, 'gcx, 'tcx> TypeRelation<'infcx, 'gcx, 'tcx>\n         // Consts can only be equal or unequal to each other: there's no subtyping\n         // relation, so we're just going to perform equating here instead.\n         let a_is_expected = self.a_is_expected();\n-        if let (&ty::LazyConst::Evaluated(a_eval), &ty::LazyConst::Evaluated(b_eval)) = (a, b) {\n-            match (a_eval.val, b_eval.val) {\n-                (ConstValue::Infer(InferConst::Var(a_vid)),\n-                 ConstValue::Infer(InferConst::Var(b_vid))) => {\n-                    infcx.const_unification_table\n-                        .borrow_mut()\n-                        .unify_var_var(a_vid, b_vid)\n-                        .map_err(|e| const_unification_error(a_is_expected, e))?;\n-                    return Ok(a);\n-                }\n-\n-                (ConstValue::Infer(InferConst::Var(a_id)), _) => {\n-                    self.fields.infcx.unify_const_variable(a_is_expected, a_id, b)?;\n-                    return Ok(a);\n-                }\n-\n-                (_, ConstValue::Infer(InferConst::Var(b_id))) => {\n-                    self.fields.infcx.unify_const_variable(!a_is_expected, b_id, a)?;\n-                    return Ok(a);\n-                }\n-\n-                _ => {}\n+        match (a.val, b.val) {\n+            (ConstValue::Infer(InferConst::Var(a_vid)),\n+                ConstValue::Infer(InferConst::Var(b_vid))) => {\n+                infcx.const_unification_table\n+                    .borrow_mut()\n+                    .unify_var_var(a_vid, b_vid)\n+                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n+                return Ok(a);\n             }\n+\n+            (ConstValue::Infer(InferConst::Var(a_id)), _) => {\n+                self.fields.infcx.unify_const_variable(a_is_expected, a_id, b)?;\n+                return Ok(a);\n+            }\n+\n+            (_, ConstValue::Infer(InferConst::Var(b_id))) => {\n+                self.fields.infcx.unify_const_variable(!a_is_expected, b_id, a)?;\n+                return Ok(a);\n+            }\n+\n+            _ => {}\n         }\n \n         self.fields.infcx.super_combine_consts(self, a, b)?;"}, {"sha": "9b1b423ef5059d0eaa4fbc825e21fc434296bf6f", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -90,14 +90,14 @@ pub enum ConstVariableOrigin {\n \n #[derive(Copy, Clone, Debug)]\n pub enum ConstVariableValue<'tcx> {\n-    Known { value: &'tcx ty::LazyConst<'tcx> },\n+    Known { value: &'tcx ty::Const<'tcx> },\n     Unknown { universe: ty::UniverseIndex },\n }\n \n impl<'tcx> ConstVariableValue<'tcx> {\n     /// If this value is known, returns the const it is known to be.\n     /// Otherwise, `None`.\n-    pub fn known(&self) -> Option<&'tcx ty::LazyConst<'tcx>> {\n+    pub fn known(&self) -> Option<&'tcx ty::Const<'tcx>> {\n         match *self {\n             ConstVariableValue::Unknown { .. } => None,\n             ConstVariableValue::Known { value } => Some(value),\n@@ -126,15 +126,15 @@ impl<'tcx> UnifyKey for ty::ConstVid<'tcx> {\n }\n \n impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n-    type Error = (&'tcx ty::LazyConst<'tcx>, &'tcx ty::LazyConst<'tcx>);\n+    type Error = (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>);\n \n     fn unify_values(value1: &Self, value2: &Self) -> Result<Self, Self::Error> {\n         let val = match (value1.val, value2.val) {\n             (\n                 ConstVariableValue::Known { value: value1 },\n                 ConstVariableValue::Known { value: value2 }\n             ) => {\n-                match <&'tcx ty::LazyConst<'tcx>>::unify_values(&value1, &value2) {\n+                match <&'tcx ty::Const<'tcx>>::unify_values(&value1, &value2) {\n                     Ok(value) => Ok(ConstVariableValue::Known { value }),\n                     Err(err) => Err(err),\n                 }\n@@ -168,16 +168,13 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n     }\n }\n \n-impl<'tcx> EqUnifyValue for &'tcx ty::LazyConst<'tcx> {}\n+impl<'tcx> EqUnifyValue for &'tcx ty::Const<'tcx> {}\n \n pub fn replace_if_possible(\n     mut table: RefMut<'_, UnificationTable<InPlace<ty::ConstVid<'tcx>>>>,\n-    c: &'tcx ty::LazyConst<'tcx>\n-) -> &'tcx ty::LazyConst<'tcx> {\n-    if let ty::LazyConst::Evaluated(ty::Const {\n-        val: ConstValue::Infer(InferConst::Var(vid)),\n-        ..\n-    }) = c {\n+    c: &'tcx ty::Const<'tcx>\n+) -> &'tcx ty::Const<'tcx> {\n+    if let ty::Const { val: ConstValue::Infer(InferConst::Var(vid)), .. } = c {\n         match table.probe_value(*vid).val.known() {\n             Some(c) => c,\n             None => c,"}, {"sha": "8640216b071ae4783cd27d01c64a2579c28fa532", "filename": "src/librustc/ty/_match.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2F_match.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -81,26 +81,24 @@ impl<'a, 'gcx, 'tcx> TypeRelation<'a, 'gcx, 'tcx> for Match<'a, 'gcx, 'tcx> {\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::LazyConst<'tcx>,\n-        b: &'tcx ty::LazyConst<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>> {\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n         debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n         if a == b {\n             return Ok(a);\n         }\n \n-        if let (&ty::LazyConst::Evaluated(a_eval), &ty::LazyConst::Evaluated(b_eval)) = (a, b) {\n-            match (a_eval.val, b_eval.val) {\n-                (_, ConstValue::Infer(InferConst::Fresh(_))) => {\n-                    return Ok(a);\n-                }\n-\n-                (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n-                    return Err(TypeError::ConstMismatch(relate::expected_found(self, &a, &b)));\n-                }\n+        match (a.val, b.val) {\n+            (_, ConstValue::Infer(InferConst::Fresh(_))) => {\n+                return Ok(a);\n+            }\n \n-                _ => {}\n+            (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n+                return Err(TypeError::ConstMismatch(relate::expected_found(self, &a, &b)));\n             }\n+\n+            _ => {}\n         }\n \n         relate::super_relate_consts(self, a, b)"}, {"sha": "e7b6a0ff4f4b5a485fed92198d24097a67d99c73", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -232,7 +232,7 @@ pub struct CommonLifetimes<'tcx> {\n     pub re_static: Region<'tcx>,\n     pub re_erased: Region<'tcx>,\n \n-    pub ct_err: &'tcx LazyConst<'tcx>,\n+    pub ct_err: &'tcx Const<'tcx>,\n }\n \n pub struct LocalTableInContext<'a, V: 'a> {\n@@ -2683,11 +2683,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self,\n         ic: InferConst<'tcx>,\n         ty: Ty<'tcx>,\n-    ) -> &'tcx LazyConst<'tcx> {\n-        self.mk_lazy_const(LazyConst::Evaluated(ty::Const {\n+    ) -> &'tcx ty::Const<'tcx> {\n+        self.mk_const(ty::Const {\n             val: ConstValue::Infer(ic),\n             ty,\n-        }))\n+        })\n     }\n \n     #[inline]"}, {"sha": "4e4024d5bab43e67ba507a02be7d3b68d825daad", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -45,7 +45,7 @@ pub enum TypeError<'tcx> {\n     ProjectionBoundsLength(ExpectedFound<usize>),\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n \n-    ConstMismatch(ExpectedFound<&'tcx ty::LazyConst<'tcx>>),\n+    ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]"}, {"sha": "dbf9047f775bf2ea738ebd2c64730ef00242e408", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -201,7 +201,7 @@ pub trait TypeVisitor<'tcx> : Sized {\n pub struct BottomUpFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a, F, G, H>\n     where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n           G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n-          H: FnMut(&'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx>,\n+          H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n     pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub ty_op: F,\n@@ -212,7 +212,7 @@ pub struct BottomUpFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a, F, G, H>\n impl<'a, 'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx, 'tcx, F, G, H>\n     where F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n           G: FnMut(ty::Region<'tcx>) -> ty::Region<'tcx>,\n-          H: FnMut(&'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx>,\n+          H: FnMut(&'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx>,\n {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx, F, G, H> TypeFolder<'gcx, 'tcx> for BottomUpFolder<'a, 'gcx\n         (self.lt_op)(r)\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         let ct = ct.super_fold_with(self);\n         (self.ct_op)(ct)\n     }\n@@ -435,7 +435,7 @@ struct BoundVarReplacer<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n \n     fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n     fld_t: &'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a),\n-    fld_c: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::LazyConst<'tcx> + 'a),\n+    fld_c: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx> + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n@@ -447,7 +447,7 @@ impl<'a, 'gcx, 'tcx> BoundVarReplacer<'a, 'gcx, 'tcx> {\n     ) -> Self\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n-              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::LazyConst<'tcx>,\n+              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n     {\n         BoundVarReplacer {\n             tcx,\n@@ -515,11 +515,11 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for BoundVarReplacer<'a, 'gcx, 'tcx>\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n-        if let ty::LazyConst::Evaluated(ty::Const {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const {\n             val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, bound_const)),\n             ty,\n-        }) = *ct {\n+        } = *ct {\n             if debruijn == self.current_index {\n                 let fld_c = &mut self.fld_c;\n                 let ct = fld_c(bound_const, ty);\n@@ -582,7 +582,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n-              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::LazyConst<'tcx>,\n+              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n               T: TypeFoldable<'tcx>,\n     {\n         use rustc_data_structures::fx::FxHashMap;\n@@ -629,7 +629,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ) -> (T, BTreeMap<ty::BoundRegion, ty::Region<'tcx>>)\n         where F: FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n               G: FnMut(ty::BoundTy) -> Ty<'tcx>,\n-              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::LazyConst<'tcx>,\n+              H: FnMut(ty::BoundVar, Ty<'tcx>) -> &'tcx ty::Const<'tcx>,\n               T: TypeFoldable<'tcx>\n     {\n         self.replace_escaping_bound_vars(value.skip_binder(), fld_r, fld_t, fld_c)\n@@ -794,11 +794,11 @@ impl TypeFolder<'gcx, 'tcx> for Shifter<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn fold_const(&mut self, ct: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n-        if let ty::LazyConst::Evaluated(ty::Const {\n+    fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+        if let ty::Const {\n             val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, bound_const)),\n             ty,\n-        }) = *ct {\n+        } = *ct {\n             if self.amount == 0 || debruijn < self.current_index {\n                 ct\n             } else {\n@@ -908,11 +908,11 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n         r.bound_at_or_above_binder(self.outer_index)\n     }\n \n-    fn visit_const(&mut self, ct: &'tcx ty::LazyConst<'tcx>) -> bool {\n-        if let ty::LazyConst::Evaluated(ty::Const {\n+    fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> bool {\n+        if let ty::Const {\n             val: ConstValue::Infer(ty::InferConst::Canonical(debruijn, _)),\n             ..\n-        }) = *ct {\n+        } = *ct {\n             debruijn >= self.outer_index\n         } else {\n             false"}, {"sha": "36da21b71f53676fcd13907d5a33de83be642734", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -96,6 +96,7 @@ mod constness;\n pub mod error;\n mod erase_regions;\n pub mod fast_reject;\n+pub mod flags;\n pub mod fold;\n pub mod inhabitedness;\n pub mod layout;\n@@ -112,7 +113,6 @@ pub mod wf;\n pub mod util;\n \n mod context;\n-mod flags;\n mod instance;\n mod structural_impls;\n mod sty;"}, {"sha": "d2cc2514536102ac335656f51bf21516318dc9b9", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -712,7 +712,7 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             // in order to place the projections inside the `<...>`.\n             if !resugared {\n                 // Use a type that can't appear in defaults of type parameters.\n-                let dummy_self = self.tcx().mk_infer(ty::FreshTy(0));\n+                let dummy_self = self.tcx().mk_ty_infer(ty::FreshTy(0));\n                 let principal = principal.with_self_ty(self.tcx(), dummy_self);\n \n                 let args = self.generic_args_to_print(\n@@ -1481,7 +1481,7 @@ define_print_and_forward_display! {\n \n     ty::ExistentialTraitRef<'tcx> {\n         // Use a type that can't appear in defaults of type parameters.\n-        let dummy_self = cx.tcx().mk_infer(ty::FreshTy(0));\n+        let dummy_self = cx.tcx().mk_ty_infer(ty::FreshTy(0));\n         let trait_ref = self.with_self_ty(cx.tcx(), dummy_self);\n         p!(print(trait_ref))\n     }"}, {"sha": "1ba5a67f7364d336eac4589599f5a7fd51868012", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 51, "deletions": 55, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -7,7 +7,7 @@\n use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use crate::ty::error::{ExpectedFound, TypeError, ConstError};\n+use crate::ty::error::{ExpectedFound, TypeError};\n use crate::mir::interpret::{GlobalId, ConstValue, Scalar};\n use crate::util::common::ErrorReported;\n use syntax_pos::DUMMY_SP;\n@@ -86,9 +86,9 @@ pub trait TypeRelation<'a, 'gcx: 'a+'tcx, 'tcx: 'a> : Sized {\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::LazyConst<'tcx>,\n-        b: &'tcx ty::LazyConst<'tcx>\n-    ) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>>;\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>;\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)\n                   -> RelateResult<'tcx, ty::Binder<T>>\n@@ -124,7 +124,7 @@ impl<'tcx> Relate<'tcx> for ty::TypeAndMut<'tcx> {\n                 ast::Mutability::MutMutable => ty::Invariant,\n             };\n             let ty = relation.relate_with_variance(variance, &a.ty, &b.ty)?;\n-            Ok(ty::TypeAndMut {ty: ty, mutbl: mutbl})\n+            Ok(ty::TypeAndMut { ty, mutbl })\n         }\n     }\n }\n@@ -590,59 +590,55 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n /// it.\n pub fn super_relate_consts<'a, 'gcx, 'tcx, R>(\n     relation: &mut R,\n-    a: &'tcx ty::LazyConst<'tcx>,\n-    b: &'tcx ty::LazyConst<'tcx>\n-) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>>\n+    a: &'tcx ty::Const<'tcx>,\n+    b: &'tcx ty::Const<'tcx>\n+) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n where\n     R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n {\n+    // Only consts whose types are equal should be compared.\n+    assert_eq!(a.ty, b.ty);\n+\n     let tcx = relation.tcx();\n \n-    match (a, b) {\n-        (ty::LazyConst::Evaluated(a_eval), ty::LazyConst::Evaluated(b_eval)) => {\n-            // Only consts whose types are equal should be compared.\n-            assert_eq!(a_eval.ty, b_eval.ty);\n-\n-            // Currently, the values that can be unified are those that\n-            // implement both `PartialEq` and `Eq`, corresponding to\n-            // `structural_match` types.\n-            // FIXME(const_generics): check for `structural_match` synthetic attribute.\n-            match (a_eval.val, b_eval.val) {\n-                (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n-                    // The caller should handle these cases!\n-                    bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n-                }\n-                (ConstValue::Param(a_p), ConstValue::Param(b_p)) if a_p.index == b_p.index => {\n-                    Ok(a)\n-                }\n-                (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n-                    Ok(a)\n-                }\n-                (ConstValue::Scalar(Scalar::Bits { .. }), _) if a == b => {\n-                    Ok(a)\n-                }\n-                (ConstValue::ByRef(..), _) => {\n-                    bug!(\n-                        \"non-Scalar ConstValue encountered in super_relate_consts {:?} {:?}\",\n-                        a,\n-                        b,\n-                    );\n-                }\n-                 _ => {\n-                    Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n-                }\n-            }\n+    // Currently, the values that can be unified are those that\n+    // implement both `PartialEq` and `Eq`, corresponding to\n+    // `structural_match` types.\n+    // FIXME(const_generics): check for `structural_match` synthetic attribute.\n+    match (a.val, b.val) {\n+        (ConstValue::Infer(_), _) | (_, ConstValue::Infer(_)) => {\n+            // The caller should handle these cases!\n+            bug!(\"var types encountered in super_relate_consts: {:?} {:?}\", a, b)\n         }\n-        // FIXME(const_generics): this is probably wrong (regarding TyProjection)\n-        (\n-            ty::LazyConst::Unevaluated(a_def_id, a_substs),\n-            ty::LazyConst::Unevaluated(b_def_id, b_substs),\n-        ) if a_def_id == b_def_id => {\n-            let substs =\n-                relation.relate_with_variance(ty::Variance::Invariant, a_substs, b_substs)?;\n-            Ok(tcx.mk_lazy_const(ty::LazyConst::Unevaluated(*a_def_id, substs)))\n+        (ConstValue::Param(a_p), ConstValue::Param(b_p)) if a_p.index == b_p.index => {\n+            Ok(a)\n+        }\n+        (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n+            Ok(a)\n+        }\n+        (ConstValue::Scalar(Scalar::Bits { .. }), _) if a == b => {\n+            Ok(a)\n         }\n-        _ => {\n+        (ConstValue::ByRef(..), _) => {\n+            bug!(\n+                \"non-Scalar ConstValue encountered in super_relate_consts {:?} {:?}\",\n+                a,\n+                b,\n+            );\n+        }\n+\n+        // FIXME(const_generics): this is wrong, as it is a projection\n+        (ConstValue::Unevaluated(a_def_id, a_substs),\n+            ConstValue::Unevaluated(b_def_id, b_substs)) if a_def_id == b_def_id => {\n+                let substs =\n+                    relation.relate_with_variance(ty::Variance::Invariant, &a_substs, &b_substs)?;\n+                Ok(tcx.mk_const(ty::Const {\n+                    val: ConstValue::Unevaluated(a_def_id, &substs),\n+                    ty: a.ty,\n+                })\n+            }\n+\n+            _ => {\n             Err(TypeError::ConstMismatch(expected_found(relation, &a, &b)))\n         }\n     }\n@@ -719,11 +715,11 @@ impl<'tcx> Relate<'tcx> for ty::Region<'tcx> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for &'tcx ty::LazyConst<'tcx> {\n+impl<'tcx> Relate<'tcx> for &'tcx ty::Const<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &&'tcx ty::LazyConst<'tcx>,\n-                           b: &&'tcx ty::LazyConst<'tcx>)\n-                           -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>>\n+                           a: &&'tcx ty::Const<'tcx>,\n+                           b: &&'tcx ty::Const<'tcx>)\n+                           -> RelateResult<'tcx, &'tcx ty::Const<'tcx>>\n         where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n     {\n         relation.consts(*a, *b)"}, {"sha": "6bc62364b43fd55eb0a20eab6d096bf60721bfae", "filename": "src/librustc_traits/chalk_context/resolvent_ops.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fresolvent_ops.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -279,13 +279,13 @@ impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n \n     fn consts(\n         &mut self,\n-        a: &'tcx ty::LazyConst<'tcx>,\n-        b: &'tcx ty::LazyConst<'tcx>,\n-    ) -> RelateResult<'tcx, &'tcx ty::LazyConst<'tcx>> {\n-        if let ty::LazyConst::Evaluated(ty::Const {\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        if let ty::Const {\n             val: ConstValue::Infer(InferConst::Canonical(debruijn, bound_ct)),\n             ..\n-        }) = a {\n+        } = a {\n             if *debruijn == self.binder_index {\n                 self.unify_free_answer_var(*bound_ct, b.into())?;\n                 return Ok(b);\n@@ -294,14 +294,14 @@ impl TypeRelation<'cx, 'gcx, 'tcx> for AnswerSubstitutor<'cx, 'gcx, 'tcx> {\n \n         match (a, b) {\n             (\n-                ty::LazyConst::Evaluated(ty::Const {\n+                ty::Const {\n                     val: ConstValue::Infer(InferConst::Canonical(a_debruijn, a_bound)),\n                     ..\n-                }),\n-                ty::LazyConst::Evaluated(ty::Const {\n+                },\n+                ty::Const {\n                     val: ConstValue::Infer(InferConst::Canonical(b_debruijn, b_bound)),\n                     ..\n-                }),\n+                },\n             ) => {\n                 assert_eq!(a_debruijn, b_debruijn);\n                 assert_eq!(a_bound, b_bound);"}, {"sha": "f56ef1a0d0c4e09da16848fddf0a0c963d99f653", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=fc16b0a1476bdd1aa8fafd69dc841b5f539bc94e", "patch": "@@ -11,7 +11,7 @@ use rustc::infer::InferCtxt;\n use rustc::ty::adjustment::{Adjust, Adjustment, PointerCast};\n use rustc::ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use rustc::ty::subst::UnpackedKind;\n-use rustc::ty::{self, Ty, TyCtxt, Const, LazyConst};\n+use rustc::ty::{self, Ty, TyCtxt, Const};\n use rustc::mir::interpret::ConstValue;\n use rustc::util::nodemap::DefIdSet;\n use rustc_data_structures::sync::Lrc;\n@@ -567,36 +567,34 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     },\n                     ct_op: |ct| {\n                         trace!(\"checking const {:?}\", ct);\n-                        // find a const parameter\n-                        if let LazyConst::Evaluated(Const { ty, val }) = ct {\n-                            if let ConstValue::Param(..) = val {\n-                                // look it up in the substitution list\n-                                assert_eq!(opaque_defn.substs.len(), generics.params.len());\n-                                for (subst, param) in opaque_defn.substs.iter()\n-                                                                        .zip(&generics.params) {\n-                                    if let UnpackedKind::Const(subst) = subst.unpack() {\n-                                        if subst == ct {\n-                                            // found it in the substitution list, replace with the\n-                                            // parameter from the existential type\n-                                            return self.tcx()\n-                                                .global_tcx()\n-                                                .mk_const_param(param.index, param.name, ty);\n-                                        }\n+                        // Find a const parameter\n+                        if let ConstValue::Param(..) = ct.val {\n+                            // look it up in the substitution list\n+                            assert_eq!(opaque_defn.substs.len(), generics.params.len());\n+                            for (subst, param) in opaque_defn.substs.iter()\n+                                                                    .zip(&generics.params) {\n+                                if let UnpackedKind::Const(subst) = subst.unpack() {\n+                                    if subst == ct {\n+                                        // found it in the substitution list, replace with the\n+                                        // parameter from the existential type\n+                                        return self.tcx()\n+                                            .global_tcx()\n+                                            .mk_const_param(param.index, param.name, ty);\n                                     }\n                                 }\n-                                self.tcx()\n-                                    .sess\n-                                    .struct_span_err(\n-                                        span,\n-                                        &format!(\n-                                            \"const parameter `{}` is part of concrete type but not \\\n-                                             used in parameter list for existential type\",\n-                                            ct,\n-                                        ),\n-                                    )\n-                                    .emit();\n-                                return self.tcx().types.ct_err;\n                             }\n+                            self.tcx()\n+                                .sess\n+                                .struct_span_err(\n+                                    span,\n+                                    &format!(\n+                                        \"const parameter `{}` is part of concrete type but not \\\n+                                            used in parameter list for existential type\",\n+                                        ct,\n+                                    ),\n+                                )\n+                                .emit();\n+                            return self.tcx().types.ct_err;\n                         }\n                         ct\n                     }"}]}