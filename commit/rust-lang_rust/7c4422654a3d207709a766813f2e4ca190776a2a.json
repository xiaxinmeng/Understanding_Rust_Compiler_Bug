{"sha": "7c4422654a3d207709a766813f2e4ca190776a2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjNDQyMjY1NGEzZDIwNzcwOWE3NjY4MTNmMmU0Y2ExOTA3NzZhMmE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-06T09:42:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-06T09:55:31Z"}, "message": "convert throw_validation_failure macro to same syntax as try_validation", "tree": {"sha": "6b2cbfe3aff33f3b8493ea673bf85c969c4d03f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b2cbfe3aff33f3b8493ea673bf85c969c4d03f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c4422654a3d207709a766813f2e4ca190776a2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c4422654a3d207709a766813f2e4ca190776a2a", "html_url": "https://github.com/rust-lang/rust/commit/7c4422654a3d207709a766813f2e4ca190776a2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c4422654a3d207709a766813f2e4ca190776a2a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "441419a9237ca3ffeb8bcaca9f3c406991c2fa75", "url": "https://api.github.com/repos/rust-lang/rust/commits/441419a9237ca3ffeb8bcaca9f3c406991c2fa75", "html_url": "https://github.com/rust-lang/rust/commit/441419a9237ca3ffeb8bcaca9f3c406991c2fa75"}], "stats": {"total": 107, "additions": 51, "deletions": 56}, "files": [{"sha": "143447ee566bdabfc4f6a38f12cac52d67bcda40", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/7c4422654a3d207709a766813f2e4ca190776a2a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c4422654a3d207709a766813f2e4ca190776a2a/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=7c4422654a3d207709a766813f2e4ca190776a2a", "patch": "@@ -25,14 +25,19 @@ use super::{\n };\n \n macro_rules! throw_validation_failure {\n-    ($what:expr, $where:expr $(, $expected:expr )?) => {{\n-        let mut msg = format!(\"encountered {}\", $what);\n+    ($where:expr, { $( $what_fmt:expr ),+ } $( expected { $( $expected_fmt:expr ),+ } )?) => {{\n+        let mut msg = String::new();\n+        msg.push_str(\"encountered \");\n+        write!(&mut msg, $($what_fmt),+).unwrap();\n         let where_ = &$where;\n         if !where_.is_empty() {\n             msg.push_str(\" at \");\n             write_path(&mut msg, where_);\n         }\n-        $( write!(&mut msg, \", but expected {}\", $expected).unwrap(); )?\n+        $(\n+            msg.push_str(\", but expected \");\n+            write!(&mut msg, $($expected_fmt),+).unwrap();\n+        )?\n         throw_ub!(ValidationFailure(msg))\n     }};\n }\n@@ -76,9 +81,8 @@ macro_rules! try_validation {\n             // allocation here as this can only slow down builds that fail anyway.\n             $( Err(InterpErrorInfo { kind: $p, .. }) )|+ =>\n                 throw_validation_failure!(\n-                    format_args!($( $what_fmt ),+),\n-                    $where\n-                    $(, format_args!($( $expected_fmt ),+))?\n+                    $where,\n+                    { $( $what_fmt ),+ } $( expected { $( $expected_fmt ),+ } )?\n                 ),\n             #[allow(unreachable_patterns)]\n             Err(e) => Err::<!, _>(e)?,\n@@ -366,9 +370,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let size_and_align = match self.ecx.size_and_align_of(place.meta, place.layout) {\n             Ok(res) => res,\n             Err(err) => match err.kind {\n-                err_ub!(InvalidMeta(msg)) => throw_validation_failure!(\n-                    format_args!(\"invalid {} metadata: {}\", kind, msg),\n-                    self.path\n+                err_ub!(InvalidMeta(msg)) => throw_validation_failure!(self.path,\n+                    { \"invalid {} metadata: {}\", kind, msg }\n                 ),\n                 _ => bug!(\"unexpected error during ptr size_and_align_of: {}\", err),\n             },\n@@ -393,37 +396,32 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 );\n                 match err.kind {\n                     err_ub!(DanglingIntPointer(0, _)) => {\n-                        throw_validation_failure!(format_args!(\"a NULL {}\", kind), self.path)\n+                        throw_validation_failure!(self.path,\n+                            { \"a NULL {}\", kind }\n+                        )\n                     }\n-                    err_ub!(DanglingIntPointer(i, _)) => throw_validation_failure!(\n-                        format_args!(\"a {} to unallocated address {}\", kind, i),\n-                        self.path\n+                    err_ub!(DanglingIntPointer(i, _)) => throw_validation_failure!(self.path,\n+                        { \"a {} to unallocated address {}\", kind, i }\n                     ),\n                     err_ub!(AlignmentCheckFailed { required, has }) => throw_validation_failure!(\n-                        format_args!(\n+                        self.path,\n+                        {\n                             \"an unaligned {} (required {} byte alignment but found {})\",\n                             kind,\n                             required.bytes(),\n                             has.bytes()\n-                        ),\n-                        self.path\n+                        }\n                     ),\n-                    err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(\n-                        format_args!(\"a dangling {} (created from integer)\", kind),\n-                        self.path\n+                    err_unsup!(ReadBytesAsPointer) => throw_validation_failure!(self.path,\n+                        { \"a dangling {} (created from integer)\", kind }\n                     ),\n-                    err_ub!(PointerOutOfBounds { .. }) => throw_validation_failure!(\n-                        format_args!(\n-                            \"a dangling {} (going beyond the bounds of its allocation)\",\n-                            kind\n-                        ),\n-                        self.path\n+                    err_ub!(PointerOutOfBounds { .. }) => throw_validation_failure!(self.path,\n+                        { \"a dangling {} (going beyond the bounds of its allocation)\", kind }\n                     ),\n                     // This cannot happen during const-eval (because interning already detects\n                     // dangling pointers), but it can happen in Miri.\n-                    err_ub!(PointerUseAfterFree(_)) => throw_validation_failure!(\n-                        format_args!(\"a dangling {} (use-after-free)\", kind),\n-                        self.path\n+                    err_ub!(PointerUseAfterFree(_)) => throw_validation_failure!(self.path,\n+                        { \"a dangling {} (use-after-free)\", kind }\n                     ),\n                     _ => bug!(\"Unexpected error during ptr inbounds test: {}\", err),\n                 }\n@@ -443,9 +441,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     // We also need to do it here instead of going on to avoid running\n                     // into the `before_access_global` check during validation.\n                     if !self.may_ref_to_static && self.ecx.tcx.is_static(did) {\n-                        throw_validation_failure!(\n-                            format_args!(\"a {} pointing to a static variable\", kind),\n-                            self.path\n+                        throw_validation_failure!(self.path,\n+                            { \"a {} pointing to a static variable\", kind }\n                         );\n                     }\n                     // `extern static` cannot be validated as they have no body.\n@@ -516,10 +513,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                     // Integers/floats in CTFE: Must be scalar bits, pointers are dangerous\n                     let is_bits = value.not_undef().map_or(false, |v| v.is_bits());\n                     if !is_bits {\n-                        throw_validation_failure!(\n-                            value,\n-                            self.path,\n-                            \"initialized plain (non-pointer) bytes\"\n+                        throw_validation_failure!(self.path,\n+                            { \"{}\", value } expected { \"initialized plain (non-pointer) bytes\" }\n                         )\n                     }\n                 } else {\n@@ -563,7 +558,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // FIXME: Check if the signature matches\n                 Ok(true)\n             }\n-            ty::Never => throw_validation_failure!(\"a value of the never type `!`\", self.path),\n+            ty::Never => throw_validation_failure!(self.path, { \"a value of the never type `!`\" }),\n             ty::Foreign(..) | ty::FnDef(..) => {\n                 // Nothing to check.\n                 Ok(true)\n@@ -622,26 +617,24 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 if lo == 1 && hi == max_hi {\n                     // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n-                        throw_validation_failure!(\n-                            \"a potentially NULL pointer\",\n-                            self.path,\n-                            format_args!(\n+                        throw_validation_failure!(self.path,\n+                            { \"a potentially NULL pointer\" }\n+                            expected {\n                                 \"something that cannot possibly fail to be {}\",\n                                 wrapping_range_format(valid_range, max_hi)\n-                            )\n+                            }\n                         )\n                     }\n                     return Ok(());\n                 } else {\n                     // Conservatively, we reject, because the pointer *could* have a bad\n                     // value.\n-                    throw_validation_failure!(\n-                        \"a pointer\",\n-                        self.path,\n-                        format_args!(\n+                    throw_validation_failure!(self.path,\n+                        { \"a pointer\" }\n+                        expected {\n                             \"something that cannot possibly fail to be {}\",\n                             wrapping_range_format(valid_range, max_hi)\n-                        )\n+                        }\n                     )\n                 }\n             }\n@@ -651,10 +644,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if wrapping_range_contains(&valid_range, bits) {\n             Ok(())\n         } else {\n-            throw_validation_failure!(\n-                bits,\n-                self.path,\n-                format_args!(\"something {}\", wrapping_range_format(valid_range, max_hi))\n+            throw_validation_failure!(self.path,\n+                { \"{}\", bits }\n+                expected { \"something {}\", wrapping_range_format(valid_range, max_hi) }\n             )\n         }\n     }\n@@ -722,10 +714,14 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             Ok(()) => {}\n             Err(err) => match err.kind {\n                 err_ub!(InvalidDiscriminant(val)) => {\n-                    throw_validation_failure!(val, self.path, \"a valid enum discriminant\")\n+                    throw_validation_failure!(self.path,\n+                        { \"{}\", val } expected { \"a valid enum discriminant\" }\n+                    )\n                 }\n                 err_unsup!(ReadPointerAsBytes) => {\n-                    throw_validation_failure!(\"a pointer\", self.path, \"plain (non-pointer) bytes\")\n+                    throw_validation_failure!(self.path,\n+                        { \"a pointer\" } expected { \"plain (non-pointer) bytes\" }\n+                    )\n                 }\n                 // Propagate upwards (that will also check for unexpected errors).\n                 _ => return Err(err),\n@@ -744,9 +740,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // MyNewtype and then the scalar in there).\n         match op.layout.abi {\n             Abi::Uninhabited => {\n-                throw_validation_failure!(\n-                    format_args!(\"a value of uninhabited type {:?}\", op.layout.ty),\n-                    self.path\n+                throw_validation_failure!(self.path,\n+                    { \"a value of uninhabited type {:?}\", op.layout.ty }\n                 );\n             }\n             Abi::Scalar(ref scalar_layout) => {\n@@ -840,7 +835,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                                     .unwrap();\n                                 self.path.push(PathElem::ArrayElem(i));\n \n-                                throw_validation_failure!(\"uninitialized bytes\", self.path)\n+                                throw_validation_failure!(self.path, { \"uninitialized bytes\" })\n                             }\n                             // Propagate upwards (that will also check for unexpected errors).\n                             _ => return Err(err),"}]}