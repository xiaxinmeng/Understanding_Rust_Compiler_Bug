{"sha": "95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1ZjgzMTA1MTQyMzhmYzJjM2I0ZDFkZGVjYmQxYjc5ZDJjOTYzYTI=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-06-30T05:55:20Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-01T06:50:45Z"}, "message": "Structured search debugging", "tree": {"sha": "fae3a79e0597e8d26bbb2d7e1200ecfa594e082b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fae3a79e0597e8d26bbb2d7e1200ecfa594e082b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "html_url": "https://github.com/rust-lang/rust/commit/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1a2d016450c96581c9cc70cc464f8aab2e5c0f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1a2d016450c96581c9cc70cc464f8aab2e5c0f3", "html_url": "https://github.com/rust-lang/rust/commit/b1a2d016450c96581c9cc70cc464f8aab2e5c0f3"}], "stats": {"total": 448, "additions": 285, "deletions": 163}, "files": [{"sha": "422e15ee6af028544e91680c7d81308d2afbf606", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 157, "deletions": 5, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "patch": "@@ -9,10 +9,11 @@ mod replacing;\n #[cfg(test)]\n mod tests;\n \n-use crate::matching::Match;\n+pub use crate::matching::Match;\n+use crate::matching::{record_match_fails_reasons_scope, MatchFailureReason};\n use hir::Semantics;\n use ra_db::{FileId, FileRange};\n-use ra_syntax::{ast, AstNode, SmolStr, SyntaxNode};\n+use ra_syntax::{ast, AstNode, SmolStr, SyntaxKind, SyntaxNode, TextRange};\n use ra_text_edit::TextEdit;\n use rustc_hash::FxHashMap;\n \n@@ -26,7 +27,7 @@ pub struct SsrRule {\n }\n \n #[derive(Debug)]\n-struct SsrPattern {\n+pub struct SsrPattern {\n     raw: parsing::RawSearchPattern,\n     /// Placeholders keyed by the stand-in ident that we use in Rust source code.\n     placeholders_by_stand_in: FxHashMap<SmolStr, parsing::Placeholder>,\n@@ -45,7 +46,7 @@ pub struct SsrError(String);\n \n #[derive(Debug, Default)]\n pub struct SsrMatches {\n-    matches: Vec<Match>,\n+    pub matches: Vec<Match>,\n }\n \n /// Searches a crate for pattern matches and possibly replaces them with something else.\n@@ -64,6 +65,12 @@ impl<'db> MatchFinder<'db> {\n         self.rules.push(rule);\n     }\n \n+    /// Adds a search pattern. For use if you intend to only call `find_matches_in_file`. If you\n+    /// intend to do replacement, use `add_rule` instead.\n+    pub fn add_search_pattern(&mut self, pattern: SsrPattern) {\n+        self.add_rule(SsrRule { pattern, template: \"()\".parse().unwrap() })\n+    }\n+\n     pub fn edits_for_file(&self, file_id: FileId) -> Option<TextEdit> {\n         let matches = self.find_matches_in_file(file_id);\n         if matches.matches.is_empty() {\n@@ -74,14 +81,40 @@ impl<'db> MatchFinder<'db> {\n         }\n     }\n \n-    fn find_matches_in_file(&self, file_id: FileId) -> SsrMatches {\n+    pub fn find_matches_in_file(&self, file_id: FileId) -> SsrMatches {\n         let file = self.sema.parse(file_id);\n         let code = file.syntax();\n         let mut matches = SsrMatches::default();\n         self.find_matches(code, &None, &mut matches);\n         matches\n     }\n \n+    /// Finds all nodes in `file_id` whose text is exactly equal to `snippet` and attempts to match\n+    /// them, while recording reasons why they don't match. This API is useful for command\n+    /// line-based debugging where providing a range is difficult.\n+    pub fn debug_where_text_equal(&self, file_id: FileId, snippet: &str) -> Vec<MatchDebugInfo> {\n+        use ra_db::SourceDatabaseExt;\n+        let file = self.sema.parse(file_id);\n+        let mut res = Vec::new();\n+        let file_text = self.sema.db.file_text(file_id);\n+        let mut remaining_text = file_text.as_str();\n+        let mut base = 0;\n+        let len = snippet.len() as u32;\n+        while let Some(offset) = remaining_text.find(snippet) {\n+            let start = base + offset as u32;\n+            let end = start + len;\n+            self.output_debug_for_nodes_at_range(\n+                file.syntax(),\n+                FileRange { file_id, range: TextRange::new(start.into(), end.into()) },\n+                &None,\n+                &mut res,\n+            );\n+            remaining_text = &remaining_text[offset + snippet.len()..];\n+            base = end;\n+        }\n+        res\n+    }\n+\n     fn find_matches(\n         &self,\n         code: &SyntaxNode,\n@@ -128,6 +161,59 @@ impl<'db> MatchFinder<'db> {\n             self.find_matches(&child, restrict_range, matches_out);\n         }\n     }\n+\n+    fn output_debug_for_nodes_at_range(\n+        &self,\n+        node: &SyntaxNode,\n+        range: FileRange,\n+        restrict_range: &Option<FileRange>,\n+        out: &mut Vec<MatchDebugInfo>,\n+    ) {\n+        for node in node.children() {\n+            let node_range = self.sema.original_range(&node);\n+            if node_range.file_id != range.file_id || !node_range.range.contains_range(range.range)\n+            {\n+                continue;\n+            }\n+            if node_range.range == range.range {\n+                for rule in &self.rules {\n+                    let pattern =\n+                        rule.pattern.tree_for_kind_with_reason(node.kind()).map(|p| p.clone());\n+                    out.push(MatchDebugInfo {\n+                        matched: matching::get_match(true, rule, &node, restrict_range, &self.sema)\n+                            .map_err(|e| MatchFailureReason {\n+                                reason: e.reason.unwrap_or_else(|| {\n+                                    \"Match failed, but no reason was given\".to_owned()\n+                                }),\n+                            }),\n+                        pattern,\n+                        node: node.clone(),\n+                    });\n+                }\n+            } else if let Some(macro_call) = ast::MacroCall::cast(node.clone()) {\n+                if let Some(expanded) = self.sema.expand(&macro_call) {\n+                    if let Some(tt) = macro_call.token_tree() {\n+                        self.output_debug_for_nodes_at_range(\n+                            &expanded,\n+                            range,\n+                            &Some(self.sema.original_range(tt.syntax())),\n+                            out,\n+                        );\n+                    }\n+                }\n+            } else {\n+                self.output_debug_for_nodes_at_range(&node, range, restrict_range, out);\n+            }\n+        }\n+    }\n+}\n+\n+pub struct MatchDebugInfo {\n+    node: SyntaxNode,\n+    /// Our search pattern parsed as the same kind of syntax node as `node`. e.g. expression, item,\n+    /// etc. Will be absent if the pattern can't be parsed as that kind.\n+    pattern: Result<SyntaxNode, MatchFailureReason>,\n+    matched: Result<Match, MatchFailureReason>,\n }\n \n impl std::fmt::Display for SsrError {\n@@ -136,4 +222,70 @@ impl std::fmt::Display for SsrError {\n     }\n }\n \n+impl std::fmt::Debug for MatchDebugInfo {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"========= PATTERN ==========\\n\")?;\n+        match &self.pattern {\n+            Ok(pattern) => {\n+                write!(f, \"{:#?}\", pattern)?;\n+            }\n+            Err(err) => {\n+                write!(f, \"{}\", err.reason)?;\n+            }\n+        }\n+        write!(\n+            f,\n+            \"\\n============ AST ===========\\n\\\n+            {:#?}\\n============================\\n\",\n+            self.node\n+        )?;\n+        match &self.matched {\n+            Ok(_) => write!(f, \"Node matched\")?,\n+            Err(reason) => write!(f, \"Node failed to match because: {}\", reason.reason)?,\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl SsrPattern {\n+    fn tree_for_kind_with_reason(\n+        &self,\n+        kind: SyntaxKind,\n+    ) -> Result<&SyntaxNode, MatchFailureReason> {\n+        record_match_fails_reasons_scope(true, || self.tree_for_kind(kind))\n+            .map_err(|e| MatchFailureReason { reason: e.reason.unwrap() })\n+    }\n+}\n+\n+impl SsrMatches {\n+    /// Returns `self` with any nested matches removed and made into top-level matches.\n+    pub fn flattened(self) -> SsrMatches {\n+        let mut out = SsrMatches::default();\n+        self.flatten_into(&mut out);\n+        out\n+    }\n+\n+    fn flatten_into(self, out: &mut SsrMatches) {\n+        for mut m in self.matches {\n+            for p in m.placeholder_values.values_mut() {\n+                std::mem::replace(&mut p.inner_matches, SsrMatches::default()).flatten_into(out);\n+            }\n+            out.matches.push(m);\n+        }\n+    }\n+}\n+\n+impl Match {\n+    pub fn matched_text(&self) -> String {\n+        self.matched_node.text().to_string()\n+    }\n+}\n+\n impl std::error::Error for SsrError {}\n+\n+#[cfg(test)]\n+impl MatchDebugInfo {\n+    pub(crate) fn match_failure_reason(&self) -> Option<&str> {\n+        self.matched.as_ref().err().map(|r| r.reason.as_str())\n+    }\n+}"}, {"sha": "53d802e77527e5646b5ca370a1fa1fbf5f50a44b", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "patch": "@@ -8,9 +8,7 @@ use crate::{\n use hir::Semantics;\n use ra_db::FileRange;\n use ra_syntax::ast::{AstNode, AstToken};\n-use ra_syntax::{\n-    ast, SyntaxElement, SyntaxElementChildren, SyntaxKind, SyntaxNode, SyntaxToken, TextRange,\n-};\n+use ra_syntax::{ast, SyntaxElement, SyntaxElementChildren, SyntaxKind, SyntaxNode, SyntaxToken};\n use rustc_hash::FxHashMap;\n use std::{cell::Cell, iter::Peekable};\n \n@@ -44,8 +42,8 @@ macro_rules! fail_match {\n \n /// Information about a match that was found.\n #[derive(Debug)]\n-pub(crate) struct Match {\n-    pub(crate) range: TextRange,\n+pub struct Match {\n+    pub(crate) range: FileRange,\n     pub(crate) matched_node: SyntaxNode,\n     pub(crate) placeholder_values: FxHashMap<Var, PlaceholderMatch>,\n     pub(crate) ignored_comments: Vec<ast::Comment>,\n@@ -135,7 +133,7 @@ impl<'db, 'sema> MatchState<'db, 'sema> {\n         match_state.attempt_match_node(&match_inputs, &pattern_tree, code)?;\n         match_state.validate_range(&sema.original_range(code))?;\n         match_state.match_out = Some(Match {\n-            range: sema.original_range(code).range,\n+            range: sema.original_range(code),\n             matched_node: code.clone(),\n             placeholder_values: FxHashMap::default(),\n             ignored_comments: Vec::new(),"}, {"sha": "e43cc51674dd7a7d2183f8cc1bde300c1d8b7a7d", "filename": "crates/ra_ssr/src/replacing.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Fra_ssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Freplacing.rs?ref=95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "patch": "@@ -21,8 +21,10 @@ fn matches_to_edit_at_offset(\n ) -> TextEdit {\n     let mut edit_builder = ra_text_edit::TextEditBuilder::default();\n     for m in &matches.matches {\n-        edit_builder\n-            .replace(m.range.checked_sub(relative_start).unwrap(), render_replace(m, file_src));\n+        edit_builder.replace(\n+            m.range.range.checked_sub(relative_start).unwrap(),\n+            render_replace(m, file_src),\n+        );\n     }\n     edit_builder.finish()\n }"}, {"sha": "c692c97e2e7ec7b89bf575d6bf3507a3659f5e27", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 42, "deletions": 147, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "patch": "@@ -1,150 +1,5 @@\n-use crate::matching::MatchFailureReason;\n-use crate::{matching, Match, MatchFinder, SsrMatches, SsrPattern, SsrRule};\n-use matching::record_match_fails_reasons_scope;\n-use ra_db::{FileId, FileRange, SourceDatabaseExt};\n-use ra_syntax::ast::AstNode;\n-use ra_syntax::{ast, SyntaxKind, SyntaxNode, TextRange};\n-\n-struct MatchDebugInfo {\n-    node: SyntaxNode,\n-    /// Our search pattern parsed as the same kind of syntax node as `node`. e.g. expression, item,\n-    /// etc. Will be absent if the pattern can't be parsed as that kind.\n-    pattern: Result<SyntaxNode, MatchFailureReason>,\n-    matched: Result<Match, MatchFailureReason>,\n-}\n-\n-impl SsrPattern {\n-    pub(crate) fn tree_for_kind_with_reason(\n-        &self,\n-        kind: SyntaxKind,\n-    ) -> Result<&SyntaxNode, MatchFailureReason> {\n-        record_match_fails_reasons_scope(true, || self.tree_for_kind(kind))\n-            .map_err(|e| MatchFailureReason { reason: e.reason.unwrap() })\n-    }\n-}\n-\n-impl std::fmt::Debug for MatchDebugInfo {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"========= PATTERN ==========\\n\")?;\n-        match &self.pattern {\n-            Ok(pattern) => {\n-                write!(f, \"{:#?}\", pattern)?;\n-            }\n-            Err(err) => {\n-                write!(f, \"{}\", err.reason)?;\n-            }\n-        }\n-        write!(\n-            f,\n-            \"\\n============ AST ===========\\n\\\n-            {:#?}\\n============================\",\n-            self.node\n-        )?;\n-        match &self.matched {\n-            Ok(_) => write!(f, \"Node matched\")?,\n-            Err(reason) => write!(f, \"Node failed to match because: {}\", reason.reason)?,\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl SsrMatches {\n-    /// Returns `self` with any nested matches removed and made into top-level matches.\n-    pub(crate) fn flattened(self) -> SsrMatches {\n-        let mut out = SsrMatches::default();\n-        self.flatten_into(&mut out);\n-        out\n-    }\n-\n-    fn flatten_into(self, out: &mut SsrMatches) {\n-        for mut m in self.matches {\n-            for p in m.placeholder_values.values_mut() {\n-                std::mem::replace(&mut p.inner_matches, SsrMatches::default()).flatten_into(out);\n-            }\n-            out.matches.push(m);\n-        }\n-    }\n-}\n-\n-impl Match {\n-    pub(crate) fn matched_text(&self) -> String {\n-        self.matched_node.text().to_string()\n-    }\n-}\n-\n-impl<'db> MatchFinder<'db> {\n-    /// Adds a search pattern. For use if you intend to only call `find_matches_in_file`. If you\n-    /// intend to do replacement, use `add_rule` instead.\n-    fn add_search_pattern(&mut self, pattern: SsrPattern) {\n-        self.add_rule(SsrRule { pattern, template: \"()\".parse().unwrap() })\n-    }\n-\n-    /// Finds all nodes in `file_id` whose text is exactly equal to `snippet` and attempts to match\n-    /// them, while recording reasons why they don't match. This API is useful for command\n-    /// line-based debugging where providing a range is difficult.\n-    fn debug_where_text_equal(&self, file_id: FileId, snippet: &str) -> Vec<MatchDebugInfo> {\n-        let file = self.sema.parse(file_id);\n-        let mut res = Vec::new();\n-        let file_text = self.sema.db.file_text(file_id);\n-        let mut remaining_text = file_text.as_str();\n-        let mut base = 0;\n-        let len = snippet.len() as u32;\n-        while let Some(offset) = remaining_text.find(snippet) {\n-            let start = base + offset as u32;\n-            let end = start + len;\n-            self.output_debug_for_nodes_at_range(\n-                file.syntax(),\n-                TextRange::new(start.into(), end.into()),\n-                &None,\n-                &mut res,\n-            );\n-            remaining_text = &remaining_text[offset + snippet.len()..];\n-            base = end;\n-        }\n-        res\n-    }\n-\n-    fn output_debug_for_nodes_at_range(\n-        &self,\n-        node: &SyntaxNode,\n-        range: TextRange,\n-        restrict_range: &Option<FileRange>,\n-        out: &mut Vec<MatchDebugInfo>,\n-    ) {\n-        for node in node.children() {\n-            if !node.text_range().contains_range(range) {\n-                continue;\n-            }\n-            if node.text_range() == range {\n-                for rule in &self.rules {\n-                    let pattern =\n-                        rule.pattern.tree_for_kind_with_reason(node.kind()).map(|p| p.clone());\n-                    out.push(MatchDebugInfo {\n-                        matched: matching::get_match(true, rule, &node, restrict_range, &self.sema)\n-                            .map_err(|e| MatchFailureReason {\n-                                reason: e.reason.unwrap_or_else(|| {\n-                                    \"Match failed, but no reason was given\".to_owned()\n-                                }),\n-                            }),\n-                        pattern,\n-                        node: node.clone(),\n-                    });\n-                }\n-            } else if let Some(macro_call) = ast::MacroCall::cast(node.clone()) {\n-                if let Some(expanded) = self.sema.expand(&macro_call) {\n-                    if let Some(tt) = macro_call.token_tree() {\n-                        self.output_debug_for_nodes_at_range(\n-                            &expanded,\n-                            range,\n-                            &Some(self.sema.original_range(tt.syntax())),\n-                            out,\n-                        );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n+use crate::{MatchFinder, SsrRule};\n+use ra_db::{FileId, SourceDatabaseExt};\n \n fn parse_error_text(query: &str) -> String {\n     format!(\"{}\", query.parse::<SsrRule>().unwrap_err())\n@@ -260,6 +115,19 @@ fn assert_no_match(pattern: &str, code: &str) {\n     assert_matches(pattern, code, &[]);\n }\n \n+fn assert_match_failure_reason(pattern: &str, code: &str, snippet: &str, expected_reason: &str) {\n+    let (db, file_id) = single_file(code);\n+    let mut match_finder = MatchFinder::new(&db);\n+    match_finder.add_search_pattern(pattern.parse().unwrap());\n+    let mut reasons = Vec::new();\n+    for d in match_finder.debug_where_text_equal(file_id, snippet) {\n+        if let Some(reason) = d.match_failure_reason() {\n+            reasons.push(reason.to_owned());\n+        }\n+    }\n+    assert_eq!(reasons, vec![expected_reason]);\n+}\n+\n #[test]\n fn ssr_function_to_method() {\n     assert_ssr_transform(\n@@ -623,3 +491,30 @@ fn preserves_whitespace_within_macro_expansion() {\n             fn f() {macro1!(4 - 3 - 1   *   2}\"#,\n     )\n }\n+\n+#[test]\n+fn match_failure_reasons() {\n+    let code = r#\"\n+        macro_rules! foo {\n+            ($a:expr) => {\n+                1 + $a + 2\n+            };\n+        }\n+        fn f1() {\n+            bar(1, 2);\n+            foo!(5 + 43.to_string() + 5);\n+        }\n+        \"#;\n+    assert_match_failure_reason(\n+        \"bar($a, 3)\",\n+        code,\n+        \"bar(1, 2)\",\n+        r#\"Pattern wanted token '3' (INT_NUMBER), but code had token '2' (INT_NUMBER)\"#,\n+    );\n+    assert_match_failure_reason(\n+        \"42.to_string()\",\n+        code,\n+        \"43.to_string()\",\n+        r#\"Pattern wanted token '42' (INT_NUMBER), but code had token '43' (INT_NUMBER)\"#,\n+    );\n+}"}, {"sha": "8c0f4df8b80cd421391e9b06a7f6f713cc4d61bb", "filename": "crates/rust-analyzer/src/bin/args.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fargs.rs?ref=95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "patch": "@@ -5,7 +5,7 @@\n \n use anyhow::{bail, Result};\n use pico_args::Arguments;\n-use ra_ssr::SsrRule;\n+use ra_ssr::{SsrPattern, SsrRule};\n use rust_analyzer::cli::{BenchWhat, Position, Verbosity};\n \n use std::{fmt::Write, path::PathBuf};\n@@ -50,6 +50,10 @@ pub(crate) enum Command {\n     Ssr {\n         rules: Vec<SsrRule>,\n     },\n+    StructuredSearch {\n+        debug_snippet: Option<String>,\n+        patterns: Vec<SsrPattern>,\n+    },\n     ProcMacro,\n     RunServer,\n     Version,\n@@ -294,6 +298,7 @@ EXAMPLE:\n     rust-analyzer ssr '$a.foo($b) ==> bar($a, $b)'\n \n FLAGS:\n+    --debug <snippet>   Prints debug information for any nodes with source exactly equal to <snippet>\n     -h, --help          Prints help information\n \n ARGS:\n@@ -307,6 +312,34 @@ ARGS:\n                 }\n                 Command::Ssr { rules }\n             }\n+            \"search\" => {\n+                if matches.contains([\"-h\", \"--help\"]) {\n+                    eprintln!(\n+                        \"\\\n+rust-analyzer search\n+\n+USAGE:\n+    rust-analyzer search [FLAGS] [PATTERN...]\n+\n+EXAMPLE:\n+    rust-analyzer search '$a.foo($b)'\n+\n+FLAGS:\n+    --debug <snippet>   Prints debug information for any nodes with source exactly equal to <snippet>\n+    -h, --help          Prints help information\n+\n+ARGS:\n+    <PATTERN>           A structured search pattern\"\n+                    );\n+                    return Ok(Err(HelpPrinted));\n+                }\n+                let debug_snippet = matches.opt_value_from_str(\"--debug\")?;\n+                let mut patterns = Vec::new();\n+                while let Some(rule) = matches.free_from_str()? {\n+                    patterns.push(rule);\n+                }\n+                Command::StructuredSearch { patterns, debug_snippet }\n+            }\n             _ => {\n                 print_subcommands();\n                 return Ok(Err(HelpPrinted));\n@@ -334,6 +367,7 @@ SUBCOMMANDS:\n     diagnostics\n     proc-macro\n     parse\n+    search\n     ssr\n     symbols\"\n     )"}, {"sha": "eec76d4156aa873c85dfb55ce555a40ef9e00746", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "patch": "@@ -65,6 +65,9 @@ fn main() -> Result<()> {\n         args::Command::Ssr { rules } => {\n             cli::apply_ssr_rules(rules)?;\n         }\n+        args::Command::StructuredSearch { patterns, debug_snippet } => {\n+            cli::search_for_patterns(patterns, debug_snippet)?;\n+        }\n         args::Command::Version => println!(\"rust-analyzer {}\", env!(\"REV\")),\n     }\n     Ok(())"}, {"sha": "6863f100b64024562d6348946add1cb8049dc49c", "filename": "crates/rust-analyzer/src/cli.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli.rs?ref=95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "patch": "@@ -18,7 +18,7 @@ pub use analysis_bench::{analysis_bench, BenchWhat, Position};\n pub use analysis_stats::analysis_stats;\n pub use diagnostics::diagnostics;\n pub use load_cargo::load_cargo;\n-pub use ssr::apply_ssr_rules;\n+pub use ssr::{apply_ssr_rules, search_for_patterns};\n \n #[derive(Clone, Copy)]\n pub enum Verbosity {"}, {"sha": "4fb829ea5cfd7a5c8acde37e7444613f52bcf8d4", "filename": "crates/rust-analyzer/src/cli/ssr.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95f8310514238fc2c3b4d1ddecbd1b79d2c963a2/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fssr.rs?ref=95f8310514238fc2c3b4d1ddecbd1b79d2c963a2", "patch": "@@ -2,7 +2,7 @@\n \n use crate::cli::{load_cargo::load_cargo, Result};\n use ra_ide::SourceFileEdit;\n-use ra_ssr::{MatchFinder, SsrRule};\n+use ra_ssr::{MatchFinder, SsrPattern, SsrRule};\n \n pub fn apply_ssr_rules(rules: Vec<SsrRule>) -> Result<()> {\n     use ra_db::SourceDatabaseExt;\n@@ -31,3 +31,41 @@ pub fn apply_ssr_rules(rules: Vec<SsrRule>) -> Result<()> {\n     }\n     Ok(())\n }\n+\n+/// Searches for `patterns`, printing debug information for any nodes whose text exactly matches\n+/// `debug_snippet`. This is intended for debugging and probably isn't in it's current form useful\n+/// for much else.\n+pub fn search_for_patterns(patterns: Vec<SsrPattern>, debug_snippet: Option<String>) -> Result<()> {\n+    use ra_db::SourceDatabaseExt;\n+    use ra_ide_db::symbol_index::SymbolsDatabase;\n+    let (host, vfs) = load_cargo(&std::env::current_dir()?, true, true)?;\n+    let db = host.raw_database();\n+    let mut match_finder = MatchFinder::new(db);\n+    for pattern in patterns {\n+        match_finder.add_search_pattern(pattern);\n+    }\n+    for &root in db.local_roots().iter() {\n+        let sr = db.source_root(root);\n+        for file_id in sr.iter() {\n+            if let Some(debug_snippet) = &debug_snippet {\n+                for debug_info in match_finder.debug_where_text_equal(file_id, debug_snippet) {\n+                    println!(\"{:#?}\", debug_info);\n+                }\n+            } else {\n+                let matches = match_finder.find_matches_in_file(file_id);\n+                if !matches.matches.is_empty() {\n+                    let matches = matches.flattened().matches;\n+                    if let Some(path) = vfs.file_path(file_id).as_path() {\n+                        println!(\"{} matches in '{}'\", matches.len(), path.to_string_lossy());\n+                    }\n+                    // We could possibly at some point do something more useful than just printing\n+                    // the matched text. For now though, that's the easiest thing to do.\n+                    for m in matches {\n+                        println!(\"{}\", m.matched_text());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    Ok(())\n+}"}]}