{"sha": "d45ce5aed63fb58385705016dfaff1832a58d7c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NWNlNWFlZDYzZmI1ODM4NTcwNTAxNmRmYWZmMTgzMmE1OGQ3Yzg=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-12-26T15:02:21Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-03-02T11:43:06Z"}, "message": "Inline catching panics into std::catch_unwind\n\nThis allows LLVM to inline the happy path, such that catching unwinding is\nzero-cost when no panic occurs. This also allows us to match the code generated\nby C++ try/catch.", "tree": {"sha": "35a9bea734e796c0690399f6ebfc5049994b02f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35a9bea734e796c0690399f6ebfc5049994b02f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d45ce5aed63fb58385705016dfaff1832a58d7c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d45ce5aed63fb58385705016dfaff1832a58d7c8", "html_url": "https://github.com/rust-lang/rust/commit/d45ce5aed63fb58385705016dfaff1832a58d7c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d45ce5aed63fb58385705016dfaff1832a58d7c8/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b2983af1a85d857ae3a9345ac93ba0564ab7a73", "html_url": "https://github.com/rust-lang/rust/commit/6b2983af1a85d857ae3a9345ac93ba0564ab7a73"}], "stats": {"total": 137, "additions": 60, "deletions": 77}, "files": [{"sha": "ebc57860b9d4a47f2231c9a69f7506ff49396633", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=d45ce5aed63fb58385705016dfaff1832a58d7c8", "patch": "@@ -17,18 +17,11 @@\n #![feature(panic_runtime)]\n #![feature(staged_api)]\n #![feature(rustc_attrs)]\n+#![feature(raw)]\n \n-// Rust's \"try\" function, but if we're aborting on panics we just call the\n-// function as there's nothing else we need to do here.\n #[rustc_std_internal_symbol]\n-pub unsafe extern \"C\" fn __rust_maybe_catch_panic(\n-    f: fn(*mut u8),\n-    data: *mut u8,\n-    _data_ptr: *mut usize,\n-    _vtable_ptr: *mut usize,\n-) -> u32 {\n-    f(data);\n-    0\n+pub unsafe extern \"C\" fn __rust_cleanup(_: *mut u8) -> core::raw::TraitObject {\n+    unreachable!()\n }\n \n // \"Leak\" the payload and shim to the relevant abort on the platform in"}, {"sha": "30593d3b88af9bcea9ce6010c31ff75e178e98e6", "filename": "src/libpanic_unwind/dummy.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Fdummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Fdummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdummy.rs?ref=d45ce5aed63fb58385705016dfaff1832a58d7c8", "patch": "@@ -6,9 +6,7 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::intrinsics;\n \n-pub fn payload() -> *mut u8 {\n-    core::ptr::null_mut()\n-}\n+pub type Payload = *mut u8;\n \n pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {\n     intrinsics::abort()"}, {"sha": "873135414bd9d46b46cb4397386a3fb3795891a5", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=d45ce5aed63fb58385705016dfaff1832a58d7c8", "patch": "@@ -48,9 +48,7 @@ static EXCEPTION_TYPE_INFO: TypeInfo = TypeInfo {\n     name: b\"rust_panic\\0\".as_ptr(),\n };\n \n-pub fn payload() -> *mut u8 {\n-    ptr::null_mut()\n-}\n+pub type Payload = *mut u8;\n \n struct Exception {\n     // This needs to be an Option because the object's lifetime follows C++"}, {"sha": "dd84a814f48b16a7afe76cf89ef8bd2466e2bcd4", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=d45ce5aed63fb58385705016dfaff1832a58d7c8", "patch": "@@ -48,7 +48,6 @@\n \n use alloc::boxed::Box;\n use core::any::Any;\n-use core::ptr;\n \n use crate::dwarf::eh::{self, EHAction, EHContext};\n use libc::{c_int, uintptr_t};\n@@ -83,9 +82,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     }\n }\n \n-pub fn payload() -> *mut u8 {\n-    ptr::null_mut()\n-}\n+pub type Payload = *mut u8;\n \n pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     let exception = Box::from_raw(ptr as *mut Exception);"}, {"sha": "8ffb4bcd3df23697d0fe691d5f7c55527f8dbfa1", "filename": "src/libpanic_unwind/hermit.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Fhermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Fhermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fhermit.rs?ref=d45ce5aed63fb58385705016dfaff1832a58d7c8", "patch": "@@ -6,9 +6,7 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::ptr;\n \n-pub fn payload() -> *mut u8 {\n-    ptr::null_mut()\n-}\n+pub type Payload = *mut u8;\n \n pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {\n     extern \"C\" {"}, {"sha": "60ddf70cea52f2ec57590096d1abf349bfdeb7fe", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=d45ce5aed63fb58385705016dfaff1832a58d7c8", "patch": "@@ -22,20 +22,20 @@\n #![feature(libc)]\n #![feature(nll)]\n #![feature(panic_unwind)]\n-#![feature(raw)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(unwind_attributes)]\n #![feature(abi_thiscall)]\n+#![feature(rustc_attrs)]\n+#![feature(raw)]\n #![panic_runtime]\n #![feature(panic_runtime)]\n \n use alloc::boxed::Box;\n-use core::intrinsics;\n-use core::mem;\n use core::panic::BoxMeUp;\n-use core::raw;\n \n+// If adding to this list, you should also look at libstd::panicking's identical\n+// list of Payload types and likely add to there as well.\n cfg_if::cfg_if! {\n     if #[cfg(target_os = \"emscripten\")] {\n         #[path = \"emcc.rs\"]\n@@ -69,28 +69,11 @@ extern \"C\" {\n \n mod dwarf;\n \n-// Entry point for catching an exception, implemented using the `try` intrinsic\n-// in the compiler.\n-//\n-// The interaction between the `payload` function and the compiler is pretty\n-// hairy and tightly coupled, for more information see the compiler's\n-// implementation of this.\n #[no_mangle]\n-pub unsafe extern \"C\" fn __rust_maybe_catch_panic(\n-    f: fn(*mut u8),\n-    data: *mut u8,\n-    data_ptr: *mut usize,\n-    vtable_ptr: *mut usize,\n-) -> u32 {\n-    let mut payload = imp::payload();\n-    if intrinsics::r#try(f, data, &mut payload as *mut _ as *mut _) == 0 {\n-        0\n-    } else {\n-        let obj = mem::transmute::<_, raw::TraitObject>(imp::cleanup(payload));\n-        *data_ptr = obj.data as usize;\n-        *vtable_ptr = obj.vtable as usize;\n-        1\n-    }\n+pub unsafe extern \"C\" fn __rust_panic_cleanup(payload: *mut u8) -> core::raw::TraitObject {\n+    let payload = payload as *mut imp::Payload;\n+    let payload = *(payload);\n+    core::mem::transmute(imp::cleanup(payload))\n }\n \n // Entry point for raising an exception, just delegates to the platform-specific"}, {"sha": "6f464c1ab680e5550f398aef809167147a66d333", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=d45ce5aed63fb58385705016dfaff1832a58d7c8", "patch": "@@ -308,9 +308,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     _CxxThrowException(throw_ptr, &mut THROW_INFO as *mut _ as *mut _);\n }\n \n-pub fn payload() -> [u64; 2] {\n-    [0; 2]\n-}\n+pub type Payload = [u64; 2];\n \n pub unsafe fn cleanup(payload: [u64; 2]) -> Box<dyn Any + Send> {\n     mem::transmute(raw::TraitObject { data: payload[0] as *mut _, vtable: payload[1] as *mut _ })"}, {"sha": "f71849fae34fa3afe1bcdfb2d556da45e19f34e9", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 44, "deletions": 26, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45ce5aed63fb58385705016dfaff1832a58d7c8/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=d45ce5aed63fb58385705016dfaff1832a58d7c8", "patch": "@@ -12,9 +12,8 @@ use core::panic::{BoxMeUp, Location, PanicInfo};\n use crate::any::Any;\n use crate::fmt;\n use crate::intrinsics;\n-use crate::mem::{self, ManuallyDrop};\n+use crate::mem::{self, ManuallyDrop, MaybeUninit};\n use crate::process;\n-use crate::raw;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::stdio::panic_output;\n use crate::sys_common::backtrace::{self, RustBacktrace};\n@@ -29,6 +28,31 @@ use crate::io::set_panic;\n #[cfg(test)]\n use realstd::io::set_panic;\n \n+// This must be kept in sync with the implementations in libpanic_unwind.\n+//\n+// This is *not* checked in anyway; the compiler does not allow us to use a\n+// type/macro/anything from panic_unwind, since we're then linking in the\n+// panic_unwind runtime even during -Cpanic=abort.\n+//\n+// Essentially this must be the type of `imp::Payload` in libpanic_unwind.\n+cfg_if::cfg_if! {\n+    if #[cfg(not(feature = \"panic_unwind\"))] {\n+        type Payload = ();\n+    } else if #[cfg(target_os = \"emscripten\")] {\n+        type Payload = *mut u8;\n+    } else if #[cfg(target_arch = \"wasm32\")] {\n+        type Payload = *mut u8;\n+    } else if #[cfg(target_os = \"hermit\")] {\n+        type Payload = *mut u8;\n+    } else if #[cfg(all(target_env = \"msvc\", target_arch = \"aarch64\"))] {\n+        type Payload = *mut u8;\n+    } else if #[cfg(target_env = \"msvc\")] {\n+        type Payload = [u64; 2];\n+    } else {\n+        type Payload = *mut u8;\n+    }\n+}\n+\n // Binary interface to the panic runtime that the standard library depends on.\n //\n // The standard library is tagged with `#![needs_panic_runtime]` (introduced in\n@@ -41,12 +65,9 @@ use realstd::io::set_panic;\n // hook up these functions, but it is not this day!\n #[allow(improper_ctypes)]\n extern \"C\" {\n-    fn __rust_maybe_catch_panic(\n-        f: fn(*mut u8),\n-        data: *mut u8,\n-        data_ptr: *mut usize,\n-        vtable_ptr: *mut usize,\n-    ) -> u32;\n+    /// The payload ptr here is actually the same as the payload ptr for the try\n+    /// intrinsic (i.e., is really `*mut [u64; 2]` or `*mut *mut u8`).\n+    fn __rust_panic_cleanup(payload: *mut u8) -> core::raw::TraitObject;\n \n     /// `payload` is actually a `*mut &mut dyn BoxMeUp` but that would cause FFI warnings.\n     /// It cannot be `Box<dyn BoxMeUp>` because the other end of this call does not depend\n@@ -250,9 +271,9 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     }\n \n     // We do some sketchy operations with ownership here for the sake of\n-    // performance. We can only  pass pointers down to\n-    // `__rust_maybe_catch_panic` (can't pass objects by value), so we do all\n-    // the ownership tracking here manually using a union.\n+    // performance. We can only pass pointers down to `do_call` (can't pass\n+    // objects by value), so we do all the ownership tracking here manually\n+    // using a union.\n     //\n     // We go through a transition where:\n     //\n@@ -263,7 +284,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     // * If the closure successfully returns, we write the return value into the\n     //   data's return slot. Note that `ptr::write` is used as it's overwriting\n     //   uninitialized data.\n-    // * Finally, when we come back out of the `__rust_maybe_catch_panic` we're\n+    // * Finally, when we come back out of the `try` intrinsic we're\n     //   in one of two states:\n     //\n     //      1. The closure didn't panic, in which case the return value was\n@@ -274,27 +295,24 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     //\n     // Once we stack all that together we should have the \"most efficient'\n     // method of calling a catch panic whilst juggling ownership.\n-    let mut any_data = 0;\n-    let mut any_vtable = 0;\n     let mut data = Data { f: ManuallyDrop::new(f) };\n \n-    let r = __rust_maybe_catch_panic(\n-        do_call::<F, R>,\n-        &mut data as *mut _ as *mut u8,\n-        &mut any_data,\n-        &mut any_vtable,\n-    );\n+    let mut payload: MaybeUninit<Payload> = MaybeUninit::uninit();\n \n-    return if r == 0 {\n+    let data_ptr = &mut data as *mut _ as *mut u8;\n+    let payload_ptr = payload.as_mut_ptr() as *mut _;\n+    return if intrinsics::r#try(do_call::<F, R>, data_ptr, payload_ptr) == 0 {\n         Ok(ManuallyDrop::into_inner(data.r))\n     } else {\n-        update_panic_count(-1);\n-        Err(mem::transmute(raw::TraitObject {\n-            data: any_data as *mut _,\n-            vtable: any_vtable as *mut _,\n-        }))\n+        Err(cleanup(payload.assume_init()))\n     };\n \n+    unsafe fn cleanup(mut payload: Payload) -> Box<dyn Any + Send + 'static> {\n+        let obj = crate::mem::transmute(__rust_panic_cleanup(&mut payload as *mut _ as *mut u8));\n+        update_panic_count(-1);\n+        obj\n+    }\n+\n     fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n         unsafe {\n             let data = data as *mut Data<F, R>;"}]}