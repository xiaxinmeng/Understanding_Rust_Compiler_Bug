{"sha": "63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZWE0MmZkM2M4MmM2MjlhMGU1YThiOTgxYmRhZWIzMGNkYzAyNTM=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-05-16T19:07:35Z"}, "committer": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-05-16T21:18:19Z"}, "message": "Rollup merge of #50793 - jrlusby:master, r=petrochenkov\n\ntidy: Add a check for empty UI test files\n\nCheck for empty `.stderr` and `.stdout` files in UI test directories.\nEmpty files could  still pass testing for `compile-pass` tests with no output\nso they can get into the repo accidentally, but they are not necessary and can\nbe removed.\n\nThis is very much an in progress pull request. I'm having an issue with rustfmt. It wanted to reformat the entire file for almost every file by default. And when I run tidy it just errors out because it catches the empty files that are already in the repo.\n\nMy next step is goin got be to remove those empty file and see if running tidy again will actually reformat things outside of the context of `cargo fmt`\n\nFixes https://github.com/rust-lang/rust/issues/50785", "tree": {"sha": "02b249287151f4f5e67c47c1a67bab41c40f3862", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02b249287151f4f5e67c47c1a67bab41c40f3862"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEZ1R8CLMp8f2GxWoQ/vbIBR0OATwFAlr8oBwACgkQ/vbIBR0O\nATxTNg//bUZSs3OlZPKRTn8to8VYX7GcxHVBzNnzvk5DxizczRIoQO8lyDDece32\nF4hMQ4VS8i9TXhJkWTI8GQ6aUeyRwoeWbWB7BxCQQ5aicvOLAb8uTwsBjrfs5ZIt\nR1BGRZmLIFufGQCCquRVn8GUvtZHUucJAQc9Xe5HnxvcNrzxO+SSS17wcj9kluMm\nhFPLOx/MT7rbu9W6KxLJOyH+RUdpXQemgZMHTh1t3Xo0QSIBnPVE9P2RztiIy8B4\nh1pZAeqMuNM/LFiRztRaXbtxxSUQ7034nkG4xX0jZ895Csr5CWoSnBBbYlguNMAK\n6mhtpu+IH5FBGP6cPnQcJLvqgdISQQRn3UwLcXSswSd4oL2JDpaxBlnN/x5oTMm4\n5M13u3BmuGCjls4fzig911o4pbYsieSb8CvTwv5X7GzV6w9gu5Mu/9KQcPlyhR48\nz9PMg5F5/SQBwzsDm+939s15npvD8IvvqCDNPPOf2hOBi8ZA45wY7pI7Ca1PJmpm\nCCW8b7Sua17w9LFsZ2Z6KbJL14x4K03KFdWhs5z7MRMB1nXW2+ulyPgzSS6uwVpB\nLIHh270dfdS1XZGMnkPlGOgYzcRqlPjeKcetteEIDN/Eweq9A+tgUeF69y4/WJTB\nMybnik+/Hri0rGqi+BCHLmoMhLxhgXjB4ikMEapSRfsb+Oc4Sww=\n=jmh5\n-----END PGP SIGNATURE-----", "payload": "tree 02b249287151f4f5e67c47c1a67bab41c40f3862\nparent 0306630925bf4ab112bf1778bea0b27919b1cc8f\nparent 6ed200aaeabb7ab2e12c6fd2a52627bd3f457a95\nauthor kennytm <kennytm@gmail.com> 1526497655 +0800\ncommitter kennytm <kennytm@gmail.com> 1526505499 +0800\n\nRollup merge of #50793 - jrlusby:master, r=petrochenkov\n\ntidy: Add a check for empty UI test files\n\nCheck for empty `.stderr` and `.stdout` files in UI test directories.\nEmpty files could  still pass testing for `compile-pass` tests with no output\nso they can get into the repo accidentally, but they are not necessary and can\nbe removed.\n\nThis is very much an in progress pull request. I'm having an issue with rustfmt. It wanted to reformat the entire file for almost every file by default. And when I run tidy it just errors out because it catches the empty files that are already in the repo.\n\nMy next step is goin got be to remove those empty file and see if running tidy again will actually reformat things outside of the context of `cargo fmt`\n\nFixes https://github.com/rust-lang/rust/issues/50785\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "html_url": "https://github.com/rust-lang/rust/commit/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0306630925bf4ab112bf1778bea0b27919b1cc8f", "url": "https://api.github.com/repos/rust-lang/rust/commits/0306630925bf4ab112bf1778bea0b27919b1cc8f", "html_url": "https://github.com/rust-lang/rust/commit/0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "6ed200aaeabb7ab2e12c6fd2a52627bd3f457a95", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ed200aaeabb7ab2e12c6fd2a52627bd3f457a95", "html_url": "https://github.com/rust-lang/rust/commit/6ed200aaeabb7ab2e12c6fd2a52627bd3f457a95"}], "stats": {"total": 627, "additions": 550, "deletions": 77}, "files": [{"sha": "7e03288f57284bf4c0a6f32af369ba2e518da930", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -179,7 +179,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn expr(&mut self, expr: &hir::Expr, pred: CFGIndex) -> CFGIndex {\n         match expr.node {\n-            hir::ExprBlock(ref blk) => {\n+            hir::ExprBlock(ref blk, _) => {\n                 let blk_exit = self.block(&blk, pred);\n                 self.add_ast_node(expr.hir_id.local_id, &[blk_exit])\n             }"}, {"sha": "59b058e98611c5336ccd8a84c37e9a324ae9acee", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -1015,7 +1015,10 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                              expression.span,\n                              expression.id)\n         }\n-        ExprBlock(ref block) => visitor.visit_block(block),\n+        ExprBlock(ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n         ExprAssign(ref left_hand_expression, ref right_hand_expression) => {\n             visitor.visit_expr(right_hand_expression);\n             visitor.visit_expr(left_hand_expression)"}, {"sha": "0f4871954d669bbe231ba9cdf6344381d8701f62", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -3048,7 +3048,7 @@ impl<'a> LoweringContext<'a> {\n                     );\n                     block.expr = Some(this.wrap_in_try_constructor(\n                         \"from_ok\", tail, unstable_span));\n-                    hir::ExprBlock(P(block))\n+                    hir::ExprBlock(P(block), None)\n                 })\n             }\n             ExprKind::Match(ref expr, ref arms) => hir::ExprMatch(\n@@ -3100,7 +3100,11 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 })\n             }\n-            ExprKind::Block(ref blk) => hir::ExprBlock(self.lower_block(blk, false)),\n+            ExprKind::Block(ref blk, opt_label) => {\n+                hir::ExprBlock(self.lower_block(blk,\n+                                                opt_label.is_some()),\n+                                                self.lower_label(opt_label))\n+            }\n             ExprKind::Assign(ref el, ref er) => {\n                 hir::ExprAssign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n             }\n@@ -3843,7 +3847,7 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_block(&mut self, b: P<hir::Block>, attrs: ThinVec<Attribute>) -> hir::Expr {\n-        self.expr(b.span, hir::ExprBlock(b), attrs)\n+        self.expr(b.span, hir::ExprBlock(b, None), attrs)\n     }\n \n     fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr>) -> P<hir::Expr> {"}, {"sha": "c48fb7ab7ebde0bfa21de9186bb91101fa16789c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -778,9 +778,8 @@ pub struct Block {\n     pub rules: BlockCheckMode,\n     pub span: Span,\n     /// If true, then there may exist `break 'a` values that aim to\n-    /// break out of this block early. As of this writing, this is not\n-    /// currently permitted in Rust itself, but it is generated as\n-    /// part of `catch` statements.\n+    /// break out of this block early.\n+    /// Used by `'label: {}` blocks and by `catch` statements.\n     pub targeted_by_break: bool,\n     /// If true, don't emit return value type errors as the parser had\n     /// to recover from a parse error so this block will not have an\n@@ -1381,8 +1380,8 @@ pub enum Expr_ {\n     /// This may also be a generator literal, indicated by the final boolean,\n     /// in that case there is an GeneratorClause.\n     ExprClosure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n-    /// A block (`{ ... }`)\n-    ExprBlock(P<Block>),\n+    /// A block (`'label: { ... }`)\n+    ExprBlock(P<Block>, Option<Label>),\n \n     /// An assignment (`a = foo()`)\n     ExprAssign(P<Expr>, P<Expr>),"}, {"sha": "9cd9e0dce54e35d487d2d1fe2db8cde85f4607fe", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -1047,7 +1047,7 @@ impl<'a> State<'a> {\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n-                    hir::ExprBlock(ref b) => {\n+                    hir::ExprBlock(ref b, _) => {\n                         self.cbox(indent_unit - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else \")?;\n@@ -1377,7 +1377,11 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 self.ibox(0)?;\n             }\n-            hir::ExprBlock(ref blk) => {\n+            hir::ExprBlock(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n+                    self.word_space(\":\")?;\n+                }\n                 // containing cbox, will be closed by print-block at }\n                 self.cbox(indent_unit)?;\n                 // head-box, will be closed by print-block after {\n@@ -1893,7 +1897,11 @@ impl<'a> State<'a> {\n         self.word_space(\"=>\")?;\n \n         match arm.body.node {\n-            hir::ExprBlock(ref blk) => {\n+            hir::ExprBlock(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n+                    self.word_space(\":\")?;\n+                }\n                 // the block will close the pattern's ibox\n                 self.print_block_unclosed_indent(&blk, indent_unit)?;\n \n@@ -2299,7 +2307,7 @@ fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n         hir::ExprIf(..) |\n         hir::ExprMatch(..) |\n-        hir::ExprBlock(_) |\n+        hir::ExprBlock(..) |\n         hir::ExprWhile(..) |\n         hir::ExprLoop(..) => false,\n         _ => true,"}, {"sha": "ed01704e6a45c4dcd90b39bad59f69723317a54e", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -589,7 +589,7 @@ impl_stable_hash_for!(enum hir::Expr_ {\n     ExprLoop(body, label, loop_src),\n     ExprMatch(matchee, arms, match_src),\n     ExprClosure(capture_clause, decl, body_id, span, gen),\n-    ExprBlock(blk),\n+    ExprBlock(blk, label),\n     ExprAssign(lhs, rhs),\n     ExprAssignOp(op, lhs, rhs),\n     ExprField(owner, field_name),"}, {"sha": "3ba230fe55a5132de01c10fd66ef0e7e3efdad3a", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -499,7 +499,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 self.consume_expr(&rhs);\n             }\n \n-            hir::ExprBlock(ref blk) => {\n+            hir::ExprBlock(ref blk, _) => {\n                 self.walk_block(&blk);\n             }\n "}, {"sha": "b39311a74718f5ac1a021cb3533fb280822c0563", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -1187,7 +1187,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             succ\n           }\n \n-          hir::ExprBlock(ref blk) => {\n+          // Note that labels have been resolved, so we don't need to look\n+          // at the label ident\n+          hir::ExprBlock(ref blk, _) => {\n             self.propagate_through_block(&blk, succ)\n           }\n         }"}, {"sha": "52217600759313192aebe52df34d51b7537d9353", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -1247,7 +1247,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n             hir::ExprCast(ref subexpr, _) => {\n                 record_rvalue_scope_if_borrow_expr(visitor, &subexpr, blk_id)\n             }\n-            hir::ExprBlock(ref block) => {\n+            hir::ExprBlock(ref block, _) => {\n                 if let Some(ref subexpr) = block.expr {\n                     record_rvalue_scope_if_borrow_expr(\n                         visitor, &subexpr, blk_id);"}, {"sha": "19280372d551dc676a561c2d24e168f4c6adb09f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -228,7 +228,7 @@ impl UnsafeCode {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        if let hir::ExprBlock(ref blk) = e.node {\n+        if let hir::ExprBlock(ref blk, _) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) {\n                 self.report_unsafe(cx, blk.span, \"usage of an `unsafe` block\");"}, {"sha": "c9f86d43998c8a7c18623e75d5058bd0963f7ea7", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.in_opt_scope(opt_destruction_scope.map(|de|(de, source_info)), block, move |this| {\n             this.in_scope((region_scope, source_info), LintLevel::Inherited, block, move |this| {\n                 if targeted_by_break {\n-                    // This is a `break`-able block (currently only `catch { ... }`)\n+                    // This is a `break`-able block\n                     let exit_block = this.cfg.start_new_block();\n                     let block_exit = this.in_breakable_scope(\n                         None, exit_block, destination.clone(), |this| {"}, {"sha": "97a4e0f37249f41007391ca34b8dbc38e423e2f8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -292,7 +292,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        hir::ExprBlock(ref blk) => ExprKind::Block { body: &blk },\n+        hir::ExprBlock(ref blk, _) => ExprKind::Block { body: &blk },\n \n         hir::ExprAssign(ref lhs, ref rhs) => {\n             ExprKind::Assign {"}, {"sha": "85af00956c933851e5696ca592a32ab0b4b65e19", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -141,7 +141,7 @@ fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) ->\n             }\n             // Check if this is an unsafe block, or an item\n             match node {\n-                Node::NodeExpr(&hir::Expr { node: hir::ExprBlock(ref block), ..}) => {\n+                Node::NodeExpr(&hir::Expr { node: hir::ExprBlock(ref block, _), ..}) => {\n                     if block_is_unsafe(&*block) {\n                         // Found an unsafe block, we can bail out here.\n                         return true;"}, {"sha": "d031694d85308a1d1cbc97f9aaec3f21a2540acf", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -259,6 +259,44 @@ let result = loop { // ok!\n     i += 1;\n };\n ```\n+\"##,\n+\n+E0695: r##\"\n+A `break` statement without a label appeared inside a labeled block.\n+\n+Example of erroneous code:\n+\n+```compile_fail,E0695\n+# #![feature(label_break_value)]\n+loop {\n+    'a: {\n+        break;\n+    }\n+}\n+```\n+\n+Make sure to always label the `break`:\n+\n+```\n+# #![feature(label_break_value)]\n+'l: loop {\n+    'a: {\n+        break 'l;\n+    }\n+}\n+```\n+\n+Or if you want to `break` the labeled block:\n+\n+```\n+# #![feature(label_break_value)]\n+loop {\n+    'a: {\n+        break 'a;\n+    }\n+    break;\n+}\n+```\n \"##\n }\n \n@@ -271,4 +309,5 @@ register_diagnostics! {\n     E0642, // patterns aren't allowed in methods without bodies\n     E0666, // nested `impl Trait` is illegal\n     E0667, // `impl Trait` in projections\n+    E0696, // `continue` pointing to a labeled block\n }"}, {"sha": "2368b1aca69481d36438c84276443da61f2e6ee1", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -13,7 +13,7 @@ use rustc::session::Session;\n \n use rustc::hir::map::Map;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir;\n+use rustc::hir::{self, Destination};\n use syntax::ast;\n use syntax_pos::Span;\n \n@@ -39,6 +39,7 @@ enum Context {\n     Normal,\n     Loop(LoopKind),\n     Closure,\n+    LabeledBlock,\n }\n \n #[derive(Copy, Clone)]\n@@ -84,7 +85,16 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n             hir::ExprClosure(.., b, _, _) => {\n                 self.with_context(Closure, |v| v.visit_nested_body(b));\n             }\n+            hir::ExprBlock(ref b, Some(_label)) => {\n+                self.with_context(LabeledBlock, |v| v.visit_block(&b));\n+            }\n             hir::ExprBreak(label, ref opt_expr) => {\n+                if self.require_label_in_labeled_block(e.span, &label, \"break\") {\n+                    // If we emitted an error about an unlabeled break in a labeled\n+                    // block, we don't need any further checking for this break any more\n+                    return;\n+                }\n+\n                 let loop_id = match label.target_id.into() {\n                     Ok(loop_id) => loop_id,\n                     Err(hir::LoopIdError::OutsideLoopScope) => ast::DUMMY_NODE_ID,\n@@ -94,6 +104,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     },\n                     Err(hir::LoopIdError::UnresolvedLabel) => ast::DUMMY_NODE_ID,\n                 };\n+\n                 if loop_id != ast::DUMMY_NODE_ID {\n                     match self.hir_map.find(loop_id).unwrap() {\n                         hir::map::NodeBlock(_) => return,\n@@ -113,13 +124,15 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                         })\n                     };\n                     match loop_kind {\n-                        None | Some(LoopKind::Loop(hir::LoopSource::Loop)) => (),\n+                        None |\n+                        Some(LoopKind::Loop(hir::LoopSource::Loop)) => (),\n                         Some(kind) => {\n                             struct_span_err!(self.sess, e.span, E0571,\n                                              \"`break` with value from a `{}` loop\",\n                                              kind.name())\n                                 .span_label(e.span,\n-                                            \"can only break with a value inside `loop`\")\n+                                            \"can only break with a value inside \\\n+                                            `loop` or breakable block\")\n                                 .span_suggestion(e.span,\n                                                  &format!(\"instead, use `break` on its own \\\n                                                            without a value inside this `{}` loop\",\n@@ -130,13 +143,29 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n                     }\n                 }\n \n-                self.require_loop(\"break\", e.span);\n+                self.require_break_cx(\"break\", e.span);\n             }\n             hir::ExprAgain(label) => {\n-                if let Err(hir::LoopIdError::UnlabeledCfInWhileCondition) = label.target_id {\n-                    self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n+                self.require_label_in_labeled_block(e.span, &label, \"continue\");\n+\n+                match label.target_id {\n+                    Ok(loop_id) => {\n+                        if let hir::map::NodeBlock(block) = self.hir_map.find(loop_id).unwrap() {\n+                            struct_span_err!(self.sess, e.span, E0696,\n+                                            \"`continue` pointing to a labeled block\")\n+                                .span_label(e.span,\n+                                            \"labeled blocks cannot be `continue`'d\")\n+                                .span_note(block.span,\n+                                            \"labeled block the continue points to\")\n+                                .emit();\n+                        }\n+                    }\n+                    Err(hir::LoopIdError::UnlabeledCfInWhileCondition) => {\n+                        self.emit_unlabled_cf_in_while_condition(e.span, \"continue\");\n+                    }\n+                    _ => {}\n                 }\n-                self.require_loop(\"continue\", e.span)\n+                self.require_break_cx(\"continue\", e.span)\n             },\n             _ => intravisit::walk_expr(self, e),\n         }\n@@ -153,8 +182,9 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n         self.cx = old_cx;\n     }\n \n-    fn require_loop(&self, name: &str, span: Span) {\n+    fn require_break_cx(&self, name: &str, span: Span) {\n         match self.cx {\n+            LabeledBlock |\n             Loop(_) => {}\n             Closure => {\n                 struct_span_err!(self.sess, span, E0267, \"`{}` inside of a closure\", name)\n@@ -169,6 +199,22 @@ impl<'a, 'hir> CheckLoopVisitor<'a, 'hir> {\n         }\n     }\n \n+    fn require_label_in_labeled_block(&mut self, span: Span, label: &Destination, cf_type: &str)\n+        -> bool\n+    {\n+        if self.cx == LabeledBlock {\n+            if label.label.is_none() {\n+                struct_span_err!(self.sess, span, E0695,\n+                                \"unlabeled `{}` inside of a labeled block\", cf_type)\n+                    .span_label(span,\n+                                format!(\"`{}` statements that would diverge to or through \\\n+                                a labeled block need to bear a label\", cf_type))\n+                    .emit();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n     fn emit_unlabled_cf_in_while_condition(&mut self, span: Span, cf_type: &str) {\n         struct_span_err!(self.sess, span, E0590,\n                          \"`break` or `continue` with no label in the condition of a `while` loop\")"}, {"sha": "2e737a016da7761c53d2075017d1a6626f057c72", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -342,7 +342,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             let mut callee = &**callee;\n             loop {\n                 callee = match callee.node {\n-                    hir::ExprBlock(ref block) => match block.expr {\n+                    hir::ExprBlock(ref block, _) => match block.expr {\n                         Some(ref tail) => &tail,\n                         None => break\n                     },\n@@ -404,7 +404,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n \n-        hir::ExprBlock(_) |\n+        hir::ExprBlock(..) |\n         hir::ExprIndex(..) |\n         hir::ExprField(..) |\n         hir::ExprArray(_) |"}, {"sha": "d2934bc9ee8acc10ebddc9e19c62a33bef8225c5", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -3753,6 +3753,8 @@ impl<'a> Resolver<'a> {\n                 self.ribs[ValueNS].pop();\n             }\n \n+            ExprKind::Block(ref block, label) => self.resolve_labeled_block(label, block.id, block),\n+\n             // Equivalent to `visit::walk_expr` + passing some context to children.\n             ExprKind::Field(ref subexpression, _) => {\n                 self.resolve_expr(subexpression, Some(expr));"}, {"sha": "39de09fe34f401ce4f360445b141859c00cd32c6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -3536,7 +3536,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Warn for non-block expressions with diverging children.\n         match expr.node {\n-            hir::ExprBlock(_) |\n+            hir::ExprBlock(..) |\n             hir::ExprLoop(..) | hir::ExprWhile(..) |\n             hir::ExprIf(..) | hir::ExprMatch(..) => {}\n \n@@ -3912,7 +3912,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprClosure(capture, ref decl, body_id, _, gen) => {\n               self.check_expr_closure(expr, capture, &decl, body_id, gen, expected)\n           }\n-          hir::ExprBlock(ref body) => {\n+          hir::ExprBlock(ref body, _) => {\n             self.check_block_with_expected(&body, expected)\n           }\n           hir::ExprCall(ref callee, ref args) => {\n@@ -4326,8 +4326,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // In some cases, blocks have just one exit, but other blocks\n-        // can be targeted by multiple breaks. This cannot happen in\n-        // normal Rust syntax today, but it can happen when we desugar\n+        // can be targeted by multiple breaks. This can happen both\n+        // with labeled blocks as well as when we desugar\n         // a `do catch { ... }` expression.\n         //\n         // Example 1:"}, {"sha": "2b6635ec7831f09da58276e7206a310cce4e2a3a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -934,7 +934,7 @@ impl Expr {\n     /// Whether this expression would be valid somewhere that expects a value, for example, an `if`\n     /// condition.\n     pub fn returns(&self) -> bool {\n-        if let ExprKind::Block(ref block) = self.node {\n+        if let ExprKind::Block(ref block, _) = self.node {\n             match block.stmts.last().map(|last_stmt| &last_stmt.node) {\n                 // implicit return\n                 Some(&StmtKind::Expr(_)) => true,\n@@ -1121,8 +1121,8 @@ pub enum ExprKind {\n     ///\n     /// The final span is the span of the argument block `|...|`\n     Closure(CaptureBy, Movability, P<FnDecl>, P<Expr>, Span),\n-    /// A block (`{ ... }`)\n-    Block(P<Block>),\n+    /// A block (`'label: { ... }`)\n+    Block(P<Block>, Option<Label>),\n     /// A catch block (`catch { ... }`)\n     Catch(P<Block>),\n "}, {"sha": "a4f9ebcf41811190393294ba9a400ca3093357f2", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -668,7 +668,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(span, ast::ExprKind::MethodCall(segment, args))\n     }\n     fn expr_block(&self, b: P<ast::Block>) -> P<ast::Expr> {\n-        self.expr(b.span, ast::ExprKind::Block(b))\n+        self.expr(b.span, ast::ExprKind::Block(b, None))\n     }\n     fn field_imm(&self, span: Span, ident: Ident, e: P<ast::Expr>) -> ast::Field {\n         ast::Field {"}, {"sha": "f1229520c77434e7d428e5a36407fdddf4003b1d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -466,6 +466,9 @@ declare_features! (\n \n     // inconsistent bounds in where clauses\n     (active, trivial_bounds, \"1.28.0\", Some(48214), None),\n+\n+    // 'a: { break 'a; }\n+    (active, label_break_value, \"1.28.0\", Some(48594), None),\n );\n \n declare_features! (\n@@ -1696,6 +1699,12 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                     \"multiple patterns in `if let` and `while let` are unstable\");\n                 }\n             }\n+            ast::ExprKind::Block(_, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    gate_feature_post!(&self, label_break_value, label.ident.span,\n+                                    \"labels on blocks are unstable\");\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "29cc208c06b1a4154064a4fdcd603392f2b0698a", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -1256,7 +1256,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                                   folder.fold_expr(body),\n                                   folder.new_span(span))\n             }\n-            ExprKind::Block(blk) => ExprKind::Block(folder.fold_block(blk)),\n+            ExprKind::Block(blk, opt_label) => {\n+                ExprKind::Block(folder.fold_block(blk),\n+                                opt_label.map(|label| folder.fold_label(label)))\n+            }\n             ExprKind::Assign(el, er) => {\n                 ExprKind::Assign(folder.fold_expr(el), folder.fold_expr(er))\n             }"}, {"sha": "531483e7de120efd0fa8c06d554d0621d3a874b1", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -26,7 +26,7 @@ pub fn expr_requires_semi_to_be_stmt(e: &ast::Expr) -> bool {\n         ast::ExprKind::If(..) |\n         ast::ExprKind::IfLet(..) |\n         ast::ExprKind::Match(..) |\n-        ast::ExprKind::Block(_) |\n+        ast::ExprKind::Block(..) |\n         ast::ExprKind::While(..) |\n         ast::ExprKind::WhileLet(..) |\n         ast::ExprKind::Loop(..) |"}, {"sha": "7b91c49170068c8a4f0e02f26dc20e7a7708bae3", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -128,7 +128,7 @@ macro_rules! maybe_whole_expr {\n                 token::NtBlock(ref block) => {\n                     $p.bump();\n                     let span = $p.span;\n-                    let kind = ExprKind::Block((*block).clone());\n+                    let kind = ExprKind::Block((*block).clone(), None);\n                     return Ok($p.mk_expr(span, kind, ThinVec::new()));\n                 }\n                 _ => {},\n@@ -2244,7 +2244,7 @@ impl<'a> Parser<'a> {\n                 };\n             }\n             token::OpenDelim(token::Brace) => {\n-                return self.parse_block_expr(lo, BlockCheckMode::Default, attrs);\n+                return self.parse_block_expr(None, lo, BlockCheckMode::Default, attrs);\n             }\n             token::BinOp(token::Or) | token::OrOr => {\n                 return self.parse_lambda_expr(attrs);\n@@ -2318,7 +2318,13 @@ impl<'a> Parser<'a> {\n                     if self.eat_keyword(keywords::Loop) {\n                         return self.parse_loop_expr(Some(label), lo, attrs)\n                     }\n-                    let msg = \"expected `while`, `for`, or `loop` after a label\";\n+                    if self.token == token::OpenDelim(token::Brace) {\n+                        return self.parse_block_expr(Some(label),\n+                                                     lo,\n+                                                     BlockCheckMode::Default,\n+                                                     attrs);\n+                    }\n+                    let msg = \"expected `while`, `for`, `loop` or `{` after a label\";\n                     let mut err = self.fatal(msg);\n                     err.span_label(self.span, msg);\n                     return Err(err);\n@@ -2338,6 +2344,7 @@ impl<'a> Parser<'a> {\n                 }\n                 if self.eat_keyword(keywords::Unsafe) {\n                     return self.parse_block_expr(\n+                        None,\n                         lo,\n                         BlockCheckMode::Unsafe(ast::UserProvided),\n                         attrs);\n@@ -2502,7 +2509,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a block or unsafe block\n-    pub fn parse_block_expr(&mut self, lo: Span, blk_mode: BlockCheckMode,\n+    pub fn parse_block_expr(&mut self, opt_label: Option<Label>,\n+                            lo: Span, blk_mode: BlockCheckMode,\n                             outer_attrs: ThinVec<Attribute>)\n                             -> PResult<'a, P<Expr>> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n@@ -2511,7 +2519,7 @@ impl<'a> Parser<'a> {\n         attrs.extend(self.parse_inner_attributes()?);\n \n         let blk = self.parse_block_tail(lo, blk_mode)?;\n-        return Ok(self.mk_expr(blk.span, ExprKind::Block(blk), attrs));\n+        return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, opt_label), attrs));\n     }\n \n     /// parse a.b or a(13) or a[4] or just a\n@@ -3261,7 +3269,7 @@ impl<'a> Parser<'a> {\n                 // If an explicit return type is given, require a\n                 // block to appear (RFC 968).\n                 let body_lo = self.span;\n-                self.parse_block_expr(body_lo, BlockCheckMode::Default, ThinVec::new())?\n+                self.parse_block_expr(None, body_lo, BlockCheckMode::Default, ThinVec::new())?\n             }\n         };\n \n@@ -3277,7 +3285,7 @@ impl<'a> Parser<'a> {\n             return self.parse_if_expr(ThinVec::new());\n         } else {\n             let blk = self.parse_block()?;\n-            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk), ThinVec::new()));\n+            return Ok(self.mk_expr(blk.span, ExprKind::Block(blk, None), ThinVec::new()));\n         }\n     }\n "}, {"sha": "a700799cde564c24df903ea45f47967a16b9efa6", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -1792,7 +1792,7 @@ impl<'a> State<'a> {\n                         self.print_else(e.as_ref().map(|e| &**e))\n                     }\n                     // \"final else\"\n-                    ast::ExprKind::Block(ref b) => {\n+                    ast::ExprKind::Block(ref b, _) => {\n                         self.cbox(INDENT_UNIT - 1)?;\n                         self.ibox(0)?;\n                         self.s.word(\" else \")?;\n@@ -2182,7 +2182,11 @@ impl<'a> State<'a> {\n                 // empty box to satisfy the close.\n                 self.ibox(0)?;\n             }\n-            ast::ExprKind::Block(ref blk) => {\n+            ast::ExprKind::Block(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n+                    self.word_space(\":\")?;\n+                }\n                 // containing cbox, will be closed by print-block at }\n                 self.cbox(INDENT_UNIT)?;\n                 // head-box, will be closed by print-block after {\n@@ -2695,7 +2699,12 @@ impl<'a> State<'a> {\n         self.word_space(\"=>\")?;\n \n         match arm.body.node {\n-            ast::ExprKind::Block(ref blk) => {\n+            ast::ExprKind::Block(ref blk, opt_label) => {\n+                if let Some(label) = opt_label {\n+                    self.print_ident(label.ident)?;\n+                    self.word_space(\":\")?;\n+                }\n+\n                 // the block will close the pattern's ibox\n                 self.print_block_unclosed_indent(blk, INDENT_UNIT)?;\n "}, {"sha": "2013e838c05cc7f1c747afb8747833dc55834de8", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -736,7 +736,10 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n                              expression.span,\n                              expression.id)\n         }\n-        ExprKind::Block(ref block) => visitor.visit_block(block),\n+        ExprKind::Block(ref block, ref opt_label) => {\n+            walk_list!(visitor, visit_label, opt_label);\n+            visitor.visit_block(block);\n+        }\n         ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n             visitor.visit_expr(left_hand_expression);\n             visitor.visit_expr(right_hand_expression);"}, {"sha": "444845e24dc7d34f1987d09ad331ba17eccb08ea", "filename": "src/test/run-pass/label_break_value.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Frun-pass%2Flabel_break_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Frun-pass%2Flabel_break_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flabel_break_value.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -0,0 +1,123 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(label_break_value)]\n+\n+// Test control flow to follow label_break_value semantics\n+fn label_break(a: bool, b: bool) -> u32 {\n+    let mut v = 0;\n+    'b: {\n+        v = 1;\n+        if a {\n+            break 'b;\n+        }\n+        v = 2;\n+        if b {\n+            break 'b;\n+        }\n+        v = 3;\n+    }\n+    return v;\n+}\n+\n+// Test that values can be returned\n+fn break_value(a: bool, b: bool) -> u32 {\n+    let result = 'block: {\n+        if a { break 'block 1; }\n+        if b { break 'block 2; }\n+        3\n+    };\n+    result\n+}\n+\n+// Test nesting of labeled blocks\n+// here we only check that it compiles\n+fn label_break_nested() {\n+    'b: {\n+        println!(\"hi\");\n+        if false {\n+            break 'b;\n+        }\n+        'c: {\n+            if false {\n+                break 'b;\n+            }\n+            break 'c;\n+        }\n+        println!(\"hello\");\n+        if true {\n+            break 'b;\n+        }\n+    }\n+}\n+\n+// Tests for mixing labeled blocks with loop constructs\n+// This function should be the identity function\n+fn label_break_mixed(v: u32) -> u32 {\n+    let mut r = 0;\n+    'b: {\n+        // Unlabeled break still works\n+        // (only crossing boundaries is an error)\n+        loop {\n+            break;\n+        }\n+        if v == 0 {\n+            break 'b;\n+        }\n+        // Labeled breaking an inner loop still works\n+        'c: loop {\n+            if r == 1 {\n+                break 'c;\n+            }\n+            r += 1;\n+        }\n+        assert_eq!(r, 1);\n+        if v == 1 {\n+            break 'b;\n+        }\n+        // Labeled breaking an outer loop still works\n+        'd: loop {\n+            'e: {\n+                if v == r {\n+                    break 'b;\n+                }\n+                if r == 5 {\n+                    break 'd;\n+                }\n+                r += 1;\n+            }\n+        }\n+        assert_eq!(r, 5);\n+        assert!(v > r);\n+        // Here we test return from inside a labeled block\n+        return v;\n+    }\n+    r\n+}\n+\n+pub fn main() {\n+    assert_eq!(label_break(true, false), 1);\n+    assert_eq!(label_break(false, true), 2);\n+    assert_eq!(label_break(false, false), 3);\n+\n+    assert_eq!(break_value(true, false), 1);\n+    assert_eq!(break_value(false, true), 2);\n+    assert_eq!(break_value(false, false), 3);\n+\n+    assert_eq!(label_break_mixed(0), 0);\n+    assert_eq!(label_break_mixed(1), 1);\n+    assert_eq!(label_break_mixed(2), 2);\n+    assert_eq!(label_break_mixed(3), 3);\n+    assert_eq!(label_break_mixed(4), 4);\n+    assert_eq!(label_break_mixed(5), 5);\n+    assert_eq!(label_break_mixed(6), 6);\n+\n+    // FIXME: ensure that labeled blocks work if produced by macros and in match arms\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/compare-method/proj-outlives-region.stdout", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fproj-outlives-region.stdout?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/compare-method/region-extra.stdout", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-extra.stdout?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/compare-method/region-unrelated.stdout", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fregion-unrelated.stdout?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/const-eval/const_transmute.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fconst-eval%2Fconst_transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fconst-eval%2Fconst_transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fconst_transmute.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/const-expr-addr-operator.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fconst-expr-addr-operator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fconst-expr-addr-operator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-expr-addr-operator.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/const-pattern-not-const-evaluable.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-pattern-not-const-evaluable.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/feature-gate-const-indexing.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-const-indexing.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "dcda7580bda410fc316e0be925d35727409f8e72", "filename": "src/test/ui/feature-gate-label_break_value.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Ffeature-gate-label_break_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Ffeature-gate-label_break_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-label_break_value.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    'a: { //~ ERROR labels on blocks are unstable\n+        break 'a;\n+    }\n+}"}, {"sha": "8e8f31e78713306b4a046c9656cd824920826a69", "filename": "src/test/ui/feature-gate-label_break_value.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Ffeature-gate-label_break_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Ffeature-gate-label_break_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-label_break_value.stderr?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: labels on blocks are unstable (see issue #48594)\n+  --> $DIR/feature-gate-label_break_value.rs:12:5\n+   |\n+LL |     'a: { //~ ERROR labels on blocks are unstable\n+   |     ^^\n+   |\n+   = help: add #![feature(label_break_value)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/issue-38875/issue_38875.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-38875%2Fissue_38875.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "52e24b759d1d21bca8f549e05b2ee4871ac1ea83", "filename": "src/test/ui/label_break_value_continue.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel_break_value_continue.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(label_break_value)]\n+\n+// Simple continue pointing to an unlabeled break should yield in an error\n+fn continue_simple() {\n+    'b: {\n+        continue; //~ ERROR unlabeled `continue` inside of a labeled block\n+    }\n+}\n+\n+// Labeled continue pointing to an unlabeled break should yield in an error\n+fn continue_labeled() {\n+    'b: {\n+        continue 'b; //~ ERROR `continue` pointing to a labeled block\n+    }\n+}\n+\n+// Simple continue that would cross a labeled block should yield in an error\n+fn continue_crossing() {\n+    loop {\n+        'b: {\n+            continue; //~ ERROR unlabeled `continue` inside of a labeled block\n+        }\n+    }\n+}\n+\n+pub fn main() {}"}, {"sha": "24c2d1a22d01cc751b169658433075570681d70f", "filename": "src/test/ui/label_break_value_continue.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel_break_value_continue.stderr?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -0,0 +1,30 @@\n+error[E0695]: unlabeled `continue` inside of a labeled block\n+  --> $DIR/label_break_value_continue.rs:16:9\n+   |\n+LL |         continue; //~ ERROR unlabeled `continue` inside of a labeled block\n+   |         ^^^^^^^^ `continue` statements that would diverge to or through a labeled block need to bear a label\n+\n+error[E0696]: `continue` pointing to a labeled block\n+  --> $DIR/label_break_value_continue.rs:23:9\n+   |\n+LL |         continue 'b; //~ ERROR `continue` pointing to a labeled block\n+   |         ^^^^^^^^^^^ labeled blocks cannot be `continue`'d\n+   |\n+note: labeled block the continue points to\n+  --> $DIR/label_break_value_continue.rs:22:5\n+   |\n+LL | /     'b: {\n+LL | |         continue 'b; //~ ERROR `continue` pointing to a labeled block\n+LL | |     }\n+   | |_____^\n+\n+error[E0695]: unlabeled `continue` inside of a labeled block\n+  --> $DIR/label_break_value_continue.rs:31:13\n+   |\n+LL |             continue; //~ ERROR unlabeled `continue` inside of a labeled block\n+   |             ^^^^^^^^ `continue` statements that would diverge to or through a labeled block need to bear a label\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0695, E0696.\n+For more information about an error, try `rustc --explain E0695`."}, {"sha": "18644033e4ff885b26d04ad9bfa3c70477696114", "filename": "src/test/ui/label_break_value_illegal_uses.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_illegal_uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_illegal_uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel_break_value_illegal_uses.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(label_break_value)]\n+\n+// These are forbidden occurences of label-break-value\n+\n+fn labeled_unsafe() {\n+    unsafe 'b: {} //~ ERROR expected one of `extern`, `fn`, or `{`\n+}\n+\n+fn labeled_if() {\n+    if true 'b: {} //~ ERROR expected `{`, found `'b`\n+}\n+\n+fn labeled_else() {\n+    if true {} else 'b: {} //~ ERROR expected `{`, found `'b`\n+}\n+\n+fn labeled_match() {\n+    match false 'b: {} //~ ERROR expected one of `.`, `?`, `{`, or an operator\n+}\n+\n+pub fn main() {}"}, {"sha": "0ab1ad2c24200360595147b43f83da6a71ffeb79", "filename": "src/test/ui/label_break_value_illegal_uses.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_illegal_uses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_illegal_uses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel_break_value_illegal_uses.stderr?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -0,0 +1,31 @@\n+error: expected one of `extern`, `fn`, or `{`, found `'b`\n+  --> $DIR/label_break_value_illegal_uses.rs:16:12\n+   |\n+LL |     unsafe 'b: {} //~ ERROR expected one of `extern`, `fn`, or `{`\n+   |            ^^ expected one of `extern`, `fn`, or `{` here\n+\n+error: expected `{`, found `'b`\n+  --> $DIR/label_break_value_illegal_uses.rs:20:13\n+   |\n+LL |     if true 'b: {} //~ ERROR expected `{`, found `'b`\n+   |     --      ^^----\n+   |     |       |\n+   |     |       help: try placing this code inside a block: `{ 'b: { } }`\n+   |     this `if` statement has a condition, but no block\n+\n+error: expected `{`, found `'b`\n+  --> $DIR/label_break_value_illegal_uses.rs:24:21\n+   |\n+LL |     if true {} else 'b: {} //~ ERROR expected `{`, found `'b`\n+   |                     ^^----\n+   |                     |\n+   |                     help: try placing this code inside a block: `{ 'b: { } }`\n+\n+error: expected one of `.`, `?`, `{`, or an operator, found `'b`\n+  --> $DIR/label_break_value_illegal_uses.rs:28:17\n+   |\n+LL |     match false 'b: {} //~ ERROR expected one of `.`, `?`, `{`, or an operator\n+   |                 ^^ expected one of `.`, `?`, `{`, or an operator here\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "38918da291c8662d7e3d0663baa08f325c808338", "filename": "src/test/ui/label_break_value_unlabeled_break.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_unlabeled_break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_unlabeled_break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel_break_value_unlabeled_break.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(label_break_value)]\n+\n+// Simple unlabeled break should yield in an error\n+fn unlabeled_break_simple() {\n+    'b: {\n+        break; //~ ERROR unlabeled `break` inside of a labeled block\n+    }\n+}\n+\n+// Unlabeled break that would cross a labeled block should yield in an error\n+fn unlabeled_break_crossing() {\n+    loop {\n+        'b: {\n+            break; //~ ERROR unlabeled `break` inside of a labeled block\n+        }\n+    }\n+}\n+\n+pub fn main() {}"}, {"sha": "8a25975a7bda2bb6eae4ba276e86c9b32df608ba", "filename": "src/test/ui/label_break_value_unlabeled_break.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_unlabeled_break.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Flabel_break_value_unlabeled_break.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flabel_break_value_unlabeled_break.stderr?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -0,0 +1,15 @@\n+error[E0695]: unlabeled `break` inside of a labeled block\n+  --> $DIR/label_break_value_unlabeled_break.rs:16:9\n+   |\n+LL |         break; //~ ERROR unlabeled `break` inside of a labeled block\n+   |         ^^^^^ `break` statements that would diverge to or through a labeled block need to bear a label\n+\n+error[E0695]: unlabeled `break` inside of a labeled block\n+  --> $DIR/label_break_value_unlabeled_break.rs:24:13\n+   |\n+LL |             break; //~ ERROR unlabeled `break` inside of a labeled block\n+   |             ^^^^^ `break` statements that would diverge to or through a labeled block need to bear a label\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0695`."}, {"sha": "68a2bab1674e83633b41306bbb81244e9afc3808", "filename": "src/test/ui/loop-break-value-no-repeat.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Floop-break-value-no-repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftest%2Fui%2Floop-break-value-no-repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floop-break-value-no-repeat.stderr?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -2,7 +2,7 @@ error[E0571]: `break` with value from a `for` loop\n   --> $DIR/loop-break-value-no-repeat.rs:22:9\n    |\n LL |         break 22 //~ ERROR `break` with value from a `for` loop\n-   |         ^^^^^^^^ can only break with a value inside `loop`\n+   |         ^^^^^^^^ can only break with a value inside `loop` or breakable block\n help: instead, use `break` on its own without a value inside this `for` loop\n    |\n LL |         break //~ ERROR `break` with value from a `for` loop"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/nll/drop-may-dangle.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdrop-may-dangle.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/nll/maybe-initialized-drop-uninitialized.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/nll/ty-outlives/ty-param-implied-bounds.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-implied-bounds.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/anonymous.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/anonymous.stdout", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.stdout?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/multiple_types.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/packed.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/print_type_sizes/repr-align.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Frepr-align.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/reachable/expr_andand.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Freachable%2Fexpr_andand.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Freachable%2Fexpr_andand.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_andand.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/reachable/expr_oror.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Freachable%2Fexpr_oror.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Freachable%2Fexpr_oror.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freachable%2Fexpr_oror.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/rfc1598-generic-associated-types/generic-associated-types-where.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/rfc1598-generic-associated-types/shadowing.stdout", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fshadowing.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fshadowing.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fshadowing.stdout?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/trivial-bounds-inconsistent-associated-functions.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-associated-functions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-associated-functions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-associated-functions.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/union/union-const-eval.stderr", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Funion%2Funion-const-eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0306630925bf4ab112bf1778bea0b27919b1cc8f/src%2Ftest%2Fui%2Funion%2Funion-const-eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-const-eval.stderr?ref=0306630925bf4ab112bf1778bea0b27919b1cc8f"}, {"sha": "c15744078077e3d376347c5a518064308f7db9ae", "filename": "src/tools/tidy/src/ui_tests.rs", "status": "modified", "additions": 40, "deletions": 23, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fui_tests.rs?ref=63ea42fd3c82c629a0e5a8b981bdaeb30cdc0253", "patch": "@@ -10,32 +10,49 @@\n \n //! Tidy check to ensure that there are no stray `.stderr` files in UI test directories.\n \n+use std::fs;\n use std::path::Path;\n \n pub fn check(path: &Path, bad: &mut bool) {\n-    super::walk_many(&[&path.join(\"test/ui\"), &path.join(\"test/ui-fulldeps\")],\n-                     &mut |_| false,\n-                     &mut |file_path| {\n-        if let Some(ext) = file_path.extension() {\n-            if ext == \"stderr\" || ext == \"stdout\" {\n-                // Test output filenames have the format:\n-                // $testname.stderr\n-                // $testname.$mode.stderr\n-                // $testname.$revision.stderr\n-                // $testname.$revision.$mode.stderr\n-                //\n-                // For now, just make sure that there is a corresponding\n-                // $testname.rs file.\n-                let testname = file_path.file_name().unwrap()\n-                                        .to_str().unwrap()\n-                                        .splitn(2, '.').next().unwrap();\n-                if !file_path.with_file_name(testname)\n-                             .with_extension(\"rs\")\n-                             .exists() {\n-                    println!(\"Stray file with UI testing output: {:?}\", file_path);\n-                    *bad = true;\n+    super::walk_many(\n+        &[&path.join(\"test/ui\"), &path.join(\"test/ui-fulldeps\")],\n+        &mut |_| false,\n+        &mut |file_path| {\n+            if let Some(ext) = file_path.extension() {\n+                if ext == \"stderr\" || ext == \"stdout\" {\n+                    // Test output filenames have the format:\n+                    // $testname.stderr\n+                    // $testname.$mode.stderr\n+                    // $testname.$revision.stderr\n+                    // $testname.$revision.$mode.stderr\n+                    //\n+                    // For now, just make sure that there is a corresponding\n+                    // $testname.rs file.\n+                    let testname = file_path\n+                        .file_name()\n+                        .unwrap()\n+                        .to_str()\n+                        .unwrap()\n+                        .splitn(2, '.')\n+                        .next()\n+                        .unwrap();\n+                    if !file_path\n+                        .with_file_name(testname)\n+                        .with_extension(\"rs\")\n+                        .exists()\n+                    {\n+                        println!(\"Stray file with UI testing output: {:?}\", file_path);\n+                        *bad = true;\n+                    }\n+\n+                    if let Ok(metadata) = fs::metadata(file_path) {\n+                        if metadata.len() == 0 {\n+                            println!(\"Empty file with UI testing output: {:?}\", file_path);\n+                            *bad = true;\n+                        }\n+                    }\n                 }\n             }\n-        }\n-    });\n+        },\n+    );\n }"}]}