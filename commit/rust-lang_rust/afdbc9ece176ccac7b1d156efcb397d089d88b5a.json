{"sha": "afdbc9ece176ccac7b1d156efcb397d089d88b5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmZGJjOWVjZTE3NmNjYWM3YjFkMTU2ZWZjYjM5N2QwODlkODhiNWE=", "commit": {"author": {"name": "Soveu", "email": "marx.tomasz@gmail.com", "date": "2021-03-15T19:36:29Z"}, "committer": {"name": "Soveu", "email": "marx.tomasz@gmail.com", "date": "2021-03-15T19:36:29Z"}, "message": "Vec::dedup optimization - finishing polishes", "tree": {"sha": "d8480cfdae421942750ad22160eda06c9a2216a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8480cfdae421942750ad22160eda06c9a2216a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afdbc9ece176ccac7b1d156efcb397d089d88b5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afdbc9ece176ccac7b1d156efcb397d089d88b5a", "html_url": "https://github.com/rust-lang/rust/commit/afdbc9ece176ccac7b1d156efcb397d089d88b5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afdbc9ece176ccac7b1d156efcb397d089d88b5a/comments", "author": {"login": "Soveu", "id": 34382234, "node_id": "MDQ6VXNlcjM0MzgyMjM0", "avatar_url": "https://avatars.githubusercontent.com/u/34382234?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Soveu", "html_url": "https://github.com/Soveu", "followers_url": "https://api.github.com/users/Soveu/followers", "following_url": "https://api.github.com/users/Soveu/following{/other_user}", "gists_url": "https://api.github.com/users/Soveu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Soveu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Soveu/subscriptions", "organizations_url": "https://api.github.com/users/Soveu/orgs", "repos_url": "https://api.github.com/users/Soveu/repos", "events_url": "https://api.github.com/users/Soveu/events{/privacy}", "received_events_url": "https://api.github.com/users/Soveu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Soveu", "id": 34382234, "node_id": "MDQ6VXNlcjM0MzgyMjM0", "avatar_url": "https://avatars.githubusercontent.com/u/34382234?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Soveu", "html_url": "https://github.com/Soveu", "followers_url": "https://api.github.com/users/Soveu/followers", "following_url": "https://api.github.com/users/Soveu/following{/other_user}", "gists_url": "https://api.github.com/users/Soveu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Soveu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Soveu/subscriptions", "organizations_url": "https://api.github.com/users/Soveu/orgs", "repos_url": "https://api.github.com/users/Soveu/repos", "events_url": "https://api.github.com/users/Soveu/events{/privacy}", "received_events_url": "https://api.github.com/users/Soveu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2abab1f688fe0d4a740b216b298f32fbb48b653b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2abab1f688fe0d4a740b216b298f32fbb48b653b", "html_url": "https://github.com/rust-lang/rust/commit/2abab1f688fe0d4a740b216b298f32fbb48b653b"}], "stats": {"total": 18, "additions": 7, "deletions": 11}, "files": [{"sha": "19198d4eeefd9ac6679e3181ade42f9c84d5b32c", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/afdbc9ece176ccac7b1d156efcb397d089d88b5a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afdbc9ece176ccac7b1d156efcb397d089d88b5a/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=afdbc9ece176ccac7b1d156efcb397d089d88b5a", "patch": "@@ -1538,13 +1538,9 @@ impl<T, A: Allocator> Vec<T, A> {\n \n         impl<'a, T, A: core::alloc::Allocator> Drop for FillGapOnDrop<'a, T, A> {\n             fn drop(&mut self) {\n-                /* This code gets executed either at the end of `dedup_by` or\n-                 * when `same_bucket` panics */\n+                /* This code gets executed when `same_bucket` panics */\n \n-                /* SAFETY (if finishing successfully): self.read == len, so\n-                 * no data is copied and length is set correctly */\n-\n-                /* SAFETY (if panicing): invariant guarantees that `read - write`\n+                /* SAFETY: invariant guarantees that `read - write`\n                  * and `len - read` never overflow and that the copy is always\n                  * in-bounds. */\n                 unsafe {\n@@ -1553,7 +1549,7 @@ impl<T, A: Allocator> Vec<T, A> {\n \n                     /* How many items were left when `same_bucket` paniced.\n                      * Basically vec[read..].len() */\n-                    let items_left = len - self.read;\n+                    let items_left = len.wrapping_sub(self.read);\n \n                     /* Pointer to first item in vec[write..write+items_left] slice */\n                     let dropped_ptr = ptr.add(self.write);\n@@ -1566,15 +1562,14 @@ impl<T, A: Allocator> Vec<T, A> {\n \n                     /* How many items have been already dropped\n                      * Basically vec[read..write].len() */\n-                    let dropped = self.read - self.write;\n+                    let dropped = self.read.wrapping_sub(self.write);\n \n                     self.vec.set_len(len - dropped);\n                 }\n             }\n         }\n \n         let mut gap = FillGapOnDrop { read: 1, write: 1, vec: self };\n-\n         let ptr = gap.vec.as_mut_ptr();\n \n         /* Drop items while going through Vec, it should be more efficient than\n@@ -1593,8 +1588,9 @@ impl<T, A: Allocator> Vec<T, A> {\n                 } else {\n                     let write_ptr = ptr.add(gap.write);\n \n-                    /* Looks like doing just `copy` can be faster than\n-                     * conditional `copy_nonoverlapping` */\n+                    /* Because `read_ptr` can be equal to `write_ptr`, we either\n+                     * have to use `copy` or conditional `copy_nonoverlapping`.\n+                     * Looks like the first option is faster. */\n                     ptr::copy(read_ptr, write_ptr, 1);\n \n                     /* We have filled that place, so go further */"}]}