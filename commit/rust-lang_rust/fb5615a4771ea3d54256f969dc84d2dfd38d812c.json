{"sha": "fb5615a4771ea3d54256f969dc84d2dfd38d812c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiNTYxNWE0NzcxZWEzZDU0MjU2Zjk2OWRjODRkMmRmZDM4ZDgxMmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-28T05:01:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-28T05:01:27Z"}, "message": "Auto merge of #71292 - marmeladema:queries-local-def-id, r=eddyb\n\nConvert more queries to use `LocalDefId`\n\nThis PR is based on commits in https://github.com/rust-lang/rust/pull/71215 and should partially solve #70853", "tree": {"sha": "a02609df0f068818972925187e7e5c3ce61cdf96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a02609df0f068818972925187e7e5c3ce61cdf96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb5615a4771ea3d54256f969dc84d2dfd38d812c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5615a4771ea3d54256f969dc84d2dfd38d812c", "html_url": "https://github.com/rust-lang/rust/commit/fb5615a4771ea3d54256f969dc84d2dfd38d812c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb5615a4771ea3d54256f969dc84d2dfd38d812c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6db2094c909309ab1c25a571d6111825b49c822c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6db2094c909309ab1c25a571d6111825b49c822c", "html_url": "https://github.com/rust-lang/rust/commit/6db2094c909309ab1c25a571d6111825b49c822c"}, {"sha": "1349272a6e0f923da21b81414ad2a92f2cbbeda9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1349272a6e0f923da21b81414ad2a92f2cbbeda9", "html_url": "https://github.com/rust-lang/rust/commit/1349272a6e0f923da21b81414ad2a92f2cbbeda9"}], "stats": {"total": 527, "additions": 288, "deletions": 239}, "files": [{"sha": "92e210cdd8cb764d8fc3577d0a89b14e6f5d257d", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -290,7 +290,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n             spflags |= DISPFlags::SPFlagOptimized;\n         }\n         if let Some((id, _)) = self.tcx.entry_fn(LOCAL_CRATE) {\n-            if id == def_id {\n+            if id.to_def_id() == def_id {\n                 spflags |= DISPFlags::SPFlagMainSubprogram;\n             }\n         }"}, {"sha": "cd43ca8257e926b7c7544d4415b721454b448898", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -30,7 +30,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::print_time_passes_entry;\n use rustc_data_structures::sync::{par_iter, Lock, ParallelIterator};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::lang_items::StartFnLangItem;\n use rustc_index::vec::Idx;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n@@ -397,7 +397,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         None => return None,\n     };\n \n-    let instance = Instance::mono(cx.tcx(), main_def_id);\n+    let instance = Instance::mono(cx.tcx(), main_def_id.to_def_id());\n \n     if !cx.codegen_unit().contains_item(&MonoItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n@@ -416,7 +416,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         cx: &'a Bx::CodegenCx,\n         sp: Span,\n         rust_main: Bx::Value,\n-        rust_main_def_id: DefId,\n+        rust_main_def_id: LocalDefId,\n         use_start_lang_item: bool,\n     ) -> Bx::Function {\n         // The entry function is either `int main(void)` or `int main(int argc, char **argv)`,"}, {"sha": "9a8a05713c8d45319ea786b3058a050727b9b555", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -835,7 +835,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n     });\n \n     sess.time(\"MIR_borrow_checking\", || {\n-        tcx.par_body_owners(|def_id| tcx.ensure().mir_borrowck(def_id.to_def_id()));\n+        tcx.par_body_owners(|def_id| tcx.ensure().mir_borrowck(def_id));\n     });\n \n     sess.time(\"dumping_chalk_like_clauses\", || {"}, {"sha": "9e8f3a84e20e9b0f5714497464c89f6c3422c630", "filename": "src/librustc_interface/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_interface%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_interface%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fqueries.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -293,7 +293,7 @@ impl<'tcx> Queries<'tcx> {\n             _ => return,\n         };\n \n-        let attrs = &*tcx.get_attrs(def_id);\n+        let attrs = &*tcx.get_attrs(def_id.to_def_id());\n         let attrs = attrs.iter().filter(|attr| attr.check_name(sym::rustc_error));\n         for attr in attrs {\n             match attr.meta_item_list() {"}, {"sha": "4033c2b28494cf692c8445388f5cb46c6c31b7c4", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -56,7 +56,7 @@ mod unused;\n \n use rustc_ast::ast;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::{\n@@ -90,12 +90,8 @@ pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { lint_mod, ..*providers };\n }\n \n-fn lint_mod(tcx: TyCtxt<'_>, module_def_id: DefId) {\n-    late::late_lint_mod(\n-        tcx,\n-        module_def_id.expect_local(),\n-        BuiltinCombinedModuleLateLintPass::new(),\n-    );\n+fn lint_mod(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n+    late::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n }\n \n macro_rules! pre_expansion_lint_passes {"}, {"sha": "da1dd1e589b00605af945d1baa4361d0ae0d0f67", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -5,12 +5,11 @@ use log::{debug, trace};\n use rustc_ast::ast::{self, Ident};\n use rustc_ast::attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, Lrc};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n-use rustc_hir::def_id::DefIdSet;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathTable;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -644,8 +643,8 @@ impl EncodeContext<'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n-        self.encode_optimized_mir(def_id);\n-        self.encode_promoted_mir(def_id);\n+        self.encode_optimized_mir(def_id.expect_local());\n+        self.encode_promoted_mir(def_id.expect_local());\n     }\n \n     fn encode_enum_variant_ctor(&mut self, def: &ty::AdtDef, index: VariantIdx) {\n@@ -683,8 +682,8 @@ impl EncodeContext<'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n-        self.encode_optimized_mir(def_id);\n-        self.encode_promoted_mir(def_id);\n+        self.encode_optimized_mir(def_id.expect_local());\n+        self.encode_promoted_mir(def_id.expect_local());\n     }\n \n     fn encode_info_for_mod(\n@@ -786,8 +785,8 @@ impl EncodeContext<'tcx> {\n         self.encode_generics(def_id);\n         self.encode_explicit_predicates(def_id);\n         self.encode_inferred_outlives(def_id);\n-        self.encode_optimized_mir(def_id);\n-        self.encode_promoted_mir(def_id);\n+        self.encode_optimized_mir(def_id.expect_local());\n+        self.encode_promoted_mir(def_id.expect_local());\n     }\n \n     fn encode_generics(&mut self, def_id: DefId) {\n@@ -896,8 +895,8 @@ impl EncodeContext<'tcx> {\n         self.encode_inferred_outlives(def_id);\n \n         // This should be kept in sync with `PrefetchVisitor.visit_trait_item`.\n-        self.encode_optimized_mir(def_id);\n-        self.encode_promoted_mir(def_id);\n+        self.encode_optimized_mir(def_id.expect_local());\n+        self.encode_promoted_mir(def_id.expect_local());\n     }\n \n     fn metadata_output_only(&self) -> bool {\n@@ -985,8 +984,8 @@ impl EncodeContext<'tcx> {\n             hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(..) => false,\n         };\n         if mir {\n-            self.encode_optimized_mir(def_id);\n-            self.encode_promoted_mir(def_id);\n+            self.encode_optimized_mir(def_id.expect_local());\n+            self.encode_promoted_mir(def_id.expect_local());\n         }\n     }\n \n@@ -1004,17 +1003,17 @@ impl EncodeContext<'tcx> {\n         self.lazy(param_names.iter().map(|ident| ident.name))\n     }\n \n-    fn encode_optimized_mir(&mut self, def_id: DefId) {\n+    fn encode_optimized_mir(&mut self, def_id: LocalDefId) {\n         debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            record!(self.tables.mir[def_id] <- self.tcx.optimized_mir(def_id));\n+            record!(self.tables.mir[def_id.to_def_id()] <- self.tcx.optimized_mir(def_id));\n         }\n     }\n \n-    fn encode_promoted_mir(&mut self, def_id: DefId) {\n+    fn encode_promoted_mir(&mut self, def_id: LocalDefId) {\n         debug!(\"EncodeContext::encode_promoted_mir({:?})\", def_id);\n         if self.tcx.mir_keys(LOCAL_CRATE).contains(&def_id) {\n-            record!(self.tables.promoted_mir[def_id] <- self.tcx.promoted_mir(def_id));\n+            record!(self.tables.promoted_mir[def_id.to_def_id()] <- self.tcx.promoted_mir(def_id));\n         }\n     }\n \n@@ -1282,8 +1281,8 @@ impl EncodeContext<'tcx> {\n             _ => false,\n         };\n         if mir {\n-            self.encode_optimized_mir(def_id);\n-            self.encode_promoted_mir(def_id);\n+            self.encode_optimized_mir(def_id.expect_local());\n+            self.encode_promoted_mir(def_id.expect_local());\n         }\n     }\n \n@@ -1316,8 +1315,7 @@ impl EncodeContext<'tcx> {\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n         let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n \n-        let def_id = def_id.to_def_id();\n-        record!(self.tables.kind[def_id] <- match ty.kind {\n+        record!(self.tables.kind[def_id.to_def_id()] <- match ty.kind {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n                 EntryKind::Generator(data)\n@@ -1327,14 +1325,14 @@ impl EncodeContext<'tcx> {\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         });\n-        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n-        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n-        record!(self.tables.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n-        self.encode_item_type(def_id);\n+        record!(self.tables.visibility[def_id.to_def_id()] <- ty::Visibility::Public);\n+        record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n+        record!(self.tables.attributes[def_id.to_def_id()] <- &self.tcx.get_attrs(def_id.to_def_id())[..]);\n+        self.encode_item_type(def_id.to_def_id());\n         if let ty::Closure(def_id, substs) = ty.kind {\n             record!(self.tables.fn_sig[def_id] <- substs.as_closure().sig());\n         }\n-        self.encode_generics(def_id);\n+        self.encode_generics(def_id.to_def_id());\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -1344,16 +1342,15 @@ impl EncodeContext<'tcx> {\n         let id = self.tcx.hir().as_local_hir_id(def_id);\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n-        let def_id = def_id.to_def_id();\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n \n-        record!(self.tables.kind[def_id] <- EntryKind::Const(qualifs, const_data));\n-        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n-        record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n-        self.encode_item_type(def_id);\n-        self.encode_generics(def_id);\n-        self.encode_explicit_predicates(def_id);\n-        self.encode_inferred_outlives(def_id);\n+        record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Const(qualifs, const_data));\n+        record!(self.tables.visibility[def_id.to_def_id()] <- ty::Visibility::Public);\n+        record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n+        self.encode_item_type(def_id.to_def_id());\n+        self.encode_generics(def_id.to_def_id());\n+        self.encode_explicit_predicates(def_id.to_def_id());\n+        self.encode_inferred_outlives(def_id.to_def_id());\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n     }\n@@ -1726,12 +1723,11 @@ impl<'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'tcx> {\n /// Only a subset of the queries are actually prefetched to keep this code smaller.\n struct PrefetchVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    mir_keys: &'tcx DefIdSet,\n+    mir_keys: &'tcx FxHashSet<LocalDefId>,\n }\n \n impl<'tcx> PrefetchVisitor<'tcx> {\n     fn prefetch_mir(&self, def_id: LocalDefId) {\n-        let def_id = def_id.to_def_id();\n         if self.mir_keys.contains(&def_id) {\n             self.tcx.optimized_mir(def_id);\n             self.tcx.promoted_mir(def_id);"}, {"sha": "d0f700299477045166f1792dfda4c150443005e5", "filename": "src/librustc_middle/arena.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Farena.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -34,7 +34,8 @@ macro_rules! arena_types {\n                 rustc_hir::def_id::DefId,\n                 rustc_middle::ty::subst::SubstsRef<$tcx>\n             )>,\n-            [few, decode] mir_keys: rustc_hir::def_id::DefIdSet,\n+            [few, decode] collect_and_partition_mono_items: rustc_hir::def_id::DefIdSet,\n+            [few, decode] mir_keys: rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>,\n             [decode] specialization_graph: rustc_middle::traits::specialization_graph::Graph,\n             [] region_scope_tree: rustc_middle::middle::region::ScopeTree,\n             [] item_local_set: rustc_hir::ItemLocalSet,"}, {"sha": "632607e3356266f8d18a56443645764512113b6b", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::base_n;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::HirId;\n use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n@@ -95,7 +95,7 @@ impl<'tcx> MonoItem<'tcx> {\n                 // linkage, then we'll be creating a globally shared version.\n                 if self.explicit_linkage(tcx).is_some()\n                     || !instance.def.generates_cgu_internal_copy(tcx)\n-                    || Some(instance.def_id()) == entry_def_id\n+                    || Some(instance.def_id()) == entry_def_id.map(LocalDefId::to_def_id)\n                 {\n                     return InstantiationMode::GloballyShared { may_conflict: false };\n                 }"}, {"sha": "c3e023f40299ed29275c96e75ba799ee0170dd04", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 40, "deletions": 30, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -156,7 +156,7 @@ rustc_queries! {\n         /// Set of all the `DefId`s in this crate that have MIR associated with\n         /// them. This includes all the body owners, but also things like struct\n         /// constructors.\n-        query mir_keys(_: CrateNum) -> &'tcx DefIdSet {\n+        query mir_keys(_: CrateNum) -> &'tcx FxHashSet<LocalDefId> {\n             desc { \"getting a list of all mir_keys\" }\n         }\n \n@@ -170,7 +170,7 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        query mir_built(_: LocalDefId) -> &'tcx Steal<mir::Body<'tcx>> {\n             desc { \"building MIR for\" }\n         }\n \n@@ -182,12 +182,13 @@ rustc_queries! {\n             no_hash\n         }\n \n-        query mir_validated(_: DefId) ->\n+        query mir_validated(key: LocalDefId) ->\n             (\n                 &'tcx Steal<mir::Body<'tcx>>,\n                 &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n             ) {\n             no_hash\n+            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n         /// MIR after our optimization passes have run. This is MIR that is ready\n@@ -275,9 +276,9 @@ rustc_queries! {\n \n         /// To avoid cycles within the predicates of a single item we compute\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n-        query type_param_predicates(key: (DefId, DefId)) -> ty::GenericPredicates<'tcx> {\n+        query type_param_predicates(key: (DefId, LocalDefId)) -> ty::GenericPredicates<'tcx> {\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n-                let id = tcx.hir().as_local_hir_id(key.1.expect_local());\n+                let id = tcx.hir().as_local_hir_id(key.1);\n                 tcx.hir().ty_param_name(id)\n             }}\n         }\n@@ -389,9 +390,9 @@ rustc_queries! {\n \n     TypeChecking {\n         /// The result of unsafety-checking this `DefId`.\n-        query unsafety_check_result(key: DefId) -> mir::UnsafetyCheckResult {\n-            desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key) }\n-            cache_on_disk_if { key.is_local() }\n+        query unsafety_check_result(key: LocalDefId) -> mir::UnsafetyCheckResult {\n+            desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            cache_on_disk_if { true }\n         }\n \n         /// HACK: when evaluated, this reports a \"unsafe derive on repr(packed)\" error\n@@ -402,8 +403,8 @@ rustc_queries! {\n     }\n \n     Other {\n-        query lint_mod(key: DefId) -> () {\n-            desc { |tcx| \"linting {}\", describe_as_module(key, tcx) }\n+        query lint_mod(key: LocalDefId) -> () {\n+            desc { |tcx| \"linting {}\", describe_as_module(key.to_def_id(), tcx) }\n         }\n \n         /// Checks the attributes in the module.\n@@ -429,8 +430,8 @@ rustc_queries! {\n             desc { |tcx| \"checking item types in {}\", describe_as_module(key, tcx) }\n         }\n \n-        query check_mod_privacy(key: DefId) -> () {\n-            desc { |tcx| \"checking privacy in {}\", describe_as_module(key, tcx) }\n+        query check_mod_privacy(key: LocalDefId) -> () {\n+            desc { |tcx| \"checking privacy in {}\", describe_as_module(key.to_def_id(), tcx) }\n         }\n \n         query check_mod_intrinsics(key: DefId) -> () {\n@@ -459,12 +460,13 @@ rustc_queries! {\n             desc { \"type-checking all item bodies\" }\n         }\n \n-        query typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n-            desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key) }\n-            cache_on_disk_if { key.is_local() }\n+        query typeck_tables_of(key: LocalDefId) -> &'tcx ty::TypeckTables<'tcx> {\n+            desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            cache_on_disk_if { true }\n         }\n-        query diagnostic_only_typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n-            cache_on_disk_if { key.is_local() }\n+        query diagnostic_only_typeck_tables_of(key: LocalDefId) -> &'tcx ty::TypeckTables<'tcx> {\n+            desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            cache_on_disk_if { true }\n             load_cached(tcx, id) {\n                 let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n                     .queries.on_disk_cache\n@@ -476,8 +478,9 @@ rustc_queries! {\n     }\n \n     Other {\n-        query used_trait_imports(key: DefId) -> &'tcx DefIdSet {\n-            cache_on_disk_if { key.is_local() }\n+        query used_trait_imports(key: LocalDefId) -> &'tcx DefIdSet {\n+            desc { |tcx| \"used_trait_imports `{}`\", tcx.def_path_str(key.to_def_id()) }\n+            cache_on_disk_if { true }\n         }\n     }\n \n@@ -492,12 +495,11 @@ rustc_queries! {\n     BorrowChecking {\n         /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n-        query mir_borrowck(key: DefId) -> &'tcx mir::BorrowCheckResult<'tcx> {\n-            desc { |tcx| \"borrow-checking `{}`\", tcx.def_path_str(key) }\n+        query mir_borrowck(key: LocalDefId) -> &'tcx mir::BorrowCheckResult<'tcx> {\n+            desc { |tcx| \"borrow-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n             cache_on_disk_if(tcx, opt_result) {\n-                key.is_local()\n-                    && (tcx.is_closure(key)\n-                        || opt_result.map_or(false, |r| !r.concrete_opaque_types.is_empty()))\n+                tcx.is_closure(key.to_def_id())\n+                    || opt_result.map_or(false, |r| !r.concrete_opaque_types.is_empty())\n             }\n         }\n     }\n@@ -802,9 +804,15 @@ rustc_queries! {\n     TypeChecking {\n         query impl_defaultness(_: DefId) -> hir::Defaultness {}\n \n-        query check_item_well_formed(_: DefId) -> () {}\n-        query check_trait_item_well_formed(_: DefId) -> () {}\n-        query check_impl_item_well_formed(_: DefId) -> () {}\n+        query check_item_well_formed(key: LocalDefId) -> () {\n+            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        }\n+        query check_trait_item_well_formed(key: LocalDefId) -> () {\n+            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        }\n+        query check_impl_item_well_formed(key: LocalDefId) -> () {\n+            desc { |tcx| \"processing `{}`\", tcx.def_path_str(key.to_def_id()) }\n+        }\n     }\n \n     Linking {\n@@ -878,7 +886,7 @@ rustc_queries! {\n \n         /// Identifies the entry-point (e.g., the `main` function) for a given\n         /// crate, returning `None` if there is no entry point (such as for library crates).\n-        query entry_fn(_: CrateNum) -> Option<(DefId, EntryFnType)> {\n+        query entry_fn(_: CrateNum) -> Option<(LocalDefId, EntryFnType)> {\n             desc { \"looking up the entry function of a crate\" }\n         }\n         query plugin_registrar_fn(_: CrateNum) -> Option<DefId> {\n@@ -1028,17 +1036,19 @@ rustc_queries! {\n         query upvars(_: DefId) -> Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>> {\n             eval_always\n         }\n-        query maybe_unused_trait_import(_: DefId) -> bool {\n+        query maybe_unused_trait_import(def_id: LocalDefId) -> bool {\n             eval_always\n+            desc { |tcx| \"maybe_unused_trait_import for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n         }\n         query maybe_unused_extern_crates(_: CrateNum)\n             -> &'tcx [(DefId, Span)] {\n             eval_always\n             desc { \"looking up all possibly unused extern crates\" }\n         }\n-        query names_imported_by_glob_use(_: DefId)\n+        query names_imported_by_glob_use(def_id: LocalDefId)\n             -> &'tcx FxHashSet<ast::Name> {\n             eval_always\n+            desc { |tcx| \"names_imported_by_glob_use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n         }\n \n         query stability_index(_: CrateNum) -> &'tcx stability::Index<'tcx> {"}, {"sha": "c5813ae57a653bde7468ed9c3e1b7efdd29b3c4d", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -945,11 +945,11 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub queries: query::Queries<'tcx>,\n \n-    maybe_unused_trait_imports: FxHashSet<DefId>,\n+    maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     maybe_unused_extern_crates: Vec<(DefId, Span)>,\n     /// A map of glob use to a set of names it actually imports. Currently only\n     /// used in save-analysis.\n-    glob_map: FxHashMap<DefId, FxHashSet<ast::Name>>,\n+    glob_map: FxHashMap<LocalDefId, FxHashSet<ast::Name>>,\n     /// Extern prelude entries. The value is `true` if the entry was introduced\n     /// via `extern crate` item and not `--extern` option or compiler built-in.\n     pub extern_prelude: FxHashMap<ast::Name, bool>,\n@@ -1165,7 +1165,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             maybe_unused_trait_imports: resolutions\n                 .maybe_unused_trait_imports\n                 .into_iter()\n-                .map(|id| definitions.local_def_id(id).to_def_id())\n+                .map(|id| definitions.local_def_id(id))\n                 .collect(),\n             maybe_unused_extern_crates: resolutions\n                 .maybe_unused_extern_crates\n@@ -1175,7 +1175,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             glob_map: resolutions\n                 .glob_map\n                 .into_iter()\n-                .map(|(id, names)| (definitions.local_def_id(id).to_def_id(), names))\n+                .map(|(id, names)| (definitions.local_def_id(id), names))\n                 .collect(),\n             extern_prelude: resolutions.extern_prelude,\n             untracked_crate: krate,\n@@ -2716,10 +2716,8 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         &tcx.maybe_unused_extern_crates[..]\n     };\n-    providers.names_imported_by_glob_use = |tcx, id| {\n-        assert_eq!(id.krate, LOCAL_CRATE);\n-        tcx.arena.alloc(tcx.glob_map.get(&id).cloned().unwrap_or_default())\n-    };\n+    providers.names_imported_by_glob_use =\n+        |tcx, id| tcx.arena.alloc(tcx.glob_map.get(&id).cloned().unwrap_or_default());\n \n     providers.lookup_stability = |tcx, id| {\n         let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());"}, {"sha": "0abe44b31065d2171a1ab4c316df7090196ad778", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -2637,7 +2637,7 @@ pub enum ImplOverlapKind {\n \n impl<'tcx> TyCtxt<'tcx> {\n     pub fn body_tables(self, body: hir::BodyId) -> &'tcx TypeckTables<'tcx> {\n-        self.typeck_tables_of(self.hir().body_owner_def_id(body).to_def_id())\n+        self.typeck_tables_of(self.hir().body_owner_def_id(body))\n     }\n \n     /// Returns an iterator of the `DefId`s for all body-owners in this"}, {"sha": "7354e89001cec7ba4da433ea67bee2d33dafc663", "filename": "src/librustc_middle/ty/query/keys.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fquery%2Fkeys.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -117,6 +117,17 @@ impl Key for (DefId, DefId) {\n     }\n }\n \n+impl Key for (DefId, LocalDefId) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n impl Key for (CrateNum, DefId) {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "749265458302554de459068eca8112e203f9cdf0", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -191,7 +191,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     .ty;\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n-                    let tables = self.infcx.tcx.typeck_tables_of(id);\n+                    let tables = self.infcx.tcx.typeck_tables_of(id.expect_local());\n                     let hir_id = self.infcx.tcx.hir().as_local_hir_id(id.expect_local());\n \n                     tables.closure_kind_origins().get(hir_id).is_none()\n@@ -880,7 +880,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 match &self\n                                     .infcx\n                                     .tcx\n-                                    .typeck_tables_of(self.mir_def_id)\n+                                    .typeck_tables_of(def_id)\n                                     .node_type(fn_hir_id)\n                                     .kind\n                                 {"}, {"sha": "9e4458e7104ff6b5bb5a049b44e6c0f7e20b60d3", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -97,7 +97,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n                 if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind {\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(did.expect_local());\n+                    let did = did.expect_local();\n+                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(did);\n \n                     if let Some((span, name)) =\n                         self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id)\n@@ -119,7 +120,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // Check if we are just moving a closure after it has been invoked.\n         if let Some(target) = target {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind {\n-                let hir_id = self.infcx.tcx.hir().as_local_hir_id(did.expect_local());\n+                let did = did.expect_local();\n+                let hir_id = self.infcx.tcx.hir().as_local_hir_id(did);\n \n                 if let Some((span, name)) =\n                     self.infcx.tcx.typeck_tables_of(did).closure_kind_origins().get(hir_id)"}, {"sha": "af5c392aa986e7872c887cce16fb9d60dd87d0b7", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -92,14 +92,14 @@ pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { mir_borrowck, ..*providers };\n }\n \n-fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> &BorrowCheckResult<'_> {\n+fn mir_borrowck(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &BorrowCheckResult<'_> {\n     let (input_body, promoted) = tcx.mir_validated(def_id);\n-    debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n+    debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id.to_def_id()));\n \n     let opt_closure_req = tcx.infer_ctxt().enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n-        do_mir_borrowck(&infcx, input_body, promoted, def_id.expect_local())\n+        do_mir_borrowck(&infcx, input_body, promoted, def_id)\n     });\n     debug!(\"mir_borrowck done\");\n \n@@ -1268,7 +1268,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 match **aggregate_kind {\n                     AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) => {\n                         let BorrowCheckResult { used_mut_upvars, .. } =\n-                            self.infcx.tcx.mir_borrowck(def_id);\n+                            self.infcx.tcx.mir_borrowck(def_id.expect_local());\n                         debug!(\"{:?} used_mut_upvars={:?}\", def_id, used_mut_upvars);\n                         for field in used_mut_upvars {\n                             self.propagate_closure_used_mut_upvar(&operands[field.index()]);"}, {"sha": "894a997ea7a4da4d781f561bf4d797f3f623bed8", "filename": "src/librustc_mir/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         if !self.tcx().is_closure(self.mir_def_id) {\n             user_provided_sig = None;\n         } else {\n-            let typeck_tables = self.tcx().typeck_tables_of(self.mir_def_id);\n+            let typeck_tables = self.tcx().typeck_tables_of(self.mir_def_id.expect_local());\n             user_provided_sig = match typeck_tables.user_provided_sigs.get(&self.mir_def_id) {\n                 None => None,\n                 Some(user_provided_poly_sig) => {"}, {"sha": "d60ab2b81fd4d7b940d22866d455a721183e54cd", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -9,7 +9,7 @@ use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_infer::infer::outlives::env::RegionBoundPairs;\n@@ -1232,7 +1232,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n         let body = self.body;\n-        let concrete_opaque_types = &tcx.typeck_tables_of(anon_owner_def_id).concrete_opaque_types;\n+        let concrete_opaque_types =\n+            &tcx.typeck_tables_of(anon_owner_def_id.expect_local()).concrete_opaque_types;\n         let mut opaque_type_values = Vec::new();\n \n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);\n@@ -2568,7 +2569,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             // clauses on the struct.\n             AggregateKind::Closure(def_id, substs)\n             | AggregateKind::Generator(def_id, substs, _) => {\n-                self.prove_closure_bounds(tcx, *def_id, substs, location)\n+                self.prove_closure_bounds(tcx, def_id.expect_local(), substs, location)\n             }\n \n             AggregateKind::Array(_) | AggregateKind::Tuple => ty::InstantiatedPredicates::empty(),\n@@ -2583,14 +2584,18 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn prove_closure_bounds(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n+        def_id: LocalDefId,\n         substs: SubstsRef<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n         if let Some(ref closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements\n         {\n             let closure_constraints = QueryRegionConstraints {\n-                outlives: closure_region_requirements.apply_requirements(tcx, def_id, substs),\n+                outlives: closure_region_requirements.apply_requirements(\n+                    tcx,\n+                    def_id.to_def_id(),\n+                    substs,\n+                ),\n \n                 // Presently, closures never propagate member\n                 // constraints to their parents -- they are enforced"}, {"sha": "d70ee8f9d5ec56c4780f75d71407a98247da70e4", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -498,7 +498,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let defining_ty = if self.mir_def_id == closure_base_def_id {\n                     tcx.type_of(closure_base_def_id)\n                 } else {\n-                    let tables = tcx.typeck_tables_of(self.mir_def_id);\n+                    let tables = tcx.typeck_tables_of(self.mir_def_id.expect_local());\n                     tables.node_type(self.mir_hir_id)\n                 };\n "}, {"sha": "95c5d0f0b10590df317cc63025999a29237a40e7", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -289,9 +289,11 @@ pub fn const_eval_raw_provider<'tcx>(\n     let cid = key.value;\n     let def_id = cid.instance.def.def_id();\n \n-    if def_id.is_local() && tcx.has_typeck_tables(def_id) {\n-        if let Some(error_reported) = tcx.typeck_tables_of(def_id).tainted_by_errors {\n-            return Err(ErrorHandled::Reported(error_reported));\n+    if let Some(def_id) = def_id.as_local() {\n+        if tcx.has_typeck_tables(def_id) {\n+            if let Some(error_reported) = tcx.typeck_tables_of(def_id).tainted_by_errors {\n+                return Err(ErrorHandled::Reported(error_reported));\n+            }\n         }\n     }\n "}, {"sha": "82e1984e4623d69abdbd6b9368eff1dd031d7255", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -402,9 +402,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, &'tcx mir::Body<'tcx>> {\n         // do not continue if typeck errors occurred (can only occur in local crate)\n         let did = instance.def_id();\n-        if did.is_local() && self.tcx.has_typeck_tables(did) {\n-            if let Some(error_reported) = self.tcx.typeck_tables_of(did).tainted_by_errors {\n-                throw_inval!(TypeckError(error_reported))\n+        if let Some(did) = did.as_local() {\n+            if self.tcx.has_typeck_tables(did) {\n+                if let Some(error_reported) = self.tcx.typeck_tables_of(did).tainted_by_errors {\n+                    throw_inval!(TypeckError(error_reported))\n+                }\n             }\n         }\n         trace!(\"load mir(instance={:?}, promoted={:?})\", instance, promoted);"}, {"sha": "838a5b32fc80b403cd7876faf78ac43368c1a113", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -199,9 +199,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             // generators and closures.\n             ty::Closure(def_id, _) | ty::Generator(def_id, _, _) => {\n                 let mut name = None;\n-                if def_id.is_local() {\n+                if let Some(def_id) = def_id.as_local() {\n                     let tables = self.ecx.tcx.typeck_tables_of(def_id);\n-                    if let Some(upvars) = tables.upvar_list.get(&def_id) {\n+                    if let Some(upvars) = tables.upvar_list.get(&def_id.to_def_id()) {\n                         // Sometimes the index is beyond the number of upvars (seen\n                         // for a generator).\n                         if let Some((&var_hir_id, _)) = upvars.get_index(field) {"}, {"sha": "dfcd2c3c93600d85a82d319167b5c996008d062e", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -919,7 +919,7 @@ struct RootCollector<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     mode: MonoItemCollectionMode,\n     output: &'a mut Vec<MonoItem<'tcx>>,\n-    entry_fn: Option<(DefId, EntryFnType)>,\n+    entry_fn: Option<(LocalDefId, EntryFnType)>,\n }\n \n impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n@@ -1008,7 +1008,7 @@ impl RootCollector<'_, 'v> {\n             && match self.mode {\n                 MonoItemCollectionMode::Eager => true,\n                 MonoItemCollectionMode::Lazy => {\n-                    self.entry_fn.map(|(id, _)| id) == Some(def_id.to_def_id())\n+                    self.entry_fn.map(|(id, _)| id) == Some(def_id)\n                         || self.tcx.is_reachable_non_generic(def_id)\n                         || self\n                             .tcx"}, {"sha": "1c1560cbf9de711461615c8361113b4dd588086d", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 &AggregateKind::Closure(def_id, _) | &AggregateKind::Generator(def_id, _, _) => {\n                     let UnsafetyCheckResult { violations, unsafe_blocks } =\n-                        self.tcx.unsafety_check_result(def_id);\n+                        self.tcx.unsafety_check_result(def_id.expect_local());\n                     self.register_violations(&violations, &unsafe_blocks);\n                 }\n             },\n@@ -485,7 +485,7 @@ fn check_unused_unsafe(\n     intravisit::Visitor::visit_body(&mut visitor, body);\n }\n \n-fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult {\n+fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: LocalDefId) -> UnsafetyCheckResult {\n     debug!(\"unsafety_violations({:?})\", def_id);\n \n     // N.B., this borrow is valid because all the consumers of\n@@ -494,21 +494,18 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n \n     let param_env = tcx.param_env(def_id);\n \n-    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let id = tcx.hir().as_local_hir_id(def_id);\n     let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n-        hir::BodyOwnerKind::Fn => (is_const_fn(tcx, def_id), is_min_const_fn(tcx, def_id)),\n+        hir::BodyOwnerKind::Fn => {\n+            (is_const_fn(tcx, def_id.to_def_id()), is_min_const_fn(tcx, def_id.to_def_id()))\n+        }\n         hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => (true, false),\n     };\n     let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body, tcx, param_env);\n     checker.visit_body(&body);\n \n-    check_unused_unsafe(\n-        tcx,\n-        def_id.expect_local(),\n-        &checker.used_unsafe,\n-        &mut checker.inherited_blocks,\n-    );\n+    check_unused_unsafe(tcx, def_id, &checker.used_unsafe, &mut checker.inherited_blocks);\n     UnsafetyCheckResult {\n         violations: checker.violations.into(),\n         unsafe_blocks: checker.inherited_blocks.into(),\n@@ -600,7 +597,8 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n         return;\n     }\n \n-    let UnsafetyCheckResult { violations, unsafe_blocks } = tcx.unsafety_check_result(def_id);\n+    let UnsafetyCheckResult { violations, unsafe_blocks } =\n+        tcx.unsafety_check_result(def_id.expect_local());\n \n     for &UnsafetyViolation { source_info, description, details, kind } in violations.iter() {\n         // Report an error."}, {"sha": "9f63340065fbff598572d1eb7183be70d4e9ce67", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -1,8 +1,9 @@\n use crate::{shim, util};\n use required_consts::RequiredConstsVisitor;\n use rustc_ast::ast;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdSet, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir::visit::Visitor as _;\n@@ -54,24 +55,24 @@ pub(crate) fn provide(providers: &mut Providers<'_>) {\n }\n \n fn is_mir_available(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    tcx.mir_keys(def_id.krate).contains(&def_id)\n+    tcx.mir_keys(def_id.krate).contains(&def_id.expect_local())\n }\n \n /// Finds the full set of `DefId`s within the current crate that have\n /// MIR associated with them.\n-fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n+fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &FxHashSet<LocalDefId> {\n     assert_eq!(krate, LOCAL_CRATE);\n \n-    let mut set = DefIdSet::default();\n+    let mut set = FxHashSet::default();\n \n     // All body-owners have MIR associated with them.\n-    set.extend(tcx.body_owners().map(LocalDefId::to_def_id));\n+    set.extend(tcx.body_owners());\n \n     // Additionally, tuple struct/variant constructors have MIR, but\n     // they don't have a BodyId, so we need to build them separately.\n     struct GatherCtors<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n-        set: &'a mut DefIdSet,\n+        set: &'a mut FxHashSet<LocalDefId>,\n     }\n     impl<'a, 'tcx> Visitor<'tcx> for GatherCtors<'a, 'tcx> {\n         fn visit_variant_data(\n@@ -83,7 +84,7 @@ fn mir_keys(tcx: TyCtxt<'_>, krate: CrateNum) -> &DefIdSet {\n             _: Span,\n         ) {\n             if let hir::VariantData::Tuple(_, hir_id) = *v {\n-                self.set.insert(self.tcx.hir().local_def_id(hir_id).to_def_id());\n+                self.set.insert(self.tcx.hir().local_def_id(hir_id));\n             }\n             intravisit::walk_struct_def(self, v)\n         }\n@@ -211,17 +212,21 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def_id: DefId) -> ConstQualifs {\n }\n \n fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n+    let def_id = def_id.expect_local();\n+\n     // Unsafety check uses the raw mir, so make sure it is run\n     let _ = tcx.unsafety_check_result(def_id);\n \n     let mut body = tcx.mir_built(def_id).steal();\n \n-    util::dump_mir(tcx, None, \"mir_map\", &0, MirSource::item(def_id), &body, |_, _| Ok(()));\n+    util::dump_mir(tcx, None, \"mir_map\", &0, MirSource::item(def_id.to_def_id()), &body, |_, _| {\n+        Ok(())\n+    });\n \n     run_passes(\n         tcx,\n         &mut body,\n-        InstanceDef::Item(def_id),\n+        InstanceDef::Item(def_id.to_def_id()),\n         None,\n         MirPhase::Const,\n         &[&[\n@@ -235,13 +240,13 @@ fn mir_const(tcx: TyCtxt<'_>, def_id: DefId) -> &Steal<Body<'_>> {\n \n fn mir_validated(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n ) -> (&'tcx Steal<Body<'tcx>>, &'tcx Steal<IndexVec<Promoted, Body<'tcx>>>) {\n     // Ensure that we compute the `mir_const_qualif` for constants at\n     // this point, before we steal the mir-const result.\n-    let _ = tcx.mir_const_qualif(def_id);\n+    let _ = tcx.mir_const_qualif(def_id.to_def_id());\n \n-    let mut body = tcx.mir_const(def_id).steal();\n+    let mut body = tcx.mir_const(def_id.to_def_id()).steal();\n \n     let mut required_consts = Vec::new();\n     let mut required_consts_visitor = RequiredConstsVisitor::new(&mut required_consts);\n@@ -254,7 +259,7 @@ fn mir_validated(\n     run_passes(\n         tcx,\n         &mut body,\n-        InstanceDef::Item(def_id),\n+        InstanceDef::Item(def_id.to_def_id()),\n         None,\n         MirPhase::Validated,\n         &[&[\n@@ -271,7 +276,7 @@ fn mir_validated(\n fn run_optimization_passes<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &mut Body<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     promoted: Option<Promoted>,\n ) {\n     let post_borrowck_cleanup: &[&dyn MirPass<'tcx>] = &[\n@@ -344,7 +349,7 @@ fn run_optimization_passes<'tcx>(\n     run_passes(\n         tcx,\n         body,\n-        InstanceDef::Item(def_id),\n+        InstanceDef::Item(def_id.to_def_id()),\n         promoted,\n         MirPhase::Optimized,\n         &[\n@@ -364,6 +369,8 @@ fn optimized_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &Body<'_> {\n         return shim::build_adt_ctor(tcx, def_id);\n     }\n \n+    let def_id = def_id.expect_local();\n+\n     // (Mir-)Borrowck uses `mir_validated`, so we have to force it to\n     // execute before we can steal.\n     tcx.ensure().mir_borrowck(def_id);\n@@ -382,6 +389,8 @@ fn promoted_mir(tcx: TyCtxt<'_>, def_id: DefId) -> &IndexVec<Promoted, Body<'_>>\n         return tcx.intern_promoted(IndexVec::new());\n     }\n \n+    let def_id = def_id.expect_local();\n+\n     tcx.ensure().mir_borrowck(def_id);\n     let (_, promoted) = tcx.mir_validated(def_id);\n     let mut promoted = promoted.steal();"}, {"sha": "5ff7fbf742a0c900f280bc8b8156c560578d5e42", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -868,5 +868,9 @@ fn write_user_type_annotations(body: &Body<'_>, w: &mut dyn Write) -> io::Result\n }\n \n pub fn dump_mir_def_ids(tcx: TyCtxt<'_>, single: Option<DefId>) -> Vec<DefId> {\n-    if let Some(i) = single { vec![i] } else { tcx.mir_keys(LOCAL_CRATE).iter().cloned().collect() }\n+    if let Some(i) = single {\n+        vec![i]\n+    } else {\n+        tcx.mir_keys(LOCAL_CRATE).iter().map(|def_id| def_id.to_def_id()).collect()\n+    }\n }"}, {"sha": "69a04e772ecee741c26fa26eb79069923415266d", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -21,8 +21,8 @@ use rustc_target::spec::PanicStrategy;\n \n use super::lints;\n \n-crate fn mir_built(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::steal::Steal<Body<'_>> {\n-    tcx.alloc_steal_mir(mir_build(tcx, def_id.expect_local()))\n+crate fn mir_built(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &ty::steal::Steal<Body<'_>> {\n+    tcx.alloc_steal_mir(mir_build(tcx, def_id))\n }\n \n /// Construct the MIR for a given `DefId`.\n@@ -181,7 +181,7 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Body<'_> {\n             build::construct_const(cx, body_id, return_ty, return_ty_span)\n         };\n \n-        lints::check(tcx, &body, def_id.to_def_id());\n+        lints::check(tcx, &body, def_id);\n \n         // The borrow checker will replace all the regions here with its own\n         // inference variables. There's no point having non-erased regions here."}, {"sha": "990f55f6d422fba5c4e4792af4537a10b044be78", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -1,7 +1,7 @@\n use rustc_data_structures::graph::iterate::{\n     ControlFlow, NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::FnKind;\n use rustc_middle::hir::map::blocks::FnLikeNode;\n use rustc_middle::mir::{BasicBlock, Body, Operand, TerminatorKind};\n@@ -10,8 +10,8 @@ use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc_span::Span;\n \n-crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: LocalDefId) {\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n         if let FnKind::Closure(_) = fn_like_node.kind() {\n@@ -20,12 +20,12 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n         }\n \n         // If this is trait/impl method, extract the trait's substs.\n-        let trait_substs = match tcx.opt_associated_item(def_id) {\n+        let trait_substs = match tcx.opt_associated_item(def_id.to_def_id()) {\n             Some(AssocItem {\n                 container: AssocItemContainer::TraitContainer(trait_def_id), ..\n             }) => {\n                 let trait_substs_count = tcx.generics_of(trait_def_id).count();\n-                &InternalSubsts::identity_for_item(tcx, def_id)[..trait_substs_count]\n+                &InternalSubsts::identity_for_item(tcx, def_id.to_def_id())[..trait_substs_count]\n             }\n             _ => &[],\n         };\n@@ -37,7 +37,7 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: DefId) {\n \n         vis.reachable_recursive_calls.sort();\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+        let hir_id = tcx.hir().as_local_hir_id(def_id);\n         let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");\n@@ -57,7 +57,7 @@ struct NonRecursive;\n struct Search<'mir, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'mir Body<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     trait_substs: &'tcx [GenericArg<'tcx>],\n \n     reachable_recursive_calls: Vec<Span>,\n@@ -84,7 +84,8 @@ impl<'mir, 'tcx> Search<'mir, 'tcx> {\n             // calling into an entirely different method (for example, a call from the default\n             // method in the trait to `<A as Trait<B>>::method`, where `A` and/or `B` are\n             // specific types).\n-            return call_fn_id == def_id && &call_substs[..trait_substs.len()] == trait_substs;\n+            return call_fn_id == def_id.to_def_id()\n+                && &call_substs[..trait_substs.len()] == trait_substs;\n         }\n \n         false"}, {"sha": "1b8c053b16e0b92bbf9bf4fa4457dd4fc93b5556", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -452,8 +452,7 @@ fn create_and_seed_worklist<'tcx>(\n         )\n         .chain(\n             // Seed entry point\n-            tcx.entry_fn(LOCAL_CRATE)\n-                .map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id.expect_local())),\n+            tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id)),\n         )\n         .collect::<Vec<_>>();\n "}, {"sha": "6a6d0316609078b82f960761cca6876df53e81e7", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -1,7 +1,7 @@\n use rustc_ast::attr;\n use rustc_ast::entry::EntryPointType;\n use rustc_errors::struct_span_err;\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{HirId, ImplItem, Item, ItemKind, TraitItem};\n use rustc_middle::hir::map::Map;\n@@ -48,7 +48,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     }\n }\n \n-fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n+fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(LocalDefId, EntryFnType)> {\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     let any_exe =\n@@ -143,13 +143,16 @@ fn find_item(item: &Item<'_>, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n     }\n }\n \n-fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(DefId, EntryFnType)> {\n+fn configure_main(\n+    tcx: TyCtxt<'_>,\n+    visitor: &EntryContext<'_, '_>,\n+) -> Option<(LocalDefId, EntryFnType)> {\n     if let Some((hir_id, _)) = visitor.start_fn {\n-        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Start))\n+        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Start))\n     } else if let Some((hir_id, _)) = visitor.attr_main_fn {\n-        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Main))\n+        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n     } else if let Some((hir_id, _)) = visitor.main_fn {\n-        Some((tcx.hir().local_def_id(hir_id).to_def_id(), EntryFnType::Main))\n+        Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n     } else {\n         no_main_err(tcx, visitor);\n         None\n@@ -211,7 +214,7 @@ fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) {\n     err.emit();\n }\n \n-pub fn find_entry_point(tcx: TyCtxt<'_>) -> Option<(DefId, EntryFnType)> {\n+pub fn find_entry_point(tcx: TyCtxt<'_>) -> Option<(LocalDefId, EntryFnType)> {\n     tcx.entry_fn(LOCAL_CRATE)\n }\n "}, {"sha": "b407276cfbecd8fb17db174fe761ee0413f1c061", "filename": "src/librustc_passes/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_passes%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_passes%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fintrinsicck.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -132,7 +132,7 @@ impl Visitor<'tcx> for ItemVisitor<'tcx> {\n         let owner_def_id = self.tcx.hir().body_owner_def_id(body_id);\n         let body = self.tcx.hir().body(body_id);\n         let param_env = self.tcx.param_env(owner_def_id.to_def_id());\n-        let tables = self.tcx.typeck_tables_of(owner_def_id.to_def_id());\n+        let tables = self.tcx.typeck_tables_of(owner_def_id);\n         ExprVisitor { tcx: self.tcx, param_env, tables }.visit_body(body);\n         self.visit_body(body);\n     }"}, {"sha": "8f736c1dd549bbf810536c2245882e5701d04308", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -101,7 +101,7 @@ use rustc_data_structures::fx::FxIndexMap;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::*;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{Expr, HirId, HirIdMap, HirIdSet, Node};\n use rustc_middle::hir::map::Map;\n@@ -398,7 +398,7 @@ fn visit_fn<'tcx>(\n     intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n     // compute liveness\n-    let mut lsets = Liveness::new(&mut fn_maps, def_id.to_def_id());\n+    let mut lsets = Liveness::new(&mut fn_maps, def_id);\n     let entry_ln = lsets.compute(&body.value);\n \n     // check for various error conditions\n@@ -671,7 +671,7 @@ struct Liveness<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn new(ir: &'a mut IrMaps<'tcx>, def_id: DefId) -> Liveness<'a, 'tcx> {\n+    fn new(ir: &'a mut IrMaps<'tcx>, def_id: LocalDefId) -> Liveness<'a, 'tcx> {\n         // Special nodes and variables:\n         // - exit_ln represents the end of the fn, either by return or panic\n         // - implicit_ret_var is a pseudo-variable that represents"}, {"sha": "82b45cf7cf884156cd81c6029abf1ae322bf288e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, DeepVisitor, NestedVisitorMap, Visitor};\n use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n@@ -1174,15 +1174,17 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n struct TypePrivacyVisitor<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n-    current_item: DefId,\n+    current_item: LocalDefId,\n     in_body: bool,\n     span: Span,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     fn item_is_accessible(&self, did: DefId) -> bool {\n-        def_id_visibility(self.tcx, did).0.is_accessible_from(self.current_item, self.tcx)\n+        def_id_visibility(self.tcx, did)\n+            .0\n+            .is_accessible_from(self.current_item.to_def_id(), self.tcx)\n     }\n \n     // Take node-id of an expression or pattern and check its type for privacy.\n@@ -1387,10 +1389,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(\n-            &mut self.current_item,\n-            self.tcx.hir().local_def_id(item.hir_id).to_def_id(),\n-        );\n+        let orig_current_item =\n+            mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.hir_id));\n         let orig_in_body = mem::replace(&mut self.in_body, false);\n         let orig_tables =\n             mem::replace(&mut self.tables, item_tables(self.tcx, item.hir_id, self.empty_tables));\n@@ -2076,7 +2076,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     };\n }\n \n-fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: DefId) {\n+fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let empty_tables = ty::TypeckTables::empty(None);\n \n     // Check privacy of names not checked in previous compilation stages.\n@@ -2086,7 +2086,7 @@ fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: DefId) {\n         current_item: None,\n         empty_tables: &empty_tables,\n     };\n-    let (module, span, hir_id) = tcx.hir().get_module(module_def_id.expect_local());\n+    let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n \n     intravisit::walk_mod(&mut visitor, module, hir_id);\n "}, {"sha": "ccce72fb0ac2468dd809245a628d38e0772a147d", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -107,7 +107,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n     where\n         F: FnOnce(&mut Self),\n     {\n-        let item_def_id = self.tcx.hir().local_def_id_from_node_id(item_id).to_def_id();\n+        let item_def_id = self.tcx.hir().local_def_id_from_node_id(item_id);\n \n         let tables = if self.tcx.has_typeck_tables(item_def_id) {\n             self.tcx.typeck_tables_of(item_def_id)\n@@ -1183,7 +1183,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n \n                 // Make a comma-separated list of names of imported modules.\n                 let def_id = self.tcx.hir().local_def_id_from_node_id(id);\n-                let names = self.tcx.names_imported_by_glob_use(def_id.to_def_id());\n+                let names = self.tcx.names_imported_by_glob_use(def_id);\n                 let names: Vec<_> = names.iter().map(|n| n.to_string()).collect();\n \n                 // Otherwise it's a span with wrong macro expansion info, which"}, {"sha": "5ec2d68ab2a7d52048b9ff211796181a9a694918", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -1243,7 +1243,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let tables: &TypeckTables<'tcx> = match &in_progress_tables {\n             Some(t) if t.hir_owner.map(|owner| owner.to_def_id()) == Some(generator_did_root) => t,\n             _ => {\n-                query_tables = self.tcx.typeck_tables_of(generator_did);\n+                query_tables = self.tcx.typeck_tables_of(generator_did.expect_local());\n                 &query_tables\n             }\n         };"}, {"sha": "5877c6d269ad65d30198c34f12fe191d597fb0c9", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -754,16 +754,16 @@ fn typeck_item_bodies(tcx: TyCtxt<'_>, crate_num: CrateNum) {\n     });\n }\n \n-fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    wfcheck::check_item_well_formed(tcx, def_id.expect_local());\n+fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    wfcheck::check_item_well_formed(tcx, def_id);\n }\n \n-fn check_trait_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    wfcheck::check_trait_item(tcx, def_id.expect_local());\n+fn check_trait_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    wfcheck::check_trait_item(tcx, def_id);\n }\n \n-fn check_impl_item_well_formed(tcx: TyCtxt<'_>, def_id: DefId) {\n-    wfcheck::check_impl_item(tcx, def_id.expect_local());\n+fn check_impl_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    wfcheck::check_impl_item(tcx, def_id);\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n@@ -853,7 +853,7 @@ fn has_typeck_tables(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     }\n }\n \n-fn used_trait_imports(tcx: TyCtxt<'_>, def_id: DefId) -> &DefIdSet {\n+fn used_trait_imports(tcx: TyCtxt<'_>, def_id: LocalDefId) -> &DefIdSet {\n     &*tcx.typeck_tables_of(def_id).used_trait_imports\n }\n \n@@ -968,20 +968,19 @@ where\n     val.fold_with(&mut FixupFolder { tcx })\n }\n \n-fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &ty::TypeckTables<'tcx> {\n-    let fallback = move || tcx.type_of(def_id);\n+fn typeck_tables_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckTables<'tcx> {\n+    let fallback = move || tcx.type_of(def_id.to_def_id());\n     typeck_tables_of_with_fallback(tcx, def_id, fallback)\n }\n \n /// Used only to get `TypeckTables` for type inference during error recovery.\n /// Currently only used for type inference of `static`s and `const`s to avoid type cycle errors.\n fn diagnostic_only_typeck_tables_of<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n ) -> &ty::TypeckTables<'tcx> {\n-    assert!(def_id.is_local());\n     let fallback = move || {\n-        let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id.expect_local()));\n+        let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id));\n         tcx.sess.delay_span_bug(span, \"diagnostic only typeck table used\");\n         tcx.types.err\n     };\n@@ -990,17 +989,17 @@ fn diagnostic_only_typeck_tables_of<'tcx>(\n \n fn typeck_tables_of_with_fallback<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     fallback: impl Fn() -> Ty<'tcx> + 'tcx,\n ) -> &'tcx ty::TypeckTables<'tcx> {\n     // Closures' tables come from their outermost function,\n     // as they are part of the same \"inference environment\".\n-    let outer_def_id = tcx.closure_base_def_id(def_id);\n+    let outer_def_id = tcx.closure_base_def_id(def_id.to_def_id()).expect_local();\n     if outer_def_id != def_id {\n         return tcx.typeck_tables_of(outer_def_id);\n     }\n \n-    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let id = tcx.hir().as_local_hir_id(def_id);\n     let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n@@ -1009,7 +1008,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n     });\n     let body = tcx.hir().body(body_id);\n \n-    let tables = Inherited::build(tcx, def_id.expect_local()).enter(|inh| {\n+    let tables = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n         let fcx = if let (Some(header), Some(decl)) = (fn_header, fn_decl) {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n@@ -1029,7 +1028,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n             check_abi(tcx, span, fn_sig.abi());\n \n             // Compute the fty from point of view of inside the fn.\n-            let fn_sig = tcx.liberate_late_bound_regions(def_id, &fn_sig);\n+            let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), &fn_sig);\n             let fn_sig = inh.normalize_associated_types_in(\n                 body.value.span,\n                 body_id.hir_id,\n@@ -1121,7 +1120,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n         // because they don't constrain other type variables.\n         fcx.closure_analyze(body);\n         assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n-        fcx.resolve_generator_interiors(def_id);\n+        fcx.resolve_generator_interiors(def_id.to_def_id());\n \n         for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n             let ty = fcx.normalize_ty(span, ty);\n@@ -1452,7 +1451,7 @@ fn check_fn<'a, 'tcx>(\n     // Check that the main return type implements the termination trait.\n     if let Some(term_id) = tcx.lang_items().termination() {\n         if let Some((def_id, EntryFnType::Main)) = tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = hir.as_local_hir_id(def_id.expect_local());\n+            let main_id = hir.as_local_hir_id(def_id);\n             if main_id == fn_id {\n                 let substs = tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);"}, {"sha": "53d6ec96bd251be7a43341d0348634e029447031", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -77,7 +77,7 @@ use crate::check::FnCtxt;\n use crate::mem_categorization as mc;\n use crate::middle::region;\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n@@ -109,7 +109,7 @@ macro_rules! ignore_err {\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn regionck_expr(&self, body: &'tcx hir::Body<'tcx>) {\n-        let subject = self.tcx.hir().body_owner_def_id(body.id()).to_def_id();\n+        let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let id = body.value.hir_id;\n         let mut rcx =\n             RegionCtxt::new(self, RepeatingScope(id), id, Subject(subject), self.param_env);\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self,\n             RepeatingScope(item_id),\n             item_id,\n-            Subject(subject.to_def_id()),\n+            Subject(subject),\n             self.param_env,\n         );\n         rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n@@ -154,7 +154,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// constraints to add.\n     pub fn regionck_fn(&self, fn_id: hir::HirId, body: &'tcx hir::Body<'tcx>) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n-        let subject = self.tcx.hir().body_owner_def_id(body.id()).to_def_id();\n+        let subject = self.tcx.hir().body_owner_def_id(body.id());\n         let hir_id = body.value.hir_id;\n         let mut rcx =\n             RegionCtxt::new(self, RepeatingScope(hir_id), hir_id, Subject(subject), self.param_env);\n@@ -180,7 +180,7 @@ pub struct RegionCtxt<'a, 'tcx> {\n \n     // id of innermost fn body id\n     body_id: hir::HirId,\n-    body_owner: DefId,\n+    body_owner: LocalDefId,\n \n     // call_site scope of innermost fn\n     call_site_scope: Option<region::Scope>,\n@@ -189,7 +189,7 @@ pub struct RegionCtxt<'a, 'tcx> {\n     repeating_scope: hir::HirId,\n \n     // id of AST node being analyzed (the subject of the analysis).\n-    subject_def_id: DefId,\n+    subject_def_id: LocalDefId,\n }\n \n impl<'a, 'tcx> Deref for RegionCtxt<'a, 'tcx> {\n@@ -200,7 +200,7 @@ impl<'a, 'tcx> Deref for RegionCtxt<'a, 'tcx> {\n }\n \n pub struct RepeatingScope(hir::HirId);\n-pub struct Subject(DefId);\n+pub struct Subject(LocalDefId);\n \n impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     pub fn new(\n@@ -290,7 +290,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n \n         let body_id = body.id();\n         self.body_id = body_id.hir_id;\n-        self.body_owner = self.tcx.hir().body_owner_def_id(body_id).to_def_id();\n+        self.body_owner = self.tcx.hir().body_owner_def_id(body_id);\n \n         let call_site =\n             region::Scope { id: body.value.hir_id.local_id, data: region::ScopeData::CallSite };\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         );\n \n         self.fcx.resolve_regions_and_report_errors(\n-            self.subject_def_id,\n+            self.subject_def_id.to_def_id(),\n             &self.region_scope_tree,\n             &self.outlives_environment,\n             mode,"}, {"sha": "55802c140bc9f3207a323d7ca6e65c5f18f8faa4", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -146,8 +146,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id()).to_def_id();\n-        assert_eq!(body_owner_def_id, closure_def_id);\n+        let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());\n+        assert_eq!(body_owner_def_id.to_def_id(), closure_def_id);\n         let mut delegate = InferBorrowKind {\n             fcx: self,\n             closure_def_id,"}, {"sha": "ce1538bfa49c351298832a67f9a6906f4069914e", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -12,7 +12,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n     let mut used_trait_imports = DefIdSet::default();\n     for &body_id in tcx.hir().krate().bodies.keys() {\n         let item_def_id = tcx.hir().body_owner_def_id(body_id);\n-        let imports = tcx.used_trait_imports(item_def_id.to_def_id());\n+        let imports = tcx.used_trait_imports(item_def_id);\n         debug!(\"GatherVisitor: item_def_id={:?} with imports {:#?}\", item_def_id, imports);\n         used_trait_imports.extend(imports.iter());\n     }"}, {"sha": "9f70a0fbc246274c3e008ba9245cc07afa921a39", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -295,7 +295,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n     }\n \n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n-        self.tcx.at(span).type_param_predicates((self.item_def_id, def_id))\n+        self.tcx.at(span).type_param_predicates((self.item_def_id, def_id.expect_local()))\n     }\n \n     fn re_infer(&self, _: Option<&ty::GenericParamDef>, _: Span) -> Option<ty::Region<'tcx>> {\n@@ -478,19 +478,19 @@ fn get_new_lifetime_name<'tcx>(\n /// `X: Foo` where `X` is the type parameter `def_id`.\n fn type_param_predicates(\n     tcx: TyCtxt<'_>,\n-    (item_def_id, def_id): (DefId, DefId),\n+    (item_def_id, def_id): (DefId, LocalDefId),\n ) -> ty::GenericPredicates<'_> {\n     use rustc_hir::*;\n \n     // In the AST, bounds can derive from two places. Either\n     // written inline like `<T: Foo>` or in a where-clause like\n     // `where T: Foo`.\n \n-    let param_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let param_id = tcx.hir().as_local_hir_id(def_id);\n     let param_owner = tcx.hir().ty_param_owner(param_id);\n     let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n-    let index = generics.param_def_id_to_index[&def_id];\n+    let index = generics.param_def_id_to_index[&def_id.to_def_id()];\n     let ty = tcx.mk_ty_param(index, tcx.hir().ty_param_name(param_id));\n \n     // Don't look for bounds where the type parameter isn't in scope.\n@@ -503,7 +503,7 @@ fn type_param_predicates(\n     let mut result = parent\n         .map(|parent| {\n             let icx = ItemCtxt::new(tcx, parent);\n-            icx.get_type_parameter_bounds(DUMMY_SP, def_id)\n+            icx.get_type_parameter_bounds(DUMMY_SP, def_id.to_def_id())\n         })\n         .unwrap_or_default();\n     let mut extend = None;\n@@ -1459,9 +1459,10 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     use rustc_hir::Node::*;\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let def_id = def_id.expect_local();\n+    let hir_id = tcx.hir().as_local_hir_id(def_id);\n \n-    let icx = ItemCtxt::new(tcx, def_id);\n+    let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n \n     match tcx.hir().get(hir_id) {\n         TraitItem(hir::TraitItem {\n@@ -1516,7 +1517,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             ..\n         }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n-            compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi, ident)\n+            compute_sig_of_foreign_fn_decl(tcx, def_id.to_def_id(), fn_decl, abi, ident)\n         }\n \n         Ctor(data) | Variant(hir::Variant { data, .. }) if data.ctor_hir_id().is_some() => {"}, {"sha": "cf0e3f9cdf592008c8b1ee69b1ec1f2bd72a43db", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -34,7 +34,13 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             TraitItemKind::Const(ref ty, body_id) => body_id\n                 .and_then(|body_id| {\n                     if is_suggestable_infer_ty(ty) {\n-                        Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n+                        Some(infer_placeholder_type(\n+                            tcx,\n+                            def_id.expect_local(),\n+                            body_id,\n+                            ty.span,\n+                            item.ident,\n+                        ))\n                     } else {\n                         None\n                     }\n@@ -53,7 +59,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             }\n             ImplItemKind::Const(ref ty, body_id) => {\n                 if is_suggestable_infer_ty(ty) {\n-                    infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n+                    infer_placeholder_type(tcx, def_id.expect_local(), body_id, ty.span, item.ident)\n                 } else {\n                     icx.to_ty(ty)\n                 }\n@@ -78,7 +84,13 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n             match item.kind {\n                 ItemKind::Static(ref ty, .., body_id) | ItemKind::Const(ref ty, body_id) => {\n                     if is_suggestable_infer_ty(ty) {\n-                        infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n+                        infer_placeholder_type(\n+                            tcx,\n+                            def_id.expect_local(),\n+                            body_id,\n+                            ty.span,\n+                            item.ident,\n+                        )\n                     } else {\n                         icx.to_ty(ty)\n                     }\n@@ -102,13 +114,13 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), origin, .. }) => {\n                     let concrete_types = match origin {\n                         OpaqueTyOrigin::FnReturn | OpaqueTyOrigin::AsyncFn => {\n-                            &tcx.mir_borrowck(owner).concrete_opaque_types\n+                            &tcx.mir_borrowck(owner.expect_local()).concrete_opaque_types\n                         }\n                         OpaqueTyOrigin::Misc => {\n                             // We shouldn't leak borrowck results through impl trait in bindings.\n                             // For example, we shouldn't be able to tell if `x` in\n                             // `let x: impl Sized + 'a = &()` has type `&'static ()` or `&'a ()`.\n-                            &tcx.typeck_tables_of(owner).concrete_opaque_types\n+                            &tcx.typeck_tables_of(owner.expect_local()).concrete_opaque_types\n                         }\n                         OpaqueTyOrigin::TypeAlias => {\n                             span_bug!(item.span, \"Type alias impl trait shouldn't have an owner\")\n@@ -126,7 +138,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 ),\n                             );\n                             if let Some(ErrorReported) =\n-                                tcx.typeck_tables_of(owner).tainted_by_errors\n+                                tcx.typeck_tables_of(owner.expect_local()).tainted_by_errors\n                             {\n                                 // Some error in the\n                                 // owner fn prevented us from populating\n@@ -405,7 +417,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n     }\n \n     impl ConstraintLocator<'_> {\n-        fn check(&mut self, def_id: DefId) {\n+        fn check(&mut self, def_id: LocalDefId) {\n             // Don't try to check items that cannot possibly constrain the type.\n             if !self.tcx.has_typeck_tables(def_id) {\n                 debug!(\n@@ -512,32 +524,32 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n         fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n             if let hir::ExprKind::Closure(..) = ex.kind {\n                 let def_id = self.tcx.hir().local_def_id(ex.hir_id);\n-                self.check(def_id.to_def_id());\n+                self.check(def_id);\n             }\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id).to_def_id();\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if def_id != self.def_id {\n+            if def_id.to_def_id() != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id).to_def_id();\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if def_id != self.def_id {\n+            if def_id.to_def_id() != self.def_id {\n                 self.check(def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n             debug!(\"find_existential_constraints: visiting {:?}\", it);\n             let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            self.check(def_id.to_def_id());\n+            self.check(def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n     }\n@@ -586,7 +598,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n \n fn infer_placeholder_type(\n     tcx: TyCtxt<'_>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     body_id: hir::BodyId,\n     span: Span,\n     item_ident: Ident,"}, {"sha": "cdebd63b5942fe78749b4c66d19cd060b2636541", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -9,7 +9,7 @@ pub use mc::{Place, PlaceBase, Projection};\n \n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::PatKind;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::{self, adjustment, TyCtxt};\n@@ -84,7 +84,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     pub fn new(\n         delegate: &'a mut (dyn Delegate<'tcx> + 'a),\n         infcx: &'a InferCtxt<'a, 'tcx>,\n-        body_owner: DefId,\n+        body_owner: LocalDefId,\n         param_env: ty::ParamEnv<'tcx>,\n         tables: &'a ty::TypeckTables<'tcx>,\n     ) -> Self {"}, {"sha": "8d8a1b4d9676169c67d4c6dfc77b131a6fb65b1e", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -303,8 +303,8 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n \n fn check_for_entry_fn(tcx: TyCtxt<'_>) {\n     match tcx.entry_fn(LOCAL_CRATE) {\n-        Some((def_id, EntryFnType::Main)) => check_main_fn_ty(tcx, def_id.expect_local()),\n-        Some((def_id, EntryFnType::Start)) => check_start_fn_ty(tcx, def_id.expect_local()),\n+        Some((def_id, EntryFnType::Main)) => check_main_fn_ty(tcx, def_id),\n+        Some((def_id, EntryFnType::Start)) => check_start_fn_ty(tcx, def_id),\n         _ => {}\n     }\n }"}, {"sha": "f6edb6b754534f1a4f5bb35a6941ebf508ceaf30", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb5615a4771ea3d54256f969dc84d2dfd38d812c/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=fb5615a4771ea3d54256f969dc84d2dfd38d812c", "patch": "@@ -55,7 +55,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::PatKind;\n use rustc_infer::infer::InferCtxt;\n use rustc_span::Span;\n@@ -140,7 +140,7 @@ crate struct MemCategorizationContext<'a, 'tcx> {\n     crate tables: &'a ty::TypeckTables<'tcx>,\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-    body_owner: DefId,\n+    body_owner: LocalDefId,\n     upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n }\n \n@@ -151,7 +151,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n     crate fn new(\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        body_owner: DefId,\n+        body_owner: LocalDefId,\n         tables: &'a ty::TypeckTables<'tcx>,\n     ) -> MemCategorizationContext<'a, 'tcx> {\n         MemCategorizationContext {\n@@ -473,7 +473,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n         let upvar_id = ty::UpvarId {\n             var_path: ty::UpvarPath { hir_id: var_id },\n-            closure_expr_id: closure_expr_def_id.expect_local(),\n+            closure_expr_id: closure_expr_def_id,\n         };\n         let var_ty = self.node_ty(var_id)?;\n "}]}