{"sha": "277bc9641d5585fcb2d94440efc6b1880a74fd64", "node_id": "C_kwDOAAsO6NoAKDI3N2JjOTY0MWQ1NTg1ZmNiMmQ5NDQ0MGVmYzZiMTg4MGE3NGZkNjQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-06T06:13:51Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-07-11T04:04:42Z"}, "message": "Remove unnecessary sigils and `ref`s in derived code.\n\nE.g. improving code like this:\n```\nmatch &*self {\n    &Enum1::Single { x: ref __self_0 } => {\n        ::core::hash::Hash::hash(&*__self_0, state)\n    }\n}\n```\nto this:\n```\nmatch self {\n    Enum1::Single { x: __self_0 } => {\n        ::core::hash::Hash::hash(&*__self_0, state)\n    }\n}\n```\nby removing the `&*`, the `&`, and the `ref`.\n\nI suspect the current generated code predates deref-coercion.\n\nThe commit also gets rid of `use_temporaries`, instead passing around\n`always_copy`, which makes things a little clearer. And it fixes up some\ncomments.", "tree": {"sha": "d1413452a67b2f087f899689f4bf2299a08031fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1413452a67b2f087f899689f4bf2299a08031fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/277bc9641d5585fcb2d94440efc6b1880a74fd64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/277bc9641d5585fcb2d94440efc6b1880a74fd64", "html_url": "https://github.com/rust-lang/rust/commit/277bc9641d5585fcb2d94440efc6b1880a74fd64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/277bc9641d5585fcb2d94440efc6b1880a74fd64/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f314ece27503a7518b91b011ba74709914204913", "url": "https://api.github.com/repos/rust-lang/rust/commits/f314ece27503a7518b91b011ba74709914204913", "html_url": "https://github.com/rust-lang/rust/commit/f314ece27503a7518b91b011ba74709914204913"}], "stats": {"total": 356, "additions": 160, "deletions": 196}, "files": [{"sha": "dbac6e61ea9aa5181e7c0257d88a446b6c612ff2", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 53, "deletions": 86, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/277bc9641d5585fcb2d94440efc6b1880a74fd64/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/277bc9641d5585fcb2d94440efc6b1880a74fd64/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=277bc9641d5585fcb2d94440efc6b1880a74fd64", "patch": "@@ -183,7 +183,6 @@ use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, BinOpKind, EnumDef, Expr, Generics, PatKind};\n use rustc_ast::{GenericArg, GenericParamKind, VariantData};\n use rustc_attr as attr;\n-use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_expand::base::{Annotatable, ExtCtxt};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -455,7 +454,6 @@ impl<'a> TraitDef<'a> {\n                 };\n                 let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n                 let always_copy = has_no_type_params && cx.resolver.has_derive_copy(container_id);\n-                let use_temporaries = is_packed && always_copy;\n \n                 let newitem = match item.kind {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => self.expand_struct_def(\n@@ -464,11 +462,11 @@ impl<'a> TraitDef<'a> {\n                         item.ident,\n                         generics,\n                         from_scratch,\n-                        use_temporaries,\n                         is_packed,\n+                        always_copy,\n                     ),\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n-                        // We ignore `use_temporaries` here, because\n+                        // We ignore `is_packed`/`always_copy` here, because\n                         // `repr(packed)` enums cause an error later on.\n                         //\n                         // This can only cause further compilation errors\n@@ -484,8 +482,8 @@ impl<'a> TraitDef<'a> {\n                                 item.ident,\n                                 generics,\n                                 from_scratch,\n-                                use_temporaries,\n                                 is_packed,\n+                                always_copy,\n                             )\n                         } else {\n                             cx.span_err(mitem.span, \"this trait cannot be derived for unions\");\n@@ -766,8 +764,8 @@ impl<'a> TraitDef<'a> {\n         type_ident: Ident,\n         generics: &Generics,\n         from_scratch: bool,\n-        use_temporaries: bool,\n         is_packed: bool,\n+        always_copy: bool,\n     ) -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> =\n             struct_def.fields().iter().map(|field| field.ty.clone()).collect();\n@@ -795,8 +793,8 @@ impl<'a> TraitDef<'a> {\n                         type_ident,\n                         &selflike_args,\n                         &nonselflike_args,\n-                        use_temporaries,\n                         is_packed,\n+                        always_copy,\n                     )\n                 };\n \n@@ -937,9 +935,7 @@ impl<'a> MethodDef<'a> {\n \n             match ty {\n                 // Selflike (`&Self`) arguments only occur in non-static methods.\n-                Ref(box Self_, _) if !self.is_static() => {\n-                    selflike_args.push(cx.expr_deref(span, arg_expr))\n-                }\n+                Ref(box Self_, _) if !self.is_static() => selflike_args.push(arg_expr),\n                 Self_ => cx.span_bug(span, \"`Self` in non-return position\"),\n                 _ => nonselflike_args.push(arg_expr),\n             }\n@@ -1025,9 +1021,9 @@ impl<'a> MethodDef<'a> {\n     /// # struct A { x: i32, y: i32 }\n     /// impl PartialEq for A {\n     ///     fn eq(&self, other: &A) -> bool {\n-    ///         let Self { x: ref __self_0_0, y: ref __self_0_1 } = *self;\n-    ///         let Self { x: ref __self_1_0, y: ref __self_1_1 } = *other;\n-    ///         *__self_0_0 == *__self_1_0 && *__self_0_1 == *__self_1_1\n+    ///         let Self { x: __self_0_0, y: __self_0_1 } = *self;\n+    ///         let Self { x: __self_1_0, y: __self_1_1 } = *other;\n+    ///         __self_0_0 == __self_1_0 && __self_0_1 == __self_1_1\n     ///     }\n     /// }\n     /// ```\n@@ -1039,8 +1035,8 @@ impl<'a> MethodDef<'a> {\n         type_ident: Ident,\n         selflike_args: &[P<Expr>],\n         nonselflike_args: &[P<Expr>],\n-        use_temporaries: bool,\n         is_packed: bool,\n+        always_copy: bool,\n     ) -> BlockOrExpr {\n         let span = trait_.span;\n         assert!(selflike_args.len() == 1 || selflike_args.len() == 2);\n@@ -1062,23 +1058,21 @@ impl<'a> MethodDef<'a> {\n         } else {\n             let prefixes: Vec<_> =\n                 (0..selflike_args.len()).map(|i| format!(\"__self_{}\", i)).collect();\n+            let no_deref = always_copy;\n             let selflike_fields =\n-                trait_.create_struct_pattern_fields(cx, struct_def, &prefixes, use_temporaries);\n+                trait_.create_struct_pattern_fields(cx, struct_def, &prefixes, no_deref);\n             let mut body = mk_body(cx, selflike_fields);\n \n             let struct_path = cx.path(span, vec![Ident::new(kw::SelfUpper, type_ident.span)]);\n-            let patterns = trait_.create_struct_patterns(\n-                cx,\n-                struct_path,\n-                struct_def,\n-                &prefixes,\n-                use_temporaries,\n-            );\n+            let use_ref_pat = is_packed && !always_copy;\n+            let patterns =\n+                trait_.create_struct_patterns(cx, struct_path, struct_def, &prefixes, use_ref_pat);\n \n             // Do the let-destructuring.\n             let mut stmts: Vec<_> = iter::zip(selflike_args, patterns)\n                 .map(|(selflike_arg_expr, pat)| {\n-                    cx.stmt_let_pat(span, pat, selflike_arg_expr.clone())\n+                    let selflike_arg_expr = cx.expr_deref(span, selflike_arg_expr.clone());\n+                    cx.stmt_let_pat(span, pat, selflike_arg_expr)\n                 })\n                 .collect();\n             stmts.extend(std::mem::take(&mut body.0));\n@@ -1118,18 +1112,16 @@ impl<'a> MethodDef<'a> {\n     /// impl ::core::cmp::PartialEq for A {\n     ///     #[inline]\n     ///     fn eq(&self, other: &A) -> bool {\n-    ///         {\n-    ///             let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-    ///             let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n-    ///             if true && __self_vi == __arg_1_vi {\n-    ///                 match (&*self, &*other) {\n-    ///                     (&A::A2(ref __self_0), &A::A2(ref __arg_1_0)) =>\n-    ///                         (*__self_0) == (*__arg_1_0),\n-    ///                     _ => true,\n-    ///                 }\n-    ///             } else {\n-    ///                 false // catch-all handler\n+    ///         let __self_vi = ::core::intrinsics::discriminant_value(self);\n+    ///         let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n+    ///         if __self_vi == __arg_1_vi {\n+    ///             match (self, other) {\n+    ///                 (A::A2(__self_0), A::A2(__arg_1_0)) =>\n+    ///                     *__self_0 == *__arg_1_0,\n+    ///                 _ => true,\n     ///             }\n+    ///         } else {\n+    ///             false // catch-all handler\n     ///         }\n     ///     }\n     /// }\n@@ -1202,28 +1194,21 @@ impl<'a> MethodDef<'a> {\n                 // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n                 // (see \"Final wrinkle\" note below for why.)\n \n-                let use_temporaries = false; // enums can't be repr(packed)\n-                let fields = trait_.create_struct_pattern_fields(\n+                let no_deref = false; // because enums can't be repr(packed)\n+                let fields =\n+                    trait_.create_struct_pattern_fields(cx, &variant.data, &prefixes, no_deref);\n+\n+                let sp = variant.span.with_ctxt(trait_.span.ctxt());\n+                let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n+                let use_ref_pat = false; // because enums can't be repr(packed)\n+                let mut subpats: Vec<_> = trait_.create_struct_patterns(\n                     cx,\n+                    variant_path,\n                     &variant.data,\n                     &prefixes,\n-                    use_temporaries,\n+                    use_ref_pat,\n                 );\n \n-                let sp = variant.span.with_ctxt(trait_.span.ctxt());\n-                let variant_path = cx.path(sp, vec![type_ident, variant.ident]);\n-                let mut subpats: Vec<_> = trait_\n-                    .create_struct_patterns(\n-                        cx,\n-                        variant_path,\n-                        &variant.data,\n-                        &prefixes,\n-                        use_temporaries,\n-                    )\n-                    .into_iter()\n-                    .map(|p| cx.pat(span, PatKind::Ref(p, ast::Mutability::Not)))\n-                    .collect();\n-\n                 // Here is the pat = `(&VariantK, &VariantK, ...)`\n                 let single_pat = if subpats.len() == 1 {\n                     subpats.pop().unwrap()\n@@ -1302,25 +1287,23 @@ impl<'a> MethodDef<'a> {\n             // Build a series of let statements mapping each selflike_arg\n             // to its discriminant value.\n             //\n-            // i.e., for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n-            // with three Self args, builds three statements:\n+            // i.e., for `enum E<T> { A, B(1), C(T, T) }` for `PartialEq::eq`,\n+            // builds two statements:\n             // ```\n-            // let __self_vi = std::intrinsics::discriminant_value(&self);\n-            // let __arg_1_vi = std::intrinsics::discriminant_value(&arg1);\n-            // let __arg_2_vi = std::intrinsics::discriminant_value(&arg2);\n+            // let __self_vi = ::core::intrinsics::discriminant_value(self);\n+            // let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n             // ```\n             let mut index_let_stmts: Vec<ast::Stmt> = Vec::with_capacity(vi_idents.len() + 1);\n \n-            // We also build an expression which checks whether all discriminants are equal:\n-            // `__self_vi == __arg_1_vi && __self_vi == __arg_2_vi && ...`\n+            // We also build an expression which checks whether all discriminants are equal, e.g.\n+            // `__self_vi == __arg_1_vi`.\n             let mut discriminant_test = cx.expr_bool(span, true);\n             for (i, (&ident, selflike_arg)) in iter::zip(&vi_idents, &selflike_args).enumerate() {\n-                let selflike_addr = cx.expr_addr_of(span, selflike_arg.clone());\n                 let variant_value = deriving::call_intrinsic(\n                     cx,\n                     span,\n                     sym::discriminant_value,\n-                    vec![selflike_addr],\n+                    vec![selflike_arg.clone()],\n                 );\n                 let let_stmt = cx.stmt_let(span, false, ident, variant_value);\n                 index_let_stmts.push(let_stmt);\n@@ -1347,17 +1330,11 @@ impl<'a> MethodDef<'a> {\n                 )\n                 .into_expr(cx, span);\n \n-            // Final wrinkle: the selflike_args are expressions that deref\n-            // down to desired places, but we cannot actually deref\n-            // them when they are fed as r-values into a tuple\n-            // expression; here add a layer of borrowing, turning\n-            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            selflike_args.map_in_place(|selflike_arg| cx.expr_addr_of(span, selflike_arg));\n             let match_arg = cx.expr(span, ast::ExprKind::Tup(selflike_args));\n \n-            // Lastly we create an expression which branches on all discriminants being equal\n-            //  if discriminant_test {\n-            //      match (...) {\n+            // Lastly we create an expression which branches on all discriminants being equal, e.g.\n+            //  if __self_vi == _arg_1_vi {\n+            //      match (self, other) {\n             //          (Variant1, Variant1, ...) => Body1\n             //          (Variant2, Variant2, ...) => Body2,\n             //          ...\n@@ -1376,12 +1353,6 @@ impl<'a> MethodDef<'a> {\n             // for the zero variant case.\n             BlockOrExpr(vec![], Some(deriving::call_unreachable(cx, span)))\n         } else {\n-            // Final wrinkle: the selflike_args are expressions that deref\n-            // down to desired places, but we cannot actually deref\n-            // them when they are fed as r-values into a tuple\n-            // expression; here add a layer of borrowing, turning\n-            // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n-            selflike_args.map_in_place(|selflike_arg| cx.expr_addr_of(span, selflike_arg));\n             let match_arg = if selflike_args.len() == 1 {\n                 selflike_args.pop().unwrap()\n             } else {\n@@ -1451,18 +1422,18 @@ impl<'a> TraitDef<'a> {\n         struct_path: ast::Path,\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n-        use_temporaries: bool,\n+        use_ref_pat: bool,\n     ) -> Vec<P<ast::Pat>> {\n         prefixes\n             .iter()\n             .map(|prefix| {\n                 let pieces_iter =\n                     struct_def.fields().iter().enumerate().map(|(i, struct_field)| {\n                         let sp = struct_field.span.with_ctxt(self.span.ctxt());\n-                        let binding_mode = if use_temporaries {\n-                            ast::BindingMode::ByValue(ast::Mutability::Not)\n-                        } else {\n+                        let binding_mode = if use_ref_pat {\n                             ast::BindingMode::ByRef(ast::Mutability::Not)\n+                        } else {\n+                            ast::BindingMode::ByValue(ast::Mutability::Not)\n                         };\n                         let ident = self.mk_pattern_ident(prefix, i);\n                         let path = ident.with_span_pos(sp);\n@@ -1541,15 +1512,15 @@ impl<'a> TraitDef<'a> {\n         cx: &mut ExtCtxt<'_>,\n         struct_def: &'a VariantData,\n         prefixes: &[String],\n-        use_temporaries: bool,\n+        no_deref: bool,\n     ) -> Vec<FieldInfo> {\n         self.create_fields(struct_def, |i, _struct_field, sp| {\n             prefixes\n                 .iter()\n                 .map(|prefix| {\n                     let ident = self.mk_pattern_ident(prefix, i);\n                     let expr = cx.expr_path(cx.path_ident(sp, ident));\n-                    if use_temporaries { expr } else { cx.expr_deref(sp, expr) }\n+                    if no_deref { expr } else { cx.expr_deref(sp, expr) }\n                 })\n                 .collect()\n         })\n@@ -1564,11 +1535,7 @@ impl<'a> TraitDef<'a> {\n         self.create_fields(struct_def, |i, struct_field, sp| {\n             selflike_args\n                 .iter()\n-                .map(|mut selflike_arg| {\n-                    // We don't the need the deref, if there is one.\n-                    if let ast::ExprKind::Unary(ast::UnOp::Deref, inner) = &selflike_arg.kind {\n-                        selflike_arg = inner;\n-                    }\n+                .map(|selflike_arg| {\n                     // Note: we must use `struct_field.span` rather than `span` in the\n                     // `unwrap_or_else` case otherwise the hygiene is wrong and we get\n                     // \"field `0` of struct `Point` is private\" errors on tuple"}, {"sha": "4d46f7cd48a5107117d36938df28808b379dedd5", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/277bc9641d5585fcb2d94440efc6b1880a74fd64/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/277bc9641d5585fcb2d94440efc6b1880a74fd64/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=277bc9641d5585fcb2d94440efc6b1880a74fd64", "patch": "@@ -196,9 +196,8 @@ impl Bounds {\n }\n \n pub fn get_explicit_self(cx: &ExtCtxt<'_>, span: Span) -> (P<Expr>, ast::ExplicitSelf) {\n-    // this constructs a fresh `self` path\n+    // This constructs a fresh `self` path.\n     let self_path = cx.expr_self(span);\n     let self_ty = respan(span, SelfKind::Region(None, ast::Mutability::Not));\n-    let self_expr = cx.expr_deref(span, self_path);\n-    (self_expr, self_ty)\n+    (self_path, self_ty)\n }"}, {"sha": "ae98d1ad9e6e2d8229f006309d32cd18f7df96c5", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 105, "deletions": 107, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/277bc9641d5585fcb2d94440efc6b1880a74fd64/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/277bc9641d5585fcb2d94440efc6b1880a74fd64/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=277bc9641d5585fcb2d94440efc6b1880a74fd64", "patch": "@@ -675,8 +675,8 @@ enum Enum1 {\n impl ::core::clone::Clone for Enum1 {\n     #[inline]\n     fn clone(&self) -> Enum1 {\n-        match &*self {\n-            &Enum1::Single { x: ref __self_0 } =>\n+        match self {\n+            Enum1::Single { x: __self_0 } =>\n                 Enum1::Single { x: ::core::clone::Clone::clone(&*__self_0) },\n         }\n     }\n@@ -685,8 +685,8 @@ impl ::core::clone::Clone for Enum1 {\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Enum1 {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match &*self {\n-            &Enum1::Single { x: ref __self_0 } =>\n+        match self {\n+            Enum1::Single { x: __self_0 } =>\n                 ::core::fmt::Formatter::debug_struct_field1_finish(f,\n                     \"Single\", \"x\", &&*__self_0),\n         }\n@@ -696,8 +696,8 @@ impl ::core::fmt::Debug for Enum1 {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Enum1 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match &*self {\n-            &Enum1::Single { x: ref __self_0 } => {\n+        match self {\n+            Enum1::Single { x: __self_0 } => {\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n         }\n@@ -709,16 +709,16 @@ impl ::core::marker::StructuralPartialEq for Enum1 {}\n impl ::core::cmp::PartialEq for Enum1 {\n     #[inline]\n     fn eq(&self, other: &Enum1) -> bool {\n-        match (&*self, &*other) {\n-            (&Enum1::Single { x: ref __self_0 }, &Enum1::Single {\n-                x: ref __arg_1_0 }) => *__self_0 == *__arg_1_0,\n+        match (self, other) {\n+            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg_1_0 }) =>\n+                *__self_0 == *__arg_1_0,\n         }\n     }\n     #[inline]\n     fn ne(&self, other: &Enum1) -> bool {\n-        match (&*self, &*other) {\n-            (&Enum1::Single { x: ref __self_0 }, &Enum1::Single {\n-                x: ref __arg_1_0 }) => *__self_0 != *__arg_1_0,\n+        match (self, other) {\n+            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg_1_0 }) =>\n+                *__self_0 != *__arg_1_0,\n         }\n     }\n }\n@@ -739,9 +739,8 @@ impl ::core::cmp::PartialOrd for Enum1 {\n     #[inline]\n     fn partial_cmp(&self, other: &Enum1)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        match (&*self, &*other) {\n-            (&Enum1::Single { x: ref __self_0 }, &Enum1::Single {\n-                x: ref __arg_1_0 }) =>\n+        match (self, other) {\n+            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg_1_0 }) =>\n                 ::core::cmp::PartialOrd::partial_cmp(&*__self_0, &*__arg_1_0),\n         }\n     }\n@@ -751,9 +750,8 @@ impl ::core::cmp::PartialOrd for Enum1 {\n impl ::core::cmp::Ord for Enum1 {\n     #[inline]\n     fn cmp(&self, other: &Enum1) -> ::core::cmp::Ordering {\n-        match (&*self, &*other) {\n-            (&Enum1::Single { x: ref __self_0 }, &Enum1::Single {\n-                x: ref __arg_1_0 }) =>\n+        match (self, other) {\n+            (Enum1::Single { x: __self_0 }, Enum1::Single { x: __arg_1_0 }) =>\n                 ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n         }\n     }\n@@ -770,15 +768,15 @@ enum Fieldless1 {\n impl ::core::clone::Clone for Fieldless1 {\n     #[inline]\n     fn clone(&self) -> Fieldless1 {\n-        match &*self { &Fieldless1::A => Fieldless1::A, }\n+        match self { Fieldless1::A => Fieldless1::A, }\n     }\n }\n #[automatically_derived]\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fieldless1 {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match &*self {\n-            &Fieldless1::A => ::core::fmt::Formatter::write_str(f, \"A\"),\n+        match self {\n+            Fieldless1::A => ::core::fmt::Formatter::write_str(f, \"A\"),\n         }\n     }\n }\n@@ -792,7 +790,7 @@ impl ::core::default::Default for Fieldless1 {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fieldless1 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match &*self { _ => {} }\n+        match self { _ => {} }\n     }\n }\n impl ::core::marker::StructuralPartialEq for Fieldless1 {}\n@@ -801,7 +799,7 @@ impl ::core::marker::StructuralPartialEq for Fieldless1 {}\n impl ::core::cmp::PartialEq for Fieldless1 {\n     #[inline]\n     fn eq(&self, other: &Fieldless1) -> bool {\n-        match (&*self, &*other) { _ => true, }\n+        match (self, other) { _ => true, }\n     }\n }\n impl ::core::marker::StructuralEq for Fieldless1 {}\n@@ -819,7 +817,7 @@ impl ::core::cmp::PartialOrd for Fieldless1 {\n     #[inline]\n     fn partial_cmp(&self, other: &Fieldless1)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        match (&*self, &*other) {\n+        match (self, other) {\n             _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n         }\n     }\n@@ -829,7 +827,7 @@ impl ::core::cmp::PartialOrd for Fieldless1 {\n impl ::core::cmp::Ord for Fieldless1 {\n     #[inline]\n     fn cmp(&self, other: &Fieldless1) -> ::core::cmp::Ordering {\n-        match (&*self, &*other) { _ => ::core::cmp::Ordering::Equal, }\n+        match (self, other) { _ => ::core::cmp::Ordering::Equal, }\n     }\n }\n \n@@ -854,10 +852,10 @@ impl ::core::marker::Copy for Fieldless { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fieldless {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match &*self {\n-            &Fieldless::A => ::core::fmt::Formatter::write_str(f, \"A\"),\n-            &Fieldless::B => ::core::fmt::Formatter::write_str(f, \"B\"),\n-            &Fieldless::C => ::core::fmt::Formatter::write_str(f, \"C\"),\n+        match self {\n+            Fieldless::A => ::core::fmt::Formatter::write_str(f, \"A\"),\n+            Fieldless::B => ::core::fmt::Formatter::write_str(f, \"B\"),\n+            Fieldless::C => ::core::fmt::Formatter::write_str(f, \"C\"),\n         }\n     }\n }\n@@ -871,7 +869,7 @@ impl ::core::default::Default for Fieldless {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fieldless {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match &*self {\n+        match self {\n             _ => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state)\n@@ -885,10 +883,10 @@ impl ::core::marker::StructuralPartialEq for Fieldless {}\n impl ::core::cmp::PartialEq for Fieldless {\n     #[inline]\n     fn eq(&self, other: &Fieldless) -> bool {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) { _ => true, }\n+                match (self, other) { _ => true, }\n             } else { false }\n     }\n }\n@@ -907,10 +905,10 @@ impl ::core::cmp::PartialOrd for Fieldless {\n     #[inline]\n     fn partial_cmp(&self, other: &Fieldless)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) {\n+                match (self, other) {\n                     _ =>\n                         ::core::option::Option::Some(::core::cmp::Ordering::Equal),\n                 }\n@@ -924,10 +922,10 @@ impl ::core::cmp::PartialOrd for Fieldless {\n impl ::core::cmp::Ord for Fieldless {\n     #[inline]\n     fn cmp(&self, other: &Fieldless) -> ::core::cmp::Ordering {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) { _ => ::core::cmp::Ordering::Equal, }\n+                match (self, other) { _ => ::core::cmp::Ordering::Equal, }\n             } else { ::core::cmp::Ord::cmp(&__self_vi, &__arg_1_vi) }\n     }\n }\n@@ -960,13 +958,13 @@ impl ::core::marker::Copy for Mixed { }\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Mixed {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match &*self {\n-            &Mixed::P => ::core::fmt::Formatter::write_str(f, \"P\"),\n-            &Mixed::Q => ::core::fmt::Formatter::write_str(f, \"Q\"),\n-            &Mixed::R(ref __self_0) =>\n+        match self {\n+            Mixed::P => ::core::fmt::Formatter::write_str(f, \"P\"),\n+            Mixed::Q => ::core::fmt::Formatter::write_str(f, \"Q\"),\n+            Mixed::R(__self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"R\",\n                     &&*__self_0),\n-            &Mixed::S { d1: ref __self_0, d2: ref __self_1 } =>\n+            Mixed::S { d1: __self_0, d2: __self_1 } =>\n                 ::core::fmt::Formatter::debug_struct_field2_finish(f, \"S\",\n                     \"d1\", &&*__self_0, \"d2\", &&*__self_1),\n         }\n@@ -982,13 +980,13 @@ impl ::core::default::Default for Mixed {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Mixed {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match &*self {\n-            &Mixed::R(ref __self_0) => {\n+        match self {\n+            Mixed::R(__self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n-            &Mixed::S { d1: ref __self_0, d2: ref __self_1 } => {\n+            Mixed::S { d1: __self_0, d2: __self_1 } => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state);\n@@ -1007,29 +1005,29 @@ impl ::core::marker::StructuralPartialEq for Mixed {}\n impl ::core::cmp::PartialEq for Mixed {\n     #[inline]\n     fn eq(&self, other: &Mixed) -> bool {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) {\n-                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                match (self, other) {\n+                    (Mixed::R(__self_0), Mixed::R(__arg_1_0)) =>\n                         *__self_0 == *__arg_1_0,\n-                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                    (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n+                        d1: __arg_1_0, d2: __arg_1_1 }) =>\n                         *__self_0 == *__arg_1_0 && *__self_1 == *__arg_1_1,\n                     _ => true,\n                 }\n             } else { false }\n     }\n     #[inline]\n     fn ne(&self, other: &Mixed) -> bool {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) {\n-                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                match (self, other) {\n+                    (Mixed::R(__self_0), Mixed::R(__arg_1_0)) =>\n                         *__self_0 != *__arg_1_0,\n-                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                    (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n+                        d1: __arg_1_0, d2: __arg_1_1 }) =>\n                         *__self_0 != *__arg_1_0 || *__self_1 != *__arg_1_1,\n                     _ => false,\n                 }\n@@ -1053,15 +1051,15 @@ impl ::core::cmp::PartialOrd for Mixed {\n     #[inline]\n     fn partial_cmp(&self, other: &Mixed)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) {\n-                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                match (self, other) {\n+                    (Mixed::R(__self_0), Mixed::R(__arg_1_0)) =>\n                         ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n                             &*__arg_1_0),\n-                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                    (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n+                        d1: __arg_1_0, d2: __arg_1_1 }) =>\n                         match ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n                                 &*__arg_1_0) {\n                             ::core::option::Option::Some(::core::cmp::Ordering::Equal)\n@@ -1083,14 +1081,14 @@ impl ::core::cmp::PartialOrd for Mixed {\n impl ::core::cmp::Ord for Mixed {\n     #[inline]\n     fn cmp(&self, other: &Mixed) -> ::core::cmp::Ordering {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) {\n-                    (&Mixed::R(ref __self_0), &Mixed::R(ref __arg_1_0)) =>\n+                match (self, other) {\n+                    (Mixed::R(__self_0), Mixed::R(__arg_1_0)) =>\n                         ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n-                    (&Mixed::S { d1: ref __self_0, d2: ref __self_1 },\n-                        &Mixed::S { d1: ref __arg_1_0, d2: ref __arg_1_1 }) =>\n+                    (Mixed::S { d1: __self_0, d2: __self_1 }, Mixed::S {\n+                        d1: __arg_1_0, d2: __arg_1_1 }) =>\n                         match ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0) {\n                             ::core::cmp::Ordering::Equal =>\n                                 ::core::cmp::Ord::cmp(&*__self_1, &*__arg_1_1),\n@@ -1110,12 +1108,12 @@ enum Fielded { X(u32), Y(bool), Z(Option<i32>), }\n impl ::core::clone::Clone for Fielded {\n     #[inline]\n     fn clone(&self) -> Fielded {\n-        match &*self {\n-            &Fielded::X(ref __self_0) =>\n+        match self {\n+            Fielded::X(__self_0) =>\n                 Fielded::X(::core::clone::Clone::clone(&*__self_0)),\n-            &Fielded::Y(ref __self_0) =>\n+            Fielded::Y(__self_0) =>\n                 Fielded::Y(::core::clone::Clone::clone(&*__self_0)),\n-            &Fielded::Z(ref __self_0) =>\n+            Fielded::Z(__self_0) =>\n                 Fielded::Z(::core::clone::Clone::clone(&*__self_0)),\n         }\n     }\n@@ -1124,14 +1122,14 @@ impl ::core::clone::Clone for Fielded {\n #[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fielded {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n-        match &*self {\n-            &Fielded::X(ref __self_0) =>\n+        match self {\n+            Fielded::X(__self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"X\",\n                     &&*__self_0),\n-            &Fielded::Y(ref __self_0) =>\n+            Fielded::Y(__self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Y\",\n                     &&*__self_0),\n-            &Fielded::Z(ref __self_0) =>\n+            Fielded::Z(__self_0) =>\n                 ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Z\",\n                     &&*__self_0),\n         }\n@@ -1141,18 +1139,18 @@ impl ::core::fmt::Debug for Fielded {\n #[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fielded {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n-        match &*self {\n-            &Fielded::X(ref __self_0) => {\n+        match self {\n+            Fielded::X(__self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n-            &Fielded::Y(ref __self_0) => {\n+            Fielded::Y(__self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n             }\n-            &Fielded::Z(ref __self_0) => {\n+            Fielded::Z(__self_0) => {\n                 ::core::hash::Hash::hash(&::core::intrinsics::discriminant_value(self),\n                     state);\n                 ::core::hash::Hash::hash(&*__self_0, state)\n@@ -1166,31 +1164,31 @@ impl ::core::marker::StructuralPartialEq for Fielded {}\n impl ::core::cmp::PartialEq for Fielded {\n     #[inline]\n     fn eq(&self, other: &Fielded) -> bool {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) {\n-                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                match (self, other) {\n+                    (Fielded::X(__self_0), Fielded::X(__arg_1_0)) =>\n                         *__self_0 == *__arg_1_0,\n-                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                    (Fielded::Y(__self_0), Fielded::Y(__arg_1_0)) =>\n                         *__self_0 == *__arg_1_0,\n-                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                    (Fielded::Z(__self_0), Fielded::Z(__arg_1_0)) =>\n                         *__self_0 == *__arg_1_0,\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }\n             } else { false }\n     }\n     #[inline]\n     fn ne(&self, other: &Fielded) -> bool {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) {\n-                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                match (self, other) {\n+                    (Fielded::X(__self_0), Fielded::X(__arg_1_0)) =>\n                         *__self_0 != *__arg_1_0,\n-                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                    (Fielded::Y(__self_0), Fielded::Y(__arg_1_0)) =>\n                         *__self_0 != *__arg_1_0,\n-                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                    (Fielded::Z(__self_0), Fielded::Z(__arg_1_0)) =>\n                         *__self_0 != *__arg_1_0,\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }\n@@ -1216,17 +1214,17 @@ impl ::core::cmp::PartialOrd for Fielded {\n     #[inline]\n     fn partial_cmp(&self, other: &Fielded)\n         -> ::core::option::Option<::core::cmp::Ordering> {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) {\n-                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                match (self, other) {\n+                    (Fielded::X(__self_0), Fielded::X(__arg_1_0)) =>\n                         ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n                             &*__arg_1_0),\n-                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                    (Fielded::Y(__self_0), Fielded::Y(__arg_1_0)) =>\n                         ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n                             &*__arg_1_0),\n-                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                    (Fielded::Z(__self_0), Fielded::Z(__arg_1_0)) =>\n                         ::core::cmp::PartialOrd::partial_cmp(&*__self_0,\n                             &*__arg_1_0),\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n@@ -1241,15 +1239,15 @@ impl ::core::cmp::PartialOrd for Fielded {\n impl ::core::cmp::Ord for Fielded {\n     #[inline]\n     fn cmp(&self, other: &Fielded) -> ::core::cmp::Ordering {\n-        let __self_vi = ::core::intrinsics::discriminant_value(&*self);\n-        let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);\n+        let __self_vi = ::core::intrinsics::discriminant_value(self);\n+        let __arg_1_vi = ::core::intrinsics::discriminant_value(other);\n         if __self_vi == __arg_1_vi {\n-                match (&*self, &*other) {\n-                    (&Fielded::X(ref __self_0), &Fielded::X(ref __arg_1_0)) =>\n+                match (self, other) {\n+                    (Fielded::X(__self_0), Fielded::X(__arg_1_0)) =>\n                         ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n-                    (&Fielded::Y(ref __self_0), &Fielded::Y(ref __arg_1_0)) =>\n+                    (Fielded::Y(__self_0), Fielded::Y(__arg_1_0)) =>\n                         ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n-                    (&Fielded::Z(ref __self_0), &Fielded::Z(ref __arg_1_0)) =>\n+                    (Fielded::Z(__self_0), Fielded::Z(__arg_1_0)) =>\n                         ::core::cmp::Ord::cmp(&*__self_0, &*__arg_1_0),\n                     _ => unsafe { ::core::intrinsics::unreachable() }\n                 }"}]}