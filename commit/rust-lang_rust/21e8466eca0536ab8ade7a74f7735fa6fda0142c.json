{"sha": "21e8466eca0536ab8ade7a74f7735fa6fda0142c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZTg0NjZlY2EwNTM2YWI4YWRlN2E3NGY3NzM1ZmE2ZmRhMDE0MmM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-01-17T03:57:59Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-03T20:04:30Z"}, "message": "extra: Re-add the Once primitve to extra::sync\n\nThis originally lived in std::unstable::mutex, but now it has a new home (and a\nmore proper one).", "tree": {"sha": "813493fe6358c5576adaca16d72fa2b78cf436c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/813493fe6358c5576adaca16d72fa2b78cf436c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21e8466eca0536ab8ade7a74f7735fa6fda0142c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21e8466eca0536ab8ade7a74f7735fa6fda0142c", "html_url": "https://github.com/rust-lang/rust/commit/21e8466eca0536ab8ade7a74f7735fa6fda0142c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21e8466eca0536ab8ade7a74f7735fa6fda0142c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99582f88847b6c1feba61c4cbce7e95308d5103b", "url": "https://api.github.com/repos/rust-lang/rust/commits/99582f88847b6c1feba61c4cbce7e95308d5103b", "html_url": "https://github.com/rust-lang/rust/commit/99582f88847b6c1feba61c4cbce7e95308d5103b"}], "stats": {"total": 194, "additions": 184, "deletions": 10}, "files": [{"sha": "6dc1cbee6dc4ea91702c7086f9f9cfbe077c1265", "filename": "src/libextra/sync/one.rs", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/21e8466eca0536ab8ade7a74f7735fa6fda0142c/src%2Flibextra%2Fsync%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e8466eca0536ab8ade7a74f7735fa6fda0142c/src%2Flibextra%2Fsync%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync%2Fone.rs?ref=21e8466eca0536ab8ade7a74f7735fa6fda0142c", "patch": "@@ -0,0 +1,168 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A \"once initialization\" primitive\n+//!\n+//! This primitive is meant to be used to run one-time initialization. An\n+//! example use case would be for initializing an FFI library.\n+\n+use std::int;\n+use std::sync::atomics;\n+use sync::mutex::{StaticMutex, MUTEX_INIT};\n+\n+/// A type which can be used to run a one-time global initialization. This type\n+/// is *unsafe* to use because it is built on top of the `Mutex` in this module.\n+/// It does not know whether the currently running task is in a green or native\n+/// context, and a blocking mutex should *not* be used under normal\n+/// circumstances on a green task.\n+///\n+/// Despite its unsafety, it is often useful to have a one-time initialization\n+/// routine run for FFI bindings or related external functionality. This type\n+/// can only be statically constructed with the `ONCE_INIT` value.\n+///\n+/// # Example\n+///\n+/// ```rust\n+/// use std::unstable::mutex::{Once, ONCE_INIT};\n+///\n+/// static mut START: Once = ONCE_INIT;\n+/// unsafe {\n+///     START.doit(|| {\n+///         // run initialization here\n+///     });\n+/// }\n+/// ```\n+pub struct Once {\n+    priv mutex: StaticMutex,\n+    priv cnt: atomics::AtomicInt,\n+    priv lock_cnt: atomics::AtomicInt,\n+}\n+\n+/// Initialization value for static `Once` values.\n+pub static ONCE_INIT: Once = Once {\n+    mutex: MUTEX_INIT,\n+    cnt: atomics::INIT_ATOMIC_INT,\n+    lock_cnt: atomics::INIT_ATOMIC_INT,\n+};\n+\n+impl Once {\n+    /// Perform an initialization routine once and only once. The given closure\n+    /// will be executed if this is the first time `doit` has been called, and\n+    /// otherwise the routine will *not* be invoked.\n+    ///\n+    /// This method will block the calling *os thread* if another initialization\n+    /// routine is currently running.\n+    ///\n+    /// When this function returns, it is guaranteed that some initialization\n+    /// has run and completed (it may not be the closure specified).\n+    pub fn doit(&mut self, f: ||) {\n+        // Implementation-wise, this would seem like a fairly trivial primitive.\n+        // The stickler part is where our mutexes currently require an\n+        // allocation, and usage of a `Once` should't leak this allocation.\n+        //\n+        // This means that there must be a deterministic destroyer of the mutex\n+        // contained within (because it's not needed after the initialization\n+        // has run).\n+        //\n+        // The general scheme here is to gate all future threads once\n+        // initialization has completed with a \"very negative\" count, and to\n+        // allow through threads to lock the mutex if they see a non negative\n+        // count. For all threads grabbing the mutex, exactly one of them should\n+        // be responsible for unlocking the mutex, and this should only be done\n+        // once everyone else is done with the mutex.\n+        //\n+        // This atomicity is achieved by swapping a very negative value into the\n+        // shared count when the initialization routine has completed. This will\n+        // read the number of threads which will at some point attempt to\n+        // acquire the mutex. This count is then squirreled away in a separate\n+        // variable, and the last person on the way out of the mutex is then\n+        // responsible for destroying the mutex.\n+        //\n+        // It is crucial that the negative value is swapped in *after* the\n+        // initialization routine has completed because otherwise new threads\n+        // calling `doit` will return immediately before the initialization has\n+        // completed.\n+\n+        let prev = self.cnt.fetch_add(1, atomics::SeqCst);\n+        if prev < 0 {\n+            // Make sure we never overflow, we'll never have int::MIN\n+            // simultaneous calls to `doit` to make this value go back to 0\n+            self.cnt.store(int::MIN, atomics::SeqCst);\n+            return\n+        }\n+\n+        // If the count is negative, then someone else finished the job,\n+        // otherwise we run the job and record how many people will try to grab\n+        // this lock\n+        {\n+            let _guard = self.mutex.lock();\n+            if self.cnt.load(atomics::SeqCst) > 0 {\n+                f();\n+                let prev = self.cnt.swap(int::MIN, atomics::SeqCst);\n+                self.lock_cnt.store(prev, atomics::SeqCst);\n+            }\n+        }\n+\n+        // Last one out cleans up after everyone else, no leaks!\n+        if self.lock_cnt.fetch_add(-1, atomics::SeqCst) == 1 {\n+            unsafe { self.mutex.destroy() }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{ONCE_INIT, Once};\n+    use std::task;\n+\n+    #[test]\n+    fn smoke_once() {\n+        static mut o: Once = ONCE_INIT;\n+        let mut a = 0;\n+        unsafe { o.doit(|| a += 1); }\n+        assert_eq!(a, 1);\n+        unsafe { o.doit(|| a += 1); }\n+        assert_eq!(a, 1);\n+    }\n+\n+    #[test]\n+    fn stampede_once() {\n+        static mut o: Once = ONCE_INIT;\n+        static mut run: bool = false;\n+\n+        let (p, c) = SharedChan::new();\n+        for _ in range(0, 10) {\n+            let c = c.clone();\n+            do spawn {\n+                for _ in range(0, 4) { task::deschedule() }\n+                unsafe {\n+                    o.doit(|| {\n+                        assert!(!run);\n+                        run = true;\n+                    });\n+                    assert!(run);\n+                }\n+                c.send(());\n+            }\n+        }\n+\n+        unsafe {\n+            o.doit(|| {\n+                assert!(!run);\n+                run = true;\n+            });\n+            assert!(run);\n+        }\n+\n+        for _ in range(0, 10) {\n+            p.recv();\n+        }\n+    }\n+}"}, {"sha": "cf0b1f05ebda06dc4f08b402badda11987afd609", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/21e8466eca0536ab8ade7a74f7735fa6fda0142c/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e8466eca0536ab8ade7a74f7735fa6fda0142c/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=21e8466eca0536ab8ade7a74f7735fa6fda0142c", "patch": "@@ -201,14 +201,20 @@ pub fn init() {\n     }\n \n     unsafe {\n-        use std::unstable::mutex::{Once, ONCE_INIT};\n-        static mut INIT: Once = ONCE_INIT;\n-        INIT.doit(|| {\n-            let mut data: WSADATA = intrinsics::init();\n-            let ret = WSAStartup(0x202,      // version 2.2\n-                                 &mut data);\n-            assert_eq!(ret, 0);\n-        });\n+        use std::unstable::mutex::{Mutex, MUTEX_INIT};\n+        static mut INITIALIZED: bool = false;\n+        static mut LOCK: Mutex = MUTEX_INIT;\n+        unsafe {\n+            LOCK.lock();\n+            if !INITIALIZED {\n+                let mut data: WSADATA = intrinsics::init();\n+                let ret = WSAStartup(0x202,      // version 2.2\n+                                     &mut data);\n+                assert_eq!(ret, 0);\n+                INITIALIZED = true;\n+            }\n+            LOCK.unlock();\n+        }\n     }\n }\n "}, {"sha": "8cdf79b274d4ffbd6812f899312cefc939a5e633", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e8466eca0536ab8ade7a74f7735fa6fda0142c/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e8466eca0536ab8ade7a74f7735fa6fda0142c/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=21e8466eca0536ab8ade7a74f7735fa6fda0142c", "patch": "@@ -332,7 +332,7 @@ pub mod write {\n     }\n \n     unsafe fn configure_llvm(sess: Session) {\n-        use std::unstable::mutex::{Once, ONCE_INIT};\n+        use extra::sync::one::{Once, ONCE_INIT};\n         static mut INIT: Once = ONCE_INIT;\n \n         // Copy what clang does by turning on loop vectorization at O2 and"}, {"sha": "1ebe4a03cfdd2a5cef44df6175ec81c10462365a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e8466eca0536ab8ade7a74f7735fa6fda0142c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e8466eca0536ab8ade7a74f7735fa6fda0142c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=21e8466eca0536ab8ade7a74f7735fa6fda0142c", "patch": "@@ -2660,7 +2660,7 @@ pub fn trans_crate(sess: session::Session,\n                    output: &Path) -> CrateTranslation {\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     unsafe {\n-        use std::unstable::mutex::{Once, ONCE_INIT};\n+        use extra::sync::one::{Once, ONCE_INIT};\n         static mut INIT: Once = ONCE_INIT;\n         static mut POISONED: bool = false;\n         INIT.doit(|| {"}]}