{"sha": "9782fc42852927428736f27f0496deece545f46c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3ODJmYzQyODUyOTI3NDI4NzM2ZjI3ZjA0OTZkZWVjZTU0NWY0NmM=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-27T11:43:59Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-27T13:49:55Z"}, "message": "move not_unsafe_ptr_arg_deref to its own module", "tree": {"sha": "9a26086d2884726e01776e22fedc7187e667f3d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a26086d2884726e01776e22fedc7187e667f3d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9782fc42852927428736f27f0496deece545f46c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9782fc42852927428736f27f0496deece545f46c", "html_url": "https://github.com/rust-lang/rust/commit/9782fc42852927428736f27f0496deece545f46c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9782fc42852927428736f27f0496deece545f46c/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c028de05f7b6803c062e12ee09a41ea9007d1e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c028de05f7b6803c062e12ee09a41ea9007d1e1", "html_url": "https://github.com/rust-lang/rust/commit/7c028de05f7b6803c062e12ee09a41ea9007d1e1"}], "stats": {"total": 241, "additions": 131, "deletions": 110}, "files": [{"sha": "f53edc1b3c77f4ed086fc481e697916bf3dcc6fb", "filename": "clippy_lints/src/functions/mod.rs", "status": "modified", "additions": 6, "deletions": 110, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/9782fc42852927428736f27f0496deece545f46c/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9782fc42852927428736f27f0496deece545f46c/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmod.rs?ref=9782fc42852927428736f27f0496deece545f46c", "patch": "@@ -1,13 +1,11 @@\n+mod not_unsafe_ptr_arg_deref;\n mod too_many_arguments;\n mod too_many_lines;\n \n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_then};\n+use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{is_must_use_ty, is_type_diagnostic_item, type_is_unsafe_function};\n-use clippy_utils::{\n-    attr_by_name, attrs::is_proc_macro, iter_input_pats, match_def_path, must_use_attr, path_to_local, return_ty,\n-    trait_ref_of_method,\n-};\n+use clippy_utils::ty::{is_must_use_ty, is_type_diagnostic_item};\n+use clippy_utils::{attr_by_name, attrs::is_proc_macro, match_def_path, must_use_attr, return_ty, trait_ref_of_method};\n use if_chain::if_chain;\n use rustc_ast::ast::Attribute;\n use rustc_data_structures::fx::FxHashSet;\n@@ -258,14 +256,7 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n     ) {\n         too_many_arguments::check_fn(cx, kind, decl, span, hir_id, self.too_many_arguments_threshold);\n         too_many_lines::check(cx, span, body, self.too_many_lines_threshold);\n-\n-        let unsafety = match kind {\n-            intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _) => unsafety,\n-            intravisit::FnKind::Method(_, sig, _) => sig.header.unsafety,\n-            intravisit::FnKind::Closure => return,\n-        };\n-\n-        Self::check_raw_ptr(cx, unsafety, decl, body, hir_id);\n+        not_unsafe_ptr_arg_deref::check_fn(cx, kind, decl, body, hir_id);\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n@@ -323,6 +314,7 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n         too_many_arguments::check_trait_item(cx, item, self.too_many_arguments_threshold);\n+        not_unsafe_ptr_arg_deref::check_trait_item(cx, item);\n \n         if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n             let is_public = cx.access_levels.is_exported(item.hir_id());\n@@ -338,8 +330,6 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n             }\n             if let hir::TraitFn::Provided(eid) = *eid {\n                 let body = cx.tcx.hir().body(eid);\n-                Self::check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id());\n-\n                 if attr.is_none() && is_public && !is_proc_macro(cx.sess(), attrs) {\n                     check_must_use_candidate(\n                         cx,\n@@ -356,35 +346,6 @@ impl<'tcx> LateLintPass<'tcx> for Functions {\n     }\n }\n \n-impl<'tcx> Functions {\n-    fn check_raw_ptr(\n-        cx: &LateContext<'tcx>,\n-        unsafety: hir::Unsafety,\n-        decl: &'tcx hir::FnDecl<'_>,\n-        body: &'tcx hir::Body<'_>,\n-        hir_id: hir::HirId,\n-    ) {\n-        let expr = &body.value;\n-        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(hir_id) {\n-            let raw_ptrs = iter_input_pats(decl, body)\n-                .zip(decl.inputs.iter())\n-                .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))\n-                .collect::<FxHashSet<_>>();\n-\n-            if !raw_ptrs.is_empty() {\n-                let typeck_results = cx.tcx.typeck_body(body.id());\n-                let mut v = DerefVisitor {\n-                    cx,\n-                    ptrs: raw_ptrs,\n-                    typeck_results,\n-                };\n-\n-                intravisit::walk_expr(&mut v, expr);\n-            }\n-        }\n-    }\n-}\n-\n fn check_result_unit_err(cx: &LateContext<'_>, decl: &hir::FnDecl<'_>, item_span: Span, fn_header_span: Span) {\n     if_chain! {\n         if !in_external_macro(cx.sess(), item_span);\n@@ -524,71 +485,6 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n     }\n }\n \n-fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty<'_>) -> Option<hir::HirId> {\n-    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.kind, &ty.kind) {\n-        Some(id)\n-    } else {\n-        None\n-    }\n-}\n-\n-struct DerefVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    ptrs: FxHashSet<hir::HirId>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n-}\n-\n-impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n-        match expr.kind {\n-            hir::ExprKind::Call(ref f, args) => {\n-                let ty = self.typeck_results.expr_ty(f);\n-\n-                if type_is_unsafe_function(self.cx, ty) {\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::MethodCall(_, _, args, _) => {\n-                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n-                let base_type = self.cx.tcx.type_of(def_id);\n-\n-                if type_is_unsafe_function(self.cx, base_type) {\n-                    for arg in args {\n-                        self.check_arg(arg);\n-                    }\n-                }\n-            },\n-            hir::ExprKind::Unary(hir::UnOp::Deref, ref ptr) => self.check_arg(ptr),\n-            _ => (),\n-        }\n-\n-        intravisit::walk_expr(self, expr);\n-    }\n-\n-    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n-        intravisit::NestedVisitorMap::None\n-    }\n-}\n-\n-impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n-    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n-        if let Some(id) = path_to_local(ptr) {\n-            if self.ptrs.contains(&id) {\n-                span_lint(\n-                    self.cx,\n-                    NOT_UNSAFE_PTR_ARG_DEREF,\n-                    ptr.span,\n-                    \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n-                );\n-            }\n-        }\n-    }\n-}\n-\n struct StaticMutVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     mutates_static: bool,"}, {"sha": "ac02b60a356f689bea866b734b5c60aaf6dde0cc", "filename": "clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/9782fc42852927428736f27f0496deece545f46c/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9782fc42852927428736f27f0496deece545f46c/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=9782fc42852927428736f27f0496deece545f46c", "patch": "@@ -0,0 +1,125 @@\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::{self as hir, intravisit};\n+use rustc_lint::LateContext;\n+use rustc_middle::{hir::map::Map, ty};\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::ty::type_is_unsafe_function;\n+use clippy_utils::{iter_input_pats, path_to_local};\n+\n+use super::NOT_UNSAFE_PTR_ARG_DEREF;\n+\n+pub(super) fn check_fn(\n+    cx: &LateContext<'tcx>,\n+    kind: intravisit::FnKind<'tcx>,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n+    body: &'tcx hir::Body<'tcx>,\n+    hir_id: hir::HirId,\n+) {\n+    let unsafety = match kind {\n+        intravisit::FnKind::ItemFn(_, _, hir::FnHeader { unsafety, .. }, _) => unsafety,\n+        intravisit::FnKind::Method(_, sig, _) => sig.header.unsafety,\n+        intravisit::FnKind::Closure => return,\n+    };\n+\n+    check_raw_ptr(cx, unsafety, decl, body, hir_id);\n+}\n+\n+pub(super) fn check_trait_item(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n+    if let hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(eid)) = item.kind {\n+        let body = cx.tcx.hir().body(eid);\n+        check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id());\n+    }\n+}\n+\n+fn check_raw_ptr(\n+    cx: &LateContext<'tcx>,\n+    unsafety: hir::Unsafety,\n+    decl: &'tcx hir::FnDecl<'tcx>,\n+    body: &'tcx hir::Body<'tcx>,\n+    hir_id: hir::HirId,\n+) {\n+    let expr = &body.value;\n+    if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(hir_id) {\n+        let raw_ptrs = iter_input_pats(decl, body)\n+            .zip(decl.inputs.iter())\n+            .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))\n+            .collect::<FxHashSet<_>>();\n+\n+        if !raw_ptrs.is_empty() {\n+            let typeck_results = cx.tcx.typeck_body(body.id());\n+            let mut v = DerefVisitor {\n+                cx,\n+                ptrs: raw_ptrs,\n+                typeck_results,\n+            };\n+\n+            intravisit::walk_expr(&mut v, expr);\n+        }\n+    }\n+}\n+\n+fn raw_ptr_arg(arg: &hir::Param<'_>, ty: &hir::Ty<'_>) -> Option<hir::HirId> {\n+    if let (&hir::PatKind::Binding(_, id, _, _), &hir::TyKind::Ptr(_)) = (&arg.pat.kind, &ty.kind) {\n+        Some(id)\n+    } else {\n+        None\n+    }\n+}\n+\n+struct DerefVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    ptrs: FxHashSet<hir::HirId>,\n+    typeck_results: &'a ty::TypeckResults<'tcx>,\n+}\n+\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr<'_>) {\n+        match expr.kind {\n+            hir::ExprKind::Call(ref f, args) => {\n+                let ty = self.typeck_results.expr_ty(f);\n+\n+                if type_is_unsafe_function(self.cx, ty) {\n+                    for arg in args {\n+                        self.check_arg(arg);\n+                    }\n+                }\n+            },\n+            hir::ExprKind::MethodCall(_, _, args, _) => {\n+                let def_id = self.typeck_results.type_dependent_def_id(expr.hir_id).unwrap();\n+                let base_type = self.cx.tcx.type_of(def_id);\n+\n+                if type_is_unsafe_function(self.cx, base_type) {\n+                    for arg in args {\n+                        self.check_arg(arg);\n+                    }\n+                }\n+            },\n+            hir::ExprKind::Unary(hir::UnOp::Deref, ref ptr) => self.check_arg(ptr),\n+            _ => (),\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::None\n+    }\n+}\n+\n+impl<'a, 'tcx> DerefVisitor<'a, 'tcx> {\n+    fn check_arg(&self, ptr: &hir::Expr<'_>) {\n+        if let Some(id) = path_to_local(ptr) {\n+            if self.ptrs.contains(&id) {\n+                span_lint(\n+                    self.cx,\n+                    NOT_UNSAFE_PTR_ARG_DEREF,\n+                    ptr.span,\n+                    \"this public function dereferences a raw pointer but is not marked `unsafe`\",\n+                );\n+            }\n+        }\n+    }\n+}"}]}