{"sha": "4f513b5fd7945937cba8bbfab84ae33e14642b85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNTEzYjVmZDc5NDU5MzdjYmE4YmJmYWI4NGFlMzNlMTQ2NDJiODU=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-03-23T21:39:59Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-03-23T21:39:59Z"}, "message": "Split out some impls from rustc::mir into a separate submodule", "tree": {"sha": "fcaa056c670b7f4dae9456536fde9d731a97f428", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcaa056c670b7f4dae9456536fde9d731a97f428"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f513b5fd7945937cba8bbfab84ae33e14642b85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f513b5fd7945937cba8bbfab84ae33e14642b85", "html_url": "https://github.com/rust-lang/rust/commit/4f513b5fd7945937cba8bbfab84ae33e14642b85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f513b5fd7945937cba8bbfab84ae33e14642b85/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5aa15bfa1c54d3139559e7296ff2b74ebedcc07e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa15bfa1c54d3139559e7296ff2b74ebedcc07e", "html_url": "https://github.com/rust-lang/rust/commit/5aa15bfa1c54d3139559e7296ff2b74ebedcc07e"}], "stats": {"total": 645, "additions": 323, "deletions": 322}, "files": [{"sha": "63019c57b2fccd90ded30a995317e96eab143c5b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 322, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/4f513b5fd7945937cba8bbfab84ae33e14642b85/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f513b5fd7945937cba8bbfab84ae33e14642b85/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=4f513b5fd7945937cba8bbfab84ae33e14642b85", "patch": "@@ -45,6 +45,7 @@ pub mod mono;\n mod query;\n pub mod tcx;\n pub mod traversal;\n+mod type_foldable;\n pub mod visit;\n \n /// Types for locals\n@@ -2683,325 +2684,3 @@ impl Location {\n         }\n     }\n }\n-\n-/*\n- * `TypeFoldable` implementations for MIR types\n-*/\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    BlockTailInfo,\n-    MirPhase,\n-    SourceInfo,\n-    FakeReadCause,\n-    RetagKind,\n-    SourceScope,\n-    SourceScopeData,\n-    SourceScopeLocalData,\n-    UserTypeAnnotationIndex,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        use crate::mir::TerminatorKind::*;\n-\n-        let kind = match self.kind {\n-            Goto { target } => Goto { target },\n-            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n-                discr: discr.fold_with(folder),\n-                switch_ty: switch_ty.fold_with(folder),\n-                values: values.clone(),\n-                targets: targets.clone(),\n-            },\n-            Drop { ref location, target, unwind } => {\n-                Drop { location: location.fold_with(folder), target, unwind }\n-            }\n-            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n-                location: location.fold_with(folder),\n-                value: value.fold_with(folder),\n-                target,\n-                unwind,\n-            },\n-            Yield { ref value, resume, ref resume_arg, drop } => Yield {\n-                value: value.fold_with(folder),\n-                resume,\n-                resume_arg: resume_arg.fold_with(folder),\n-                drop,\n-            },\n-            Call { ref func, ref args, ref destination, cleanup, from_hir_call } => {\n-                let dest =\n-                    destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n-\n-                Call {\n-                    func: func.fold_with(folder),\n-                    args: args.fold_with(folder),\n-                    destination: dest,\n-                    cleanup,\n-                    from_hir_call,\n-                }\n-            }\n-            Assert { ref cond, expected, ref msg, target, cleanup } => {\n-                use AssertKind::*;\n-                let msg = match msg {\n-                    BoundsCheck { ref len, ref index } => {\n-                        BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n-                    }\n-                    Overflow(_)\n-                    | OverflowNeg\n-                    | DivisionByZero\n-                    | RemainderByZero\n-                    | ResumedAfterReturn(_)\n-                    | ResumedAfterPanic(_) => msg.clone(),\n-                };\n-                Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n-            }\n-            GeneratorDrop => GeneratorDrop,\n-            Resume => Resume,\n-            Abort => Abort,\n-            Return => Return,\n-            Unreachable => Unreachable,\n-            FalseEdges { real_target, imaginary_target } => {\n-                FalseEdges { real_target, imaginary_target }\n-            }\n-            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n-        };\n-        Terminator { source_info: self.source_info, kind }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use crate::mir::TerminatorKind::*;\n-\n-        match self.kind {\n-            SwitchInt { ref discr, switch_ty, .. } => {\n-                discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n-            }\n-            Drop { ref location, .. } => location.visit_with(visitor),\n-            DropAndReplace { ref location, ref value, .. } => {\n-                location.visit_with(visitor) || value.visit_with(visitor)\n-            }\n-            Yield { ref value, .. } => value.visit_with(visitor),\n-            Call { ref func, ref args, ref destination, .. } => {\n-                let dest = if let Some((ref loc, _)) = *destination {\n-                    loc.visit_with(visitor)\n-                } else {\n-                    false\n-                };\n-                dest || func.visit_with(visitor) || args.visit_with(visitor)\n-            }\n-            Assert { ref cond, ref msg, .. } => {\n-                if cond.visit_with(visitor) {\n-                    use AssertKind::*;\n-                    match msg {\n-                        BoundsCheck { ref len, ref index } => {\n-                            len.visit_with(visitor) || index.visit_with(visitor)\n-                        }\n-                        Overflow(_)\n-                        | OverflowNeg\n-                        | DivisionByZero\n-                        | RemainderByZero\n-                        | ResumedAfterReturn(_)\n-                        | ResumedAfterPanic(_) => false,\n-                    }\n-                } else {\n-                    false\n-                }\n-            }\n-            Goto { .. }\n-            | Resume\n-            | Abort\n-            | Return\n-            | GeneratorDrop\n-            | Unreachable\n-            | FalseEdges { .. }\n-            | FalseUnwind { .. } => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.local.visit_with(visitor) || self.projection.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>();\n-        folder.tcx().intern_place_elems(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        use crate::mir::Rvalue::*;\n-        match *self {\n-            Use(ref op) => Use(op.fold_with(folder)),\n-            Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n-            Ref(region, bk, ref place) => {\n-                Ref(region.fold_with(folder), bk, place.fold_with(folder))\n-            }\n-            AddressOf(mutability, ref place) => AddressOf(mutability, place.fold_with(folder)),\n-            Len(ref place) => Len(place.fold_with(folder)),\n-            Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n-            BinaryOp(op, ref rhs, ref lhs) => {\n-                BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n-            }\n-            CheckedBinaryOp(op, ref rhs, ref lhs) => {\n-                CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n-            }\n-            UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n-            Discriminant(ref place) => Discriminant(place.fold_with(folder)),\n-            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n-            Aggregate(ref kind, ref fields) => {\n-                let kind = box match **kind {\n-                    AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n-                    AggregateKind::Tuple => AggregateKind::Tuple,\n-                    AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n-                        def,\n-                        v,\n-                        substs.fold_with(folder),\n-                        user_ty.fold_with(folder),\n-                        n,\n-                    ),\n-                    AggregateKind::Closure(id, substs) => {\n-                        AggregateKind::Closure(id, substs.fold_with(folder))\n-                    }\n-                    AggregateKind::Generator(id, substs, movablity) => {\n-                        AggregateKind::Generator(id, substs.fold_with(folder), movablity)\n-                    }\n-                };\n-                Aggregate(kind, fields.fold_with(folder))\n-            }\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        use crate::mir::Rvalue::*;\n-        match *self {\n-            Use(ref op) => op.visit_with(visitor),\n-            Repeat(ref op, _) => op.visit_with(visitor),\n-            Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n-            AddressOf(_, ref place) => place.visit_with(visitor),\n-            Len(ref place) => place.visit_with(visitor),\n-            Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n-            BinaryOp(_, ref rhs, ref lhs) | CheckedBinaryOp(_, ref rhs, ref lhs) => {\n-                rhs.visit_with(visitor) || lhs.visit_with(visitor)\n-            }\n-            UnaryOp(_, ref val) => val.visit_with(visitor),\n-            Discriminant(ref place) => place.visit_with(visitor),\n-            NullaryOp(_, ty) => ty.visit_with(visitor),\n-            Aggregate(ref kind, ref fields) => {\n-                (match **kind {\n-                    AggregateKind::Array(ty) => ty.visit_with(visitor),\n-                    AggregateKind::Tuple => false,\n-                    AggregateKind::Adt(_, _, substs, user_ty, _) => {\n-                        substs.visit_with(visitor) || user_ty.visit_with(visitor)\n-                    }\n-                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n-                    AggregateKind::Generator(_, substs, _) => substs.visit_with(visitor),\n-                }) || fields.visit_with(visitor)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            Operand::Copy(ref place) => Operand::Copy(place.fold_with(folder)),\n-            Operand::Move(ref place) => Operand::Move(place.fold_with(folder)),\n-            Operand::Constant(ref c) => Operand::Constant(c.fold_with(folder)),\n-        }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        match *self {\n-            Operand::Copy(ref place) | Operand::Move(ref place) => place.visit_with(visitor),\n-            Operand::Constant(ref c) => c.visit_with(visitor),\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        use crate::mir::ProjectionElem::*;\n-\n-        match *self {\n-            Deref => Deref,\n-            Field(f, ty) => Field(f, ty.fold_with(folder)),\n-            Index(v) => Index(v.fold_with(folder)),\n-            Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n-            ConstantIndex { offset, min_length, from_end } => {\n-                ConstantIndex { offset, min_length, from_end }\n-            }\n-            Subslice { from, to, from_end } => Subslice { from, to, from_end },\n-        }\n-    }\n-\n-    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n-        use crate::mir::ProjectionElem::*;\n-\n-        match self {\n-            Field(_, ty) => ty.visit_with(visitor),\n-            Index(v) => v.visit_with(visitor),\n-            _ => false,\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Field {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n-        self.clone()\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Constant {\n-            span: self.span,\n-            user_ty: self.user_ty.fold_with(folder),\n-            literal: self.literal.fold_with(folder),\n-        }\n-    }\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.literal.visit_with(visitor)\n-    }\n-}"}, {"sha": "9520f081b6bfbb28bc40f4e99428c3ab09ab21d7", "filename": "src/librustc/mir/type_foldable.rs", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/4f513b5fd7945937cba8bbfab84ae33e14642b85/src%2Flibrustc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f513b5fd7945937cba8bbfab84ae33e14642b85/src%2Flibrustc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftype_foldable.rs?ref=4f513b5fd7945937cba8bbfab84ae33e14642b85", "patch": "@@ -0,0 +1,322 @@\n+//! `TypeFoldable` implementations for MIR types\n+\n+use super::*;\n+use crate::ty;\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    BlockTailInfo,\n+    MirPhase,\n+    SourceInfo,\n+    FakeReadCause,\n+    RetagKind,\n+    SourceScope,\n+    SourceScopeData,\n+    SourceScopeLocalData,\n+    UserTypeAnnotationIndex,\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        use crate::mir::TerminatorKind::*;\n+\n+        let kind = match self.kind {\n+            Goto { target } => Goto { target },\n+            SwitchInt { ref discr, switch_ty, ref values, ref targets } => SwitchInt {\n+                discr: discr.fold_with(folder),\n+                switch_ty: switch_ty.fold_with(folder),\n+                values: values.clone(),\n+                targets: targets.clone(),\n+            },\n+            Drop { ref location, target, unwind } => {\n+                Drop { location: location.fold_with(folder), target, unwind }\n+            }\n+            DropAndReplace { ref location, ref value, target, unwind } => DropAndReplace {\n+                location: location.fold_with(folder),\n+                value: value.fold_with(folder),\n+                target,\n+                unwind,\n+            },\n+            Yield { ref value, resume, ref resume_arg, drop } => Yield {\n+                value: value.fold_with(folder),\n+                resume,\n+                resume_arg: resume_arg.fold_with(folder),\n+                drop,\n+            },\n+            Call { ref func, ref args, ref destination, cleanup, from_hir_call } => {\n+                let dest =\n+                    destination.as_ref().map(|&(ref loc, dest)| (loc.fold_with(folder), dest));\n+\n+                Call {\n+                    func: func.fold_with(folder),\n+                    args: args.fold_with(folder),\n+                    destination: dest,\n+                    cleanup,\n+                    from_hir_call,\n+                }\n+            }\n+            Assert { ref cond, expected, ref msg, target, cleanup } => {\n+                use AssertKind::*;\n+                let msg = match msg {\n+                    BoundsCheck { ref len, ref index } => {\n+                        BoundsCheck { len: len.fold_with(folder), index: index.fold_with(folder) }\n+                    }\n+                    Overflow(_)\n+                    | OverflowNeg\n+                    | DivisionByZero\n+                    | RemainderByZero\n+                    | ResumedAfterReturn(_)\n+                    | ResumedAfterPanic(_) => msg.clone(),\n+                };\n+                Assert { cond: cond.fold_with(folder), expected, msg, target, cleanup }\n+            }\n+            GeneratorDrop => GeneratorDrop,\n+            Resume => Resume,\n+            Abort => Abort,\n+            Return => Return,\n+            Unreachable => Unreachable,\n+            FalseEdges { real_target, imaginary_target } => {\n+                FalseEdges { real_target, imaginary_target }\n+            }\n+            FalseUnwind { real_target, unwind } => FalseUnwind { real_target, unwind },\n+        };\n+        Terminator { source_info: self.source_info, kind }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use crate::mir::TerminatorKind::*;\n+\n+        match self.kind {\n+            SwitchInt { ref discr, switch_ty, .. } => {\n+                discr.visit_with(visitor) || switch_ty.visit_with(visitor)\n+            }\n+            Drop { ref location, .. } => location.visit_with(visitor),\n+            DropAndReplace { ref location, ref value, .. } => {\n+                location.visit_with(visitor) || value.visit_with(visitor)\n+            }\n+            Yield { ref value, .. } => value.visit_with(visitor),\n+            Call { ref func, ref args, ref destination, .. } => {\n+                let dest = if let Some((ref loc, _)) = *destination {\n+                    loc.visit_with(visitor)\n+                } else {\n+                    false\n+                };\n+                dest || func.visit_with(visitor) || args.visit_with(visitor)\n+            }\n+            Assert { ref cond, ref msg, .. } => {\n+                if cond.visit_with(visitor) {\n+                    use AssertKind::*;\n+                    match msg {\n+                        BoundsCheck { ref len, ref index } => {\n+                            len.visit_with(visitor) || index.visit_with(visitor)\n+                        }\n+                        Overflow(_)\n+                        | OverflowNeg\n+                        | DivisionByZero\n+                        | RemainderByZero\n+                        | ResumedAfterReturn(_)\n+                        | ResumedAfterPanic(_) => false,\n+                    }\n+                } else {\n+                    false\n+                }\n+            }\n+            Goto { .. }\n+            | Resume\n+            | Abort\n+            | Return\n+            | GeneratorDrop\n+            | Unreachable\n+            | FalseEdges { .. }\n+            | FalseUnwind { .. } => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for GeneratorKind {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Place { local: self.local.fold_with(folder), projection: self.projection.fold_with(folder) }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.local.visit_with(visitor) || self.projection.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<Vec<_>>();\n+        folder.tcx().intern_place_elems(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        use crate::mir::Rvalue::*;\n+        match *self {\n+            Use(ref op) => Use(op.fold_with(folder)),\n+            Repeat(ref op, len) => Repeat(op.fold_with(folder), len),\n+            Ref(region, bk, ref place) => {\n+                Ref(region.fold_with(folder), bk, place.fold_with(folder))\n+            }\n+            AddressOf(mutability, ref place) => AddressOf(mutability, place.fold_with(folder)),\n+            Len(ref place) => Len(place.fold_with(folder)),\n+            Cast(kind, ref op, ty) => Cast(kind, op.fold_with(folder), ty.fold_with(folder)),\n+            BinaryOp(op, ref rhs, ref lhs) => {\n+                BinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n+            }\n+            CheckedBinaryOp(op, ref rhs, ref lhs) => {\n+                CheckedBinaryOp(op, rhs.fold_with(folder), lhs.fold_with(folder))\n+            }\n+            UnaryOp(op, ref val) => UnaryOp(op, val.fold_with(folder)),\n+            Discriminant(ref place) => Discriminant(place.fold_with(folder)),\n+            NullaryOp(op, ty) => NullaryOp(op, ty.fold_with(folder)),\n+            Aggregate(ref kind, ref fields) => {\n+                let kind = box match **kind {\n+                    AggregateKind::Array(ty) => AggregateKind::Array(ty.fold_with(folder)),\n+                    AggregateKind::Tuple => AggregateKind::Tuple,\n+                    AggregateKind::Adt(def, v, substs, user_ty, n) => AggregateKind::Adt(\n+                        def,\n+                        v,\n+                        substs.fold_with(folder),\n+                        user_ty.fold_with(folder),\n+                        n,\n+                    ),\n+                    AggregateKind::Closure(id, substs) => {\n+                        AggregateKind::Closure(id, substs.fold_with(folder))\n+                    }\n+                    AggregateKind::Generator(id, substs, movablity) => {\n+                        AggregateKind::Generator(id, substs.fold_with(folder), movablity)\n+                    }\n+                };\n+                Aggregate(kind, fields.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        use crate::mir::Rvalue::*;\n+        match *self {\n+            Use(ref op) => op.visit_with(visitor),\n+            Repeat(ref op, _) => op.visit_with(visitor),\n+            Ref(region, _, ref place) => region.visit_with(visitor) || place.visit_with(visitor),\n+            AddressOf(_, ref place) => place.visit_with(visitor),\n+            Len(ref place) => place.visit_with(visitor),\n+            Cast(_, ref op, ty) => op.visit_with(visitor) || ty.visit_with(visitor),\n+            BinaryOp(_, ref rhs, ref lhs) | CheckedBinaryOp(_, ref rhs, ref lhs) => {\n+                rhs.visit_with(visitor) || lhs.visit_with(visitor)\n+            }\n+            UnaryOp(_, ref val) => val.visit_with(visitor),\n+            Discriminant(ref place) => place.visit_with(visitor),\n+            NullaryOp(_, ty) => ty.visit_with(visitor),\n+            Aggregate(ref kind, ref fields) => {\n+                (match **kind {\n+                    AggregateKind::Array(ty) => ty.visit_with(visitor),\n+                    AggregateKind::Tuple => false,\n+                    AggregateKind::Adt(_, _, substs, user_ty, _) => {\n+                        substs.visit_with(visitor) || user_ty.visit_with(visitor)\n+                    }\n+                    AggregateKind::Closure(_, substs) => substs.visit_with(visitor),\n+                    AggregateKind::Generator(_, substs, _) => substs.visit_with(visitor),\n+                }) || fields.visit_with(visitor)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            Operand::Copy(ref place) => Operand::Copy(place.fold_with(folder)),\n+            Operand::Move(ref place) => Operand::Move(place.fold_with(folder)),\n+            Operand::Constant(ref c) => Operand::Constant(c.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            Operand::Copy(ref place) | Operand::Move(ref place) => place.visit_with(visitor),\n+            Operand::Constant(ref c) => c.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        use crate::mir::ProjectionElem::*;\n+\n+        match *self {\n+            Deref => Deref,\n+            Field(f, ty) => Field(f, ty.fold_with(folder)),\n+            Index(v) => Index(v.fold_with(folder)),\n+            Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n+            ConstantIndex { offset, min_length, from_end } => {\n+                ConstantIndex { offset, min_length, from_end }\n+            }\n+            Subslice { from, to, from_end } => Subslice { from, to, from_end },\n+        }\n+    }\n+\n+    fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n+        use crate::mir::ProjectionElem::*;\n+\n+        match self {\n+            Field(_, ty) => ty.visit_with(visitor),\n+            Index(v) => v.visit_with(visitor),\n+            _ => false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Field {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for GeneratorSavedLocal {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        *self\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx, R: Idx, C: Idx> TypeFoldable<'tcx> for BitMatrix<R, C> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, _: &mut F) -> Self {\n+        self.clone()\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Constant<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Constant {\n+            span: self.span,\n+            user_ty: self.user_ty.fold_with(folder),\n+            literal: self.literal.fold_with(folder),\n+        }\n+    }\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.literal.visit_with(visitor)\n+    }\n+}"}]}