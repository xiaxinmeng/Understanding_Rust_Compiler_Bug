{"sha": "340fc2d08a032e7cd5e9537b56ef54afb4d24d6a", "node_id": "C_kwDOAAsO6NoAKDM0MGZjMmQwOGEwMzJlN2NkNWU5NTM3YjU2ZWY1NGFmYjRkMjRkNmE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-19T11:55:13Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-05-19T11:58:31Z"}, "message": "Leverage the interval property to precompute borrow kill points.", "tree": {"sha": "12c196b4dc9d7df89685b8a27503548bc2e5fbac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12c196b4dc9d7df89685b8a27503548bc2e5fbac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a", "html_url": "https://github.com/rust-lang/rust/commit/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdd030127cc68afec44a8d3f6341525dd34e50ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdd030127cc68afec44a8d3f6341525dd34e50ae", "html_url": "https://github.com/rust-lang/rust/commit/fdd030127cc68afec44a8d3f6341525dd34e50ae"}], "stats": {"total": 151, "additions": 101, "deletions": 50}, "files": [{"sha": "68ef790ac26f8fe0af263023379660a2e2c85064", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=340fc2d08a032e7cd5e9537b56ef54afb4d24d6a", "patch": "@@ -156,10 +156,10 @@ impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n         &mut self,\n         borrow_index: BorrowIndex,\n         borrow_region: RegionVid,\n-        location: Location,\n+        first_location: Location,\n     ) {\n         // We visit one BB at a time. The complication is that we may start in the\n-        // middle of the first BB visited (the one containing `location`), in which\n+        // middle of the first BB visited (the one containing `first_location`), in which\n         // case we may have to later on process the first part of that BB if there\n         // is a path back to its start.\n \n@@ -168,61 +168,58 @@ impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n         // `visited` once they are added to `stack`, before they are actually\n         // processed, because this avoids the need to look them up again on\n         // completion.\n-        self.visited.insert(location.block);\n+        self.visited.insert(first_location.block);\n \n-        let mut first_lo = location.statement_index;\n-        let first_hi = self.body[location.block].statements.len();\n+        let first_block = first_location.block;\n+        let mut first_lo = first_location.statement_index;\n+        let first_hi = self.body[first_block].statements.len();\n \n-        self.visit_stack.push(StackEntry { bb: location.block, lo: first_lo, hi: first_hi });\n+        self.visit_stack.push(StackEntry { bb: first_block, lo: first_lo, hi: first_hi });\n \n-        while let Some(StackEntry { bb, lo, hi }) = self.visit_stack.pop() {\n-            // If we process the first part of the first basic block (i.e. we encounter that block\n-            // for the second time), we no longer have to visit its successors again.\n-            let mut finished_early = bb == location.block && hi != first_hi;\n-            for i in lo..=hi {\n-                let location = Location { block: bb, statement_index: i };\n+        'preorder: while let Some(StackEntry { bb, lo, hi }) = self.visit_stack.pop() {\n+            if let Some(kill_stmt) =\n+                self.regioncx.first_non_contained_inclusive(borrow_region, bb, lo, hi)\n+            {\n+                let kill_location = Location { block: bb, statement_index: kill_stmt };\n                 // If region does not contain a point at the location, then add to list and skip\n                 // successor locations.\n-                if !self.regioncx.region_contains(borrow_region, location) {\n-                    debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n-                    self.borrows_out_of_scope_at_location\n-                        .entry(location)\n-                        .or_default()\n-                        .push(borrow_index);\n-                    finished_early = true;\n-                    break;\n-                }\n+                debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, kill_location);\n+                self.borrows_out_of_scope_at_location\n+                    .entry(kill_location)\n+                    .or_default()\n+                    .push(borrow_index);\n+                continue 'preorder;\n             }\n \n-            if !finished_early {\n-                // Add successor BBs to the work list, if necessary.\n-                let bb_data = &self.body[bb];\n-                debug_assert!(hi == bb_data.statements.len());\n-                for succ_bb in bb_data.terminator().successors() {\n-                    if !self.visited.insert(succ_bb) {\n-                        if succ_bb == location.block && first_lo > 0 {\n-                            // `succ_bb` has been seen before. If it wasn't\n-                            // fully processed, add its first part to `stack`\n-                            // for processing.\n-                            self.visit_stack.push(StackEntry {\n-                                bb: succ_bb,\n-                                lo: 0,\n-                                hi: first_lo - 1,\n-                            });\n-\n-                            // And update this entry with 0, to represent the\n-                            // whole BB being processed.\n-                            first_lo = 0;\n-                        }\n-                    } else {\n-                        // succ_bb hasn't been seen before. Add it to\n-                        // `stack` for processing.\n-                        self.visit_stack.push(StackEntry {\n-                            bb: succ_bb,\n-                            lo: 0,\n-                            hi: self.body[succ_bb].statements.len(),\n-                        });\n+            // If we process the first part of the first basic block (i.e. we encounter that block\n+            // for the second time), we no longer have to visit its successors again.\n+            if bb == first_block && hi != first_hi {\n+                continue;\n+            }\n+\n+            // Add successor BBs to the work list, if necessary.\n+            let bb_data = &self.body[bb];\n+            debug_assert!(hi == bb_data.statements.len());\n+            for succ_bb in bb_data.terminator().successors() {\n+                if !self.visited.insert(succ_bb) {\n+                    if succ_bb == first_block && first_lo > 0 {\n+                        // `succ_bb` has been seen before. If it wasn't\n+                        // fully processed, add its first part to `stack`\n+                        // for processing.\n+                        self.visit_stack.push(StackEntry { bb: succ_bb, lo: 0, hi: first_lo - 1 });\n+\n+                        // And update this entry with 0, to represent the\n+                        // whole BB being processed.\n+                        first_lo = 0;\n                     }\n+                } else {\n+                    // succ_bb hasn't been seen before. Add it to\n+                    // `stack` for processing.\n+                    self.visit_stack.push(StackEntry {\n+                        bb: succ_bb,\n+                        lo: 0,\n+                        hi: self.body[succ_bb].statements.len(),\n+                    });\n                 }\n             }\n         }"}, {"sha": "3be06a94bc0b83cbf31c36f96699a80ea84182fd", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=340fc2d08a032e7cd5e9537b56ef54afb4d24d6a", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n-    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureOutlivesSubjectTy,\n+    BasicBlock, Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureOutlivesSubjectTy,\n     ClosureRegionRequirements, ConstraintCategory, Local, Location, ReturnConstraint,\n     TerminatorKind,\n };\n@@ -598,6 +598,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_values.contains(scc, p)\n     }\n \n+    /// Returns the lowest statement index in `start..=end` which is not contained by `r`.\n+    ///\n+    /// Panics if called before `solve()` executes.\n+    pub(crate) fn first_non_contained_inclusive(\n+        &self,\n+        r: RegionVid,\n+        block: BasicBlock,\n+        start: usize,\n+        end: usize,\n+    ) -> Option<usize> {\n+        let scc = self.constraint_sccs.scc(r);\n+        self.scc_values.first_non_contained_inclusive(scc, block, start, end)\n+    }\n+\n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_value_str(&self, r: RegionVid) -> String {\n         let scc = self.constraint_sccs.scc(r);"}, {"sha": "60ddf9ebaea96b732d96274c58abf59fb8dd8fab", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=340fc2d08a032e7cd5e9537b56ef54afb4d24d6a", "patch": "@@ -283,6 +283,22 @@ impl<N: Idx> RegionValues<N> {\n         elem.contained_in_row(self, r)\n     }\n \n+    /// Returns the lowest statement index in `start..=end` which is not contained by `r`.\n+    pub(crate) fn first_non_contained_inclusive(\n+        &self,\n+        r: N,\n+        block: BasicBlock,\n+        start: usize,\n+        end: usize,\n+    ) -> Option<usize> {\n+        let row = self.points.row(r)?;\n+        let block = self.elements.entry_point(block);\n+        let start = block.plus(start);\n+        let end = block.plus(end);\n+        let first_unset = row.first_unset_in(start..=end)?;\n+        Some(first_unset.index() - block.index())\n+    }\n+\n     /// `self[to] |= values[from]`, essentially: that is, take all the\n     /// elements for the region `from` from `values` and add them to\n     /// the region `to` in `self`."}, {"sha": "9199a78c326a1fb301062c37e42107c1a143a215", "filename": "compiler/rustc_index/src/interval.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/340fc2d08a032e7cd5e9537b56ef54afb4d24d6a/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=340fc2d08a032e7cd5e9537b56ef54afb4d24d6a", "patch": "@@ -181,6 +181,30 @@ impl<I: Idx> IntervalSet<I> {\n         self.map.is_empty()\n     }\n \n+    /// Equivalent to `range.iter().find(|i| !self.contains(i))`.\n+    pub fn first_unset_in(&self, range: impl RangeBounds<I> + Clone) -> Option<I> {\n+        let start = inclusive_start(range.clone());\n+        let Some(end) = inclusive_end(self.domain, range) else {\n+            // empty range\n+            return None;\n+        };\n+        if start > end {\n+            return None;\n+        }\n+        let Some(last) = self.map.partition_point(|r| r.0 <= start).checked_sub(1) else {\n+            // All ranges in the map start after the new range's end\n+            return Some(I::new(start as usize));\n+        };\n+        let (_, prev_end) = self.map[last];\n+        if start > prev_end {\n+            Some(I::new(start as usize))\n+        } else if prev_end < end {\n+            Some(I::new(prev_end as usize + 1))\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Returns the maximum (last) element present in the set from `range`.\n     pub fn last_set_in(&self, range: impl RangeBounds<I> + Clone) -> Option<I> {\n         let start = inclusive_start(range.clone());"}]}