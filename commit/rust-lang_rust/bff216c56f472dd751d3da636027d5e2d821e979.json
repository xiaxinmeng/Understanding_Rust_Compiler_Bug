{"sha": "bff216c56f472dd751d3da636027d5e2d821e979", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmZjIxNmM1NmY0NzJkZDc1MWQzZGE2MzYwMjdkNWUyZDgyMWU5Nzk=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-01-20T22:32:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-20T22:32:44Z"}, "message": "Rollup merge of #68297 - Aaron1011:fix/new-const-prop-bounds, r=oli-obk\n\n Filter and test predicates using `normalize_and_test_predicates` for const-prop\n\nFixes #68264\n\nPreviously, I attempted to use\n`substitute_normalize_and_test_predicates` to detect unsatisfiable\nbounds. Unfortunately, since const-prop runs in a generic environment\n(we don't have any of the function's generic parameters substituted),\nthis could lead to cycle errors when attempting to normalize predicates.\n\nThis check is replaced with a more precise check. We now only call\n`normalize_and_test_predicates` on predicates that have the possibility\nof being proved unsatisfiable - that is, predicates that don't depend\non anything local to the function (e.g. generic parameters). This\nensures that we don't hit cycle errors when we normalize said\npredicates, while still ensuring that we detect unsatisfiable\npredicates.\n\nI haven't been able to come up with a minimization of the Diesel issue - however, I've verified that it compiles successfully.", "tree": {"sha": "30cb8a64c2af31dbde2872e90a39e934aa6c16db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30cb8a64c2af31dbde2872e90a39e934aa6c16db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bff216c56f472dd751d3da636027d5e2d821e979", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeJiqMCRBK7hj4Ov3rIwAAdHIIAGfXbXICurMPoaqComND3I3p\neByJZsaEX30UpjsehQiLri0XxZj5FFBm6M9yJTmLQ1aemVY3+juAoH/L/T1u5O7B\nThTQDr7IWu7a3VrLzc8CfLppKOYK9xgVNVPCehYyeeFOMUzXJAV2Dz7AttcT31Lx\nByVvHOojrnCUrktGiRI8ycnk9M0kzVptmMDZc+VA8YkeHa7FJmhKRxAukW/U5ar9\n9ftVFMF11X0fyH8plGCZ2hRBCLKl1DOl2j3kPHeNSUYyP9agnJrgvRy9eEwv0Koc\nyWXRr8XPYfcDOKsomBmYHjqCSgJXBb5I3GzJJzrab7Lmnkw74C6Yv2JGQ79QEQ4=\n=TyLq\n-----END PGP SIGNATURE-----\n", "payload": "tree 30cb8a64c2af31dbde2872e90a39e934aa6c16db\nparent eff6381c32c23b094152ad8a7f63f4e617014fd0\nparent 3fef3d8b76e70da88366e45a62f98592cf9be76c\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1579559564 +0900\ncommitter GitHub <noreply@github.com> 1579559564 +0900\n\nRollup merge of #68297 - Aaron1011:fix/new-const-prop-bounds, r=oli-obk\n\n Filter and test predicates using `normalize_and_test_predicates` for const-prop\n\nFixes #68264\n\nPreviously, I attempted to use\n`substitute_normalize_and_test_predicates` to detect unsatisfiable\nbounds. Unfortunately, since const-prop runs in a generic environment\n(we don't have any of the function's generic parameters substituted),\nthis could lead to cycle errors when attempting to normalize predicates.\n\nThis check is replaced with a more precise check. We now only call\n`normalize_and_test_predicates` on predicates that have the possibility\nof being proved unsatisfiable - that is, predicates that don't depend\non anything local to the function (e.g. generic parameters). This\nensures that we don't hit cycle errors when we normalize said\npredicates, while still ensuring that we detect unsatisfiable\npredicates.\n\nI haven't been able to come up with a minimization of the Diesel issue - however, I've verified that it compiles successfully.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bff216c56f472dd751d3da636027d5e2d821e979", "html_url": "https://github.com/rust-lang/rust/commit/bff216c56f472dd751d3da636027d5e2d821e979", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bff216c56f472dd751d3da636027d5e2d821e979/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eff6381c32c23b094152ad8a7f63f4e617014fd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/eff6381c32c23b094152ad8a7f63f4e617014fd0", "html_url": "https://github.com/rust-lang/rust/commit/eff6381c32c23b094152ad8a7f63f4e617014fd0"}, {"sha": "3fef3d8b76e70da88366e45a62f98592cf9be76c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fef3d8b76e70da88366e45a62f98592cf9be76c", "html_url": "https://github.com/rust-lang/rust/commit/3fef3d8b76e70da88366e45a62f98592cf9be76c"}], "stats": {"total": 151, "additions": 79, "deletions": 72}, "files": [{"sha": "51ce575e51f3b61aaec5fdd72cfc51d831a1abab", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=bff216c56f472dd751d3da636027d5e2d821e979", "patch": "@@ -1,7 +1,6 @@\n use crate::dep_graph::{DepConstructor, DepNode, WorkProduct, WorkProductId};\n use crate::ich::{Fingerprint, NodeIdHashingMode, StableHashingContext};\n use crate::session::config::OptLevel;\n-use crate::traits::TraitQueryMode;\n use crate::ty::print::obsolete::DefPathBasedNames;\n use crate::ty::{subst::InternalSubsts, Instance, InstanceDef, SymbolName, TyCtxt};\n use rustc_data_structures::base_n;\n@@ -168,9 +167,7 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::GlobalAsm(..) => return true,\n         };\n \n-        // We shouldn't encounter any overflow here, so we use TraitQueryMode::Standard\\\n-        // to report an error if overflow somehow occurs.\n-        tcx.substitute_normalize_and_test_predicates((def_id, &substs, TraitQueryMode::Standard))\n+        tcx.substitute_normalize_and_test_predicates((def_id, &substs))\n     }\n \n     pub fn to_string(&self, tcx: TyCtxt<'tcx>, debug: bool) -> String {"}, {"sha": "deb2d6ac630ac57534958e583400dcbd5e984ab8", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=bff216c56f472dd751d3da636027d5e2d821e979", "patch": "@@ -1156,11 +1156,11 @@ rustc_queries! {\n             desc { \"normalizing `{:?}`\", goal }\n         }\n \n-        query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>, traits::TraitQueryMode)) -> bool {\n+        query substitute_normalize_and_test_predicates(key: (DefId, SubstsRef<'tcx>)) -> bool {\n             no_force\n             desc { |tcx|\n-                \"testing substituted normalized predicates in mode {:?}:`{}`\",\n-                key.2, tcx.def_path_str(key.0)\n+                \"testing substituted normalized predicates:`{}`\",\n+                tcx.def_path_str(key.0)\n             }\n         }\n "}, {"sha": "46ece6fc4059364039f0d72d885d6411476a39b3", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=bff216c56f472dd751d3da636027d5e2d821e979", "patch": "@@ -16,7 +16,6 @@ use super::CodeSelectionError;\n use super::{ConstEvalFailure, Unimplemented};\n use super::{FulfillmentError, FulfillmentErrorCode};\n use super::{ObligationCause, PredicateObligation};\n-use crate::traits::TraitQueryMode;\n \n impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n     type Predicate = ty::Predicate<'tcx>;\n@@ -63,9 +62,6 @@ pub struct FulfillmentContext<'tcx> {\n     // a snapshot (they don't *straddle* a snapshot, so there\n     // is no trouble there).\n     usable_in_snapshot: bool,\n-\n-    // The `TraitQueryMode` used when constructing a `SelectionContext`\n-    query_mode: TraitQueryMode,\n }\n \n #[derive(Clone, Debug)]\n@@ -79,26 +75,12 @@ pub struct PendingPredicateObligation<'tcx> {\n static_assert_size!(PendingPredicateObligation<'_>, 136);\n \n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n-    /// Creates a new fulfillment context with `TraitQueryMode::Standard`\n-    /// You almost always want to use this instead of `with_query_mode`\n+    /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             register_region_obligations: true,\n             usable_in_snapshot: false,\n-            query_mode: TraitQueryMode::Standard,\n-        }\n-    }\n-\n-    /// Creates a new fulfillment context with the specified query mode.\n-    /// This should only be used when you want to ignore overflow,\n-    /// rather than reporting it as an error.\n-    pub fn with_query_mode(query_mode: TraitQueryMode) -> FulfillmentContext<'tcx> {\n-        FulfillmentContext {\n-            predicates: ObligationForest::new(),\n-            register_region_obligations: true,\n-            usable_in_snapshot: false,\n-            query_mode,\n         }\n     }\n \n@@ -107,7 +89,6 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n             predicates: ObligationForest::new(),\n             register_region_obligations: true,\n             usable_in_snapshot: true,\n-            query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n@@ -116,7 +97,6 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n             predicates: ObligationForest::new(),\n             register_region_obligations: false,\n             usable_in_snapshot: false,\n-            query_mode: TraitQueryMode::Standard,\n         }\n     }\n \n@@ -237,7 +217,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n         &mut self,\n         infcx: &InferCtxt<'_, 'tcx>,\n     ) -> Result<(), Vec<FulfillmentError<'tcx>>> {\n-        let mut selcx = SelectionContext::with_query_mode(infcx, self.query_mode);\n+        let mut selcx = SelectionContext::new(infcx);\n         self.select(&mut selcx)\n     }\n "}, {"sha": "e93529186ac86ebf8f6f0838e2f7ad8780e6763f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=bff216c56f472dd751d3da636027d5e2d821e979", "patch": "@@ -95,7 +95,7 @@ pub enum IntercrateMode {\n }\n \n /// The mode that trait queries run in.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum TraitQueryMode {\n     // Standard/un-canonicalized queries get accurate\n     // spans etc. passed in and hence can do reasonable\n@@ -1014,17 +1014,16 @@ where\n /// environment. If this returns false, then either normalize\n /// encountered an error or one of the predicates did not hold. Used\n /// when creating vtables to check for unsatisfiable methods.\n-fn normalize_and_test_predicates<'tcx>(\n+pub fn normalize_and_test_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicates: Vec<ty::Predicate<'tcx>>,\n-    mode: TraitQueryMode,\n ) -> bool {\n-    debug!(\"normalize_and_test_predicates(predicates={:?}, mode={:?})\", predicates, mode);\n+    debug!(\"normalize_and_test_predicates(predicates={:?})\", predicates);\n \n     let result = tcx.infer_ctxt().enter(|infcx| {\n         let param_env = ty::ParamEnv::reveal_all();\n-        let mut selcx = SelectionContext::with_query_mode(&infcx, mode);\n-        let mut fulfill_cx = FulfillmentContext::with_query_mode(mode);\n+        let mut selcx = SelectionContext::new(&infcx);\n+        let mut fulfill_cx = FulfillmentContext::new();\n         let cause = ObligationCause::dummy();\n         let Normalized { value: predicates, obligations } =\n             normalize(&mut selcx, param_env, cause.clone(), &predicates);\n@@ -1044,12 +1043,12 @@ fn normalize_and_test_predicates<'tcx>(\n \n fn substitute_normalize_and_test_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    key: (DefId, SubstsRef<'tcx>, TraitQueryMode),\n+    key: (DefId, SubstsRef<'tcx>),\n ) -> bool {\n     debug!(\"substitute_normalize_and_test_predicates(key={:?})\", key);\n \n     let predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n-    let result = normalize_and_test_predicates(tcx, predicates, key.2);\n+    let result = normalize_and_test_predicates(tcx, predicates);\n \n     debug!(\"substitute_normalize_and_test_predicates(key={:?}) = {:?}\", key, result);\n     result\n@@ -1102,10 +1101,7 @@ fn vtable_methods<'tcx>(\n             // Note that this method could then never be called, so we\n             // do not want to try and codegen it, in that case (see #23435).\n             let predicates = tcx.predicates_of(def_id).instantiate_own(tcx, substs);\n-            // We don't expect overflow here, so report an error if it somehow ends\n-            // up happening.\n-            if !normalize_and_test_predicates(tcx, predicates.predicates, TraitQueryMode::Standard)\n-            {\n+            if !normalize_and_test_predicates(tcx, predicates.predicates) {\n                 debug!(\"vtable_methods: predicates do not hold\");\n                 return None;\n             }"}, {"sha": "cbf335ad607ef3e9f1ae84ed3825cde3a0f32df9", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=bff216c56f472dd751d3da636027d5e2d821e979", "patch": "@@ -125,15 +125,6 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     }\n }\n \n-impl<'tcx> Key for (DefId, SubstsRef<'tcx>, traits::TraitQueryMode) {\n-    fn query_crate(&self) -> CrateNum {\n-        self.0.krate\n-    }\n-    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n-        self.0.default_span(tcx)\n-    }\n-}\n-\n impl<'tcx> Key for (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>) {\n     fn query_crate(&self) -> CrateNum {\n         self.1.def_id().krate"}, {"sha": "d645f6cf183b4f435a1b33788de2256fa89edb6c", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff216c56f472dd751d3da636027d5e2d821e979/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=bff216c56f472dd751d3da636027d5e2d821e979", "patch": "@@ -14,7 +14,7 @@ use rustc::mir::{\n     SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator, TerminatorKind,\n     UnOp, RETURN_PLACE,\n };\n-use rustc::traits::TraitQueryMode;\n+use rustc::traits;\n use rustc::ty::layout::{\n     HasDataLayout, HasTyCtxt, LayoutError, LayoutOf, Size, TargetDataLayout, TyLayout,\n };\n@@ -90,28 +90,28 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         // If there are unsatisfiable where clauses, then all bets are\n         // off, and we just give up.\n         //\n-        // Note that we use TraitQueryMode::Canonical here, which causes\n-        // us to treat overflow like any other error. This is because we\n-        // are \"speculatively\" evaluating this item with the default substs.\n-        // While this usually succeeds, it may fail with tricky impls\n-        // (e.g. the typenum crate). Const-propagation is fundamentally\n-        // \"best-effort\", and does not affect correctness in any way.\n-        // Therefore, it's perfectly fine to just \"give up\" if we're\n-        // unable to check the bounds with the default substs.\n+        // We manually filter the predicates, skipping anything that's not\n+        // \"global\". We are in a potentially generic context\n+        // (e.g. we are evaluating a function without substituting generic\n+        // parameters, so this filtering serves two purposes:\n         //\n-        // False negatives (failing to run const-prop on something when we actually\n-        // could) are fine. However, false positives (running const-prop on\n-        // an item with unsatisfiable bounds) can lead to us generating invalid\n-        // MIR.\n-        if !tcx.substitute_normalize_and_test_predicates((\n-            source.def_id(),\n-            InternalSubsts::identity_for_item(tcx, source.def_id()),\n-            TraitQueryMode::Canonical,\n-        )) {\n-            trace!(\n-                \"ConstProp skipped for item with unsatisfiable predicates: {:?}\",\n-                source.def_id()\n-            );\n+        // 1. We skip evaluating any predicates that we would\n+        // never be able prove are unsatisfiable (e.g. `<T as Foo>`\n+        // 2. We avoid trying to normalize predicates involving generic\n+        // parameters (e.g. `<T as Foo>::MyItem`). This can confuse\n+        // the normalization code (leading to cycle errors), since\n+        // it's usually never invoked in this way.\n+        let predicates = tcx\n+            .predicates_of(source.def_id())\n+            .predicates\n+            .iter()\n+            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None })\n+            .collect();\n+        if !traits::normalize_and_test_predicates(\n+            tcx,\n+            traits::elaborate_predicates(tcx, predicates).collect(),\n+        ) {\n+            trace!(\"ConstProp skipped for {:?}: found unsatisfiable predicates\", source.def_id());\n             return;\n         }\n "}, {"sha": "8f21e0648d4c73c012ec1f7f592fd64886f71beb", "filename": "src/test/ui/consts/issue-68264-overflow.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bff216c56f472dd751d3da636027d5e2d821e979/src%2Ftest%2Fui%2Fconsts%2Fissue-68264-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bff216c56f472dd751d3da636027d5e2d821e979/src%2Ftest%2Fui%2Fconsts%2Fissue-68264-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-68264-overflow.rs?ref=bff216c56f472dd751d3da636027d5e2d821e979", "patch": "@@ -0,0 +1,43 @@\n+// check-pass\n+// compile-flags: --emit=mir,link\n+// Regression test for issue #68264\n+// Checks that we don't encounter overflow\n+// when running const-prop on functions with\n+// complicated bounds\n+pub trait Query {}\n+\n+pub trait AsQuery {\n+    type Query: Query;\n+}\n+pub trait Table: AsQuery + Sized {}\n+\n+pub trait LimitDsl {\n+    type Output;\n+}\n+\n+pub(crate) trait LoadQuery<Conn, U>: RunQueryDsl<Conn> {}\n+\n+impl<T: Query> AsQuery for T {\n+    type Query = Self;\n+}\n+\n+impl<T> LimitDsl for T\n+where\n+    T: Table,\n+    T::Query: LimitDsl,\n+{\n+    type Output = <T::Query as LimitDsl>::Output;\n+}\n+\n+pub(crate) trait RunQueryDsl<Conn>: Sized {\n+    fn first<U>(self, _conn: &Conn) -> U\n+    where\n+        Self: LimitDsl,\n+        Self::Output: LoadQuery<Conn, U>,\n+    {\n+        // Overflow is caused by this function body\n+        unimplemented!()\n+    }\n+}\n+\n+fn main() {}"}]}