{"sha": "8e9837df21942ca12a5aece0a868ea46eb405742", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOTgzN2RmMjE5NDJjYTEyYTVhZWNlMGE4NjhlYTQ2ZWI0MDU3NDI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-07T10:50:36Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-12-07T12:05:56Z"}, "message": "Remove idx and parent generics from generics\n\nThis makes `hir_def::GenericParams` flatter. The logic for\nre-numbering the params is moved to hir instead.", "tree": {"sha": "664cfafc63c0895d76df5c85f6f10c0739f82275", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/664cfafc63c0895d76df5c85f6f10c0739f82275"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e9837df21942ca12a5aece0a868ea46eb405742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9837df21942ca12a5aece0a868ea46eb405742", "html_url": "https://github.com/rust-lang/rust/commit/8e9837df21942ca12a5aece0a868ea46eb405742", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e9837df21942ca12a5aece0a868ea46eb405742/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "30fefcc08cc0c670ce541476491238d258ca55c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/30fefcc08cc0c670ce541476491238d258ca55c1", "html_url": "https://github.com/rust-lang/rust/commit/30fefcc08cc0c670ce541476491238d258ca55c1"}], "stats": {"total": 338, "additions": 181, "deletions": 157}, "files": [{"sha": "29ace8479dc875d674dfd6c0e2fc69ab046ec483", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=8e9837df21942ca12a5aece0a868ea46eb405742", "patch": "@@ -15,7 +15,7 @@ use hir_def::{\n     per_ns::PerNs,\n     resolver::HasResolver,\n     type_ref::{Mutability, TypeRef},\n-    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericDefId,\n+    AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericParamId,\n     HasModule, ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId, LocalStructFieldId,\n     Lookup, ModuleId, StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n@@ -857,8 +857,7 @@ impl Local {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct GenericParam {\n-    pub(crate) parent: GenericDefId,\n-    pub(crate) idx: u32,\n+    pub(crate) id: GenericParamId,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "8c4b635d22fc2c48588e39b08498c4374d8ce8ff", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=8e9837df21942ca12a5aece0a868ea46eb405742", "patch": "@@ -262,10 +262,7 @@ impl SourceAnalyzer {\n     ) -> Option<PathResolution> {\n         let types = self.resolver.resolve_path_in_type_ns_fully(db, &path).map(|ty| match ty {\n             TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n-            TypeNs::GenericParam(idx) => PathResolution::GenericParam(GenericParam {\n-                parent: self.resolver.generic_def().unwrap(),\n-                idx,\n-            }),\n+            TypeNs::GenericParam(id) => PathResolution::GenericParam(GenericParam { id }),\n             TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => {\n                 PathResolution::Def(Adt::from(it).into())\n             }\n@@ -337,10 +334,7 @@ impl SourceAnalyzer {\n                 resolver::ScopeDef::PerNs(it) => it.into(),\n                 resolver::ScopeDef::ImplSelfType(it) => ScopeDef::ImplSelfType(it.into()),\n                 resolver::ScopeDef::AdtSelfType(it) => ScopeDef::AdtSelfType(it.into()),\n-                resolver::ScopeDef::GenericParam(idx) => {\n-                    let parent = self.resolver.generic_def().unwrap();\n-                    ScopeDef::GenericParam(GenericParam { parent, idx })\n-                }\n+                resolver::ScopeDef::GenericParam(id) => ScopeDef::GenericParam(GenericParam { id }),\n                 resolver::ScopeDef::Local(pat_id) => {\n                     let parent = self.resolver.body_owner().unwrap().into();\n                     ScopeDef::Local(Local { parent, pat_id })"}, {"sha": "94ce835646c5cf9fd7cd808cae42b2ae7b35edd4", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 19, "deletions": 71, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=8e9837df21942ca12a5aece0a868ea46eb405742", "patch": "@@ -12,22 +12,19 @@ use crate::{\n     db::DefDatabase,\n     src::HasSource,\n     type_ref::{TypeBound, TypeRef},\n-    AdtId, AstItemDef, ContainerId, GenericDefId, LocalGenericParamId, Lookup,\n+    AdtId, AstItemDef, GenericDefId, LocalGenericParamId, Lookup,\n };\n \n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct GenericParamData {\n-    // FIXME: give generic params proper IDs\n-    pub idx: u32,\n     pub name: Name,\n     pub default: Option<TypeRef>,\n }\n \n /// Data about the generic parameters of a function, struct, impl, etc.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct GenericParams {\n-    pub parent_params: Option<Arc<GenericParams>>,\n     pub params: Arena<LocalGenericParamId, GenericParamData>,\n     pub where_predicates: Vec<WherePredicate>,\n }\n@@ -47,51 +44,40 @@ impl GenericParams {\n         db: &impl DefDatabase,\n         def: GenericDefId,\n     ) -> Arc<GenericParams> {\n-        let parent_generics = parent_generic_def(db, def).map(|it| db.generic_params(it));\n-        Arc::new(GenericParams::new(db, def.into(), parent_generics))\n+        Arc::new(GenericParams::new(db, def.into()))\n     }\n \n-    fn new(\n-        db: &impl DefDatabase,\n-        def: GenericDefId,\n-        parent_params: Option<Arc<GenericParams>>,\n-    ) -> GenericParams {\n-        let mut generics =\n-            GenericParams { params: Arena::default(), parent_params, where_predicates: Vec::new() };\n-        let start = generics.parent_params.as_ref().map(|p| p.params.len()).unwrap_or(0) as u32;\n+    fn new(db: &impl DefDatabase, def: GenericDefId) -> GenericParams {\n+        let mut generics = GenericParams { params: Arena::default(), where_predicates: Vec::new() };\n         // FIXME: add `: Sized` bound for everything except for `Self` in traits\n         match def {\n-            GenericDefId::FunctionId(it) => generics.fill(&it.lookup(db).source(db).value, start),\n-            GenericDefId::AdtId(AdtId::StructId(it)) => generics.fill(&it.source(db).value, start),\n-            GenericDefId::AdtId(AdtId::UnionId(it)) => generics.fill(&it.source(db).value, start),\n-            GenericDefId::AdtId(AdtId::EnumId(it)) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::FunctionId(it) => generics.fill(&it.lookup(db).source(db).value),\n+            GenericDefId::AdtId(AdtId::StructId(it)) => generics.fill(&it.source(db).value),\n+            GenericDefId::AdtId(AdtId::UnionId(it)) => generics.fill(&it.source(db).value),\n+            GenericDefId::AdtId(AdtId::EnumId(it)) => generics.fill(&it.source(db).value),\n             GenericDefId::TraitId(it) => {\n                 // traits get the Self type as an implicit first type parameter\n-                generics.params.alloc(GenericParamData {\n-                    idx: start,\n-                    name: name::SELF_TYPE,\n-                    default: None,\n-                });\n-                generics.fill(&it.source(db).value, start + 1);\n+                generics.params.alloc(GenericParamData { name: name::SELF_TYPE, default: None });\n+                generics.fill(&it.source(db).value);\n                 // add super traits as bounds on Self\n                 // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n                 let self_param = TypeRef::Path(name::SELF_TYPE.into());\n                 generics.fill_bounds(&it.source(db).value, self_param);\n             }\n-            GenericDefId::TypeAliasId(it) => generics.fill(&it.lookup(db).source(db).value, start),\n+            GenericDefId::TypeAliasId(it) => generics.fill(&it.lookup(db).source(db).value),\n             // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n             // type-parameter, but rather is a type-alias for impl's target\n             // type, so this is handled by the resolver.\n-            GenericDefId::ImplId(it) => generics.fill(&it.source(db).value, start),\n+            GenericDefId::ImplId(it) => generics.fill(&it.source(db).value),\n             GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => {}\n         }\n \n         generics\n     }\n \n-    fn fill(&mut self, node: &impl TypeParamsOwner, start: u32) {\n+    fn fill(&mut self, node: &impl TypeParamsOwner) {\n         if let Some(params) = node.type_param_list() {\n-            self.fill_params(params, start)\n+            self.fill_params(params)\n         }\n         if let Some(where_clause) = node.where_clause() {\n             self.fill_where_predicates(where_clause);\n@@ -106,12 +92,12 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n-        for (idx, type_param) in params.type_params().enumerate() {\n+    fn fill_params(&mut self, params: ast::TypeParamList) {\n+        for type_param in params.type_params() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n             // FIXME: Use `Path::from_src`\n             let default = type_param.default_type().map(TypeRef::from_ast);\n-            let param = GenericParamData { idx: idx as u32 + start, name: name.clone(), default };\n+            let param = GenericParamData { name: name.clone(), default };\n             self.params.alloc(param);\n \n             let type_ref = TypeRef::Path(name.into());\n@@ -141,45 +127,7 @@ impl GenericParams {\n         self.where_predicates.push(WherePredicate { type_ref, bound });\n     }\n \n-    pub fn find_by_name(&self, name: &Name) -> Option<&GenericParamData> {\n-        self.params.iter().map(|(_id, data)| data).find(|p| &p.name == name)\n-    }\n-\n-    pub fn count_parent_params(&self) -> usize {\n-        self.parent_params.as_ref().map(|p| p.count_params_including_parent()).unwrap_or(0)\n-    }\n-\n-    pub fn count_params_including_parent(&self) -> usize {\n-        let parent_count = self.count_parent_params();\n-        parent_count + self.params.len()\n-    }\n-\n-    fn for_each_param<'a>(&'a self, f: &mut impl FnMut(&'a GenericParamData)) {\n-        if let Some(parent) = &self.parent_params {\n-            parent.for_each_param(f);\n-        }\n-        self.params.iter().map(|(_id, data)| data).for_each(f);\n-    }\n-\n-    pub fn params_including_parent(&self) -> Vec<&GenericParamData> {\n-        let mut vec = Vec::with_capacity(self.count_params_including_parent());\n-        self.for_each_param(&mut |p| vec.push(p));\n-        vec\n-    }\n-}\n-\n-fn parent_generic_def(db: &impl DefDatabase, def: GenericDefId) -> Option<GenericDefId> {\n-    let container = match def {\n-        GenericDefId::FunctionId(it) => it.lookup(db).container,\n-        GenericDefId::TypeAliasId(it) => it.lookup(db).container,\n-        GenericDefId::ConstId(it) => it.lookup(db).container,\n-        GenericDefId::EnumVariantId(it) => return Some(it.parent.into()),\n-        GenericDefId::AdtId(_) | GenericDefId::TraitId(_) | GenericDefId::ImplId(_) => return None,\n-    };\n-\n-    match container {\n-        ContainerId::ImplId(it) => Some(it.into()),\n-        ContainerId::TraitId(it) => Some(it.into()),\n-        ContainerId::ModuleId(_) => None,\n+    pub fn find_by_name(&self, name: &Name) -> Option<LocalGenericParamId> {\n+        self.params.iter().find_map(|(id, p)| if &p.name == name { Some(id) } else { None })\n     }\n }"}, {"sha": "e00bd03d54f956c9c28dd4d6310d0d656803ee0b", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=8e9837df21942ca12a5aece0a868ea46eb405742", "patch": "@@ -18,12 +18,13 @@ use crate::{\n     path::{Path, PathKind},\n     per_ns::PerNs,\n     AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId, FunctionId,\n-    GenericDefId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId, StaticId,\n-    StructId, TraitId, TypeAliasId,\n+    GenericDefId, GenericParamId, HasModule, ImplId, LocalModuleId, Lookup, ModuleDefId, ModuleId,\n+    StaticId, StructId, TraitId, TypeAliasId,\n };\n \n #[derive(Debug, Clone, Default)]\n pub struct Resolver {\n+    // FIXME: all usages generally call `.rev`, so maybe reverse once in consturciton?\n     scopes: Vec<Scope>,\n }\n \n@@ -58,7 +59,7 @@ enum Scope {\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub enum TypeNs {\n     SelfType(ImplId),\n-    GenericParam(u32),\n+    GenericParam(GenericParamId),\n     AdtId(AdtId),\n     AdtSelfType(AdtId),\n     // Yup, enum variants are added to the types ns, but any usage of variant as\n@@ -152,10 +153,13 @@ impl Resolver {\n                 Scope::ExprScope(_) => continue,\n                 Scope::GenericParams { .. } | Scope::ImplBlockScope(_) if skip_to_mod => continue,\n \n-                Scope::GenericParams { params, .. } => {\n-                    if let Some(param) = params.find_by_name(first_name) {\n+                Scope::GenericParams { params, def } => {\n+                    if let Some(local_id) = params.find_by_name(first_name) {\n                         let idx = if path.segments.len() == 1 { None } else { Some(1) };\n-                        return Some((TypeNs::GenericParam(param.idx), idx));\n+                        return Some((\n+                            TypeNs::GenericParam(GenericParamId { local_id, parent: *def }),\n+                            idx,\n+                        ));\n                     }\n                 }\n                 Scope::ImplBlockScope(impl_) => {\n@@ -246,9 +250,9 @@ impl Resolver {\n                 }\n                 Scope::ExprScope(_) => continue,\n \n-                Scope::GenericParams { params, .. } if n_segments > 1 => {\n-                    if let Some(param) = params.find_by_name(first_name) {\n-                        let ty = TypeNs::GenericParam(param.idx);\n+                Scope::GenericParams { params, def } if n_segments > 1 => {\n+                    if let Some(local_id) = params.find_by_name(first_name) {\n+                        let ty = TypeNs::GenericParam(GenericParamId { local_id, parent: *def });\n                         return Some(ResolveValueResult::Partial(ty, 1));\n                     }\n                 }\n@@ -368,6 +372,7 @@ impl Resolver {\n     ) -> impl Iterator<Item = &'a crate::generics::WherePredicate> + 'a {\n         self.scopes\n             .iter()\n+            .rev()\n             .filter_map(|scope| match scope {\n                 Scope::GenericParams { params, .. } => Some(params),\n                 _ => None,\n@@ -376,14 +381,14 @@ impl Resolver {\n     }\n \n     pub fn generic_def(&self) -> Option<GenericDefId> {\n-        self.scopes.iter().find_map(|scope| match scope {\n+        self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::GenericParams { def, .. } => Some(*def),\n             _ => None,\n         })\n     }\n \n     pub fn body_owner(&self) -> Option<DefWithBodyId> {\n-        self.scopes.iter().find_map(|scope| match scope {\n+        self.scopes.iter().rev().find_map(|scope| match scope {\n             Scope::ExprScope(it) => Some(it.owner),\n             _ => None,\n         })\n@@ -394,7 +399,7 @@ pub enum ScopeDef {\n     PerNs(PerNs),\n     ImplSelfType(ImplId),\n     AdtSelfType(AdtId),\n-    GenericParam(u32),\n+    GenericParam(GenericParamId),\n     Local(PatId),\n }\n \n@@ -425,9 +430,12 @@ impl Scope {\n                     });\n                 }\n             }\n-            Scope::GenericParams { params, .. } => {\n-                for (_id, param) in params.params.iter() {\n-                    f(param.name.clone(), ScopeDef::GenericParam(param.idx))\n+            Scope::GenericParams { params, def } => {\n+                for (local_id, param) in params.params.iter() {\n+                    f(\n+                        param.name.clone(),\n+                        ScopeDef::GenericParam(GenericParamId { local_id, parent: *def }),\n+                    )\n                 }\n             }\n             Scope::ImplBlockScope(i) => {"}, {"sha": "a6db7f623bcc34fbb589f9acf73ff1f86969b224", "filename": "crates/ra_hir_ty/src/autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fautoderef.rs?ref=8e9837df21942ca12a5aece0a868ea46eb405742", "patch": "@@ -10,10 +10,10 @@ use hir_expand::name;\n use log::{info, warn};\n use ra_db::CrateId;\n \n-use crate::db::HirDatabase;\n-\n-use super::{\n+use crate::{\n+    db::HirDatabase,\n     traits::{InEnvironment, Solution},\n+    utils::generics,\n     Canonical, Substs, Ty, TypeWalk,\n };\n \n@@ -54,7 +54,7 @@ fn deref_by_trait(\n     };\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name::TARGET_TYPE)?;\n \n-    let generic_params = db.generic_params(target.into());\n+    let generic_params = generics(db, target.into());\n     if generic_params.count_params_including_parent() != 1 {\n         // the Target type + Deref trait should only have one generic parameter,\n         // namely Deref's Self type"}, {"sha": "e52040eb5b88dc23ed65e50e4d954c5ac61cba2f", "filename": "crates/ra_hir_ty/src/infer/expr.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=8e9837df21942ca12a5aece0a868ea46eb405742", "patch": "@@ -6,7 +6,6 @@ use std::sync::Arc;\n use hir_def::{\n     builtin_type::Signedness,\n     expr::{Array, BinaryOp, Expr, ExprId, Literal, Statement, UnaryOp},\n-    generics::GenericParams,\n     path::{GenericArg, GenericArgs},\n     resolver::resolver_for_expr,\n     AdtId, ContainerId, Lookup, StructFieldId,\n@@ -15,7 +14,11 @@ use hir_expand::name::{self, Name};\n use ra_syntax::ast::RangeOp;\n \n use crate::{\n-    autoderef, db::HirDatabase, method_resolution, op, traits::InEnvironment, utils::variant_data,\n+    autoderef,\n+    db::HirDatabase,\n+    method_resolution, op,\n+    traits::InEnvironment,\n+    utils::{generics, variant_data, Generics},\n     CallableDef, InferTy, IntTy, Mutability, Obligation, ProjectionPredicate, ProjectionTy, Substs,\n     TraitRef, Ty, TypeCtor, TypeWalk, Uncertain,\n };\n@@ -596,7 +599,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             Some((ty, func)) => {\n                 let ty = canonicalized_receiver.decanonicalize_ty(ty);\n                 self.write_method_resolution(tgt_expr, func);\n-                (ty, self.db.value_ty(func.into()), Some(self.db.generic_params(func.into())))\n+                (ty, self.db.value_ty(func.into()), Some(generics(self.db, func.into())))\n             }\n             None => (receiver_ty, Ty::Unknown, None),\n         };\n@@ -653,16 +656,17 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n     fn substs_for_method_call(\n         &mut self,\n-        def_generics: Option<Arc<GenericParams>>,\n+        def_generics: Option<Generics>,\n         generic_args: Option<&GenericArgs>,\n         receiver_ty: &Ty,\n     ) -> Substs {\n-        let (parent_param_count, param_count) =\n-            def_generics.as_ref().map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n+        let (parent_param_count, param_count) = def_generics\n+            .as_ref()\n+            .map_or((0, 0), |g| (g.count_parent_params(), g.params.params.len()));\n         let mut substs = Vec::with_capacity(parent_param_count + param_count);\n         // Parent arguments are unknown, except for the receiver type\n-        if let Some(parent_generics) = def_generics.and_then(|p| p.parent_params.clone()) {\n-            for (_id, param) in parent_generics.params.iter() {\n+        if let Some(parent_generics) = def_generics.as_ref().map(|p| p.iter_parent()) {\n+            for (_id, param) in parent_generics {\n                 if param.name == name::SELF_TYPE {\n                     substs.push(receiver_ty.clone());\n                 } else {\n@@ -706,9 +710,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         if let ContainerId::TraitId(trait_) = f.lookup(self.db).container {\n                             // construct a TraitDef\n                             let substs = a_ty.parameters.prefix(\n-                                self.db\n-                                    .generic_params(trait_.into())\n-                                    .count_params_including_parent(),\n+                                generics(self.db, trait_.into()).count_params_including_parent(),\n                             );\n                             self.obligations.push(Obligation::Trait(TraitRef {\n                                 trait_: trait_.into(),"}, {"sha": "99fd7158ee8b473a02eb8a958cc558d315b6e1fb", "filename": "crates/ra_hir_ty/src/lib.rs", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flib.rs?ref=8e9837df21942ca12a5aece0a868ea46eb405742", "patch": "@@ -44,7 +44,7 @@ use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n use hir_def::{\n-    expr::ExprId, generics::GenericParams, type_ref::Mutability, AdtId, ContainerId, DefWithBodyId,\n+    expr::ExprId, type_ref::Mutability, AdtId, ContainerId, DefWithBodyId,\n     GenericDefId, HasModule, Lookup, TraitId, TypeAliasId,\n };\n use hir_expand::name::Name;\n@@ -53,7 +53,7 @@ use ra_db::{impl_intern_key, salsa, CrateId};\n use crate::{\n     db::HirDatabase,\n     primitive::{FloatTy, IntTy, Uncertain},\n-    utils::make_mut_slice,\n+    utils::{generics, make_mut_slice, Generics},\n };\n use display::{HirDisplay, HirFormatter};\n \n@@ -166,15 +166,15 @@ impl TypeCtor {\n             | TypeCtor::Closure { .. } // 1 param representing the signature of the closure\n             => 1,\n             TypeCtor::Adt(adt) => {\n-                let generic_params = db.generic_params(AdtId::from(adt).into());\n+                let generic_params = generics(db, AdtId::from(adt).into());\n                 generic_params.count_params_including_parent()\n             }\n             TypeCtor::FnDef(callable) => {\n-                let generic_params = db.generic_params(callable.into());\n+                let generic_params = generics(db, callable.into());\n                 generic_params.count_params_including_parent()\n             }\n             TypeCtor::AssociatedType(type_alias) => {\n-                let generic_params = db.generic_params(type_alias.into());\n+                let generic_params = generics(db, type_alias.into());\n                 generic_params.count_params_including_parent()\n             }\n             TypeCtor::FnPtr { num_args } => num_args as usize + 1,\n@@ -364,35 +364,25 @@ impl Substs {\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n-    pub fn identity(generic_params: &GenericParams) -> Substs {\n+    pub(crate) fn identity(generic_params: &Generics) -> Substs {\n         Substs(\n-            generic_params\n-                .params_including_parent()\n-                .into_iter()\n-                .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n-                .collect(),\n+            generic_params.iter().map(|(idx, p)| Ty::Param { idx, name: p.name.clone() }).collect(),\n         )\n     }\n \n     /// Return Substs that replace each parameter by a bound variable.\n-    pub fn bound_vars(generic_params: &GenericParams) -> Substs {\n-        Substs(\n-            generic_params\n-                .params_including_parent()\n-                .into_iter()\n-                .map(|p| Ty::Bound(p.idx))\n-                .collect(),\n-        )\n+    pub(crate) fn bound_vars(generic_params: &Generics) -> Substs {\n+        Substs(generic_params.iter().map(|(idx, _p)| Ty::Bound(idx)).collect())\n     }\n \n     pub fn build_for_def(db: &impl HirDatabase, def: impl Into<GenericDefId>) -> SubstsBuilder {\n         let def = def.into();\n-        let params = db.generic_params(def);\n+        let params = generics(db, def);\n         let param_count = params.count_params_including_parent();\n         Substs::builder(param_count)\n     }\n \n-    pub fn build_for_generics(generic_params: &GenericParams) -> SubstsBuilder {\n+    pub(crate) fn build_for_generics(generic_params: &Generics) -> SubstsBuilder {\n         Substs::builder(generic_params.count_params_including_parent())\n     }\n "}, {"sha": "d31f6a2d2959f883958ece11b260bf56a49c7ce3", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=8e9837df21942ca12a5aece0a868ea46eb405742", "patch": "@@ -24,7 +24,7 @@ use crate::{\n     db::HirDatabase,\n     primitive::{FloatTy, IntTy},\n     utils::{\n-        all_super_traits, associated_type_by_name_including_super_traits, make_mut_slice,\n+        all_super_traits, associated_type_by_name_including_super_traits, generics, make_mut_slice,\n         variant_data,\n     },\n     FnSig, GenericPredicate, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, TraitRef,\n@@ -111,7 +111,9 @@ impl Ty {\n             Some((it, None)) => it,\n             _ => return None,\n         };\n-        if let TypeNs::GenericParam(idx) = resolution {\n+        if let TypeNs::GenericParam(param_id) = resolution {\n+            let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n+            let idx = generics.param_idx(param_id);\n             Some(idx)\n         } else {\n             None\n@@ -174,9 +176,11 @@ impl Ty {\n                     Ty::Dyn(Arc::new([GenericPredicate::Implemented(trait_ref)]))\n                 };\n             }\n-            TypeNs::GenericParam(idx) => {\n+            TypeNs::GenericParam(param_id) => {\n+                let generics = generics(db, resolver.generic_def().expect(\"generics in scope\"));\n+                let idx = generics.param_idx(param_id);\n                 // FIXME: maybe return name in resolution?\n-                let name = resolved_segment.name.clone();\n+                let name = generics.param_name(param_id);\n                 Ty::Param { idx, name }\n             }\n             TypeNs::SelfType(impl_id) => db.impl_self_ty(impl_id).clone(),\n@@ -315,10 +319,10 @@ pub(super) fn substs_from_path_segment(\n     add_self_param: bool,\n ) -> Substs {\n     let mut substs = Vec::new();\n-    let def_generics = def_generic.map(|def| db.generic_params(def.into()));\n+    let def_generics = def_generic.map(|def| generics(db, def.into()));\n \n     let (parent_param_count, param_count) =\n-        def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.len()));\n+        def_generics.map_or((0, 0), |g| (g.count_parent_params(), g.params.params.len()));\n     substs.extend(iter::repeat(Ty::Unknown).take(parent_param_count));\n     if add_self_param {\n         // FIXME this add_self_param argument is kind of a hack: Traits have the\n@@ -567,12 +571,11 @@ pub(crate) fn generic_predicates_query(\n /// Resolve the default type params from generics\n pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDefId) -> Substs {\n     let resolver = def.resolver(db);\n-    let generic_params = db.generic_params(def.into());\n+    let generic_params = generics(db, def.into());\n \n     let defaults = generic_params\n-        .params_including_parent()\n-        .into_iter()\n-        .map(|p| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(db, &resolver, t)))\n+        .iter()\n+        .map(|(_idx, p)| p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(db, &resolver, t)))\n         .collect();\n \n     Substs(defaults)\n@@ -589,7 +592,7 @@ fn fn_sig_for_fn(db: &impl HirDatabase, def: FunctionId) -> FnSig {\n /// Build the declared type of a function. This should not need to look at the\n /// function body.\n fn type_for_fn(db: &impl HirDatabase, def: FunctionId) -> Ty {\n-    let generics = db.generic_params(def.into());\n+    let generics = generics(db, def.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n@@ -639,7 +642,7 @@ fn type_for_struct_constructor(db: &impl HirDatabase, def: StructId) -> Ty {\n     if struct_data.variant_data.is_unit() {\n         return type_for_adt(db, def.into()); // Unit struct\n     }\n-    let generics = db.generic_params(def.into());\n+    let generics = generics(db, def.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(def.into()), substs)\n }\n@@ -653,7 +656,7 @@ fn fn_sig_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId\n         .iter()\n         .map(|(_, field)| Ty::from_hir(db, &resolver, &field.type_ref))\n         .collect::<Vec<_>>();\n-    let generics = db.generic_params(def.parent.into());\n+    let generics = generics(db, def.parent.into());\n     let substs = Substs::identity(&generics);\n     let ret = type_for_adt(db, def.parent.into()).subst(&substs);\n     FnSig::from_params_and_return(params, ret)\n@@ -666,18 +669,18 @@ fn type_for_enum_variant_constructor(db: &impl HirDatabase, def: EnumVariantId)\n     if var_data.is_unit() {\n         return type_for_adt(db, def.parent.into()); // Unit variant\n     }\n-    let generics = db.generic_params(def.parent.into());\n+    let generics = generics(db, def.parent.into());\n     let substs = Substs::identity(&generics);\n     Ty::apply(TypeCtor::FnDef(EnumVariantId::from(def).into()), substs)\n }\n \n fn type_for_adt(db: &impl HirDatabase, adt: AdtId) -> Ty {\n-    let generics = db.generic_params(adt.into());\n+    let generics = generics(db, adt.into());\n     Ty::apply(TypeCtor::Adt(adt), Substs::identity(&generics))\n }\n \n fn type_for_type_alias(db: &impl HirDatabase, t: TypeAliasId) -> Ty {\n-    let generics = db.generic_params(t.into());\n+    let generics = generics(db, t.into());\n     let resolver = t.resolver(db);\n     let type_ref = &db.type_alias_data(t).type_ref;\n     let substs = Substs::identity(&generics);"}, {"sha": "1d44320b94412d161e9ca0c4e75d380b0d613b7e", "filename": "crates/ra_hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=8e9837df21942ca12a5aece0a868ea46eb405742", "patch": "@@ -19,8 +19,8 @@ use ra_db::{\n \n use super::{builtin, AssocTyValue, Canonical, ChalkContext, Impl, Obligation};\n use crate::{\n-    db::HirDatabase, display::HirDisplay, ApplicationTy, GenericPredicate, ProjectionTy, Substs,\n-    TraitRef, Ty, TypeCtor, TypeWalk,\n+    db::HirDatabase, display::HirDisplay, utils::generics, ApplicationTy, GenericPredicate,\n+    ProjectionTy, Substs, TraitRef, Ty, TypeCtor, TypeWalk,\n };\n \n /// This represents a trait whose name we could not resolve.\n@@ -547,7 +547,7 @@ pub(crate) fn associated_ty_data_query(\n         ContainerId::TraitId(t) => t,\n         _ => panic!(\"associated type not in trait\"),\n     };\n-    let generic_params = db.generic_params(type_alias.into());\n+    let generic_params = generics(db, type_alias.into());\n     let bound_data = chalk_rust_ir::AssociatedTyDatumBound {\n         // FIXME add bounds and where clauses\n         bounds: vec![],\n@@ -589,7 +589,7 @@ pub(crate) fn trait_datum_query(\n     let trait_: TraitId = from_chalk(db, trait_id);\n     let trait_data = db.trait_data(trait_);\n     debug!(\"trait {:?} = {:?}\", trait_id, trait_data.name);\n-    let generic_params = db.generic_params(trait_.into());\n+    let generic_params = generics(db, trait_.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let flags = chalk_rust_ir::TraitFlags {\n         auto: trait_data.auto,\n@@ -626,7 +626,7 @@ pub(crate) fn struct_datum_query(\n     let where_clauses = type_ctor\n         .as_generic_def()\n         .map(|generic_def| {\n-            let generic_params = db.generic_params(generic_def.into());\n+            let generic_params = generics(db, generic_def.into());\n             let bound_vars = Substs::bound_vars(&generic_params);\n             convert_where_clauses(db, generic_def, &bound_vars)\n         })\n@@ -669,7 +669,7 @@ fn impl_block_datum(\n     let trait_ref = db.impl_trait(impl_id)?;\n     let impl_data = db.impl_data(impl_id);\n \n-    let generic_params = db.generic_params(impl_id.into());\n+    let generic_params = generics(db, impl_id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let trait_ref = trait_ref.subst(&bound_vars);\n     let trait_ = trait_ref.trait_;\n@@ -767,7 +767,7 @@ fn type_alias_associated_ty_value(\n         .trait_data(trait_ref.trait_)\n         .associated_type_by_name(&type_alias_data.name)\n         .expect(\"assoc ty value should not exist\"); // validated when building the impl data as well\n-    let generic_params = db.generic_params(impl_id.into());\n+    let generic_params = generics(db, impl_id.into());\n     let bound_vars = Substs::bound_vars(&generic_params);\n     let ty = db.ty(type_alias.into()).subst(&bound_vars);\n     let value_bound = chalk_rust_ir::AssociatedTyValueBound { ty: ty.to_chalk(db) };"}, {"sha": "2c458867ffbac06097e578d2b80035de249da50a", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9837df21942ca12a5aece0a868ea46eb405742/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=8e9837df21942ca12a5aece0a868ea46eb405742", "patch": "@@ -5,9 +5,10 @@ use std::sync::Arc;\n use hir_def::{\n     adt::VariantData,\n     db::DefDatabase,\n+    generics::{GenericParamData, GenericParams},\n     resolver::{HasResolver, TypeNs},\n     type_ref::TypeRef,\n-    TraitId, TypeAliasId, VariantId,\n+    ContainerId, GenericDefId, GenericParamId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{self, Name};\n \n@@ -82,3 +83,82 @@ pub(crate) fn make_mut_slice<T: Clone>(a: &mut Arc<[T]>) -> &mut [T] {\n     }\n     Arc::get_mut(a).unwrap()\n }\n+\n+pub(crate) fn generics(db: &impl DefDatabase, def: GenericDefId) -> Generics {\n+    let parent_generics = parent_generic_def(db, def).map(|def| Box::new(generics(db, def)));\n+    Generics { def, params: db.generic_params(def), parent_generics }\n+}\n+\n+pub(crate) struct Generics {\n+    def: GenericDefId,\n+    pub(crate) params: Arc<GenericParams>,\n+    parent_generics: Option<Box<Generics>>,\n+}\n+\n+impl Generics {\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = (u32, &'a GenericParamData)> + 'a {\n+        self.parent_generics\n+            .as_ref()\n+            .into_iter()\n+            .flat_map(|it| it.params.params.iter())\n+            .chain(self.params.params.iter())\n+            .enumerate()\n+            .map(|(i, (_local_id, p))| (i as u32, p))\n+    }\n+\n+    pub(crate) fn iter_parent<'a>(\n+        &'a self,\n+    ) -> impl Iterator<Item = (u32, &'a GenericParamData)> + 'a {\n+        self.parent_generics\n+            .as_ref()\n+            .into_iter()\n+            .flat_map(|it| it.params.params.iter())\n+            .enumerate()\n+            .map(|(i, (_local_id, p))| (i as u32, p))\n+    }\n+\n+    pub(crate) fn count_parent_params(&self) -> usize {\n+        self.parent_generics.as_ref().map_or(0, |p| p.count_params_including_parent())\n+    }\n+\n+    pub(crate) fn count_params_including_parent(&self) -> usize {\n+        let parent_count = self.count_parent_params();\n+        parent_count + self.params.params.len()\n+    }\n+    pub(crate) fn param_idx(&self, param: GenericParamId) -> u32 {\n+        self.find_param(param).0\n+    }\n+    pub(crate) fn param_name(&self, param: GenericParamId) -> Name {\n+        self.find_param(param).1.name.clone()\n+    }\n+    fn find_param(&self, param: GenericParamId) -> (u32, &GenericParamData) {\n+        if param.parent == self.def {\n+            let (idx, (_local_id, data)) = self\n+                .params\n+                .params\n+                .iter()\n+                .enumerate()\n+                .find(|(_, (idx, _))| *idx == param.local_id)\n+                .unwrap();\n+\n+            return ((self.count_parent_params() + idx) as u32, data);\n+        }\n+        self.parent_generics.as_ref().unwrap().find_param(param)\n+    }\n+}\n+\n+fn parent_generic_def(db: &impl DefDatabase, def: GenericDefId) -> Option<GenericDefId> {\n+    let container = match def {\n+        GenericDefId::FunctionId(it) => it.lookup(db).container,\n+        GenericDefId::TypeAliasId(it) => it.lookup(db).container,\n+        GenericDefId::ConstId(it) => it.lookup(db).container,\n+        GenericDefId::EnumVariantId(it) => return Some(it.parent.into()),\n+        GenericDefId::AdtId(_) | GenericDefId::TraitId(_) | GenericDefId::ImplId(_) => return None,\n+    };\n+\n+    match container {\n+        ContainerId::ImplId(it) => Some(it.into()),\n+        ContainerId::TraitId(it) => Some(it.into()),\n+        ContainerId::ModuleId(_) => None,\n+    }\n+}"}]}