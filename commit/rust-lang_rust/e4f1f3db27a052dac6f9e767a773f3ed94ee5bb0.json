{"sha": "e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZjFmM2RiMjdhMDUyZGFjNmY5ZTc2N2E3NzNmM2VkOTRlZTViYjA=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-03-11T14:18:01Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-03-11T17:42:51Z"}, "message": "Implement incremental caching of object files", "tree": {"sha": "40df8ef424d76c2ddeb15d1dcd7c6a198ef409bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40df8ef424d76c2ddeb15d1dcd7c6a198ef409bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0", "html_url": "https://github.com/rust-lang/rust/commit/e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e074106e60e6b3108c7757a70c1e72be385d3ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e074106e60e6b3108c7757a70c1e72be385d3ba", "html_url": "https://github.com/rust-lang/rust/commit/1e074106e60e6b3108c7757a70c1e72be385d3ba"}], "stats": {"total": 237, "additions": 187, "deletions": 50}, "files": [{"sha": "1ce2e1ce7733c716c86489ca290242a6e3fd2936", "filename": "src/driver.rs", "status": "modified", "additions": 175, "deletions": 46, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0", "patch": "@@ -2,9 +2,11 @@ use std::any::Any;\n use std::ffi::CString;\n use std::os::raw::{c_char, c_int};\n \n+use rustc::dep_graph::{WorkProduct, WorkProductFileKind, WorkProductId};\n use rustc::middle::cstore::EncodedMetadata;\n-use rustc::mir::mono::{Linkage as RLinkage, Visibility};\n+use rustc::mir::mono::{CodegenUnit, Linkage as RLinkage, Visibility};\n use rustc::session::config::{DebugInfo, OutputType};\n+use rustc_session::cgu_reuse_tracker::CguReuse;\n use rustc_codegen_ssa::back::linker::LinkerInfo;\n use rustc_codegen_ssa::CrateInfo;\n \n@@ -172,20 +174,32 @@ fn run_aot(\n     tcx: TyCtxt<'_>,\n     metadata: EncodedMetadata,\n     need_metadata_module: bool,\n-) -> Box<CodegenResults> {\n-    let new_module = |name: String| {\n+) -> Box<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)> {\n+    let mut work_products = FxHashMap::default();\n+\n+    fn new_module(tcx: TyCtxt<'_>, name: String) -> Module<crate::backend::Backend> {\n         let module = crate::backend::make_module(tcx.sess, name);\n         assert_eq!(pointer_ty(tcx), module.target_config().pointer_type());\n         module\n     };\n \n+    struct ModuleCodegenResult(CompiledModule, Option<(WorkProductId, WorkProduct)>);\n+\n+    use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+\n+    impl<HCX> HashStable<HCX> for ModuleCodegenResult {\n+        fn hash_stable(&self, _: &mut HCX, _: &mut StableHasher) {\n+            // do nothing\n+        }\n+    }\n+\n     fn emit_module<B: Backend>(\n         tcx: TyCtxt<'_>,\n         name: String,\n         kind: ModuleKind,\n         mut module: Module<B>,\n         debug: Option<DebugContext>,\n-    ) -> CompiledModule\n+    ) -> ModuleCodegenResult\n         where B::Product: Emit + WriteDebugInfo,\n     {\n             module.finalize_definitions();\n@@ -200,54 +214,146 @@ fn run_aot(\n                 .temp_path(OutputType::Object, Some(&name));\n             let obj = product.emit();\n             std::fs::write(&tmp_file, obj).unwrap();\n-            CompiledModule {\n-                name,\n-                kind,\n-                object: Some(tmp_file),\n-                bytecode: None,\n-                bytecode_compressed: None,\n-            }\n+\n+            let work_product = if std::env::var(\"CG_CLIF_INCR_CACHE\").is_ok() {\n+                rustc_incremental::copy_cgu_workproducts_to_incr_comp_cache_dir(\n+                    tcx.sess,\n+                    &name,\n+                    &[(WorkProductFileKind::Object, tmp_file.clone())],\n+                )\n+            } else {\n+                None\n+            };\n+\n+            ModuleCodegenResult(\n+                CompiledModule {\n+                    name,\n+                    kind,\n+                    object: Some(tmp_file),\n+                    bytecode: None,\n+                    bytecode_compressed: None,\n+                },\n+                work_product,\n+            )\n         };\n \n     let (_, cgus) = tcx.collect_and_partition_mono_items(LOCAL_CRATE);\n \n-    let modules = time(tcx.sess, \"codegen mono items\", move || {\n+    if tcx.dep_graph.is_fully_enabled() {\n+        for cgu in &*cgus {\n+            tcx.codegen_unit(cgu.name());\n+        }\n+    }\n+\n+    let modules = time(tcx.sess, \"codegen mono items\", || {\n         cgus.iter().map(|cgu| {\n-            let mono_items = cgu.items_in_deterministic_order(tcx);\n+            let cgu_reuse = determine_cgu_reuse(tcx, cgu);\n+            tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n+\n+            match cgu_reuse {\n+                CguReuse::No => {}\n+                CguReuse::PreLto => {\n+                    let incr_comp_session_dir = tcx.sess.incr_comp_session_dir();\n+                    let mut object = None;\n+                    let work_product = cgu.work_product(tcx);\n+                    for (kind, saved_file) in &work_product.saved_files {\n+                        let obj_out = match kind {\n+                            WorkProductFileKind::Object => {\n+                                let path = tcx.output_filenames(LOCAL_CRATE).temp_path(OutputType::Object, Some(&cgu.name().as_str()));\n+                                object = Some(path.clone());\n+                                path\n+                            }\n+                            WorkProductFileKind::Bytecode | WorkProductFileKind::BytecodeCompressed => {\n+                                panic!(\"cg_clif doesn't use bytecode\");\n+                            }\n+                        };\n+                        let source_file = rustc_incremental::in_incr_comp_dir(&incr_comp_session_dir, &saved_file);\n+                        if let Err(err) = rustc_fs_util::link_or_copy(&source_file, &obj_out) {\n+                            tcx.sess.err(&format!(\n+                                \"unable to copy {} to {}: {}\",\n+                                source_file.display(),\n+                                obj_out.display(),\n+                                err\n+                            ));\n+                        }\n+                    }\n+\n+                    work_products.insert(cgu.work_product_id(), work_product);\n \n-            let mut module = new_module(cgu.name().as_str().to_string());\n+                    return CompiledModule {\n+                        name: cgu.name().to_string(),\n+                        kind: ModuleKind::Regular,\n+                        object,\n+                        bytecode: None,\n+                        bytecode_compressed: None,\n+                    };\n+                }\n+                CguReuse::PostLto => unreachable!(),\n+            }\n+\n+            let dep_node = cgu.codegen_dep_node(tcx);\n+            let (ModuleCodegenResult(module, work_product), _) =\n+                tcx.dep_graph.with_task(dep_node, tcx, cgu.name(), module_codegen, rustc::dep_graph::hash_result);\n \n-            let mut debug = if tcx.sess.opts.debuginfo != DebugInfo::None {\n-                let debug = DebugContext::new(\n+            fn module_codegen(tcx: TyCtxt<'_>, cgu_name: rustc_span::Symbol) -> ModuleCodegenResult {\n+                let cgu = tcx.codegen_unit(cgu_name);\n+                let mono_items = cgu.items_in_deterministic_order(tcx);\n+\n+                let mut module = new_module(tcx, cgu_name.as_str().to_string());\n+\n+                let mut debug = if tcx.sess.opts.debuginfo != DebugInfo::None {\n+                    let debug = DebugContext::new(\n+                        tcx,\n+                        module.target_config().pointer_type().bytes() as u8,\n+                    );\n+                    Some(debug)\n+                } else {\n+                    None\n+                };\n+\n+                codegen_mono_items(tcx, &mut module, debug.as_mut(), mono_items);\n+                crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module);\n+\n+                emit_module(\n                     tcx,\n-                    module.target_config().pointer_type().bytes() as u8,\n-                );\n-                Some(debug)\n-            } else {\n-                None\n-            };\n+                    cgu.name().as_str().to_string(),\n+                    ModuleKind::Regular,\n+                    module,\n+                    debug,\n+                )\n+            }\n \n-            codegen_mono_items(tcx, &mut module, debug.as_mut(), mono_items);\n-            crate::main_shim::maybe_create_entry_wrapper(tcx, &mut module);\n+            if let Some((id, product)) = work_product {\n+                work_products.insert(id, product);\n+            }\n \n-            emit_module(\n-                tcx,\n-                cgu.name().as_str().to_string(),\n-                ModuleKind::Regular,\n-                module,\n-                debug,\n-            )\n+            module\n         }).collect::<Vec<_>>()\n     });\n \n     tcx.sess.abort_if_errors();\n \n-    let mut allocator_module = new_module(\"allocator_shim\".to_string());\n+    let mut allocator_module = new_module(tcx, \"allocator_shim\".to_string());\n     let created_alloc_shim = crate::allocator::codegen(tcx, &mut allocator_module);\n \n+    let allocator_module = if created_alloc_shim {\n+        let ModuleCodegenResult(module, work_product) = emit_module(\n+            tcx,\n+            \"allocator_shim\".to_string(),\n+            ModuleKind::Allocator,\n+            allocator_module,\n+            None,\n+        );\n+        if let Some((id, product)) = work_product {\n+            work_products.insert(id, product);\n+        }\n+        Some(module)\n+    } else {\n+        None\n+    };\n+\n     rustc_incremental::assert_dep_graph(tcx);\n     rustc_incremental::save_dep_graph(tcx);\n-    rustc_incremental::finalize_session_directory(tcx.sess, tcx.crate_hash(LOCAL_CRATE));\n \n     let metadata_module = if need_metadata_module {\n         let _timer = tcx.prof.generic_activity(\"codegen crate metadata\");\n@@ -284,27 +390,17 @@ fn run_aot(\n         None\n     };\n \n-    Box::new(CodegenResults {\n+    Box::new((CodegenResults {\n         crate_name: tcx.crate_name(LOCAL_CRATE),\n         modules,\n-        allocator_module: if created_alloc_shim {\n-            Some(emit_module(\n-                tcx,\n-                \"allocator_shim\".to_string(),\n-                ModuleKind::Allocator,\n-                allocator_module,\n-                None,\n-            ))\n-        } else {\n-            None\n-        },\n+        allocator_module,\n         metadata_module,\n         crate_hash: tcx.crate_hash(LOCAL_CRATE),\n         metadata,\n         windows_subsystem: None, // Windows is not yet supported\n         linker_info: LinkerInfo::new(tcx),\n         crate_info: CrateInfo::new(tcx),\n-    })\n+    }, work_products))\n }\n \n fn codegen_mono_items<'tcx>(\n@@ -402,3 +498,36 @@ fn time<R>(sess: &Session, name: &'static str, f: impl FnOnce() -> R) -> R {\n     println!(\"[{}] end time: {:?}\", name, after - before);\n     res\n }\n+\n+// Adapted from https://github.com/rust-lang/rust/blob/303d8aff6092709edd4dbd35b1c88e9aa40bf6d8/src/librustc_codegen_ssa/base.rs#L922-L953\n+fn determine_cgu_reuse<'tcx>(tcx: TyCtxt<'tcx>, cgu: &CodegenUnit<'tcx>) -> CguReuse {\n+    if !tcx.dep_graph.is_fully_enabled() {\n+        return CguReuse::No;\n+    }\n+\n+    let work_product_id = &cgu.work_product_id();\n+    if tcx.dep_graph.previous_work_product(work_product_id).is_none() {\n+        // We don't have anything cached for this CGU. This can happen\n+        // if the CGU did not exist in the previous session.\n+        return CguReuse::No;\n+    }\n+\n+    // Try to mark the CGU as green. If it we can do so, it means that nothing\n+    // affecting the LLVM module has changed and we can re-use a cached version.\n+    // If we compile with any kind of LTO, this means we can re-use the bitcode\n+    // of the Pre-LTO stage (possibly also the Post-LTO version but we'll only\n+    // know that later). If we are not doing LTO, there is only one optimized\n+    // version of each module, so we re-use that.\n+    let dep_node = cgu.codegen_dep_node(tcx);\n+    assert!(\n+        !tcx.dep_graph.dep_node_exists(&dep_node),\n+        \"CompileCodegenUnit dep-node for CGU `{}` already exists before marking.\",\n+        cgu.name()\n+    );\n+\n+    if tcx.dep_graph.try_mark_green(tcx, &dep_node).is_some() {\n+        CguReuse::PreLto\n+    } else {\n+        CguReuse::No\n+    }\n+}"}, {"sha": "81111b776d67610db9d5781b00214af9ac469c98", "filename": "src/lib.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=e4f1f3db27a052dac6f9e767a773f3ed94ee5bb0", "patch": "@@ -21,7 +21,7 @@ extern crate rustc_ast;\n \n use std::any::Any;\n \n-use rustc::dep_graph::DepGraph;\n+use rustc::dep_graph::{DepGraph, WorkProduct, WorkProductId};\n use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::session::config::OutputFilenames;\n use rustc::ty::query::Providers;\n@@ -216,10 +216,16 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     fn join_codegen(\n         &self,\n         ongoing_codegen: Box<dyn Any>,\n-        _sess: &Session,\n-        _dep_graph: &DepGraph,\n+        sess: &Session,\n+        dep_graph: &DepGraph,\n     ) -> Result<Box<dyn Any>, ErrorReported> {\n-        Ok(ongoing_codegen)\n+        let (codegen_results, work_products) = *ongoing_codegen.downcast::<(CodegenResults, FxHashMap<WorkProductId, WorkProduct>)>().unwrap();\n+\n+        sess.time(\"serialize_work_products\", move || {\n+            rustc_incremental::save_work_product_index(sess, &dep_graph, work_products)\n+        });\n+\n+        Ok(Box::new(codegen_results))\n     }\n \n     fn link(\n@@ -247,6 +253,8 @@ impl CodegenBackend for CraneliftCodegenBackend {\n             );\n         });\n \n+        rustc_incremental::finalize_session_directory(sess, codegen_results.crate_hash);\n+\n         Ok(())\n     }\n }"}]}