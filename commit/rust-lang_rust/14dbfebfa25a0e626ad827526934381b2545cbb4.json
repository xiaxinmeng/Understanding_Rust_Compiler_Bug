{"sha": "14dbfebfa25a0e626ad827526934381b2545cbb4", "node_id": "C_kwDOAAsO6NoAKDE0ZGJmZWJmYTI1YTBlNjI2YWQ4Mjc1MjY5MzQzODFiMjU0NWNiYjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T13:36:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T13:36:59Z"}, "message": "Auto merge of #99506 - Dylan-DPC:rollup-q3msucx, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #98101 (stdlib support for Apple WatchOS)\n - #99345 (Do not allow typeck children items to constrain outer RPITs)\n - #99383 (Formalize defining_use_anchor)\n - #99436 (Add flag to configure `noalias` on `Box<T>`)\n - #99483 (Fix a numerical underflow in tuple wrap suggestion)\n - #99485 (Stop injecting `#[allow(unused_qualifications)]` in generated `derive` implementations)\n - #99486 (Refactor: remove a string comparison between types in `check_str_addition`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "5da756420888e6037fb4e622111af294e635ad74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5da756420888e6037fb4e622111af294e635ad74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14dbfebfa25a0e626ad827526934381b2545cbb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14dbfebfa25a0e626ad827526934381b2545cbb4", "html_url": "https://github.com/rust-lang/rust/commit/14dbfebfa25a0e626ad827526934381b2545cbb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14dbfebfa25a0e626ad827526934381b2545cbb4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d60d88fe5cd55496b9ccb1511a9af4994b7c43d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60d88fe5cd55496b9ccb1511a9af4994b7c43d0", "html_url": "https://github.com/rust-lang/rust/commit/d60d88fe5cd55496b9ccb1511a9af4994b7c43d0"}, {"sha": "17a2832ba0b2596db7b23d55f68b581eb7e80254", "url": "https://api.github.com/repos/rust-lang/rust/commits/17a2832ba0b2596db7b23d55f68b581eb7e80254", "html_url": "https://github.com/rust-lang/rust/commit/17a2832ba0b2596db7b23d55f68b581eb7e80254"}], "stats": {"total": 876, "additions": 544, "deletions": 332}, "files": [{"sha": "efc17a173f4d308f539c7c19d59b9f457b6f3f3e", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n use rustc_middle::mir::Body;\n use rustc_middle::ty::{self, TyCtxt};\n \n@@ -31,7 +31,7 @@ pub fn get_body_with_borrowck_facts<'tcx>(\n     def: ty::WithOptConstParam<LocalDefId>,\n ) -> BodyWithBorrowckFacts<'tcx> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n-    tcx.infer_ctxt().with_opaque_type_inference(def.did).enter(|infcx| {\n+    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def.did)).enter(|infcx| {\n         let input_body: &Body<'_> = &input_body.borrow();\n         let promoted: &IndexVec<_, _> = &promoted.borrow();\n         *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()"}, {"sha": "9dfefe4d236f66fe28eab3c0d9662a927d6a923b", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -24,7 +24,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{DefiningAnchor, InferCtxt, TyCtxtInferExt};\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, Operand, Place, PlaceElem,\n     PlaceRef, VarDebugInfoContents,\n@@ -130,11 +130,14 @@ fn mir_borrowck<'tcx>(\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def.did.to_def_id()));\n     let hir_owner = tcx.hir().local_def_id_to_hir_id(def.did).owner;\n \n-    let opt_closure_req = tcx.infer_ctxt().with_opaque_type_inference(hir_owner).enter(|infcx| {\n-        let input_body: &Body<'_> = &input_body.borrow();\n-        let promoted: &IndexVec<_, _> = &promoted.borrow();\n-        do_mir_borrowck(&infcx, input_body, promoted, false).0\n-    });\n+    let opt_closure_req = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bind(hir_owner))\n+        .enter(|infcx| {\n+            let input_body: &Body<'_> = &input_body.borrow();\n+            let promoted: &IndexVec<_, _> = &promoted.borrow();\n+            do_mir_borrowck(&infcx, input_body, promoted, false).0\n+        });\n     debug!(\"mir_borrowck done\");\n \n     tcx.arena.alloc(opt_closure_req)"}, {"sha": "407bbf48813c35fb0e3d55d13a901174be38cea4", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -3,8 +3,8 @@ use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n use rustc_infer::infer::error_reporting::unexpected_hidden_region_diagnostic;\n-use rustc_infer::infer::InferCtxt;\n use rustc_infer::infer::TyCtxtInferExt as _;\n+use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n use rustc_infer::traits::{Obligation, ObligationCause, TraitEngine};\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, InternalSubsts};\n@@ -269,59 +269,65 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             // FIXME(oli-obk): Also do region checks here and then consider removing `check_opaque_meets_bounds` entirely.\n             let param_env = self.tcx.param_env(def_id);\n             let body_id = self.tcx.local_def_id_to_hir_id(def_id);\n-            self.tcx.infer_ctxt().enter(move |infcx| {\n-                // Require the hidden type to be well-formed with only the generics of the opaque type.\n-                // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-                // hidden type is well formed even without those bounds.\n-                let predicate =\n-                    ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n-                        .to_predicate(infcx.tcx);\n-                let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n-\n-                // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n-                // the bounds that the function supplies.\n-                match infcx.register_hidden_type(\n-                    OpaqueTypeKey { def_id, substs: id_substs },\n-                    ObligationCause::misc(instantiated_ty.span, body_id),\n-                    param_env,\n-                    definition_ty,\n-                    origin,\n-                ) {\n-                    Ok(infer_ok) => {\n-                        for obligation in infer_ok.obligations {\n-                            fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+            // HACK This bubble is required for this tests to pass:\n+            // type-alias-impl-trait/issue-67844-nested-opaque.rs\n+            self.tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter(\n+                move |infcx| {\n+                    // Require the hidden type to be well-formed with only the generics of the opaque type.\n+                    // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+                    // hidden type is well formed even without those bounds.\n+                    let predicate =\n+                        ty::Binder::dummy(ty::PredicateKind::WellFormed(definition_ty.into()))\n+                            .to_predicate(infcx.tcx);\n+                    let mut fulfillment_cx = <dyn TraitEngine<'tcx>>::new(infcx.tcx);\n+\n+                    // Require that the hidden type actually fulfills all the bounds of the opaque type, even without\n+                    // the bounds that the function supplies.\n+                    match infcx.register_hidden_type(\n+                        OpaqueTypeKey { def_id, substs: id_substs },\n+                        ObligationCause::misc(instantiated_ty.span, body_id),\n+                        param_env,\n+                        definition_ty,\n+                        origin,\n+                    ) {\n+                        Ok(infer_ok) => {\n+                            for obligation in infer_ok.obligations {\n+                                fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                            }\n+                        }\n+                        Err(err) => {\n+                            infcx\n+                                .report_mismatched_types(\n+                                    &ObligationCause::misc(instantiated_ty.span, body_id),\n+                                    self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n+                                    definition_ty,\n+                                    err,\n+                                )\n+                                .emit();\n                         }\n                     }\n-                    Err(err) => {\n-                        infcx\n-                            .report_mismatched_types(\n-                                &ObligationCause::misc(instantiated_ty.span, body_id),\n-                                self.tcx.mk_opaque(def_id.to_def_id(), id_substs),\n-                                definition_ty,\n-                                err,\n-                            )\n-                            .emit();\n-                    }\n-                }\n \n-                fulfillment_cx.register_predicate_obligation(\n-                    &infcx,\n-                    Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n-                );\n+                    fulfillment_cx.register_predicate_obligation(\n+                        &infcx,\n+                        Obligation::misc(instantiated_ty.span, body_id, param_env, predicate),\n+                    );\n \n-                // Check that all obligations are satisfied by the implementation's\n-                // version.\n-                let errors = fulfillment_cx.select_all_or_error(&infcx);\n+                    // Check that all obligations are satisfied by the implementation's\n+                    // version.\n+                    let errors = fulfillment_cx.select_all_or_error(&infcx);\n \n-                let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+                    // This is still required for many(half of the tests in ui/type-alias-impl-trait)\n+                    // tests to pass\n+                    let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n-                if errors.is_empty() {\n-                    definition_ty\n-                } else {\n-                    infcx.report_fulfillment_errors(&errors, None, false);\n-                    self.tcx.ty_error()\n-                }\n-            })\n+                    if errors.is_empty() {\n+                        definition_ty\n+                    } else {\n+                        infcx.report_fulfillment_errors(&errors, None, false);\n+                        self.tcx.ty_error()\n+                    }\n+                },\n+            )\n         } else {\n             definition_ty\n         }"}, {"sha": "eb9df281e7d24ab26a755ed2e6b28f199c6b916d", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -21,6 +21,7 @@ use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKi\n use rustc_infer::infer::{\n     InferCtxt, InferOk, LateBoundRegion, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n };\n+use rustc_infer::traits::ObligationCause;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::AssertKind;\n@@ -224,6 +225,26 @@ pub(crate) fn type_check<'mir, 'tcx>(\n                     )\n                     .unwrap();\n                     let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n+                    // Check that RPITs are only constrained in their outermost\n+                    // function, otherwise report a mismatched types error.\n+                    if let OpaqueTyOrigin::FnReturn(parent) | OpaqueTyOrigin::AsyncFn(parent)\n+                            = infcx.opaque_ty_origin_unchecked(opaque_type_key.def_id, hidden_type.span)\n+                        && parent.to_def_id() != body.source.def_id()\n+                    {\n+                        infcx\n+                            .report_mismatched_types(\n+                                &ObligationCause::misc(\n+                                    hidden_type.span,\n+                                    infcx.tcx.hir().local_def_id_to_hir_id(\n+                                        body.source.def_id().expect_local(),\n+                                    ),\n+                                ),\n+                                infcx.tcx.mk_opaque(opaque_type_key.def_id.to_def_id(), opaque_type_key.substs),\n+                                hidden_type.ty,\n+                                ty::error::TypeError::Mismatch,\n+                            )\n+                            .emit();\n+                    }\n                     trace!(\n                         \"finalized opaque type {:?} to {:#?}\",\n                         opaque_type_key,"}, {"sha": "735017aa5a850f9d3ec9690aab3e029b7bfba649", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -727,16 +727,8 @@ impl<'a> TraitDef<'a> {\n \n         let attr = cx.attribute(cx.meta_word(self.span, sym::automatically_derived));\n         let opt_trait_ref = Some(trait_ref);\n-        let unused_qual = {\n-            let word = rustc_ast::attr::mk_nested_word_item(Ident::new(\n-                sym::unused_qualifications,\n-                self.span,\n-            ));\n-            let list = rustc_ast::attr::mk_list_item(Ident::new(sym::allow, self.span), vec![word]);\n-            cx.attribute(list)\n-        };\n \n-        let mut a = vec![attr, unused_qual];\n+        let mut a = vec![attr];\n         a.extend(self.attributes.iter().cloned());\n \n         cx.item("}, {"sha": "0e44d4e7c972b392eccd9228cc0e40a2b71a581c", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -239,17 +239,31 @@ impl<'tcx> InferCtxtInner<'tcx> {\n     }\n }\n \n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum DefiningAnchor {\n+    /// `DefId` of the item.\n+    Bind(LocalDefId),\n+    /// When opaque types are not resolved, we `Bubble` up, meaning\n+    /// return the opaque/hidden type pair from query, for caller of query to handle it.\n+    Bubble,\n+    /// Used to catch type mismatch errors when handling opaque types.\n+    Error,\n+}\n+\n pub struct InferCtxt<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n \n     /// The `DefId` of the item in whose context we are performing inference or typeck.\n     /// It is used to check whether an opaque type use is a defining use.\n     ///\n-    /// If it is `None`, we can't resolve opaque types here and need to bubble up\n+    /// If it is `DefiningAnchor::Bubble`, we can't resolve opaque types here and need to bubble up\n     /// the obligation. This frequently happens for\n     /// short lived InferCtxt within queries. The opaque type obligations are forwarded\n     /// to the outside until the end up in an `InferCtxt` for typeck or borrowck.\n-    pub defining_use_anchor: Option<LocalDefId>,\n+    ///\n+    /// It is default value is `DefiningAnchor::Error`, this way it is easier to catch errors that\n+    /// might come up during inference or typeck.\n+    pub defining_use_anchor: DefiningAnchor,\n \n     /// During type-checking/inference of a body, `in_progress_typeck_results`\n     /// contains a reference to the typeck results being built up, which are\n@@ -526,7 +540,7 @@ impl<'tcx> fmt::Display for FixupError<'tcx> {\n pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     fresh_typeck_results: Option<RefCell<ty::TypeckResults<'tcx>>>,\n-    defining_use_anchor: Option<LocalDefId>,\n+    defining_use_anchor: DefiningAnchor,\n }\n \n pub trait TyCtxtInferExt<'tcx> {\n@@ -535,7 +549,11 @@ pub trait TyCtxtInferExt<'tcx> {\n \n impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n     fn infer_ctxt(self) -> InferCtxtBuilder<'tcx> {\n-        InferCtxtBuilder { tcx: self, defining_use_anchor: None, fresh_typeck_results: None }\n+        InferCtxtBuilder {\n+            tcx: self,\n+            defining_use_anchor: DefiningAnchor::Error,\n+            fresh_typeck_results: None,\n+        }\n     }\n }\n \n@@ -545,7 +563,7 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// Will also change the scope for opaque type defining use checks to the given owner.\n     pub fn with_fresh_in_progress_typeck_results(mut self, table_owner: LocalDefId) -> Self {\n         self.fresh_typeck_results = Some(RefCell::new(ty::TypeckResults::new(table_owner)));\n-        self.with_opaque_type_inference(table_owner)\n+        self.with_opaque_type_inference(DefiningAnchor::Bind(table_owner))\n     }\n \n     /// Whenever the `InferCtxt` should be able to handle defining uses of opaque types,\n@@ -554,8 +572,8 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     /// It is only meant to be called in two places, for typeck\n     /// (via `with_fresh_in_progress_typeck_results`) and for the inference context used\n     /// in mir borrowck.\n-    pub fn with_opaque_type_inference(mut self, defining_use_anchor: LocalDefId) -> Self {\n-        self.defining_use_anchor = Some(defining_use_anchor);\n+    pub fn with_opaque_type_inference(mut self, defining_use_anchor: DefiningAnchor) -> Self {\n+        self.defining_use_anchor = defining_use_anchor;\n         self\n     }\n "}, {"sha": "7b0ff9552a3a407ff852fa97c15758dc3da9bfa8", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 46, "deletions": 41, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -1,4 +1,4 @@\n-use crate::infer::{InferCtxt, InferOk};\n+use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n use crate::traits;\n use hir::def_id::{DefId, LocalDefId};\n use hir::{HirId, OpaqueTyOrigin};\n@@ -101,44 +101,46 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let process = |a: Ty<'tcx>, b: Ty<'tcx>| match *a.kind() {\n             ty::Opaque(def_id, substs) if def_id.is_local() => {\n                 let def_id = def_id.expect_local();\n-                let origin = if self.defining_use_anchor.is_some() {\n-                    // Check that this is `impl Trait` type is\n-                    // declared by `parent_def_id` -- i.e., one whose\n-                    // value we are inferring.  At present, this is\n-                    // always true during the first phase of\n-                    // type-check, but not always true later on during\n-                    // NLL. Once we support named opaque types more fully,\n-                    // this same scenario will be able to arise during all phases.\n-                    //\n-                    // Here is an example using type alias `impl Trait`\n-                    // that indicates the distinction we are checking for:\n-                    //\n-                    // ```rust\n-                    // mod a {\n-                    //   pub type Foo = impl Iterator;\n-                    //   pub fn make_foo() -> Foo { .. }\n-                    // }\n-                    //\n-                    // mod b {\n-                    //   fn foo() -> a::Foo { a::make_foo() }\n-                    // }\n-                    // ```\n-                    //\n-                    // Here, the return type of `foo` references an\n-                    // `Opaque` indeed, but not one whose value is\n-                    // presently being inferred. You can get into a\n-                    // similar situation with closure return types\n-                    // today:\n-                    //\n-                    // ```rust\n-                    // fn foo() -> impl Iterator { .. }\n-                    // fn bar() {\n-                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n-                    // }\n-                    // ```\n-                    self.opaque_type_origin(def_id, cause.span)?\n-                } else {\n-                    self.opaque_ty_origin_unchecked(def_id, cause.span)\n+                let origin = match self.defining_use_anchor {\n+                    DefiningAnchor::Bind(_) => {\n+                        // Check that this is `impl Trait` type is\n+                        // declared by `parent_def_id` -- i.e., one whose\n+                        // value we are inferring.  At present, this is\n+                        // always true during the first phase of\n+                        // type-check, but not always true later on during\n+                        // NLL. Once we support named opaque types more fully,\n+                        // this same scenario will be able to arise during all phases.\n+                        //\n+                        // Here is an example using type alias `impl Trait`\n+                        // that indicates the distinction we are checking for:\n+                        //\n+                        // ```rust\n+                        // mod a {\n+                        //   pub type Foo = impl Iterator;\n+                        //   pub fn make_foo() -> Foo { .. }\n+                        // }\n+                        //\n+                        // mod b {\n+                        //   fn foo() -> a::Foo { a::make_foo() }\n+                        // }\n+                        // ```\n+                        //\n+                        // Here, the return type of `foo` references an\n+                        // `Opaque` indeed, but not one whose value is\n+                        // presently being inferred. You can get into a\n+                        // similar situation with closure return types\n+                        // today:\n+                        //\n+                        // ```rust\n+                        // fn foo() -> impl Iterator { .. }\n+                        // fn bar() {\n+                        //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                        // }\n+                        // ```\n+                        self.opaque_type_origin(def_id, cause.span)?\n+                    }\n+                    DefiningAnchor::Bubble => self.opaque_ty_origin_unchecked(def_id, cause.span),\n+                    DefiningAnchor::Error => return None,\n                 };\n                 if let ty::Opaque(did2, _) = *b.kind() {\n                     // We could accept this, but there are various ways to handle this situation, and we don't\n@@ -407,7 +409,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     #[instrument(skip(self), level = \"trace\")]\n     pub fn opaque_type_origin(&self, def_id: LocalDefId, span: Span) -> Option<OpaqueTyOrigin> {\n         let opaque_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-        let parent_def_id = self.defining_use_anchor?;\n+        let parent_def_id = match self.defining_use_anchor {\n+            DefiningAnchor::Bubble | DefiningAnchor::Error => return None,\n+            DefiningAnchor::Bind(bind) => bind,\n+        };\n         let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n \n         let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n@@ -433,7 +438,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(skip(self), level = \"trace\")]\n-    fn opaque_ty_origin_unchecked(&self, def_id: LocalDefId, span: Span) -> OpaqueTyOrigin {\n+    pub fn opaque_ty_origin_unchecked(&self, def_id: LocalDefId, span: Span) -> OpaqueTyOrigin {\n         let origin = match self.tcx.hir().expect_item(def_id).kind {\n             hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => origin,\n             ref itemkind => {"}, {"sha": "3eef3308770bee04c512e47296a0d401938f008b", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -718,6 +718,7 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(asm_comments, true);\n     tracked!(assume_incomplete_release, true);\n     tracked!(binary_dep_depinfo, true);\n+    tracked!(box_noalias, Some(false));\n     tracked!(\n         branch_protection,\n         Some(BranchProtection {"}, {"sha": "4491965347bd66473b2791a9c752b81e09e5653b", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -3266,7 +3266,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     // this attribute doesn't make it UB for the pointed-to data to be undef.\n                     attrs.set(ArgAttribute::NoUndef);\n \n-                    // `Box` pointer parameters never alias because ownership is transferred\n+                    // The aliasing rules for `Box<T>` are still not decided, but currently we emit\n+                    // `noalias` for it. This can be turned off using an unstable flag.\n+                    // See https://github.com/rust-lang/unsafe-code-guidelines/issues/326\n+                    let noalias_for_box =\n+                        self.tcx().sess.opts.unstable_opts.box_noalias.unwrap_or(true);\n+\n                     // `&mut` pointer parameters never alias other parameters,\n                     // or mutable global data\n                     //\n@@ -3281,7 +3286,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     // `-Zmutable-noalias` debugging option.\n                     let no_alias = match kind {\n                         PointerKind::Shared | PointerKind::UniqueBorrowed => false,\n-                        PointerKind::UniqueOwned => true,\n+                        PointerKind::UniqueOwned => noalias_for_box,\n                         PointerKind::Frozen => !is_return,\n                     };\n                     if no_alias {"}, {"sha": "5d365fc5246287040e780d8f7fea1badf0c5cc7e", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -1209,6 +1209,8 @@ options! {\n     binary_dep_depinfo: bool = (false, parse_bool, [TRACKED],\n         \"include artifacts (sysroot, crate dependencies) used during compilation in dep-info \\\n         (default: no)\"),\n+    box_noalias: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"emit noalias metadata for box (default: yes)\"),\n     branch_protection: Option<BranchProtection> = (None, parse_branch_protection, [TRACKED],\n         \"set options for branch target identification and pointer authentication on AArch64\"),\n     cf_protection: CFProtection = (CFProtection::None, parse_cfprotection, [TRACKED],"}, {"sha": "c2b2e3199511e403b8a3c39b1532f8ce679ac492", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -3,7 +3,7 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use crate::infer::TyCtxtInferExt;\n+use crate::infer::{DefiningAnchor, TyCtxtInferExt};\n use crate::traits::{\n     FulfillmentContext, ImplSource, Obligation, ObligationCause, SelectionContext, TraitEngine,\n     Unimplemented,\n@@ -30,7 +30,9 @@ pub fn codegen_fulfill_obligation<'tcx>(\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    tcx.infer_ctxt().enter(|infcx| {\n+    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bubble).enter(|infcx| {\n+        //~^ HACK `Bubble` is required for\n+        // this test to pass: type-alias-impl-trait/assoc-projection-ice.rs\n         let mut selcx = SelectionContext::new(&infcx);\n \n         let obligation_cause = ObligationCause::dummy();\n@@ -69,7 +71,8 @@ pub fn codegen_fulfill_obligation<'tcx>(\n \n         // Opaque types may have gotten their hidden types constrained, but we can ignore them safely\n         // as they will get constrained elsewhere, too.\n-        let _opaque_types = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        // (ouz-a) This is required for `type-alias-impl-trait/assoc-projection-ice.rs` to pass\n+        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n \n         debug!(\"Cache miss: {trait_ref:?} => {impl_source:?}\");\n         Ok(&*tcx.arena.alloc(impl_source))"}, {"sha": "9497d5c4528cc9e85eb4b6c842e12c4a01b8f92b", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -14,7 +14,7 @@ use rustc_hir::lang_items::LangItem;\n use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n+use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n use rustc_lint::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n use rustc_middle::hir::nested_filter;\n@@ -731,52 +731,52 @@ fn check_opaque_meets_bounds<'tcx>(\n     };\n     let param_env = tcx.param_env(defining_use_anchor);\n \n-    tcx.infer_ctxt().with_opaque_type_inference(defining_use_anchor).enter(move |infcx| {\n-        let ocx = ObligationCtxt::new(&infcx);\n-        let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n+    tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(defining_use_anchor)).enter(\n+        move |infcx| {\n+            let ocx = ObligationCtxt::new(&infcx);\n+            let opaque_ty = tcx.mk_opaque(def_id.to_def_id(), substs);\n \n-        let misc_cause = traits::ObligationCause::misc(span, hir_id);\n+            let misc_cause = traits::ObligationCause::misc(span, hir_id);\n \n-        match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n-            Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n-            Err(ty_err) => {\n-                tcx.sess.delay_span_bug(\n-                    span,\n-                    &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n-                );\n+            match infcx.at(&misc_cause, param_env).eq(opaque_ty, hidden_type) {\n+                Ok(infer_ok) => ocx.register_infer_ok_obligations(infer_ok),\n+                Err(ty_err) => {\n+                    tcx.sess.delay_span_bug(\n+                        span,\n+                        &format!(\"could not unify `{hidden_type}` with revealed type:\\n{ty_err}\"),\n+                    );\n+                }\n             }\n-        }\n \n-        // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n-        // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n-        // hidden type is well formed even without those bounds.\n-        let predicate =\n-            ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into())).to_predicate(tcx);\n-        ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n-\n-        // Check that all obligations are satisfied by the implementation's\n-        // version.\n-        let errors = ocx.select_all_or_error();\n-        if !errors.is_empty() {\n-            infcx.report_fulfillment_errors(&errors, None, false);\n-        }\n-\n-        match origin {\n-            // Checked when type checking the function containing them.\n-            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n-            // Can have different predicates to their defining use\n-            hir::OpaqueTyOrigin::TyAlias => {\n-                let outlives_environment = OutlivesEnvironment::new(param_env);\n-                infcx.check_region_obligations_and_report_errors(\n-                    defining_use_anchor,\n-                    &outlives_environment,\n-                );\n+            // Additionally require the hidden type to be well-formed with only the generics of the opaque type.\n+            // Defining use functions may have more bounds than the opaque type, which is ok, as long as the\n+            // hidden type is well formed even without those bounds.\n+            let predicate = ty::Binder::dummy(ty::PredicateKind::WellFormed(hidden_type.into()))\n+                .to_predicate(tcx);\n+            ocx.register_obligation(Obligation::new(misc_cause, param_env, predicate));\n+\n+            // Check that all obligations are satisfied by the implementation's\n+            // version.\n+            let errors = ocx.select_all_or_error();\n+            if !errors.is_empty() {\n+                infcx.report_fulfillment_errors(&errors, None, false);\n             }\n-        }\n-\n-        // Clean up after ourselves\n-        let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n-    });\n+            match origin {\n+                // Checked when type checking the function containing them.\n+                hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {}\n+                // Can have different predicates to their defining use\n+                hir::OpaqueTyOrigin::TyAlias => {\n+                    let outlives_environment = OutlivesEnvironment::new(param_env);\n+                    infcx.check_region_obligations_and_report_errors(\n+                        defining_use_anchor,\n+                        &outlives_environment,\n+                    );\n+                }\n+            }\n+            // Clean up after ourselves\n+            let _ = infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types();\n+        },\n+    );\n }\n \n fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {"}, {"sha": "020aa95d0be215067415e1fe6cc59be7a4f9f597", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -1460,6 +1460,7 @@ pub fn check_type_bounds<'tcx>(\n             .map(|e| e.map_bound(|e| *e).transpose_tuple2())\n             .map(|(bound, span)| {\n                 debug!(?bound);\n+                // this is where opaque type is found\n                 let concrete_ty_bound = bound.subst(tcx, rebased_substs);\n                 debug!(\"check_type_bounds: concrete_ty_bound = {:?}\", concrete_ty_bound);\n \n@@ -1481,7 +1482,6 @@ pub fn check_type_bounds<'tcx>(\n             ocx.register_obligations(obligations);\n             ocx.register_obligation(obligation);\n         }\n-\n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         let errors = ocx.select_all_or_error();"}, {"sha": "e3db70845ddf13c83805936f2e65f8fa8a48aa8c", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -573,6 +573,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // If so, we might have just forgotten to wrap some args in a tuple.\n             if let Some(ty::Tuple(tys)) =\n                 formal_and_expected_inputs.get(mismatch_idx.into()).map(|tys| tys.1.kind())\n+                // If the tuple is unit, we're not actually wrapping any arguments.\n+                && !tys.is_empty()\n                 && provided_arg_tys.len() == formal_and_expected_inputs.len() - 1 + tys.len()\n             {\n                 // Wrap up the N provided arguments starting at this position in a tuple."}, {"sha": "9858cd8fa1970c5a5128c0981799a74e884c5448", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -630,18 +630,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let rm_borrow_msg = \"remove the borrow to obtain an owned `String`\";\n         let to_owned_msg = \"create an owned `String` from a string reference\";\n \n-        let string_type = self.tcx.get_diagnostic_item(sym::String);\n-        let is_std_string = |ty: Ty<'tcx>| match ty.ty_adt_def() {\n-            Some(ty_def) => Some(ty_def.did()) == string_type,\n-            None => false,\n+        let is_std_string = |ty: Ty<'tcx>| {\n+            ty.ty_adt_def()\n+                .map_or(false, |ty_def| self.tcx.is_diagnostic_item(sym::String, ty_def.did()))\n         };\n \n         match (lhs_ty.kind(), rhs_ty.kind()) {\n             (&Ref(_, l_ty, _), &Ref(_, r_ty, _)) // &str or &String + &str, &String or &&str\n-                if (*l_ty.kind() == Str || is_std_string(l_ty)) && (\n-                        *r_ty.kind() == Str || is_std_string(r_ty) ||\n-                        &format!(\"{:?}\", rhs_ty) == \"&&str\"\n-                    ) =>\n+                if (*l_ty.kind() == Str || is_std_string(l_ty))\n+                    && (*r_ty.kind() == Str\n+                        || is_std_string(r_ty)\n+                        || matches!(\n+                            r_ty.kind(), Ref(_, inner_ty, _) if *inner_ty.kind() == Str\n+                        )) =>\n             {\n                 if let IsAssign::No = is_assign { // Do not supply this message if `&str += &str`\n                     err.span_label(op.span, \"`+` cannot be used to concatenate two `&str` strings\");"}, {"sha": "057e47bfdd18aaa35b6f16841600595a89e36071", "filename": "library/panic_unwind/src/gcc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -131,7 +131,7 @@ const UNWIND_DATA_REG: (i32, i32) = (10, 11); // x10, x11\n // https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c\n \n cfg_if::cfg_if! {\n-    if #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(target_os = \"netbsd\")))] {\n+    if #[cfg(all(target_arch = \"arm\", not(target_os = \"ios\"), not(target_os = \"watchos\"), not(target_os = \"netbsd\")))] {\n         // ARM EHABI personality routine.\n         // https://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf\n         //"}, {"sha": "8b1a06ee750fb0e84316d1452e682cdafb5c90f6", "filename": "library/std/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fbuild.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -15,6 +15,7 @@ fn main() {\n         || target.contains(\"illumos\")\n         || target.contains(\"apple-darwin\")\n         || target.contains(\"apple-ios\")\n+        || target.contains(\"apple-watchos\")\n         || target.contains(\"uwp\")\n         || target.contains(\"windows\")\n         || target.contains(\"fuchsia\")"}, {"sha": "6fbaa42c76846b4576d323a9fff8c5552cbf47f7", "filename": "library/std/src/os/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fmod.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -141,7 +141,6 @@ pub mod openbsd;\n pub mod redox;\n #[cfg(target_os = \"solaris\")]\n pub mod solaris;\n-\n #[cfg(target_os = \"solid_asp3\")]\n pub mod solid;\n #[cfg(target_os = \"vxworks\")]"}, {"sha": "411cc0925c4b0869d0a303c95a7876cad872d8ac", "filename": "library/std/src/os/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fmod.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -90,6 +90,7 @@ pub mod thread;\n     target_os = \"dragonfly\",\n     target_os = \"freebsd\",\n     target_os = \"ios\",\n+    target_os = \"watchos\",\n     target_os = \"macos\",\n     target_os = \"netbsd\",\n     target_os = \"openbsd\""}, {"sha": "cc3a8858793450a1bd0bc8ec58a359d220e7c80c", "filename": "library/std/src/os/unix/net/stream.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Fstream.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -12,6 +12,7 @@ use crate::os::unix::io::{AsFd, AsRawFd, BorrowedFd, FromRawFd, IntoRawFd, Owned\n     target_os = \"freebsd\",\n     target_os = \"ios\",\n     target_os = \"macos\",\n+    target_os = \"watchos\",\n     target_os = \"netbsd\",\n     target_os = \"openbsd\"\n ))]\n@@ -30,6 +31,7 @@ use crate::time::Duration;\n     target_os = \"freebsd\",\n     target_os = \"ios\",\n     target_os = \"macos\",\n+    target_os = \"watchos\",\n     target_os = \"netbsd\",\n     target_os = \"openbsd\"\n ))]\n@@ -238,6 +240,7 @@ impl UnixStream {\n         target_os = \"freebsd\",\n         target_os = \"ios\",\n         target_os = \"macos\",\n+        target_os = \"watchos\",\n         target_os = \"netbsd\",\n         target_os = \"openbsd\"\n     ))]"}, {"sha": "ae4faf27b4d39b5b2a8336e80c5fc28ef9fef853", "filename": "library/std/src/os/unix/ucred.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fos%2Funix%2Fucred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fos%2Funix%2Fucred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fucred.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -36,7 +36,7 @@ pub use self::impl_linux::peer_cred;\n ))]\n pub use self::impl_bsd::peer_cred;\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\",))]\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n pub use self::impl_mac::peer_cred;\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n@@ -97,7 +97,7 @@ pub mod impl_bsd {\n     }\n }\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\",))]\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n pub mod impl_mac {\n     use super::UCred;\n     use crate::os::unix::io::AsRawFd;"}, {"sha": "e63a2fc248eb0b0785c069fc4665fa3492afb9fe", "filename": "library/std/src/os/unix/ucred/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fos%2Funix%2Fucred%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fos%2Funix%2Fucred%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fucred%2Ftests.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -9,6 +9,7 @@ use libc::{getegid, geteuid, getpid};\n     target_os = \"freebsd\",\n     target_os = \"ios\",\n     target_os = \"macos\",\n+    target_os = \"watchos\",\n     target_os = \"openbsd\"\n ))]\n fn test_socket_pair() {\n@@ -25,7 +26,7 @@ fn test_socket_pair() {\n }\n \n #[test]\n-#[cfg(any(target_os = \"linux\", target_os = \"ios\", target_os = \"macos\",))]\n+#[cfg(any(target_os = \"linux\", target_os = \"ios\", target_os = \"macos\", target_os = \"watchos\"))]\n fn test_socket_pair_pids(arg: Type) -> RetType {\n     // Create two connected sockets and get their peer credentials.\n     let (sock_a, sock_b) = UnixStream::pair().unwrap();"}, {"sha": "a342f0f5e8597848fc6a2998bce3d62ba391842d", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -151,7 +151,7 @@ mod imp {\n     }\n }\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n mod imp {\n     use super::Args;\n     use crate::ffi::CStr;\n@@ -192,7 +192,7 @@ mod imp {\n     // for i in (0..[args count])\n     //      res.push([args objectAtIndex:i])\n     // res\n-    #[cfg(target_os = \"ios\")]\n+    #[cfg(any(target_os = \"ios\", target_os = \"watchos\"))]\n     pub fn args() -> Args {\n         use crate::ffi::OsString;\n         use crate::mem;"}, {"sha": "c9ba661c829fabe03506124a6f8ef522a40f9965", "filename": "library/std/src/sys/unix/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fenv.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -31,6 +31,17 @@ pub mod os {\n     pub const EXE_EXTENSION: &str = \"\";\n }\n \n+#[cfg(target_os = \"watchos\")]\n+pub mod os {\n+    pub const FAMILY: &str = \"unix\";\n+    pub const OS: &str = \"watchos\";\n+    pub const DLL_PREFIX: &str = \"lib\";\n+    pub const DLL_SUFFIX: &str = \".dylib\";\n+    pub const DLL_EXTENSION: &str = \"dylib\";\n+    pub const EXE_SUFFIX: &str = \"\";\n+    pub const EXE_EXTENSION: &str = \"\";\n+}\n+\n #[cfg(target_os = \"freebsd\")]\n pub mod os {\n     pub const FAMILY: &str = \"unix\";"}, {"sha": "30812dabb4e0dca3ed925240ca8fdd3c090d2314", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -47,6 +47,7 @@ const READ_LIMIT: usize = libc::ssize_t::MAX as usize;\n     target_os = \"macos\",\n     target_os = \"netbsd\",\n     target_os = \"openbsd\",\n+    target_os = \"watchos\",\n ))]\n const fn max_iov() -> usize {\n     libc::IOV_MAX as usize\n@@ -67,7 +68,8 @@ const fn max_iov() -> usize {\n     target_os = \"macos\",\n     target_os = \"netbsd\",\n     target_os = \"openbsd\",\n-    target_os = \"horizon\"\n+    target_os = \"horizon\",\n+    target_os = \"watchos\",\n )))]\n const fn max_iov() -> usize {\n     16 // The minimum value required by POSIX."}, {"sha": "7c8824694408c65d3fcc78970833d2b984876a55", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -17,6 +17,7 @@ use crate::sys_common::{AsInner, AsInnerMut, FromInner, IntoInner};\n     all(target_os = \"linux\", target_env = \"gnu\"),\n     target_os = \"macos\",\n     target_os = \"ios\",\n+    target_os = \"watchos\",\n ))]\n use crate::sys::weak::syscall;\n #[cfg(target_os = \"macos\")]\n@@ -27,6 +28,7 @@ use libc::{c_int, mode_t};\n #[cfg(any(\n     target_os = \"macos\",\n     target_os = \"ios\",\n+    target_os = \"watchos\",\n     all(target_os = \"linux\", target_env = \"gnu\")\n ))]\n use libc::c_char;\n@@ -443,7 +445,8 @@ impl FileAttr {\n         target_os = \"freebsd\",\n         target_os = \"openbsd\",\n         target_os = \"macos\",\n-        target_os = \"ios\"\n+        target_os = \"ios\",\n+        target_os = \"watchos\",\n     ))]\n     pub fn created(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::new(self.stat.st_birthtime as i64, self.stat.st_birthtime_nsec as i64))\n@@ -453,7 +456,8 @@ impl FileAttr {\n         target_os = \"freebsd\",\n         target_os = \"openbsd\",\n         target_os = \"macos\",\n-        target_os = \"ios\"\n+        target_os = \"ios\",\n+        target_os = \"watchos\",\n     )))]\n     pub fn created(&self) -> io::Result<SystemTime> {\n         cfg_has_statx! {\n@@ -707,6 +711,7 @@ impl DirEntry {\n     #[cfg(any(\n         target_os = \"macos\",\n         target_os = \"ios\",\n+        target_os = \"watchos\",\n         target_os = \"linux\",\n         target_os = \"emscripten\",\n         target_os = \"android\",\n@@ -737,6 +742,7 @@ impl DirEntry {\n     #[cfg(any(\n         target_os = \"macos\",\n         target_os = \"ios\",\n+        target_os = \"watchos\",\n         target_os = \"netbsd\",\n         target_os = \"openbsd\",\n         target_os = \"freebsd\",\n@@ -754,6 +760,7 @@ impl DirEntry {\n     #[cfg(not(any(\n         target_os = \"macos\",\n         target_os = \"ios\",\n+        target_os = \"watchos\",\n         target_os = \"netbsd\",\n         target_os = \"openbsd\",\n         target_os = \"freebsd\",\n@@ -911,11 +918,11 @@ impl File {\n         cvt_r(|| unsafe { os_fsync(self.as_raw_fd()) })?;\n         return Ok(());\n \n-        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+        #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n         unsafe fn os_fsync(fd: c_int) -> c_int {\n             libc::fcntl(fd, libc::F_FULLFSYNC)\n         }\n-        #[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+        #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\")))]\n         unsafe fn os_fsync(fd: c_int) -> c_int {\n             libc::fsync(fd)\n         }\n@@ -925,7 +932,7 @@ impl File {\n         cvt_r(|| unsafe { os_datasync(self.as_raw_fd()) })?;\n         return Ok(());\n \n-        #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+        #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n         unsafe fn os_datasync(fd: c_int) -> c_int {\n             libc::fcntl(fd, libc::F_FULLFSYNC)\n         }\n@@ -946,7 +953,8 @@ impl File {\n             target_os = \"linux\",\n             target_os = \"macos\",\n             target_os = \"netbsd\",\n-            target_os = \"openbsd\"\n+            target_os = \"openbsd\",\n+            target_os = \"watchos\",\n         )))]\n         unsafe fn os_datasync(fd: c_int) -> c_int {\n             libc::fsync(fd)\n@@ -1396,7 +1404,8 @@ fn open_to_and_set_permissions(\n     target_os = \"linux\",\n     target_os = \"android\",\n     target_os = \"macos\",\n-    target_os = \"ios\"\n+    target_os = \"ios\",\n+    target_os = \"watchos\",\n )))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     let (mut reader, reader_metadata) = open_from(from)?;\n@@ -1423,7 +1432,7 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     }\n }\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use crate::sync::atomic::{AtomicBool, Ordering};\n "}, {"sha": "abf27e7db78c7c0e30467e56289ede3c5f87e873", "filename": "library/std/src/sys/unix/locks/pthread_condvar.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fpthread_condvar.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -37,6 +37,7 @@ impl Condvar {\n     #[cfg(any(\n         target_os = \"macos\",\n         target_os = \"ios\",\n+        target_os = \"watchos\",\n         target_os = \"l4re\",\n         target_os = \"android\",\n         target_os = \"redox\"\n@@ -58,6 +59,7 @@ impl Condvar {\n     #[cfg(not(any(\n         target_os = \"macos\",\n         target_os = \"ios\",\n+        target_os = \"watchos\",\n         target_os = \"l4re\",\n         target_os = \"android\",\n         target_os = \"redox\",\n@@ -102,6 +104,7 @@ impl Condvar {\n     #[cfg(not(any(\n         target_os = \"macos\",\n         target_os = \"ios\",\n+        target_os = \"watchos\",\n         target_os = \"android\",\n         target_os = \"espidf\",\n         target_os = \"horizon\"\n@@ -135,6 +138,7 @@ impl Condvar {\n     #[cfg(any(\n         target_os = \"macos\",\n         target_os = \"ios\",\n+        target_os = \"watchos\",\n         target_os = \"android\",\n         target_os = \"espidf\",\n         target_os = \"horizon\""}, {"sha": "3d0d91460f706229f4aa8ea786e926e22f874af8", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -86,6 +86,7 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n             // The poll on Darwin doesn't set POLLNVAL for closed fds.\n             target_os = \"macos\",\n             target_os = \"ios\",\n+            target_os = \"watchos\",\n             target_os = \"redox\",\n             target_os = \"l4re\",\n             target_os = \"horizon\",\n@@ -329,7 +330,7 @@ cfg_if::cfg_if! {\n         // See #41582 and https://blog.achernya.com/2013/03/os-x-has-silly-libsystem.html\n         #[link(name = \"resolv\")]\n         extern \"C\" {}\n-    } else if #[cfg(target_os = \"ios\")] {\n+    } else if #[cfg(any(target_os = \"ios\", target_os = \"watchos\"))] {\n         #[link(name = \"System\")]\n         #[link(name = \"objc\")]\n         #[link(name = \"Security\", kind = \"framework\")]"}, {"sha": "46545a0839fe8b416a7cd17a8f57058d34f0f360", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -61,7 +61,7 @@ extern \"C\" {\n     )]\n     #[cfg_attr(any(target_os = \"solaris\", target_os = \"illumos\"), link_name = \"___errno\")]\n     #[cfg_attr(\n-        any(target_os = \"macos\", target_os = \"ios\", target_os = \"freebsd\"),\n+        any(target_os = \"macos\", target_os = \"ios\", target_os = \"freebsd\", target_os = \"watchos\"),\n         link_name = \"__error\"\n     )]\n     #[cfg_attr(target_os = \"haiku\", link_name = \"_errnop\")]\n@@ -361,7 +361,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     }\n }\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     unsafe {\n         let mut sz: u32 = 0;\n@@ -598,6 +598,7 @@ pub fn home_dir() -> Option<PathBuf> {\n     #[cfg(any(\n         target_os = \"android\",\n         target_os = \"ios\",\n+        target_os = \"watchos\",\n         target_os = \"emscripten\",\n         target_os = \"redox\",\n         target_os = \"vxworks\",\n@@ -610,6 +611,7 @@ pub fn home_dir() -> Option<PathBuf> {\n     #[cfg(not(any(\n         target_os = \"android\",\n         target_os = \"ios\",\n+        target_os = \"watchos\",\n         target_os = \"emscripten\",\n         target_os = \"redox\",\n         target_os = \"vxworks\","}, {"sha": "bf49204881d1643ef95ce45ca4f990698a88344f", "filename": "library/std/src/sys/unix/rand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Frand.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -14,6 +14,7 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n     unix,\n     not(target_os = \"macos\"),\n     not(target_os = \"ios\"),\n+    not(target_os = \"watchos\"),\n     not(target_os = \"openbsd\"),\n     not(target_os = \"freebsd\"),\n     not(target_os = \"netbsd\"),\n@@ -195,7 +196,7 @@ mod imp {\n // once per thread in `hashmap_random_keys`. Therefore `SecRandomCopyBytes` is\n // only used on iOS where direct access to `/dev/urandom` is blocked by the\n // sandbox.\n-#[cfg(target_os = \"ios\")]\n+#[cfg(any(target_os = \"ios\", target_os = \"watchos\"))]\n mod imp {\n     use crate::io;\n     use crate::ptr;"}, {"sha": "6533625876f8911de7643baf9a2ac78b70b2b950", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -139,7 +139,7 @@ impl Thread {\n         }\n     }\n \n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n     pub fn set_name(name: &CStr) {\n         unsafe {\n             libc::pthread_setname_np(name.as_ptr());"}, {"sha": "ca1a7138fded27f0b14f1c99c6f3fc0d0e501dc0", "filename": "library/std/src/sys/unix/thread_parker.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread_parker.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -52,7 +52,12 @@ unsafe fn wait_timeout(\n ) {\n     // Use the system clock on systems that do not support pthread_condattr_setclock.\n     // This unfortunately results in problems when the system time changes.\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"espidf\"))]\n+    #[cfg(any(\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"watchos\",\n+        target_os = \"espidf\"\n+    ))]\n     let (now, dur) = {\n         use super::time::SystemTime;\n         use crate::cmp::min;\n@@ -73,7 +78,12 @@ unsafe fn wait_timeout(\n         (now, dur)\n     };\n     // Use the monotonic clock on other systems.\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"espidf\")))]\n+    #[cfg(not(any(\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"watchos\",\n+        target_os = \"espidf\"\n+    )))]\n     let (now, dur) = {\n         use super::time::Timespec;\n \n@@ -111,6 +121,7 @@ impl Parker {\n             if #[cfg(any(\n                 target_os = \"macos\",\n                 target_os = \"ios\",\n+                target_os = \"watchos\",\n                 target_os = \"l4re\",\n                 target_os = \"android\",\n                 target_os = \"redox\""}, {"sha": "dff973f59d1a7dbbaedef118a4ff71aeadae1730", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -141,7 +141,7 @@ impl From<libc::timespec> for Timespec {\n     }\n }\n \n-#[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n+#[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\"))]\n mod inner {\n     use crate::sync::atomic::{AtomicU64, Ordering};\n     use crate::sys::cvt;\n@@ -257,7 +257,7 @@ mod inner {\n     }\n }\n \n-#[cfg(not(any(target_os = \"macos\", target_os = \"ios\")))]\n+#[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"watchos\")))]\n mod inner {\n     use crate::fmt;\n     use crate::mem::MaybeUninit;"}, {"sha": "c13bda328232041d655a40f0182f2ae49b43d4bd", "filename": "library/std/src/sys_common/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fnet.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -18,7 +18,7 @@ use libc::{c_int, c_void};\n cfg_if::cfg_if! {\n     if #[cfg(any(\n         target_os = \"dragonfly\", target_os = \"freebsd\",\n-        target_os = \"ios\", target_os = \"macos\",\n+        target_os = \"ios\", target_os = \"macos\", target_os = \"watchos\",\n         target_os = \"openbsd\", target_os = \"netbsd\", target_os = \"illumos\",\n         target_os = \"solaris\", target_os = \"haiku\", target_os = \"l4re\"))] {\n         use crate::sys::net::netc::IPV6_JOIN_GROUP as IPV6_ADD_MEMBERSHIP;"}, {"sha": "a5b6193b086fbf44aef522205179d07a7abefdcc", "filename": "library/unwind/src/libunwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Funwind%2Fsrc%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/library%2Funwind%2Fsrc%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flibunwind.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -30,10 +30,10 @@ pub const unwinder_private_data_size: usize = 5;\n #[cfg(target_arch = \"x86_64\")]\n pub const unwinder_private_data_size: usize = 6;\n \n-#[cfg(all(target_arch = \"arm\", not(target_os = \"ios\")))]\n+#[cfg(all(target_arch = \"arm\", not(any(target_os = \"ios\", target_os = \"watchos\"))))]\n pub const unwinder_private_data_size: usize = 20;\n \n-#[cfg(all(target_arch = \"arm\", target_os = \"ios\"))]\n+#[cfg(all(target_arch = \"arm\", any(target_os = \"ios\", target_os = \"watchos\")))]\n pub const unwinder_private_data_size: usize = 5;\n \n #[cfg(all(target_arch = \"aarch64\", target_pointer_width = \"64\"))]\n@@ -105,7 +105,7 @@ extern \"C\" {\n }\n \n cfg_if::cfg_if! {\n-if #[cfg(any(target_os = \"ios\", target_os = \"netbsd\", not(target_arch = \"arm\")))] {\n+if #[cfg(any(target_os = \"ios\", target_os = \"watchos\", target_os = \"netbsd\", not(target_arch = \"arm\")))] {\n     // Not ARM EHABI\n     #[repr(C)]\n     #[derive(Copy, Clone, PartialEq)]"}, {"sha": "afd17c7c160749badb7a83c100317022f29badb7", "filename": "src/test/codegen/noalias-box-off.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fcodegen%2Fnoalias-box-off.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fcodegen%2Fnoalias-box-off.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnoalias-box-off.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -O -Z box-noalias=no\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @box_should_not_have_noalias_if_disabled(\n+// CHECK-NOT: noalias\n+#[no_mangle]\n+pub fn box_should_not_have_noalias_if_disabled(_b: Box<u8>) {}"}, {"sha": "a3d1f093d8bd3fb20af8ae6e896da1dbe6be8b9f", "filename": "src/test/codegen/noalias-box.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fcodegen%2Fnoalias-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fcodegen%2Fnoalias-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnoalias-box.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -O\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @box_should_have_noalias_by_default(\n+// CHECK: noalias\n+#[no_mangle]\n+pub fn box_should_have_noalias_by_default(_b: Box<u8>) {}"}, {"sha": "6f5248f5b18ce3ea364701aca366c7a20e4a5741", "filename": "src/test/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -4,6 +4,7 @@\n     -Z                            asm-comments=val -- generate comments into the assembly (may change behavior) (default: no)\n     -Z                       assert-incr-state=val -- assert that the incremental cache is in given state: either `loaded` or `not-loaded`.\n     -Z                      binary-dep-depinfo=val -- include artifacts (sysroot, crate dependencies) used during compilation in dep-info (default: no)\n+    -Z                             box-noalias=val -- emit noalias metadata for box (default: yes)\n     -Z                       branch-protection=val -- set options for branch target identification and pointer authentication on AArch64\n     -Z                           cf-protection=val -- instrument control-flow architecture protection\n     -Z               cgu-partitioning-strategy=val -- the codegen unit partitioning strategy to use"}, {"sha": "731b863069b23d7283af4f129e48f3f782afa607", "filename": "src/test/ui/argument-suggestions/issue-99482.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-99482.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-99482.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-99482.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let f = |_: (), f: fn()| f;\n+    let _f = f(main);\n+    //~^ ERROR this function takes 2 arguments but 1 argument was supplied\n+}"}, {"sha": "bc005e82a2c46146ac359a93806df0aaedca9950", "filename": "src/test/ui/argument-suggestions/issue-99482.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-99482.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-99482.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fargument-suggestions%2Fissue-99482.stderr?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,19 @@\n+error[E0057]: this function takes 2 arguments but 1 argument was supplied\n+  --> $DIR/issue-99482.rs:3:14\n+   |\n+LL |     let _f = f(main);\n+   |              ^ ---- an argument of type `()` is missing\n+   |\n+note: closure defined here\n+  --> $DIR/issue-99482.rs:2:13\n+   |\n+LL |     let f = |_: (), f: fn()| f;\n+   |             ^^^^^^^^^^^^^^^^\n+help: provide the argument\n+   |\n+LL |     let _f = f((), main);\n+   |              ~~~~~~~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0057`."}, {"sha": "21fe663f06706da81320fc90a42ca695edc2ca0a", "filename": "src/test/ui/deriving/deriving-all-codegen.stdout", "status": "modified", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-all-codegen.stdout?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -25,50 +25,42 @@ extern crate std;\n // Empty struct.\n struct Empty;\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Empty {\n     #[inline]\n     fn clone(&self) -> Empty { *self }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Empty { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Empty {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         ::core::fmt::Formatter::write_str(f, \"Empty\")\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Empty {\n     #[inline]\n     fn default() -> Empty { Empty {} }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Empty {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n impl ::core::marker::StructuralPartialEq for Empty {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Empty {\n     #[inline]\n     fn eq(&self, other: &Empty) -> bool { true }\n }\n impl ::core::marker::StructuralEq for Empty {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Empty {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Empty {\n     #[inline]\n     fn partial_cmp(&self, other: &Empty)\n@@ -77,7 +69,6 @@ impl ::core::cmp::PartialOrd for Empty {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Empty {\n     #[inline]\n     fn cmp(&self, other: &Empty) -> ::core::cmp::Ordering {\n@@ -91,7 +82,6 @@ struct Point {\n     y: u32,\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Point {\n     #[inline]\n     fn clone(&self) -> Point {\n@@ -100,18 +90,15 @@ impl ::core::clone::Clone for Point {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Point { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Point {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         ::core::fmt::Formatter::debug_struct_field2_finish(f, \"Point\", \"x\",\n             &&self.x, \"y\", &&self.y)\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Point {\n     #[inline]\n     fn default() -> Point {\n@@ -122,7 +109,6 @@ impl ::core::default::Default for Point {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Point {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         ::core::hash::Hash::hash(&self.x, state);\n@@ -131,7 +117,6 @@ impl ::core::hash::Hash for Point {\n }\n impl ::core::marker::StructuralPartialEq for Point {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Point {\n     #[inline]\n     fn eq(&self, other: &Point) -> bool {\n@@ -144,7 +129,6 @@ impl ::core::cmp::PartialEq for Point {\n }\n impl ::core::marker::StructuralEq for Point {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Point {\n     #[inline]\n     #[doc(hidden)]\n@@ -154,7 +138,6 @@ impl ::core::cmp::Eq for Point {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Point {\n     #[inline]\n     fn partial_cmp(&self, other: &Point)\n@@ -167,7 +150,6 @@ impl ::core::cmp::PartialOrd for Point {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Point {\n     #[inline]\n     fn cmp(&self, other: &Point) -> ::core::cmp::Ordering {\n@@ -191,7 +173,6 @@ struct Big {\n     b8: u32,\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Big {\n     #[inline]\n     fn clone(&self) -> Big {\n@@ -208,7 +189,6 @@ impl ::core::clone::Clone for Big {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Big {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         let names: &'static _ =\n@@ -221,7 +201,6 @@ impl ::core::fmt::Debug for Big {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Big {\n     #[inline]\n     fn default() -> Big {\n@@ -238,7 +217,6 @@ impl ::core::default::Default for Big {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Big {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         ::core::hash::Hash::hash(&self.b1, state);\n@@ -253,7 +231,6 @@ impl ::core::hash::Hash for Big {\n }\n impl ::core::marker::StructuralPartialEq for Big {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Big {\n     #[inline]\n     fn eq(&self, other: &Big) -> bool {\n@@ -272,7 +249,6 @@ impl ::core::cmp::PartialEq for Big {\n }\n impl ::core::marker::StructuralEq for Big {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Big {\n     #[inline]\n     #[doc(hidden)]\n@@ -282,7 +258,6 @@ impl ::core::cmp::Eq for Big {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Big {\n     #[inline]\n     fn partial_cmp(&self, other: &Big)\n@@ -331,7 +306,6 @@ impl ::core::cmp::PartialOrd for Big {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Big {\n     #[inline]\n     fn cmp(&self, other: &Big) -> ::core::cmp::Ordering {\n@@ -370,23 +344,20 @@ impl ::core::cmp::Ord for Big {\n // A struct with an unsized field. Some derives are not usable in this case.\n struct Unsized([u32]);\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Unsized {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"Unsized\",\n             &&self.0)\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Unsized {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         ::core::hash::Hash::hash(&self.0, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for Unsized {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Unsized {\n     #[inline]\n     fn eq(&self, other: &Unsized) -> bool { self.0 == other.0 }\n@@ -395,7 +366,6 @@ impl ::core::cmp::PartialEq for Unsized {\n }\n impl ::core::marker::StructuralEq for Unsized {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Unsized {\n     #[inline]\n     #[doc(hidden)]\n@@ -405,7 +375,6 @@ impl ::core::cmp::Eq for Unsized {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Unsized {\n     #[inline]\n     fn partial_cmp(&self, other: &Unsized)\n@@ -414,7 +383,6 @@ impl ::core::cmp::PartialOrd for Unsized {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Unsized {\n     #[inline]\n     fn cmp(&self, other: &Unsized) -> ::core::cmp::Ordering {\n@@ -426,7 +394,6 @@ impl ::core::cmp::Ord for Unsized {\n #[repr(packed)]\n struct PackedCopy(u32);\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for PackedCopy {\n     #[inline]\n     fn clone(&self) -> PackedCopy {\n@@ -435,34 +402,29 @@ impl ::core::clone::Clone for PackedCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for PackedCopy { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for PackedCopy {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"PackedCopy\",\n             &&{ self.0 })\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for PackedCopy {\n     #[inline]\n     fn default() -> PackedCopy {\n         PackedCopy(::core::default::Default::default())\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for PackedCopy {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         ::core::hash::Hash::hash(&{ self.0 }, state)\n     }\n }\n impl ::core::marker::StructuralPartialEq for PackedCopy {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for PackedCopy {\n     #[inline]\n     fn eq(&self, other: &PackedCopy) -> bool { { self.0 } == { other.0 } }\n@@ -471,7 +433,6 @@ impl ::core::cmp::PartialEq for PackedCopy {\n }\n impl ::core::marker::StructuralEq for PackedCopy {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for PackedCopy {\n     #[inline]\n     #[doc(hidden)]\n@@ -481,7 +442,6 @@ impl ::core::cmp::Eq for PackedCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for PackedCopy {\n     #[inline]\n     fn partial_cmp(&self, other: &PackedCopy)\n@@ -490,7 +450,6 @@ impl ::core::cmp::PartialOrd for PackedCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for PackedCopy {\n     #[inline]\n     fn cmp(&self, other: &PackedCopy) -> ::core::cmp::Ordering {\n@@ -506,7 +465,6 @@ impl ::core::cmp::Ord for PackedCopy {\n #[repr(packed)]\n struct PackedNonCopy(u8);\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for PackedNonCopy {\n     #[inline]\n     fn clone(&self) -> PackedNonCopy {\n@@ -515,7 +473,6 @@ impl ::core::clone::Clone for PackedNonCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for PackedNonCopy {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         let Self(ref __self_0_0) = *self;\n@@ -524,15 +481,13 @@ impl ::core::fmt::Debug for PackedNonCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for PackedNonCopy {\n     #[inline]\n     fn default() -> PackedNonCopy {\n         PackedNonCopy(::core::default::Default::default())\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for PackedNonCopy {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         let Self(ref __self_0_0) = *self;\n@@ -541,7 +496,6 @@ impl ::core::hash::Hash for PackedNonCopy {\n }\n impl ::core::marker::StructuralPartialEq for PackedNonCopy {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for PackedNonCopy {\n     #[inline]\n     fn eq(&self, other: &PackedNonCopy) -> bool {\n@@ -558,7 +512,6 @@ impl ::core::cmp::PartialEq for PackedNonCopy {\n }\n impl ::core::marker::StructuralEq for PackedNonCopy {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for PackedNonCopy {\n     #[inline]\n     #[doc(hidden)]\n@@ -568,7 +521,6 @@ impl ::core::cmp::Eq for PackedNonCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for PackedNonCopy {\n     #[inline]\n     fn partial_cmp(&self, other: &PackedNonCopy)\n@@ -579,7 +531,6 @@ impl ::core::cmp::PartialOrd for PackedNonCopy {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for PackedNonCopy {\n     #[inline]\n     fn cmp(&self, other: &PackedNonCopy) -> ::core::cmp::Ordering {\n@@ -592,31 +543,26 @@ impl ::core::cmp::Ord for PackedNonCopy {\n // An empty enum.\n enum Enum0 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Enum0 {\n     #[inline]\n     fn clone(&self) -> Enum0 { *self }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Enum0 { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Enum0 {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         unsafe { ::core::intrinsics::unreachable() }\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Enum0 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         unsafe { ::core::intrinsics::unreachable() }\n     }\n }\n impl ::core::marker::StructuralPartialEq for Enum0 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Enum0 {\n     #[inline]\n     fn eq(&self, other: &Enum0) -> bool {\n@@ -625,15 +571,13 @@ impl ::core::cmp::PartialEq for Enum0 {\n }\n impl ::core::marker::StructuralEq for Enum0 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Enum0 {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Enum0 {\n     #[inline]\n     fn partial_cmp(&self, other: &Enum0)\n@@ -642,7 +586,6 @@ impl ::core::cmp::PartialOrd for Enum0 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Enum0 {\n     #[inline]\n     fn cmp(&self, other: &Enum0) -> ::core::cmp::Ordering {\n@@ -657,7 +600,6 @@ enum Enum1 {\n     },\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Enum1 {\n     #[inline]\n     fn clone(&self) -> Enum1 {\n@@ -668,7 +610,6 @@ impl ::core::clone::Clone for Enum1 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Enum1 {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         match self {\n@@ -679,7 +620,6 @@ impl ::core::fmt::Debug for Enum1 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Enum1 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         match self {\n@@ -690,7 +630,6 @@ impl ::core::hash::Hash for Enum1 {\n }\n impl ::core::marker::StructuralPartialEq for Enum1 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Enum1 {\n     #[inline]\n     fn eq(&self, other: &Enum1) -> bool {\n@@ -709,7 +648,6 @@ impl ::core::cmp::PartialEq for Enum1 {\n }\n impl ::core::marker::StructuralEq for Enum1 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Enum1 {\n     #[inline]\n     #[doc(hidden)]\n@@ -719,7 +657,6 @@ impl ::core::cmp::Eq for Enum1 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Enum1 {\n     #[inline]\n     fn partial_cmp(&self, other: &Enum1)\n@@ -731,7 +668,6 @@ impl ::core::cmp::PartialOrd for Enum1 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Enum1 {\n     #[inline]\n     fn cmp(&self, other: &Enum1) -> ::core::cmp::Ordering {\n@@ -749,47 +685,40 @@ enum Fieldless1 {\n     A,\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Fieldless1 {\n     #[inline]\n     fn clone(&self) -> Fieldless1 { Fieldless1::A }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fieldless1 {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         ::core::fmt::Formatter::write_str(f, \"A\")\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Fieldless1 {\n     #[inline]\n     fn default() -> Fieldless1 { Self::A }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fieldless1 {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}\n }\n impl ::core::marker::StructuralPartialEq for Fieldless1 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Fieldless1 {\n     #[inline]\n     fn eq(&self, other: &Fieldless1) -> bool { true }\n }\n impl ::core::marker::StructuralEq for Fieldless1 {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Fieldless1 {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Fieldless1 {\n     #[inline]\n     fn partial_cmp(&self, other: &Fieldless1)\n@@ -798,7 +727,6 @@ impl ::core::cmp::PartialOrd for Fieldless1 {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fieldless1 {\n     #[inline]\n     fn cmp(&self, other: &Fieldless1) -> ::core::cmp::Ordering {\n@@ -815,16 +743,13 @@ enum Fieldless {\n     C,\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Fieldless {\n     #[inline]\n     fn clone(&self) -> Fieldless { *self }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Fieldless { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fieldless {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         match self {\n@@ -835,13 +760,11 @@ impl ::core::fmt::Debug for Fieldless {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Fieldless {\n     #[inline]\n     fn default() -> Fieldless { Self::A }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fieldless {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n@@ -850,7 +773,6 @@ impl ::core::hash::Hash for Fieldless {\n }\n impl ::core::marker::StructuralPartialEq for Fieldless {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Fieldless {\n     #[inline]\n     fn eq(&self, other: &Fieldless) -> bool {\n@@ -861,15 +783,13 @@ impl ::core::cmp::PartialEq for Fieldless {\n }\n impl ::core::marker::StructuralEq for Fieldless {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Fieldless {\n     #[inline]\n     #[doc(hidden)]\n     #[no_coverage]\n     fn assert_receiver_is_total_eq(&self) -> () {}\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Fieldless {\n     #[inline]\n     fn partial_cmp(&self, other: &Fieldless)\n@@ -880,7 +800,6 @@ impl ::core::cmp::PartialOrd for Fieldless {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fieldless {\n     #[inline]\n     fn cmp(&self, other: &Fieldless) -> ::core::cmp::Ordering {\n@@ -903,7 +822,6 @@ enum Mixed {\n     },\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Mixed {\n     #[inline]\n     fn clone(&self) -> Mixed {\n@@ -912,10 +830,8 @@ impl ::core::clone::Clone for Mixed {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Mixed { }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Mixed {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         match self {\n@@ -931,13 +847,11 @@ impl ::core::fmt::Debug for Mixed {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::default::Default for Mixed {\n     #[inline]\n     fn default() -> Mixed { Self::P }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Mixed {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n@@ -954,7 +868,6 @@ impl ::core::hash::Hash for Mixed {\n }\n impl ::core::marker::StructuralPartialEq for Mixed {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Mixed {\n     #[inline]\n     fn eq(&self, other: &Mixed) -> bool {\n@@ -987,7 +900,6 @@ impl ::core::cmp::PartialEq for Mixed {\n }\n impl ::core::marker::StructuralEq for Mixed {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Mixed {\n     #[inline]\n     #[doc(hidden)]\n@@ -997,7 +909,6 @@ impl ::core::cmp::Eq for Mixed {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Mixed {\n     #[inline]\n     fn partial_cmp(&self, other: &Mixed)\n@@ -1025,7 +936,6 @@ impl ::core::cmp::PartialOrd for Mixed {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Mixed {\n     #[inline]\n     fn cmp(&self, other: &Mixed) -> ::core::cmp::Ordering {\n@@ -1054,7 +964,6 @@ impl ::core::cmp::Ord for Mixed {\n // for this enum.\n enum Fielded { X(u32), Y(bool), Z(Option<i32>), }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Fielded {\n     #[inline]\n     fn clone(&self) -> Fielded {\n@@ -1069,7 +978,6 @@ impl ::core::clone::Clone for Fielded {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::fmt::Debug for Fielded {\n     fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n         match self {\n@@ -1086,7 +994,6 @@ impl ::core::fmt::Debug for Fielded {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::hash::Hash for Fielded {\n     fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {\n         let __self_tag = ::core::intrinsics::discriminant_value(self);\n@@ -1100,7 +1007,6 @@ impl ::core::hash::Hash for Fielded {\n }\n impl ::core::marker::StructuralPartialEq for Fielded {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialEq for Fielded {\n     #[inline]\n     fn eq(&self, other: &Fielded) -> bool {\n@@ -1135,7 +1041,6 @@ impl ::core::cmp::PartialEq for Fielded {\n }\n impl ::core::marker::StructuralEq for Fielded {}\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Eq for Fielded {\n     #[inline]\n     #[doc(hidden)]\n@@ -1147,7 +1052,6 @@ impl ::core::cmp::Eq for Fielded {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::PartialOrd for Fielded {\n     #[inline]\n     fn partial_cmp(&self, other: &Fielded)\n@@ -1170,7 +1074,6 @@ impl ::core::cmp::PartialOrd for Fielded {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::cmp::Ord for Fielded {\n     #[inline]\n     fn cmp(&self, other: &Fielded) -> ::core::cmp::Ordering {\n@@ -1199,7 +1102,6 @@ pub union Union {\n     pub i: i32,\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::clone::Clone for Union {\n     #[inline]\n     fn clone(&self) -> Union {\n@@ -1208,5 +1110,4 @@ impl ::core::clone::Clone for Union {\n     }\n }\n #[automatically_derived]\n-#[allow(unused_qualifications)]\n impl ::core::marker::Copy for Union { }"}, {"sha": "bebd8286de9fec2060420df8abaadb25aec45aac", "filename": "src/test/ui/impl-trait/issue-99073-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073-2.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,17 @@\n+use std::fmt::Display;\n+\n+fn main() {\n+    test(\"hi\", true);\n+}\n+\n+fn test<T: Display>(t: T, recurse: bool) -> impl Display {\n+    let f = || {\n+        let i: u32 = test::<i32>(-1, false);\n+        //~^ ERROR mismatched types\n+        println!(\"{i}\");\n+    };\n+    if recurse {\n+        f();\n+    }\n+    t\n+}"}, {"sha": "c1e4b823c08e7873bb4a5ba5618cba50e5e66f99", "filename": "src/test/ui/impl-trait/issue-99073-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073-2.stderr?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,15 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-99073-2.rs:9:22\n+   |\n+LL | fn test<T: Display>(t: T, recurse: bool) -> impl Display {\n+   |                                             ------------ the expected opaque type\n+LL |     let f = || {\n+LL |         let i: u32 = test::<i32>(-1, false);\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^ types differ\n+   |\n+   = note: expected opaque type `impl std::fmt::Display`\n+                     found type `u32`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "1d75f6086664fd6db66f24379727b7388495ff86", "filename": "src/test/ui/impl-trait/issue-99073.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let _ = fix(|_: &dyn Fn()| {});\n+}\n+\n+fn fix<F: Fn(G), G: Fn()>(f: F) -> impl Fn() {\n+    move || f(fix(&f))\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "b35d58093d5fc89c00f20762a201a11db5084879", "filename": "src/test/ui/impl-trait/issue-99073.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-99073.stderr?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-99073.rs:6:13\n+   |\n+LL | fn fix<F: Fn(G), G: Fn()>(f: F) -> impl Fn() {\n+   |                                    --------- the expected opaque type\n+LL |     move || f(fix(&f))\n+   |             ^^^^^^^^^^ types differ\n+   |\n+   = note: expected opaque type `impl Fn()`\n+           found type parameter `G`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "b05579f216620d7b1635f5bc389d102f8f2add7a", "filename": "src/test/ui/impl-trait/issues/issue-99348-impl-compatibility.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -6,7 +6,7 @@ type Tait = impl Sized;\n \n impl Foo for Concrete {\n     type Item = Concrete;\n-    //~^ mismatched types\n+    //~^ type mismatch resolving\n }\n \n impl Bar for Concrete {"}, {"sha": "f0dceb1b11a5ddbc245e48747f02fffc9c6bc6e5", "filename": "src/test/ui/impl-trait/issues/issue-99348-impl-compatibility.stderr", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-99348-impl-compatibility.stderr?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -1,15 +1,25 @@\n-error[E0308]: mismatched types\n+error[E0271]: type mismatch resolving `<Concrete as Bar>::Other == Concrete`\n   --> $DIR/issue-99348-impl-compatibility.rs:8:17\n    |\n LL | type Tait = impl Sized;\n-   |             ---------- the expected opaque type\n+   |             ---------- the found opaque type\n ...\n LL |     type Item = Concrete;\n-   |                 ^^^^^^^^ types differ\n+   |                 ^^^^^^^^ type mismatch resolving `<Concrete as Bar>::Other == Concrete`\n    |\n-   = note: expected opaque type `Tait`\n-                   found struct `Concrete`\n+note: expected this to be `Concrete`\n+  --> $DIR/issue-99348-impl-compatibility.rs:13:18\n+   |\n+LL |     type Other = Tait;\n+   |                  ^^^^\n+   = note:   expected struct `Concrete`\n+           found opaque type `Tait`\n+note: required by a bound in `Foo::Item`\n+  --> $DIR/issue-99348-impl-compatibility.rs:17:20\n+   |\n+LL |     type Item: Bar<Other = Self>;\n+   |                    ^^^^^^^^^^^^ required by this bound in `Foo::Item`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0308`.\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "9d0e3068aed73a41dd9c89df2e42a09735d9396d", "filename": "src/test/ui/lint/auxiliary/add-impl.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fauxiliary%2Fadd-impl.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,22 @@\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(AddImpl)]\n+// Unnecessary qualification `bar::foo`\n+// https://github.com/rust-lang/rust/issues/71898\n+pub fn derive(input: TokenStream) -> TokenStream {\n+    \"impl B {\n+            fn foo(&self) { use bar::foo; bar::foo() }\n+        }\n+\n+        fn foo() {}\n+\n+        mod bar { pub fn foo() {} }\n+    \".parse().unwrap()\n+}"}, {"sha": "c2efbf507fec88c06f79091a0d6c2f781bbd7698", "filename": "src/test/ui/lint/unused-qualification-in-derive-expansion.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Flint%2Funused-qualification-in-derive-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Flint%2Funused-qualification-in-derive-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused-qualification-in-derive-expansion.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,16 @@\n+// run-pass\n+// aux-build:add-impl.rs\n+\n+#![forbid(unused_qualifications)]\n+\n+#[macro_use]\n+extern crate add_impl;\n+\n+#[derive(AddImpl)]\n+struct B;\n+\n+fn main() {\n+    B.foo();\n+    foo();\n+    bar::foo();\n+}"}, {"sha": "8ff14fb1f304aee283b93b1bf8256a9d90c1ad83", "filename": "src/test/ui/parser/fn-header-semantic-fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -27,7 +27,7 @@ fn main() {\n     struct Y;\n     impl X for Y {\n         async fn ft1() {} //~ ERROR functions in traits cannot be declared `async`\n-        //~^ ERROR impl has stricter requirements than trait\n+        //~^ ERROR has an incompatible type for trait\n         unsafe fn ft2() {} // OK.\n         const fn ft3() {} //~ ERROR functions in traits cannot be declared const\n         extern \"C\" fn ft4() {}\n@@ -36,7 +36,7 @@ fn main() {\n         //~| ERROR functions in traits cannot be declared const\n         //~| ERROR functions cannot be both `const` and `async`\n         //~| ERROR cycle detected\n-        //~| ERROR impl has stricter requirements than trait\n+        //~| ERROR has an incompatible type for trait\n     }\n \n     impl Y {"}, {"sha": "bc51ba8b8c5c51971799f77b3dea857c71f7243d", "filename": "src/test/ui/parser/fn-header-semantic-fail.stderr", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ffn-header-semantic-fail.stderr?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -216,23 +216,41 @@ LL | |     }\n LL | | }\n    | |_^\n \n-error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/fn-header-semantic-fail.rs:29:9\n+error[E0053]: method `ft1` has an incompatible type for trait\n+  --> $DIR/fn-header-semantic-fail.rs:29:24\n    |\n-LL |         async fn ft1();\n-   |         --------------- definition of `ft1` from trait\n-...\n LL |         async fn ft1() {}\n-   |         ^^^^^^^^^^^^^^ impl has extra requirement `(): Future`\n+   |                        ^\n+   |                        |\n+   |                        checked the `Output` of this `async fn`, found opaque type\n+   |                        expected `()`, found opaque type\n+   |\n+   = note: while checking the return type of the `async fn`\n+note: type in trait\n+  --> $DIR/fn-header-semantic-fail.rs:17:23\n+   |\n+LL |         async fn ft1();\n+   |                       ^\n+   = note: expected fn pointer `fn()`\n+              found fn pointer `fn() -> impl Future<Output = ()>`\n \n-error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/fn-header-semantic-fail.rs:34:9\n+error[E0053]: method `ft5` has an incompatible type for trait\n+  --> $DIR/fn-header-semantic-fail.rs:34:48\n    |\n-LL |         const async unsafe extern \"C\" fn ft5();\n-   |         --------------------------------------- definition of `ft5` from trait\n-...\n LL |         const async unsafe extern \"C\" fn ft5() {}\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `(): Future`\n+   |                                                ^\n+   |                                                |\n+   |                                                checked the `Output` of this `async fn`, found opaque type\n+   |                                                expected `()`, found opaque type\n+   |\n+   = note: while checking the return type of the `async fn`\n+note: type in trait\n+  --> $DIR/fn-header-semantic-fail.rs:21:47\n+   |\n+LL |         const async unsafe extern \"C\" fn ft5();\n+   |                                               ^\n+   = note: expected fn pointer `unsafe extern \"C\" fn()`\n+              found fn pointer `unsafe extern \"C\" fn() -> impl Future<Output = ()>`\n \n error[E0391]: cycle detected when computing type of `main::<impl at $DIR/fn-header-semantic-fail.rs:28:5: 28:17>::ft5::{opaque#0}`\n   --> $DIR/fn-header-semantic-fail.rs:34:48\n@@ -308,5 +326,5 @@ LL | | }\n \n error: aborting due to 23 previous errors\n \n-Some errors have detailed explanations: E0276, E0379, E0391, E0706.\n-For more information about an error, try `rustc --explain E0276`.\n+Some errors have detailed explanations: E0053, E0379, E0391, E0706.\n+For more information about an error, try `rustc --explain E0053`."}, {"sha": "aaf0f7eaef0dcdd3969dcb3d743d0b4fba8f69f0", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -14,7 +14,7 @@ trait B {\n impl B for A {\n     async fn associated(); //~ ERROR without body\n     //~^ ERROR cannot be declared `async`\n-    //~| ERROR impl has stricter requirements than trait\n+    //~| ERROR has an incompatible type for trait\n }\n \n fn main() {}"}, {"sha": "d3214458eac13cc8f89bedfcf498812c5aad6116", "filename": "src/test/ui/resolve/issue-70736-async-fn-no-body-def-collector.stderr", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-70736-async-fn-no-body-def-collector.stderr?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -44,16 +44,25 @@ LL |     async fn associated();\n    = note: `async` trait functions are not currently supported\n    = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n-error[E0276]: impl has stricter requirements than trait\n-  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:15:5\n+error[E0053]: method `associated` has an incompatible type for trait\n+  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:15:26\n    |\n LL |     async fn associated();\n-   |     ---------------------- definition of `associated` from trait\n-...\n+   |                          ^\n+   |                          |\n+   |                          checked the `Output` of this `async fn`, found opaque type\n+   |                          expected `()`, found opaque type\n+   |\n+   = note: while checking the return type of the `async fn`\n+note: type in trait\n+  --> $DIR/issue-70736-async-fn-no-body-def-collector.rs:11:26\n+   |\n LL |     async fn associated();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ impl has extra requirement `(): Future`\n+   |                          ^\n+   = note: expected fn pointer `fn()`\n+              found fn pointer `fn() -> impl Future<Output = ()>`\n \n error: aborting due to 6 previous errors\n \n-Some errors have detailed explanations: E0276, E0706.\n-For more information about an error, try `rustc --explain E0276`.\n+Some errors have detailed explanations: E0053, E0706.\n+For more information about an error, try `rustc --explain E0053`."}, {"sha": "4a11bb5020e6d21aa3a0da8725a843b5b4684f9b", "filename": "src/test/ui/type-alias-impl-trait/issue-53398-cyclic-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -3,7 +3,7 @@\n type Foo = impl Fn() -> Foo;\n \n fn foo() -> Foo {\n-//~^ ERROR: overflow evaluating the requirement `fn() -> Foo {foo}: Sized`\n+//~^ ERROR: overflow evaluating the requirement\n     foo\n }\n "}, {"sha": "00c682b21939c81a461f5754cde9ce41d9e56495", "filename": "src/test/ui/type-alias-impl-trait/issue-53398-cyclic-types.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53398-cyclic-types.stderr?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -1,10 +1,8 @@\n-error[E0275]: overflow evaluating the requirement `fn() -> Foo {foo}: Sized`\n+error[E0275]: overflow evaluating the requirement `<fn() -> Foo {foo} as FnOnce<()>>::Output == fn() -> Foo {foo}`\n   --> $DIR/issue-53398-cyclic-types.rs:5:13\n    |\n LL | fn foo() -> Foo {\n    |             ^^^\n-   |\n-   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_53398_cyclic_types`)\n \n error: aborting due to previous error\n "}, {"sha": "472886c9caa23f0ff11101c545c83b6a4b591406", "filename": "src/test/ui/type-alias-impl-trait/issue-57961.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.rs?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,18 @@\n+#![feature(type_alias_impl_trait)]\n+\n+type X = impl Sized;\n+\n+trait Foo {\n+    type Bar: Iterator<Item = X>;\n+}\n+\n+impl Foo for () {\n+    type Bar = std::vec::IntoIter<u32>;\n+    //~^ ERROR type mismatch resolving `<std::vec::IntoIter<u32> as Iterator>::Item == X\n+}\n+\n+fn incoherent() {\n+    let f: X = 22_i32;\n+}\n+\n+fn main() {}"}, {"sha": "ed4caf6ce68d6e6cf3e778c88512deda0c0a2037", "filename": "src/test/ui/type-alias-impl-trait/issue-57961.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/14dbfebfa25a0e626ad827526934381b2545cbb4/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57961.stderr?ref=14dbfebfa25a0e626ad827526934381b2545cbb4", "patch": "@@ -0,0 +1,20 @@\n+error[E0271]: type mismatch resolving `<std::vec::IntoIter<u32> as Iterator>::Item == X`\n+  --> $DIR/issue-57961.rs:10:16\n+   |\n+LL | type X = impl Sized;\n+   |          ---------- the expected opaque type\n+...\n+LL |     type Bar = std::vec::IntoIter<u32>;\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^ expected opaque type, found `u32`\n+   |\n+   = note: expected opaque type `X`\n+                     found type `u32`\n+note: required by a bound in `Foo::Bar`\n+  --> $DIR/issue-57961.rs:6:24\n+   |\n+LL |     type Bar: Iterator<Item = X>;\n+   |                        ^^^^^^^^ required by this bound in `Foo::Bar`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}]}