{"sha": "9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhMjMxOTYxZDU5MTM1YzdkYzQxZDliOTRmZmU0M2VjYzliYmQ4Y2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-31T22:08:34Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-09-05T14:37:58Z"}, "message": "rustc: Move stability functionality into queries\n\nThis commit primarily removes the `stability` field from `TyCtxt` as well as its\ninternal mutable state, instead using a query to build the stability index as\nwell as primarily using queries for other related lookups.\n\nLike previous commits the calculation of the stability index is wrapped in a\n`with_ignore` node to avoid regressing the current tests, and otherwise this\ncommit also introduces #44232 but somewhat intentionally so.", "tree": {"sha": "cada5b4f27f31664a7d877c3084e3a417307b4a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cada5b4f27f31664a7d877c3084e3a417307b4a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "html_url": "https://github.com/rust-lang/rust/commit/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0182c8bbda094c7a6abf89b6c45185ba1e5d38b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/0182c8bbda094c7a6abf89b6c45185ba1e5d38b3", "html_url": "https://github.com/rust-lang/rust/commit/0182c8bbda094c7a6abf89b6c45185ba1e5d38b3"}], "stats": {"total": 414, "additions": 212, "deletions": 202}, "files": [{"sha": "810355dc2c0f861a4b203bbb54ae0c0660ea0498", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -511,8 +511,8 @@ define_dep_nodes!( <'tcx>\n     [] ParamEnv(DefId),\n     [] DescribeDef(DefId),\n     [] DefSpan(DefId),\n-    [] Stability(DefId),\n-    [] Deprecation(DefId),\n+    [] LookupStability(DefId),\n+    [] LookupDeprecationEntry(DefId),\n     [] ItemBodyNestedBodies(DefId),\n     [] ConstIsRvaluePromotableToStatic(DefId),\n     [] ImplParent(DefId),\n@@ -573,6 +573,7 @@ define_dep_nodes!( <'tcx>\n     [] Freevars(HirId),\n     [] MaybeUnusedTraitImport(HirId),\n     [] MaybeUnusedExternCrates,\n+    [] StabilityIndex,\n );\n \n trait DepNodeParams<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> : fmt::Debug {"}, {"sha": "d043d8346e6a850a781a3849b160c74f79a17a62", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -878,7 +878,17 @@ impl<'hir> Map<'hir> {\n \n             Some(RootCrate(_)) => self.forest.krate.span,\n             Some(NotPresent) | None => {\n-                bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n+                // Some nodes, notably macro definitions, are not\n+                // present in the map for whatever reason, but\n+                // they *do* have def-ids. So if we encounter an\n+                // empty hole, check for that case.\n+                if let Some(def_index) = self.definitions.opt_def_index(id) {\n+                    let def_path_hash = self.definitions.def_path_hash(def_index);\n+                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n+                    DUMMY_SP\n+                } else {\n+                    bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n+                }\n             }\n         }\n     }"}, {"sha": "ecf3aab05d858d60e91b665e820bcba0d8f48ab1", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 101, "deletions": 145, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -15,20 +15,19 @@ pub use self::StabilityLevel::*;\n \n use lint;\n use hir::def::Def;\n-use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use ty::{self, TyCtxt};\n use middle::privacy::AccessLevels;\n-use session::Session;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};\n use syntax::attr::{self, Stability, Deprecation};\n-use util::nodemap::{DefIdMap, FxHashSet, FxHashMap};\n+use util::nodemap::{FxHashSet, FxHashMap};\n \n use hir;\n-use hir::{Item, Generics, StructField, Variant};\n+use hir::{Item, Generics, StructField, Variant, HirId};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::mem::replace;\n@@ -63,19 +62,18 @@ pub struct DeprecationEntry {\n     pub attr: Deprecation,\n     /// The def id where the attr was originally attached. `None` for non-local\n     /// `DefId`'s.\n-    origin: Option<DefIndex>,\n+    origin: Option<HirId>,\n }\n \n impl DeprecationEntry {\n-    fn local(attr: Deprecation, id: DefId) -> DeprecationEntry {\n-        assert!(id.is_local());\n+    fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n         DeprecationEntry {\n             attr,\n-            origin: Some(id.index),\n+            origin: Some(id),\n         }\n     }\n \n-    fn external(attr: Deprecation) -> DeprecationEntry {\n+    pub fn external(attr: Deprecation) -> DeprecationEntry {\n         DeprecationEntry {\n             attr,\n             origin: None,\n@@ -94,17 +92,14 @@ impl DeprecationEntry {\n pub struct Index<'tcx> {\n     /// This is mostly a cache, except the stabilities of local items\n     /// are filled by the annotator.\n-    stab_map: DefIdMap<Option<&'tcx Stability>>,\n-    depr_map: DefIdMap<Option<DeprecationEntry>>,\n+    stab_map: FxHashMap<HirId, &'tcx Stability>,\n+    depr_map: FxHashMap<HirId, DeprecationEntry>,\n \n     /// Maps for each crate whether it is part of the staged API.\n     staged_api: FxHashMap<CrateNum, bool>,\n \n     /// Features enabled for this crate.\n     active_features: FxHashSet<Symbol>,\n-\n-    /// Features used by this crate. Updated before and during typeck.\n-    used_features: FxHashMap<Symbol, attr::StabilityLevel>\n }\n \n // A private tree-walker for producing an Index.\n@@ -178,8 +173,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                     }\n                 }\n \n-                let def_id = self.tcx.hir.local_def_id(id);\n-                self.index.stab_map.insert(def_id, Some(stab));\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                self.index.stab_map.insert(hir_id, stab);\n \n                 let orig_parent_stab = replace(&mut self.parent_stab, Some(stab));\n                 visit_children(self);\n@@ -188,8 +183,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n                 if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n-                        let def_id = self.tcx.hir.local_def_id(id);\n-                        self.index.stab_map.insert(def_id, Some(stab));\n+                        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                        self.index.stab_map.insert(hir_id, stab);\n                     }\n                 }\n                 visit_children(self);\n@@ -209,8 +204,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             // -Zforce-unstable-if-unmarked is set.\n             if let Some(stab) = self.parent_stab {\n                 if stab.level.is_unstable() {\n-                    let def_id = self.tcx.hir.local_def_id(id);\n-                    self.index.stab_map.insert(def_id, Some(stab));\n+                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    self.index.stab_map.insert(hir_id, stab);\n                 }\n             }\n \n@@ -220,16 +215,17 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n \n                 // `Deprecation` is just two pointers, no need to intern it\n-                let def_id = self.tcx.hir.local_def_id(id);\n-                let depr_entry = Some(DeprecationEntry::local(depr, def_id));\n-                self.index.depr_map.insert(def_id, depr_entry.clone());\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let depr_entry = DeprecationEntry::local(depr, hir_id);\n+                self.index.depr_map.insert(hir_id, depr_entry.clone());\n \n-                let orig_parent_depr = replace(&mut self.parent_depr, depr_entry);\n+                let orig_parent_depr = replace(&mut self.parent_depr,\n+                                               Some(depr_entry));\n                 visit_children(self);\n                 self.parent_depr = orig_parent_depr;\n-            } else if let parent_depr @ Some(_) = self.parent_depr.clone() {\n-                let def_id = self.tcx.hir.local_def_id(id);\n-                self.index.depr_map.insert(def_id, parent_depr);\n+            } else if let Some(parent_depr) = self.parent_depr.clone() {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                self.index.depr_map.insert(hir_id, parent_depr);\n                 visit_children(self);\n             } else {\n                 visit_children(self);\n@@ -322,10 +318,10 @@ struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n     fn check_missing_stability(&self, id: NodeId, span: Span) {\n-        let def_id = self.tcx.hir.local_def_id(id);\n-        let stab = self.tcx.stability.borrow().stab_map.get(&def_id).cloned();\n+        let hir_id = self.tcx.hir.node_to_hir_id(id);\n+        let stab = self.tcx.stability().local_stability(hir_id);\n         let is_error = !self.tcx.sess.opts.test &&\n-                        (stab == None || stab == Some(None)) &&\n+                        stab.is_none() &&\n                         self.access_levels.is_reachable(id);\n         if is_error {\n             self.tcx.sess.span_err(span, \"This node does not have a stability attribute\");\n@@ -386,60 +382,70 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Index<'tcx> {\n-    /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Index<'tcx> {\n+        let is_staged_api =\n+            tcx.sess.opts.debugging_opts.force_unstable_if_unmarked ||\n+            tcx.sess.features.borrow().staged_api;\n+        let mut staged_api = FxHashMap();\n+        staged_api.insert(LOCAL_CRATE, is_staged_api);\n+        let mut index = Index {\n+            staged_api,\n+            stab_map: FxHashMap(),\n+            depr_map: FxHashMap(),\n+            active_features: FxHashSet(),\n+        };\n+\n         let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n         // Put the active features into a map for quick lookup\n-        self.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+        index.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+\n+        {\n+            let krate = tcx.hir.krate();\n+            let mut annotator = Annotator {\n+                tcx,\n+                index: &mut index,\n+                parent_stab: None,\n+                parent_depr: None,\n+                in_trait_impl: false,\n+            };\n \n-        let krate = tcx.hir.krate();\n-        let mut annotator = Annotator {\n-            tcx,\n-            index: self,\n-            parent_stab: None,\n-            parent_depr: None,\n-            in_trait_impl: false,\n-        };\n+            // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n+            // a parent stability annotation which indicates that this is private\n+            // with the `rustc_private` feature. This is intended for use when\n+            // compiling librustc crates themselves so we can leverage crates.io\n+            // while maintaining the invariant that all sysroot crates are unstable\n+            // by default and are unable to be used.\n+            if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n+                let reason = \"this crate is being loaded from the sysroot, and \\\n+                              unstable location; did you mean to load this crate \\\n+                              from crates.io via `Cargo.toml` instead?\";\n+                let stability = tcx.intern_stability(Stability {\n+                    level: attr::StabilityLevel::Unstable {\n+                        reason: Some(Symbol::intern(reason)),\n+                        issue: 27812,\n+                    },\n+                    feature: Symbol::intern(\"rustc_private\"),\n+                    rustc_depr: None,\n+                });\n+                annotator.parent_stab = Some(stability);\n+            }\n \n-        // If the `-Z force-unstable-if-unmarked` flag is passed then we provide\n-        // a parent stability annotation which indicates that this is private\n-        // with the `rustc_private` feature. This is intended for use when\n-        // compiling librustc crates themselves so we can leverage crates.io\n-        // while maintaining the invariant that all sysroot crates are unstable\n-        // by default and are unable to be used.\n-        if tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n-            let reason = \"this crate is being loaded from the sysroot, and \\\n-                          unstable location; did you mean to load this crate \\\n-                          from crates.io via `Cargo.toml` instead?\";\n-            let stability = tcx.intern_stability(Stability {\n-                level: attr::StabilityLevel::Unstable {\n-                    reason: Some(Symbol::intern(reason)),\n-                    issue: 27812,\n-                },\n-                feature: Symbol::intern(\"rustc_private\"),\n-                rustc_depr: None,\n-            });\n-            annotator.parent_stab = Some(stability);\n+            annotator.annotate(ast::CRATE_NODE_ID,\n+                               &krate.attrs,\n+                               krate.span,\n+                               AnnotationKind::Required,\n+                               |v| intravisit::walk_crate(v, krate));\n         }\n+        return index\n+    }\n \n-        annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, krate.span, AnnotationKind::Required,\n-                           |v| intravisit::walk_crate(v, krate));\n+    pub fn local_stability(&self, id: HirId) -> Option<&'tcx Stability> {\n+        self.stab_map.get(&id).cloned()\n     }\n \n-    pub fn new(sess: &Session) -> Index<'tcx> {\n-        let is_staged_api =\n-            sess.opts.debugging_opts.force_unstable_if_unmarked ||\n-            sess.features.borrow().staged_api;\n-        let mut staged_api = FxHashMap();\n-        staged_api.insert(LOCAL_CRATE, is_staged_api);\n-        Index {\n-            staged_api,\n-            stab_map: DefIdMap(),\n-            depr_map: DefIdMap(),\n-            active_features: FxHashSet(),\n-            used_features: FxHashMap(),\n-        }\n+    pub fn local_deprecation_entry(&self, id: HirId) -> Option<DeprecationEntry> {\n+        self.depr_map.get(&id).cloned()\n     }\n }\n \n@@ -547,18 +553,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return\n         }\n \n-        if let Some(&Stability { ref level, ref feature, .. }) = stability {\n-            self.stability.borrow_mut().used_features.insert(feature.clone(), level.clone());\n-        }\n-\n         // Issue 38412: private items lack stability markers.\n         if self.skip_stability_check_due_to_privacy(def_id) {\n             return\n         }\n \n         match stability {\n             Some(&Stability { level: attr::Unstable {ref reason, issue}, ref feature, .. }) => {\n-                if self.stability.borrow().active_features.contains(feature) {\n+                if self.stability().active_features.contains(feature) {\n                     return\n                 }\n \n@@ -672,49 +674,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    /// Lookup the stability for a node, loading external crate\n-    /// metadata as necessary.\n-    pub fn lookup_stability(self, id: DefId) -> Option<&'gcx Stability> {\n-        if let Some(st) = self.stability.borrow().stab_map.get(&id) {\n-            return *st;\n-        }\n-\n-        let st = self.lookup_stability_uncached(id);\n-        self.stability.borrow_mut().stab_map.insert(id, st);\n-        st\n-    }\n-\n     pub fn lookup_deprecation(self, id: DefId) -> Option<Deprecation> {\n         self.lookup_deprecation_entry(id).map(|depr| depr.attr)\n     }\n-\n-    pub fn lookup_deprecation_entry(self, id: DefId) -> Option<DeprecationEntry> {\n-        if let Some(depr) = self.stability.borrow().depr_map.get(&id) {\n-            return depr.clone();\n-        }\n-\n-        let depr = self.lookup_deprecation_uncached(id);\n-        self.stability.borrow_mut().depr_map.insert(id, depr.clone());\n-        depr\n-    }\n-\n-    fn lookup_stability_uncached(self, id: DefId) -> Option<&'gcx Stability> {\n-        debug!(\"lookup(id={:?})\", id);\n-        if id.is_local() {\n-            None // The stability cache is filled partially lazily\n-        } else {\n-            self.stability(id).map(|st| self.intern_stability(st))\n-        }\n-    }\n-\n-    fn lookup_deprecation_uncached(self, id: DefId) -> Option<DeprecationEntry> {\n-        debug!(\"lookup(id={:?})\", id);\n-        if id.is_local() {\n-            None // The stability cache is filled partially lazily\n-        } else {\n-            self.deprecation(id).map(DeprecationEntry::external)\n-        }\n-    }\n }\n \n /// Given the list of enabled features that were not language features (i.e. that\n@@ -725,7 +687,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n \n-    if tcx.stability.borrow().staged_api[&LOCAL_CRATE] {\n+    if tcx.stability().staged_api[&LOCAL_CRATE] {\n         let krate = tcx.hir.krate();\n         let mut missing = MissingStabilityAnnotations {\n             tcx,\n@@ -741,10 +703,6 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         = declared_lib_features.clone().into_iter().collect();\n     remaining_lib_features.remove(&Symbol::intern(\"proc_macro\"));\n \n-    fn format_stable_since_msg(version: &str) -> String {\n-        format!(\"this feature has been stable since {}. Attribute no longer needed\", version)\n-    }\n-\n     for &(ref stable_lang_feature, span) in &sess.features.borrow().declared_stable_lang_features {\n         let version = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n             .expect(\"unexpectedly couldn't find version feature was stabilized\");\n@@ -754,25 +712,23 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                       &format_stable_since_msg(version));\n     }\n \n-    let index = tcx.stability.borrow();\n-    for (used_lib_feature, level) in &index.used_features {\n-        match remaining_lib_features.remove(used_lib_feature) {\n-            Some(span) => {\n-                if let &attr::StabilityLevel::Stable { since: ref version } = level {\n-                    tcx.lint_node(lint::builtin::STABLE_FEATURES,\n-                                  ast::CRATE_NODE_ID,\n-                                  span,\n-                                  &format_stable_since_msg(&version.as_str()));\n-                }\n-            }\n-            None => ( /* used but undeclared, handled during the previous ast visit */ )\n-        }\n-    }\n+    // FIXME(#44232) the `used_features` table no longer exists, so we don't\n+    //               lint about unknown or unused features. We should reenable\n+    //               this one day!\n+    //\n+    // let index = tcx.stability();\n+    // for (used_lib_feature, level) in &index.used_features {\n+    //     remaining_lib_features.remove(used_lib_feature);\n+    // }\n+    //\n+    // for &span in remaining_lib_features.values() {\n+    //     tcx.lint_node(lint::builtin::UNUSED_FEATURES,\n+    //                   ast::CRATE_NODE_ID,\n+    //                   span,\n+    //                   \"unused or unknown feature\");\n+    // }\n+}\n \n-    for &span in remaining_lib_features.values() {\n-        tcx.lint_node(lint::builtin::UNUSED_FEATURES,\n-                      ast::CRATE_NODE_ID,\n-                      span,\n-                      \"unused or unknown feature\");\n-    }\n+fn format_stable_since_msg(version: &str) -> String {\n+    format!(\"this feature has been stable since {}. Attribute no longer needed\", version)\n }"}, {"sha": "10918d702d7532e6f8e1f0a4860c4960ffe427f0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -855,9 +855,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// about.\n     pub used_mut_nodes: RefCell<NodeSet>,\n \n-    /// Maps any item's def-id to its stability index.\n-    pub stability: RefCell<stability::Index<'tcx>>,\n-\n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n@@ -989,7 +986,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                   resolutions: ty::Resolutions,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   hir: hir_map::Map<'tcx>,\n-                                  stability: stability::Index<'tcx>,\n                                   crate_name: &str,\n                                   f: F) -> R\n                                   where F: for<'b> FnOnce(TyCtxt<'b, 'tcx, 'tcx>) -> R\n@@ -1086,7 +1082,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             normalized_cache: RefCell::new(FxHashMap()),\n             inhabitedness_cache: RefCell::new(FxHashMap()),\n             used_mut_nodes: RefCell::new(NodeSet()),\n-            stability: RefCell::new(stability),\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n@@ -1118,6 +1113,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             self.get_lang_items(LOCAL_CRATE)\n         })\n     }\n+\n+    pub fn stability(self) -> Rc<stability::Index<'tcx>> {\n+        self.dep_graph.with_ignore(|| {\n+            self.stability_index(LOCAL_CRATE)\n+        })\n+    }\n }\n \n impl<'gcx: 'tcx, 'tcx> GlobalCtxt<'gcx> {\n@@ -2012,6 +2013,9 @@ struct NamedRegionMap {\n }\n \n pub fn provide(providers: &mut ty::maps::Providers) {\n+    // FIXME(#44234) - almost all of these queries have no sub-queries and\n+    // therefore no actual inputs, they're just reading tables calculated in\n+    // resolve! Does this work? Unsure! That's what the issue is about\n     providers.in_scope_traits = |tcx, id| tcx.gcx.trait_map.get(&id).cloned();\n     providers.module_exports = |tcx, id| tcx.gcx.export_map.get(&id).cloned();\n     providers.named_region = |tcx, id| tcx.gcx.named_region_map.defs.get(&id).cloned();\n@@ -2035,4 +2039,19 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         Rc::new(tcx.maybe_unused_extern_crates.clone())\n     };\n+\n+    providers.stability_index = |tcx, cnum| {\n+        assert_eq!(cnum, LOCAL_CRATE);\n+        Rc::new(stability::Index::new(tcx))\n+    };\n+    providers.lookup_stability = |tcx, id| {\n+        assert_eq!(id.krate, LOCAL_CRATE);\n+        let id = tcx.hir.definitions().def_index_to_hir_id(id.index);\n+        tcx.stability().local_stability(id)\n+    };\n+    providers.lookup_deprecation_entry = |tcx, id| {\n+        assert_eq!(id.krate, LOCAL_CRATE);\n+        let id = tcx.hir.definitions().def_index_to_hir_id(id.index);\n+        tcx.stability().local_deprecation_entry(id)\n+    };\n }"}, {"sha": "65d70bb9fd040212f36e5c028469409c9af423b7", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -22,6 +22,7 @@ use middle::privacy::AccessLevels;\n use middle::region;\n use middle::region::RegionMaps;\n use middle::resolve_lifetime::{Region, ObjectLifetimeDefault};\n+use middle::stability::{self, DeprecationEntry};\n use middle::lang_items::{LanguageItems, LangItem};\n use mir;\n use mir::transform::{MirSuite, MirPassIndex};\n@@ -434,13 +435,13 @@ impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n }\n \n \n-impl<'tcx> QueryDescription for queries::stability<'tcx> {\n+impl<'tcx> QueryDescription for queries::lookup_stability<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"stability\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::deprecation<'tcx> {\n+impl<'tcx> QueryDescription for queries::lookup_deprecation_entry<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"deprecation\")\n     }\n@@ -748,6 +749,12 @@ impl<'tcx> QueryDescription for queries::maybe_unused_extern_crates<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::stability_index<'tcx> {\n+    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n+        format!(\"calculating the stability index for the local crate\")\n+    }\n+}\n+\n // If enabled, send a message to the profile-queries thread\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n@@ -1272,8 +1279,8 @@ define_maps! { <'tcx>\n \n     [] fn describe_def: DescribeDef(DefId) -> Option<Def>,\n     [] fn def_span: DefSpan(DefId) -> Span,\n-    [] fn stability: Stability(DefId) -> Option<attr::Stability>,\n-    [] fn deprecation: Deprecation(DefId) -> Option<attr::Deprecation>,\n+    [] fn lookup_stability: LookupStability(DefId) -> Option<&'tcx attr::Stability>,\n+    [] fn lookup_deprecation_entry: LookupDeprecationEntry(DefId) -> Option<DeprecationEntry>,\n     [] fn item_attrs: ItemAttrs(DefId) -> Rc<[ast::Attribute]>,\n     [] fn fn_arg_names: FnArgNames(DefId) -> Vec<ast::Name>,\n     [] fn impl_parent: ImplParent(DefId) -> Option<DefId>,\n@@ -1337,37 +1344,39 @@ define_maps! { <'tcx>\n     [] fn all_trait_implementations: AllTraitImplementations(CrateNum)\n         -> Rc<Vec<DefId>>,\n \n-    [] is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n-    [] is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n-    [] native_library_kind: NativeLibraryKind(DefId)\n+    [] fn is_dllimport_foreign_item: IsDllimportForeignItem(DefId) -> bool,\n+    [] fn is_statically_included_foreign_item: IsStaticallyIncludedForeignItem(DefId) -> bool,\n+    [] fn native_library_kind: NativeLibraryKind(DefId)\n         -> Option<NativeLibraryKind>,\n-    [] link_args: link_args_node(CrateNum) -> Rc<Vec<String>>,\n+    [] fn link_args: link_args_node(CrateNum) -> Rc<Vec<String>>,\n \n-    [] named_region: NamedRegion(HirId) -> Option<Region>,\n-    [] is_late_bound: IsLateBound(HirId) -> bool,\n-    [] object_lifetime_defaults: ObjectLifetimeDefaults(HirId)\n+    [] fn named_region: NamedRegion(HirId) -> Option<Region>,\n+    [] fn is_late_bound: IsLateBound(HirId) -> bool,\n+    [] fn object_lifetime_defaults: ObjectLifetimeDefaults(HirId)\n         -> Option<Rc<Vec<ObjectLifetimeDefault>>>,\n \n-    [] visibility: Visibility(DefId) -> ty::Visibility,\n-    [] dep_kind: DepKind(CrateNum) -> DepKind,\n-    [] crate_name: CrateName(CrateNum) -> Symbol,\n-    [] item_children: ItemChildren(DefId) -> Rc<Vec<Export>>,\n-    [] extern_mod_stmt_cnum: ExternModStmtCnum(HirId) -> Option<CrateNum>,\n-\n-    [] get_lang_items: get_lang_items_node(CrateNum) -> Rc<LanguageItems>,\n-    [] defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefIndex, usize)>>,\n-    [] missing_lang_items: MissingLangItems(CrateNum) -> Rc<Vec<LangItem>>,\n-    [] extern_const_body: ExternConstBody(DefId) -> &'tcx hir::Body,\n-    [] visible_parent_map: visible_parent_map_node(CrateNum)\n+    [] fn visibility: Visibility(DefId) -> ty::Visibility,\n+    [] fn dep_kind: DepKind(CrateNum) -> DepKind,\n+    [] fn crate_name: CrateName(CrateNum) -> Symbol,\n+    [] fn item_children: ItemChildren(DefId) -> Rc<Vec<Export>>,\n+    [] fn extern_mod_stmt_cnum: ExternModStmtCnum(HirId) -> Option<CrateNum>,\n+\n+    [] fn get_lang_items: get_lang_items_node(CrateNum) -> Rc<LanguageItems>,\n+    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefIndex, usize)>>,\n+    [] fn missing_lang_items: MissingLangItems(CrateNum) -> Rc<Vec<LangItem>>,\n+    [] fn extern_const_body: ExternConstBody(DefId) -> &'tcx hir::Body,\n+    [] fn visible_parent_map: visible_parent_map_node(CrateNum)\n         -> Rc<DefIdMap<DefId>>,\n-    [] missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n-    [] used_crate_source: UsedCrateSource(CrateNum) -> Rc<CrateSource>,\n-    [] postorder_cnums: postorder_cnums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n+    [] fn missing_extern_crate_item: MissingExternCrateItem(CrateNum) -> bool,\n+    [] fn used_crate_source: UsedCrateSource(CrateNum) -> Rc<CrateSource>,\n+    [] fn postorder_cnums: postorder_cnums_node(CrateNum) -> Rc<Vec<CrateNum>>,\n \n-    [] freevars: Freevars(HirId) -> Option<Rc<Vec<hir::Freevar>>>,\n-    [] maybe_unused_trait_import: MaybeUnusedTraitImport(HirId) -> bool,\n-    [] maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n+    [] fn freevars: Freevars(HirId) -> Option<Rc<Vec<hir::Freevar>>>,\n+    [] fn maybe_unused_trait_import: MaybeUnusedTraitImport(HirId) -> bool,\n+    [] fn maybe_unused_extern_crates: maybe_unused_extern_crates_node(CrateNum)\n         -> Rc<Vec<(HirId, Span)>>,\n+\n+    [] fn stability_index: stability_index_node(CrateNum) -> Rc<stability::Index<'tcx>>,\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {\n@@ -1473,3 +1482,7 @@ fn postorder_cnums_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n fn maybe_unused_extern_crates_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::MaybeUnusedExternCrates\n }\n+\n+fn stability_index_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::StabilityIndex\n+}"}, {"sha": "b4dde2120a840bcad56ef8146be35f133397982e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -934,8 +934,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n               \"static item recursion checking\",\n               || static_recursion::check_crate(sess, &hir_map))?;\n \n-    let index = stability::Index::new(&sess);\n-\n     let mut local_providers = ty::maps::Providers::default();\n     borrowck::provide(&mut local_providers);\n     mir::provide(&mut local_providers);\n@@ -1022,7 +1020,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                              resolutions,\n                              named_region_map,\n                              hir_map,\n-                             index,\n                              name,\n                              |tcx| {\n         let incremental_hashes_map =\n@@ -1034,10 +1031,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"load_dep_graph\",\n              || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n \n-        time(time_passes, \"stability index\", || {\n-            tcx.stability.borrow_mut().build(tcx)\n-        });\n-\n         time(time_passes,\n              \"stability checking\",\n              || stability::check_unstable_api_usage(tcx));"}, {"sha": "dbb188e923a0250b8a9daf03bb8c0ab2f7f3b800", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -19,6 +19,7 @@ use rustc::middle::cstore::{CrateStore, DepKind,\n                             MetadataLoader, LinkMeta,\n                             LoadedMacro, EncodedMetadata,\n                             EncodedMetadataHashes, NativeLibraryKind};\n+use rustc::middle::stability::DeprecationEntry;\n use rustc::hir::def;\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n@@ -142,8 +143,12 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_default_impl => { cdata.is_default_impl(def_id.index) }\n     describe_def => { cdata.get_def(def_id.index) }\n     def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n-    stability => { cdata.get_stability(def_id.index) }\n-    deprecation => { cdata.get_deprecation(def_id.index) }\n+    lookup_stability => {\n+        cdata.get_stability(def_id.index).map(|s| tcx.intern_stability(s))\n+    }\n+    lookup_deprecation_entry => {\n+        cdata.get_deprecation(def_id.index).map(DeprecationEntry::external)\n+    }\n     item_attrs => { cdata.get_item_attrs(def_id.index, &tcx.dep_graph) }\n     // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n     // a `fn` when encoding, so the dep-tracking wouldn't work.\n@@ -242,6 +247,9 @@ pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n         }\n     }\n \n+    // FIXME(#44234) - almost all of these queries have no sub-queries and\n+    // therefore no actual inputs, they're just reading tables calculated in\n+    // resolve! Does this work? Unsure! That's what the issue is about\n     *providers = Providers {\n         is_const_fn,\n         is_dllimport_foreign_item: |tcx, id| {"}, {"sha": "06b872066695393aed63937490d1779dc88bc952", "filename": "src/test/compile-fail/feature-gate/issue-43106-gating-of-builtin-attrs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -99,7 +99,8 @@\n \n // For #![crate_id], see issue #43142. (I cannot bear to enshrine current behavior in a test)\n \n-#![feature                    ( x0600)] //~ WARN unused or unknown feature\n+// FIXME(#44232) we should warn that this isn't used.\n+#![feature                    ( x0600)]\n \n // For #![no_start], see issue #43144. (I cannot bear to enshrine current behavior in a test)\n "}, {"sha": "ef072d4bbb3916f424f6f69ade886c88938f5f26", "filename": "src/test/compile-fail/lint-output-format-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Ftest%2Fcompile-fail%2Flint-output-format-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Ftest%2Fcompile-fail%2Flint-output-format-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-output-format-2.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -F unused_features\n // aux-build:lint_output_format.rs\n \n+// FIXME(#44232) we should warn that this isn't used.\n #![feature(foo)]\n-//~^ ERROR unused or unknown feature\n-//~| NOTE requested on the command line with `-F unused-features`\n \n #![feature(test_feature)]\n+#![feature(rustc_attrs)]\n \n extern crate lint_output_format;\n use lint_output_format::{foo, bar};\n //~^ WARNING use of deprecated item: text\n //~| NOTE #[warn(deprecated)] on by default\n \n-fn main() {\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n     let _x = foo();\n     //~^ WARNING use of deprecated item: text\n     //~| NOTE #[warn(deprecated)] on by default"}, {"sha": "79ba3ea45e1878ed20b54fcb2d64edae800e041e", "filename": "src/test/compile-fail/lint-unknown-feature-default.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature-default.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -10,8 +10,10 @@\n \n // Tests the default for the unused_features lint\n \n-#![deny(warnings)]\n+// FIXME(#44232) we should warn that this isn't used.\n+#![feature(this_is_not_a_feature)]\n \n-#![feature(this_is_not_a_feature)] //~ ERROR: unused or unknown feature\n+#![feature(rustc_attrs)]\n \n-fn main() { }\n+#[rustc_error]\n+fn main() { } //~ ERROR: compilation successful"}, {"sha": "d230297aaba01cbd108e4502bee0cd7023fd1569", "filename": "src/test/compile-fail/lint-unknown-feature.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unknown-feature.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -8,8 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(unused_features)]\n+#![warn(unused_features)]\n \n-#![feature(this_is_not_a_feature)] //~ ERROR: unused or unknown feature\n+// FIXME(#44232) we should warn that this isn't used.\n+#![feature(this_is_not_a_feature)]\n \n-fn main() {}\n+#![feature(rustc_attrs)]\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR: compilation successful"}, {"sha": "5993f4b5a0941add1e740afb04eb490c68f2e6b2", "filename": "src/test/compile-fail/stable-features.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Ftest%2Fcompile-fail%2Fstable-features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb/src%2Ftest%2Fcompile-fail%2Fstable-features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstable-features.rs?ref=9a231961d59135c7dc41d9b94ffe43ecc9bbd8cb", "patch": "@@ -12,8 +12,11 @@\n // language and lib features.\n \n #![deny(stable_features)]\n+\n #![feature(test_accepted_feature)] //~ ERROR this feature has been stable since 1.0.0\n-#![feature(rust1)] //~ ERROR this feature has been stable since 1.0.0\n+\n+// FIXME(#44232) we should error that this isn't used.\n+#![feature(rust1)]\n \n fn main() {\n     let _foo: Vec<()> = Vec::new();"}]}