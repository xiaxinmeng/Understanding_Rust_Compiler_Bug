{"sha": "051dae222164a04c703c5c0914a304d35206a62f", "node_id": "C_kwDOAAsO6NoAKDA1MWRhZTIyMjE2NGEwNGM3MDNjNWMwOTE0YTMwNGQzNTIwNmE2MmY", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-14T13:32:38Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-17T09:38:36Z"}, "message": "Support record pattern MIR lowering", "tree": {"sha": "f522caad698a662cae7cdfab71e75c6353eb4910", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f522caad698a662cae7cdfab71e75c6353eb4910"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/051dae222164a04c703c5c0914a304d35206a62f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/051dae222164a04c703c5c0914a304d35206a62f", "html_url": "https://github.com/rust-lang/rust/commit/051dae222164a04c703c5c0914a304d35206a62f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/051dae222164a04c703c5c0914a304d35206a62f/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "513e340bd344ee373847953baead3097f0b43815", "url": "https://api.github.com/repos/rust-lang/rust/commits/513e340bd344ee373847953baead3097f0b43815", "html_url": "https://github.com/rust-lang/rust/commit/513e340bd344ee373847953baead3097f0b43815"}], "stats": {"total": 262, "additions": 200, "deletions": 62}, "files": [{"sha": "1d298f96091aed074bf669b4644e62f8b95db341", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/051dae222164a04c703c5c0914a304d35206a62f/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051dae222164a04c703c5c0914a304d35206a62f/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=051dae222164a04c703c5c0914a304d35206a62f", "patch": "@@ -555,6 +555,38 @@ fn structs() {\n         \"#,\n         17,\n     );\n+    check_number(\n+        r#\"\n+        struct Point {\n+            x: i32,\n+            y: i32,\n+        }\n+\n+        const GOAL: i32 = {\n+            let p = Point { x: 5, y: 2 };\n+            let p2 = Point { x: 3, ..p };\n+            p.x * 1000 + p.y * 100 + p2.x * 10 + p2.y\n+        };\n+        \"#,\n+        5232,\n+    );\n+    check_number(\n+        r#\"\n+        struct Point {\n+            x: i32,\n+            y: i32,\n+        }\n+\n+        const GOAL: i32 = {\n+            let p = Point { x: 5, y: 2 };\n+            let Point { x, y } = p;\n+            let Point { x: x2, .. } = p;\n+            let Point { y: y2, .. } = p;\n+            x * 1000 + y * 100 + x2 * 10 + y2\n+        };\n+        \"#,\n+        5252,\n+    );\n }\n \n #[test]\n@@ -599,13 +631,14 @@ fn tuples() {\n     );\n     check_number(\n         r#\"\n-    struct TupleLike(i32, u8, i64, u16);\n-    const GOAL: u8 = {\n+    struct TupleLike(i32, i64, u8, u16);\n+    const GOAL: i64 = {\n         let a = TupleLike(10, 20, 3, 15);\n-        a.1\n+        let TupleLike(b, .., c) = a;\n+        a.1 * 100 + b as i64 + c as i64\n     };\n         \"#,\n-        20,\n+        2025,\n     );\n     check_number(\n         r#\""}, {"sha": "2003d24038b1d89e4ffba040ae587c343e0447de", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/051dae222164a04c703c5c0914a304d35206a62f/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051dae222164a04c703c5c0914a304d35206a62f/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=051dae222164a04c703c5c0914a304d35206a62f", "patch": "@@ -711,12 +711,13 @@ pub fn is_dyn_method(\n     };\n     let self_ty = trait_ref.self_type_parameter(Interner);\n     if let TyKind::Dyn(d) = self_ty.kind(Interner) {\n-        let is_my_trait_in_bounds = d.bounds.skip_binders().as_slice(Interner).iter().any(|x| match x.skip_binders() {\n-            // rustc doesn't accept `impl Foo<2> for dyn Foo<5>`, so if the trait id is equal, no matter\n-            // what the generics are, we are sure that the method is come from the vtable.\n-            WhereClause::Implemented(tr) => tr.trait_id == trait_ref.trait_id,\n-            _ => false,\n-        });\n+        let is_my_trait_in_bounds =\n+            d.bounds.skip_binders().as_slice(Interner).iter().any(|x| match x.skip_binders() {\n+                // rustc doesn't accept `impl Foo<2> for dyn Foo<5>`, so if the trait id is equal, no matter\n+                // what the generics are, we are sure that the method is come from the vtable.\n+                WhereClause::Implemented(tr) => tr.trait_id == trait_ref.trait_id,\n+                _ => false,\n+            });\n         if is_my_trait_in_bounds {\n             return Some(fn_params);\n         }"}, {"sha": "787665bb637a4b617204f850014df8c1553c5aaf", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/051dae222164a04c703c5c0914a304d35206a62f/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051dae222164a04c703c5c0914a304d35206a62f/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=051dae222164a04c703c5c0914a304d35206a62f", "patch": "@@ -25,8 +25,8 @@ use crate::{\n     mapping::from_chalk,\n     method_resolution::{is_dyn_method, lookup_impl_method},\n     traits::FnTrait,\n-    CallableDefId, Const, ConstScalar, FnDefId, Interner, MemoryMap, Substitution,\n-    TraitEnvironment, Ty, TyBuilder, TyExt, GenericArgData,\n+    CallableDefId, Const, ConstScalar, FnDefId, GenericArgData, Interner, MemoryMap, Substitution,\n+    TraitEnvironment, Ty, TyBuilder, TyExt,\n };\n \n use super::{\n@@ -1315,10 +1315,13 @@ impl Evaluator<'_> {\n                 args_for_target[0] = args_for_target[0][0..self.ptr_size()].to_vec();\n                 let generics_for_target = Substitution::from_iter(\n                     Interner,\n-                    generic_args\n-                        .iter(Interner)\n-                        .enumerate()\n-                        .map(|(i, x)| if i == self_ty_idx { &ty } else { x })\n+                    generic_args.iter(Interner).enumerate().map(|(i, x)| {\n+                        if i == self_ty_idx {\n+                            &ty\n+                        } else {\n+                            x\n+                        }\n+                    }),\n                 );\n                 return self.exec_fn_with_args(\n                     def,"}, {"sha": "d36d9e946ca8cfbcd88497d27ba972788c249888", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 146, "deletions": 45, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/051dae222164a04c703c5c0914a304d35206a62f/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051dae222164a04c703c5c0914a304d35206a62f/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=051dae222164a04c703c5c0914a304d35206a62f", "patch": "@@ -4,16 +4,17 @@ use std::{iter, mem, sync::Arc};\n \n use chalk_ir::{BoundVar, ConstData, DebruijnIndex, TyKind};\n use hir_def::{\n+    adt::VariantData,\n     body::Body,\n     expr::{\n         Array, BindingAnnotation, BindingId, ExprId, LabelId, Literal, MatchArm, Pat, PatId,\n-        RecordLitField,\n+        RecordFieldPat, RecordLitField,\n     },\n     lang_item::{LangItem, LangItemTarget},\n     layout::LayoutError,\n     path::Path,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n-    DefWithBodyId, EnumVariantId, HasModule, ItemContainerId, TraitId,\n+    DefWithBodyId, EnumVariantId, HasModule, ItemContainerId, LocalFieldId, TraitId,\n };\n use hir_expand::name::Name;\n use la_arena::ArenaMap;\n@@ -106,6 +107,12 @@ impl MirLowerError {\n \n type Result<T> = std::result::Result<T, MirLowerError>;\n \n+enum AdtPatternShape<'a> {\n+    Tuple { args: &'a [PatId], ellipsis: Option<usize> },\n+    Record { args: &'a [RecordFieldPat] },\n+    Unit,\n+}\n+\n impl MirLowerCtx<'_> {\n     fn temp(&mut self, ty: Ty) -> Result<LocalId> {\n         if matches!(ty.kind(Interner), TyKind::Slice(_) | TyKind::Dyn(_)) {\n@@ -444,7 +451,8 @@ impl MirLowerCtx<'_> {\n                         current,\n                         pat.into(),\n                         Some(end),\n-                        &[pat], &None)?;\n+                        AdtPatternShape::Tuple { args: &[pat], ellipsis: None },\n+                    )?;\n                     if let Some((_, block)) = this.lower_expr_as_place(current, body, true)? {\n                         this.set_goto(block, begin);\n                     }\n@@ -573,7 +581,17 @@ impl MirLowerCtx<'_> {\n                 Ok(None)\n             }\n             Expr::Yield { .. } => not_supported!(\"yield\"),\n-            Expr::RecordLit { fields, path, .. } => {\n+            Expr::RecordLit { fields, path, spread, ellipsis: _, is_assignee_expr: _ } => {\n+                let spread_place = match spread {\n+                    &Some(x) => {\n+                        let Some((p, c)) = self.lower_expr_as_place(current, x, true)? else {\n+                            return Ok(None);\n+                        };\n+                        current = c;\n+                        Some(p)\n+                    },\n+                    None => None,\n+                };\n                 let variant_id = self\n                     .infer\n                     .variant_resolution_for_expr(expr_id)\n@@ -603,9 +621,24 @@ impl MirLowerCtx<'_> {\n                             place,\n                             Rvalue::Aggregate(\n                                 AggregateKind::Adt(variant_id, subst),\n-                                operands.into_iter().map(|x| x).collect::<Option<_>>().ok_or(\n-                                    MirLowerError::TypeError(\"missing field in record literal\"),\n-                                )?,\n+                                match spread_place {\n+                                    Some(sp) => operands.into_iter().enumerate().map(|(i, x)| {\n+                                        match x {\n+                                            Some(x) => x,\n+                                            None => {\n+                                                let mut p = sp.clone();\n+                                                p.projection.push(ProjectionElem::Field(FieldId {\n+                                                    parent: variant_id,\n+                                                    local_id: LocalFieldId::from_raw(RawIdx::from(i as u32)),\n+                                                }));\n+                                                Operand::Copy(p)\n+                                            },\n+                                        }\n+                                    }).collect(),\n+                                    None => operands.into_iter().map(|x| x).collect::<Option<_>>().ok_or(\n+                                        MirLowerError::TypeError(\"missing field in record literal\"),\n+                                    )?,\n+                                },\n                             ),\n                             expr_id.into(),\n                         );\n@@ -1021,14 +1054,11 @@ impl MirLowerCtx<'_> {\n                 self.pattern_match_tuple_like(\n                     current,\n                     current_else,\n-                    args.iter().enumerate().map(|(i, x)| {\n-                        (\n-                            PlaceElem::TupleField(i),\n-                            *x,\n-                            subst.at(Interner, i).assert_ty_ref(Interner).clone(),\n-                        )\n-                    }),\n+                    args,\n                     *ellipsis,\n+                    subst.iter(Interner).enumerate().map(|(i, x)| {\n+                        (PlaceElem::TupleField(i), x.assert_ty_ref(Interner).clone())\n+                    }),\n                     &cond_place,\n                     binding_mode,\n                 )?\n@@ -1062,7 +1092,21 @@ impl MirLowerCtx<'_> {\n                 }\n                 (then_target, current_else)\n             }\n-            Pat::Record { .. } => not_supported!(\"record pattern\"),\n+            Pat::Record { args, .. } => {\n+                let Some(variant) = self.infer.variant_resolution_for_pat(pattern) else {\n+                    not_supported!(\"unresolved variant\");\n+                };\n+                self.pattern_matching_variant(\n+                    cond_ty,\n+                    binding_mode,\n+                    cond_place,\n+                    variant,\n+                    current,\n+                    pattern.into(),\n+                    current_else,\n+                    AdtPatternShape::Record { args: &*args },\n+                )?\n+            }\n             Pat::Range { .. } => not_supported!(\"range pattern\"),\n             Pat::Slice { .. } => not_supported!(\"slice pattern\"),\n             Pat::Path(_) => {\n@@ -1077,8 +1121,7 @@ impl MirLowerCtx<'_> {\n                     current,\n                     pattern.into(),\n                     current_else,\n-                    &[],\n-                    &None,\n+                    AdtPatternShape::Unit,\n                 )?\n             }\n             Pat::Lit(l) => {\n@@ -1160,8 +1203,7 @@ impl MirLowerCtx<'_> {\n                     current,\n                     pattern.into(),\n                     current_else,\n-                    args,\n-                    ellipsis,\n+                    AdtPatternShape::Tuple { args, ellipsis: *ellipsis },\n                 )?\n             }\n             Pat::Ref { .. } => not_supported!(\"& pattern\"),\n@@ -1179,15 +1221,13 @@ impl MirLowerCtx<'_> {\n         current: BasicBlockId,\n         span: MirSpan,\n         current_else: Option<BasicBlockId>,\n-        args: &[PatId],\n-        ellipsis: &Option<usize>,\n+        shape: AdtPatternShape<'_>,\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n         pattern_matching_dereference(&mut cond_ty, &mut binding_mode, &mut cond_place);\n         let subst = match cond_ty.kind(Interner) {\n             TyKind::Adt(_, s) => s,\n             _ => return Err(MirLowerError::TypeError(\"non adt type matched with tuple struct\")),\n         };\n-        let fields_type = self.db.field_types(variant);\n         Ok(match variant {\n             VariantId::EnumVariantId(v) => {\n                 let e = self.db.const_eval_discriminant(v)? as u128;\n@@ -1208,57 +1248,99 @@ impl MirLowerCtx<'_> {\n                     },\n                 );\n                 let enum_data = self.db.enum_data(v.parent);\n-                let fields =\n-                    enum_data.variants[v.local_id].variant_data.fields().iter().map(|(x, _)| {\n-                        (\n-                            PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n-                            fields_type[x].clone().substitute(Interner, subst),\n-                        )\n-                    });\n-                self.pattern_match_tuple_like(\n+                self.pattern_matching_variant_fields(\n+                    shape,\n+                    &enum_data.variants[v.local_id].variant_data,\n+                    variant,\n+                    subst,\n                     next,\n                     Some(else_target),\n-                    args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n-                    *ellipsis,\n                     &cond_place,\n                     binding_mode,\n                 )?\n             }\n             VariantId::StructId(s) => {\n                 let struct_data = self.db.struct_data(s);\n-                let fields = struct_data.variant_data.fields().iter().map(|(x, _)| {\n+                self.pattern_matching_variant_fields(\n+                    shape,\n+                    &struct_data.variant_data,\n+                    variant,\n+                    subst,\n+                    current,\n+                    current_else,\n+                    &cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            VariantId::UnionId(_) => {\n+                return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n+            }\n+        })\n+    }\n+\n+    fn pattern_matching_variant_fields(\n+        &mut self,\n+        shape: AdtPatternShape<'_>,\n+        variant_data: &VariantData,\n+        v: VariantId,\n+        subst: &Substitution,\n+        current: BasicBlockId,\n+        current_else: Option<BasicBlockId>,\n+        cond_place: &Place,\n+        binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let fields_type = self.db.field_types(v);\n+        Ok(match shape {\n+            AdtPatternShape::Record { args } => {\n+                let it = args\n+                    .iter()\n+                    .map(|x| {\n+                        let field_id =\n+                            variant_data.field(&x.name).ok_or(MirLowerError::UnresolvedField)?;\n+                        Ok((\n+                            PlaceElem::Field(FieldId { parent: v.into(), local_id: field_id }),\n+                            x.pat,\n+                            fields_type[field_id].clone().substitute(Interner, subst),\n+                        ))\n+                    })\n+                    .collect::<Result<Vec<_>>>()?;\n+                self.pattern_match_adt(\n+                    current,\n+                    current_else,\n+                    it.into_iter(),\n+                    cond_place,\n+                    binding_mode,\n+                )?\n+            }\n+            AdtPatternShape::Tuple { args, ellipsis } => {\n+                let fields = variant_data.fields().iter().map(|(x, _)| {\n                     (\n-                        PlaceElem::Field(FieldId { parent: s.into(), local_id: x }),\n+                        PlaceElem::Field(FieldId { parent: v.into(), local_id: x }),\n                         fields_type[x].clone().substitute(Interner, subst),\n                     )\n                 });\n                 self.pattern_match_tuple_like(\n                     current,\n                     current_else,\n-                    args.iter().zip(fields).map(|(x, y)| (y.0, *x, y.1)),\n-                    *ellipsis,\n-                    &cond_place,\n+                    args,\n+                    ellipsis,\n+                    fields,\n+                    cond_place,\n                     binding_mode,\n                 )?\n             }\n-            VariantId::UnionId(_) => {\n-                return Err(MirLowerError::TypeError(\"pattern matching on union\"))\n-            }\n+            AdtPatternShape::Unit => (current, current_else),\n         })\n     }\n \n-    fn pattern_match_tuple_like(\n+    fn pattern_match_adt(\n         &mut self,\n         mut current: BasicBlockId,\n         mut current_else: Option<BasicBlockId>,\n         args: impl Iterator<Item = (PlaceElem, PatId, Ty)>,\n-        ellipsis: Option<usize>,\n         cond_place: &Place,\n         binding_mode: BindingAnnotation,\n     ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n-        if ellipsis.is_some() {\n-            not_supported!(\"tuple like pattern with ellipsis\");\n-        }\n         for (proj, arg, ty) in args {\n             let mut cond_place = cond_place.clone();\n             cond_place.projection.push(proj);\n@@ -1268,6 +1350,25 @@ impl MirLowerCtx<'_> {\n         Ok((current, current_else))\n     }\n \n+    fn pattern_match_tuple_like(\n+        &mut self,\n+        current: BasicBlockId,\n+        current_else: Option<BasicBlockId>,\n+        args: &[PatId],\n+        ellipsis: Option<usize>,\n+        fields: impl DoubleEndedIterator<Item = (PlaceElem, Ty)> + Clone,\n+        cond_place: &Place,\n+        binding_mode: BindingAnnotation,\n+    ) -> Result<(BasicBlockId, Option<BasicBlockId>)> {\n+        let (al, ar) = args.split_at(ellipsis.unwrap_or(args.len()));\n+        let it = al\n+            .iter()\n+            .zip(fields.clone())\n+            .chain(ar.iter().rev().zip(fields.rev()))\n+            .map(|(x, y)| (y.0, *x, y.1));\n+        self.pattern_match_adt(current, current_else, it, cond_place, binding_mode)\n+    }\n+\n     fn discr_temp_place(&mut self) -> Place {\n         match &self.discr_temp {\n             Some(x) => x.clone(),"}, {"sha": "f6597efd8fd279363e9090d8e035b74931149ce8", "filename": "lib/la-arena/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/051dae222164a04c703c5c0914a304d35206a62f/lib%2Fla-arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/051dae222164a04c703c5c0914a304d35206a62f/lib%2Fla-arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lib%2Fla-arena%2Fsrc%2Flib.rs?ref=051dae222164a04c703c5c0914a304d35206a62f", "patch": "@@ -295,7 +295,7 @@ impl<T> Arena<T> {\n     /// ```\n     pub fn iter(\n         &self,\n-    ) -> impl Iterator<Item = (Idx<T>, &T)> + ExactSizeIterator + DoubleEndedIterator {\n+    ) -> impl Iterator<Item = (Idx<T>, &T)> + ExactSizeIterator + DoubleEndedIterator + Clone {\n         self.data.iter().enumerate().map(|(idx, value)| (Idx::from_raw(RawIdx(idx as u32)), value))\n     }\n "}]}