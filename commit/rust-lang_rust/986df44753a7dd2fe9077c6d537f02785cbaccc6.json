{"sha": "986df44753a7dd2fe9077c6d537f02785cbaccc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NmRmNDQ3NTNhN2RkMmZlOTA3N2M2ZDUzN2YwMjc4NWNiYWNjYzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-02T14:31:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-02T14:31:52Z"}, "message": "auto merge of #8195 : bblum/rust/task-cleanup, r=brson\n\nIn the first commit it is obvious why some of the barriers can be changed to ```Relaxed```, but it is not as obvious for the once I changed in ```kill.rs```. The rationale for those is documented as part of the documenting commit.\r\n\r\nAlso the last commit is a temporary hack to prevent kill signals from being received in taskgroup cleanup code, which could be fixed in a more principled way once the old runtime is gone.", "tree": {"sha": "7e3ea157e53f302f5f46caea676b86a9ec7ece69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e3ea157e53f302f5f46caea676b86a9ec7ece69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/986df44753a7dd2fe9077c6d537f02785cbaccc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/986df44753a7dd2fe9077c6d537f02785cbaccc6", "html_url": "https://github.com/rust-lang/rust/commit/986df44753a7dd2fe9077c6d537f02785cbaccc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/986df44753a7dd2fe9077c6d537f02785cbaccc6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af973397713806fdaf27b19e80637cc6a45d7278", "url": "https://api.github.com/repos/rust-lang/rust/commits/af973397713806fdaf27b19e80637cc6a45d7278", "html_url": "https://github.com/rust-lang/rust/commit/af973397713806fdaf27b19e80637cc6a45d7278"}, {"sha": "963d37e821590b470f7a1fc9cfcda5a5ceceeee4", "url": "https://api.github.com/repos/rust-lang/rust/commits/963d37e821590b470f7a1fc9cfcda5a5ceceeee4", "html_url": "https://github.com/rust-lang/rust/commit/963d37e821590b470f7a1fc9cfcda5a5ceceeee4"}], "stats": {"total": 123, "additions": 94, "deletions": 29}, "files": [{"sha": "00e1aaa2193252e1124185d7d1b3ff628de2443d", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/986df44753a7dd2fe9077c6d537f02785cbaccc6/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986df44753a7dd2fe9077c6d537f02785cbaccc6/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=986df44753a7dd2fe9077c6d537f02785cbaccc6", "patch": "@@ -18,7 +18,7 @@ use kinds::Send;\n use rt::sched::Scheduler;\n use rt::local::Local;\n use rt::select::{Select, SelectPort};\n-use unstable::atomics::{AtomicUint, AtomicOption, Acquire, Release, SeqCst};\n+use unstable::atomics::{AtomicUint, AtomicOption, Acquire, Relaxed, SeqCst};\n use unstable::sync::UnsafeAtomicRcBox;\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n@@ -217,15 +217,15 @@ impl<T> Select for PortOne<T> {\n                 }\n                 STATE_ONE => {\n                     // Re-record that we are the only owner of the packet.\n-                    // Release barrier needed in case the task gets reawoken\n-                    // on a different core (this is analogous to writing a\n-                    // payload; a barrier in enqueueing the task protects it).\n+                    // No barrier needed, even if the task gets reawoken\n+                    // on a different core -- this is analogous to writing a\n+                    // payload; a barrier in enqueueing the task protects it.\n                     // NB(#8132). This *must* occur before the enqueue below.\n                     // FIXME(#6842, #8130) This is usually only needed for the\n                     // assertion in recv_ready, except in the case of select().\n                     // This won't actually ever have cacheline contention, but\n                     // maybe should be optimized out with a cfg(test) anyway?\n-                    (*self.packet()).state.store(STATE_ONE, Release);\n+                    (*self.packet()).state.store(STATE_ONE, Relaxed);\n \n                     rtdebug!(\"rendezvous recv\");\n                     sched.metrics.rendezvous_recvs += 1;\n@@ -300,7 +300,7 @@ impl<T> SelectPort<T> for PortOne<T> {\n         unsafe {\n             // See corresponding store() above in block_on for rationale.\n             // FIXME(#8130) This can happen only in test builds.\n-            assert!((*packet).state.load(Acquire) == STATE_ONE);\n+            assert!((*packet).state.load(Relaxed) == STATE_ONE);\n \n             let payload = (*packet).payload.take();\n \n@@ -375,9 +375,7 @@ impl<T> Drop for PortOne<T> {\n                     // receiver was killed awake. The task can't still be\n                     // blocked (we are it), but we need to free the handle.\n                     let recvr = BlockedTask::cast_from_uint(task_as_state);\n-                    // FIXME(#7554)(bblum): Make this cfg(test) dependent.\n-                    // in a later commit.\n-                    assert!(recvr.wake().is_none());\n+                    recvr.assert_already_awake();\n                 }\n             }\n         }"}, {"sha": "696f4a8c35515083457f44a63de9a28ed705c932", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 76, "deletions": 12, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/986df44753a7dd2fe9077c6d537f02785cbaccc6/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986df44753a7dd2fe9077c6d537f02785cbaccc6/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=986df44753a7dd2fe9077c6d537f02785cbaccc6", "patch": "@@ -8,16 +8,73 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Task death: asynchronous killing, linked failure, exit code propagation.\n+/*!\n+\n+Task death: asynchronous killing, linked failure, exit code propagation.\n+\n+This file implements two orthogonal building-blocks for communicating failure\n+between tasks. One is 'linked failure' or 'task killing', that is, a failing\n+task causing other tasks to fail promptly (even those that are blocked on\n+pipes or I/O). The other is 'exit code propagation', which affects the result\n+observed by the parent of a task::try task that itself spawns child tasks\n+(such as any #[test] function). In both cases the data structures live in\n+KillHandle.\n+\n+I. Task killing.\n+\n+The model for killing involves two atomic flags, the \"kill flag\" and the\n+\"unkillable flag\". Operations on the kill flag include:\n+\n+- In the taskgroup code (task/spawn.rs), tasks store a clone of their\n+  KillHandle in their shared taskgroup. Another task in the group that fails\n+  will use that handle to call kill().\n+- When a task blocks, it turns its ~Task into a BlockedTask by storing a\n+  the transmuted ~Task pointer inside the KillHandle's kill flag. A task\n+  trying to block and a task trying to kill it can simultaneously access the\n+  kill flag, after which the task will get scheduled and fail (no matter who\n+  wins the race). Likewise, a task trying to wake a blocked task normally and\n+  a task trying to kill it can simultaneously access the flag; only one will\n+  get the task to reschedule it.\n+\n+Operations on the unkillable flag include:\n+\n+- When a task becomes unkillable, it swaps on the flag to forbid any killer\n+  from waking it up while it's blocked inside the unkillable section. If a\n+  kill was already pending, the task fails instead of becoming unkillable.\n+- When a task is done being unkillable, it restores the flag to the normal\n+  running state. If a kill was received-but-blocked during the unkillable\n+  section, the task fails at this later point.\n+- When a task tries to kill another task, before swapping on the kill flag, it\n+  first swaps on the unkillable flag, to see if it's \"allowed\" to wake up the\n+  task. If it isn't, the killed task will receive the signal when it becomes\n+  killable again. (Of course, a task trying to wake the task normally (e.g.\n+  sending on a channel) does not access the unkillable flag at all.)\n+\n+Why do we not need acquire/release barriers on any of the kill flag swaps?\n+This is because barriers establish orderings between accesses on different\n+memory locations, but each kill-related operation is only a swap on a single\n+location, so atomicity is all that matters. The exception is kill(), which\n+does a swap on both flags in sequence. kill() needs no barriers because it\n+does not matter if its two accesses are seen reordered on another CPU: if a\n+killer does perform both writes, it means it saw a KILL_RUNNING in the\n+unkillable flag, which means an unkillable task will see KILL_KILLED and fail\n+immediately (rendering the subsequent write to the kill flag unnecessary).\n+\n+II. Exit code propagation.\n+\n+FIXME(#7544): Decide on the ultimate model for this and document it.\n+\n+*/\n \n use cast;\n use cell::Cell;\n use either::{Either, Left, Right};\n use option::{Option, Some, None};\n use prelude::*;\n use rt::task::Task;\n+use task::spawn::Taskgroup;\n use to_bytes::IterBytes;\n-use unstable::atomics::{AtomicUint, Acquire, SeqCst};\n+use unstable::atomics::{AtomicUint, Relaxed};\n use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n use util;\n \n@@ -95,7 +152,7 @@ impl Drop for KillFlag {\n     // Letting a KillFlag with a task inside get dropped would leak the task.\n     // We could free it here, but the task should get awoken by hand somehow.\n     fn drop(&self) {\n-        match self.load(Acquire) {\n+        match self.load(Relaxed) {\n             KILL_RUNNING | KILL_KILLED => { },\n             _ => rtabort!(\"can't drop kill flag with a blocked task inside!\"),\n         }\n@@ -124,7 +181,7 @@ impl BlockedTask {\n             Unkillable(task) => Some(task),\n             Killable(flag_arc) => {\n                 let flag = unsafe { &mut **flag_arc.get() };\n-                match flag.swap(KILL_RUNNING, SeqCst) {\n+                match flag.swap(KILL_RUNNING, Relaxed) {\n                     KILL_RUNNING => None, // woken from select(), perhaps\n                     KILL_KILLED  => None, // a killer stole it already\n                     task_ptr     =>\n@@ -159,7 +216,7 @@ impl BlockedTask {\n                 let flag     = &mut **flag_arc.get();\n                 let task_ptr = cast::transmute(task);\n                 // Expect flag to contain RUNNING. If KILLED, it should stay KILLED.\n-                match flag.compare_and_swap(KILL_RUNNING, task_ptr, SeqCst) {\n+                match flag.compare_and_swap(KILL_RUNNING, task_ptr, Relaxed) {\n                     KILL_RUNNING => Right(Killable(flag_arc)),\n                     KILL_KILLED  => Left(revive_task_ptr(task_ptr, Some(flag_arc))),\n                     x            => rtabort!(\"can't block task! kill flag = %?\", x),\n@@ -257,7 +314,7 @@ impl KillHandle {\n         let inner = unsafe { &mut *self.get() };\n         // Expect flag to contain RUNNING. If KILLED, it should stay KILLED.\n         // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n-        match inner.unkillable.compare_and_swap(KILL_RUNNING, KILL_UNKILLABLE, SeqCst) {\n+        match inner.unkillable.compare_and_swap(KILL_RUNNING, KILL_UNKILLABLE, Relaxed) {\n             KILL_RUNNING    => { }, // normal case\n             KILL_KILLED     => if !already_failing { fail!(KILLED_MSG) },\n             _               => rtabort!(\"inhibit_kill: task already unkillable\"),\n@@ -270,7 +327,7 @@ impl KillHandle {\n         let inner = unsafe { &mut *self.get() };\n         // Expect flag to contain UNKILLABLE. If KILLED, it should stay KILLED.\n         // FIXME(#7544)(bblum): is it really necessary to prohibit double kill?\n-        match inner.unkillable.compare_and_swap(KILL_UNKILLABLE, KILL_RUNNING, SeqCst) {\n+        match inner.unkillable.compare_and_swap(KILL_UNKILLABLE, KILL_RUNNING, Relaxed) {\n             KILL_UNKILLABLE => { }, // normal case\n             KILL_KILLED     => if !already_failing { fail!(KILLED_MSG) },\n             _               => rtabort!(\"allow_kill: task already killable\"),\n@@ -281,10 +338,10 @@ impl KillHandle {\n     // if it was blocked and needs punted awake. To be called by other tasks.\n     pub fn kill(&mut self) -> Option<~Task> {\n         let inner = unsafe { &mut *self.get() };\n-        if inner.unkillable.swap(KILL_KILLED, SeqCst) == KILL_RUNNING {\n+        if inner.unkillable.swap(KILL_KILLED, Relaxed) == KILL_RUNNING {\n             // Got in. Allowed to try to punt the task awake.\n             let flag = unsafe { &mut *inner.killed.get() };\n-            match flag.swap(KILL_KILLED, SeqCst) {\n+            match flag.swap(KILL_KILLED, Relaxed) {\n                 // Task either not blocked or already taken care of.\n                 KILL_RUNNING | KILL_KILLED => None,\n                 // Got ownership of the blocked task.\n@@ -306,8 +363,11 @@ impl KillHandle {\n         // is unkillable with a kill signal pending.\n         let inner = unsafe { &*self.get() };\n         let flag  = unsafe { &*inner.killed.get() };\n-        // FIXME(#6598): can use relaxed ordering (i think)\n-        flag.load(Acquire) == KILL_KILLED\n+        // A barrier-related concern here is that a task that gets killed\n+        // awake needs to see the killer's write of KILLED to this flag. This\n+        // is analogous to receiving a pipe payload; the appropriate barrier\n+        // should happen when enqueueing the task.\n+        flag.load(Relaxed) == KILL_KILLED\n     }\n \n     pub fn notify_immediate_failure(&mut self) {\n@@ -415,7 +475,7 @@ impl Death {\n     }\n \n     /// Collect failure exit codes from children and propagate them to a parent.\n-    pub fn collect_failure(&mut self, mut success: bool) {\n+    pub fn collect_failure(&mut self, mut success: bool, group: Option<Taskgroup>) {\n         // This may run after the task has already failed, so even though the\n         // task appears to need to be killed, the scheduler should not fail us\n         // when we block to unwrap.\n@@ -425,6 +485,10 @@ impl Death {\n         rtassert!(self.unkillable == 0);\n         self.unkillable = 1;\n \n+        // FIXME(#7544): See corresponding fixme at the callsite in task.rs.\n+        // NB(#8192): Doesn't work with \"let _ = ...\"\n+        { use util; util::ignore(group); }\n+\n         // Step 1. Decide if we need to collect child failures synchronously.\n         do self.on_exit.take_map |on_exit| {\n             if success {"}, {"sha": "b242ee13fa66807a8ab119d9e3da189bfde4fc38", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/986df44753a7dd2fe9077c6d537f02785cbaccc6/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986df44753a7dd2fe9077c6d537f02785cbaccc6/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=986df44753a7dd2fe9077c6d537f02785cbaccc6", "patch": "@@ -212,8 +212,13 @@ impl Task {\n     pub fn run(&mut self, f: &fn()) {\n         rtdebug!(\"run called on task: %u\", borrow::to_uint(self));\n         self.unwinder.try(f);\n-        { let _ = self.taskgroup.take(); }\n-        self.death.collect_failure(!self.unwinder.unwinding);\n+        // FIXME(#7544): We pass the taskgroup into death so that it can be\n+        // dropped while the unkillable counter is set. This should not be\n+        // necessary except for an extraneous clone() in task/spawn.rs that\n+        // causes a killhandle to get dropped, which mustn't receive a kill\n+        // signal since we're outside of the unwinder's try() scope.\n+        // { let _ = self.taskgroup.take(); }\n+        self.death.collect_failure(!self.unwinder.unwinding, self.taskgroup.take());\n         self.destroy();\n     }\n "}, {"sha": "88c9c6ccb3aa4d9fc4af614a081f30c9f985615d", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/986df44753a7dd2fe9077c6d537f02785cbaccc6/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986df44753a7dd2fe9077c6d537f02785cbaccc6/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=986df44753a7dd2fe9077c6d537f02785cbaccc6", "patch": "@@ -16,7 +16,7 @@ use ptr;\n use option::*;\n use either::{Either, Left, Right};\n use task;\n-use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,SeqCst};\n+use unstable::atomics::{AtomicOption,AtomicUint,Acquire,Release,Relaxed,SeqCst};\n use unstable::finally::Finally;\n use ops::Drop;\n use clone::Clone;\n@@ -95,8 +95,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n     pub fn get(&self) -> *mut T {\n         unsafe {\n             let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-            // FIXME(#6598) Change Acquire to Relaxed.\n-            assert!(data.count.load(Acquire) > 0);\n+            assert!(data.count.load(Relaxed) > 0);\n             let r: *mut T = data.data.get_mut_ref();\n             cast::forget(data);\n             return r;\n@@ -107,7 +106,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n     pub fn get_immut(&self) -> *T {\n         unsafe {\n             let data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n-            assert!(data.count.load(Acquire) > 0); // no barrier is really needed\n+            assert!(data.count.load(Relaxed) > 0);\n             let r: *T = data.data.get_ref();\n             cast::forget(data);\n             return r;\n@@ -130,8 +129,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n                 // Try to put our server end in the unwrapper slot.\n                 // This needs no barrier -- it's protected by the release barrier on\n                 // the xadd, and the acquire+release barrier in the destructor's xadd.\n-                // FIXME(#6598) Change Acquire to Relaxed.\n-                if data.unwrapper.fill(~(c1,p2), Acquire).is_none() {\n+                if data.unwrapper.fill(~(c1,p2), Relaxed).is_none() {\n                     // Got in. Tell this handle's destructor not to run (we are now it).\n                     this.data = ptr::mut_null();\n                     // Drop our own reference."}]}