{"sha": "b7176b44a203322c834302f3b515f8c10a54f2c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3MTc2YjQ0YTIwMzMyMmM4MzQzMDJmM2I1MTVmOGMxMGE1NGYyYzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-27T09:35:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-27T09:35:12Z"}, "message": "Auto merge of #65519 - pnkfelix:issue-63438-trait-based-structural-match, r=matthewjasper\n\ntrait-based structural match implementation\n\nMoves from using a `#[structural_match]` attribute to using a marker trait (or pair of such traits, really) instead.\n\nFix #63438.\n\n(This however does not remove the hacks that I believe were put into place to support the previous approach of injecting the attribute based on the presence of both derives... I have left that for follow-on work.)", "tree": {"sha": "5f80b511b61d444c5e1fb772cc92f51ef3b1cea1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f80b511b61d444c5e1fb772cc92f51ef3b1cea1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7176b44a203322c834302f3b515f8c10a54f2c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7176b44a203322c834302f3b515f8c10a54f2c1", "html_url": "https://github.com/rust-lang/rust/commit/b7176b44a203322c834302f3b515f8c10a54f2c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7176b44a203322c834302f3b515f8c10a54f2c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf148a717a275741a35b5f51eab182aa42bd06a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf148a717a275741a35b5f51eab182aa42bd06a6", "html_url": "https://github.com/rust-lang/rust/commit/cf148a717a275741a35b5f51eab182aa42bd06a6"}, {"sha": "f645e90992d4f76a2c5e7f8b4656246769a285ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/f645e90992d4f76a2c5e7f8b4656246769a285ff", "html_url": "https://github.com/rust-lang/rust/commit/f645e90992d4f76a2c5e7f8b4656246769a285ff"}], "stats": {"total": 1086, "additions": 730, "deletions": 356}, "files": [{"sha": "1ac51291b93d790b8bfaa76c3b6a358da43254e5", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -211,7 +211,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// Derive macro generating an impl of the trait `PartialEq`.\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[allow_internal_unstable(core_intrinsics)]\n+#[allow_internal_unstable(core_intrinsics, structural_match)]\n pub macro PartialEq($item:item) { /* compiler built-in */ }\n \n /// Trait for equality comparisons which are [equivalence relations](\n@@ -273,7 +273,7 @@ pub trait Eq: PartialEq<Self> {\n /// Derive macro generating an impl of the trait `Eq`.\n #[rustc_builtin_macro]\n #[stable(feature = \"builtin_macro_prelude\", since = \"1.38.0\")]\n-#[allow_internal_unstable(core_intrinsics, derive_eq)]\n+#[allow_internal_unstable(core_intrinsics, derive_eq, structural_match)]\n pub macro Eq($item:item) { /* compiler built-in */ }\n \n // FIXME: this struct is used solely by #[derive] to"}, {"sha": "a25573feabb2bb02b7366d52d04f886b39ac56cd", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -126,6 +126,85 @@ pub trait Unsize<T: ?Sized> {\n     // Empty.\n }\n \n+/// Required trait for constants used in pattern matches.\n+///\n+/// Any type that derives `PartialEq` automatically implements this trait,\n+/// *regardless* of whether its type-parameters implement `Eq`.\n+///\n+/// If a `const` item contains some type that does not implement this trait,\n+/// then that type either (1.) does not implement `PartialEq` (which means the\n+/// constant will not provide that comparison method, which code generation\n+/// assumes is available), or (2.) it implements *its own* version of\n+/// `PartialEq` (which we assume does not conform to a structural-equality\n+/// comparison).\n+///\n+/// In either of the two scenarios above, we reject usage of such a constant in\n+/// a pattern match.\n+///\n+/// See also the [structural match RFC][RFC1445], and [issue 63438][] which\n+/// motivated migrating from attribute-based design to this trait.\n+///\n+/// [RFC1445]: https://github.com/rust-lang/rfcs/blob/master/text/1445-restrict-constants-in-patterns.md\n+/// [issue 63438]: https://github.com/rust-lang/rust/issues/63438\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"structural_match\", issue = \"31434\")]\n+#[rustc_on_unimplemented(message=\"the type `{Self}` does not `#[derive(PartialEq)]`\")]\n+#[lang = \"structural_peq\"]\n+pub trait StructuralPartialEq {\n+    // Empty.\n+}\n+\n+/// Required trait for constants used in pattern matches.\n+///\n+/// Any type that derives `Eq` automatically implements this trait, *regardless*\n+/// of whether its type-parameters implement `Eq`.\n+///\n+/// This is a hack to workaround a limitation in our type-system.\n+///\n+/// Background:\n+///\n+/// We want to require that types of consts used in pattern matches\n+/// have the attribute `#[derive(PartialEq, Eq)]`.\n+///\n+/// In a more ideal world, we could check that requirement by just checking that\n+/// the given type implements both (1.) the `StructuralPartialEq` trait *and*\n+/// (2.) the `Eq` trait. However, you can have ADTs that *do* `derive(PartialEq, Eq)`,\n+/// and be a case that we want the compiler to accept, and yet the constant's\n+/// type fails to implement `Eq`.\n+///\n+/// Namely, a case like this:\n+///\n+/// ```rust\n+/// #[derive(PartialEq, Eq)]\n+/// struct Wrap<X>(X);\n+/// fn higher_order(_: &()) { }\n+/// const CFN: Wrap<fn(&())> = Wrap(higher_order);\n+/// fn main() {\n+///     match CFN {\n+///         CFN => {}\n+///         _ => {}\n+///     }\n+/// }\n+/// ```\n+///\n+/// (The problem in the above code is that `Wrap<fn(&())>` does not implement\n+/// `PartialEq`, nor `Eq`, because `for<'a> fn(&'a _)` does not implement those\n+/// traits.)\n+///\n+/// Therefore, we cannot rely on naive check for `StructuralPartialEq` and\n+/// mere `Eq`.\n+///\n+/// As a hack to work around this, we use two separate traits injected by each\n+/// of the two derives (`#[derive(PartialEq)]` and `#[derive(Eq)]`) and check\n+/// that both of them are present as part of structural-match checking.\n+#[cfg(not(bootstrap))]\n+#[unstable(feature = \"structural_match\", issue = \"31434\")]\n+#[rustc_on_unimplemented(message=\"the type `{Self}` does not `#[derive(Eq)]`\")]\n+#[lang = \"structural_teq\"]\n+pub trait StructuralEq {\n+    // Empty.\n+}\n+\n /// Types whose values can be duplicated simply by copying bits.\n ///\n /// By default, variable bindings have 'move semantics.' In other\n@@ -437,6 +516,14 @@ macro_rules! impls{\n                 $t\n             }\n         }\n+\n+        #[cfg(not(bootstrap))]\n+        #[unstable(feature = \"structural_match\", issue = \"31434\")]\n+        impl<T: ?Sized> StructuralPartialEq for $t<T> { }\n+\n+        #[cfg(not(bootstrap))]\n+        #[unstable(feature = \"structural_match\", issue = \"31434\")]\n+        impl<T: ?Sized> StructuralEq for $t<T> { }\n         )\n }\n "}, {"sha": "0db79785282a3e986f3d75e83c5ba8e937321039", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -297,6 +297,10 @@ language_item_table! {\n \n     SizedTraitLangItem,          \"sized\",              sized_trait,             Target::Trait;\n     UnsizeTraitLangItem,         \"unsize\",             unsize_trait,            Target::Trait;\n+    // trait injected by #[derive(PartialEq)], (i.e. \"Partial EQ\").\n+    StructuralPeqTraitLangItem,  \"structural_peq\",     structural_peq_trait,    Target::Trait;\n+    // trait injected by #[derive(Eq)], (i.e. \"Total EQ\"; no, I will not apologize).\n+    StructuralTeqTraitLangItem,  \"structural_teq\",     structural_teq_trait,    Target::Trait;\n     CopyTraitLangItem,           \"copy\",               copy_trait,              Target::Trait;\n     CloneTraitLangItem,          \"clone\",              clone_trait,             Target::Trait;\n     SyncTraitLangItem,           \"sync\",               sync_trait,              Target::Trait;"}, {"sha": "b2e5624f4760c94a756303b849526f235287e474", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -2167,6 +2167,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ObligationCauseCode::ConstSized => {\n                 err.note(\"constant expressions must have a statically known size\");\n             }\n+            ObligationCauseCode::ConstPatternStructural => {\n+                err.note(\"constants used for pattern-matching must derive `PartialEq` and `Eq`\");\n+            }\n             ObligationCauseCode::SharedStatic => {\n                 err.note(\"shared static variables must have a type that implements `Sync`\");\n             }"}, {"sha": "04c1b4d927a9c762245425b2be587f34a4f544e7", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -239,6 +239,9 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Computing common supertype in the pattern guard for the arms of a match expression\n     MatchExpressionArmPattern { span: Span, ty: Ty<'tcx> },\n \n+    /// Constants in patterns must have `Structural` type.\n+    ConstPatternStructural,\n+\n     /// Computing common supertype in an if expression\n     IfExpression(Box<IfExpressionCause>),\n "}, {"sha": "d9b796d063e2631ece96f46d89ea525cadd4be31", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -497,6 +497,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::RepeatVec => Some(super::RepeatVec),\n             super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n             super::ConstSized => Some(super::ConstSized),\n+            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n             super::SharedStatic => Some(super::SharedStatic),\n             super::BuiltinDerivedObligation(ref cause) => {\n                 tcx.lift(cause).map(super::BuiltinDerivedObligation)"}, {"sha": "260b525507e80dc5843740d041b8bf3d52609c72", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 125, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -51,7 +51,7 @@ use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n \n use smallvec;\n-use rustc_data_structures::fx::{FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxIndexMap};\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_index::vec::{Idx, IndexVec};\n \n@@ -84,6 +84,10 @@ pub use self::context::{\n \n pub use self::instance::{Instance, InstanceDef};\n \n+pub use self::structural_match::search_for_structural_match_violation;\n+pub use self::structural_match::type_marked_structural;\n+pub use self::structural_match::NonStructuralMatchTy;\n+\n pub use self::trait_def::TraitDef;\n \n pub use self::query::queries;\n@@ -116,6 +120,7 @@ pub mod util;\n mod context;\n mod instance;\n mod structural_impls;\n+mod structural_match;\n mod sty;\n \n // Data types\n@@ -3396,130 +3401,6 @@ fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n     fn_like.asyncness()\n }\n \n-pub enum NonStructuralMatchTy<'tcx> {\n-    Adt(&'tcx AdtDef),\n-    Param,\n-}\n-\n-/// This method traverses the structure of `ty`, trying to find an\n-/// instance of an ADT (i.e. struct or enum) that was declared without\n-/// the `#[structural_match]` attribute, or a generic type parameter\n-/// (which cannot be determined to be `structural_match`).\n-///\n-/// The \"structure of a type\" includes all components that would be\n-/// considered when doing a pattern match on a constant of that\n-/// type.\n-///\n-///  * This means this method descends into fields of structs/enums,\n-///    and also descends into the inner type `T` of `&T` and `&mut T`\n-///\n-///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n-///    `*mut T`), and it does not visit the type arguments of an\n-///    instantiated generic like `PhantomData<T>`.\n-///\n-/// The reason we do this search is Rust currently require all ADTs\n-/// reachable from a constant's type to be annotated with\n-/// `#[structural_match]`, an attribute which essentially says that\n-/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n-/// comparison against the unfolded structure.\n-///\n-/// For more background on why Rust has this requirement, and issues\n-/// that arose when the requirement was not enforced completely, see\n-/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n-pub fn search_for_structural_match_violation<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Option<NonStructuralMatchTy<'tcx>> {\n-    let mut search = Search { tcx, found: None, seen: FxHashSet::default() };\n-    ty.visit_with(&mut search);\n-    return search.found;\n-\n-    struct Search<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        // Records the first ADT or type parameter we find without `#[structural_match`.\n-        found: Option<NonStructuralMatchTy<'tcx>>,\n-\n-        // Tracks ADTs previously encountered during search, so that\n-        // we will not recurse on them again.\n-        seen: FxHashSet<hir::def_id::DefId>,\n-    }\n-\n-    impl<'tcx> TypeVisitor<'tcx> for Search<'tcx> {\n-        fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-            debug!(\"Search visiting ty: {:?}\", ty);\n-\n-            let (adt_def, substs) = match ty.kind {\n-                ty::Adt(adt_def, substs) => (adt_def, substs),\n-                ty::Param(_) => {\n-                    self.found = Some(NonStructuralMatchTy::Param);\n-                    return true; // Stop visiting.\n-                }\n-                ty::RawPtr(..) => {\n-                    // `#[structural_match]` ignores substructure of\n-                    // `*const _`/`*mut _`, so skip super_visit_with\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::FnDef(..) | ty::FnPtr(..) => {\n-                    // types of formals and return in `fn(_) -> _` are also irrelevant\n-                    //\n-                    // (But still tell caller to continue search.)\n-                    return false;\n-                }\n-                ty::Array(_, n) if n.try_eval_usize(self.tcx, ty::ParamEnv::reveal_all()) == Some(0)\n-                => {\n-                    // rust-lang/rust#62336: ignore type of contents\n-                    // for empty array.\n-                    return false;\n-                }\n-                _ => {\n-                    ty.super_visit_with(self);\n-                    return false;\n-                }\n-            };\n-\n-            if !self.tcx.has_attr(adt_def.did, sym::structural_match) {\n-                self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n-                debug!(\"Search found adt_def: {:?}\", adt_def);\n-                return true; // Stop visiting.\n-            }\n-\n-            if !self.seen.insert(adt_def.did) {\n-                debug!(\"Search already seen adt_def: {:?}\", adt_def);\n-                // let caller continue its search\n-                return false;\n-            }\n-\n-            // `#[structural_match]` does not care about the\n-            // instantiation of the generics in an ADT (it\n-            // instead looks directly at its fields outside\n-            // this match), so we skip super_visit_with.\n-            //\n-            // (Must not recur on substs for `PhantomData<T>` cf\n-            // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n-            // want to skip substs when only uses of generic are\n-            // behind unsafe pointers `*const T`/`*mut T`.)\n-\n-            // even though we skip super_visit_with, we must recur on\n-            // fields of ADT.\n-            let tcx = self.tcx;\n-            for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n-                if field_ty.visit_with(self) {\n-                    // found an ADT without `#[structural_match]`; halt visiting!\n-                    assert!(self.found.is_some());\n-                    return true;\n-                }\n-            }\n-\n-            // Even though we do not want to recur on substs, we do\n-            // want our caller to continue its own search.\n-            false\n-        }\n-    }\n-}\n-\n pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);"}, {"sha": "cdf5734f5a50673e4d0bf5eab1674c7932ebb535", "filename": "src/librustc/ty/structural_match.rs", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Fty%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc%2Fty%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_match.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -0,0 +1,209 @@\n+use crate::hir;\n+use rustc::infer::InferCtxt;\n+use rustc::traits::{self, ConstPatternStructural, TraitEngine};\n+use rustc::traits::ObligationCause;\n+\n+use rustc_data_structures::fx::{FxHashSet};\n+\n+use syntax_pos::Span;\n+\n+use crate::ty::{self, AdtDef, Ty, TyCtxt};\n+use crate::ty::fold::{TypeFoldable, TypeVisitor};\n+\n+#[derive(Debug)]\n+pub enum NonStructuralMatchTy<'tcx> {\n+    Adt(&'tcx AdtDef),\n+    Param,\n+}\n+\n+/// This method traverses the structure of `ty`, trying to find an\n+/// instance of an ADT (i.e. struct or enum) that was declared without\n+/// the `#[structural_match]` attribute, or a generic type parameter\n+/// (which cannot be determined to be `structural_match`).\n+///\n+/// The \"structure of a type\" includes all components that would be\n+/// considered when doing a pattern match on a constant of that\n+/// type.\n+///\n+///  * This means this method descends into fields of structs/enums,\n+///    and also descends into the inner type `T` of `&T` and `&mut T`\n+///\n+///  * The traversal doesn't dereference unsafe pointers (`*const T`,\n+///    `*mut T`), and it does not visit the type arguments of an\n+///    instantiated generic like `PhantomData<T>`.\n+///\n+/// The reason we do this search is Rust currently require all ADTs\n+/// reachable from a constant's type to be annotated with\n+/// `#[structural_match]`, an attribute which essentially says that\n+/// the implementation of `PartialEq::eq` behaves *equivalently* to a\n+/// comparison against the unfolded structure.\n+///\n+/// For more background on why Rust has this requirement, and issues\n+/// that arose when the requirement was not enforced completely, see\n+/// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n+pub fn search_for_structural_match_violation<'tcx>(\n+    id: hir::HirId,\n+    span: Span,\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<NonStructuralMatchTy<'tcx>> {\n+    // FIXME: we should instead pass in an `infcx` from the outside.\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let mut search = Search { id, span, infcx, found: None, seen: FxHashSet::default() };\n+        ty.visit_with(&mut search);\n+        search.found\n+    })\n+}\n+\n+/// This method returns true if and only if `adt_ty` itself has been marked as\n+/// eligible for structural-match: namely, if it implements both\n+/// `StructuralPartialEq` and `StructuralEq` (which are respectively injected by\n+/// `#[derive(PartialEq)]` and `#[derive(Eq)]`).\n+///\n+/// Note that this does *not* recursively check if the substructure of `adt_ty`\n+/// implements the traits.\n+pub fn type_marked_structural(id: hir::HirId,\n+                              span: Span,\n+                              infcx: &InferCtxt<'_, 'tcx>,\n+                              adt_ty: Ty<'tcx>)\n+                              -> bool\n+{\n+    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n+    // require `#[derive(PartialEq)]`\n+    let structural_peq_def_id = infcx.tcx.lang_items().structural_peq_trait().unwrap();\n+    fulfillment_cx.register_bound(\n+        infcx, ty::ParamEnv::empty(), adt_ty, structural_peq_def_id, cause);\n+    // for now, require `#[derive(Eq)]`. (Doing so is a hack to work around\n+    // the type `for<'a> fn(&'a ())` failing to implement `Eq` itself.)\n+    let cause = ObligationCause::new(span, id, ConstPatternStructural);\n+    let structural_teq_def_id = infcx.tcx.lang_items().structural_teq_trait().unwrap();\n+    fulfillment_cx.register_bound(\n+        infcx, ty::ParamEnv::empty(), adt_ty, structural_teq_def_id, cause);\n+\n+    // We deliberately skip *reporting* fulfillment errors (via\n+    // `report_fulfillment_errors`), for two reasons:\n+    //\n+    // 1. The error messages would mention `std::marker::StructuralPartialEq`\n+    //    (a trait which is solely meant as an implementation detail\n+    //    for now), and\n+    //\n+    // 2. We are sometimes doing future-incompatibility lints for\n+    //    now, so we do not want unconditional errors here.\n+    fulfillment_cx.select_all_or_error(infcx).is_ok()\n+}\n+\n+/// This implements the traversal over the structure of a given type to try to\n+/// find instances of ADTs (specifically structs or enums) that do not implement\n+/// the structural-match traits (`StructuralPartialEq` and `StructuralEq`).\n+struct Search<'a, 'tcx> {\n+    id: hir::HirId,\n+    span: Span,\n+\n+    infcx: InferCtxt<'a, 'tcx>,\n+\n+    /// Records first ADT that does not implement a structural-match trait.\n+    found: Option<NonStructuralMatchTy<'tcx>>,\n+\n+    /// Tracks ADTs previously encountered during search, so that\n+    /// we will not recur on them again.\n+    seen: FxHashSet<hir::def_id::DefId>,\n+}\n+\n+impl Search<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn type_marked_structural(&self, adt_ty: Ty<'tcx>) -> bool {\n+        type_marked_structural(self.id, self.span, &self.infcx, adt_ty)\n+    }\n+}\n+\n+impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        debug!(\"Search visiting ty: {:?}\", ty);\n+\n+        let (adt_def, substs) = match ty.kind {\n+            ty::Adt(adt_def, substs) => (adt_def, substs),\n+            ty::Param(_) => {\n+                self.found = Some(NonStructuralMatchTy::Param);\n+                return true; // Stop visiting.\n+            }\n+            ty::RawPtr(..) => {\n+                // structural-match ignores substructure of\n+                // `*const _`/`*mut _`, so skip `super_visit_with`.\n+                //\n+                // For example, if you have:\n+                // ```\n+                // struct NonStructural;\n+                // #[derive(PartialEq, Eq)]\n+                // struct T(*const NonStructural);\n+                // const C: T = T(std::ptr::null());\n+                // ```\n+                //\n+                // Even though `NonStructural` does not implement `PartialEq`,\n+                // structural equality on `T` does not recur into the raw\n+                // pointer. Therefore, one can still use `C` in a pattern.\n+\n+                // (But still tell caller to continue search.)\n+                return false;\n+            }\n+            ty::FnDef(..) | ty::FnPtr(..) => {\n+                // types of formals and return in `fn(_) -> _` are also irrelevant;\n+                // so we do not recur into them via `super_visit_with`\n+                //\n+                // (But still tell caller to continue search.)\n+                return false;\n+            }\n+            ty::Array(_, n) if {\n+                n.try_eval_usize(self.tcx(), ty::ParamEnv::reveal_all()) == Some(0)\n+            } => {\n+                // rust-lang/rust#62336: ignore type of contents\n+                // for empty array.\n+                return false;\n+            }\n+            _ => {\n+                ty.super_visit_with(self);\n+                return false;\n+            }\n+        };\n+\n+        if !self.seen.insert(adt_def.did) {\n+            debug!(\"Search already seen adt_def: {:?}\", adt_def);\n+            // let caller continue its search\n+            return false;\n+        }\n+\n+        if !self.type_marked_structural(ty) {\n+            debug!(\"Search found ty: {:?}\", ty);\n+            self.found = Some(NonStructuralMatchTy::Adt(&adt_def));\n+            return true; // Halt visiting!\n+        }\n+\n+        // structural-match does not care about the\n+        // instantiation of the generics in an ADT (it\n+        // instead looks directly at its fields outside\n+        // this match), so we skip super_visit_with.\n+        //\n+        // (Must not recur on substs for `PhantomData<T>` cf\n+        // rust-lang/rust#55028 and rust-lang/rust#55837; but also\n+        // want to skip substs when only uses of generic are\n+        // behind unsafe pointers `*const T`/`*mut T`.)\n+\n+        // even though we skip super_visit_with, we must recur on\n+        // fields of ADT.\n+        let tcx = self.tcx();\n+        for field_ty in adt_def.all_fields().map(|field| field.ty(tcx, substs)) {\n+            if field_ty.visit_with(self) {\n+                // found an ADT without structural-match; halt visiting!\n+                assert!(self.found.is_some());\n+                return true;\n+            }\n+        }\n+\n+        // Even though we do not want to recur on substs, we do\n+        // want our caller to continue its own search.\n+        false\n+    }\n+}"}, {"sha": "bfc539639db1ec7ad7aeca51510be3f1d1503f84", "filename": "src/librustc_mir/hair/pattern/const_to_pat.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fconst_to_pat.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -0,0 +1,282 @@\n+use crate::const_eval::const_variant_index;\n+\n+use rustc::hir;\n+use rustc::lint;\n+use rustc::mir::Field;\n+use rustc::infer::InferCtxt;\n+use rustc::traits::{ObligationCause, PredicateObligation};\n+use rustc::ty::{self, Ty, TyCtxt};\n+\n+use rustc_index::vec::Idx;\n+\n+use syntax_pos::Span;\n+\n+\n+use std::cell::Cell;\n+\n+use super::{FieldPat, Pat, PatCtxt, PatKind};\n+\n+impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n+    /// Converts an evaluated constant to a pattern (if possible).\n+    /// This means aggregate values (like structs and enums) are converted\n+    /// to a pattern that matches the value (as if you'd compared via structural equality).\n+    pub(super) fn const_to_pat(\n+        &self,\n+        cv: &'tcx ty::Const<'tcx>,\n+        id: hir::HirId,\n+        span: Span,\n+    ) -> Pat<'tcx> {\n+        debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n+        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n+\n+        self.tcx.infer_ctxt().enter(|infcx| {\n+            let mut convert = ConstToPat::new(self, id, span, infcx);\n+            convert.to_pat(cv)\n+        })\n+    }\n+}\n+\n+struct ConstToPat<'a, 'tcx> {\n+    id: hir::HirId,\n+    span: Span,\n+    param_env: ty::ParamEnv<'tcx>,\n+\n+    // This tracks if we signal some hard error for a given const value, so that\n+    // we will not subsequently issue an irrelevant lint for the same const\n+    // value.\n+    saw_const_match_error: Cell<bool>,\n+\n+    // inference context used for checking `T: Structural` bounds.\n+    infcx: InferCtxt<'a, 'tcx>,\n+\n+    include_lint_checks: bool,\n+}\n+\n+impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n+    fn new(pat_ctxt: &PatCtxt<'_, 'tcx>,\n+                      id: hir::HirId,\n+                      span: Span,\n+                      infcx: InferCtxt<'a, 'tcx>) -> Self {\n+        ConstToPat {\n+            id, span, infcx,\n+            param_env: pat_ctxt.param_env,\n+            include_lint_checks: pat_ctxt.include_lint_checks,\n+            saw_const_match_error: Cell::new(false),\n+        }\n+    }\n+\n+    fn tcx(&self) -> TyCtxt<'tcx> { self.infcx.tcx }\n+\n+    fn search_for_structural_match_violation(&self,\n+                                             ty: Ty<'tcx>)\n+                                             -> Option<ty::NonStructuralMatchTy<'tcx>>\n+    {\n+        ty::search_for_structural_match_violation(self.id, self.span, self.tcx(), ty)\n+    }\n+\n+    fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {\n+        ty::type_marked_structural(self.id, self.span, &self.infcx, ty)\n+    }\n+\n+    fn to_pat(&mut self, cv: &'tcx ty::Const<'tcx>) -> Pat<'tcx> {\n+        // This method is just a wrapper handling a validity check; the heavy lifting is\n+        // performed by the recursive `recur` method, which is not meant to be\n+        // invoked except by this method.\n+        //\n+        // once indirect_structural_match is a full fledged error, this\n+        // level of indirection can be eliminated\n+\n+        let inlined_const_as_pat = self.recur(cv);\n+\n+        if self.include_lint_checks && !self.saw_const_match_error.get() {\n+            // If we were able to successfully convert the const to some pat,\n+            // double-check that all types in the const implement `Structural`.\n+\n+            let structural = self.search_for_structural_match_violation(cv.ty);\n+            debug!(\"search_for_structural_match_violation cv.ty: {:?} returned: {:?}\",\n+                   cv.ty, structural);\n+            if let Some(non_sm_ty) = structural {\n+                let adt_def = match non_sm_ty {\n+                    ty::NonStructuralMatchTy::Adt(adt_def) => adt_def,\n+                    ty::NonStructuralMatchTy::Param =>\n+                        bug!(\"use of constant whose type is a parameter inside a pattern\"),\n+                };\n+                let path = self.tcx().def_path_str(adt_def.did);\n+                let msg = format!(\n+                    \"to use a constant of type `{}` in a pattern, \\\n+                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                    path,\n+                    path,\n+                );\n+\n+                // double-check there even *is* a semantic `PartialEq` to dispatch to.\n+                //\n+                // (If there isn't, then we can safely issue a hard\n+                // error, because that's never worked, due to compiler\n+                // using `PartialEq::eq` in this scenario in the past.)\n+                //\n+                // Note: To fix rust-lang/rust#65466, one could lift this check\n+                // *before* any structural-match checking, and unconditionally error\n+                // if `PartialEq` is not implemented. However, that breaks stable\n+                // code at the moment, because types like `for <'a> fn(&'a ())` do\n+                // not *yet* implement `PartialEq`. So for now we leave this here.\n+                let ty_is_partial_eq: bool = {\n+                    let partial_eq_trait_id = self.tcx().lang_items().eq_trait().unwrap();\n+                    let obligation: PredicateObligation<'_> =\n+                        self.tcx().predicate_for_trait_def(\n+                            self.param_env,\n+                            ObligationCause::misc(self.span, self.id),\n+                            partial_eq_trait_id,\n+                            0,\n+                            cv.ty,\n+                            &[]);\n+                    // FIXME: should this call a `predicate_must_hold` variant instead?\n+                    self.infcx.predicate_may_hold(&obligation)\n+                };\n+\n+                if !ty_is_partial_eq {\n+                    // span_fatal avoids ICE from resolution of non-existent method (rare case).\n+                    self.tcx().sess.span_fatal(self.span, &msg);\n+                } else {\n+                    self.tcx().lint_hir(lint::builtin::INDIRECT_STRUCTURAL_MATCH,\n+                                        self.id,\n+                                        self.span,\n+                                        &msg);\n+                }\n+            }\n+        }\n+\n+        inlined_const_as_pat\n+    }\n+\n+    // Recursive helper for `to_pat`; invoke that (instead of calling this directly).\n+    fn recur(&self, cv: &'tcx ty::Const<'tcx>) -> Pat<'tcx> {\n+        let id = self.id;\n+        let span = self.span;\n+        let tcx = self.tcx();\n+        let param_env = self.param_env;\n+\n+        let adt_subpattern = |i, variant_opt| {\n+            let field = Field::new(i);\n+            let val = crate::const_eval::const_field(\n+                tcx, param_env, variant_opt, field, cv\n+            );\n+            self.recur(val)\n+        };\n+        let adt_subpatterns = |n, variant_opt| {\n+            (0..n).map(|i| {\n+                let field = Field::new(i);\n+                FieldPat {\n+                    field,\n+                    pattern: adt_subpattern(i, variant_opt),\n+                }\n+            }).collect::<Vec<_>>()\n+        };\n+\n+\n+        let kind = match cv.ty.kind {\n+            ty::Float(_) => {\n+                tcx.lint_hir(\n+                    ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n+                    id,\n+                    span,\n+                    \"floating-point types cannot be used in patterns\",\n+                );\n+                PatKind::Constant {\n+                    value: cv,\n+                }\n+            }\n+            ty::Adt(adt_def, _) if adt_def.is_union() => {\n+                // Matching on union fields is unsafe, we can't hide it in constants\n+                self.saw_const_match_error.set(true);\n+                tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n+                PatKind::Wild\n+            }\n+            // keep old code until future-compat upgraded to errors.\n+            ty::Adt(adt_def, _) if !self.type_marked_structural(cv.ty) => {\n+                debug!(\"adt_def {:?} has !type_marked_structural for cv.ty: {:?}\",\n+                       adt_def, cv.ty);\n+                let path = tcx.def_path_str(adt_def.did);\n+                let msg = format!(\n+                    \"to use a constant of type `{}` in a pattern, \\\n+                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                    path,\n+                    path,\n+                );\n+                self.saw_const_match_error.set(true);\n+                tcx.sess.span_err(span, &msg);\n+                PatKind::Wild\n+            }\n+            // keep old code until future-compat upgraded to errors.\n+            ty::Ref(_, adt_ty @ ty::TyS { kind: ty::Adt(_, _), .. }, _)\n+                if !self.type_marked_structural(adt_ty) =>\n+            {\n+                let adt_def = if let ty::Adt(adt_def, _) = adt_ty.kind {\n+                    adt_def\n+                } else {\n+                    unreachable!()\n+                };\n+\n+                debug!(\"adt_def {:?} has !type_marked_structural for adt_ty: {:?}\",\n+                       adt_def, adt_ty);\n+\n+                // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n+                // would be wrong. Returnging `PatKind::Wild` is not technically correct.\n+                let path = tcx.def_path_str(adt_def.did);\n+                let msg = format!(\n+                    \"to use a constant of type `{}` in a pattern, \\\n+                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n+                    path,\n+                    path,\n+                );\n+                self.saw_const_match_error.set(true);\n+                tcx.sess.span_err(span, &msg);\n+                PatKind::Wild\n+            }\n+            ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n+                let variant_index = const_variant_index(tcx, self.param_env, cv);\n+                let subpatterns = adt_subpatterns(\n+                    adt_def.variants[variant_index].fields.len(),\n+                    Some(variant_index),\n+                );\n+                PatKind::Variant {\n+                    adt_def,\n+                    substs,\n+                    variant_index,\n+                    subpatterns,\n+                }\n+            }\n+            ty::Adt(adt_def, _) => {\n+                let struct_var = adt_def.non_enum_variant();\n+                PatKind::Leaf {\n+                    subpatterns: adt_subpatterns(struct_var.fields.len(), None),\n+                }\n+            }\n+            ty::Tuple(fields) => {\n+                PatKind::Leaf {\n+                    subpatterns: adt_subpatterns(fields.len(), None),\n+                }\n+            }\n+            ty::Array(_, n) => {\n+                PatKind::Array {\n+                    prefix: (0..n.eval_usize(tcx, self.param_env))\n+                        .map(|i| adt_subpattern(i as usize, None))\n+                        .collect(),\n+                    slice: None,\n+                    suffix: Vec::new(),\n+                }\n+            }\n+            _ => {\n+                PatKind::Constant {\n+                    value: cv,\n+                }\n+            }\n+        };\n+\n+        Pat {\n+            span,\n+            ty: cv.ty,\n+            kind: Box::new(kind),\n+        }\n+    }\n+}"}, {"sha": "1ecc78ba227ceb487afda3c15b26ec7344664904", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 4, "deletions": 216, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -2,19 +2,16 @@\n \n mod _match;\n mod check_match;\n+mod const_to_pat;\n \n pub(crate) use self::check_match::check_match;\n \n-use crate::const_eval::const_variant_index;\n-\n use crate::hair::util::UserAnnotatedTyHelpers;\n use crate::hair::constant::*;\n \n-use rustc::lint;\n use rustc::mir::{Field, BorrowKind, Mutability};\n use rustc::mir::{UserTypeProjection};\n use rustc::mir::interpret::{GlobalId, ConstValue, get_slice_bytes, sign_extend};\n-use rustc::traits::{ObligationCause, PredicateObligation};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, UserType, DefIdTree};\n use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations};\n use rustc::ty::subst::{SubstsRef, GenericArg};\n@@ -29,7 +26,6 @@ use rustc_index::vec::Idx;\n use std::cmp::Ordering;\n use std::fmt;\n use syntax::ast;\n-use syntax::symbol::sym;\n use syntax_pos::Span;\n \n #[derive(Clone, Debug)]\n@@ -867,7 +863,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                         };\n                         match self.tcx.at(span).const_eval(self.param_env.and(cid)) {\n                             Ok(value) => {\n-                                let pattern = self.const_to_pat(instance, value, id, span);\n+                                let pattern = self.const_to_pat(value, id, span);\n                                 if !is_associated_const {\n                                     return pattern;\n                                 }\n@@ -934,11 +930,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let ty = self.tables.expr_ty(expr);\n                 match lit_to_const(&lit.node, self.tcx, ty, false) {\n                     Ok(val) => {\n-                        let instance = ty::Instance::new(\n-                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n-                            self.substs,\n-                        );\n-                        *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n+                        *self.const_to_pat(val, expr.hir_id, lit.span).kind\n                     },\n                     Err(LitToConstError::UnparseableFloat) => {\n                         self.errors.push(PatternError::FloatBug);\n@@ -956,11 +948,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 };\n                 match lit_to_const(&lit.node, self.tcx, ty, true) {\n                     Ok(val) => {\n-                        let instance = ty::Instance::new(\n-                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n-                            self.substs,\n-                        );\n-                        *self.const_to_pat(instance, val, expr.hir_id, lit.span).kind\n+                        *self.const_to_pat(val, expr.hir_id, lit.span).kind\n                     },\n                     Err(LitToConstError::UnparseableFloat) => {\n                         self.errors.push(PatternError::FloatBug);\n@@ -972,206 +960,6 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n         }\n     }\n-\n-    /// Converts an evaluated constant to a pattern (if possible).\n-    /// This means aggregate values (like structs and enums) are converted\n-    /// to a pattern that matches the value (as if you'd compared via structural equality).\n-    fn const_to_pat(\n-        &self,\n-        instance: ty::Instance<'tcx>,\n-        cv: &'tcx ty::Const<'tcx>,\n-        id: hir::HirId,\n-        span: Span,\n-    ) -> Pat<'tcx> {\n-        // This method is just a warpper handling a validity check; the heavy lifting is\n-        // performed by the recursive const_to_pat_inner method, which is not meant to be\n-        // invoked except by this method.\n-        //\n-        // once indirect_structural_match is a full fledged error, this\n-        // level of indirection can be eliminated\n-\n-        debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n-        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n-\n-        let mut saw_error = false;\n-        let inlined_const_as_pat = self.const_to_pat_inner(instance, cv, id, span, &mut saw_error);\n-\n-        if self.include_lint_checks && !saw_error {\n-            // If we were able to successfully convert the const to some pat, double-check\n-            // that the type of the const obeys `#[structural_match]` constraint.\n-            if let Some(non_sm_ty) = ty::search_for_structural_match_violation(self.tcx, cv.ty) {\n-                let msg = match non_sm_ty {\n-                    ty::NonStructuralMatchTy::Adt(adt_def) => {\n-                        let path = self.tcx.def_path_str(adt_def.did);\n-                        format!(\n-                            \"to use a constant of type `{}` in a pattern, \\\n-                             `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                            path,\n-                            path,\n-                        )\n-                    }\n-                    ty::NonStructuralMatchTy::Param => {\n-                        bug!(\"use of constant whose type is a parameter inside a pattern\");\n-                    }\n-                };\n-\n-                // before issuing lint, double-check there even *is* a\n-                // semantic PartialEq for us to dispatch to.\n-                //\n-                // (If there isn't, then we can safely issue a hard\n-                // error, because that's never worked, due to compiler\n-                // using PartialEq::eq in this scenario in the past.)\n-\n-                let ty_is_partial_eq: bool = {\n-                    let partial_eq_trait_id = self.tcx.lang_items().eq_trait().unwrap();\n-                    let obligation: PredicateObligation<'_> =\n-                        self.tcx.predicate_for_trait_def(self.param_env,\n-                                                         ObligationCause::misc(span, id),\n-                                                         partial_eq_trait_id,\n-                                                         0,\n-                                                         cv.ty,\n-                                                         &[]);\n-                    self.tcx\n-                        .infer_ctxt()\n-                        .enter(|infcx| infcx.predicate_may_hold(&obligation))\n-                };\n-\n-                if !ty_is_partial_eq {\n-                    // span_fatal avoids ICE from resolution of non-existent method (rare case).\n-                    self.tcx.sess.span_fatal(span, &msg);\n-                } else {\n-                    self.tcx.lint_hir(lint::builtin::INDIRECT_STRUCTURAL_MATCH, id, span, &msg);\n-                }\n-            }\n-        }\n-\n-        inlined_const_as_pat\n-    }\n-\n-    /// Recursive helper for `const_to_pat`; invoke that (instead of calling this directly).\n-    fn const_to_pat_inner(\n-        &self,\n-        instance: ty::Instance<'tcx>,\n-        cv: &'tcx ty::Const<'tcx>,\n-        id: hir::HirId,\n-        span: Span,\n-        // This tracks if we signal some hard error for a given const\n-        // value, so that we will not subsequently issue an irrelevant\n-        // lint for the same const value.\n-        saw_const_match_error: &mut bool,\n-    ) -> Pat<'tcx> {\n-\n-        let mut adt_subpattern = |i, variant_opt| {\n-            let field = Field::new(i);\n-            let val = crate::const_eval::const_field(\n-                self.tcx, self.param_env, variant_opt, field, cv\n-            );\n-            self.const_to_pat_inner(instance, val, id, span, saw_const_match_error)\n-        };\n-        let mut adt_subpatterns = |n, variant_opt| {\n-            (0..n).map(|i| {\n-                let field = Field::new(i);\n-                FieldPat {\n-                    field,\n-                    pattern: adt_subpattern(i, variant_opt),\n-                }\n-            }).collect::<Vec<_>>()\n-        };\n-\n-\n-        let kind = match cv.ty.kind {\n-            ty::Float(_) => {\n-                self.tcx.lint_hir(\n-                    ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n-                    id,\n-                    span,\n-                    \"floating-point types cannot be used in patterns\",\n-                );\n-                PatKind::Constant {\n-                    value: cv,\n-                }\n-            }\n-            ty::Adt(adt_def, _) if adt_def.is_union() => {\n-                // Matching on union fields is unsafe, we can't hide it in constants\n-                *saw_const_match_error = true;\n-                self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n-                PatKind::Wild\n-            }\n-            // keep old code until future-compat upgraded to errors.\n-            ty::Adt(adt_def, _) if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n-                let path = self.tcx.def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path,\n-                    path,\n-                );\n-                *saw_const_match_error = true;\n-                self.tcx.sess.span_err(span, &msg);\n-                PatKind::Wild\n-            }\n-            // keep old code until future-compat upgraded to errors.\n-            ty::Ref(_, ty::TyS { kind: ty::Adt(adt_def, _), .. }, _)\n-            if !self.tcx.has_attr(adt_def.did, sym::structural_match) => {\n-                // HACK(estebank): Side-step ICE #53708, but anything other than erroring here\n-                // would be wrong. Returnging `PatKind::Wild` is not technically correct.\n-                let path = self.tcx.def_path_str(adt_def.did);\n-                let msg = format!(\n-                    \"to use a constant of type `{}` in a pattern, \\\n-                     `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                    path,\n-                    path,\n-                );\n-                *saw_const_match_error = true;\n-                self.tcx.sess.span_err(span, &msg);\n-                PatKind::Wild\n-            }\n-            ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                let variant_index = const_variant_index(self.tcx, self.param_env, cv);\n-                let subpatterns = adt_subpatterns(\n-                    adt_def.variants[variant_index].fields.len(),\n-                    Some(variant_index),\n-                );\n-                PatKind::Variant {\n-                    adt_def,\n-                    substs,\n-                    variant_index,\n-                    subpatterns,\n-                }\n-            }\n-            ty::Adt(adt_def, _) => {\n-                let struct_var = adt_def.non_enum_variant();\n-                PatKind::Leaf {\n-                    subpatterns: adt_subpatterns(struct_var.fields.len(), None),\n-                }\n-            }\n-            ty::Tuple(fields) => {\n-                PatKind::Leaf {\n-                    subpatterns: adt_subpatterns(fields.len(), None),\n-                }\n-            }\n-            ty::Array(_, n) => {\n-                PatKind::Array {\n-                    prefix: (0..n.eval_usize(self.tcx, self.param_env))\n-                        .map(|i| adt_subpattern(i as usize, None))\n-                        .collect(),\n-                    slice: None,\n-                    suffix: Vec::new(),\n-                }\n-            }\n-            _ => {\n-                PatKind::Constant {\n-                    value: cv,\n-                }\n-            }\n-        };\n-\n-        Pat {\n-            span,\n-            ty: cv.ty,\n-            kind: Box::new(kind),\n-        }\n-    }\n }\n \n impl UserAnnotatedTyHelpers<'tcx> for PatCtxt<'_, 'tcx> {"}, {"sha": "2395cb7495df4c49e24f632fdab22eecb664d100", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -1532,7 +1532,9 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                         );\n                     };\n                 }\n-                if ty::search_for_structural_match_violation(tcx, ty).is_some() {\n+                if ty::search_for_structural_match_violation(\n+                    param.hir_id, param.span, tcx, ty).is_some()\n+                {\n                     struct_span_err!(\n                         tcx.sess,\n                         hir_ty.span,"}, {"sha": "162aaedafea325c9fd04eda006887657375c0894", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -42,6 +42,12 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n                       }],\n         associated_types: Vec::new(),\n     };\n+\n+    super::inject_impl_of_structural_trait(\n+        cx, span, item,\n+        path_std!(cx, marker::StructuralEq),\n+        push);\n+\n     trait_def.expand_ext(cx, mitem, item, push, true)\n }\n "}, {"sha": "c3e2b78bbe506ccf27c211c95a62e12a355168e7", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::{BinOpKind, Expr, MetaItem};\n use syntax_expand::base::{Annotatable, ExtCtxt, SpecialDerives};\n use syntax::ptr::P;\n use syntax::symbol::sym;\n-use syntax_pos::Span;\n+use syntax_pos::{self, Span};\n \n pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n                                   span: Span,\n@@ -81,6 +81,11 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n         } }\n     }\n \n+    super::inject_impl_of_structural_trait(\n+        cx, span, item,\n+        path_std!(cx, marker::StructuralPartialEq),\n+        push);\n+\n     // avoid defining `ne` if we can\n     // c-like enums, enums without any fields and structs without fields\n     // can safely define only `eq`."}, {"sha": "a98cce1fd61c14deb6a4a60096b5e810516fd61e", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -1,6 +1,6 @@\n //! The compiler code necessary to implement the `#[derive]` extensions.\n \n-use syntax::ast::{self, MetaItem};\n+use syntax::ast::{self, ItemKind, MetaItem};\n use syntax_expand::base::{Annotatable, ExtCtxt, MultiItemModifier};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, sym};\n@@ -74,3 +74,85 @@ fn call_intrinsic(cx: &ExtCtxt<'_>,\n         span,\n     }))\n }\n+\n+\n+// Injects `impl<...> Structural for ItemType<...> { }`. In particular,\n+// does *not* add `where T: Structural` for parameters `T` in `...`.\n+// (That's the main reason we cannot use TraitDef here.)\n+fn inject_impl_of_structural_trait(cx: &mut ExtCtxt<'_>,\n+                                   span: Span,\n+                                   item: &Annotatable,\n+                                   structural_path: generic::ty::Path<'_>,\n+                                   push: &mut dyn FnMut(Annotatable)) {\n+    let item = match *item {\n+        Annotatable::Item(ref item) => item,\n+        _ => {\n+            // Non-Item derive is an error, but it should have been\n+            // set earlier; see\n+            // libsyntax/ext/expand.rs:MacroExpander::expand()\n+            return;\n+        }\n+    };\n+\n+    let generics = match item.kind {\n+        ItemKind::Struct(_, ref generics) |\n+        ItemKind::Enum(_, ref generics) => generics,\n+        // Do not inject `impl Structural for Union`. (`PartialEq` does not\n+        // support unions, so we will see error downstream.)\n+        ItemKind::Union(..) => return,\n+        _ => unreachable!(),\n+    };\n+\n+    // Create generics param list for where clauses and impl headers\n+    let mut generics = generics.clone();\n+\n+    // Create the type of `self`.\n+    //\n+    // in addition, remove defaults from type params (impls cannot have them).\n+    let self_params: Vec<_> = generics.params.iter_mut().map(|param| match &mut param.kind {\n+        ast::GenericParamKind::Lifetime => {\n+            ast::GenericArg::Lifetime(cx.lifetime(span, param.ident))\n+        }\n+        ast::GenericParamKind::Type { default } => {\n+            *default = None;\n+            ast::GenericArg::Type(cx.ty_ident(span, param.ident))\n+        }\n+        ast::GenericParamKind::Const { ty: _ } => {\n+            ast::GenericArg::Const(cx.const_ident(span, param.ident))\n+        }\n+    }).collect();\n+\n+    let type_ident = item.ident;\n+\n+    let trait_ref = cx.trait_ref(structural_path.to_path(cx, span, type_ident, &generics));\n+    let self_type = cx.ty_path(cx.path_all(span, false, vec![type_ident], self_params));\n+\n+    // It would be nice to also encode constraint `where Self: Eq` (by adding it\n+    // onto `generics` cloned above). Unfortunately, that strategy runs afoul of\n+    // rust-lang/rust#48214. So we perform that additional check in the compiler\n+    // itself, instead of encoding it here.\n+\n+    // Keep the lint and stability attributes of the original item, to control\n+    // how the generated implementation is linted.\n+    let mut attrs = Vec::new();\n+    attrs.extend(item.attrs\n+                 .iter()\n+                 .filter(|a| {\n+                     [sym::allow, sym::warn, sym::deny, sym::forbid, sym::stable, sym::unstable]\n+                         .contains(&a.name_or_empty())\n+                 })\n+                 .cloned());\n+\n+    let newitem = cx.item(span,\n+                          ast::Ident::invalid(),\n+                          attrs,\n+                          ItemKind::Impl(ast::Unsafety::Normal,\n+                                         ast::ImplPolarity::Positive,\n+                                         ast::Defaultness::Final,\n+                                         generics,\n+                                         Some(trait_ref),\n+                                         self_type,\n+                                         Vec::new()));\n+\n+    push(Annotatable::Item(newitem));\n+}"}, {"sha": "0b4c97723d6bc44e5298d55968e774feb75faafd", "filename": "src/test/codegen-units/item-collection/overloaded-operators.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Foverloaded-operators.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -34,8 +34,8 @@ impl IndexMut<usize> for Indexable {\n }\n \n \n-//~ MONO_ITEM fn overloaded_operators::{{impl}}[4]::eq[0]\n-//~ MONO_ITEM fn overloaded_operators::{{impl}}[4]::ne[0]\n+//~ MONO_ITEM fn overloaded_operators::{{impl}}[5]::eq[0]\n+//~ MONO_ITEM fn overloaded_operators::{{impl}}[5]::ne[0]\n #[derive(PartialEq)]\n pub struct Equatable(u32);\n "}, {"sha": "42b81cd43000f446754f271532457dc8e2e1c7ed", "filename": "src/test/ui/rfc1445/feature-gate.no_gate.stderr", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.no_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.no_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.no_gate.stderr?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -1,12 +1,21 @@\n-error[E0658]: the semantics of constant patterns is not yet settled\n-  --> $DIR/feature-gate.rs:13:1\n+error[E0658]: use of unstable library feature 'structural_match'\n+  --> $DIR/feature-gate.rs:29:6\n    |\n-LL | #[structural_match]\n-   | ^^^^^^^^^^^^^^^^^^^\n+LL | impl std::marker::StructuralPartialEq for Foo { }\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/31434\n    = help: add `#![feature(structural_match)]` to the crate attributes to enable\n \n-error: aborting due to previous error\n+error[E0658]: use of unstable library feature 'structural_match'\n+  --> $DIR/feature-gate.rs:31:6\n+   |\n+LL | impl std::marker::StructuralEq for Foo { }\n+   |      ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/31434\n+   = help: add `#![feature(structural_match)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "38d6406efa50d2a6199e1ad7548daf36f48a5164", "filename": "src/test/ui/rfc1445/feature-gate.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Ffeature-gate.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -10,7 +10,7 @@\n #![feature(rustc_attrs)]\n #![cfg_attr(with_gate, feature(structural_match))]\n \n-#[structural_match] //[no_gate]~ ERROR semantics of constant patterns is not yet settled\n+\n struct Foo {\n     x: u32\n }\n@@ -25,3 +25,15 @@ fn main() { //[with_gate]~ ERROR compilation successful\n         _ => { }\n     }\n }\n+\n+impl std::marker::StructuralPartialEq for Foo { }\n+//[no_gate]~^ ERROR use of unstable library feature 'structural_match'\n+impl std::marker::StructuralEq for Foo { }\n+//[no_gate]~^ ERROR use of unstable library feature 'structural_match'\n+\n+impl PartialEq<Foo> for Foo {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.x == other.x\n+    }\n+}\n+impl Eq for Foo { }"}, {"sha": "e288beca090813245849a5591e98752895569ef4", "filename": "src/test/ui/rfc1445/issue-61188-match-slice-forbidden-without-eq.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Ftest%2Fui%2Frfc1445%2Fissue-61188-match-slice-forbidden-without-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Ftest%2Fui%2Frfc1445%2Fissue-61188-match-slice-forbidden-without-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-61188-match-slice-forbidden-without-eq.rs?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -1,4 +1,4 @@\n-// Issue 61118 pointed out a case where we hit an ICE during code gen:\n+// Issue 61188 pointed out a case where we hit an ICE during code gen:\n // the compiler assumed that `PartialEq` was always implemented on any\n // use of a `const` item in a pattern context, but the pre-existing\n // checking for the presence of `#[structural_match]` was too shallow", "previous_filename": "src/test/ui/rfc1445/issue-61118-match-slice-forbidden-without-eq.rs"}, {"sha": "0bf369fa8cb87d32dc0fe9dad44722270f4b434f", "filename": "src/test/ui/rfc1445/issue-61188-match-slice-forbidden-without-eq.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Ftest%2Fui%2Frfc1445%2Fissue-61188-match-slice-forbidden-without-eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b7176b44a203322c834302f3b515f8c10a54f2c1/src%2Ftest%2Fui%2Frfc1445%2Fissue-61188-match-slice-forbidden-without-eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1445%2Fissue-61188-match-slice-forbidden-without-eq.stderr?ref=b7176b44a203322c834302f3b515f8c10a54f2c1", "patch": "@@ -1,5 +1,5 @@\n error: to use a constant of type `B` in a pattern, `B` must be annotated with `#[derive(PartialEq, Eq)]`\n-  --> $DIR/issue-61118-match-slice-forbidden-without-eq.rs:15:9\n+  --> $DIR/issue-61188-match-slice-forbidden-without-eq.rs:15:9\n    |\n LL |         A => (),\n    |         ^", "previous_filename": "src/test/ui/rfc1445/issue-61118-match-slice-forbidden-without-eq.stderr"}]}