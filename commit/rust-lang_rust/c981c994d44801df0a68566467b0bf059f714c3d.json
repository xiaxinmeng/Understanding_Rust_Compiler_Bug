{"sha": "c981c994d44801df0a68566467b0bf059f714c3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ODFjOTk0ZDQ0ODAxZGYwYTY4NTY2NDY3YjBiZjA1OWY3MTRjM2Q=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-18T18:03:20Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-11-18T22:38:25Z"}, "message": "Move E0594 to new error code system", "tree": {"sha": "c0f38acc89108621ccb6737d473d4e52e2403212", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0f38acc89108621ccb6737d473d4e52e2403212"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c981c994d44801df0a68566467b0bf059f714c3d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c981c994d44801df0a68566467b0bf059f714c3d", "html_url": "https://github.com/rust-lang/rust/commit/c981c994d44801df0a68566467b0bf059f714c3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c981c994d44801df0a68566467b0bf059f714c3d/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd13335ae23c115275d2c99728f3e66efc25993d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd13335ae23c115275d2c99728f3e66efc25993d", "html_url": "https://github.com/rust-lang/rust/commit/cd13335ae23c115275d2c99728f3e66efc25993d"}], "stats": {"total": 2602, "additions": 24, "deletions": 2578}, "files": [{"sha": "9fc375cc7b044a37f8efd4f5e2a96feb7bb898a4", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c981c994d44801df0a68566467b0bf059f714c3d/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c981c994d44801df0a68566467b0bf059f714c3d/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=c981c994d44801df0a68566467b0bf059f714c3d", "patch": "@@ -318,6 +318,7 @@ E0590: include_str!(\"./error_codes/E0590.md\"),\n E0591: include_str!(\"./error_codes/E0591.md\"),\n E0592: include_str!(\"./error_codes/E0592.md\"),\n E0593: include_str!(\"./error_codes/E0593.md\"),\n+E0594: include_str!(\"./error_codes/E0594.md\"),\n E0595: include_str!(\"./error_codes/E0595.md\"),\n E0596: include_str!(\"./error_codes/E0596.md\"),\n E0597: include_str!(\"./error_codes/E0597.md\"),\n@@ -566,7 +567,6 @@ E0744: include_str!(\"./error_codes/E0744.md\"),\n //  E0563, // cannot determine a type for this `impl Trait` removed in 6383de15\n //  E0564, // only named lifetimes are allowed in `impl Trait`,\n            // but `{}` was found in the type `{}`\n-    E0594, // cannot assign to {}\n //  E0598, // lifetime of {} is too short to guarantee its contents can be...\n //  E0611, // merged into E0616\n //  E0612, // merged into E0609"}, {"sha": "ad8eb631e63b16a733018e86e44861304acfc86a", "filename": "src/librustc_error_codes/error_codes/E0594.md", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c981c994d44801df0a68566467b0bf059f714c3d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0594.md", "raw_url": "https://github.com/rust-lang/rust/raw/c981c994d44801df0a68566467b0bf059f714c3d/src%2Flibrustc_error_codes%2Ferror_codes%2FE0594.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0594.md?ref=c981c994d44801df0a68566467b0bf059f714c3d", "patch": "@@ -0,0 +1,23 @@\n+A non-mutable value was assigned a value.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0594\n+struct SolarSystem {\n+    earth: i32,\n+}\n+\n+let ss = SolarSystem { earth: 3 };\n+ss.earth = 2; // error!\n+```\n+\n+To fix this error, declare `ss` as mutable by using the `mut` keyword:\n+\n+```\n+struct SolarSystem {\n+    earth: i32,\n+}\n+\n+let mut ss = SolarSystem { earth: 3 }; // declaring `ss` as mutable\n+ss.earth = 2; // ok!\n+```"}, {"sha": "5e9bf4be75eada25e6fb0f7e6e08700553517694", "filename": "src/librustc_mir/error_codes.rs", "status": "removed", "additions": 0, "deletions": 2577, "changes": 2577, "blob_url": "https://github.com/rust-lang/rust/blob/cd13335ae23c115275d2c99728f3e66efc25993d/src%2Flibrustc_mir%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd13335ae23c115275d2c99728f3e66efc25993d/src%2Flibrustc_mir%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ferror_codes.rs?ref=cd13335ae23c115275d2c99728f3e66efc25993d", "patch": "@@ -1,2577 +0,0 @@\n-syntax::register_diagnostics! {\n-\n-\n-E0001: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error suggests that the expression arm corresponding to the noted pattern\n-will never be reached as for all possible values of the expression being\n-matched, one of the preceding patterns will match.\n-\n-This means that perhaps some of the preceding patterns are too general, this\n-one is too specific or the ordering is incorrect.\n-\n-For example, the following `match` block has too many arms:\n-\n-```\n-match Some(0) {\n-    Some(bar) => {/* ... */}\n-    x => {/* ... */} // This handles the `None` case\n-    _ => {/* ... */} // All possible cases have already been handled\n-}\n-```\n-\n-`match` blocks have their patterns matched in order, so, for example, putting\n-a wildcard arm above a more specific arm will make the latter arm irrelevant.\n-\n-Ensure the ordering of the match arm is correct and remove any superfluous\n-arms.\n-\"##,\n-\n-E0002: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error indicates that an empty match expression is invalid because the type\n-it is matching on is non-empty (there exist values of this type). In safe code\n-it is impossible to create an instance of an empty type, so empty match\n-expressions are almost never desired. This error is typically fixed by adding\n-one or more cases to the match expression.\n-\n-An example of an empty type is `enum Empty { }`. So, the following will work:\n-\n-```\n-enum Empty {}\n-\n-fn foo(x: Empty) {\n-    match x {\n-        // empty\n-    }\n-}\n-```\n-\n-However, this won't:\n-\n-```compile_fail\n-fn foo(x: Option<String>) {\n-    match x {\n-        // empty\n-    }\n-}\n-```\n-\"##,\n-\n-E0004: r##\"\n-This error indicates that the compiler cannot guarantee a matching pattern for\n-one or more possible inputs to a match expression. Guaranteed matches are\n-required in order to assign values to match expressions, or alternatively,\n-determine the flow of execution.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0004\n-enum Terminator {\n-    HastaLaVistaBaby,\n-    TalkToMyHand,\n-}\n-\n-let x = Terminator::HastaLaVistaBaby;\n-\n-match x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n-    Terminator::TalkToMyHand => {}\n-}\n-```\n-\n-If you encounter this error you must alter your patterns so that every possible\n-value of the input type is matched. For types with a small number of variants\n-(like enums) you should probably cover all cases explicitly. Alternatively, the\n-underscore `_` wildcard pattern can be added after all other patterns to match\n-\"anything else\". Example:\n-\n-```\n-enum Terminator {\n-    HastaLaVistaBaby,\n-    TalkToMyHand,\n-}\n-\n-let x = Terminator::HastaLaVistaBaby;\n-\n-match x {\n-    Terminator::TalkToMyHand => {}\n-    Terminator::HastaLaVistaBaby => {}\n-}\n-\n-// or:\n-\n-match x {\n-    Terminator::TalkToMyHand => {}\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0005: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee\n-that a name will be extracted in all cases.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0005\n-let x = Some(1);\n-let Some(y) = x;\n-// error: refutable pattern in local binding: `None` not covered\n-```\n-\n-If you encounter this error you probably need to use a `match` or `if let` to\n-deal with the possibility of failure. Example:\n-\n-```\n-let x = Some(1);\n-\n-match x {\n-    Some(y) => {\n-        // do something\n-    },\n-    None => {}\n-}\n-\n-// or:\n-\n-if let Some(y) = x {\n-    // do something\n-}\n-```\n-\"##,\n-\n-E0007: r##\"\n-This error indicates that the bindings in a match arm would require a value to\n-be moved into more than one location, thus violating unique ownership. Code\n-like the following is invalid as it requires the entire `Option<String>` to be\n-moved into a variable called `op_string` while simultaneously requiring the\n-inner `String` to be moved into a variable called `s`.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0007\n-let x = Some(\"s\".to_string());\n-\n-match x {\n-    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n-    None => {},\n-}\n-```\n-\n-See also the error E0303.\n-\"##,\n-\n-E0009: r##\"\n-In a pattern, all values that don't implement the `Copy` trait have to be bound\n-the same way. The goal here is to avoid binding simultaneously by-move and\n-by-ref.\n-\n-This limitation may be removed in a future version of Rust.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0009\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\n-                            //        same pattern\n-    None => panic!()\n-}\n-```\n-\n-You have two solutions:\n-\n-Solution #1: Bind the pattern's values the same way.\n-\n-```\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((ref y, ref z)) => {},\n-    // or Some((y, z)) => {}\n-    None => panic!()\n-}\n-```\n-\n-Solution #2: Implement the `Copy` trait for the `X` structure.\n-\n-However, please keep in mind that the first solution should be preferred.\n-\n-```\n-#[derive(Clone, Copy)]\n-struct X { x: (), }\n-\n-let x = Some((X { x: () }, X { x: () }));\n-match x {\n-    Some((y, ref z)) => {},\n-    None => panic!()\n-}\n-```\n-\"##,\n-\n-E0010: r##\"\n-The value of statics and constants must be known at compile time, and they live\n-for the entire lifetime of a program. Creating a boxed value allocates memory on\n-the heap at runtime, and therefore cannot be done at compile time.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0010\n-#![feature(box_syntax)]\n-\n-const CON : Box<i32> = box 0;\n-```\n-\"##,\n-\n-E0013: r##\"\n-Static and const variables can refer to other const variables. But a const\n-variable cannot refer to a static variable.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0013\n-static X: i32 = 42;\n-const Y: i32 = X;\n-```\n-\n-In this example, `Y` cannot refer to `X` here. To fix this, the value can be\n-extracted as a const and then used:\n-\n-```\n-const A: i32 = 42;\n-static X: i32 = A;\n-const Y: i32 = A;\n-```\n-\"##,\n-\n-// FIXME(#57563) Change the language here when const fn stabilizes\n-E0015: r##\"\n-The only functions that can be called in static or constant expressions are\n-`const` functions, and struct/enum constructors. `const` functions are only\n-available on a nightly compiler. Rust currently does not support more general\n-compile-time function execution.\n-\n-```\n-const FOO: Option<u8> = Some(1); // enum constructor\n-struct Bar {x: u8}\n-const BAR: Bar = Bar {x: 1}; // struct constructor\n-```\n-\n-See [RFC 911] for more details on the design of `const fn`s.\n-\n-[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n-\"##,\n-\n-E0017: r##\"\n-References in statics and constants may only refer to immutable values.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0017\n-static X: i32 = 1;\n-const C: i32 = 2;\n-\n-// these three are not allowed:\n-const CR: &mut i32 = &mut C;\n-static STATIC_REF: &'static mut i32 = &mut X;\n-static CONST_REF: &'static mut i32 = &mut C;\n-```\n-\n-Statics are shared everywhere, and if they refer to mutable data one might\n-violate memory safety since holding multiple mutable references to shared data\n-is not allowed.\n-\n-If you really want global mutable state, try using `static mut` or a global\n-`UnsafeCell`.\n-\"##,\n-\n-E0019: r##\"\n-A function call isn't allowed in the const's initialization expression\n-because the expression's value must be known at compile-time.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0019\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    struct MyOwned;\n-\n-    static STATIC11: Box<MyOwned> = box MyOwned; // error!\n-}\n-```\n-\n-Remember: you can't use a function call inside a const's initialization\n-expression! However, you can totally use it anywhere else:\n-\n-```\n-enum Test {\n-    V1\n-}\n-\n-impl Test {\n-    fn func(&self) -> i32 {\n-        12\n-    }\n-}\n-\n-fn main() {\n-    const FOO: Test = Test::V1;\n-\n-    FOO.func(); // here is good\n-    let x = FOO.func(); // or even here!\n-}\n-```\n-\"##,\n-\n-E0030: r##\"\n-When matching against a range, the compiler verifies that the range is\n-non-empty. Range patterns include both end-points, so this is equivalent to\n-requiring the start of the range to be less than or equal to the end of the\n-range.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0030\n-match 5u32 {\n-    // This range is ok, albeit pointless.\n-    1 ..= 1 => {}\n-    // This range is empty, and the compiler can tell.\n-    1000 ..= 5 => {}\n-}\n-```\n-\"##,\n-\n-E0133: r##\"\n-Unsafe code was used outside of an unsafe function or block.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0133\n-unsafe fn f() { return; } // This is the unsafe code\n-\n-fn main() {\n-    f(); // error: call to unsafe function requires unsafe function or block\n-}\n-```\n-\n-Using unsafe functionality is potentially dangerous and disallowed by safety\n-checks. Examples:\n-\n-* Dereferencing raw pointers\n-* Calling functions via FFI\n-* Calling functions marked unsafe\n-\n-These safety checks can be relaxed for a section of the code by wrapping the\n-unsafe instructions with an `unsafe` block. For instance:\n-\n-```\n-unsafe fn f() { return; }\n-\n-fn main() {\n-    unsafe { f(); } // ok!\n-}\n-```\n-\n-See also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n-\"##,\n-\n-E0158: r##\"\n-An associated const has been referenced in a pattern.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0158\n-enum EFoo { A, B, C, D }\n-\n-trait Foo {\n-    const X: EFoo;\n-}\n-\n-fn test<A: Foo>(arg: EFoo) {\n-    match arg {\n-        A::X => { // error!\n-            println!(\"A::X\");\n-        }\n-    }\n-}\n-```\n-\n-`const` and `static` mean different things. A `const` is a compile-time\n-constant, an alias for a literal value. This property means you can match it\n-directly within a pattern.\n-\n-The `static` keyword, on the other hand, guarantees a fixed location in memory.\n-This does not always mean that the value is constant. For example, a global\n-mutex can be declared `static` as well.\n-\n-If you want to match against a `static`, consider using a guard instead:\n-\n-```\n-static FORTY_TWO: i32 = 42;\n-\n-match Some(42) {\n-    Some(x) if x == FORTY_TWO => {}\n-    _ => {}\n-}\n-```\n-\"##,\n-\n-E0161: r##\"\n-A value was moved. However, its size was not known at compile time, and only\n-values of a known size can be moved.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0161\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<[isize]> = box *array;\n-    // error: cannot move a value of type [isize]: the size of [isize] cannot\n-    //        be statically determined\n-}\n-```\n-\n-In Rust, you can only move a value when its size is known at compile time.\n-\n-To work around this restriction, consider \"hiding\" the value behind a reference:\n-either `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\n-it around as usual. Example:\n-\n-```\n-#![feature(box_syntax)]\n-\n-fn main() {\n-    let array: &[isize] = &[1, 2, 3];\n-    let _x: Box<&[isize]> = box array; // ok!\n-}\n-```\n-\"##,\n-\n-E0162: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-An if-let pattern attempts to match the pattern, and enters the body if the\n-match was successful. If the match is irrefutable (when it cannot fail to\n-match), use a regular `let`-binding instead. For instance:\n-\n-```\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-// This fails to compile because the match is irrefutable.\n-if let Irrefutable(x) = irr {\n-    // This body will always be executed.\n-    // ...\n-}\n-```\n-\n-Try this instead:\n-\n-```\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-let Irrefutable(x) = irr;\n-println!(\"{}\", x);\n-```\n-\"##,\n-\n-E0165: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-A while-let pattern attempts to match the pattern, and enters the body if the\n-match was successful. If the match is irrefutable (when it cannot fail to\n-match), use a regular `let`-binding inside a `loop` instead. For instance:\n-\n-```no_run\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-// This fails to compile because the match is irrefutable.\n-while let Irrefutable(x) = irr {\n-    // ...\n-}\n-```\n-\n-Try this instead:\n-\n-```no_run\n-struct Irrefutable(i32);\n-let irr = Irrefutable(0);\n-\n-loop {\n-    let Irrefutable(x) = irr;\n-    // ...\n-}\n-```\n-\"##,\n-\n-E0170: r##\"\n-Enum variants are qualified by default. For example, given this type:\n-\n-```\n-enum Method {\n-    GET,\n-    POST,\n-}\n-```\n-\n-You would match it using:\n-\n-```\n-enum Method {\n-    GET,\n-    POST,\n-}\n-\n-let m = Method::GET;\n-\n-match m {\n-    Method::GET => {},\n-    Method::POST => {},\n-}\n-```\n-\n-If you don't qualify the names, the code will bind new variables named \"GET\" and\n-\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\n-that happens.\n-\n-Qualified names are good practice, and most code works well with them. But if\n-you prefer them unqualified, you can import the variants into scope:\n-\n-```\n-use Method::*;\n-enum Method { GET, POST }\n-# fn main() {}\n-```\n-\n-If you want others to be able to import variants from your module directly, use\n-`pub use`:\n-\n-```\n-pub use Method::*;\n-pub enum Method { GET, POST }\n-# fn main() {}\n-```\n-\"##,\n-\n-\n-E0297: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Patterns used to bind names must be irrefutable. That is, they must guarantee\n-that a name will be extracted in all cases. Instead of pattern matching the\n-loop variable, consider using a `match` or `if let` inside the loop body. For\n-instance:\n-\n-```compile_fail,E0005\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-// This fails because `None` is not covered.\n-for Some(x) in xs {\n-    // ...\n-}\n-```\n-\n-Match inside the loop instead:\n-\n-```\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-for item in xs {\n-    match item {\n-        Some(x) => {},\n-        None => {},\n-    }\n-}\n-```\n-\n-Or use `if let`:\n-\n-```\n-let xs : Vec<Option<i32>> = vec![Some(1), None];\n-\n-for item in xs {\n-    if let Some(x) = item {\n-        // ...\n-    }\n-}\n-```\n-\"##,\n-\n-E0301: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Mutable borrows are not allowed in pattern guards, because matching cannot have\n-side effects. Side effects could alter the matched object or the environment\n-on which the match depends in such a way, that the match would not be\n-exhaustive. For instance, the following would not match any arm if mutable\n-borrows were allowed:\n-\n-```compile_fail,E0596\n-match Some(()) {\n-    None => { },\n-    option if option.take().is_none() => {\n-        /* impossible, option is `Some` */\n-    },\n-    Some(_) => { } // When the previous match failed, the option became `None`.\n-}\n-```\n-\"##,\n-\n-E0302: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Assignments are not allowed in pattern guards, because matching cannot have\n-side effects. Side effects could alter the matched object or the environment\n-on which the match depends in such a way, that the match would not be\n-exhaustive. For instance, the following would not match any arm if assignments\n-were allowed:\n-\n-```compile_fail,E0594\n-match Some(()) {\n-    None => { },\n-    option if { option = None; false } => { },\n-    Some(_) => { } // When the previous match failed, the option became `None`.\n-}\n-```\n-\"##,\n-\n-E0303: r##\"\n-In certain cases it is possible for sub-bindings to violate memory safety.\n-Updates to the borrow checker in a future version of Rust may remove this\n-restriction, but for now patterns must be rewritten without sub-bindings.\n-\n-Before:\n-\n-```compile_fail,E0303\n-match Some(\"hi\".to_string()) {\n-    ref op_string_ref @ Some(s) => {},\n-    None => {},\n-}\n-```\n-\n-After:\n-\n-```\n-match Some(\"hi\".to_string()) {\n-    Some(ref s) => {\n-        let op_string_ref = &Some(s);\n-        // ...\n-    },\n-    None => {},\n-}\n-```\n-\n-The `op_string_ref` binding has type `&Option<&String>` in both cases.\n-\n-See also https://github.com/rust-lang/rust/issues/14587\n-\"##,\n-\n-E0373: r##\"\n-This error occurs when an attempt is made to use data captured by a closure,\n-when that data may no longer exist. It's most commonly seen when attempting to\n-return a closure:\n-\n-```compile_fail,E0373\n-fn foo() -> Box<Fn(u32) -> u32> {\n-    let x = 0u32;\n-    Box::new(|y| x + y)\n-}\n-```\n-\n-Notice that `x` is stack-allocated by `foo()`. By default, Rust captures\n-closed-over data by reference. This means that once `foo()` returns, `x` no\n-longer exists. An attempt to access `x` within the closure would thus be\n-unsafe.\n-\n-Another situation where this might be encountered is when spawning threads:\n-\n-```compile_fail,E0373\n-fn foo() {\n-    let x = 0u32;\n-    let y = 1u32;\n-\n-    let thr = std::thread::spawn(|| {\n-        x + y\n-    });\n-}\n-```\n-\n-Since our new thread runs in parallel, the stack frame containing `x` and `y`\n-may well have disappeared by the time we try to use them. Even if we call\n-`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\n-stack frame won't disappear), we will not succeed: the compiler cannot prove\n-that this behaviour is safe, and so won't let us do it.\n-\n-The solution to this problem is usually to switch to using a `move` closure.\n-This approach moves (or copies, where possible) data into the closure, rather\n-than taking references to it. For example:\n-\n-```\n-fn foo() -> Box<Fn(u32) -> u32> {\n-    let x = 0u32;\n-    Box::new(move |y| x + y)\n-}\n-```\n-\n-Now that the closure has its own copy of the data, there's no need to worry\n-about safety.\n-\"##,\n-\n-E0381: r##\"\n-It is not allowed to use or capture an uninitialized variable.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0381\n-fn main() {\n-    let x: i32;\n-    let y = x; // error, use of possibly-uninitialized variable\n-}\n-```\n-\n-To fix this, ensure that any declared variables are initialized before being\n-used. Example:\n-\n-```\n-fn main() {\n-    let x: i32 = 0;\n-    let y = x; // ok!\n-}\n-```\n-\"##,\n-\n-E0382: r##\"\n-This error occurs when an attempt is made to use a variable after its contents\n-have been moved elsewhere.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0382\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = MyStruct{ s: 5u32 };\n-    let y = x;\n-    x.s = 6;\n-    println!(\"{}\", x.s);\n-}\n-```\n-\n-Since `MyStruct` is a type that is not marked `Copy`, the data gets moved out\n-of `x` when we set `y`. This is fundamental to Rust's ownership system: outside\n-of workarounds like `Rc`, a value cannot be owned by more than one variable.\n-\n-Sometimes we don't need to move the value. Using a reference, we can let another\n-function borrow the value without changing its ownership. In the example below,\n-we don't actually have to move our string to `calculate_length`, we can give it\n-a reference to it with `&` instead.\n-\n-```\n-fn main() {\n-    let s1 = String::from(\"hello\");\n-\n-    let len = calculate_length(&s1);\n-\n-    println!(\"The length of '{}' is {}.\", s1, len);\n-}\n-\n-fn calculate_length(s: &String) -> usize {\n-    s.len()\n-}\n-```\n-\n-A mutable reference can be created with `&mut`.\n-\n-Sometimes we don't want a reference, but a duplicate. All types marked `Clone`\n-can be duplicated by calling `.clone()`. Subsequent changes to a clone do not\n-affect the original variable.\n-\n-Most types in the standard library are marked `Clone`. The example below\n-demonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\n-copied to `s2`. Then the first character of `s1` is removed, without affecting\n-`s2`. \"any many\" is printed to the console.\n-\n-```\n-fn main() {\n-    let mut s1 = String::from(\"many\");\n-    let s2 = s1.clone();\n-    s1.remove(0);\n-    println!(\"{} {}\", s1, s2);\n-}\n-```\n-\n-If we control the definition of a type, we can implement `Clone` on it ourselves\n-with `#[derive(Clone)]`.\n-\n-Some types have no ownership semantics at all and are trivial to duplicate. An\n-example is `i32` and the other number types. We don't have to call `.clone()` to\n-clone them, because they are marked `Copy` in addition to `Clone`.  Implicit\n-cloning is more convenient in this case. We can mark our own types `Copy` if\n-all their members also are marked `Copy`.\n-\n-In the example below, we implement a `Point` type. Because it only stores two\n-integers, we opt-out of ownership semantics with `Copy`. Then we can\n-`let p2 = p1` without `p1` being moved.\n-\n-```\n-#[derive(Copy, Clone)]\n-struct Point { x: i32, y: i32 }\n-\n-fn main() {\n-    let mut p1 = Point{ x: -1, y: 2 };\n-    let p2 = p1;\n-    p1.x = 1;\n-    println!(\"p1: {}, {}\", p1.x, p1.y);\n-    println!(\"p2: {}, {}\", p2.x, p2.y);\n-}\n-```\n-\n-Alternatively, if we don't control the struct's definition, or mutable shared\n-ownership is truly required, we can use `Rc` and `RefCell`:\n-\n-```\n-use std::cell::RefCell;\n-use std::rc::Rc;\n-\n-struct MyStruct { s: u32 }\n-\n-fn main() {\n-    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n-    let y = x.clone();\n-    x.borrow_mut().s = 6;\n-    println!(\"{}\", x.borrow().s);\n-}\n-```\n-\n-With this approach, x and y share ownership of the data via the `Rc` (reference\n-count type). `RefCell` essentially performs runtime borrow checking: ensuring\n-that at most one writer or multiple readers can access the data at any one time.\n-\n-If you wish to learn more about ownership in Rust, start with the chapter in the\n-Book:\n-\n-https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n-\"##,\n-\n-E0383: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error occurs when an attempt is made to partially reinitialize a\n-structure that is currently uninitialized.\n-\n-For example, this can happen when a drop has taken place:\n-\n-```compile_fail\n-struct Foo {\n-    a: u32,\n-}\n-impl Drop for Foo {\n-    fn drop(&mut self) { /* ... */ }\n-}\n-\n-let mut x = Foo { a: 1 };\n-drop(x); // `x` is now uninitialized\n-x.a = 2; // error, partial reinitialization of uninitialized structure `t`\n-```\n-\n-This error can be fixed by fully reinitializing the structure in question:\n-\n-```\n-struct Foo {\n-    a: u32,\n-}\n-impl Drop for Foo {\n-    fn drop(&mut self) { /* ... */ }\n-}\n-\n-let mut x = Foo { a: 1 };\n-drop(x);\n-x = Foo { a: 2 };\n-```\n-\"##,\n-\n-E0384: r##\"\n-This error occurs when an attempt is made to reassign an immutable variable.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0384\n-fn main() {\n-    let x = 3;\n-    x = 5; // error, reassignment of immutable variable\n-}\n-```\n-\n-By default, variables in Rust are immutable. To fix this error, add the keyword\n-`mut` after the keyword `let` when declaring the variable. For example:\n-\n-```\n-fn main() {\n-    let mut x = 3;\n-    x = 5;\n-}\n-```\n-\"##,\n-\n-E0386: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error occurs when an attempt is made to mutate the target of a mutable\n-reference stored inside an immutable container.\n-\n-For example, this can happen when storing a `&mut` inside an immutable `Box`:\n-\n-```\n-let mut x: i64 = 1;\n-let y: Box<_> = Box::new(&mut x);\n-**y = 2; // error, cannot assign to data in an immutable container\n-```\n-\n-This error can be fixed by making the container mutable:\n-\n-```\n-let mut x: i64 = 1;\n-let mut y: Box<_> = Box::new(&mut x);\n-**y = 2;\n-```\n-\n-It can also be fixed by using a type with interior mutability, such as `Cell`\n-or `RefCell`:\n-\n-```\n-use std::cell::Cell;\n-\n-let x: i64 = 1;\n-let y: Box<Cell<_>> = Box::new(Cell::new(x));\n-y.set(2);\n-```\n-\"##,\n-\n-E0387: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error occurs when an attempt is made to mutate or mutably reference data\n-that a closure has captured immutably.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-// Accepts a function or a closure that captures its environment immutably.\n-// Closures passed to foo will not be able to mutate their closed-over state.\n-fn foo<F: Fn()>(f: F) { }\n-\n-// Attempts to mutate closed-over data. Error message reads:\n-// `cannot assign to data in a captured outer variable...`\n-fn mutable() {\n-    let mut x = 0u32;\n-    foo(|| x = 2);\n-}\n-\n-// Attempts to take a mutable reference to closed-over data.  Error message\n-// reads: `cannot borrow data mutably in a captured outer variable...`\n-fn mut_addr() {\n-    let mut x = 0u32;\n-    foo(|| { let y = &mut x; });\n-}\n-```\n-\n-The problem here is that foo is defined as accepting a parameter of type `Fn`.\n-Closures passed into foo will thus be inferred to be of type `Fn`, meaning that\n-they capture their context immutably.\n-\n-If the definition of `foo` is under your control, the simplest solution is to\n-capture the data mutably. This can be done by defining `foo` to take FnMut\n-rather than Fn:\n-\n-```\n-fn foo<F: FnMut()>(f: F) { }\n-```\n-\n-Alternatively, we can consider using the `Cell` and `RefCell` types to achieve\n-interior mutability through a shared reference. Our example's `mutable`\n-function could be redefined as below:\n-\n-```\n-use std::cell::Cell;\n-\n-fn foo<F: Fn()>(f: F) { }\n-\n-fn mutable() {\n-    let x = Cell::new(0u32);\n-    foo(|| x.set(2));\n-}\n-```\n-\n-You can read more about cell types in the API documentation:\n-\n-https://doc.rust-lang.org/std/cell/\n-\"##,\n-\n-E0388: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\"##,\n-\n-E0389: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-An attempt was made to mutate data using a non-mutable reference. This\n-commonly occurs when attempting to assign to a non-mutable reference of a\n-mutable reference (`&(&mut T)`).\n-\n-Erroneous code example:\n-\n-```compile_fail\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-    let fancy_ref = &(&mut fancy);\n-    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\n-Here, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\n-immutable reference to a value borrows it immutably. There can be multiple\n-references of type `&(&mut T)` that point to the same value, so they must be\n-immutable to prevent multiple mutable references to the same value.\n-\n-To fix this, either remove the outer reference:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-\n-    let fancy_ref = &mut fancy;\n-    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n-\n-    fancy_ref.num = 6; // No error!\n-\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\n-Or make the outer reference mutable:\n-\n-```\n-struct FancyNum {\n-    num: u8\n-}\n-\n-fn main() {\n-    let mut fancy = FancyNum{ num: 5 };\n-\n-    let fancy_ref = &mut (&mut fancy);\n-    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n-\n-    fancy_ref.num = 6; // No error!\n-\n-    println!(\"{}\", fancy_ref.num);\n-}\n-```\n-\"##,\n-\n-E0492: r##\"\n-A borrow of a constant containing interior mutability was attempted.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0492\n-use std::sync::atomic::AtomicUsize;\n-\n-const A: AtomicUsize = AtomicUsize::new(0);\n-static B: &'static AtomicUsize = &A;\n-// error: cannot borrow a constant which may contain interior mutability,\n-//        create a static instead\n-```\n-\n-A `const` represents a constant value that should never change. If one takes\n-a `&` reference to the constant, then one is taking a pointer to some memory\n-location containing the value. Normally this is perfectly fine: most values\n-can't be changed via a shared `&` pointer, but interior mutability would allow\n-it. That is, a constant value could be mutated. On the other hand, a `static` is\n-explicitly a single memory location, which can be mutated at will.\n-\n-So, in order to solve this error, either use statics which are `Sync`:\n-\n-```\n-use std::sync::atomic::AtomicUsize;\n-\n-static A: AtomicUsize = AtomicUsize::new(0);\n-static B: &'static AtomicUsize = &A; // ok!\n-```\n-\n-You can also have this error while using a cell type:\n-\n-```compile_fail,E0492\n-use std::cell::Cell;\n-\n-const A: Cell<usize> = Cell::new(1);\n-const B: &Cell<usize> = &A;\n-// error: cannot borrow a constant which may contain interior mutability,\n-//        create a static instead\n-\n-// or:\n-struct C { a: Cell<usize> }\n-\n-const D: C = C { a: Cell::new(1) };\n-const E: &Cell<usize> = &D.a; // error\n-\n-// or:\n-const F: &C = &D; // error\n-```\n-\n-This is because cell types do operations that are not thread-safe. Due to this,\n-they don't implement Sync and thus can't be placed in statics.\n-\n-However, if you still wish to use these types, you can achieve this by an unsafe\n-wrapper:\n-\n-```\n-use std::cell::Cell;\n-use std::marker::Sync;\n-\n-struct NotThreadSafe<T> {\n-    value: Cell<T>,\n-}\n-\n-unsafe impl<T> Sync for NotThreadSafe<T> {}\n-\n-static A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\n-static B: &'static NotThreadSafe<usize> = &A; // ok!\n-```\n-\n-Remember this solution is unsafe! You will have to ensure that accesses to the\n-cell are synchronized.\n-\"##,\n-\n-E0493: r##\"\n-A type with a `Drop` implementation was destructured when trying to initialize\n-a static item.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0493\n-enum DropType {\n-    A,\n-}\n-\n-impl Drop for DropType {\n-    fn drop(&mut self) {}\n-}\n-\n-struct Foo {\n-    field1: DropType,\n-}\n-\n-static FOO: Foo = Foo { ..Foo { field1: DropType::A } }; // error!\n-```\n-\n-The problem here is that if the given type or one of its fields implements the\n-`Drop` trait, this `Drop` implementation cannot be called during the static\n-type initialization which might cause a memory leak. To prevent this issue,\n-you need to instantiate all the static type's fields by hand.\n-\n-```\n-enum DropType {\n-    A,\n-}\n-\n-impl Drop for DropType {\n-    fn drop(&mut self) {}\n-}\n-\n-struct Foo {\n-    field1: DropType,\n-}\n-\n-static FOO: Foo = Foo { field1: DropType::A }; // We initialize all fields\n-                                               // by hand.\n-```\n-\"##,\n-\n-E0499: r##\"\n-A variable was borrowed as mutable more than once.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0499\n-let mut i = 0;\n-let mut x = &mut i;\n-let mut a = &mut i;\n-x;\n-// error: cannot borrow `i` as mutable more than once at a time\n-```\n-\n-Please note that in rust, you can either have many immutable references, or one\n-mutable reference. Take a look at\n-https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html for more\n-information. Example:\n-\n-\n-```\n-let mut i = 0;\n-let mut x = &mut i; // ok!\n-\n-// or:\n-let mut i = 0;\n-let a = &i; // ok!\n-let b = &i; // still ok!\n-let c = &i; // still ok!\n-b;\n-a;\n-```\n-\"##,\n-\n-E0500: r##\"\n-A borrowed variable was used by a closure.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0500\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let nights_watch = &jon_snow;\n-    let starks = || {\n-        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n-                       //        but it is already borrowed\n-    };\n-    println!(\"{}\", nights_watch);\n-}\n-```\n-\n-In here, `jon_snow` is already borrowed by the `nights_watch` reference, so it\n-cannot be borrowed by the `starks` closure at the same time. To fix this issue,\n-you can create the closure after the borrow has ended:\n-\n-```\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let nights_watch = &jon_snow;\n-    println!(\"{}\", nights_watch);\n-    let starks = || {\n-        *jon_snow = 3;\n-    };\n-}\n-```\n-\n-Or, if the type implements the `Clone` trait, you can clone it between\n-closures:\n-\n-```\n-fn you_know_nothing(jon_snow: &mut i32) {\n-    let mut jon_copy = jon_snow.clone();\n-    let starks = || {\n-        *jon_snow = 3;\n-    };\n-    println!(\"{}\", jon_copy);\n-}\n-```\n-\"##,\n-\n-E0501: r##\"\n-This error indicates that a mutable variable is being used while it is still\n-captured by a closure. Because the closure has borrowed the variable, it is not\n-available for use until the closure goes out of scope.\n-\n-Note that a capture will either move or borrow a variable, but in this\n-situation, the closure is borrowing the variable. Take a look at\n-http://rustbyexample.com/fn/closures/capture.html for more information about\n-capturing.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0501\n-fn inside_closure(x: &mut i32) {\n-    // Actions which require unique access\n-}\n-\n-fn outside_closure(x: &mut i32) {\n-    // Actions which require unique access\n-}\n-\n-fn foo(a: &mut i32) {\n-    let mut bar = || {\n-        inside_closure(a)\n-    };\n-    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n-                        //        closure requires unique access.\n-    bar();\n-}\n-```\n-\n-To fix this error, you can finish using the closure before using the captured\n-variable:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    let mut bar = || {\n-        inside_closure(a)\n-    };\n-    bar();\n-    // borrow on `a` ends.\n-    outside_closure(a); // ok!\n-}\n-```\n-\n-Or you can pass the variable as a parameter to the closure:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    let mut bar = |s: &mut i32| {\n-        inside_closure(s)\n-    };\n-    outside_closure(a);\n-    bar(a);\n-}\n-```\n-\n-It may be possible to define the closure later:\n-\n-```\n-fn inside_closure(x: &mut i32) {}\n-fn outside_closure(x: &mut i32) {}\n-\n-fn foo(a: &mut i32) {\n-    outside_closure(a);\n-    let mut bar = || {\n-        inside_closure(a)\n-    };\n-    bar();\n-}\n-```\n-\"##,\n-\n-E0502: r##\"\n-This error indicates that you are trying to borrow a variable as mutable when it\n-has already been borrowed as immutable.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0502\n-fn bar(x: &mut i32) {}\n-fn foo(a: &mut i32) {\n-    let ref y = a; // a is borrowed as immutable.\n-    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n-            //        as immutable\n-    println!(\"{}\", y);\n-}\n-```\n-\n-To fix this error, ensure that you don't have any other references to the\n-variable before trying to access it mutably:\n-\n-```\n-fn bar(x: &mut i32) {}\n-fn foo(a: &mut i32) {\n-    bar(a);\n-    let ref y = a; // ok!\n-    println!(\"{}\", y);\n-}\n-```\n-\n-For more information on the rust ownership system, take a look at\n-https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html.\n-\"##,\n-\n-E0503: r##\"\n-A value was used after it was mutably borrowed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0503\n-fn main() {\n-    let mut value = 3;\n-    // Create a mutable borrow of `value`.\n-    let borrow = &mut value;\n-    let _sum = value + 1; // error: cannot use `value` because\n-                          //        it was mutably borrowed\n-    println!(\"{}\", borrow);\n-}\n-```\n-\n-In this example, `value` is mutably borrowed by `borrow` and cannot be\n-used to calculate `sum`. This is not possible because this would violate\n-Rust's mutability rules.\n-\n-You can fix this error by finishing using the borrow before the next use of\n-the value:\n-\n-```\n-fn main() {\n-    let mut value = 3;\n-    let borrow = &mut value;\n-    println!(\"{}\", borrow);\n-    // The block has ended and with it the borrow.\n-    // You can now use `value` again.\n-    let _sum = value + 1;\n-}\n-```\n-\n-Or by cloning `value` before borrowing it:\n-\n-```\n-fn main() {\n-    let mut value = 3;\n-    // We clone `value`, creating a copy.\n-    let value_cloned = value.clone();\n-    // The mutable borrow is a reference to `value` and\n-    // not to `value_cloned`...\n-    let borrow = &mut value;\n-    // ... which means we can still use `value_cloned`,\n-    let _sum = value_cloned + 1;\n-    // even though the borrow only ends here.\n-    println!(\"{}\", borrow);\n-}\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n-\"##,\n-\n-E0504: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-This error occurs when an attempt is made to move a borrowed variable into a\n-closure.\n-\n-Erroneous code example:\n-\n-```compile_fail\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-\n-    let x = move || {\n-        println!(\"child function: {}\", fancy_num.num);\n-        // error: cannot move `fancy_num` into closure because it is borrowed\n-    };\n-\n-    x();\n-    println!(\"main function: {}\", fancy_ref.num);\n-}\n-```\n-\n-Here, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\n-the closure `x`. There is no way to move a value into a closure while it is\n-borrowed, as that would invalidate the borrow.\n-\n-If the closure can't outlive the value being moved, try using a reference\n-rather than moving:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-\n-    let x = move || {\n-        // fancy_ref is usable here because it doesn't move `fancy_num`\n-        println!(\"child function: {}\", fancy_ref.num);\n-    };\n-\n-    x();\n-\n-    println!(\"main function: {}\", fancy_num.num);\n-}\n-```\n-\n-If the value has to be borrowed and then moved, try limiting the lifetime of\n-the borrow using a scoped block:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"main function: {}\", fancy_ref.num);\n-        // `fancy_ref` goes out of scope here\n-    }\n-\n-    let x = move || {\n-        // `fancy_num` can be moved now (no more references exist)\n-        println!(\"child function: {}\", fancy_num.num);\n-    };\n-\n-    x();\n-}\n-```\n-\n-If the lifetime of a reference isn't enough, such as in the case of threading,\n-consider using an `Arc` to create a reference-counted value:\n-\n-```\n-use std::sync::Arc;\n-use std::thread;\n-\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n-    let fancy_ref2 = fancy_ref1.clone();\n-\n-    let x = thread::spawn(move || {\n-        // `fancy_ref1` can be moved and has a `'static` lifetime\n-        println!(\"child thread: {}\", fancy_ref1.num);\n-    });\n-\n-    x.join().expect(\"child thread should finish\");\n-    println!(\"main thread: {}\", fancy_ref2.num);\n-}\n-```\n-\"##,\n-\n-E0505: r##\"\n-A value was moved out while it was still borrowed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0505\n-struct Value {}\n-\n-fn borrow(val: &Value) {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    let _ref_to_val: &Value = &x;\n-    eat(x);\n-    borrow(_ref_to_val);\n-}\n-```\n-\n-Here, the function `eat` takes ownership of `x`. However,\n-`x` cannot be moved because the borrow to `_ref_to_val`\n-needs to last till the function `borrow`.\n-To fix that you can do a few different things:\n-\n-* Try to avoid moving the variable.\n-* Release borrow before move.\n-* Implement the `Copy` trait on the type.\n-\n-Examples:\n-\n-```\n-struct Value {}\n-\n-fn borrow(val: &Value) {}\n-\n-fn eat(val: &Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-\n-    let ref_to_val: &Value = &x;\n-    eat(&x); // pass by reference, if it's possible\n-    borrow(ref_to_val);\n-}\n-```\n-\n-Or:\n-\n-```\n-struct Value {}\n-\n-fn borrow(val: &Value) {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-\n-    let ref_to_val: &Value = &x;\n-    borrow(ref_to_val);\n-    // ref_to_val is no longer used.\n-    eat(x);\n-}\n-```\n-\n-Or:\n-\n-```\n-#[derive(Clone, Copy)] // implement Copy trait\n-struct Value {}\n-\n-fn borrow(val: &Value) {}\n-\n-fn eat(val: Value) {}\n-\n-fn main() {\n-    let x = Value{};\n-    let ref_to_val: &Value = &x;\n-    eat(x); // it will be copied here.\n-    borrow(ref_to_val);\n-}\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n-\"##,\n-\n-E0506: r##\"\n-This error occurs when an attempt is made to assign to a borrowed value.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0506\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let fancy_ref = &fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-    // error: cannot assign to `fancy_num` because it is borrowed\n-\n-    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n-}\n-```\n-\n-Because `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\n-be assigned to a new value as it would invalidate the reference.\n-\n-Alternatively, we can move out of `fancy_num` into a second `fancy_num`:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-    let moved_num = fancy_num;\n-    fancy_num = FancyNum { num: 6 };\n-\n-    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n-}\n-```\n-\n-If the value has to be borrowed, try limiting the lifetime of the borrow using\n-a scoped block:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    {\n-        let fancy_ref = &fancy_num;\n-        println!(\"Ref: {}\", fancy_ref.num);\n-    }\n-\n-    // Works because `fancy_ref` is no longer in scope\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-```\n-\n-Or by moving the reference into a function:\n-\n-```\n-struct FancyNum {\n-    num: u8,\n-}\n-\n-fn main() {\n-    let mut fancy_num = FancyNum { num: 5 };\n-\n-    print_fancy_ref(&fancy_num);\n-\n-    // Works because function borrow has ended\n-    fancy_num = FancyNum { num: 6 };\n-    println!(\"Num: {}\", fancy_num.num);\n-}\n-\n-fn print_fancy_ref(fancy_ref: &FancyNum){\n-    println!(\"Ref: {}\", fancy_ref.num);\n-}\n-```\n-\"##,\n-\n-E0507: r##\"\n-You tried to move out of a value which was borrowed.\n-\n-This can also happen when using a type implementing `Fn` or `FnMut`, as neither\n-allows moving out of them (they usually represent closures which can be called\n-more than once). Much of the text following applies equally well to non-`FnOnce`\n-closure bodies.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0507\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n-}\n-```\n-\n-Here, the `nothing_is_true` method takes the ownership of `self`. However,\n-`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\n-which is a borrow of the content owned by the `RefCell`. To fix this error,\n-you have three choices:\n-\n-* Try to avoid moving the variable.\n-* Somehow reclaim the ownership.\n-* Implement the `Copy` trait on the type.\n-\n-Examples:\n-\n-```\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(&self) {} // First case, we don't take ownership\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // ok!\n-}\n-```\n-\n-Or:\n-\n-```\n-use std::cell::RefCell;\n-\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-    let x = x.into_inner(); // we get back ownership\n-\n-    x.nothing_is_true(); // ok!\n-}\n-```\n-\n-Or:\n-\n-```\n-use std::cell::RefCell;\n-\n-#[derive(Clone, Copy)] // we implement the Copy trait\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-fn main() {\n-    let x = RefCell::new(TheDarkKnight);\n-\n-    x.borrow().nothing_is_true(); // ok!\n-}\n-```\n-\n-Moving a member out of a mutably borrowed struct will also cause E0507 error:\n-\n-```compile_fail,E0507\n-struct TheDarkKnight;\n-\n-impl TheDarkKnight {\n-    fn nothing_is_true(self) {}\n-}\n-\n-struct Batcave {\n-    knight: TheDarkKnight\n-}\n-\n-fn main() {\n-    let mut cave = Batcave {\n-        knight: TheDarkKnight\n-    };\n-    let borrowed = &mut cave;\n-\n-    borrowed.knight.nothing_is_true(); // E0507\n-}\n-```\n-\n-It is fine only if you put something back. `mem::replace` can be used for that:\n-\n-```\n-# struct TheDarkKnight;\n-# impl TheDarkKnight { fn nothing_is_true(self) {} }\n-# struct Batcave { knight: TheDarkKnight }\n-use std::mem;\n-\n-let mut cave = Batcave {\n-    knight: TheDarkKnight\n-};\n-let borrowed = &mut cave;\n-\n-mem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n-```\n-\n-You can find more information about borrowing in the rust-book:\n-http://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n-\"##,\n-\n-E0508: r##\"\n-A value was moved out of a non-copy fixed-size array.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0508\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\n-                           //        a non-copy fixed-size array\n-}\n-```\n-\n-The first element was moved out of the array, but this is not\n-possible because `NonCopy` does not implement the `Copy` trait.\n-\n-Consider borrowing the element instead of moving it:\n-\n-```\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    let _value = &array[0]; // Borrowing is allowed, unlike moving.\n-}\n-```\n-\n-Alternatively, if your type implements `Clone` and you need to own the value,\n-consider borrowing and then cloning:\n-\n-```\n-#[derive(Clone)]\n-struct NonCopy;\n-\n-fn main() {\n-    let array = [NonCopy; 1];\n-    // Now you can clone the array element.\n-    let _value = array[0].clone();\n-}\n-```\n-\"##,\n-\n-E0509: r##\"\n-This error occurs when an attempt is made to move out of a value whose type\n-implements the `Drop` trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0509\n-struct FancyNum {\n-    num: usize\n-}\n-\n-struct DropStruct {\n-    fancy: FancyNum\n-}\n-\n-impl Drop for DropStruct {\n-    fn drop(&mut self) {\n-        // Destruct DropStruct, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n-    let fancy_field = drop_struct.fancy; // Error E0509\n-    println!(\"Fancy: {}\", fancy_field.num);\n-    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n-}\n-```\n-\n-Here, we tried to move a field out of a struct of type `DropStruct` which\n-implements the `Drop` trait. However, a struct cannot be dropped if one or\n-more of its fields have been moved.\n-\n-Structs implementing the `Drop` trait have an implicit destructor that gets\n-called when they go out of scope. This destructor may use the fields of the\n-struct, so moving out of the struct could make it impossible to run the\n-destructor. Therefore, we must think of all values whose type implements the\n-`Drop` trait as single units whose fields cannot be moved.\n-\n-This error can be fixed by creating a reference to the fields of a struct,\n-enum, or tuple using the `ref` keyword:\n-\n-```\n-struct FancyNum {\n-    num: usize\n-}\n-\n-struct DropStruct {\n-    fancy: FancyNum\n-}\n-\n-impl Drop for DropStruct {\n-    fn drop(&mut self) {\n-        // Destruct DropStruct, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n-    let ref fancy_field = drop_struct.fancy; // No more errors!\n-    println!(\"Fancy: {}\", fancy_field.num);\n-    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n-}\n-```\n-\n-Note that this technique can also be used in the arms of a match expression:\n-\n-```\n-struct FancyNum {\n-    num: usize\n-}\n-\n-enum DropEnum {\n-    Fancy(FancyNum)\n-}\n-\n-impl Drop for DropEnum {\n-    fn drop(&mut self) {\n-        // Destruct DropEnum, possibly using FancyNum\n-    }\n-}\n-\n-fn main() {\n-    // Creates and enum of type `DropEnum`, which implements `Drop`\n-    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n-    match drop_enum {\n-        // Creates a reference to the inside of `DropEnum::Fancy`\n-        DropEnum::Fancy(ref fancy_field) => // No error!\n-            println!(\"It was fancy-- {}!\", fancy_field.num),\n-    }\n-    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n-}\n-```\n-\"##,\n-\n-E0510: r##\"\n-Cannot mutate place in this match guard.\n-\n-When matching on a variable it cannot be mutated in the match guards, as this\n-could cause the match to be non-exhaustive:\n-\n-```compile_fail,E0510\n-let mut x = Some(0);\n-match x {\n-    None => (),\n-    Some(_) if { x = None; false } => (),\n-    Some(v) => (), // No longer matches\n-}\n-```\n-\n-Here executing `x = None` would modify the value being matched and require us\n-to go \"back in time\" to the `None` arm.\n-\"##,\n-\n-E0515: r##\"\n-Cannot return value that references local variable\n-\n-Local variables, function parameters and temporaries are all dropped before the\n-end of the function body. So a reference to them cannot be returned.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0515\n-fn get_dangling_reference() -> &'static i32 {\n-    let x = 0;\n-    &x\n-}\n-```\n-\n-```compile_fail,E0515\n-use std::slice::Iter;\n-fn get_dangling_iterator<'a>() -> Iter<'a, i32> {\n-    let v = vec![1, 2, 3];\n-    v.iter()\n-}\n-```\n-\n-Consider returning an owned value instead:\n-\n-```\n-use std::vec::IntoIter;\n-\n-fn get_integer() -> i32 {\n-    let x = 0;\n-    x\n-}\n-\n-fn get_owned_iterator() -> IntoIter<i32> {\n-    let v = vec![1, 2, 3];\n-    v.into_iter()\n-}\n-```\n-\"##,\n-\n-E0524: r##\"\n-A variable which requires unique access is being used in more than one closure\n-at the same time.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0524\n-fn set(x: &mut isize) {\n-    *x += 4;\n-}\n-\n-fn dragoooon(x: &mut isize) {\n-    let mut c1 = || set(x);\n-    let mut c2 = || set(x); // error!\n-\n-    c2();\n-    c1();\n-}\n-```\n-\n-To solve this issue, multiple solutions are available. First, is it required\n-for this variable to be used in more than one closure at a time? If it is the\n-case, use reference counted types such as `Rc` (or `Arc` if it runs\n-concurrently):\n-\n-```\n-use std::rc::Rc;\n-use std::cell::RefCell;\n-\n-fn set(x: &mut isize) {\n-    *x += 4;\n-}\n-\n-fn dragoooon(x: &mut isize) {\n-    let x = Rc::new(RefCell::new(x));\n-    let y = Rc::clone(&x);\n-    let mut c1 = || { let mut x2 = x.borrow_mut(); set(&mut x2); };\n-    let mut c2 = || { let mut x2 = y.borrow_mut(); set(&mut x2); }; // ok!\n-\n-    c2();\n-    c1();\n-}\n-```\n-\n-If not, just run closures one at a time:\n-\n-```\n-fn set(x: &mut isize) {\n-    *x += 4;\n-}\n-\n-fn dragoooon(x: &mut isize) {\n-    { // This block isn't necessary since non-lexical lifetimes, it's just to\n-      // make it more clear.\n-        let mut c1 = || set(&mut *x);\n-        c1();\n-    } // `c1` has been dropped here so we're free to use `x` again!\n-    let mut c2 = || set(&mut *x);\n-    c2();\n-}\n-```\n-\"##,\n-\n-E0579: r##\"\n-When matching against an exclusive range, the compiler verifies that the range\n-is non-empty. Exclusive range patterns include the start point but not the end\n-point, so this is equivalent to requiring the start of the range to be less\n-than the end of the range.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0579\n-#![feature(exclusive_range_pattern)]\n-\n-fn main() {\n-    match 5u32 {\n-        // This range is ok, albeit pointless.\n-        1 .. 2 => {}\n-        // This range is empty, and the compiler can tell.\n-        5 .. 5 => {} // error!\n-    }\n-}\n-```\n-\"##,\n-\n-E0594: r##\"\n-A non-mutable value was assigned a value.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0594\n-struct SolarSystem {\n-    earth: i32,\n-}\n-\n-let ss = SolarSystem { earth: 3 };\n-ss.earth = 2; // error!\n-```\n-\n-To fix this error, just declare `ss` as mutable by using the `mut` keyword:\n-\n-```\n-struct SolarSystem {\n-    earth: i32,\n-}\n-\n-let mut ss = SolarSystem { earth: 3 }; // declaring `ss` as mutable\n-ss.earth = 2; // ok!\n-```\n-\"##,\n-\n-E0595: r##\"\n-#### Note: this error code is no longer emitted by the compiler.\n-\n-Closures cannot mutate immutable captured variables.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0594\n-let x = 3; // error: closure cannot assign to immutable local variable `x`\n-let mut c = || { x += 1 };\n-```\n-\n-Make the variable binding mutable:\n-\n-```\n-let mut x = 3; // ok!\n-let mut c = || { x += 1 };\n-```\n-\"##,\n-\n-E0596: r##\"\n-This error occurs because you tried to mutably borrow a non-mutable variable.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0596\n-let x = 1;\n-let y = &mut x; // error: cannot borrow mutably\n-```\n-\n-In here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\n-fails. To fix this error, you need to make `x` mutable:\n-\n-```\n-let mut x = 1;\n-let y = &mut x; // ok!\n-```\n-\"##,\n-\n-E0597: r##\"\n-This error occurs because a value was dropped while it was still borrowed\n-\n-Erroneous code example:\n-\n-```compile_fail,E0597\n-struct Foo<'a> {\n-    x: Option<&'a u32>,\n-}\n-\n-let mut x = Foo { x: None };\n-{\n-    let y = 0;\n-    x.x = Some(&y); // error: `y` does not live long enough\n-}\n-println!(\"{:?}\", x.x);\n-```\n-\n-In here, `y` is dropped at the end of the inner scope, but it is borrowed by\n-`x` until the `println`. To fix the previous example, just remove the scope\n-so that `y` isn't dropped until after the println\n-\n-```\n-struct Foo<'a> {\n-    x: Option<&'a u32>,\n-}\n-\n-let mut x = Foo { x: None };\n-\n-let y = 0;\n-x.x = Some(&y);\n-\n-println!(\"{:?}\", x.x);\n-```\n-\"##,\n-\n-E0626: r##\"\n-This error occurs because a borrow in a generator persists across a\n-yield point.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0626\n-# #![feature(generators, generator_trait, pin)]\n-# use std::ops::Generator;\n-# use std::pin::Pin;\n-let mut b = || {\n-    let a = &String::new(); // <-- This borrow...\n-    yield (); // ...is still in scope here, when the yield occurs.\n-    println!(\"{}\", a);\n-};\n-Pin::new(&mut b).resume();\n-```\n-\n-At present, it is not permitted to have a yield that occurs while a\n-borrow is still in scope. To resolve this error, the borrow must\n-either be \"contained\" to a smaller scope that does not overlap the\n-yield or else eliminated in another way. So, for example, we might\n-resolve the previous example by removing the borrow and just storing\n-the integer by value:\n-\n-```\n-# #![feature(generators, generator_trait, pin)]\n-# use std::ops::Generator;\n-# use std::pin::Pin;\n-let mut b = || {\n-    let a = 3;\n-    yield ();\n-    println!(\"{}\", a);\n-};\n-Pin::new(&mut b).resume();\n-```\n-\n-This is a very simple case, of course. In more complex cases, we may\n-wish to have more than one reference to the value that was borrowed --\n-in those cases, something like the `Rc` or `Arc` types may be useful.\n-\n-This error also frequently arises with iteration:\n-\n-```compile_fail,E0626\n-# #![feature(generators, generator_trait, pin)]\n-# use std::ops::Generator;\n-# use std::pin::Pin;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  for &x in &v { // <-- borrow of `v` is still in scope...\n-    yield x; // ...when this yield occurs.\n-  }\n-};\n-Pin::new(&mut b).resume();\n-```\n-\n-Such cases can sometimes be resolved by iterating \"by value\" (or using\n-`into_iter()`) to avoid borrowing:\n-\n-```\n-# #![feature(generators, generator_trait, pin)]\n-# use std::ops::Generator;\n-# use std::pin::Pin;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  for x in v { // <-- Take ownership of the values instead!\n-    yield x; // <-- Now yield is OK.\n-  }\n-};\n-Pin::new(&mut b).resume();\n-```\n-\n-If taking ownership is not an option, using indices can work too:\n-\n-```\n-# #![feature(generators, generator_trait, pin)]\n-# use std::ops::Generator;\n-# use std::pin::Pin;\n-let mut b = || {\n-  let v = vec![1,2,3];\n-  let len = v.len(); // (*)\n-  for i in 0..len {\n-    let x = v[i]; // (*)\n-    yield x; // <-- Now yield is OK.\n-  }\n-};\n-Pin::new(&mut b).resume();\n-\n-// (*) -- Unfortunately, these temporaries are currently required.\n-// See <https://github.com/rust-lang/rust/issues/43122>.\n-```\n-\"##,\n-\n-E0712: r##\"\n-This error occurs because a borrow of a thread-local variable was made inside a\n-function which outlived the lifetime of the function.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0712\n-#![feature(thread_local)]\n-\n-#[thread_local]\n-static FOO: u8 = 3;\n-\n-fn main() {\n-    let a = &FOO; // error: thread-local variable borrowed past end of function\n-\n-    std::thread::spawn(move || {\n-        println!(\"{}\", a);\n-    });\n-}\n-```\n-\"##,\n-\n-E0713: r##\"\n-This error occurs when an attempt is made to borrow state past the end of the\n-lifetime of a type that implements the `Drop` trait.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0713\n-#![feature(nll)]\n-\n-pub struct S<'a> { data: &'a mut String }\n-\n-impl<'a> Drop for S<'a> {\n-    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n-}\n-\n-fn demo<'a>(s: S<'a>) -> &'a mut String { let p = &mut *s.data; p }\n-```\n-\n-Here, `demo` tries to borrow the string data held within its\n-argument `s` and then return that borrow. However, `S` is\n-declared as implementing `Drop`.\n-\n-Structs implementing the `Drop` trait have an implicit destructor that\n-gets called when they go out of scope. This destructor gets exclusive\n-access to the fields of the struct when it runs.\n-\n-This means that when `s` reaches the end of `demo`, its destructor\n-gets exclusive access to its `&mut`-borrowed string data.  allowing\n-another borrow of that string data (`p`), to exist across the drop of\n-`s` would be a violation of the principle that `&mut`-borrows have\n-exclusive, unaliased access to their referenced data.\n-\n-This error can be fixed by changing `demo` so that the destructor does\n-not run while the string-data is borrowed; for example by taking `S`\n-by reference:\n-\n-```\n-pub struct S<'a> { data: &'a mut String }\n-\n-impl<'a> Drop for S<'a> {\n-    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n-}\n-\n-fn demo<'a>(s: &'a mut S<'a>) -> &'a mut String { let p = &mut *(*s).data; p }\n-```\n-\n-Note that this approach needs a reference to S with lifetime `'a`.\n-Nothing shorter than `'a` will suffice: a shorter lifetime would imply\n-that after `demo` finishes executing, something else (such as the\n-destructor!) could access `s.data` after the end of that shorter\n-lifetime, which would again violate the `&mut`-borrow's exclusive\n-access.\n-\"##,\n-\n-E0716: r##\"\n-This error indicates that a temporary value is being dropped\n-while a borrow is still in active use.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0716\n-fn foo() -> i32 { 22 }\n-fn bar(x: &i32) -> &i32 { x }\n-let p = bar(&foo());\n-         // ------ creates a temporary\n-let q = *p;\n-```\n-\n-Here, the expression `&foo()` is borrowing the expression\n-`foo()`. As `foo()` is a call to a function, and not the name of\n-a variable, this creates a **temporary** -- that temporary stores\n-the return value from `foo()` so that it can be borrowed.\n-You could imagine that `let p = bar(&foo());` is equivalent\n-to this:\n-\n-```compile_fail,E0597\n-# fn foo() -> i32 { 22 }\n-# fn bar(x: &i32) -> &i32 { x }\n-let p = {\n-  let tmp = foo(); // the temporary\n-  bar(&tmp)\n-}; // <-- tmp is freed as we exit this block\n-let q = p;\n-```\n-\n-Whenever a temporary is created, it is automatically dropped (freed)\n-according to fixed rules. Ordinarily, the temporary is dropped\n-at the end of the enclosing statement -- in this case, after the `let`.\n-This is illustrated in the example above by showing that `tmp` would\n-be freed as we exit the block.\n-\n-To fix this problem, you need to create a local variable\n-to store the value in rather than relying on a temporary.\n-For example, you might change the original program to\n-the following:\n-\n-```\n-fn foo() -> i32 { 22 }\n-fn bar(x: &i32) -> &i32 { x }\n-let value = foo(); // dropped at the end of the enclosing block\n-let p = bar(&value);\n-let q = *p;\n-```\n-\n-By introducing the explicit `let value`, we allocate storage\n-that will last until the end of the enclosing block (when `value`\n-goes out of scope). When we borrow `&value`, we are borrowing a\n-local variable that already exists, and hence no temporary is created.\n-\n-Temporaries are not always dropped at the end of the enclosing\n-statement. In simple cases where the `&` expression is immediately\n-stored into a variable, the compiler will automatically extend\n-the lifetime of the temporary until the end of the enclosing\n-block. Therefore, an alternative way to fix the original\n-program is to write `let tmp = &foo()` and not `let tmp = foo()`:\n-\n-```\n-fn foo() -> i32 { 22 }\n-fn bar(x: &i32) -> &i32 { x }\n-let value = &foo();\n-let p = bar(value);\n-let q = *p;\n-```\n-\n-Here, we are still borrowing `foo()`, but as the borrow is assigned\n-directly into a variable, the temporary will not be dropped until\n-the end of the enclosing block. Similar rules apply when temporaries\n-are stored into aggregate structures like a tuple or struct:\n-\n-```\n-// Here, two temporaries are created, but\n-// as they are stored directly into `value`,\n-// they are not dropped until the end of the\n-// enclosing block.\n-fn foo() -> i32 { 22 }\n-let value = (&foo(), &foo());\n-```\n-\"##,\n-\n-E0723: r##\"\n-An feature unstable in `const` contexts was used.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0723\n-trait T {}\n-\n-impl T for () {}\n-\n-const fn foo() -> impl T { // error: `impl Trait` in const fn is unstable\n-    ()\n-}\n-```\n-\n-To enable this feature on a nightly version of rustc, add the `const_fn`\n-feature flag:\n-\n-```\n-#![feature(const_fn)]\n-\n-trait T {}\n-\n-impl T for () {}\n-\n-const fn foo() -> impl T {\n-    ()\n-}\n-```\n-\"##,\n-\n-E0729: r##\"\n-Support for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler\n-since 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow\n-checker for NLL uncovered some bugs in the old borrow checker, which in some\n-cases allowed unsound code to compile, resulting in memory safety issues.\n-\n-### What do I do?\n-\n-Change your code so the warning does no longer trigger. For backwards\n-compatibility, this unsound code may still compile (with a warning) right now.\n-However, at some point in the future, the compiler will no longer accept this\n-code and will throw a hard error.\n-\n-### Shouldn't you fix the old borrow checker?\n-\n-The old borrow checker has known soundness issues that are basically impossible\n-to fix. The new NLL-based borrow checker is the fix.\n-\n-### Can I turn these warnings into errors by denying a lint?\n-\n-No.\n-\n-### When are these warnings going to turn into errors?\n-\n-No formal timeline for turning the warnings into errors has been set. See\n-[GitHub issue 58781](https://github.com/rust-lang/rust/issues/58781) for more\n-information.\n-\n-### Why do I get this message with code that doesn't involve borrowing?\n-\n-There are some known bugs that trigger this message.\n-\"##,\n-\n-;\n-\n-//  E0008, // cannot bind by-move into a pattern guard\n-//  E0298, // cannot compare constants\n-//  E0299, // mismatched types between arms\n-//  E0471, // constant evaluation error (in pattern)\n-//  E0385, // {} in an aliasable location\n-    E0521, // borrowed data escapes outside of closure\n-//  E0526, // shuffle indices are not constant\n-//  E0598, // lifetime of {} is too short to guarantee its contents can be...\n-    E0625, // thread-local statics cannot be accessed at compile-time\n-}"}]}