{"sha": "7899699a4af9c4a286daa148bf17be0a0b740756", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4OTk2OTlhNGFmOWM0YTI4NmRhYTE0OGJmMTdiZTBhMGI3NDA3NTY=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2015-08-13T16:10:19Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2016-01-05T10:02:43Z"}, "message": "Implement fn alloc_bytes for Arena and fn clear for both arena types\n\nCloses #18471\nCloses #18261", "tree": {"sha": "96af6d0579b206a224235b331537bf415be8adc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96af6d0579b206a224235b331537bf415be8adc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7899699a4af9c4a286daa148bf17be0a0b740756", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7899699a4af9c4a286daa148bf17be0a0b740756", "html_url": "https://github.com/rust-lang/rust/commit/7899699a4af9c4a286daa148bf17be0a0b740756", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7899699a4af9c4a286daa148bf17be0a0b740756/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f1b1ec8fed0b4e79f3b00fac6698213d15b6027", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f1b1ec8fed0b4e79f3b00fac6698213d15b6027", "html_url": "https://github.com/rust-lang/rust/commit/5f1b1ec8fed0b4e79f3b00fac6698213d15b6027"}], "stats": {"total": 161, "additions": 143, "deletions": 18}, "files": [{"sha": "8c42fcfb81f36916422d3532e10e30ca7e02a99b", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 143, "deletions": 18, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/7899699a4af9c4a286daa148bf17be0a0b740756/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7899699a4af9c4a286daa148bf17be0a0b740756/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=7899699a4af9c4a286daa148bf17be0a0b740756", "patch": "@@ -46,6 +46,7 @@ use std::intrinsics;\n use std::marker::{PhantomData, Send};\n use std::mem;\n use std::ptr;\n+use std::slice;\n \n use alloc::heap;\n use alloc::raw_vec::RawVec;\n@@ -122,9 +123,8 @@ impl Chunk {\n /// plain-old-data (`Copy` types) and means we don't need to waste time running\n /// their destructors.\n pub struct Arena<'longer_than_self> {\n-    // The head is separated out from the list as a unbenchmarked\n-    // microoptimization, to avoid needing to case on the list to access the\n-    // head.\n+    // The heads are separated out from the list as a unbenchmarked\n+    // microoptimization, to avoid needing to case on the list to access a head.\n     head: RefCell<Chunk>,\n     copy_head: RefCell<Chunk>,\n     chunks: RefCell<Vec<Chunk>>,\n@@ -329,6 +329,37 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n             }\n         }\n     }\n+\n+    /// Allocates a slice of bytes of requested length. The bytes are not guaranteed to be zero\n+    /// if the arena has previously been cleared.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the requested length is too large and causes overflow.\n+    pub fn alloc_bytes(&self, len: usize) -> &mut [u8] {\n+        unsafe {\n+            // Check for overflow.\n+            self.copy_head.borrow().fill.get().checked_add(len).expect(\"length overflow\");\n+            let ptr = self.alloc_copy_inner(len, 1);\n+            intrinsics::assume(!ptr.is_null());\n+            slice::from_raw_parts_mut(ptr as *mut _, len)\n+        }\n+    }\n+\n+    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n+    pub fn clear(&mut self) {\n+        unsafe {\n+            self.head.borrow().destroy();\n+            self.head.borrow().fill.set(0);\n+            self.copy_head.borrow().fill.set(0);\n+            for chunk in self.chunks.borrow().iter() {\n+                if !chunk.is_copy.get() {\n+                    chunk.destroy();\n+                }\n+            }\n+            self.chunks.borrow_mut().clear();\n+        }\n+    }\n }\n \n #[test]\n@@ -495,6 +526,45 @@ impl<T> TypedArena<T> {\n             }\n         }\n     }\n+    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n+    pub fn clear(&mut self) {\n+        unsafe {\n+            // Clear the last chunk, which is partially filled.\n+            let mut chunks_borrow = self.chunks.borrow_mut();\n+            let last_idx = chunks_borrow.len() - 1;\n+            self.clear_last_chunk(&mut chunks_borrow[last_idx]);\n+            // If `T` is ZST, code below has no effect.\n+            for mut chunk in chunks_borrow.drain(..last_idx) {\n+                let cap = chunk.storage.cap();\n+                chunk.destroy(cap);\n+            }\n+        }\n+    }\n+\n+    // Drops the contents of the last chunk. The last chunk is partially empty, unlike all other\n+    // chunks.\n+    fn clear_last_chunk(&self, last_chunk: &mut TypedArenaChunk<T>) {\n+        // Determine how much was filled.\n+        let start = last_chunk.start() as usize;\n+        // We obtain the value of the pointer to the first uninitialized element.\n+        let end = self.ptr.get() as usize;\n+        // We then calculate the number of elements to be dropped in the last chunk,\n+        // which is the filled area's length.\n+        let diff = if mem::size_of::<T>() == 0 {\n+            // `T` is ZST. It can't have a drop flag, so the value here doesn't matter. We get\n+            // the number of zero-sized values in the last and only chunk, just out of caution.\n+            // Recall that `end` was incremented for each allocated value.\n+            end - start\n+        } else {\n+            (end - start) / mem::size_of::<T>()\n+        };\n+        // Pass that to the `destroy` method.\n+        unsafe {\n+            last_chunk.destroy(diff);\n+        }\n+        // Reset the chunk.\n+        self.ptr.set(last_chunk.start());\n+    }\n }\n \n impl<T> Drop for TypedArena<T> {\n@@ -504,24 +574,14 @@ impl<T> Drop for TypedArena<T> {\n             // Determine how much was filled.\n             let mut chunks_borrow = self.chunks.borrow_mut();\n             let mut last_chunk = chunks_borrow.pop().unwrap();\n-            let start = last_chunk.start() as usize;\n-            let end = self.ptr.get() as usize;\n-            let diff = if mem::size_of::<T>() == 0 {\n-                // Avoid division by zero.\n-                end - start\n-            } else {\n-                (end - start) / mem::size_of::<T>()\n-            };\n-\n-            // Pass that to the `destroy` method.\n-            last_chunk.destroy(diff);\n-            // Destroy this chunk.\n-            let _: RawVec<T> = mem::transmute(last_chunk);\n-\n+            // Drop the contents of the last chunk.\n+            self.clear_last_chunk(&mut last_chunk);\n+            // The last chunk will be dropped. Destroy all other chunks.\n             for chunk in chunks_borrow.iter_mut() {\n                 let cap = chunk.storage.cap();\n                 chunk.destroy(cap);\n             }\n+            // RawVec handles deallocation of `last_chunk` and `self.chunks`.\n         }\n     }\n }\n@@ -533,6 +593,7 @@ mod tests {\n     extern crate test;\n     use self::test::Bencher;\n     use super::{Arena, TypedArena};\n+    use std::rc::Rc;\n \n     #[allow(dead_code)]\n     struct Point {\n@@ -667,10 +728,74 @@ mod tests {\n     }\n \n     #[test]\n-    pub fn test_zero_sized() {\n+    pub fn test_typed_arena_zero_sized() {\n         let arena = TypedArena::new();\n         for _ in 0..100000 {\n             arena.alloc(());\n         }\n     }\n+\n+    #[test]\n+    pub fn test_arena_zero_sized() {\n+        let arena = Arena::new();\n+        for _ in 0..1000 {\n+            for _ in 0..100 {\n+                arena.alloc(|| ());\n+            }\n+            arena.alloc(|| Point {\n+                x: 1,\n+                y: 2,\n+                z: 3,\n+            });\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_typed_arena_clear() {\n+        let mut arena = TypedArena::new();\n+        for _ in 0..10 {\n+            arena.clear();\n+            for _ in 0..10000 {\n+                arena.alloc(Point {\n+                    x: 1,\n+                    y: 2,\n+                    z: 3,\n+                });\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_arena_clear() {\n+        let mut arena = Arena::new();\n+        for _ in 0..10 {\n+            arena.clear();\n+            for _ in 0..10000 {\n+                arena.alloc(|| Point {\n+                    x: 1,\n+                    y: 2,\n+                    z: 3,\n+                });\n+                arena.alloc(|| Noncopy {\n+                    string: \"hello world\".to_string(),\n+                    array: vec![],\n+                });\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_arena_alloc_bytes() {\n+        let arena = Arena::new();\n+        for i in 0..10000 {\n+            arena.alloc(|| Point {\n+                x: 1,\n+                y: 2,\n+                z: 3,\n+            });\n+            for byte in arena.alloc_bytes(i % 42).iter_mut() {\n+                *byte = i as u8;\n+            }\n+        }\n+    }\n }"}]}