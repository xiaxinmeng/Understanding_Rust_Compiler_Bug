{"sha": "2299d204e40e565396daabc7b8d5141cdef52c8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyOTlkMjA0ZTQwZTU2NTM5NmRhYWJjN2I4ZDUxNDFjZGVmNTJjOGI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-02-20T23:42:21Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-02-21T01:16:52Z"}, "message": "Further work on resolving and typechecking classes\n\nClass tests aren't working yet, but they fail a little later :-)\n\nAlso, make the parser correctly set a constructor's result type to\nits enclosing class type.", "tree": {"sha": "d44318a7c1a3ca7d7d6e93a020626538c0a4b0e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d44318a7c1a3ca7d7d6e93a020626538c0a4b0e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2299d204e40e565396daabc7b8d5141cdef52c8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2299d204e40e565396daabc7b8d5141cdef52c8b", "html_url": "https://github.com/rust-lang/rust/commit/2299d204e40e565396daabc7b8d5141cdef52c8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2299d204e40e565396daabc7b8d5141cdef52c8b/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5837e1e809af6d783984d94ca27fe488823ecfe6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5837e1e809af6d783984d94ca27fe488823ecfe6", "html_url": "https://github.com/rust-lang/rust/commit/5837e1e809af6d783984d94ca27fe488823ecfe6"}], "stats": {"total": 228, "additions": 200, "deletions": 28}, "files": [{"sha": "951fe54e093d8191c9e7c3242be9315aedbe396e", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 56, "deletions": 13, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=2299d204e40e565396daabc7b8d5141cdef52c8b", "patch": "@@ -151,7 +151,7 @@ enum dir { inside, outside, }\n // when looking up a variable name that's not yet in scope to check\n // if it's already bound to a enum.\n enum namespace { ns_val(ns_value_type), ns_type, ns_module, }\n-enum ns_value_type { ns_a_enum, ns_any_value, }\n+enum ns_value_type { ns_an_enum, ns_any_value, }\n \n fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n    {def_map: def_map, exp_map: exp_map, impl_map: impl_map} {\n@@ -469,7 +469,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n            variable a refers to a nullary enum. */\n           ast::pat_ident(p, none) {\n               alt lookup_in_scope(*e, sc, p.span, path_to_ident(p),\n-                                    ns_val(ns_a_enum)) {\n+                                    ns_val(ns_an_enum)) {\n                 some(fnd@ast::def_variant(_,_)) {\n                     e.def_map.insert(pat.id, fnd);\n                 }\n@@ -519,11 +519,16 @@ fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n       }\n       ast::item_class(tps, members, ctor_id, ctor_decl, ctor_block) {\n         visit::visit_ty_params(tps, sc, v);\n-        let ctor_scope = cons(scope_fn_expr(ctor_decl, ctor_id, tps), @sc);\n+        let class_scope = cons(scope_item(i), @sc);\n+        /* visit the constructor... */\n+        visit_fn_with_scope(e, visit::fk_item_fn(i.ident, tps), ctor_decl,\n+                            ctor_block, ctor_block.span, ctor_id,\n+                            class_scope, v);\n+        /* visit the items */\n         for cm in members {\n             alt cm.node.decl {\n-              class_method(i) { visit_item_with_scope(e, i, ctor_scope, v); }\n-              _ { } // instance var -- nothing to do\n+              class_method(i) { visit_item_with_scope(e, i, class_scope, v); }\n+              instance_var(_,t,_,_) { v.visit_ty(t, class_scope, v); }\n             }\n         }\n       }\n@@ -622,10 +627,10 @@ fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n     // to enum foo, or is it binding a new name foo?)\n     alt loc.node.pat.node {\n       pat_ident(an_ident,_) {\n-          // Be sure to pass ns_a_enum to lookup_in_scope so that\n+          // Be sure to pass ns_an_enum to lookup_in_scope so that\n           // if this is a name that's being shadowed, we don't die\n           alt lookup_in_scope(*e, sc, loc.span,\n-                 path_to_ident(an_ident), ns_val(ns_a_enum)) {\n+                 path_to_ident(an_ident), ns_val(ns_an_enum)) {\n               some(ast::def_variant(enum_id,variant_id)) {\n                   // Declaration shadows a enum that's in scope.\n                   // That's an error.\n@@ -804,7 +809,7 @@ fn ns_name(ns: namespace) -> str {\n       ns_val(v) {\n           alt (v) {\n               ns_any_value { \"name\" }\n-              ns_a_enum    { \"enum\" }\n+              ns_an_enum    { \"enum\" }\n           }\n       }\n       ns_module { \"modulename\" }\n@@ -1000,6 +1005,21 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n               ast::item_native_mod(m) {\n                 ret lookup_in_local_native_mod(e, it.id, sp, name, ns);\n               }\n+              ast::item_class(tps, members, ctor_id, _, _) {\n+                  if ns == ns_type {\n+                    ret lookup_in_ty_params(e, name, tps);\n+                  }\n+                  if ns == ns_val(ns_any_value) && name == it.ident {\n+                      ret some(ast::def_fn(local_def(ctor_id),\n+                                           ast::impure_fn));\n+                  }\n+                  if ns == ns_val(ns_any_value) {\n+                          ret lookup_in_class(local_def(it.id),\n+                                              members, name);\n+                  }\n+                  // FIXME: AST allows other items to appear in a class,\n+                  // but that might not be wise\n+              }\n               _ { }\n             }\n           }\n@@ -1071,7 +1091,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                             /* If we were looking for a enum, at this point\n                                we know it's bound to a non-enum value, and\n                                we can return none instead of failing */\n-                            ns_a_enum { ret none; }\n+                            ns_an_enum { ret none; }\n                             _ { \"attempted dynamic environment-capture\" }\n                           }\n                       }\n@@ -1146,6 +1166,29 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n     }\n }\n \n+/* \n+   FIXME: not sure about this code. maybe this should be handled\n+   using the mod_index stuff\n+ */\n+fn lookup_in_class(parent_id: def_id,\n+                   members: [@class_item], name: ident)\n+   -> option<def> {\n+    for m in members {\n+      alt m.node.decl {\n+        instance_var(v_name,_,_,id) {\n+            if v_name == name {\n+              ret some(def_class_field(parent_id, local_def(id)));\n+            }\n+        }\n+        class_method(i) {\n+            if i.ident == name {\n+              ret some(def_class_method(parent_id, local_def(i.id)));\n+            }\n+        }\n+      }\n+    }\n+    ret none;\n+}\n \n fn lookup_in_block(e: env, name: ident, sp: span, b: ast::blk_, pos: uint,\n                    loc_pos: uint, ns: namespace) -> option<def> {\n@@ -1430,7 +1473,7 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n     if vec::len(matches) == 0u {\n         ret none;\n         }\n-    else if vec::len(matches) == 1u || ns == ns_val(ns_a_enum) {\n+    else if vec::len(matches) == 1u || ns == ns_val(ns_an_enum) {\n         ret some(matches[0].def);\n     } else {\n         for match: glob_imp_def in matches {\n@@ -1449,7 +1492,7 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n     if !info.glob_imported_names.contains_key(id) {\n         info.glob_imported_names.insert(id, glob_resolving(sp));\n         // kludge\n-        let val_ns = if wanted_ns == ns_val(ns_a_enum) { ns_val(ns_a_enum) }\n+        let val_ns = if wanted_ns == ns_val(ns_an_enum) { ns_val(ns_an_enum) }\n                      else { ns_val(ns_any_value) };\n         let globs = info.glob_imports;\n         let val = lookup_in_globs(e, globs, sp, id, val_ns, dr);\n@@ -1615,7 +1658,7 @@ fn index_nmod(md: ast::native_mod) -> mod_index {\n // External lookups\n fn ns_for_def(d: def) -> namespace {\n     alt d {\n-      ast::def_variant(_, _) { ns_val(ns_a_enum) }\n+      ast::def_variant(_, _) { ns_val(ns_an_enum) }\n       ast::def_fn(_, _) | ast::def_self(_) |\n       ast::def_const(_) | ast::def_arg(_, _) | ast::def_local(_) |\n       ast::def_upvar(_, _, _) |  ast::def_self(_) |\n@@ -1632,7 +1675,7 @@ fn ns_for_def(d: def) -> namespace {\n // a enum\n fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n     alt actual {\n-      ns_val(ns_a_enum) {\n+      ns_val(ns_an_enum) {\n         alt wanted {\n           ns_val(_) { true }\n           _ { false }"}, {"sha": "3e9822ab4fd9353f99a87d718a585df7a3f5efd3", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=2299d204e40e565396daabc7b8d5141cdef52c8b", "patch": "@@ -2183,6 +2183,21 @@ mod unify {\n               }\n             }\n           }\n+          ty_class(expected_class, expected_tys) {\n+              alt get(actual).struct {\n+                ty_class(actual_class, actual_tys) {\n+                    if expected_class != actual_class {\n+                        ret ures_err(terr_mismatch);\n+                    }\n+                    ret unify_tps(cx, expected_tys, actual_tys, variance,\n+                           {|tps|\n+                            ures_ok(mk_class(cx.tcx, expected_class, tps))});\n+                }\n+                _ {\n+                    ret ures_err(terr_mismatch);\n+                }\n+              }\n+          }\n           _ { cx.tcx.sess.bug(\"unify: unexpected type\"); }\n         }\n     }\n@@ -2478,13 +2493,11 @@ fn enum_variant_with_id(cx: ctxt, enum_id: ast::def_id,\n \n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n+// a precondition (did.crate != ast::local_crate) would be nice\n fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n     alt cx.tcache.find(did) {\n       some(tpt) { ret tpt; }\n       none {\n-          /* where do things get added to the cache?\n-             Have to add class members */\n-\n         // The item is in this crate. The caller should have added it to the\n         // type cache already\n         assert did.crate != ast::local_crate;"}, {"sha": "69db4b8bca694e58727887af054055e945a39e95", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 112, "deletions": 8, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2299d204e40e565396daabc7b8d5141cdef52c8b", "patch": "@@ -48,8 +48,17 @@ type crate_ctxt = {mutable self_infos: [self_info],\n                    impl_map: resolve::impl_map,\n                    method_map: method_map,\n                    dict_map: dict_map,\n+                   // Not at all sure it's right to put these here\n+                   /* node_id for the class this fn is in --\n+                      none if it's not in a class */\n+                   enclosing_class_id: option<ast::node_id>,\n+                   /* map from node_ids for enclosing-class\n+                      vars and methods to types */\n+                   enclosing_class: class_map,\n                    tcx: ty::ctxt};\n \n+type class_map = hashmap<ast::node_id, ty::t>;\n+\n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n@@ -121,7 +130,6 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       }\n       ast::def_fn(id, _) | ast::def_const(id) |\n       ast::def_variant(_, id) | ast::def_class(id)\n-          | ast::def_class_method(_, id) | ast::def_class_field(_, id)\n          { ret ty::lookup_item_type(fcx.ccx.tcx, id); }\n       ast::def_binding(id) {\n         assert (fcx.locals.contains_key(id.node));\n@@ -134,6 +142,20 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n       ast::def_upvar(_, inner, _) {\n         ret ty_param_bounds_and_ty_for_def(fcx, sp, *inner);\n       }\n+      ast::def_class_method(_, id) | ast::def_class_field(_, id) {\n+          if id.crate != ast::local_crate {\n+                  fcx.ccx.tcx.sess.span_fatal(sp,\n+                                 \"class method or field referred to \\\n+                                  out of scope\");\n+          }\n+          alt fcx.ccx.enclosing_class.find(id.node) {\n+             some(a_ty) { ret {bounds: @[], ty: a_ty}; }\n+             _ { fcx.ccx.tcx.sess.span_fatal(sp,\n+                                 \"class method or field referred to \\\n+                                  out of scope\"); }\n+          }\n+      }\n+\n       _ {\n         // FIXME: handle other names.\n         fcx.ccx.tcx.sess.unimpl(\"definition variant\");\n@@ -316,7 +338,11 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, proto, decl))\n       }\n       ast::ty_path(path, id) {\n-        alt tcx.def_map.get(id) {\n+        let a_def = alt tcx.def_map.find(id) {\n+          none { tcx.sess.span_fatal(ast_ty.span, #fmt(\"unbound path %s\",\n+                                                   path_to_str(path))); }\n+          some(d) { d }};\n+        alt a_def {\n           ast::def_ty(id) {\n             instantiate(tcx, ast_ty.span, mode, id, path.node.types)\n           }\n@@ -349,6 +375,23 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n               }\n             }\n           }\n+          ast::def_class(class_id) {\n+              alt tcx.items.find(class_id.node) {\n+                 some(ast_map::node_item(\n+                  @{node: ast::item_class(tps, _, _, _, _), _}, _)) {\n+                     if vec::len(tps) != vec::len(path.node.types) {\n+                        tcx.sess.span_err(ast_ty.span, \"incorrect number of \\\n+                           type parameters to object type\");\n+                     }\n+                     ty::mk_class(tcx, class_id, vec::map(path.node.types,\n+                        {|ast_ty| ast_ty_to_ty(tcx, mode, ast_ty)}))\n+                 }\n+                 _ {\n+                     tcx.sess.span_bug(ast_ty.span, \"class id is unbound \\\n+                       in items\");\n+                 }\n+              }\n+          }\n           _ {\n             tcx.sess.span_fatal(ast_ty.span,\n                                 \"found type name used as a variable\");\n@@ -787,9 +830,20 @@ mod collect {\n           }\n         }\n     }\n-    fn convert_class_item(_cx: @ctxt, _parent_ty: ty::t,\n-                          _ci: ast::class_member) {\n-        /* TODO */\n+    fn convert_class_item(cx: @ctxt, ci: ast::class_member) {\n+        /* we want to do something here, b/c within the\n+         scope of the class, it's ok to refer to fields &\n+        methods unqualified */\n+\n+        /* they have these types *within the scope* of the\n+         class. outside the class, it's done with expr_field */\n+        alt ci {\n+         ast::instance_var(_,t,_,id) {\n+             let tt = ast_ty_to_ty(cx.tcx, m_collect, t);\n+             write_ty(cx.tcx, id, tt);\n+         }\n+         ast::class_method(it) { convert(cx, it); }\n+        }\n     }\n     fn convert(cx: @ctxt, it: @ast::item) {\n         alt it.node {\n@@ -890,16 +944,23 @@ mod collect {\n             ensure_iface_methods(cx.tcx, it.id);\n           }\n           ast::item_class(tps, members, ctor_id, ctor_decl, ctor_block) {\n-              let parent_ty = ty::lookup_item_type(cx.tcx, local_def(it.id));\n+              // Write the class type\n+              let {bounds,params} = mk_ty_params(cx.tcx, tps);\n+              let class_ty = ty::mk_class(cx.tcx, local_def(it.id), params);\n+              let tpt = {bounds: bounds, ty: class_ty};\n+              cx.tcx.tcache.insert(local_def(it.id), tpt);\n+              write_ty(cx.tcx, it.id, class_ty);\n               // Write the ctor type\n               let t_ctor = ty::mk_fn(cx.tcx,\n                                      ty_of_fn_decl(cx.tcx, m_collect,\n                                              ast::proto_any, ctor_decl));\n               write_ty(cx.tcx, ctor_id, t_ctor);\n+              cx.tcx.tcache.insert(local_def(ctor_id),\n+                                   {bounds: bounds, ty: t_ctor});\n               /* FIXME: check for proper public/privateness */\n               // Write the type of each of the members\n               for m in members {\n-                 convert_class_item(cx, parent_ty.ty, m.node.decl);\n+                 convert_class_item(cx, m.node.decl);\n               }\n           }\n           _ {\n@@ -2252,7 +2313,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_fn(proto, decl, body, captures) {\n         check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n-                                   unify, expected);\n+                          unify, expected);\n         capture::check_capture_clause(tcx, expr.id, proto, *captures);\n       }\n       ast::expr_fn_block(decl, body) {\n@@ -2446,6 +2507,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               _ {}\n             }\n           }\n+          ty::ty_class(_id, _params) {\n+              // TODO (classes)\n+              tcx.sess.span_bug(expr.span,\n+                  #fmt(\"can't check class field accesses yet: %s\",\n+                    ty_to_str(fcx.ccx.tcx, base_t)));\n+          }\n           _ {}\n         }\n         if !handled {\n@@ -2874,6 +2941,30 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n     check_fn(ccx, ast::proto_bare, method.decl, method.body, method.id, none);\n }\n \n+fn class_types(ccx: @crate_ctxt, members: [@ast::class_item]) -> class_map {\n+    let rslt = new_int_hash::<ty::t>();\n+    for m in members {\n+      alt m.node.decl {\n+         ast::instance_var(_,t,_,id) {\n+           rslt.insert(id, ast_ty_to_ty(ccx.tcx, m_collect, t));\n+         }\n+         ast::class_method(it) {\n+             rslt.insert(it.id, ty_of_item(ccx.tcx, m_collect, it).ty);\n+         }\n+      }\n+    }\n+    rslt\n+}\n+\n+fn check_class_member(ccx: @crate_ctxt, cm: ast::class_member) {\n+    alt cm {\n+      ast::instance_var(_,t,_,_) { // ??? Not sure\n+      }\n+      // not right yet -- need a scope\n+      ast::class_method(i) { check_item(ccx, i); }\n+    }\n+}\n+\n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n@@ -2889,6 +2980,17 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         for m in ms { check_method(ccx, m); }\n         vec::pop(ccx.self_infos);\n       }\n+      ast::item_class(tps, members, ctor_id, ctor_decl, ctor_body) {\n+          let cid = some(it.id);\n+          let members_info = class_types(ccx, members);\n+          let class_ccx = @{enclosing_class_id:cid,\n+                            enclosing_class:members_info with *ccx};\n+          // typecheck the ctor\n+          check_fn(class_ccx, ast::proto_bare, ctor_decl, ctor_body, ctor_id,\n+                   none);\n+          // typecheck the members\n+          for m in members { check_class_member(class_ccx, m.node.decl); }\n+      }\n       _ {/* nothing to do */ }\n     }\n }\n@@ -3149,6 +3251,8 @@ fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                 impl_map: impl_map,\n                 method_map: std::map::new_int_hash(),\n                 dict_map: std::map::new_int_hash(),\n+                enclosing_class_id: none,\n+                enclosing_class: std::map::new_int_hash(),\n                 tcx: tcx};\n     let visit = visit::mk_simple_visitor(@{\n         visit_item: bind check_item(ccx, _)"}, {"sha": "35d5119c4e6e550c7b76c22faf59ed24f49e4773", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=2299d204e40e565396daabc7b8d5141cdef52c8b", "patch": "@@ -1972,13 +1972,14 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n fn parse_item_class(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.last_span.lo;\n     let class_name = parse_value_ident(p);\n+    let class_path = ident_to_path(p.last_span, class_name);\n     let ty_params = parse_ty_params(p);\n     expect(p, token::LBRACE);\n     let items: [@ast::class_item] = [];\n     let ctor_id = p.get_id();\n     let the_ctor : option<(ast::fn_decl, ast::blk)> = none;\n     while p.token != token::RBRACE {\n-       alt parse_class_item(p) {\n+        alt parse_class_item(p, class_path) {\n             ctor_decl(a_fn_decl, blk) {\n                 the_ctor = some((a_fn_decl, blk));\n             }\n@@ -2015,10 +2016,14 @@ enum class_contents { ctor_decl(ast::fn_decl, ast::blk),\n                       // none of these are a ctor decl\n                       priv_decls([ast::class_member])}\n \n-fn parse_class_item(p:parser) -> class_contents {\n+    fn parse_class_item(p:parser, class_name:@ast::path) -> class_contents {\n     if eat_word(p, \"new\") {\n         // Can ctors have attrs?\n-        let decl = parse_fn_decl(p, ast::impure_fn);\n+            // result type is always the type of the class\n+        let decl_ = parse_fn_decl(p, ast::impure_fn);\n+        let decl = {output: @{node: ast::ty_path(class_name, p.get_id()),\n+                                  span: decl_.output.span}\n+                    with decl_};\n         let body = parse_block(p);\n         ret ctor_decl(decl, body);\n     }"}, {"sha": "547c2d5ee824c842e796f83c70cda6f9bc621b4d", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=2299d204e40e565396daabc7b8d5141cdef52c8b", "patch": "@@ -117,7 +117,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n       ty_param(id, _) {\n         \"'\" + str::from_bytes([('a' as u8) + (id as u8)])\n       }\n-      ty_enum(did, tps) | ty_res(did, _, tps) {\n+      ty_enum(did, tps) | ty_res(did, _, tps) | ty_class(did, tps) {\n         // Not sure why, but under some circumstances enum or resource types\n         // do not have an associated id.  I didn't investigate enough to know\n         // if there is a good reason for this. - Niko, 2012-02-10"}, {"sha": "938afa6b2d38e8275b87f2536a5acae93be1a4cf", "filename": "src/test/run-pass/classes-simple.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Ftest%2Frun-pass%2Fclasses-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2299d204e40e565396daabc7b8d5141cdef52c8b/src%2Ftest%2Frun-pass%2Fclasses-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple.rs?ref=2299d204e40e565396daabc7b8d5141cdef52c8b", "patch": "@@ -7,4 +7,11 @@ class cat {\n   let how_hungry : int;\n \n   new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+}\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  let kitty = cat(1000u, 2); \n+  log(debug, nyan.how_hungry);\n+  log(debug, kitty.how_hungry);\n }\n\\ No newline at end of file"}]}