{"sha": "45935640f058405c95c96308f3acfd5ac1535698", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1OTM1NjQwZjA1ODQwNWM5NWM5NjMwOGYzYWNmZDVhYzE1MzU2OTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-02T03:18:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-02T03:18:49Z"}, "message": "Auto merge of #51866 - zackmdavis:hir_making_each_day_of_the_year, r=petrochenkov\n\nadd modifier keyword spans to hir::Visibility; improve unreachable-pub, private-no-mangle lint suggestions\n\n#50455 pointed out that the unreachable-pub suggestion for brace-grouped `use`s was bogus; #50476 partially ameliorated this by marking the suggestion as `Applicability::MaybeIncorrect`, but this is the actual fix.\n\nMeanwhile, another application of having spans available in `hir::Visibility` is found in the private-no-mangle lints, where we can now issue a suggestion to use `pub` if the item has a more restricted visibility marker (this seems much less likely to come up in practice than not having any visibility keyword at all, but thoroughness is a virtue). While we're there, we can also add a helpful note if the item does have a `pub` (but triggered the lint presumably because enclosing modules were private).\n\n![hir_vis](https://user-images.githubusercontent.com/1076988/42018064-ca830290-7a65-11e8-9c4c-48bc846f861f.png)\n\nr? @nrc\ncc @Manishearth", "tree": {"sha": "4eb48a11a4f747fc76381873c70c36355468141b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4eb48a11a4f747fc76381873c70c36355468141b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45935640f058405c95c96308f3acfd5ac1535698", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45935640f058405c95c96308f3acfd5ac1535698", "html_url": "https://github.com/rust-lang/rust/commit/45935640f058405c95c96308f3acfd5ac1535698", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45935640f058405c95c96308f3acfd5ac1535698/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5df43114bcb42d4fbe4c1950016e4713cd4e5da7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5df43114bcb42d4fbe4c1950016e4713cd4e5da7", "html_url": "https://github.com/rust-lang/rust/commit/5df43114bcb42d4fbe4c1950016e4713cd4e5da7"}, {"sha": "43a0a65fa2d812c0e48e6cc60a985a4bf47bff57", "url": "https://api.github.com/repos/rust-lang/rust/commits/43a0a65fa2d812c0e48e6cc60a985a4bf47bff57", "html_url": "https://github.com/rust-lang/rust/commit/43a0a65fa2d812c0e48e6cc60a985a4bf47bff57"}], "stats": {"total": 534, "additions": 345, "deletions": 189}, "files": [{"sha": "60e944e5affc3c7ed32bd822f5a14c7304d72620", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -1104,7 +1104,7 @@ pub fn walk_arm<'v, V: Visitor<'v>>(visitor: &mut V, arm: &'v Arm) {\n }\n \n pub fn walk_vis<'v, V: Visitor<'v>>(visitor: &mut V, vis: &'v Visibility) {\n-    if let Visibility::Restricted { ref path, id } = *vis {\n+    if let VisibilityKind::Restricted { ref path, id } = vis.node {\n         visitor.visit_id(id);\n         visitor.visit_path(path, id)\n     }"}, {"sha": "e59e50ae9e698ff03f53b72ca1651b610bfbecb2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -1296,7 +1296,7 @@ impl<'a> LoweringContext<'a> {\n                 name: keywords::Invalid.name(),\n                 attrs: Default::default(),\n                 node: exist_ty_item_kind,\n-                vis: hir::Visibility::Inherited,\n+                vis: respan(span.shrink_to_lo(), hir::VisibilityKind::Inherited),\n                 span: exist_ty_span,\n             };\n \n@@ -2797,18 +2797,19 @@ impl<'a> LoweringContext<'a> {\n                         let new_id = this.lower_node_id(new_node_id);\n                         let path = this.lower_path_extra(def, &path, None, ParamMode::Explicit);\n                         let item = hir::ItemUse(P(path), hir::UseKind::Single);\n-                        let vis = match vis {\n-                            hir::Visibility::Public => hir::Visibility::Public,\n-                            hir::Visibility::Crate(sugar) => hir::Visibility::Crate(sugar),\n-                            hir::Visibility::Inherited => hir::Visibility::Inherited,\n-                            hir::Visibility::Restricted { ref path, id: _ } => {\n-                                hir::Visibility::Restricted {\n+                        let vis_kind = match vis.node {\n+                            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n+                            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+                            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+                            hir::VisibilityKind::Restricted { ref path, id: _ } => {\n+                                hir::VisibilityKind::Restricted {\n                                     path: path.clone(),\n                                     // We are allocating a new NodeId here\n                                     id: this.next_id().node_id,\n                                 }\n                             }\n                         };\n+                        let vis = respan(vis.span, vis_kind);\n \n                         this.items.insert(\n                             new_id.node_id,\n@@ -2869,18 +2870,19 @@ impl<'a> LoweringContext<'a> {\n                         self.lower_use_tree(use_tree, &prefix, new_id, &mut vis, &mut name, &attrs);\n \n                     self.with_hir_id_owner(new_id, |this| {\n-                        let vis = match vis {\n-                            hir::Visibility::Public => hir::Visibility::Public,\n-                            hir::Visibility::Crate(sugar) => hir::Visibility::Crate(sugar),\n-                            hir::Visibility::Inherited => hir::Visibility::Inherited,\n-                            hir::Visibility::Restricted { ref path, id: _ } => {\n-                                hir::Visibility::Restricted {\n+                        let vis_kind = match vis.node {\n+                            hir::VisibilityKind::Public => hir::VisibilityKind::Public,\n+                            hir::VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+                            hir::VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+                            hir::VisibilityKind::Restricted { ref path, id: _ } => {\n+                                hir::VisibilityKind::Restricted {\n                                     path: path.clone(),\n                                     // We are allocating a new NodeId here\n                                     id: this.next_id().node_id,\n                                 }\n                             }\n                         };\n+                        let vis = respan(vis.span, vis_kind);\n \n                         this.items.insert(\n                             new_id,\n@@ -2901,7 +2903,7 @@ impl<'a> LoweringContext<'a> {\n                 // the stability of `use a::{};`, to avoid it showing up as\n                 // a re-export by accident when `pub`, e.g. in documentation.\n                 let path = P(self.lower_path(id, &prefix, ParamMode::Explicit));\n-                *vis = hir::Inherited;\n+                *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n                 hir::ItemUse(path, hir::UseKind::ListStem)\n             }\n         }\n@@ -4284,19 +4286,20 @@ impl<'a> LoweringContext<'a> {\n         v: &Visibility,\n         explicit_owner: Option<NodeId>,\n     ) -> hir::Visibility {\n-        match v.node {\n-            VisibilityKind::Public => hir::Public,\n-            VisibilityKind::Crate(sugar) => hir::Visibility::Crate(sugar),\n-            VisibilityKind::Restricted { ref path, id, .. } => hir::Visibility::Restricted {\n+        let node = match v.node {\n+            VisibilityKind::Public => hir::VisibilityKind::Public,\n+            VisibilityKind::Crate(sugar) => hir::VisibilityKind::Crate(sugar),\n+            VisibilityKind::Restricted { ref path, id } => hir::VisibilityKind::Restricted {\n                 path: P(self.lower_path(id, path, ParamMode::Explicit)),\n                 id: if let Some(owner) = explicit_owner {\n                     self.lower_node_id_with_owner(id, owner).node_id\n                 } else {\n                     self.lower_node_id(id).node_id\n                 },\n             },\n-            VisibilityKind::Inherited => hir::Inherited,\n-        }\n+            VisibilityKind::Inherited => hir::VisibilityKind::Inherited,\n+        };\n+        respan(v.span, node)\n     }\n \n     fn lower_defaultness(&mut self, d: Defaultness, has_value: bool) -> hir::Defaultness {"}, {"sha": "3cc25bfd2d4d7c4a4800dfbbde1041c20ddf234d", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -458,11 +458,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_vis(&mut self, visibility: &'hir Visibility) {\n-        match *visibility {\n-            Visibility::Public |\n-            Visibility::Crate(_) |\n-            Visibility::Inherited => {}\n-            Visibility::Restricted { id, .. } => {\n+        match visibility.node {\n+            VisibilityKind::Public |\n+            VisibilityKind::Crate(_) |\n+            VisibilityKind::Inherited => {}\n+            VisibilityKind::Restricted { id, .. } => {\n                 self.insert(id, NodeVisibility(visibility));\n                 self.with_parent(id, |this| {\n                     intravisit::walk_vis(this, visibility);"}, {"sha": "08a130f049bf734c322d1961ae87e7eaf3563f02", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -1049,7 +1049,9 @@ impl<'hir> Map<'hir> {\n             Some(EntryStructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n             Some(EntryLifetime(_, _, lifetime)) => lifetime.span,\n             Some(EntryGenericParam(_, _, param)) => param.span,\n-            Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n+            Some(EntryVisibility(_, _, &Spanned {\n+                node: VisibilityKind::Restricted { ref path, .. }, ..\n+            })) => path.span,\n             Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n             Some(EntryLocal(_, _, local)) => local.span,\n             Some(EntryMacroDef(_, macro_def)) => macro_def.span,"}, {"sha": "b0b81316148ea47c97acd99ca6493df4a9ffcd07", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -24,7 +24,6 @@ pub use self::Stmt_::*;\n pub use self::Ty_::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n-pub use self::Visibility::{Public, Inherited};\n \n use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n@@ -1929,22 +1928,30 @@ pub struct PolyTraitRef {\n     pub span: Span,\n }\n \n+pub type Visibility = Spanned<VisibilityKind>;\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum Visibility {\n+pub enum VisibilityKind {\n     Public,\n     Crate(CrateSugar),\n     Restricted { path: P<Path>, id: NodeId },\n     Inherited,\n }\n \n-impl Visibility {\n+impl VisibilityKind {\n+    pub fn is_pub(&self) -> bool {\n+        match *self {\n+            VisibilityKind::Public => true,\n+            _ => false\n+        }\n+    }\n+\n     pub fn is_pub_restricted(&self) -> bool {\n-        use self::Visibility::*;\n-        match self {\n-            &Public |\n-            &Inherited => false,\n-            &Crate(_) |\n-            &Restricted { .. } => true,\n+        match *self {\n+            VisibilityKind::Public |\n+            VisibilityKind::Inherited => false,\n+            VisibilityKind::Crate(..) |\n+            VisibilityKind::Restricted { .. } => true,\n         }\n     }\n }"}, {"sha": "255009c94c6abc6e06454302da7445929891a1b2", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -12,7 +12,7 @@ pub use self::AnnNode::*;\n \n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n-use syntax::codemap::CodeMap;\n+use syntax::codemap::{CodeMap, Spanned};\n use syntax::parse::ParseSess;\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n@@ -839,11 +839,11 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_visibility(&mut self, vis: &hir::Visibility) -> io::Result<()> {\n-        match *vis {\n-            hir::Public => self.word_nbsp(\"pub\")?,\n-            hir::Visibility::Crate(ast::CrateSugar::JustCrate) => self.word_nbsp(\"crate\")?,\n-            hir::Visibility::Crate(ast::CrateSugar::PubCrate) => self.word_nbsp(\"pub(crate)\")?,\n-            hir::Visibility::Restricted { ref path, .. } => {\n+        match vis.node {\n+            hir::VisibilityKind::Public => self.word_nbsp(\"pub\")?,\n+            hir::VisibilityKind::Crate(ast::CrateSugar::JustCrate) => self.word_nbsp(\"crate\")?,\n+            hir::VisibilityKind::Crate(ast::CrateSugar::PubCrate) => self.word_nbsp(\"pub(crate)\")?,\n+            hir::VisibilityKind::Restricted { ref path, .. } => {\n                 self.s.word(\"pub(\")?;\n                 if path.segments.len() == 1 &&\n                    path.segments[0].ident.name == keywords::Super.name() {\n@@ -856,7 +856,7 @@ impl<'a> State<'a> {\n                 }\n                 self.word_nbsp(\")\")?;\n             }\n-            hir::Inherited => ()\n+            hir::VisibilityKind::Inherited => ()\n         }\n \n         Ok(())\n@@ -952,17 +952,21 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n             hir::TraitItemKind::Const(ref ty, default) => {\n-                self.print_associated_const(ti.ident, &ty, default, &hir::Inherited)?;\n+                let vis = Spanned { span: syntax_pos::DUMMY_SP,\n+                                    node: hir::VisibilityKind::Inherited };\n+                self.print_associated_const(ti.ident, &ty, default, &vis)?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref arg_names)) => {\n-                self.print_method_sig(ti.ident, sig, &ti.generics, &hir::Inherited, arg_names,\n-                    None)?;\n+                let vis = Spanned { span: syntax_pos::DUMMY_SP,\n+                                    node: hir::VisibilityKind::Inherited };\n+                self.print_method_sig(ti.ident, sig, &ti.generics, &vis, arg_names, None)?;\n                 self.s.word(\";\")?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n+                let vis = Spanned { span: syntax_pos::DUMMY_SP,\n+                                    node: hir::VisibilityKind::Inherited };\n                 self.head(\"\")?;\n-                self.print_method_sig(ti.ident, sig, &ti.generics, &hir::Inherited, &[],\n-                    Some(body))?;\n+                self.print_method_sig(ti.ident, sig, &ti.generics, &vis, &[], Some(body))?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n@@ -2266,7 +2270,8 @@ impl<'a> State<'a> {\n                       },\n                       name,\n                       &generics,\n-                      &hir::Inherited,\n+                      &Spanned { span: syntax_pos::DUMMY_SP,\n+                                 node: hir::VisibilityKind::Inherited },\n                       arg_names,\n                       None)?;\n         self.end()"}, {"sha": "0c7baea85ad8f63d33ea0589c0eba599e725729a", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -710,20 +710,20 @@ impl_stable_hash_for!(enum ::syntax::ast::CrateSugar {\n     PubCrate,\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Visibility {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::VisibilityKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            hir::Visibility::Public |\n-            hir::Visibility::Inherited => {\n+            hir::VisibilityKind::Public |\n+            hir::VisibilityKind::Inherited => {\n                 // No fields to hash.\n             }\n-            hir::Visibility::Crate(sugar) => {\n+            hir::VisibilityKind::Crate(sugar) => {\n                 sugar.hash_stable(hcx, hasher);\n             }\n-            hir::Visibility::Restricted { ref path, id } => {\n+            hir::VisibilityKind::Restricted { ref path, id } => {\n                 hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                     id.hash_stable(hcx, hasher);\n                 });\n@@ -733,6 +733,8 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Visibility {\n     }\n }\n \n+impl_stable_hash_for_spanned!(hir::VisibilityKind);\n+\n impl<'a> HashStable<StableHashingContext<'a>> for hir::Defaultness {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,"}, {"sha": "226d19a91240f3d081670b1f7661e9a90445394b", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -161,7 +161,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                         intravisit::walk_item(self, &item);\n                     }\n                     hir::ItemEnum(..) => {\n-                        self.inherited_pub_visibility = item.vis == hir::Public;\n+                        self.inherited_pub_visibility = item.vis.node.is_pub();\n                         intravisit::walk_item(self, &item);\n                     }\n                     hir::ItemFn(..)\n@@ -216,7 +216,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         let has_repr_c = self.repr_has_repr_c;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n         let live_fields = def.fields().iter().filter(|f| {\n-            has_repr_c || inherited_pub_visibility || f.vis == hir::Public\n+            has_repr_c || inherited_pub_visibility || f.vis.node.is_pub()\n         });\n         self.live_symbols.extend(live_fields.map(|f| f.id));\n "}, {"sha": "54afd795fc0f13de0e2a7cfcb4168200d560b304", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -268,16 +268,16 @@ impl<'a, 'gcx, 'tcx> DefIdTree for TyCtxt<'a, 'gcx, 'tcx> {\n \n impl Visibility {\n     pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: TyCtxt) -> Self {\n-        match *visibility {\n-            hir::Public => Visibility::Public,\n-            hir::Visibility::Crate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n-            hir::Visibility::Restricted { ref path, .. } => match path.def {\n+        match visibility.node {\n+            hir::VisibilityKind::Public => Visibility::Public,\n+            hir::VisibilityKind::Crate(_) => Visibility::Restricted(DefId::local(CRATE_DEF_INDEX)),\n+            hir::VisibilityKind::Restricted { ref path, .. } => match path.def {\n                 // If there is no resolution, `resolve` will have already reported an error, so\n                 // assume that the visibility is public to avoid reporting more privacy errors.\n                 Def::Err => Visibility::Public,\n                 def => Visibility::Restricted(def.def_id()),\n             },\n-            hir::Inherited => {\n+            hir::VisibilityKind::Inherited => {\n                 Visibility::Restricted(tcx.hir.get_module_parent(id))\n             }\n         }"}, {"sha": "f1f5e3ef6e10583d01c492d69b986e4972432fc2", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 59, "deletions": 56, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemUnion(..) => \"a union\",\n             hir::ItemTrait(.., ref trait_item_refs) => {\n                 // Issue #11592, traits are always considered exported, even when private.\n-                if it.vis == hir::Visibility::Inherited {\n+                if it.vis.node == hir::VisibilityKind::Inherited {\n                     self.private_traits.insert(it.id);\n                     for trait_item_ref in trait_item_refs {\n                         self.private_traits.insert(trait_item_ref.id.node_id);\n@@ -414,7 +414,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 if let Some(node_id) = cx.tcx.hir.as_local_node_id(real_trait) {\n                     match cx.tcx.hir.find(node_id) {\n                         Some(hir_map::NodeItem(item)) => {\n-                            if item.vis == hir::Visibility::Inherited {\n+                            if item.vis.node == hir::VisibilityKind::Inherited {\n                                 for impl_item_ref in impl_item_refs {\n                                     self.private_traits.insert(impl_item_ref.id.node_id);\n                                 }\n@@ -1182,6 +1182,26 @@ impl LintPass for InvalidNoMangleItems {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+        let suggest_export = |vis: &hir::Visibility, err: &mut DiagnosticBuilder| {\n+            let suggestion = match vis.node {\n+                hir::VisibilityKind::Inherited => {\n+                    // inherited visibility is empty span at item start; need an extra space\n+                    Some(\"pub \".to_owned())\n+                },\n+                hir::VisibilityKind::Restricted { .. } |\n+                hir::VisibilityKind::Crate(_) => {\n+                    Some(\"pub\".to_owned())\n+                },\n+                hir::VisibilityKind::Public => {\n+                    err.help(\"try exporting the item with a `pub use` statement\");\n+                    None\n+                }\n+            };\n+            if let Some(replacement) = suggestion {\n+                err.span_suggestion(vis.span, \"try making it public\", replacement);\n+            }\n+        };\n+\n         match it.node {\n             hir::ItemFn(.., ref generics, _) => {\n                 if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, \"no_mangle\") {\n@@ -1191,12 +1211,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n                     if !cx.access_levels.is_reachable(it.id) {\n                         let msg = \"function is marked #[no_mangle], but not exported\";\n                         let mut err = cx.struct_span_lint(PRIVATE_NO_MANGLE_FNS, it.span, msg);\n-                        let insertion_span = it.span.shrink_to_lo();\n-                        if it.vis == hir::Visibility::Inherited {\n-                            err.span_suggestion(insertion_span,\n-                                                \"try making it public\",\n-                                                \"pub \".to_owned());\n-                        }\n+                        suggest_export(&it.vis, &mut err);\n                         err.emit();\n                     }\n                     for param in &generics.params {\n@@ -1219,17 +1234,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n             }\n             hir::ItemStatic(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n-                   !cx.access_levels.is_reachable(it.id) {\n-                       let msg = \"static is marked #[no_mangle], but not exported\";\n-                       let mut err = cx.struct_span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, msg);\n-                       let insertion_span = it.span.shrink_to_lo();\n-                       if it.vis == hir::Visibility::Inherited {\n-                           err.span_suggestion(insertion_span,\n-                                               \"try making it public\",\n-                                               \"pub \".to_owned());\n-                       }\n-                       err.emit();\n-                }\n+                    !cx.access_levels.is_reachable(it.id) {\n+                        let msg = \"static is marked #[no_mangle], but not exported\";\n+                        let mut err = cx.struct_span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, msg);\n+                        suggest_export(&it.vis, &mut err);\n+                        err.emit();\n+                    }\n             }\n             hir::ItemConst(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") {\n@@ -1391,60 +1401,53 @@ impl LintPass for UnreachablePub {\n \n impl UnreachablePub {\n     fn perform_lint(&self, cx: &LateContext, what: &str, id: ast::NodeId,\n-                    vis: &hir::Visibility, span: Span, exportable: bool,\n-                    mut applicability: Applicability) {\n-        if !cx.access_levels.is_reachable(id) && *vis == hir::Visibility::Public {\n-            if span.ctxt().outer().expn_info().is_some() {\n-                applicability = Applicability::MaybeIncorrect;\n-            }\n-            let def_span = cx.tcx.sess.codemap().def_span(span);\n-            let mut err = cx.struct_span_lint(UNREACHABLE_PUB, def_span,\n-                                              &format!(\"unreachable `pub` {}\", what));\n-            // We are presuming that visibility is token at start of\n-            // declaration (can be macro variable rather than literal `pub`)\n-            let pub_span = cx.tcx.sess.codemap().span_until_char(def_span, ' ');\n-            let replacement = if cx.tcx.features().crate_visibility_modifier {\n-                \"crate\"\n-            } else {\n-                \"pub(crate)\"\n-            }.to_owned();\n-            err.span_suggestion_with_applicability(pub_span,\n-                                                   \"consider restricting its visibility\",\n-                                                   replacement,\n-                                                   applicability);\n-            if exportable {\n-                err.help(\"or consider exporting it for use by other crates\");\n-            }\n-            err.emit();\n+                    vis: &hir::Visibility, span: Span, exportable: bool) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        match vis.node {\n+            hir::VisibilityKind::Public if !cx.access_levels.is_reachable(id) => {\n+                if span.ctxt().outer().expn_info().is_some() {\n+                    applicability = Applicability::MaybeIncorrect;\n+                }\n+                let def_span = cx.tcx.sess.codemap().def_span(span);\n+                let mut err = cx.struct_span_lint(UNREACHABLE_PUB, def_span,\n+                                                  &format!(\"unreachable `pub` {}\", what));\n+                let replacement = if cx.tcx.features().crate_visibility_modifier {\n+                    \"crate\"\n+                } else {\n+                    \"pub(crate)\"\n+                }.to_owned();\n+\n+                err.span_suggestion_with_applicability(vis.span,\n+                                                       \"consider restricting its visibility\",\n+                                                       replacement,\n+                                                       applicability);\n+                if exportable {\n+                    err.help(\"or consider exporting it for use by other crates\");\n+                }\n+                err.emit();\n+            },\n+            _ => {}\n         }\n     }\n }\n \n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnreachablePub {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n-        let applicability = match item.node {\n-            // suggestion span-manipulation is inadequate for `pub use\n-            // module::{item}` (Issue #50455)\n-            hir::ItemUse(..) => Applicability::MaybeIncorrect,\n-            _ => Applicability::MachineApplicable,\n-        };\n-        self.perform_lint(cx, \"item\", item.id, &item.vis, item.span, true, applicability);\n+        self.perform_lint(cx, \"item\", item.id, &item.vis, item.span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext, foreign_item: &hir::ForeignItem) {\n         self.perform_lint(cx, \"item\", foreign_item.id, &foreign_item.vis,\n-                          foreign_item.span, true, Applicability::MachineApplicable);\n+                          foreign_item.span, true);\n     }\n \n     fn check_struct_field(&mut self, cx: &LateContext, field: &hir::StructField) {\n-        self.perform_lint(cx, \"field\", field.id, &field.vis, field.span, false,\n-                          Applicability::MachineApplicable);\n+        self.perform_lint(cx, \"field\", field.id, &field.vis, field.span, false);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n-        self.perform_lint(cx, \"item\", impl_item.id, &impl_item.vis, impl_item.span, false,\n-                          Applicability::MachineApplicable);\n+        self.perform_lint(cx, \"item\", impl_item.id, &impl_item.vis, impl_item.span, false);\n     }\n }\n "}, {"sha": "3cfde7a8297f97c957bf73542124fbeb36bc7df5", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -40,6 +40,7 @@ use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::attr;\n+use syntax::codemap::Spanned;\n use syntax::symbol::keywords;\n use syntax_pos::{self, hygiene, FileName, FileMap, Span};\n \n@@ -319,9 +320,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     fn encode_info_for_items(&mut self) -> Index {\n         let krate = self.tcx.hir.krate();\n         let mut index = IndexBuilder::new(self);\n+        let vis = Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Public };\n         index.record(DefId::local(CRATE_DEF_INDEX),\n                      IsolatedEncoder::encode_info_for_mod,\n-                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &hir::Public)));\n+                     FromId(CRATE_NODE_ID, (&krate.module, &krate.attrs, &vis)));\n         let mut visitor = EncodeVisitor { index: index };\n         krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n         for macro_def in &krate.exported_macros {"}, {"sha": "c55d57cb91631e8a30a95c5a7ad6ff00350ccac8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n         NestedVisitorMap::All(&self.tcx.hir)\n     }\n     fn visit_vis(&mut self, vis: &'tcx hir::Visibility) {\n-        self.has_pub_restricted = self.has_pub_restricted || vis.is_pub_restricted();\n+        self.has_pub_restricted = self.has_pub_restricted || vis.node.is_pub_restricted();\n     }\n }\n \n@@ -162,7 +162,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemTrait(..) | hir::ItemTraitAlias(..) |\n             hir::ItemExistential(..) |\n             hir::ItemTy(..) | hir::ItemUnion(..) | hir::ItemUse(..) => {\n-                if item.vis == hir::Public { self.prev_level } else { None }\n+                if item.vis.node.is_pub() { self.prev_level } else { None }\n             }\n         };\n \n@@ -181,7 +181,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n             hir::ItemImpl(.., None, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n-                    if impl_item_ref.vis == hir::Public {\n+                    if impl_item_ref.vis.node.is_pub() {\n                         self.update(impl_item_ref.id.node_id, item_level);\n                     }\n                 }\n@@ -201,14 +201,14 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     self.update(def.id(), item_level);\n                 }\n                 for field in def.fields() {\n-                    if field.vis == hir::Public {\n+                    if field.vis.node.is_pub() {\n                         self.update(field.id, item_level);\n                     }\n                 }\n             }\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if foreign_item.vis == hir::Public {\n+                    if foreign_item.vis.node.is_pub() {\n                         self.update(foreign_item.id, item_level);\n                     }\n                 }\n@@ -358,7 +358,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n         let module_did = ty::DefIdTree::parent(self.tcx, self.tcx.hir.local_def_id(md.id)).unwrap();\n         let mut module_id = self.tcx.hir.as_local_node_id(module_did).unwrap();\n-        let level = if md.vis == hir::Public { self.get(module_id) } else { None };\n+        let level = if md.vis.node.is_pub() { self.get(module_id) } else { None };\n         let level = self.update(md.id, level);\n         if level.is_none() {\n             return\n@@ -1028,7 +1028,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // .. and it corresponds to a private type in the AST (this returns\n             // None for type parameters)\n             match self.tcx.hir.find(node_id) {\n-                Some(hir::map::NodeItem(ref item)) => item.vis != hir::Public,\n+                Some(hir::map::NodeItem(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n         } else {\n@@ -1051,7 +1051,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn item_is_public(&self, id: &ast::NodeId, vis: &hir::Visibility) -> bool {\n-        self.access_levels.is_reachable(*id) || *vis == hir::Public\n+        self.access_levels.is_reachable(*id) || vis.node.is_pub()\n     }\n }\n \n@@ -1322,7 +1322,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n-        if s.vis == hir::Public || self.in_variant {\n+        if s.vis.node.is_pub() || self.in_variant {\n             intravisit::walk_struct_field(self, s);\n         }\n     }\n@@ -1461,29 +1461,36 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n         if let Some(def_id) = ty_def_id {\n             // Non-local means public (private items can't leave their crate, modulo bugs)\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n-                let vis = match self.tcx.hir.find(node_id) {\n+                let hir_vis = match self.tcx.hir.find(node_id) {\n                     Some(hir::map::NodeItem(item)) => &item.vis,\n                     Some(hir::map::NodeForeignItem(item)) => &item.vis,\n                     _ => bug!(\"expected item of foreign item\"),\n                 };\n \n-                let vis = ty::Visibility::from_hir(vis, node_id, self.tcx);\n+                let vis = ty::Visibility::from_hir(hir_vis, node_id, self.tcx);\n \n                 if !vis.is_at_least(self.min_visibility, self.tcx) {\n                     self.min_visibility = vis;\n                 }\n                 if !vis.is_at_least(self.required_visibility, self.tcx) {\n+                    let vis_adj = match hir_vis.node {\n+                        hir::VisibilityKind::Crate(_) => \"crate-visible\",\n+                        hir::VisibilityKind::Restricted { .. } => \"restricted\",\n+                        _ => \"private\"\n+                    };\n+\n                     if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n                         let mut err = struct_span_err!(self.tcx.sess, self.span, E0446,\n-                            \"private type `{}` in public interface\", ty);\n-                        err.span_label(self.span, \"can't leak private type\");\n+                            \"{} type `{}` in public interface\", vis_adj, ty);\n+                        err.span_label(self.span, format!(\"can't leak {} type\", vis_adj));\n+                        err.span_label(hir_vis.span, format!(\"`{}` declared as {}\", ty, vis_adj));\n                         err.emit();\n                     } else {\n                         self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC,\n                                            node_id,\n                                            self.span,\n-                                           &format!(\"private type `{}` in public \\\n-                                                     interface (error E0446)\", ty));\n+                                           &format!(\"{} type `{}` in public \\\n+                                                     interface (error E0446)\", vis_adj, ty));\n                     }\n                 }\n             }"}, {"sha": "447b5f1fe47e71b94c080c2da4979a701fd316ea", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -55,6 +55,7 @@ use std::fs::File;\n use std::path::{Path, PathBuf};\n \n use syntax::ast::{self, Attribute, NodeId, PatKind};\n+use syntax::codemap::Spanned;\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token;\n use syntax::print::pprust;\n@@ -631,7 +632,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 node: hir::ItemUse(ref path, _),\n                 ..\n             }) |\n-            Node::NodeVisibility(&hir::Visibility::Restricted { ref path, .. }) => path.def,\n+            Node::NodeVisibility(&Spanned {\n+                node: hir::VisibilityKind::Restricted { ref path, .. }, .. }) => path.def,\n \n             Node::NodeExpr(&hir::Expr {\n                 node: hir::ExprStruct(ref qpath, ..),"}, {"sha": "3a8ed0ea25facc3a2a18cf2df893441de93fa00e", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -39,7 +39,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        if item.vis == hir::Public || item.span.is_dummy() {\n+        if item.vis.node.is_pub() || item.span.is_dummy() {\n             return;\n         }\n         if let hir::ItemUse(ref path, _) = item.node {\n@@ -214,4 +214,3 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for CollectExternCrateVisitor<'a, 'tcx> {\n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n     }\n }\n-"}, {"sha": "b8abb98edec4800945d65bd3036d080bc8b1fa8e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -286,7 +286,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                         as_primitive(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n                     }\n                     hir::ItemUse(ref path, hir::UseKind::Single)\n-                    if item.vis == hir::Visibility::Public => {\n+                    if item.vis.node.is_pub() => {\n                         as_primitive(path.def).map(|(_, prim, attrs)| {\n                             // Pretend the primitive is local.\n                             (cx.tcx.hir.local_def_id(id.id), prim, attrs)\n@@ -328,7 +328,7 @@ impl Clean<ExternalCrate> for CrateNum {\n                         as_keyword(Def::Mod(cx.tcx.hir.local_def_id(id.id)))\n                     }\n                     hir::ItemUse(ref path, hir::UseKind::Single)\n-                    if item.vis == hir::Visibility::Public => {\n+                    if item.vis.node.is_pub() => {\n                         as_keyword(path.def).map(|(_, prim, attrs)| {\n                             (cx.tcx.hir.local_def_id(id.id), prim, attrs)\n                         })\n@@ -3225,11 +3225,11 @@ pub enum Visibility {\n \n impl Clean<Option<Visibility>> for hir::Visibility {\n     fn clean(&self, cx: &DocContext) -> Option<Visibility> {\n-        Some(match *self {\n-            hir::Visibility::Public => Visibility::Public,\n-            hir::Visibility::Inherited => Visibility::Inherited,\n-            hir::Visibility::Crate(_) => Visibility::Crate,\n-            hir::Visibility::Restricted { ref path, .. } => {\n+        Some(match self.node {\n+            hir::VisibilityKind::Public => Visibility::Public,\n+            hir::VisibilityKind::Inherited => Visibility::Inherited,\n+            hir::VisibilityKind::Crate(_) => Visibility::Crate,\n+            hir::VisibilityKind::Restricted { ref path, .. } => {\n                 let path = path.clean(cx);\n                 let did = register_def(cx, path.def);\n                 Visibility::Restricted(did, path)\n@@ -3932,7 +3932,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n         // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n-        let denied = self.vis != hir::Public || self.attrs.iter().any(|a| {\n+        let denied = !self.vis.node.is_pub() || self.attrs.iter().any(|a| {\n             a.name() == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::list_contains_name(&l, \"no_inline\") ||\n                            attr::list_contains_name(&l, \"hidden\"),"}, {"sha": "6fd9ef234f42317d006a993130b6990d29cf821b", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -17,6 +17,7 @@ use syntax::ast;\n use syntax::ast::{Name, NodeId};\n use syntax::attr;\n use syntax::ptr::P;\n+use syntax::codemap::Spanned;\n use syntax_pos::{self, Span};\n \n use rustc::hir;\n@@ -53,7 +54,7 @@ impl Module {\n         Module {\n             name       : name,\n             id: ast::CRATE_NODE_ID,\n-            vis: hir::Inherited,\n+            vis: Spanned { span: syntax_pos::DUMMY_SP, node: hir::VisibilityKind::Inherited },\n             stab: None,\n             depr: None,\n             where_outer: syntax_pos::DUMMY_SP,"}, {"sha": "fdeba93990d1c244352befe719f5a5c4ceeec347", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -15,7 +15,8 @@ use std::mem;\n \n use syntax::ast;\n use syntax::attr;\n-use syntax_pos::Span;\n+use syntax::codemap::Spanned;\n+use syntax_pos::{self, Span};\n \n use rustc::hir::map as hir_map;\n use rustc::hir::def::Def;\n@@ -94,7 +95,8 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n \n         self.module = self.visit_mod_contents(krate.span,\n                                               krate.attrs.clone(),\n-                                              hir::Public,\n+                                              Spanned { span: syntax_pos::DUMMY_SP,\n+                                                        node: hir::VisibilityKind::Public },\n                                               ast::CRATE_NODE_ID,\n                                               &krate.module,\n                                               None);\n@@ -204,7 +206,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         om.id = id;\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n-        self.inside_public_path &= vis == hir::Public;\n+        self.inside_public_path &= vis.node.is_pub();\n         for i in &m.item_ids {\n             let item = self.cx.tcx.hir.expect_item(i.id);\n             self.visit_item(item, None, &mut om);\n@@ -376,7 +378,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n         debug!(\"Visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.name);\n \n-        if item.vis == hir::Public {\n+        if item.vis.node.is_pub() {\n             let def_id = self.cx.tcx.hir.local_def_id(item.id);\n             self.store_path(def_id);\n         }\n@@ -387,14 +389,14 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n                 om.foreigns.push(if self.inlining {\n                     hir::ForeignMod {\n                         abi: fm.abi,\n-                        items: fm.items.iter().filter(|i| i.vis == hir::Public).cloned().collect(),\n+                        items: fm.items.iter().filter(|i| i.vis.node.is_pub()).cloned().collect(),\n                     }\n                 } else {\n                     fm.clone()\n                 });\n             }\n             // If we're inlining, skip private items.\n-            _ if self.inlining && item.vis != hir::Public => {}\n+            _ if self.inlining && !item.vis.node.is_pub() => {}\n             hir::ItemGlobalAsm(..) => {}\n             hir::ItemExternCrate(orig_name) => {\n                 let def_id = self.cx.tcx.hir.local_def_id(item.id);\n@@ -414,7 +416,7 @@ impl<'a, 'tcx, 'rcx> RustdocVisitor<'a, 'tcx, 'rcx> {\n \n                 // If there was a private module in the current path then don't bother inlining\n                 // anything as it will probably be stripped anyway.\n-                if item.vis == hir::Public && self.inside_public_path {\n+                if item.vis.node.is_pub() && self.inside_public_path {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n                             Some(ref list) if item.check_name(\"doc\") => {"}, {"sha": "1f062656b813bed98dbecb6d37a4ed87adc562be", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -6032,7 +6032,10 @@ impl<'a> Parser<'a> {\n         }\n \n         if !self.eat_keyword(keywords::Pub) {\n-            return Ok(respan(self.prev_span, VisibilityKind::Inherited))\n+            // We need a span for our `Spanned<VisibilityKind>`, but there's inherently no\n+            // keyword to grab a span from for inherited visibility; an empty span at the\n+            // beginning of the current token would seem to be the \"Schelling span\".\n+            return Ok(respan(self.span.shrink_to_lo(), VisibilityKind::Inherited))\n         }\n         let lo = self.prev_span;\n "}, {"sha": "6c7f3785464f9e97d3fbf8100c816c1dc105501a", "filename": "src/test/ui/error-codes/E0446.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Ferror-codes%2FE0446.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Ferror-codes%2FE0446.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0446.stderr?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -1,6 +1,9 @@\n error[E0446]: private type `Foo::Bar` in public interface\n   --> $DIR/E0446.rs:14:5\n    |\n+LL |       struct Bar(u32);\n+   |       - `Foo::Bar` declared as private\n+LL | \n LL | /     pub fn bar() -> Bar { //~ ERROR E0446\n LL | |         Bar(0)\n LL | |     }"}, {"sha": "4da2700cb9fdb7221aea5f5294a70fc6849e055c", "filename": "src/test/ui/lint/suggestions.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Flint%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Flint%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsuggestions.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -13,27 +13,41 @@\n #![warn(unused_mut, unused_parens)] // UI tests pass `-A unused`\u2014see Issue #43896\n #![feature(no_debug)]\n \n-#[no_mangle] static SHENZHOU: usize = 1; // should suggest `pub`\n+#[no_mangle] static SHENZHOU: usize = 1;\n //~^ WARN static is marked #[no_mangle]\n-#[no_mangle] const DISCOVERY: usize = 1; // should suggest `pub static` rather than `const`\n+//~| HELP try making it public\n+#[no_mangle] const DISCOVERY: usize = 1;\n //~^ ERROR const items should never be #[no_mangle]\n+//~| HELP try a static value\n \n-#[no_mangle] // should suggest removal (generics can't be no-mangle)\n+#[no_mangle]\n+//~^ HELP remove this attribute\n pub fn defiant<T>(_t: T) {}\n //~^ WARN functions generic over types must be mangled\n \n #[no_mangle]\n-fn rio_grande() {} // should suggest `pub`\n+fn rio_grande() {}\n //~^ WARN function is marked\n+//~| HELP try making it public\n \n mod badlands {\n     // The private-no-mangle lints shouldn't suggest inserting `pub` when the\n     // item is already `pub` (but triggered the lint because, e.g., it's in a\n     // private module). (Issue #47383)\n     #[no_mangle] pub static DAUNTLESS: bool = true;\n     //~^ WARN static is marked\n+    //~| HELP try exporting the item with a `pub use` statement\n     #[no_mangle] pub fn val_jean() {}\n     //~^ WARN function is marked\n+    //~| HELP try exporting the item with a `pub use` statement\n+\n+    // ... but we can suggest just-`pub` instead of restricted\n+    #[no_mangle] pub(crate) static VETAR: bool = true;\n+    //~^ WARN static is marked\n+    //~| HELP try making it public\n+    #[no_mangle] pub(crate) fn crossfield() {}\n+    //~^ WARN function is marked\n+    //~| HELP try making it public\n }\n \n struct Equinox {\n@@ -42,20 +56,26 @@ struct Equinox {\n \n #[no_debug] // should suggest removal of deprecated attribute\n //~^ WARN deprecated\n+//~| HELP remove this attribute\n fn main() {\n-    while true { // should suggest `loop`\n+    while true {\n     //~^ WARN denote infinite loops\n-        let mut a = (1); // should suggest no `mut`, no parens\n+    //~| HELP use `loop`\n+        let mut a = (1);\n         //~^ WARN does not need to be mutable\n+        //~| HELP remove this `mut`\n         //~| WARN unnecessary parentheses\n+        //~| HELP remove these parentheses\n         // the line after `mut` has a `\\t` at the beginning, this is on purpose\n         let mut\n \t        b = 1;\n         //~^^ WARN does not need to be mutable\n+        //~| HELP remove this `mut`\n         let d = Equinox { warp_factor: 9.975 };\n         match d {\n-            Equinox { warp_factor: warp_factor } => {} // should suggest shorthand\n+            Equinox { warp_factor: warp_factor } => {}\n             //~^ WARN this pattern is redundant\n+            //~| HELP remove this\n         }\n         println!(\"{} {}\", a, b);\n     }"}, {"sha": "8e5dac8be78276b8f8c5ec1c3b71b81e38ed96ab", "filename": "src/test/ui/lint/suggestions.stderr", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fsuggestions.stderr?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -1,7 +1,7 @@\n warning: unnecessary parentheses around assigned value\n-  --> $DIR/suggestions.rs:48:21\n+  --> $DIR/suggestions.rs:64:21\n    |\n-LL |         let mut a = (1); // should suggest no `mut`, no parens\n+LL |         let mut a = (1);\n    |                     ^^^ help: remove these parentheses\n    |\n note: lint level defined here\n@@ -11,17 +11,17 @@ LL | #![warn(unused_mut, unused_parens)] // UI tests pass `-A unused`\u2014see Issu\n    |                     ^^^^^^^^^^^^^\n \n warning: use of deprecated attribute `no_debug`: the `#[no_debug]` attribute was an experimental feature that has been deprecated due to lack of demand. See https://github.com/rust-lang/rust/issues/29721\n-  --> $DIR/suggestions.rs:43:1\n+  --> $DIR/suggestions.rs:57:1\n    |\n LL | #[no_debug] // should suggest removal of deprecated attribute\n    | ^^^^^^^^^^^ help: remove this attribute\n    |\n    = note: #[warn(deprecated)] on by default\n \n warning: variable does not need to be mutable\n-  --> $DIR/suggestions.rs:48:13\n+  --> $DIR/suggestions.rs:64:13\n    |\n-LL |         let mut a = (1); // should suggest no `mut`, no parens\n+LL |         let mut a = (1);\n    |             ----^\n    |             |\n    |             help: remove this `mut`\n@@ -33,7 +33,7 @@ LL | #![warn(unused_mut, unused_parens)] // UI tests pass `-A unused`\u2014see Issu\n    |         ^^^^^^^^^^\n \n warning: variable does not need to be mutable\n-  --> $DIR/suggestions.rs:52:13\n+  --> $DIR/suggestions.rs:70:13\n    |\n LL |            let mut\n    |   _____________^\n@@ -47,67 +47,88 @@ LL | ||             b = 1;\n warning: static is marked #[no_mangle], but not exported\n   --> $DIR/suggestions.rs:16:14\n    |\n-LL | #[no_mangle] static SHENZHOU: usize = 1; // should suggest `pub`\n+LL | #[no_mangle] static SHENZHOU: usize = 1;\n    |              -^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |              |\n    |              help: try making it public: `pub`\n    |\n    = note: #[warn(private_no_mangle_statics)] on by default\n \n error: const items should never be #[no_mangle]\n-  --> $DIR/suggestions.rs:18:14\n+  --> $DIR/suggestions.rs:19:14\n    |\n-LL | #[no_mangle] const DISCOVERY: usize = 1; // should suggest `pub static` rather than `const`\n+LL | #[no_mangle] const DISCOVERY: usize = 1;\n    |              -----^^^^^^^^^^^^^^^^^^^^^^\n    |              |\n    |              help: try a static value: `pub static`\n    |\n    = note: #[deny(no_mangle_const_items)] on by default\n \n warning: functions generic over types must be mangled\n-  --> $DIR/suggestions.rs:22:1\n+  --> $DIR/suggestions.rs:25:1\n    |\n-LL | #[no_mangle] // should suggest removal (generics can't be no-mangle)\n+LL | #[no_mangle]\n    | ------------ help: remove this attribute\n+LL | //~^ HELP remove this attribute\n LL | pub fn defiant<T>(_t: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: #[warn(no_mangle_generic_items)] on by default\n \n warning: function is marked #[no_mangle], but not exported\n-  --> $DIR/suggestions.rs:26:1\n+  --> $DIR/suggestions.rs:29:1\n    |\n-LL | fn rio_grande() {} // should suggest `pub`\n+LL | fn rio_grande() {}\n    | -^^^^^^^^^^^^^^^^^\n    | |\n    | help: try making it public: `pub`\n    |\n    = note: #[warn(private_no_mangle_fns)] on by default\n \n warning: static is marked #[no_mangle], but not exported\n-  --> $DIR/suggestions.rs:33:18\n+  --> $DIR/suggestions.rs:37:18\n    |\n LL |     #[no_mangle] pub static DAUNTLESS: bool = true;\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try exporting the item with a `pub use` statement\n \n warning: function is marked #[no_mangle], but not exported\n-  --> $DIR/suggestions.rs:35:18\n+  --> $DIR/suggestions.rs:40:18\n    |\n LL |     #[no_mangle] pub fn val_jean() {}\n    |                  ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try exporting the item with a `pub use` statement\n+\n+warning: static is marked #[no_mangle], but not exported\n+  --> $DIR/suggestions.rs:45:18\n+   |\n+LL |     #[no_mangle] pub(crate) static VETAR: bool = true;\n+   |                  ----------^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  help: try making it public: `pub`\n+\n+warning: function is marked #[no_mangle], but not exported\n+  --> $DIR/suggestions.rs:48:18\n+   |\n+LL |     #[no_mangle] pub(crate) fn crossfield() {}\n+   |                  ----------^^^^^^^^^^^^^^^^^^^\n+   |                  |\n+   |                  help: try making it public: `pub`\n \n warning: denote infinite loops with `loop { ... }`\n-  --> $DIR/suggestions.rs:46:5\n+  --> $DIR/suggestions.rs:61:5\n    |\n-LL |     while true { // should suggest `loop`\n+LL |     while true {\n    |     ^^^^^^^^^^ help: use `loop`\n    |\n    = note: #[warn(while_true)] on by default\n \n warning: the `warp_factor:` in this pattern is redundant\n-  --> $DIR/suggestions.rs:57:23\n+  --> $DIR/suggestions.rs:76:23\n    |\n-LL |             Equinox { warp_factor: warp_factor } => {} // should suggest shorthand\n+LL |             Equinox { warp_factor: warp_factor } => {}\n    |                       ------------^^^^^^^^^^^^\n    |                       |\n    |                       help: remove this"}, {"sha": "1cbfbd211255dcef575ea683832093185fd28fe9", "filename": "src/test/ui/lint/unreachable_pub-pub_crate.stderr", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub-pub_crate.stderr?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -17,7 +17,9 @@ warning: unreachable `pub` item\n   --> $DIR/unreachable_pub-pub_crate.rs:27:24\n    |\n LL |     pub use std::env::{Args}; // braced-use has different item spans than unbraced\n-   |                        ^^^^ help: consider restricting its visibility: `pub(crate)`\n+   |     ---                ^^^^\n+   |     |\n+   |     help: consider restricting its visibility: `pub(crate)`\n    |\n    = help: or consider exporting it for use by other crates\n \n@@ -121,12 +123,13 @@ warning: unreachable `pub` item\n   --> $DIR/unreachable_pub-pub_crate.rs:50:47\n    |\n LL |         ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n-   |                                               -----------^^^^^^^^^^^^^\n-   |                                               |\n-   |                                               help: consider restricting its visibility: `pub(crate)`\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     }\n LL |     define_empty_struct_with_visibility!(pub, Fluorine);\n-   |     ---------------------------------------------------- in this macro invocation\n+   |     ----------------------------------------------------\n+   |     |                                    |\n+   |     |                                    help: consider restricting its visibility: `pub(crate)`\n+   |     in this macro invocation\n    |\n    = help: or consider exporting it for use by other crates\n "}, {"sha": "25046055aa0247310a6d086251ab09a66d5fa5bc", "filename": "src/test/ui/lint/unreachable_pub.stderr", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funreachable_pub.stderr?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -17,7 +17,9 @@ warning: unreachable `pub` item\n   --> $DIR/unreachable_pub.rs:22:24\n    |\n LL |     pub use std::env::{Args}; // braced-use has different item spans than unbraced\n-   |                        ^^^^ help: consider restricting its visibility: `crate`\n+   |     ---                ^^^^\n+   |     |\n+   |     help: consider restricting its visibility: `crate`\n    |\n    = help: or consider exporting it for use by other crates\n \n@@ -121,12 +123,13 @@ warning: unreachable `pub` item\n   --> $DIR/unreachable_pub.rs:45:47\n    |\n LL |         ($visibility: vis, $name: ident) => { $visibility struct $name {} }\n-   |                                               -----------^^^^^^^^^^^^^\n-   |                                               |\n-   |                                               help: consider restricting its visibility: `crate`\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     }\n LL |     define_empty_struct_with_visibility!(pub, Fluorine);\n-   |     ---------------------------------------------------- in this macro invocation\n+   |     ----------------------------------------------------\n+   |     |                                    |\n+   |     |                                    help: consider restricting its visibility: `crate`\n+   |     in this macro invocation\n    |\n    = help: or consider exporting it for use by other crates\n "}, {"sha": "ec3f48f0347d34988f07a45a0427a1314799a02c", "filename": "src/test/ui/pub/issue-33174-restricted-type-in-public-interface.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.rs?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types)]  // genus is always capitalized\n+\n+pub(crate) struct Snail;\n+//~^ NOTE `Snail` declared as crate-visible\n+\n+mod sea {\n+    pub(super) struct Turtle;\n+    //~^ NOTE `sea::Turtle` declared as restricted\n+}\n+\n+struct Tortoise;\n+//~^ NOTE `Tortoise` declared as private\n+\n+pub struct Shell<T> {\n+    pub(crate) creature: T,\n+}\n+\n+pub type Helix_pomatia = Shell<Snail>;\n+//~^ ERROR crate-visible type `Snail` in public interface\n+//~| NOTE can't leak crate-visible type\n+pub type Dermochelys_coriacea = Shell<sea::Turtle>;\n+//~^ ERROR restricted type `sea::Turtle` in public interface\n+//~| NOTE can't leak restricted type\n+pub type Testudo_graeca = Shell<Tortoise>;\n+//~^ ERROR private type `Tortoise` in public interface\n+//~| NOTE can't leak private type\n+\n+fn main() {}"}, {"sha": "b35a12f999c8dccd18e0b4605176a9fc7674dc13", "filename": "src/test/ui/pub/issue-33174-restricted-type-in-public-interface.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/45935640f058405c95c96308f3acfd5ac1535698/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpub%2Fissue-33174-restricted-type-in-public-interface.stderr?ref=45935640f058405c95c96308f3acfd5ac1535698", "patch": "@@ -0,0 +1,30 @@\n+error[E0446]: crate-visible type `Snail` in public interface\n+  --> $DIR/issue-33174-restricted-type-in-public-interface.rs:28:1\n+   |\n+LL | pub(crate) struct Snail;\n+   | ---------- `Snail` declared as crate-visible\n+...\n+LL | pub type Helix_pomatia = Shell<Snail>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak crate-visible type\n+\n+error[E0446]: restricted type `sea::Turtle` in public interface\n+  --> $DIR/issue-33174-restricted-type-in-public-interface.rs:31:1\n+   |\n+LL |     pub(super) struct Turtle;\n+   |     ---------- `sea::Turtle` declared as restricted\n+...\n+LL | pub type Dermochelys_coriacea = Shell<sea::Turtle>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak restricted type\n+\n+error[E0446]: private type `Tortoise` in public interface\n+  --> $DIR/issue-33174-restricted-type-in-public-interface.rs:34:1\n+   |\n+LL | struct Tortoise;\n+   | - `Tortoise` declared as private\n+...\n+LL | pub type Testudo_graeca = Shell<Tortoise>;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0446`."}]}