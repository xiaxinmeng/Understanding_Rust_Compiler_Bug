{"sha": "0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNDE5ZWZiMWM4OTM5YTZmNDc2ZjRhZWEzMTE3ZTdhNDJlYmY0Yjc=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-25T17:05:37Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-10-25T17:33:45Z"}, "message": "check for object safety violations in constants", "tree": {"sha": "d3bf79a9e29abd3aed2911be3b8a435f7afca73e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3bf79a9e29abd3aed2911be3b8a435f7afca73e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "html_url": "https://github.com/rust-lang/rust/commit/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dadcf83707ba3503ad7e2849070443ef37f65b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dadcf83707ba3503ad7e2849070443ef37f65b2", "html_url": "https://github.com/rust-lang/rust/commit/9dadcf83707ba3503ad7e2849070443ef37f65b2"}], "stats": {"total": 284, "additions": 237, "deletions": 47}, "files": [{"sha": "4bba1feb6471c9a9cfb49efed9d40d092fff230d", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "patch": "@@ -85,8 +85,10 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                         } else if leaf.has_param_types_or_consts() {\n                             failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                         }\n+\n+                        false\n                     }\n-                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => (),\n+                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => false,\n                 });\n \n                 match failure_kind {\n@@ -194,12 +196,12 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n ///\n /// This is only able to represent a subset of `MIR`,\n /// and should not leak any information about desugarings.\n-#[derive(Clone, Copy)]\n+#[derive(Debug, Clone, Copy)]\n pub struct AbstractConst<'tcx> {\n     // FIXME: Consider adding something like `IndexSlice`\n     // and use this here.\n-    inner: &'tcx [Node<'tcx>],\n-    substs: SubstsRef<'tcx>,\n+    pub inner: &'tcx [Node<'tcx>],\n+    pub substs: SubstsRef<'tcx>,\n }\n \n impl AbstractConst<'tcx> {\n@@ -212,6 +214,17 @@ impl AbstractConst<'tcx> {\n         Ok(inner.map(|inner| AbstractConst { inner, substs }))\n     }\n \n+    pub fn from_const(\n+        tcx: TyCtxt<'tcx>,\n+        ct: &ty::Const<'tcx>,\n+    ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n+        match ct.val {\n+            ty::ConstKind::Unevaluated(def, substs, None) => AbstractConst::new(tcx, def, substs),\n+            ty::ConstKind::Error(_) => Err(ErrorReported),\n+            _ => Ok(None),\n+        }\n+    }\n+\n     #[inline]\n     pub fn subtree(self, node: NodeId) -> AbstractConst<'tcx> {\n         AbstractConst { inner: &self.inner[..=node.index()], substs: self.substs }\n@@ -550,31 +563,32 @@ pub(super) fn try_unify_abstract_consts<'tcx>(\n     // on `ErrorReported`.\n }\n \n-fn walk_abstract_const<'tcx, F>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, mut f: F)\n+// FIXME: Use `std::ops::ControlFlow` instead of `bool` here.\n+pub fn walk_abstract_const<'tcx, F>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, mut f: F) -> bool\n where\n-    F: FnMut(Node<'tcx>),\n+    F: FnMut(Node<'tcx>) -> bool,\n {\n-    recurse(tcx, ct, &mut f);\n-    fn recurse<'tcx>(tcx: TyCtxt<'tcx>, ct: AbstractConst<'tcx>, f: &mut dyn FnMut(Node<'tcx>)) {\n+    fn recurse<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        ct: AbstractConst<'tcx>,\n+        f: &mut dyn FnMut(Node<'tcx>) -> bool,\n+    ) -> bool {\n         let root = ct.root();\n-        f(root);\n-        match root {\n-            Node::Leaf(_) => (),\n-            Node::Binop(_, l, r) => {\n-                recurse(tcx, ct.subtree(l), f);\n-                recurse(tcx, ct.subtree(r), f);\n-            }\n-            Node::UnaryOp(_, v) => {\n-                recurse(tcx, ct.subtree(v), f);\n-            }\n-            Node::FunctionCall(func, args) => {\n-                recurse(tcx, ct.subtree(func), f);\n-                for &arg in args {\n-                    recurse(tcx, ct.subtree(arg), f);\n+        f(root)\n+            || match root {\n+                Node::Leaf(_) => false,\n+                Node::Binop(_, l, r) => {\n+                    recurse(tcx, ct.subtree(l), f) || recurse(tcx, ct.subtree(r), f)\n+                }\n+                Node::UnaryOp(_, v) => recurse(tcx, ct.subtree(v), f),\n+                Node::FunctionCall(func, args) => {\n+                    recurse(tcx, ct.subtree(func), f)\n+                        || args.iter().any(|&arg| recurse(tcx, ct.subtree(arg), f))\n                 }\n             }\n-        }\n     }\n+\n+    recurse(tcx, ct, &mut f)\n }\n \n /// Tries to unify two abstract constants using structural equality."}, {"sha": "d2ac24b6100daf81b97b59a3bf93a4042de60228", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "patch": "@@ -11,6 +11,7 @@\n use super::elaborate_predicates;\n \n use crate::infer::TyCtxtInferExt;\n+use crate::traits::const_evaluatable::{self, AbstractConst};\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n use rustc_errors::FatalError;\n@@ -249,7 +250,7 @@ fn predicates_reference_self(\n     predicates\n         .predicates\n         .iter()\n-        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), *sp))\n+        .map(|&(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|predicate| predicate_references_self(tcx, predicate))\n         .collect()\n }\n@@ -260,7 +261,7 @@ fn bounds_reference_self(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span\n         .in_definition_order()\n         .filter(|item| item.kind == ty::AssocKind::Type)\n         .flat_map(|item| tcx.explicit_item_bounds(item.def_id))\n-        .map(|(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), *sp))\n+        .map(|&(predicate, sp)| (predicate.subst_supertrait(tcx, &trait_ref), sp))\n         .filter_map(|predicate| predicate_references_self(tcx, predicate))\n         .collect()\n }\n@@ -415,7 +416,7 @@ fn virtual_call_violation_for_method<'tcx>(\n         ));\n     }\n \n-    for (i, input_ty) in sig.skip_binder().inputs()[1..].iter().enumerate() {\n+    for (i, &input_ty) in sig.skip_binder().inputs()[1..].iter().enumerate() {\n         if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelfInput(i));\n         }\n@@ -438,10 +439,7 @@ fn virtual_call_violation_for_method<'tcx>(\n         // so outlives predicates will always hold.\n         .cloned()\n         .filter(|(p, _)| p.to_opt_type_outlives().is_none())\n-        .collect::<Vec<_>>()\n-        // Do a shallow visit so that `contains_illegal_self_type_reference`\n-        // may apply it's custom visiting.\n-        .visit_tys_shallow(|t| contains_illegal_self_type_reference(tcx, trait_def_id, t))\n+        .any(|pred| contains_illegal_self_type_reference(tcx, trait_def_id, pred))\n     {\n         return Some(MethodViolationCode::WhereClauseReferencesSelf);\n     }\n@@ -715,10 +713,10 @@ fn receiver_is_dispatchable<'tcx>(\n     })\n }\n \n-fn contains_illegal_self_type_reference<'tcx>(\n+fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     trait_def_id: DefId,\n-    ty: Ty<'tcx>,\n+    value: T,\n ) -> bool {\n     // This is somewhat subtle. In general, we want to forbid\n     // references to `Self` in the argument and return types,\n@@ -761,15 +759,14 @@ fn contains_illegal_self_type_reference<'tcx>(\n \n     struct IllegalSelfTypeVisitor<'tcx> {\n         tcx: TyCtxt<'tcx>,\n-        self_ty: Ty<'tcx>,\n         trait_def_id: DefId,\n         supertraits: Option<Vec<ty::PolyTraitRef<'tcx>>>,\n     }\n \n     impl<'tcx> TypeVisitor<'tcx> for IllegalSelfTypeVisitor<'tcx> {\n         fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n             match t.kind() {\n-                ty::Param(_) => t == self.self_ty,\n+                ty::Param(_) => t == self.tcx.types.self_param,\n                 ty::Projection(ref data) => {\n                     // This is a projected type `<Foo as SomeTrait>::X`.\n \n@@ -802,22 +799,62 @@ fn contains_illegal_self_type_reference<'tcx>(\n             }\n         }\n \n-        fn visit_const(&mut self, _c: &ty::Const<'tcx>) -> bool {\n-            // FIXME(#72219) Look into the unevaluated constants for object safety violations.\n-            // Do not walk substitutions of unevaluated consts, as they contain `Self`, even\n-            // though the const expression doesn't necessary use it. Currently type variables\n-            // inside array length expressions are forbidden, so they can't break the above\n-            // rules.\n-            false\n+        fn visit_const(&mut self, ct: &ty::Const<'tcx>) -> bool {\n+            // First check if the type of this constant references `Self`.\n+            if self.visit_ty(ct.ty) {\n+                return true;\n+            }\n+\n+            // Constants can only influence object safety if they reference `Self`.\n+            // This is only possible for unevaluated constants, so we walk these here.\n+            //\n+            // If `AbstractConst::new` returned an error we already failed compilation\n+            // so we don't have to emit an additional error here.\n+            //\n+            // We currently recurse into abstract consts here but do not recurse in\n+            // `is_const_evaluatable`. This means that the object safety check is more\n+            // liberal than the const eval check.\n+            //\n+            // This shouldn't really matter though as we can't really use any\n+            // constants which are not considered const evaluatable.\n+            use rustc_middle::mir::abstract_const::Node;\n+            if let Ok(Some(ct)) = AbstractConst::from_const(self.tcx, ct) {\n+                const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node {\n+                    Node::Leaf(leaf) => {\n+                        let leaf = leaf.subst(self.tcx, ct.substs);\n+                        self.visit_const(leaf)\n+                    }\n+                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => false,\n+                })\n+            } else {\n+                false\n+            }\n+        }\n+\n+        fn visit_predicate(&mut self, pred: ty::Predicate<'tcx>) -> bool {\n+            if let ty::PredicateAtom::ConstEvaluatable(def, substs) = pred.skip_binders() {\n+                // FIXME(const_evaluatable_checked): We should probably deduplicate the logic for\n+                // `AbstractConst`s here, it might make sense to change `ConstEvaluatable` to\n+                // take a `ty::Const` instead.\n+                use rustc_middle::mir::abstract_const::Node;\n+                if let Ok(Some(ct)) = AbstractConst::new(self.tcx, def, substs) {\n+                    const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node {\n+                        Node::Leaf(leaf) => {\n+                            let leaf = leaf.subst(self.tcx, ct.substs);\n+                            self.visit_const(leaf)\n+                        }\n+                        Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => false,\n+                    })\n+                } else {\n+                    false\n+                }\n+            } else {\n+                pred.super_visit_with(self)\n+            }\n         }\n     }\n \n-    ty.visit_with(&mut IllegalSelfTypeVisitor {\n-        tcx,\n-        self_ty: tcx.types.self_param,\n-        trait_def_id,\n-        supertraits: None,\n-    })\n+    value.visit_with(&mut IllegalSelfTypeVisitor { tcx, trait_def_id, supertraits: None })\n }\n \n pub fn provide(providers: &mut ty::query::Providers) {"}, {"sha": "5be4b41784c270dbd580373ee531709e8593e37e", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-ret.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.rs?ref=0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "patch": "@@ -0,0 +1,21 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+\n+const fn bar<T: ?Sized>() -> usize { 7 }\n+\n+trait Foo {\n+    fn test(&self) -> [u8; bar::<Self>()];\n+}\n+\n+impl Foo for () {\n+    fn test(&self) -> [u8; bar::<Self>()] {\n+        [0; bar::<Self>()]\n+    }\n+}\n+\n+fn use_dyn(v: &dyn Foo) { //~ERROR the trait `Foo` cannot be made into an object\n+    v.test();\n+}\n+\n+fn main() {}"}, {"sha": "e0e6029252c00b3471084c478d037e1e4e86f45e", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-ret.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-ret.stderr?ref=0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "patch": "@@ -0,0 +1,18 @@\n+error[E0038]: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety-err-ret.rs:17:15\n+   |\n+LL | fn use_dyn(v: &dyn Foo) {\n+   |               ^^^^^^^^ `Foo` cannot be made into an object\n+   |\n+   = help: consider moving `test` to another trait\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/object-safety-err-ret.rs:8:23\n+   |\n+LL | trait Foo {\n+   |       --- this trait cannot be made into an object...\n+LL |     fn test(&self) -> [u8; bar::<Self>()];\n+   |                       ^^^^^^^^^^^^^^^^^^^ ...because method `test` references the `Self` type in its return type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0038`."}, {"sha": "5fbd4a5fa2e6434dee7d0d115bcbc6fd587ff789", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-where-bounds.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.rs?ref=0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "patch": "@@ -0,0 +1,22 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+#![deny(where_clauses_object_safety)]\n+\n+\n+const fn bar<T: ?Sized>() -> usize { 7 }\n+\n+trait Foo {\n+    fn test(&self) where [u8; bar::<Self>()]: Sized;\n+    //~^ ERROR the trait `Foo` cannot be made into an object\n+    //~| WARN this was previously accepted by the compiler but is being phased out\n+}\n+\n+impl Foo for () {\n+    fn test(&self) where [u8; bar::<Self>()]: Sized {}\n+}\n+\n+fn use_dyn(v: &dyn Foo) {\n+    v.test();\n+}\n+\n+fn main() {}"}, {"sha": "45c7d835f339a9321a2f2656939e45c5f8b6de6c", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-err-where-bounds.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-err-where-bounds.stderr?ref=0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "patch": "@@ -0,0 +1,24 @@\n+error: the trait `Foo` cannot be made into an object\n+  --> $DIR/object-safety-err-where-bounds.rs:9:8\n+   |\n+LL |     fn test(&self) where [u8; bar::<Self>()]: Sized;\n+   |        ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/object-safety-err-where-bounds.rs:3:9\n+   |\n+LL | #![deny(where_clauses_object_safety)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #51443 <https://github.com/rust-lang/rust/issues/51443>\n+note: for a trait to be \"object safe\" it needs to allow building a vtable to allow the call to be resolvable dynamically; for more information visit <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\n+  --> $DIR/object-safety-err-where-bounds.rs:9:8\n+   |\n+LL | trait Foo {\n+   |       --- this trait cannot be made into an object...\n+LL |     fn test(&self) where [u8; bar::<Self>()]: Sized;\n+   |        ^^^^ ...because method `test` references the `Self` type in its `where` clause\n+   = help: consider moving `test` to another trait\n+\n+error: aborting due to previous error\n+"}, {"sha": "0f85952b4e483c027337f5cb033d787ae1c2c1af", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-ok-infer-err.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.rs?ref=0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "patch": "@@ -0,0 +1,21 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+trait Foo<const N: usize> {\n+    fn test(&self) -> [u8; N + 1];\n+}\n+\n+impl<const N: usize> Foo<N> for () {\n+    fn test(&self) -> [u8; N + 1] {\n+        [0; N + 1]\n+    }\n+}\n+\n+fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n+    assert_eq!(v.test(), [0; N + 1]);\n+}\n+\n+fn main() {\n+    use_dyn(&());\n+    //~^ ERROR type annotations needed\n+}"}, {"sha": "3523de2b6ba338f396932bb32ac20cbf7d89bf16", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-ok-infer-err.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok-infer-err.stderr?ref=0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "patch": "@@ -0,0 +1,12 @@\n+error[E0284]: type annotations needed: cannot satisfy `the constant `use_dyn::<{_: usize}>::{constant#0}` can be evaluated`\n+  --> $DIR/object-safety-ok-infer-err.rs:19:5\n+   |\n+LL | fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n+   |                                                       ----- required by this bound in `use_dyn`\n+...\n+LL |     use_dyn(&());\n+   |     ^^^^^^^ cannot satisfy `the constant `use_dyn::<{_: usize}>::{constant#0}` can be evaluated`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "ae78b7936a289396962203a9ab202ce66be6dec1", "filename": "src/test/ui/const-generics/const_evaluatable_checked/object-safety-ok.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e419efb1c8939a6f476f4aea3117e7a42ebf4b7/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_evaluatable_checked%2Fobject-safety-ok.rs?ref=0e419efb1c8939a6f476f4aea3117e7a42ebf4b7", "patch": "@@ -0,0 +1,21 @@\n+// run-pass\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+trait Foo<const N: usize> {\n+    fn test(&self) -> [u8; N + 1];\n+}\n+\n+impl<const N: usize> Foo<N> for () {\n+    fn test(&self) -> [u8; N + 1] {\n+        [0; N + 1]\n+    }\n+}\n+\n+fn use_dyn<const N: usize>(v: &dyn Foo<N>) where [u8; N + 1]: Sized {\n+    assert_eq!(v.test(), [0; N + 1]);\n+}\n+\n+fn main() {\n+    use_dyn::<3>(&());\n+}"}]}