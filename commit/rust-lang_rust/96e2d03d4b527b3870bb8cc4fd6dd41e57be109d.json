{"sha": "96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2ZTJkMDNkNGI1MjdiMzg3MGJiOGNjNGZkNmRkNDFlNTdiZTEwOWQ=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-03-17T15:45:02Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2020-03-23T03:40:19Z"}, "message": "Store idents for `DefPathData` into crate metadata\n\nPreviously, we threw away the `Span` associated with a definition's\nidentifier when we encoded crate metadata, causing us to lose location\nand hygiene information.\n\nWe now store the identifier's `Span` in the crate metadata.\nWhen we decode items from the metadata, we combine\nthe name and span back into an `Ident`.\n\nThis improves the output of several tests, which previously had messages\nsuppressed due to dummy spans.\n\nThis is a prerequisite for #68686, since throwing away a `Span` means\nthat we lose hygiene information.", "tree": {"sha": "5e70fd04b90bd64d2ab034008a0b4290f82d50cc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e70fd04b90bd64d2ab034008a0b4290f82d50cc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl54L6MACgkQtAh+UQ6Y\nsWTJ1Q/+JNdRZI2fRcTOzLpoQNsYQH6nw3qcJ86iJ2iA7B0lTbADrJ/DZnKO7kf1\nG/sGsA87gS8mqhKxZDpd1IIAe5SlRCqc6fDok/WUYJUHpvg5VOVgqfrsDDSKEOpl\nYpJVAVXsWTqim8m0w0pvCljMrGW9UsKnr2kM4q4NpGUJlA2WJE3LVFi3Aw0uSCAT\nIf58pZ62Os3N5Mdz1xi8j3KdcaF1UhbUUI9vnWL+lBwupX6kK3xPt4rpSOvLib+M\nMW4injjFZjl78byslJ82xl9hyIFg+fwaaeyYchzPJgkk3wuqvjj6l23fWgoaAmwU\nVoDAnMCUYx5YNFmpow7t/aVq2MRrVVo3cRCuSa/zeSiys2CFv/sbK9ehizUnHc1Y\nXW2q/Md48Wl6oEXlBjqUqj3GbFDyjrDrIUfl9zKxJs+cJuqWwdbTiAlnRkHrE5e4\n6OwRxa7wySCAh4Xx2iLcEvurI+fCNc+OVLTFM+SWDy4KZSHU0PduYliNTn9u6u5F\nA69Z51T9YWF31JeCNFJgLzjdeBIYOie/Q/H55vtycgFNOtp/n03ZnpVc/a8sMyYe\ncw/c4DDb3aUVhvl7YNtbNKysNz3n1DZvkSfF3MKwlTGHMu+l/88is3Z8U/Ipa5Fh\nBWhn1MHyq0OGESSD2uFqGLpzv3QVkakjUt+91tBxvD5AtNemk24=\n=0s7D\n-----END PGP SIGNATURE-----", "payload": "tree 5e70fd04b90bd64d2ab034008a0b4290f82d50cc\nparent e4b01c7791446b2f79a1b1d517223378df2bf5f2\nauthor Aaron Hill <aa1ronham@gmail.com> 1584459902 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1584934819 -0400\n\nStore idents for `DefPathData` into crate metadata\n\nPreviously, we threw away the `Span` associated with a definition's\nidentifier when we encoded crate metadata, causing us to lose location\nand hygiene information.\n\nWe now store the identifier's `Span` in the crate metadata.\nWhen we decode items from the metadata, we combine\nthe name and span back into an `Ident`.\n\nThis improves the output of several tests, which previously had messages\nsuppressed due to dummy spans.\n\nThis is a prerequisite for #68686, since throwing away a `Span` means\nthat we lose hygiene information.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "html_url": "https://github.com/rust-lang/rust/commit/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4b01c7791446b2f79a1b1d517223378df2bf5f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4b01c7791446b2f79a1b1d517223378df2bf5f2", "html_url": "https://github.com/rust-lang/rust/commit/e4b01c7791446b2f79a1b1d517223378df2bf5f2"}], "stats": {"total": 263, "additions": 224, "deletions": 39}, "files": [{"sha": "754bae0ddb8134f5359aa795466d775210e64094", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 31, "deletions": 25, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -509,14 +509,6 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl SpecializedDecoder<Ident> for DecodeContext<'_, '_> {\n-    fn specialized_decode(&mut self) -> Result<Ident, Self::Error> {\n-        // FIXME(jseyfried): intercrate hygiene\n-\n-        Ok(Ident::with_dummy_span(Symbol::decode(self)?))\n-    }\n-}\n-\n impl<'a, 'tcx> SpecializedDecoder<Fingerprint> for DecodeContext<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<Fingerprint, Self::Error> {\n         Fingerprint::decode_opaque(&mut self.opaque)\n@@ -663,15 +655,27 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n-    fn item_name(&self, item_index: DefIndex) -> Symbol {\n+    fn item_ident(&self, item_index: DefIndex, sess: &Session) -> Ident {\n         if !self.is_proc_macro(item_index) {\n-            self.def_key(item_index)\n+            let name = self\n+                .def_key(item_index)\n                 .disambiguated_data\n                 .data\n                 .get_opt_name()\n-                .expect(\"no name in item_name\")\n+                .expect(\"no name in item_ident\");\n+            let span = self\n+                .root\n+                .per_def\n+                .ident_span\n+                .get(self, item_index)\n+                .map(|data| data.decode((self, sess)))\n+                .unwrap_or_else(|| panic!(\"Missing ident span for {:?} ({:?})\", name, item_index));\n+            Ident::new(name, span)\n         } else {\n-            Symbol::intern(self.raw_proc_macro(item_index).name())\n+            Ident::new(\n+                Symbol::intern(self.raw_proc_macro(item_index).name()),\n+                self.get_span(item_index, sess),\n+            )\n         }\n     }\n \n@@ -750,6 +754,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         kind: &EntryKind,\n         index: DefIndex,\n         parent_did: DefId,\n+        sess: &Session,\n     ) -> ty::VariantDef {\n         let data = match kind {\n             EntryKind::Variant(data) | EntryKind::Struct(data, _) | EntryKind::Union(data, _) => {\n@@ -771,7 +776,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         ty::VariantDef::new(\n             tcx,\n-            Ident::with_dummy_span(self.item_name(index)),\n+            self.item_ident(index, sess),\n             variant_did,\n             ctor_did,\n             data.discr,\n@@ -783,7 +788,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .decode(self)\n                 .map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    ident: Ident::with_dummy_span(self.item_name(index)),\n+                    ident: self.item_ident(index, sess),\n                     vis: self.get_visibility(index),\n                 })\n                 .collect(),\n@@ -812,10 +817,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or(Lazy::empty())\n                 .decode(self)\n-                .map(|index| self.get_variant(tcx, &self.kind(index), index, did))\n+                .map(|index| self.get_variant(tcx, &self.kind(index), index, did, tcx.sess))\n                 .collect()\n         } else {\n-            std::iter::once(self.get_variant(tcx, &kind, item_id, did)).collect()\n+            std::iter::once(self.get_variant(tcx, &kind, item_id, did, tcx.sess)).collect()\n         };\n \n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n@@ -1007,7 +1012,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                             if let Some(kind) = self.def_kind(child_index) {\n                                 callback(Export {\n                                     res: Res::Def(kind, self.local_def_id(child_index)),\n-                                    ident: Ident::with_dummy_span(self.item_name(child_index)),\n+                                    ident: self.item_ident(child_index, sess),\n                                     vis: self.get_visibility(child_index),\n                                     span: self\n                                         .root\n@@ -1028,10 +1033,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n                 let def_key = self.def_key(child_index);\n                 let span = self.get_span(child_index, sess);\n-                if let (Some(kind), Some(name)) =\n-                    (self.def_kind(child_index), def_key.disambiguated_data.data.get_opt_name())\n-                {\n-                    let ident = Ident::with_dummy_span(name);\n+                if let (Some(kind), true) = (\n+                    self.def_kind(child_index),\n+                    def_key.disambiguated_data.data.get_opt_name().is_some(),\n+                ) {\n+                    let ident = self.item_ident(child_index, sess);\n                     let vis = self.get_visibility(child_index);\n                     let def_id = self.local_def_id(child_index);\n                     let res = Res::Def(kind, def_id);\n@@ -1138,10 +1144,10 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_associated_item(&self, id: DefIndex) -> ty::AssocItem {\n+    fn get_associated_item(&self, id: DefIndex, sess: &Session) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n-        let name = def_key.disambiguated_data.data.get_opt_name().unwrap();\n+        let ident = self.item_ident(id, sess);\n \n         let (kind, container, has_self) = match self.kind(id) {\n             EntryKind::AssocConst(container, _, _) => (ty::AssocKind::Const, container, false),\n@@ -1155,7 +1161,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         };\n \n         ty::AssocItem {\n-            ident: Ident::with_dummy_span(name),\n+            ident,\n             kind,\n             vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n@@ -1219,7 +1225,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .get(self, id)\n             .unwrap_or(Lazy::empty())\n             .decode(self)\n-            .map(|index| respan(self.get_span(index, sess), self.item_name(index)))\n+            .map(|index| respan(self.get_span(index, sess), self.item_ident(index, sess).name))\n             .collect()\n     }\n "}, {"sha": "c2ea981caa90da8cc0a8039fddbbaa7bea7cbf69", "filename": "src/librustc_metadata/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -110,7 +110,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n           |child| result.push(child.res.def_id()), tcx.sess);\n         tcx.arena.alloc_slice(&result)\n     }\n-    associated_item => { cdata.get_associated_item(def_id.index) }\n+    associated_item => { cdata.get_associated_item(def_id.index, tcx.sess) }\n     impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n     impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n     coerce_unsized_info => {\n@@ -442,8 +442,8 @@ impl CStore {\n         )\n     }\n \n-    pub fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssocItem {\n-        self.get_crate_data(def.krate).get_associated_item(def.index)\n+    pub fn associated_item_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::AssocItem {\n+        self.get_crate_data(def.krate).get_associated_item(def.index, sess)\n     }\n \n     pub fn crate_source_untracked(&self, cnum: CrateNum) -> CrateSource {"}, {"sha": "af6486fb9cdd19a665cd23489ac371cfaf382ac1", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -13,7 +13,7 @@ use rustc::traits::specialization_graph;\n use rustc::ty::codec::{self as ty_codec, TyEncoder};\n use rustc::ty::layout::VariantIdx;\n use rustc::ty::{self, SymbolName, Ty, TyCtxt};\n-use rustc_ast::ast;\n+use rustc_ast::ast::{self, Ident};\n use rustc_ast::attr;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n@@ -30,7 +30,7 @@ use rustc_index::vec::Idx;\n use rustc_serialize::{opaque, Encodable, Encoder, SpecializedEncoder};\n use rustc_session::config::{self, CrateType};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::{kw, sym, Ident, Symbol};\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span};\n use std::hash::Hash;\n use std::num::NonZeroUsize;\n@@ -220,13 +220,6 @@ impl<'tcx> SpecializedEncoder<Span> for EncodeContext<'tcx> {\n     }\n }\n \n-impl SpecializedEncoder<Ident> for EncodeContext<'tcx> {\n-    fn specialized_encode(&mut self, ident: &Ident) -> Result<(), Self::Error> {\n-        // FIXME(jseyfried): intercrate hygiene\n-        ident.name.encode(self)\n-    }\n-}\n-\n impl<'tcx> SpecializedEncoder<LocalDefId> for EncodeContext<'tcx> {\n     #[inline]\n     fn specialized_encode(&mut self, def_id: &LocalDefId) -> Result<(), Self::Error> {\n@@ -633,6 +626,7 @@ impl EncodeContext<'tcx> {\n             assert!(f.did.is_local());\n             f.did.index\n         }));\n+        self.encode_ident_span(def_id, variant.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n@@ -735,6 +729,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- field.vis);\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.per_def.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n+        self.encode_ident_span(def_id, field.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n@@ -869,6 +864,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- trait_item.vis);\n         record!(self.per_def.span[def_id] <- ast_item.span);\n         record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n+        self.encode_ident_span(def_id, ast_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -952,6 +948,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- impl_item.vis);\n         record!(self.per_def.span[def_id] <- ast_item.span);\n         record!(self.per_def.attributes[def_id] <- ast_item.attrs);\n+        self.encode_ident_span(def_id, impl_item.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -1058,6 +1055,8 @@ impl EncodeContext<'tcx> {\n \n         debug!(\"EncodeContext::encode_info_for_item({:?})\", def_id);\n \n+        self.encode_ident_span(def_id, item.ident);\n+\n         record!(self.per_def.kind[def_id] <- match item.kind {\n             hir::ItemKind::Static(_, hir::Mutability::Mut, _) => EntryKind::MutStatic,\n             hir::ItemKind::Static(_, hir::Mutability::Not, _) => EntryKind::ImmStatic,\n@@ -1284,6 +1283,7 @@ impl EncodeContext<'tcx> {\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.per_def.span[def_id] <- macro_def.span);\n         record!(self.per_def.attributes[def_id] <- macro_def.attrs);\n+        self.encode_ident_span(def_id, macro_def.ident);\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n     }\n@@ -1528,6 +1528,7 @@ impl EncodeContext<'tcx> {\n             ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n         record!(self.per_def.span[def_id] <- nitem.span);\n         record!(self.per_def.attributes[def_id] <- nitem.attrs);\n+        self.encode_ident_span(def_id, nitem.ident);\n         self.encode_stability(def_id);\n         self.encode_const_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -1622,6 +1623,10 @@ impl EncodeContext<'tcx> {\n         }\n     }\n \n+    fn encode_ident_span(&mut self, def_id: DefId, ident: Ident) {\n+        record!(self.per_def.ident_span[def_id] <- ident.span);\n+    }\n+\n     /// In some cases, along with the item itself, we also\n     /// encode some sub-items. Usually we want some info from the item\n     /// so it's easier to do that here then to wait until we would encounter"}, {"sha": "3a4214e916acb2c0156997afb777382848bd6680", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -256,6 +256,7 @@ define_per_def_tables! {\n     kind: Table<DefIndex, Lazy<EntryKind>>,\n     visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n     span: Table<DefIndex, Lazy<Span>>,\n+    ident_span: Table<DefIndex, Lazy<Span>>,\n     attributes: Table<DefIndex, Lazy<[ast::Attribute]>>,\n     children: Table<DefIndex, Lazy<[DefIndex]>>,\n     stability: Table<DefIndex, Lazy<attr::Stability>>,"}, {"sha": "d29ec83bfa09a4284b5faa79df52cb7e1509b430", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -904,7 +904,10 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.insert_field_names(def_id, field_names);\n             }\n             Res::Def(DefKind::AssocFn, def_id) => {\n-                if cstore.associated_item_cloned_untracked(def_id).method_has_self_argument {\n+                if cstore\n+                    .associated_item_cloned_untracked(def_id, self.r.session)\n+                    .method_has_self_argument\n+                {\n                     self.r.has_self.insert(def_id);\n                 }\n             }"}, {"sha": "a5c961a061acbdfd77221632b07bdff15b62266a", "filename": "src/test/ui/copy-a-resource.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -6,6 +6,14 @@ LL | struct Foo {\n ...\n LL |     let _y = x.clone();\n    |                ^^^^^ method not found in `Foo`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<Foo>` here\n+   |        the method is available for `std::rc::Rc<Foo>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "be446feb847eb5a84df31d4f9657e68163ac9fdd", "filename": "src/test/ui/derives/derive-assoc-type-not-impl.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -12,6 +12,14 @@ LL | struct NotClone;\n ...\n LL |     Bar::<NotClone> { x: 1 }.clone();\n    |                              ^^^^^ method not found in `Bar<NotClone>`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<Bar<NotClone>>` here\n+   |        the method is available for `std::rc::Rc<Bar<NotClone>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `NotClone: std::clone::Clone`"}, {"sha": "8bf245648f84bc02846f3f2f84f013ad29d50e15", "filename": "src/test/ui/error-codes/E0004-2.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0004-2.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -3,6 +3,14 @@ error[E0004]: non-exhaustive patterns: `None` and `Some(_)` not covered\n    |\n LL |     match x { }\n    |           ^ patterns `None` and `Some(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     None,\n+   |     ---- not covered\n+...\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "5028405e731a3df9a2f94f1b18e949349c824709", "filename": "src/test/ui/error-codes/E0005.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0005.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -3,6 +3,11 @@ error[E0005]: refutable pattern in local binding: `None` not covered\n    |\n LL |     let Some(y) = x;\n    |         ^^^^^^^ pattern `None` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     None,\n+   |     ---- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "e25fb09f15757aac58ba2f659b63831db7663ccf", "filename": "src/test/ui/error-codes/E0297.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0297.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -3,6 +3,11 @@ error[E0005]: refutable pattern in `for` loop binding: `None` not covered\n    |\n LL |     for Some(x) in xs {}\n    |         ^^^^^^^ pattern `None` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     None,\n+   |     ---- not covered\n \n error: aborting due to previous error\n "}, {"sha": "3334e4701949461d96597f3c41f0c073218a8cac", "filename": "src/test/ui/feature-gates/feature-gate-exhaustive-patterns.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-exhaustive-patterns.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -3,6 +3,11 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n    |\n LL |     let Ok(_x) = foo();\n    |         ^^^^^^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "b5bc0c76c2fc56e46f6426276e39cc38c1ae04cb", "filename": "src/test/ui/generic-associated-types/iterable.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fiterable.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -5,6 +5,11 @@ LL | impl<T> Iterable for Vec<T> {\n    | --------------------------- in this `impl` item\n LL |     type Item<'a> where T: 'a = <std::slice::Iter<'a, T> as Iterator>::Item;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found associated type\n+   | \n+  ::: $SRC_DIR/libcore/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     type Item;\n+   |          ---- associated type defined here\n    |\n    = note:    expected reference `&T`\n            found associated type `<std::vec::Vec<T> as Iterable>::Item<'_>`\n@@ -18,6 +23,11 @@ LL | impl<T> Iterable for [T] {\n    | ------------------------ in this `impl` item\n LL |     type Item<'a> where T: 'a = <std::slice::Iter<'a, T> as Iterator>::Item;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected reference, found associated type\n+   | \n+  ::: $SRC_DIR/libcore/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     type Item;\n+   |          ---- associated type defined here\n    |\n    = note:    expected reference `&T`\n            found associated type `<[T] as Iterable>::Item<'_>`"}, {"sha": "b5135b53e18905852274a53c42caccbab77c6173", "filename": "src/test/ui/impl-trait/no-method-suggested-traits.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fno-method-suggested-traits.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -83,6 +83,16 @@ error[E0599]: no method named `method` found for struct `std::rc::Rc<&mut std::b\n    |\n LL |     std::rc::Rc::new(&mut Box::new(&1i32)).method();\n    |                                            ^^^^^^ method not found in `std::rc::Rc<&mut std::boxed::Box<&i32>>`\n+   | \n+  ::: $DIR/auxiliary/no_method_suggested_traits.rs:8:12\n+   |\n+LL |         fn method(&self) {}\n+   |            ------\n+   |            |\n+   |            the method is available for `std::boxed::Box<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n+   |            the method is available for `std::pin::Pin<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n+   |            the method is available for `std::sync::Arc<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n+   |            the method is available for `std::rc::Rc<std::rc::Rc<&mut std::boxed::Box<&i32>>>` here\n    |\n    = help: items from traits can only be used if the trait is in scope\n help: the following trait is implemented but not in scope; perhaps add a `use` for it:"}, {"sha": "0cdc501d56811fcc8ad48f9f9f31f03fce4ded41", "filename": "src/test/ui/issues/issue-2823.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -6,6 +6,14 @@ LL | struct C {\n ...\n LL |     let _d = c.clone();\n    |                ^^^^^ method not found in `C`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<C>` here\n+   |        the method is available for `std::rc::Rc<C>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "d9d61fe66f78e4f16ab253b6ad8955f855437a05", "filename": "src/test/ui/issues/issue-69725.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69725.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -8,6 +8,14 @@ LL |     let _ = Struct::<A>::new().clone();\n    |\n LL | pub struct Struct<A>(A);\n    | ------------------------ doesn't satisfy `issue_69725::Struct<A>: std::clone::Clone`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<issue_69725::Struct<A>>` here\n+   |        the method is available for `std::rc::Rc<issue_69725::Struct<A>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `A: std::clone::Clone`"}, {"sha": "78d212f7a7ba7789e0c69b4b198c23e04949ef30", "filename": "src/test/ui/non-copyable-void.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fnon-copyable-void.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fnon-copyable-void.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-copyable-void.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -3,6 +3,14 @@ error[E0599]: no method named `clone` found for enum `libc::c_void` in the curre\n    |\n LL |         let _z = (*y).clone();\n    |                       ^^^^^ method not found in `libc::c_void`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<libc::c_void>` here\n+   |        the method is available for `std::rc::Rc<libc::c_void>` here\n \n error: aborting due to previous error\n "}, {"sha": "994eb65ae15bf7d0bc17ad35aac1b9c099db3aee", "filename": "src/test/ui/noncopyable-class.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -6,6 +6,14 @@ LL | struct Foo {\n ...\n LL |     let _y = x.clone();\n    |                ^^^^^ method not found in `Foo`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<Foo>` here\n+   |        the method is available for `std::rc::Rc<Foo>` here\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:"}, {"sha": "5bf491144ae4547df2042426aad461298f281379", "filename": "src/test/ui/pattern/usefulness/match-arm-statics-2.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-arm-statics-2.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -11,6 +11,14 @@ error[E0004]: non-exhaustive patterns: `Some(Some(West))` not covered\n    |\n LL |     match Some(Some(North)) {\n    |           ^^^^^^^^^^^^^^^^^ pattern `Some(Some(West))` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ----\n+   |     |\n+   |     not covered\n+   |     not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "ce2ab34f87d69b871cbdcfb8b795f451725449a2", "filename": "src/test/ui/pattern/usefulness/match-privately-empty.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fmatch-privately-empty.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -3,6 +3,11 @@ error[E0004]: non-exhaustive patterns: `Some(Private { misc: true, .. })` not co\n    |\n LL |     match private::DATA {\n    |           ^^^^^^^^^^^^^ pattern `Some(Private { misc: true, .. })` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "f7c277258405201e51e0075be1b08a23552457f0", "filename": "src/test/ui/pattern/usefulness/non-exhaustive-match.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fnon-exhaustive-match.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -25,6 +25,11 @@ error[E0004]: non-exhaustive patterns: `Some(_)` not covered\n    |\n LL |     match Some(10) {\n    |           ^^^^^^^^ pattern `Some(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/option.rs:LL:COL\n+   |\n+LL |     Some(#[stable(feature = \"rust1\", since = \"1.0.0\")] T),\n+   |     ---- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "a91c4dd35e4677b1917982491acf2a4c9b2ecb97", "filename": "src/test/ui/recursion/recursive-types-are-not-uninhabited.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frecursion%2Frecursive-types-are-not-uninhabited.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -3,6 +3,11 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n    |\n LL |     let Ok(x) = res;\n    |         ^^^^^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "bd6e9d5950272dfe941c34b11ca83d5351101062", "filename": "src/test/ui/resolve/issue-3907-2.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907-2.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -3,8 +3,11 @@ error[E0038]: the trait `issue_3907::Foo` cannot be made into an object\n    |\n LL | fn bar(_x: Foo) {}\n    |            ^^^ the trait `issue_3907::Foo` cannot be made into an object\n+   | \n+  ::: $DIR/auxiliary/issue-3907.rs:2:8\n    |\n-   = note: the trait cannot be made into an object because associated function `bar` has no `self` parameter\n+LL |     fn bar();\n+   |        --- the trait cannot be made into an object because associated function `bar` has no `self` parameter\n \n error: aborting due to previous error\n "}, {"sha": "a214a652a387fcb4348daff59dbbeb9071499167", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -27,6 +27,13 @@ error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covere\n    |\n LL |     match x {}\n    |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   | \n+  ::: $DIR/auxiliary/uninhabited.rs:17:23\n+   |\n+LL |     #[non_exhaustive] Tuple(!),\n+   |                       ----- not covered\n+LL |     #[non_exhaustive] Struct { x: ! }\n+   |                       ------ not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "63564e9c3cc8c097b82f9532f14952829bd7c570", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -27,6 +27,13 @@ error[E0004]: non-exhaustive patterns: `Tuple(_)` and `Struct { .. }` not covere\n    |\n LL |     match x {}\n    |           ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   | \n+  ::: $DIR/auxiliary/uninhabited.rs:17:23\n+   |\n+LL |     #[non_exhaustive] Tuple(!),\n+   |                       ----- not covered\n+LL |     #[non_exhaustive] Struct { x: ! }\n+   |                       ------ not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n "}, {"sha": "e4396afb2dbf591bb25c58a9e2ffe79c9743886a", "filename": "src/test/ui/uninhabited/uninhabited-matches-feature-gated.stderr", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funinhabited%2Funinhabited-matches-feature-gated.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -3,6 +3,11 @@ error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n@@ -46,6 +51,11 @@ error[E0004]: non-exhaustive patterns: `Err(_)` not covered\n    |\n LL |     let _ = match x {\n    |                   ^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n \n@@ -54,6 +64,11 @@ error[E0005]: refutable pattern in local binding: `Err(_)` not covered\n    |\n LL |     let Ok(x) = x;\n    |         ^^^^^ pattern `Err(_)` not covered\n+   | \n+  ::: $SRC_DIR/libcore/result.rs:LL:COL\n+   |\n+LL |     Err(#[stable(feature = \"rust1\", since = \"1.0.0\")] E),\n+   |     --- not covered\n    |\n    = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n    = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html"}, {"sha": "66437611872dfe366f539e66e346e4b2b5d2afb3", "filename": "src/test/ui/union/union-derive-clone.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -21,6 +21,14 @@ LL | struct CloneNoCopy;\n ...\n LL |     let w = u.clone();\n    |               ^^^^^ method not found in `U5<CloneNoCopy>`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<U5<CloneNoCopy>>` here\n+   |        the method is available for `std::rc::Rc<U5<CloneNoCopy>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `CloneNoCopy: std::marker::Copy`"}, {"sha": "2e81e7cf8320011e744bce625109f99450f4642b", "filename": "src/test/ui/unique-object-noncopyable.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-object-noncopyable.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -14,6 +14,14 @@ LL |     let _z = y.clone();\n    |\n LL | pub struct Box<T: ?Sized>(Unique<T>);\n    | ------------------------------------- doesn't satisfy `std::boxed::Box<dyn Foo>: std::clone::Clone`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<std::boxed::Box<dyn Foo>>` here\n+   |        the method is available for `std::rc::Rc<std::boxed::Box<dyn Foo>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `dyn Foo: std::marker::Sized`"}, {"sha": "06c4b95baef565c73632127734f4a80d38482f38", "filename": "src/test/ui/unique-pinned-nocopy.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/96e2d03d4b527b3870bb8cc4fd6dd41e57be109d/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funique-pinned-nocopy.stderr?ref=96e2d03d4b527b3870bb8cc4fd6dd41e57be109d", "patch": "@@ -11,6 +11,14 @@ LL |     let _j = i.clone();\n    |\n LL | pub struct Box<T: ?Sized>(Unique<T>);\n    | ------------------------------------- doesn't satisfy `std::boxed::Box<R>: std::clone::Clone`\n+   | \n+  ::: $SRC_DIR/libcore/clone.rs:LL:COL\n+   |\n+LL |     fn clone(&self) -> Self;\n+   |        -----\n+   |        |\n+   |        the method is available for `std::sync::Arc<std::boxed::Box<R>>` here\n+   |        the method is available for `std::rc::Rc<std::boxed::Box<R>>` here\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n            `R: std::clone::Clone`"}]}