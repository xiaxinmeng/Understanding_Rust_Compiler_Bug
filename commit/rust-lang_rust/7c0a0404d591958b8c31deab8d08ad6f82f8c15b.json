{"sha": "7c0a0404d591958b8c31deab8d08ad6f82f8c15b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjMGEwNDA0ZDU5MTk1OGI4YzMxZGVhYjhkMDhhZDZmODJmOGMxNWI=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-13T23:37:18Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-23T18:40:18Z"}, "message": "Check closure freevar kinds against destination environment bounds (#3569)", "tree": {"sha": "b651f80ddf81a71995b46738060200f81f641f36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b651f80ddf81a71995b46738060200f81f641f36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c0a0404d591958b8c31deab8d08ad6f82f8c15b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c0a0404d591958b8c31deab8d08ad6f82f8c15b", "html_url": "https://github.com/rust-lang/rust/commit/7c0a0404d591958b8c31deab8d08ad6f82f8c15b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c0a0404d591958b8c31deab8d08ad6f82f8c15b/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4ccb2fa85124dc90667ac61f829c46f9a5c2dc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4ccb2fa85124dc90667ac61f829c46f9a5c2dc7", "html_url": "https://github.com/rust-lang/rust/commit/f4ccb2fa85124dc90667ac61f829c46f9a5c2dc7"}], "stats": {"total": 77, "additions": 56, "deletions": 21}, "files": [{"sha": "2e69e5efd8dda72f2c822c606b2a20c2af5a4f8a", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7c0a0404d591958b8c31deab8d08ad6f82f8c15b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c0a0404d591958b8c31deab8d08ad6f82f8c15b/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=7c0a0404d591958b8c31deab8d08ad6f82f8c15b", "patch": "@@ -81,8 +81,6 @@ pub fn check_crate(tcx: ty::ctxt,\n     tcx.sess.abort_if_errors();\n }\n \n-type check_fn = @fn(Context, @freevar_entry);\n-\n fn check_struct_safe_for_destructor(cx: Context,\n                                     span: span,\n                                     struct_did: def_id) {\n@@ -163,30 +161,43 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n // Yields the appropriate function to check the kind of closed over\n // variables. `id` is the node_id for some expression that creates the\n // closure.\n-fn with_appropriate_checker(cx: Context, id: node_id, b: &fn(check_fn)) {\n-    fn check_for_uniq(cx: Context, fv: @freevar_entry) {\n+fn with_appropriate_checker(cx: Context, id: node_id,\n+                            b: &fn(checker: &fn(Context, @freevar_entry))) {\n+    fn check_for_uniq(cx: Context, fv: @freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned, regardless of whether it is\n         // moved in or copied in.\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n+\n+        // FIXME(#3569): Once closure capabilities are restricted based on their\n+        // incoming bounds, make this check conditional based on the bounds.\n         if !check_owned(cx, var_t, fv.span) { return; }\n \n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n+\n+        check_freevar_bounds(cx, fv.span, var_t, bounds);\n     }\n \n-    fn check_for_box(cx: Context, fv: @freevar_entry) {\n+    fn check_for_box(cx: Context, fv: @freevar_entry, bounds: ty::BuiltinBounds) {\n         // all captured data must be owned\n         let id = ast_util::def_id_of_def(fv.def).node;\n         let var_t = ty::node_id_to_type(cx.tcx, id);\n+\n+        // FIXME(#3569): Once closure capabilities are restricted based on their\n+        // incoming bounds, make this check conditional based on the bounds.\n         if !check_durable(cx.tcx, var_t, fv.span) { return; }\n \n         // check that only immutable variables are implicitly copied in\n         check_imm_free_var(cx, fv.def, fv.span);\n+\n+        check_freevar_bounds(cx, fv.span, var_t, bounds);\n     }\n \n-    fn check_for_block(_cx: Context, _fv: @freevar_entry) {\n-        // no restrictions\n+    fn check_for_block(cx: Context, fv: @freevar_entry, bounds: ty::BuiltinBounds) {\n+        let id = ast_util::def_id_of_def(fv.def).node;\n+        let var_t = ty::node_id_to_type(cx.tcx, id);\n+        check_freevar_bounds(cx, fv.span, var_t, bounds);\n     }\n \n     fn check_for_bare(cx: Context, fv: @freevar_entry) {\n@@ -197,14 +208,14 @@ fn with_appropriate_checker(cx: Context, id: node_id, b: &fn(check_fn)) {\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n     match ty::get(fty).sty {\n-        ty::ty_closure(ty::ClosureTy {sigil: OwnedSigil, _}) => {\n-            b(check_for_uniq)\n+        ty::ty_closure(ty::ClosureTy {sigil: OwnedSigil, bounds: bounds, _}) => {\n+            b(|cx, fv| check_for_uniq(cx, fv, bounds))\n         }\n-        ty::ty_closure(ty::ClosureTy {sigil: ManagedSigil, _}) => {\n-            b(check_for_box)\n+        ty::ty_closure(ty::ClosureTy {sigil: ManagedSigil, bounds: bounds, _}) => {\n+            b(|cx, fv| check_for_box(cx, fv, bounds))\n         }\n-        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, _}) => {\n-            b(check_for_block)\n+        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, bounds: bounds, _}) => {\n+            b(|cx, fv| check_for_block(cx, fv, bounds))\n         }\n         ty::ty_bare_fn(_) => {\n             b(check_for_bare)\n@@ -272,7 +283,7 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n                       type_param_defs.repr(cx.tcx));\n             }\n             for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n-                check_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n+                check_typaram_bounds(cx, type_parameter_id, e.span, ty, type_param_def)\n             }\n         }\n     }\n@@ -315,7 +326,7 @@ fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n               let type_param_defs =\n                   ty::lookup_item_type(cx.tcx, did).generics.type_param_defs;\n               for ts.iter().zip(type_param_defs.iter()).advance |(&ty, type_param_def)| {\n-                  check_bounds(cx, aty.id, aty.span, ty, type_param_def)\n+                  check_typaram_bounds(cx, aty.id, aty.span, ty, type_param_def)\n               }\n           }\n       }\n@@ -324,19 +335,26 @@ fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n     visit::visit_ty(aty, (cx, v));\n }\n \n-pub fn check_bounds(cx: Context,\n-                    _type_parameter_id: node_id,\n-                    sp: span,\n-                    ty: ty::t,\n-                    type_param_def: &ty::TypeParameterDef)\n+pub fn check_builtin_bounds(cx: Context, ty: ty::t, bounds: ty::BuiltinBounds)\n+                           -> ty::BuiltinBounds // returns the missing bounds\n {\n     let kind = ty::type_contents(cx.tcx, ty);\n     let mut missing = ty::EmptyBuiltinBounds();\n-    for type_param_def.bounds.builtin_bounds.each |bound| {\n+    for bounds.each |bound| {\n         if !kind.meets_bound(cx.tcx, bound) {\n             missing.add(bound);\n         }\n     }\n+    missing\n+}\n+\n+pub fn check_typaram_bounds(cx: Context,\n+                    _type_parameter_id: node_id,\n+                    sp: span,\n+                    ty: ty::t,\n+                    type_param_def: &ty::TypeParameterDef)\n+{\n+    let missing = check_builtin_bounds(cx, ty, type_param_def.bounds.builtin_bounds);\n     if !missing.is_empty() {\n         cx.tcx.sess.span_err(\n             sp,\n@@ -347,6 +365,23 @@ pub fn check_bounds(cx: Context,\n     }\n }\n \n+pub fn check_freevar_bounds(cx: Context, sp: span, ty: ty::t,\n+                            bounds: ty::BuiltinBounds)\n+{\n+    let missing = check_builtin_bounds(cx, ty, bounds);\n+    if !missing.is_empty() {\n+        cx.tcx.sess.span_err(\n+            sp,\n+            fmt!(\"cannot capture variable of type `%s`, which does not fulfill \\\n+                  `%s`, in a bounded closure\",\n+                 ty_to_str(cx.tcx, ty), missing.user_string(cx.tcx)));\n+        cx.tcx.sess.span_note(\n+            sp,\n+            fmt!(\"this closure's environment must satisfy `%s`\",\n+                 bounds.user_string(cx.tcx)));\n+    }\n+}\n+\n fn is_nullary_variant(cx: Context, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {"}]}