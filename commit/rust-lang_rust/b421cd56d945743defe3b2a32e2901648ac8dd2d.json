{"sha": "b421cd56d945743defe3b2a32e2901648ac8dd2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0MjFjZDU2ZDk0NTc0M2RlZmUzYjJhMzJlMjkwMTY0OGFjOGRkMmQ=", "commit": {"author": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2020-12-04T04:40:09Z"}, "committer": {"name": "Aman Arora", "email": "me@aman-arora.com", "date": "2021-01-29T20:37:05Z"}, "message": "Restrict precision of captures with `capture_disjoint_fields` set\n\n- No Derefs in move closure, this will result in value behind a reference getting moved.\n- No projections are applied to raw pointers, since these require unsafe blocks. We capture\n  them completely.\n\nMotivations for these are recorded here: https://hackmd.io/71qq-IOpTNqzMkPpAI1dVg?view", "tree": {"sha": "96e46ae4f07c9464f476aa5bd97bada13278ac06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96e46ae4f07c9464f476aa5bd97bada13278ac06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b421cd56d945743defe3b2a32e2901648ac8dd2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b421cd56d945743defe3b2a32e2901648ac8dd2d", "html_url": "https://github.com/rust-lang/rust/commit/b421cd56d945743defe3b2a32e2901648ac8dd2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b421cd56d945743defe3b2a32e2901648ac8dd2d/comments", "author": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arora-aman", "id": 4193035, "node_id": "MDQ6VXNlcjQxOTMwMzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4193035?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arora-aman", "html_url": "https://github.com/arora-aman", "followers_url": "https://api.github.com/users/arora-aman/followers", "following_url": "https://api.github.com/users/arora-aman/following{/other_user}", "gists_url": "https://api.github.com/users/arora-aman/gists{/gist_id}", "starred_url": "https://api.github.com/users/arora-aman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arora-aman/subscriptions", "organizations_url": "https://api.github.com/users/arora-aman/orgs", "repos_url": "https://api.github.com/users/arora-aman/repos", "events_url": "https://api.github.com/users/arora-aman/events{/privacy}", "received_events_url": "https://api.github.com/users/arora-aman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b122908617436af187252572ed5db96850551380", "url": "https://api.github.com/repos/rust-lang/rust/commits/b122908617436af187252572ed5db96850551380", "html_url": "https://github.com/rust-lang/rust/commit/b122908617436af187252572ed5db96850551380"}], "stats": {"total": 70, "additions": 61, "deletions": 9}, "files": [{"sha": "2252493577ff6e5b152ed50e963b021df36c7036", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b421cd56d945743defe3b2a32e2901648ac8dd2d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b421cd56d945743defe3b2a32e2901648ac8dd2d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=b421cd56d945743defe3b2a32e2901648ac8dd2d", "patch": "@@ -419,15 +419,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            // Arrays are captured in entirety, drop Index projections and projections\n-            // after Index projections.\n-            let first_index_projection =\n-                place.projections.split(|proj| ProjectionKind::Index == proj.kind).next();\n-            let place = Place {\n-                base_ty: place.base_ty,\n-                base: place.base,\n-                projections: first_index_projection.map_or(Vec::new(), |p| p.to_vec()),\n-            };\n+            let place = restrict_capture_precision(place, capture_info.capture_kind);\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n@@ -960,6 +952,66 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n     }\n }\n \n+/// Truncate projections so that following rules are obeyed by the captured `place`:\n+///\n+/// - No Derefs in move closure, this will result in value behind a reference getting moved.\n+/// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n+///   them completely.\n+/// - No Index projections are captured, since arrays are captured completely.\n+fn restrict_capture_precision<'tcx>(\n+    mut place: Place<'tcx>,\n+    capture_kind: ty::UpvarCapture<'tcx>,\n+) -> Place<'tcx> {\n+    if place.projections.is_empty() {\n+        // Nothing to do here\n+        return place;\n+    }\n+\n+    if place.base_ty.is_unsafe_ptr() {\n+        place.projections.truncate(0);\n+        return place;\n+    }\n+\n+    let mut truncated_length = usize::MAX;\n+    let mut first_deref_projection = usize::MAX;\n+\n+    for (i, proj) in place.projections.iter().enumerate() {\n+        if proj.ty.is_unsafe_ptr() {\n+            // Don't apply any projections on top of an unsafe ptr\n+            truncated_length = truncated_length.min(i + 1);\n+            break;\n+        }\n+        match proj.kind {\n+            ProjectionKind::Index => {\n+                // Arrays are completely captured, so we drop Index projections\n+                truncated_length = truncated_length.min(i);\n+                break;\n+            }\n+            ProjectionKind::Deref => {\n+                // We only drop Derefs in case of move closures\n+                // There might be an index projection or raw ptr ahead, so we don't stop here.\n+                first_deref_projection = first_deref_projection.min(i);\n+            }\n+            ProjectionKind::Field(..) => {} // ignore\n+            ProjectionKind::Subslice => {}  // We never capture this\n+        }\n+    }\n+\n+    let length = place\n+        .projections\n+        .len()\n+        .min(truncated_length)\n+        // In case of capture `ByValue` we want to not capture derefs\n+        .min(match capture_kind {\n+            ty::UpvarCapture::ByValue(..) => first_deref_projection,\n+            ty::UpvarCapture::ByRef(..) => usize::MAX,\n+        });\n+\n+    place.projections.truncate(length);\n+\n+    place\n+}\n+\n fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let variable_name = match place.base {\n         PlaceBase::Upvar(upvar_id) => var_name(tcx, upvar_id.var_path.hir_id).to_string(),"}]}