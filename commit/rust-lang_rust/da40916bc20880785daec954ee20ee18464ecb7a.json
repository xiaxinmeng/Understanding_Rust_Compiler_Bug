{"sha": "da40916bc20880785daec954ee20ee18464ecb7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNDA5MTZiYzIwODgwNzg1ZGFlYzk1NGVlMjBlZTE4NDY0ZWNiN2E=", "commit": {"author": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-17T09:13:44Z"}, "committer": {"name": "ljedrz", "email": "ljedrz@gmail.com", "date": "2018-10-17T17:57:02Z"}, "message": "resolve: improve common patterns", "tree": {"sha": "8a53d82bce1c0e1fbacde56e5bb381c1572c1ebd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a53d82bce1c0e1fbacde56e5bb381c1572c1ebd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da40916bc20880785daec954ee20ee18464ecb7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da40916bc20880785daec954ee20ee18464ecb7a", "html_url": "https://github.com/rust-lang/rust/commit/da40916bc20880785daec954ee20ee18464ecb7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da40916bc20880785daec954ee20ee18464ecb7a/comments", "author": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ljedrz", "id": 3750347, "node_id": "MDQ6VXNlcjM3NTAzNDc=", "avatar_url": "https://avatars.githubusercontent.com/u/3750347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ljedrz", "html_url": "https://github.com/ljedrz", "followers_url": "https://api.github.com/users/ljedrz/followers", "following_url": "https://api.github.com/users/ljedrz/following{/other_user}", "gists_url": "https://api.github.com/users/ljedrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/ljedrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ljedrz/subscriptions", "organizations_url": "https://api.github.com/users/ljedrz/orgs", "repos_url": "https://api.github.com/users/ljedrz/repos", "events_url": "https://api.github.com/users/ljedrz/events{/privacy}", "received_events_url": "https://api.github.com/users/ljedrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37ba1071c626c43a5b85752b4ffcf6a87e2b745e", "url": "https://api.github.com/repos/rust-lang/rust/commits/37ba1071c626c43a5b85752b4ffcf6a87e2b745e", "html_url": "https://github.com/rust-lang/rust/commit/37ba1071c626c43a5b85752b4ffcf6a87e2b745e"}], "stats": {"total": 232, "additions": 108, "deletions": 124}, "files": [{"sha": "e2f5829d14ff7ae3cab5698fdd7d8ede62a745b3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da40916bc20880785daec954ee20ee18464ecb7a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da40916bc20880785daec954ee20ee18464ecb7a/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=da40916bc20880785daec954ee20ee18464ecb7a", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         let prefix_iter = || parent_prefix.iter().cloned()\n             .chain(use_tree.prefix.segments.iter().map(|seg| seg.ident));\n-        let prefix_start = prefix_iter().nth(0);\n+        let prefix_start = prefix_iter().next();\n         let starts_with_non_keyword = prefix_start.map_or(false, |ident| {\n             !ident.is_path_segment_keyword()\n         });\n@@ -1048,13 +1048,10 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n \n     fn visit_token(&mut self, t: Token) {\n         if let Token::Interpolated(nt) = t {\n-            match nt.0 {\n-                token::NtExpr(ref expr) => {\n-                    if let ast::ExprKind::Mac(..) = expr.node {\n-                        self.visit_invoc(expr.id);\n-                    }\n+            if let token::NtExpr(ref expr) = nt.0 {\n+                if let ast::ExprKind::Mac(..) = expr.node {\n+                    self.visit_invoc(expr.id);\n                 }\n-                _ => {}\n             }\n         }\n     }"}, {"sha": "6f3135b37cf05746dd3e9d5b903d3972f1a10ae7", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da40916bc20880785daec954ee20ee18464ecb7a/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da40916bc20880785daec954ee20ee18464ecb7a/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=da40916bc20880785daec954ee20ee18464ecb7a", "patch": "@@ -109,7 +109,7 @@ impl<'a, 'b, 'cl> Visitor<'a> for UnusedImportCheckVisitor<'a, 'b, 'cl> {\n                 self.item_span\n             };\n \n-            if items.len() == 0 {\n+            if items.is_empty() {\n                 self.unused_imports\n                     .entry(self.base_id)\n                     .or_default()\n@@ -170,7 +170,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n \n     for (id, spans) in &visitor.unused_imports {\n         let len = spans.len();\n-        let mut spans = spans.values().map(|s| *s).collect::<Vec<Span>>();\n+        let mut spans = spans.values().cloned().collect::<Vec<Span>>();\n         spans.sort();\n         let ms = MultiSpan::from_spans(spans.clone());\n         let mut span_snippets = spans.iter()\n@@ -183,7 +183,7 @@ pub fn check_crate(resolver: &mut Resolver, krate: &ast::Crate) {\n         span_snippets.sort();\n         let msg = format!(\"unused import{}{}\",\n                           if len > 1 { \"s\" } else { \"\" },\n-                          if span_snippets.len() > 0 {\n+                          if !span_snippets.is_empty() {\n                               format!(\": {}\", span_snippets.join(\", \"))\n                           } else {\n                               String::new()"}, {"sha": "5f821cc71c95769ecf0dd104ac162010f8e90fdb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 35, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/da40916bc20880785daec954ee20ee18464ecb7a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da40916bc20880785daec954ee20ee18464ecb7a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=da40916bc20880785daec954ee20ee18464ecb7a", "patch": "@@ -1633,19 +1633,17 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                 *def = module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 *def = path_res.base_def(),\n-            PathResult::NonModule(..) => match self.resolve_path(\n-                None,\n-                &path,\n-                None,\n-                true,\n-                span,\n-                CrateLint::No,\n-            ) {\n-                PathResult::Failed(span, msg, _) => {\n+            PathResult::NonModule(..) =>\n+                if let PathResult::Failed(span, msg, _) = self.resolve_path(\n+                    None,\n+                    &path,\n+                    None,\n+                    true,\n+                    span,\n+                    CrateLint::No,\n+                ) {\n                     error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n-                _ => {}\n-            },\n+                },\n             PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n             PathResult::Indeterminate => unreachable!(),\n             PathResult::Failed(span, msg, _) => {\n@@ -2351,7 +2349,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     span: prefix.span.to(use_tree.prefix.span),\n                 };\n \n-                if items.len() == 0 {\n+                if items.is_empty() {\n                     // Resolve prefix of an import with empty braces (issue #28388).\n                     self.smart_resolve_path_with_crate_lint(\n                         id,\n@@ -2690,7 +2688,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n                 let map_j = self.binding_mode_map(&q);\n                 for (&key, &binding_i) in &map_i {\n-                    if map_j.len() == 0 {                   // Account for missing bindings when\n+                    if map_j.is_empty() {                   // Account for missing bindings when\n                         let binding_error = missing_vars    // map_j has none.\n                             .entry(key.name)\n                             .or_insert(BindingError {\n@@ -2751,9 +2749,8 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         // This has to happen *after* we determine which pat_idents are variants\n         self.check_consistent_bindings(&arm.pats);\n \n-        match arm.guard {\n-            Some(ast::Guard::If(ref expr)) => self.visit_expr(expr),\n-            _ => {}\n+        if let Some(ast::Guard::If(ref expr)) = arm.guard {\n+            self.visit_expr(expr)\n         }\n         self.visit_expr(&arm.body);\n \n@@ -2994,14 +2991,14 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             // Make the base error.\n             let expected = source.descr_expected();\n             let path_str = names_to_string(path);\n-            let item_str = path[path.len() - 1];\n+            let item_str = path.last().unwrap();\n             let code = source.error_code(def.is_some());\n             let (base_msg, fallback_label, base_span) = if let Some(def) = def {\n                 (format!(\"expected {}, found {} `{}`\", expected, def.kind_name(), path_str),\n                  format!(\"not a {}\", expected),\n                  span)\n             } else {\n-                let item_span = path[path.len() - 1].span;\n+                let item_span = path.last().unwrap().span;\n                 let (mod_prefix, mod_str) = if path.len() == 1 {\n                     (String::new(), \"this scope\".to_string())\n                 } else if path.len() == 2 && path[0].name == keywords::CrateRoot.name() {\n@@ -3368,7 +3365,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                             );\n                         }\n                         break;\n-                    } else if snippet.trim().len() != 0  {\n+                    } else if !snippet.trim().is_empty() {\n                         debug!(\"tried to find type ascription `:` token, couldn't find it\");\n                         break;\n                     }\n@@ -3930,7 +3927,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n             _ => {}\n         }\n-        return def;\n+        def\n     }\n \n     fn lookup_assoc_candidate<FilterFn>(&mut self,\n@@ -4482,21 +4479,17 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             let extern_prelude_names = self.extern_prelude.clone();\n             for &name in extern_prelude_names.iter() {\n                 let ident = Ident::with_empty_ctxt(name);\n-                match self.crate_loader.maybe_process_path_extern(name, ident.span) {\n-                    Some(crate_id) => {\n-                        let crate_root = self.get_module(DefId {\n-                            krate: crate_id,\n-                            index: CRATE_DEF_INDEX,\n-                        });\n-                        self.populate_module_if_necessary(&crate_root);\n+                if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(name,\n+                                                                                    ident.span)\n+                {\n+                    let crate_root = self.get_module(DefId {\n+                        krate: crate_id,\n+                        index: CRATE_DEF_INDEX,\n+                    });\n+                    self.populate_module_if_necessary(&crate_root);\n \n-                        suggestions.extend(\n-                            self.lookup_import_candidates_from_module(\n-                                lookup_name, namespace, crate_root, ident, &filter_fn\n-                            )\n-                        );\n-                    }\n-                    None => {}\n+                    suggestions.extend(self.lookup_import_candidates_from_module(\n+                        lookup_name, namespace, crate_root, ident, &filter_fn));\n                 }\n             }\n         }"}, {"sha": "d5d772e13591475cb6293b496241755a697cb073", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 73, "deletions": 79, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/da40916bc20880785daec954ee20ee18464ecb7a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da40916bc20880785daec954ee20ee18464ecb7a/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=da40916bc20880785daec954ee20ee18464ecb7a", "patch": "@@ -672,7 +672,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 };\n \n                 let has_explicit_self =\n-                    import.module_path.len() > 0 &&\n+                    !import.module_path.is_empty() &&\n                     import.module_path[0].name == keywords::SelfValue.name();\n \n                 self.per_ns(|_, ns| {\n@@ -703,9 +703,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 if let SingleImport { source, ref result, .. } = import.subclass {\n                     if source.name == \"self\" {\n                         // Silence `unresolved import` error if E0429 is already emitted\n-                        match result.value_ns.get() {\n-                            Err(Determined) => continue,\n-                            _ => {},\n+                        if let Err(Determined) = result.value_ns.get() {\n+                            continue;\n                         }\n                     }\n                 }\n@@ -822,20 +821,19 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn throw_unresolved_import_error(&self, error_vec: Vec<(Span, String, String)>,\n                                      span: Option<MultiSpan>) {\n         let max_span_label_msg_count = 10;  // upper limit on number of span_label message.\n-        let (span,msg) = match error_vec.is_empty() {\n-            true => (span.unwrap(), \"unresolved import\".to_string()),\n-            false => {\n-                let span = MultiSpan::from_spans(error_vec.clone().into_iter()\n-                                    .map(|elem: (Span, String, String)| { elem.0 }\n-                                    ).collect());\n-                let path_vec: Vec<String> = error_vec.clone().into_iter()\n-                                .map(|elem: (Span, String, String)| { format!(\"`{}`\", elem.1) }\n-                                ).collect();\n-                let path = path_vec.join(\", \");\n-                let msg = format!(\"unresolved import{} {}\",\n-                                if path_vec.len() > 1 { \"s\" } else { \"\" },  path);\n-                (span, msg)\n-            }\n+        let (span, msg) = if error_vec.is_empty() {\n+            (span.unwrap(), \"unresolved import\".to_string())\n+        } else {\n+            let span = MultiSpan::from_spans(error_vec.clone().into_iter()\n+                .map(|elem: (Span, String, String)| { elem.0 })\n+                .collect());\n+            let path_vec: Vec<String> = error_vec.clone().into_iter()\n+                .map(|elem: (Span, String, String)| { format!(\"`{}`\", elem.1) })\n+                .collect();\n+            let path = path_vec.join(\", \");\n+            let msg = format!(\"unresolved import{} {}\",\n+                if path_vec.len() > 1 { \"s\" } else { \"\" }, path);\n+            (span, msg)\n         };\n         let mut err = struct_span_err!(self.resolver.session, span, E0432, \"{}\", &msg);\n         for span_error in error_vec.into_iter().take(max_span_label_msg_count) {\n@@ -1026,9 +1024,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         if all_ns_err {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-                match this.resolve_ident_in_module(module, ident, ns, record_used, span) {\n-                    Ok(_) => all_ns_failed = false,\n-                    _ => {}\n+                if this.resolve_ident_in_module(module, ident, ns, record_used, span).is_ok() {\n+                    all_ns_failed = false;\n                 }\n             });\n \n@@ -1247,65 +1244,62 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 }\n             }\n \n-            match binding.kind {\n-                NameBindingKind::Import { binding: orig_binding, directive, .. } => {\n-                    if ns == TypeNS && orig_binding.is_variant() &&\n-                        !orig_binding.vis.is_at_least(binding.vis, &*self) {\n-                            let msg = match directive.subclass {\n-                                ImportDirectiveSubclass::SingleImport { .. } => {\n-                                    format!(\"variant `{}` is private and cannot be re-exported\",\n-                                            ident)\n-                                },\n-                                ImportDirectiveSubclass::GlobImport { .. } => {\n-                                    let msg = \"enum is private and its variants \\\n-                                               cannot be re-exported\".to_owned();\n-                                    let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n-                                                    Some(binding.span),\n-                                                    msg.clone());\n-                                    let fresh = self.session.one_time_diagnostics\n-                                        .borrow_mut().insert(error_id);\n-                                    if !fresh {\n-                                        continue;\n-                                    }\n-                                    msg\n-                                },\n-                                ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n-                            };\n-                            let mut err = self.session.struct_span_err(binding.span, &msg);\n-\n-                            let imported_module = match directive.imported_module.get() {\n-                                Some(ModuleOrUniformRoot::Module(module)) => module,\n-                                _ => bug!(\"module should exist\"),\n-                            };\n-                            let resolutions = imported_module.parent.expect(\"parent should exist\")\n-                                .resolutions.borrow();\n-                            let enum_path_segment_index = directive.module_path.len() - 1;\n-                            let enum_ident = directive.module_path[enum_path_segment_index];\n-\n-                            let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n-                                .expect(\"resolution should exist\");\n-                            let enum_span = enum_resolution.borrow()\n-                                .binding.expect(\"binding should exist\")\n-                                .span;\n-                            let enum_def_span = self.session.source_map().def_span(enum_span);\n-                            let enum_def_snippet = self.session.source_map()\n-                                .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n-                            // potentially need to strip extant `crate`/`pub(path)` for suggestion\n-                            let after_vis_index = enum_def_snippet.find(\"enum\")\n-                                .expect(\"`enum` keyword should exist in snippet\");\n-                            let suggestion = format!(\"pub {}\",\n-                                                     &enum_def_snippet[after_vis_index..]);\n-\n-                            self.session\n-                                .diag_span_suggestion_once(&mut err,\n-                                                           DiagnosticMessageId::ErrorId(0),\n-                                                           enum_def_span,\n-                                                           \"consider making the enum public\",\n-                                                           suggestion);\n-                            err.emit();\n-                    }\n+            if let NameBindingKind::Import { binding: orig_binding, directive, .. } = binding.kind {\n+                if ns == TypeNS && orig_binding.is_variant() &&\n+                    !orig_binding.vis.is_at_least(binding.vis, &*self) {\n+                        let msg = match directive.subclass {\n+                            ImportDirectiveSubclass::SingleImport { .. } => {\n+                                format!(\"variant `{}` is private and cannot be re-exported\",\n+                                        ident)\n+                            },\n+                            ImportDirectiveSubclass::GlobImport { .. } => {\n+                                let msg = \"enum is private and its variants \\\n+                                           cannot be re-exported\".to_owned();\n+                                let error_id = (DiagnosticMessageId::ErrorId(0), // no code?!\n+                                                Some(binding.span),\n+                                                msg.clone());\n+                                let fresh = self.session.one_time_diagnostics\n+                                    .borrow_mut().insert(error_id);\n+                                if !fresh {\n+                                    continue;\n+                                }\n+                                msg\n+                            },\n+                            ref s @ _ => bug!(\"unexpected import subclass {:?}\", s)\n+                        };\n+                        let mut err = self.session.struct_span_err(binding.span, &msg);\n+\n+                        let imported_module = match directive.imported_module.get() {\n+                            Some(ModuleOrUniformRoot::Module(module)) => module,\n+                            _ => bug!(\"module should exist\"),\n+                        };\n+                        let resolutions = imported_module.parent.expect(\"parent should exist\")\n+                            .resolutions.borrow();\n+                        let enum_path_segment_index = directive.module_path.len() - 1;\n+                        let enum_ident = directive.module_path[enum_path_segment_index];\n+\n+                        let enum_resolution = resolutions.get(&(enum_ident, TypeNS))\n+                            .expect(\"resolution should exist\");\n+                        let enum_span = enum_resolution.borrow()\n+                            .binding.expect(\"binding should exist\")\n+                            .span;\n+                        let enum_def_span = self.session.source_map().def_span(enum_span);\n+                        let enum_def_snippet = self.session.source_map()\n+                            .span_to_snippet(enum_def_span).expect(\"snippet should exist\");\n+                        // potentially need to strip extant `crate`/`pub(path)` for suggestion\n+                        let after_vis_index = enum_def_snippet.find(\"enum\")\n+                            .expect(\"`enum` keyword should exist in snippet\");\n+                        let suggestion = format!(\"pub {}\",\n+                                                 &enum_def_snippet[after_vis_index..]);\n+\n+                        self.session\n+                            .diag_span_suggestion_once(&mut err,\n+                                                       DiagnosticMessageId::ErrorId(0),\n+                                                       enum_def_span,\n+                                                       \"consider making the enum public\",\n+                                                       suggestion);\n+                        err.emit();\n                 }\n-                _ => {}\n             }\n         }\n "}]}