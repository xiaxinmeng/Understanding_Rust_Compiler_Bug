{"sha": "0059188e77b4fa6f110785f7938dbfc35623fac8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNTkxODhlNzdiNGZhNmYxMTA3ODVmNzkzOGRiZmMzNTYyM2ZhYzg=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-22T11:51:08Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-10-22T12:48:24Z"}, "message": "algo::diff tests", "tree": {"sha": "63ae88da18b40d1a01c00f34fac5c7a2e05a4fd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63ae88da18b40d1a01c00f34fac5c7a2e05a4fd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0059188e77b4fa6f110785f7938dbfc35623fac8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0059188e77b4fa6f110785f7938dbfc35623fac8", "html_url": "https://github.com/rust-lang/rust/commit/0059188e77b4fa6f110785f7938dbfc35623fac8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0059188e77b4fa6f110785f7938dbfc35623fac8/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d86863aeb404b042a3ba1a60d5d961f392b8cb64", "url": "https://api.github.com/repos/rust-lang/rust/commits/d86863aeb404b042a3ba1a60d5d961f392b8cb64", "html_url": "https://github.com/rust-lang/rust/commit/d86863aeb404b042a3ba1a60d5d961f392b8cb64"}], "stats": {"total": 331, "additions": 327, "deletions": 4}, "files": [{"sha": "aa39ce554cff3c6f461a949e486554ebdb8efe2d", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0059188e77b4fa6f110785f7938dbfc35623fac8/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0059188e77b4fa6f110785f7938dbfc35623fac8/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=0059188e77b4fa6f110785f7938dbfc35623fac8", "patch": "@@ -27,10 +27,9 @@ serde = { version = \"1.0.106\", features = [\"derive\"] }\n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n text_edit = { path = \"../text_edit\", version = \"0.0.0\" }\n parser = { path = \"../parser\", version = \"0.0.0\" }\n+test_utils = { path = \"../test_utils\" }\n \n [dev-dependencies]\n walkdir = \"2.3.1\"\n rayon = \"1\"\n expect-test = \"1.0\"\n-\n-test_utils = { path = \"../test_utils\" }"}, {"sha": "4f9a7a6e89465454ed2e120483608a23c4bbc08c", "filename": "crates/syntax/src/algo.rs", "status": "modified", "additions": 326, "deletions": 2, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/0059188e77b4fa6f110785f7938dbfc35623fac8/crates%2Fsyntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0059188e77b4fa6f110785f7938dbfc35623fac8/crates%2Fsyntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Falgo.rs?ref=0059188e77b4fa6f110785f7938dbfc35623fac8", "patch": "@@ -9,6 +9,7 @@ use std::{\n use indexmap::IndexMap;\n use itertools::Itertools;\n use rustc_hash::FxHashMap;\n+use test_utils::mark;\n use text_edit::TextEditBuilder;\n \n use crate::{\n@@ -110,6 +111,7 @@ pub enum InsertPosition<T> {\n \n type FxIndexMap<K, V> = IndexMap<K, V, BuildHasherDefault<rustc_hash::FxHasher>>;\n \n+#[derive(Debug)]\n pub struct TreeDiff {\n     replacements: FxHashMap<SyntaxElement, SyntaxElement>,\n     deletions: Vec<SyntaxElement>,\n@@ -149,8 +151,7 @@ pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n     };\n     let (from, to) = (from.clone().into(), to.clone().into());\n \n-    // FIXME: this is both horrible inefficient and gives larger than\n-    // necessary diff. I bet there's a cool algorithm to diff trees properly.\n+    // FIXME: this is horrible inefficient. I bet there's a cool algorithm to diff trees properly.\n     if !syntax_element_eq(&from, &to) {\n         go(&mut diff, from, to);\n     }\n@@ -172,6 +173,7 @@ pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n         let (lhs, rhs) = match lhs.as_node().zip(rhs.as_node()) {\n             Some((lhs, rhs)) => (lhs, rhs),\n             _ => {\n+                mark::hit!(diff_node_token_replace);\n                 diff.replacements.insert(lhs, rhs);\n                 return;\n             }\n@@ -186,16 +188,19 @@ pub fn diff(from: &SyntaxNode, to: &SyntaxNode) -> TreeDiff {\n                 (None, None) => break,\n                 (None, Some(element)) => match last_lhs.clone() {\n                     Some(prev) => {\n+                        mark::hit!(diff_insert);\n                         diff.insertions.entry(prev).or_insert_with(Vec::new).push(element);\n                     }\n                     // first iteration, this means we got no anchor element to insert after\n                     // therefor replace the parent node instead\n                     None => {\n+                        mark::hit!(diff_replace_parent);\n                         diff.replacements.insert(lhs.clone().into(), rhs.clone().into());\n                         break;\n                     }\n                 },\n                 (Some(element), None) => {\n+                    mark::hit!(diff_delete);\n                     diff.deletions.push(element);\n                 }\n                 (Some(ref lhs_ele), Some(ref rhs_ele)) if syntax_element_eq(lhs_ele, rhs_ele) => {}\n@@ -445,3 +450,322 @@ fn to_green_element(element: SyntaxElement) -> NodeOrToken<rowan::GreenNode, row\n         NodeOrToken::Token(it) => it.green().clone().into(),\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use expect_test::{expect, Expect};\n+    use itertools::Itertools;\n+    use parser::SyntaxKind;\n+    use test_utils::mark;\n+    use text_edit::TextEdit;\n+\n+    use crate::{AstNode, SyntaxElement};\n+\n+    #[test]\n+    fn replace_node_token() {\n+        mark::check!(diff_node_token_replace);\n+        check_diff(\n+            r#\"use node;\"#,\n+            r#\"ident\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+\n+\n+                replacements:\n+\n+                Line 0: Token(USE_KW@0..3 \"use\") -> ident\n+\n+                deletions:\n+\n+                Line 1: \" \"\n+                Line 1: node\n+                Line 1: ;\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn insert() {\n+        mark::check!(diff_insert);\n+        check_diff(\n+            r#\"use foo;\"#,\n+            r#\"use foo;\n+use bar;\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+                Line 0: Node(USE@0..8)\n+                -> \"\\n\"\n+                -> use bar;\n+\n+                replacements:\n+\n+\n+\n+                deletions:\n+\n+\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn replace_parent() {\n+        mark::check!(diff_replace_parent);\n+        check_diff(\n+            r#\"\"#,\n+            r#\"use foo::bar;\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+\n+\n+                replacements:\n+\n+                Line 0: Node(SOURCE_FILE@0..0) -> use foo::bar;\n+\n+                deletions:\n+\n+\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn delete() {\n+        mark::check!(diff_delete);\n+        check_diff(\n+            r#\"use foo;\n+            use bar;\"#,\n+            r#\"use foo;\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+\n+\n+                replacements:\n+\n+\n+\n+                deletions:\n+\n+                Line 1: \"\\n            \"\n+                Line 2: use bar;\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn insert_use() {\n+        check_diff(\n+            r#\"\n+use expect_test::{expect, Expect};\n+\n+use crate::AstNode;\n+\"#,\n+            r#\"\n+use expect_test::{expect, Expect};\n+use text_edit::TextEdit;\n+\n+use crate::AstNode;\n+\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+                Line 4: Token(WHITESPACE@56..57 \"\\n\")\n+                -> use crate::AstNode;\n+                -> \"\\n\"\n+\n+                replacements:\n+\n+                Line 2: Token(WHITESPACE@35..37 \"\\n\\n\") -> \"\\n\"\n+                Line 4: Token(CRATE_KW@41..46 \"crate\") -> text_edit\n+                Line 4: Token(IDENT@48..55 \"AstNode\") -> TextEdit\n+                Line 4: Token(WHITESPACE@56..57 \"\\n\") -> \"\\n\\n\"\n+\n+                deletions:\n+\n+\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn remove_use() {\n+        check_diff(\n+            r#\"\n+use expect_test::{expect, Expect};\n+use text_edit::TextEdit;\n+\n+use crate::AstNode;\n+\"#,\n+            r#\"\n+use expect_test::{expect, Expect};\n+\n+use crate::AstNode;\n+\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+\n+\n+                replacements:\n+\n+                Line 2: Token(WHITESPACE@35..36 \"\\n\") -> \"\\n\\n\"\n+                Line 3: Node(NAME_REF@40..49) -> crate\n+                Line 3: Token(IDENT@51..59 \"TextEdit\") -> AstNode\n+                Line 3: Token(WHITESPACE@60..62 \"\\n\\n\") -> \"\\n\"\n+\n+                deletions:\n+\n+                Line 4: use crate::AstNode;\n+                Line 5: \"\\n\"\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn merge_use() {\n+        check_diff(\n+            r#\"\n+use std::{\n+    fmt,\n+    hash::BuildHasherDefault,\n+    ops::{self, RangeInclusive},\n+};\n+\"#,\n+            r#\"\n+use std::fmt;\n+use std::hash::BuildHasherDefault;\n+use std::ops::{self, RangeInclusive};\n+\"#,\n+            expect![[r#\"\n+                insertions:\n+\n+                Line 2: Node(PATH_SEGMENT@5..8)\n+                -> ::\n+                -> fmt\n+                Line 6: Token(WHITESPACE@86..87 \"\\n\")\n+                -> use std::hash::BuildHasherDefault;\n+                -> \"\\n\"\n+                -> use std::ops::{self, RangeInclusive};\n+                -> \"\\n\"\n+\n+                replacements:\n+\n+                Line 2: Token(IDENT@5..8 \"std\") -> std\n+\n+                deletions:\n+\n+                Line 2: ::\n+                Line 2: {\n+                    fmt,\n+                    hash::BuildHasherDefault,\n+                    ops::{self, RangeInclusive},\n+                }\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn early_return_assist() {\n+        check_diff(\n+            r#\"\n+fn main() {\n+    if let Ok(x) = Err(92) {\n+        foo(x);\n+    }\n+}\n+            \"#,\n+            r#\"\n+fn main() {\n+    let x = match Err(92) {\n+        Ok(it) => it,\n+        _ => return,\n+    };\n+    foo(x);\n+}\n+            \"#,\n+            expect![[r#\"\n+                insertions:\n+\n+                Line 3: Node(BLOCK_EXPR@40..63)\n+                -> \" \"\n+                -> match Err(92) {\n+                        Ok(it) => it,\n+                        _ => return,\n+                    }\n+                -> ;\n+                Line 5: Token(R_CURLY@64..65 \"}\")\n+                -> \"\\n\"\n+                -> }\n+\n+                replacements:\n+\n+                Line 3: Token(IF_KW@17..19 \"if\") -> let\n+                Line 3: Token(LET_KW@20..23 \"let\") -> x\n+                Line 3: Node(BLOCK_EXPR@40..63) -> =\n+                Line 5: Token(WHITESPACE@63..64 \"\\n\") -> \"\\n    \"\n+                Line 5: Token(R_CURLY@64..65 \"}\") -> foo(x);\n+\n+                deletions:\n+\n+                Line 3: \" \"\n+                Line 3: Ok(x)\n+                Line 3: \" \"\n+                Line 3: =\n+                Line 3: \" \"\n+                Line 3: Err(92)\n+            \"#]],\n+        )\n+    }\n+\n+    fn check_diff(from: &str, to: &str, expected_diff: Expect) {\n+        let from_node = crate::SourceFile::parse(from).tree().syntax().clone();\n+        let to_node = crate::SourceFile::parse(to).tree().syntax().clone();\n+        let diff = super::diff(&from_node, &to_node);\n+\n+        let line_number =\n+            |syn: &SyntaxElement| from[..syn.text_range().start().into()].lines().count();\n+\n+        let fmt_syntax = |syn: &SyntaxElement| match syn.kind() {\n+            SyntaxKind::WHITESPACE => format!(\"{:?}\", syn.to_string()),\n+            _ => format!(\"{}\", syn),\n+        };\n+\n+        let insertions = diff.insertions.iter().format_with(\"\\n\", |(k, v), f| {\n+            f(&format!(\n+                \"Line {}: {:?}\\n-> {}\",\n+                line_number(k),\n+                k,\n+                v.iter().format_with(\"\\n-> \", |v, f| f(&fmt_syntax(v)))\n+            ))\n+        });\n+\n+        let replacements = diff\n+            .replacements\n+            .iter()\n+            .sorted_by_key(|(syntax, _)| syntax.text_range().start())\n+            .format_with(\"\\n\", |(k, v), f| {\n+                f(&format!(\"Line {}: {:?} -> {}\", line_number(k), k, fmt_syntax(v)))\n+            });\n+\n+        let deletions = diff\n+            .deletions\n+            .iter()\n+            .format_with(\"\\n\", |v, f| f(&format!(\"Line {}: {}\", line_number(v), &fmt_syntax(v))));\n+\n+        let actual = format!(\n+            \"insertions:\\n\\n{}\\n\\nreplacements:\\n\\n{}\\n\\ndeletions:\\n\\n{}\\n\",\n+            insertions, replacements, deletions\n+        );\n+        expected_diff.assert_eq(&actual);\n+\n+        let mut from = from.to_owned();\n+        let mut text_edit = TextEdit::builder();\n+        diff.into_text_edit(&mut text_edit);\n+        text_edit.finish().apply(&mut from);\n+        assert_eq!(&*from, to, \"diff did not turn `from` to `to`\");\n+    }\n+}"}]}