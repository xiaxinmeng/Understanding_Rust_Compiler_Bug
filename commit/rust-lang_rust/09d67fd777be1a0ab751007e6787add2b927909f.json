{"sha": "09d67fd777be1a0ab751007e6787add2b927909f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZDY3ZmQ3NzdiZTFhMGFiNzUxMDA3ZTY3ODdhZGQyYjkyNzkwOWY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-09-16T13:24:56Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-11-25T14:26:16Z"}, "message": "Track what drop obligations are established on match arms.\n\nThis is accomplished by:\n\n1. Add `MatchMode` enum to `expr_use_visitor`.\n\n2. Computing the match mode for each pattern via a pre-pass, and then\n   passing the mode along when visiting the pattern in\n   expr_use_visitor.\n\n3. Adding a `fn matched_pat` callback to expr_use_visitor, which is\n   called on interior struct and enum nodes of the pattern (as opposed\n   to `fn consume_pat`, which is only invoked for identifiers at the\n   leaves of the pattern), and invoking it accordingly.\n\nOf particular interest are the `cat_downcast` instances established\nwhen matching enum variants.", "tree": {"sha": "bb15e5fb57338732c4f5b77fa344a81801018967", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb15e5fb57338732c4f5b77fa344a81801018967"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09d67fd777be1a0ab751007e6787add2b927909f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09d67fd777be1a0ab751007e6787add2b927909f", "html_url": "https://github.com/rust-lang/rust/commit/09d67fd777be1a0ab751007e6787add2b927909f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09d67fd777be1a0ab751007e6787add2b927909f/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f7cb8c6185878d6e4ad0cf354652158a73c0b72", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f7cb8c6185878d6e4ad0cf354652158a73c0b72", "html_url": "https://github.com/rust-lang/rust/commit/6f7cb8c6185878d6e4ad0cf354652158a73c0b72"}], "stats": {"total": 288, "additions": 278, "deletions": 10}, "files": [{"sha": "afcc533ffb81c90e1a502e694230a929c4546c22", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=09d67fd777be1a0ab751007e6787add2b927909f", "patch": "@@ -103,6 +103,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for CheckLoanCtxt<'a, 'tcx> {\n         self.consume_common(consume_id, consume_span, cmt, mode);\n     }\n \n+    fn matched_pat(&mut self,\n+                   _matched_pat: &ast::Pat,\n+                   _cmt: mc::cmt,\n+                   _mode: euv::MatchMode) { }\n+\n     fn consume_pat(&mut self,\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,"}, {"sha": "6950c117179883d0ae902c884534c48d753f666c", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=09d67fd777be1a0ab751007e6787add2b927909f", "patch": "@@ -88,6 +88,16 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn matched_pat(&mut self,\n+                   matched_pat: &ast::Pat,\n+                   cmt: mc::cmt<'tcx>,\n+                   mode: euv::MatchMode) {\n+        debug!(\"matched_pat(matched_pat={}, cmt={}, mode={})\",\n+               matched_pat.repr(self.tcx()),\n+               cmt.repr(self.tcx()),\n+               mode);\n+    }\n+\n     fn consume_pat(&mut self,\n                    consume_pat: &ast::Pat,\n                    cmt: mc::cmt<'tcx>,"}, {"sha": "806fea3b54fd5b7e65c6d56296424df0dd54f70b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=09d67fd777be1a0ab751007e6787add2b927909f", "patch": "@@ -18,6 +18,7 @@ use middle::def::*;\n use middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Init};\n use middle::expr_use_visitor::{JustWrite, LoanCause, MutateMode};\n use middle::expr_use_visitor::{WriteAndRead};\n+use middle::expr_use_visitor as euv;\n use middle::mem_categorization::cmt;\n use middle::pat_util::*;\n use middle::ty::*;\n@@ -1024,6 +1025,7 @@ struct MutationChecker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n+    fn matched_pat(&mut self, _: &Pat, _: cmt, _: euv::MatchMode) {}\n     fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n     fn borrow(&mut self,"}, {"sha": "dae76ba125e60f62ef32b77f5d792a16ebaa5dcf", "filename": "src/librustc/middle/check_rvalues.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_rvalues.rs?ref=09d67fd777be1a0ab751007e6787add2b927909f", "patch": "@@ -59,6 +59,11 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for RvalueContext<'a, 'tcx> {\n         }\n     }\n \n+    fn matched_pat(&mut self,\n+                   _matched_pat: &ast::Pat,\n+                   _cmt: mc::cmt,\n+                   _mode: euv::MatchMode) {}\n+\n     fn consume_pat(&mut self,\n                    _consume_pat: &ast::Pat,\n                    _cmt: mc::cmt,"}, {"sha": "d3c7ccf65dd722524af1e940cbf8a3768ab76cd8", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=09d67fd777be1a0ab751007e6787add2b927909f", "patch": "@@ -325,6 +325,12 @@ impl<'tcx> euv::Delegate<'tcx> for GlobalChecker {\n               _assignment_span: Span,\n               _assignee_cmt: mc::cmt,\n               _mode: euv::MutateMode) {}\n+\n+    fn matched_pat(&mut self,\n+                   _: &ast::Pat,\n+                   _: mc::cmt,\n+                   _: euv::MatchMode) {}\n+\n     fn consume_pat(&mut self,\n                    _consume_pat: &ast::Pat,\n                    _cmt: mc::cmt,"}, {"sha": "656feb51a1d3c9e5931ff37d2f38cd80cdb7ab41", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 249, "deletions": 10, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=09d67fd777be1a0ab751007e6787add2b927909f", "patch": "@@ -18,6 +18,8 @@ pub use self::MutateMode::*;\n pub use self::LoanCause::*;\n pub use self::ConsumeMode::*;\n pub use self::MoveReason::*;\n+pub use self::MatchMode::*;\n+use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n use middle::{def, region, pat_util};\n@@ -48,6 +50,23 @@ pub trait Delegate<'tcx> {\n                cmt: mc::cmt<'tcx>,\n                mode: ConsumeMode);\n \n+    // The value found at `cmt` has been determined to match the\n+    // pattern binding `matched_pat`, and its subparts are being\n+    // copied or moved depending on `mode`.  Note that `matched_pat`\n+    // is called on all variant/structs in the pattern (i.e., the\n+    // interior nodes of the pattern's tree structure) while\n+    // consume_pat is called on the binding identifiers in the pattern\n+    // (which are leaves of the pattern's tree structure).\n+    //\n+    // Note that variants/structs and identifiers are disjoint; thus\n+    // `matched_pat` and `consume_pat` are never both called on the\n+    // same input pattern structure (though of `consume_pat` can be\n+    // called on a subpart of an input passed to `matched_pat).\n+    fn matched_pat(&mut self,\n+                   matched_pat: &ast::Pat,\n+                   cmt: mc::cmt<'tcx>,\n+                   mode: MatchMode);\n+\n     // The value found at `cmt` is either copied or moved via the\n     // pattern binding `consume_pat`, depending on mode.\n     fn consume_pat(&mut self,\n@@ -103,6 +122,79 @@ pub enum MoveReason {\n     CaptureMove,\n }\n \n+#[deriving(PartialEq,Show)]\n+pub enum MatchMode {\n+    NonBindingMatch,\n+    BorrowingMatch,\n+    CopyingMatch,\n+    MovingMatch,\n+}\n+\n+#[deriving(PartialEq,Show)]\n+enum TrackMatchMode<T> {\n+    Unknown, Definite(MatchMode), Conflicting,\n+}\n+\n+impl<T> TrackMatchMode<T> {\n+    // Builds up the whole match mode for a pattern from its constituent\n+    // parts.  The lattice looks like this:\n+    //\n+    //          Conflicting\n+    //            /     \\\n+    //           /       \\\n+    //      Borrowing   Moving\n+    //           \\       /\n+    //            \\     /\n+    //            Copying\n+    //               |\n+    //          NonBinding\n+    //               |\n+    //            Unknown\n+    //\n+    // examples:\n+    //\n+    // * `(_, some_int)` pattern is Copying, since\n+    //   NonBinding + Copying => Copying\n+    //\n+    // * `(some_int, some_box)` pattern is Moving, since\n+    //   Copying + Moving => Moving\n+    //\n+    // * `(ref x, some_box)` pattern is Conflicting, since\n+    //   Borrowing + Moving => Conflicting\n+    //\n+    // Note that the `Unknown` and `Conflicting` states are\n+    // represented separately from the other more interesting\n+    // `Definite` states, which simplifies logic here somewhat.\n+    fn lub(&mut self, mode: MatchMode) {\n+        *self = match (*self, mode) {\n+            // Note that clause order below is very significant.\n+            (Unknown, new) => Definite(new),\n+            (Definite(old), new) if old == new => Definite(old),\n+\n+            (Definite(old), NonBindingMatch) => Definite(old),\n+            (Definite(NonBindingMatch), new) => Definite(new),\n+\n+            (Definite(old), CopyingMatch) => Definite(old),\n+            (Definite(CopyingMatch), new) => Definite(new),\n+\n+            (Definite(_), _) => Conflicting,\n+            (Conflicting, _) => *self,\n+        };\n+    }\n+\n+    fn match_mode(&self) -> MatchMode {\n+        match *self {\n+            Unknown => NonBindingMatch,\n+            Definite(mode) => mode,\n+            Conflicting => {\n+                // Conservatively return MovingMatch to let the\n+                // compiler continue to make progress.\n+                MovingMatch\n+            }\n+        }\n+    }\n+}\n+\n #[deriving(PartialEq,Show)]\n pub enum MutateMode {\n     Init,\n@@ -251,7 +343,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 ty::ReScope(fn_body_scope), // Args live only as long as the fn body.\n                 arg_ty);\n \n-            self.walk_pat(arg_cmt, &*arg.pat);\n+            self.walk_irrefutable_pat(arg_cmt, &*arg.pat);\n         }\n     }\n \n@@ -390,7 +482,9 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // treatment of the discriminant is handled while walking the arms.\n                 for arm in arms.iter() {\n-                    self.walk_arm(discr_cmt.clone(), arm);\n+                    let mode = self.arm_move_mode(discr_cmt.clone(), arm);\n+                    let mode = mode.match_mode();\n+                    self.walk_arm(discr_cmt.clone(), arm, mode);\n                 }\n             }\n \n@@ -448,7 +542,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                                  pat.span,\n                                                  ty::ReScope(blk_scope),\n                                                  pattern_type);\n-                self.walk_pat(pat_cmt, &**pat);\n+                self.walk_irrefutable_pat(pat_cmt, &**pat);\n \n                 self.walk_block(&**blk);\n             }\n@@ -617,7 +711,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 // `walk_pat`:\n                 self.walk_expr(&**expr);\n                 let init_cmt = return_if_err!(self.mc.cat_expr(&**expr));\n-                self.walk_pat(init_cmt, &*local.pat);\n+                self.walk_irrefutable_pat(init_cmt, &*local.pat);\n             }\n         }\n     }\n@@ -824,9 +918,17 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         return true;\n     }\n \n-    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) {\n+    fn arm_move_mode(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm) -> TrackMatchMode<Span> {\n+        let mut mode = Unknown;\n         for pat in arm.pats.iter() {\n-            self.walk_pat(discr_cmt.clone(), &**pat);\n+            self.determine_pat_move_mode(discr_cmt.clone(), &**pat, &mut mode);\n+        }\n+        mode\n+    }\n+\n+    fn walk_arm(&mut self, discr_cmt: mc::cmt<'tcx>, arm: &ast::Arm, mode: MatchMode) {\n+        for pat in arm.pats.iter() {\n+            self.walk_pat(discr_cmt.clone(), &**pat, mode);\n         }\n \n         for guard in arm.guard.iter() {\n@@ -836,21 +938,71 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         self.consume_expr(&*arm.body);\n     }\n \n-    fn walk_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &ast::Pat) {\n+    /// Walks an pat that occurs in isolation (i.e. top-level of fn\n+    /// arg or let binding.  *Not* a match arm or nested pat.)\n+    fn walk_irrefutable_pat(&mut self, cmt_discr: mc::cmt<'tcx>, pat: &ast::Pat) {\n+        let mut mode = Unknown;\n+        self.determine_pat_move_mode(cmt_discr.clone(), pat, &mut mode);\n+        let mode = mode.match_mode();\n+        self.walk_pat(cmt_discr, pat, mode);\n+    }\n+\n+    /// Identifies any bindings within `pat` and accumulates within\n+    /// `mode` whether the overall pattern/match structure is a move,\n+    /// copy, or borrow.\n+    fn determine_pat_move_mode(&mut self,\n+                               cmt_discr: mc::cmt<'tcx>,\n+                               pat: &ast::Pat,\n+                               mode: &mut TrackMatchMode<Span>) {\n+        debug!(\"determine_pat_move_mode cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n+               pat.repr(self.tcx()));\n+        return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |_mc, cmt_pat, pat| {\n+            let tcx = self.typer.tcx();\n+            let def_map = &self.typer.tcx().def_map;\n+            if pat_util::pat_is_binding(def_map, pat) {\n+                match pat.node {\n+                    ast::PatIdent(ast::BindByRef(_), _, _) =>\n+                        mode.lub(BorrowingMatch),\n+                    ast::PatIdent(ast::BindByValue(_), _, _) => {\n+                        match copy_or_move(tcx, cmt_pat.ty, PatBindingMove) {\n+                            Copy => mode.lub(CopyingMatch),\n+                            Move(_) => mode.lub(MovingMatch),\n+                        }\n+                    }\n+                    _ => {\n+                        tcx.sess.span_bug(\n+                            pat.span,\n+                            \"binding pattern not an identifier\");\n+                    }\n+                }\n+            }\n+        }));\n+    }\n+\n+    /// The core driver for walking a pattern; `match_mode` must be\n+    /// established up front, e.g. via `determine_pat_move_mode` (see\n+    /// also `walk_irrefutable_pat` for patterns that stand alone).\n+    fn walk_pat(&mut self,\n+                cmt_discr: mc::cmt<'tcx>,\n+                pat: &ast::Pat,\n+                match_mode: MatchMode) {\n         debug!(\"walk_pat cmt_discr={} pat={}\", cmt_discr.repr(self.tcx()),\n                pat.repr(self.tcx()));\n+\n         let mc = &self.mc;\n         let typer = self.typer;\n         let tcx = typer.tcx();\n         let def_map = &self.typer.tcx().def_map;\n         let delegate = &mut self.delegate;\n-        return_if_err!(mc.cat_pattern(cmt_discr, &*pat, |mc, cmt_pat, pat| {\n+\n+        return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n             if pat_util::pat_is_binding(def_map, pat) {\n                 let tcx = typer.tcx();\n \n-                debug!(\"binding cmt_pat={} pat={}\",\n+                debug!(\"binding cmt_pat={} pat={} match_mode={}\",\n                        cmt_pat.repr(tcx),\n-                       pat.repr(tcx));\n+                       pat.repr(tcx),\n+                       match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n                 let pat_ty = return_if_err!(typer.node_ty(pat.id));\n@@ -933,6 +1085,93 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 }\n             }\n         }));\n+\n+        // Do a second pass over the pattern, calling `matched_pat` on\n+        // the interior nodes (enum variants and structs), as opposed\n+        // to the above loop's visit of than the bindings that form\n+        // the leaves of the pattern tree structure.\n+        return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n+            let def_map = def_map.borrow();\n+            let tcx = typer.tcx();\n+\n+            match pat.node {\n+                ast::PatEnum(_, _) | ast::PatIdent(_, _, None) | ast::PatStruct(..) => {\n+                    match def_map.get(&pat.id) {\n+                        None => {\n+                            // no definition found: pat is not a\n+                            // struct or enum pattern.\n+                        }\n+\n+                        Some(&def::DefVariant(enum_did, variant_did, _is_struct)) => {\n+                            let downcast_cmt =\n+                                if ty::enum_is_univariant(tcx, enum_did) {\n+                                    cmt_pat\n+                                } else {\n+                                    let cmt_pat_ty = cmt_pat.ty;\n+                                    mc.cat_downcast(pat, cmt_pat, cmt_pat_ty, variant_did)\n+                                };\n+\n+                            debug!(\"variant downcast_cmt={} pat={}\",\n+                                   downcast_cmt.repr(tcx),\n+                                   pat.repr(tcx));\n+\n+                            delegate.matched_pat(pat, downcast_cmt, match_mode);\n+                        }\n+\n+                        Some(&def::DefStruct(..)) | Some(&def::DefTy(_, false)) => {\n+                            // A struct (in either the value or type\n+                            // namespace; we encounter the former on\n+                            // e.g. patterns for unit structs).\n+\n+                            debug!(\"struct cmt_pat={} pat={}\",\n+                                   cmt_pat.repr(tcx),\n+                                   pat.repr(tcx));\n+\n+                            delegate.matched_pat(pat, cmt_pat, match_mode);\n+                        }\n+\n+                        Some(&def::DefConst(..)) |\n+                        Some(&def::DefLocal(..)) => {\n+                            // This is a leaf (i.e. identifier binding\n+                            // or constant value to match); thus no\n+                            // `matched_pat` call.\n+                        }\n+\n+                        Some(def @ &def::DefTy(_, true)) => {\n+                            // An enum's type -- should never be in a\n+                            // pattern.\n+\n+                            let msg = format!(\"Pattern has unexpected type: {}\", def);\n+                            tcx.sess.span_bug(pat.span, msg.as_slice())\n+                        }\n+\n+                        Some(def) => {\n+                            // Remaining cases are e.g. DefFn, to\n+                            // which identifiers within patterns\n+                            // should not resolve.\n+\n+                            let msg = format!(\"Pattern has unexpected def: {}\", def);\n+                            tcx.sess.span_bug(pat.span, msg.as_slice())\n+                        }\n+                    }\n+                }\n+\n+                ast::PatIdent(_, _, Some(_)) => {\n+                    // Do nothing; this is a binding (not a enum\n+                    // variant or struct), and the cat_pattern call\n+                    // will visit the substructure recursively.\n+                }\n+\n+                ast::PatWild(_) | ast::PatTup(..) | ast::PatBox(..) |\n+                ast::PatRegion(..) | ast::PatLit(..) | ast::PatRange(..) |\n+                ast::PatVec(..) | ast::PatMac(..) => {\n+                    // Similarly, each of these cases does not\n+                    // correspond to a enum variant or struct, so we\n+                    // do not do any `matched_pat` calls for these\n+                    // cases either.\n+                }\n+            }\n+        }));\n     }\n \n     fn walk_captures(&mut self, closure_expr: &ast::Expr) {"}, {"sha": "381220d587cbca9008ac916e8b8d2aad7b99d717", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d67fd777be1a0ab751007e6787add2b927909f/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=09d67fd777be1a0ab751007e6787add2b927909f", "patch": "@@ -1274,6 +1274,7 @@ struct ReassignmentChecker {\n \n impl<'tcx> euv::Delegate<'tcx> for ReassignmentChecker {\n     fn consume(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: euv::ConsumeMode) {}\n+    fn matched_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::MatchMode) {}\n     fn consume_pat(&mut self, _: &ast::Pat, _: mc::cmt, _: euv::ConsumeMode) {}\n     fn borrow(&mut self, _: ast::NodeId, _: Span, _: mc::cmt, _: ty::Region,\n               _: ty::BorrowKind, _: euv::LoanCause) {}"}]}