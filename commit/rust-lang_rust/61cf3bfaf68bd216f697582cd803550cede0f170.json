{"sha": "61cf3bfaf68bd216f697582cd803550cede0f170", "node_id": "C_kwDOAAsO6NoAKDYxY2YzYmZhZjY4YmQyMTZmNjk3NTgyY2Q4MDM1NTBjZWRlMGYxNzA", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-05T06:42:26Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-10-05T06:42:49Z"}, "message": "Suggest calling method if fn does not exist", "tree": {"sha": "74cb68a36e6a1f45547c8b0039f1b8f183850a07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74cb68a36e6a1f45547c8b0039f1b8f183850a07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61cf3bfaf68bd216f697582cd803550cede0f170", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61cf3bfaf68bd216f697582cd803550cede0f170", "html_url": "https://github.com/rust-lang/rust/commit/61cf3bfaf68bd216f697582cd803550cede0f170", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61cf3bfaf68bd216f697582cd803550cede0f170/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66c8c5ad1df9575ec02fe88b525405ba965c8c40", "url": "https://api.github.com/repos/rust-lang/rust/commits/66c8c5ad1df9575ec02fe88b525405ba965c8c40", "html_url": "https://github.com/rust-lang/rust/commit/66c8c5ad1df9575ec02fe88b525405ba965c8c40"}], "stats": {"total": 183, "additions": 177, "deletions": 6}, "files": [{"sha": "a715ce5bee8b7d112227a8eb2e54f92fb18c41d7", "filename": "compiler/rustc_hir_analysis/src/check/callee.rs", "status": "modified", "additions": 120, "deletions": 6, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/61cf3bfaf68bd216f697582cd803550cede0f170/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61cf3bfaf68bd216f697582cd803550cede0f170/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs?ref=61cf3bfaf68bd216f697582cd803550cede0f170", "patch": "@@ -1,7 +1,9 @@\n+use super::method::probe::{IsSuggestion, Mode, ProbeScope};\n use super::method::MethodCallee;\n use super::{DefIdOrName, Expectation, FnCtxt, TupleArgumentsFlag};\n use crate::type_error_struct;\n \n+use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{struct_span_err, Applicability, Diagnostic, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{self, Namespace, Res};\n@@ -407,7 +409,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .diagnostic()\n                         .steal_diagnostic(segment.ident.span, StashKey::CallIntoMethod)\n                 {\n-                    diag.emit();\n+                    // Try suggesting `foo(a)` -> `a.foo()` if possible.\n+                    if let Some(ty) =\n+                        self.suggest_call_as_method(\n+                            &mut diag,\n+                            segment,\n+                            arg_exprs,\n+                            call_expr,\n+                            expected\n+                        )\n+                    {\n+                        diag.emit();\n+                        return ty;\n+                    } else {\n+                        diag.emit();\n+                    }\n                 }\n \n                 self.report_invalid_callee(call_expr, callee_expr, callee_ty, arg_exprs);\n@@ -457,6 +473,105 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fn_sig.output()\n     }\n \n+    /// Attempts to reinterpret `method(rcvr, args...)` as `method.rcvr(args...)`\n+    /// and suggesting the fix if the method probe is successful.\n+    fn suggest_call_as_method(\n+        &self,\n+        diag: &mut Diagnostic,\n+        segment: &'tcx hir::PathSegment<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        expected: Expectation<'tcx>,\n+    ) -> Option<Ty<'tcx>> {\n+        if let [callee_expr, rest @ ..] = arg_exprs {\n+            let callee_ty = self.check_expr(callee_expr);\n+            // First, do a probe with `IsSuggestion(true)` to avoid emitting\n+            // any strange errors. If it's successful, then we'll do a true\n+            // method lookup.\n+            let Ok(pick) = self\n+            .probe_for_name(\n+                call_expr.span,\n+                Mode::MethodCall,\n+                segment.ident,\n+                IsSuggestion(true),\n+                callee_ty,\n+                call_expr.hir_id,\n+                // We didn't record the in scope traits during late resolution\n+                // so we need to probe AllTraits unfortunately\n+                ProbeScope::AllTraits,\n+            ) else {\n+                return None;\n+            };\n+\n+            let pick = self.confirm_method(\n+                call_expr.span,\n+                callee_expr,\n+                call_expr,\n+                callee_ty,\n+                pick,\n+                segment,\n+            );\n+            if pick.illegal_sized_bound.is_some() {\n+                return None;\n+            }\n+\n+            let up_to_rcvr_span = segment.ident.span.until(callee_expr.span);\n+            let rest_span = callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n+            let rest_snippet = if let Some(first) = rest.first() {\n+                self.tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(first.span.to(call_expr.span.shrink_to_hi()))\n+            } else {\n+                Ok(\")\".to_string())\n+            };\n+\n+            if let Ok(rest_snippet) = rest_snippet {\n+                let sugg = if callee_expr.precedence().order() >= PREC_POSTFIX {\n+                    vec![\n+                        (up_to_rcvr_span, \"\".to_string()),\n+                        (rest_span, format!(\".{}({rest_snippet}\", segment.ident)),\n+                    ]\n+                } else {\n+                    vec![\n+                        (up_to_rcvr_span, \"(\".to_string()),\n+                        (rest_span, format!(\").{}({rest_snippet}\", segment.ident)),\n+                    ]\n+                };\n+                let self_ty = self.resolve_vars_if_possible(pick.callee.sig.inputs()[0]);\n+                diag.multipart_suggestion(\n+                    format!(\n+                        \"use the `.` operator to call the method `{}{}` on `{self_ty}`\",\n+                        self.tcx\n+                            .associated_item(pick.callee.def_id)\n+                            .trait_container(self.tcx)\n+                            .map_or_else(\n+                                || String::new(),\n+                                |trait_def_id| self.tcx.def_path_str(trait_def_id) + \"::\"\n+                            ),\n+                        segment.ident\n+                    ),\n+                    sugg,\n+                    Applicability::MaybeIncorrect,\n+                );\n+\n+                // Let's check the method fully now\n+                let return_ty = self.check_method_argument_types(\n+                    segment.ident.span,\n+                    call_expr,\n+                    Ok(pick.callee),\n+                    rest,\n+                    TupleArgumentsFlag::DontTupleArguments,\n+                    expected,\n+                );\n+\n+                return Some(return_ty);\n+            }\n+        }\n+\n+        None\n+    }\n+\n     fn report_invalid_callee(\n         &self,\n         call_expr: &'tcx hir::Expr<'tcx>,\n@@ -475,10 +590,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 def::CtorOf::Struct => \"struct\",\n                 def::CtorOf::Variant => \"enum variant\",\n             };\n-            let removal_span =\n-                callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n-            unit_variant =\n-                Some((removal_span, descr, rustc_hir_pretty::qpath_to_string(qpath)));\n+            let removal_span = callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n+            unit_variant = Some((removal_span, descr, rustc_hir_pretty::qpath_to_string(qpath)));\n         }\n \n         let callee_ty = self.resolve_vars_if_possible(callee_ty);\n@@ -541,7 +654,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n-            if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_expr, callee_ty)\n+            if let Some((maybe_def, output_ty, _)) =\n+                self.extract_callable_info(callee_expr, callee_ty)\n                 && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n             {\n                 let descr = match maybe_def {"}, {"sha": "9a35c3efc41b7c75553a80951c85b74248159733", "filename": "src/test/ui/suggestions/fn-to-method.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/61cf3bfaf68bd216f697582cd803550cede0f170/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61cf3bfaf68bd216f697582cd803550cede0f170/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method.rs?ref=61cf3bfaf68bd216f697582cd803550cede0f170", "patch": "@@ -0,0 +1,19 @@\n+struct Foo;\n+\n+impl Foo {\n+    fn bar(self) {}\n+}\n+\n+fn main() {\n+    let x = cmp(&1, &2);\n+    //~^ ERROR cannot find function `cmp` in this scope\n+    //~| HELP use the `.` operator to call the method `Ord::cmp` on `&{integer}`\n+\n+    let y = len([1, 2, 3]);\n+    //~^ ERROR cannot find function `len` in this scope\n+    //~| HELP use the `.` operator to call the method `len` on `&[{integer}]`\n+\n+    let z = bar(Foo);\n+    //~^ ERROR cannot find function `bar` in this scope\n+    //~| HELP use the `.` operator to call the method `bar` on `Foo`\n+}"}, {"sha": "36c17e60d3572ae83fc03588983dae37106b97e4", "filename": "src/test/ui/suggestions/fn-to-method.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/61cf3bfaf68bd216f697582cd803550cede0f170/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/61cf3bfaf68bd216f697582cd803550cede0f170/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ffn-to-method.stderr?ref=61cf3bfaf68bd216f697582cd803550cede0f170", "patch": "@@ -0,0 +1,38 @@\n+error[E0425]: cannot find function `cmp` in this scope\n+  --> $DIR/fn-to-method.rs:8:13\n+   |\n+LL |     let x = cmp(&1, &2);\n+   |             ^^^ not found in this scope\n+   |\n+help: use the `.` operator to call the method `Ord::cmp` on `&{integer}`\n+   |\n+LL |     let x = (&1).cmp(&2);\n+   |             ~  ~~~~~~~~~\n+\n+error[E0425]: cannot find function `len` in this scope\n+  --> $DIR/fn-to-method.rs:12:13\n+   |\n+LL |     let y = len([1, 2, 3]);\n+   |             ^^^ not found in this scope\n+   |\n+help: use the `.` operator to call the method `len` on `&[{integer}]`\n+   |\n+LL -     let y = len([1, 2, 3]);\n+LL +     let y = [1, 2, 3].len();\n+   |\n+\n+error[E0425]: cannot find function `bar` in this scope\n+  --> $DIR/fn-to-method.rs:16:13\n+   |\n+LL |     let z = bar(Foo);\n+   |             ^^^ not found in this scope\n+   |\n+help: use the `.` operator to call the method `bar` on `Foo`\n+   |\n+LL -     let z = bar(Foo);\n+LL +     let z = Foo.bar();\n+   |\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}]}