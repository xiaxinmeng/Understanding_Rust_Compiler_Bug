{"sha": "ad60608444c9e4c0647b2823f261c7d2359f060d", "node_id": "C_kwDOAAsO6NoAKGFkNjA2MDg0NDRjOWU0YzA2NDdiMjgyM2YyNjFjN2QyMzU5ZjA2MGQ", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2023-05-26T11:47:45Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2023-05-26T11:47:45Z"}, "message": "Merge from rustc", "tree": {"sha": "306359880c1076cb51ea1ad35ddccaf9298d9d4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/306359880c1076cb51ea1ad35ddccaf9298d9d4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad60608444c9e4c0647b2823f261c7d2359f060d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad60608444c9e4c0647b2823f261c7d2359f060d", "html_url": "https://github.com/rust-lang/rust/commit/ad60608444c9e4c0647b2823f261c7d2359f060d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad60608444c9e4c0647b2823f261c7d2359f060d/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ffd3f941081b37f5c34afbaf62eb87af9b19b9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ffd3f941081b37f5c34afbaf62eb87af9b19b9d", "html_url": "https://github.com/rust-lang/rust/commit/9ffd3f941081b37f5c34afbaf62eb87af9b19b9d"}, {"sha": "f78369b3afedd4d662cc6f92eee825bc94bf1e8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f78369b3afedd4d662cc6f92eee825bc94bf1e8e", "html_url": "https://github.com/rust-lang/rust/commit/f78369b3afedd4d662cc6f92eee825bc94bf1e8e"}], "stats": {"total": 18537, "additions": 10719, "deletions": 7818}, "files": [{"sha": "b12a0b855e2e7986b75686a6879a5965924f30bf", "filename": ".github/workflows/ci.yml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/.github%2Fworkflows%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/.github%2Fworkflows%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fci.yml?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -201,6 +201,9 @@ jobs:\n           - name: dist-i686-linux\n             os: ubuntu-20.04-8core-32gb\n             env: {}\n+          - name: dist-loongarch64-linux\n+            os: ubuntu-20.04-8core-32gb\n+            env: {}\n           - name: dist-mips-linux\n             os: ubuntu-20.04-8core-32gb\n             env: {}"}, {"sha": "0369442f11cf6b2a9e270ee095dd44e529c7afe9", "filename": "Cargo.lock", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -246,6 +246,15 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"bincode\"\n+version = \"1.3.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b1f45e9417d87227c7a56d22e471c6206462cba514c7590c09aff4cf6d1ddcad\"\n+dependencies = [\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"bitflags\"\n version = \"1.3.2\"\n@@ -717,9 +726,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.91\"\n+version = \"0.1.92\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"571298a3cce7e2afbd3d61abb91a18667d5ab25993ec577a88ee8ac45f00cc3a\"\n+checksum = \"64518f1ae689f74db058bbfb3238dfe6eb53f59f4ae712f1ff4348628522e190\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -2770,9 +2779,9 @@ dependencies = [\n \n [[package]]\n name = \"pulldown-cmark\"\n-version = \"0.9.2\"\n+version = \"0.9.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2d9cc634bc78768157b5cbfe988ffcd1dcba95cd2b2f03a88316c08c6d00ed63\"\n+checksum = \"77a1a2f1f0a7ecff9c31abbe177637be0e97a0aef46cf8738ece09327985d998\"\n dependencies = [\n  \"bitflags\",\n  \"memchr\",\n@@ -4374,6 +4383,7 @@ dependencies = [\n name = \"rustdoc-json-types\"\n version = \"0.1.0\"\n dependencies = [\n+ \"bincode\",\n  \"rustc-hash\",\n  \"serde\",\n  \"serde_json\","}, {"sha": "4360fbeb9bbc1f828f550f908a80d6fbfd11497e", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -2391,10 +2391,10 @@ pub struct FnDecl {\n \n impl FnDecl {\n     pub fn has_self(&self) -> bool {\n-        self.inputs.get(0).map_or(false, Param::is_self)\n+        self.inputs.get(0).is_some_and(Param::is_self)\n     }\n     pub fn c_variadic(&self) -> bool {\n-        self.inputs.last().map_or(false, |arg| matches!(arg.ty.kind, TyKind::CVarArgs))\n+        self.inputs.last().is_some_and(|arg| matches!(arg.ty.kind, TyKind::CVarArgs))\n     }\n }\n "}, {"sha": "15fe29580c29ce9acb1da1bd0209ff86651e6539", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -149,7 +149,7 @@ impl Attribute {\n     }\n \n     pub fn may_have_doc_links(&self) -> bool {\n-        self.doc_str().map_or(false, |s| comments::may_have_doc_links(s.as_str()))\n+        self.doc_str().is_some_and(|s| comments::may_have_doc_links(s.as_str()))\n     }\n \n     pub fn is_proc_macro_attr(&self) -> bool {\n@@ -441,12 +441,12 @@ impl NestedMetaItem {\n \n     /// Returns `true` if this list item is a MetaItem with a name of `name`.\n     pub fn has_name(&self, name: Symbol) -> bool {\n-        self.meta_item().map_or(false, |meta_item| meta_item.has_name(name))\n+        self.meta_item().is_some_and(|meta_item| meta_item.has_name(name))\n     }\n \n     /// Returns `true` if `self` is a `MetaItem` and the meta item is a word.\n     pub fn is_word(&self) -> bool {\n-        self.meta_item().map_or(false, |meta_item| meta_item.is_word())\n+        self.meta_item().is_some_and(|meta_item| meta_item.is_word())\n     }\n \n     /// Gets a list of inner meta items from a list `MetaItem` type."}, {"sha": "e87f6e820a1fcae6feeb67959990f25ab60cd7e0", "filename": "compiler/rustc_ast/src/expand/allocator.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fexpand%2Fallocator.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,20 +1,28 @@\n use rustc_span::symbol::{sym, Symbol};\n \n-#[derive(Clone, Debug, Copy, HashStable_Generic)]\n+#[derive(Clone, Debug, Copy, Eq, PartialEq, HashStable_Generic)]\n pub enum AllocatorKind {\n     Global,\n     Default,\n }\n \n-impl AllocatorKind {\n-    pub fn fn_name(&self, base: Symbol) -> String {\n-        match *self {\n-            AllocatorKind::Global => format!(\"__rg_{base}\"),\n-            AllocatorKind::Default => format!(\"__rdl_{base}\"),\n-        }\n+pub fn global_fn_name(base: Symbol) -> String {\n+    format!(\"__rust_{base}\")\n+}\n+\n+pub fn default_fn_name(base: Symbol) -> String {\n+    format!(\"__rdl_{base}\")\n+}\n+\n+pub fn alloc_error_handler_name(alloc_error_handler_kind: AllocatorKind) -> &'static str {\n+    match alloc_error_handler_kind {\n+        AllocatorKind::Global => \"__rg_oom\",\n+        AllocatorKind::Default => \"__rdl_oom\",\n     }\n }\n \n+pub const NO_ALLOC_SHIM_IS_UNSTABLE: &str = \"__rust_no_alloc_shim_is_unstable\";\n+\n pub enum AllocatorTy {\n     Layout,\n     Ptr,"}, {"sha": "7ef39f8026b209f0fd15a10a74b5f1e9f1d2abad", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -607,7 +607,7 @@ impl Token {\n     /// Returns `true` if the token is an identifier whose name is the given\n     /// string slice.\n     pub fn is_ident_named(&self, name: Symbol) -> bool {\n-        self.ident().map_or(false, |(ident, _)| ident.name == name)\n+        self.ident().is_some_and(|(ident, _)| ident.name == name)\n     }\n \n     /// Returns `true` if the token is an interpolated path."}, {"sha": "50eb92125b9450d15d54091823de59ccc96adf16", "filename": "compiler/rustc_ast/src/util/literal.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fliteral.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -392,8 +392,7 @@ fn integer_lit(symbol: Symbol, suffix: Option<Symbol>) -> Result<LitKind, LitErr\n         // Small bases are lexed as if they were base 10, e.g, the string\n         // might be `0b10201`. This will cause the conversion above to fail,\n         // but these kinds of errors are already reported by the lexer.\n-        let from_lexer =\n-            base < 10 && s.chars().any(|c| c.to_digit(10).map_or(false, |d| d >= base));\n+        let from_lexer = base < 10 && s.chars().any(|c| c.to_digit(10).is_some_and(|d| d >= base));\n         if from_lexer { LitError::LexerError } else { LitError::IntTooLarge(base) }\n     })\n }"}, {"sha": "f63a9bfcd705585809bda87e3c2207fcb6ca7ff1", "filename": "compiler/rustc_ast_lowering/messages.ftl", "status": "modified", "additions": 84, "deletions": 84, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast_lowering%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,99 +1,121 @@\n-ast_lowering_generic_type_with_parentheses =\n-    parenthesized type parameters may only be used with a `Fn` trait\n-    .label = only `Fn` traits may use parentheses\n-\n-ast_lowering_use_angle_brackets = use angle brackets instead\n+ast_lowering_abi_specified_multiple_times =\n+    `{$prev_name}` ABI specified multiple times\n+    .label = previously specified here\n+    .note = these ABIs are equivalent on the current target\n \n-ast_lowering_invalid_abi =\n-    invalid ABI: found `{$abi}`\n-    .label = invalid ABI\n-    .note = invoke `{$command}` for a full list of supported calling conventions.\n+ast_lowering_arbitrary_expression_in_pattern =\n+    arbitrary expressions aren't allowed in patterns\n \n-ast_lowering_invalid_abi_suggestion = did you mean\n+ast_lowering_argument = argument\n \n ast_lowering_assoc_ty_parentheses =\n     parenthesized generic arguments cannot be used in associated type constraints\n \n-ast_lowering_remove_parentheses = remove these parentheses\n-\n-ast_lowering_misplaced_impl_trait =\n-    `impl Trait` only allowed in function and inherent method return types, not in {$position}\n-\n-ast_lowering_misplaced_assoc_ty_binding =\n-    associated type bounds are only allowed in where clauses and function signatures, not in {$position}\n+ast_lowering_async_generators_not_supported =\n+    `async` generators are not yet supported\n \n-ast_lowering_underscore_expr_lhs_assign =\n-    in expressions, `_` can only be used on the left-hand side of an assignment\n-    .label = `_` not allowed here\n+ast_lowering_async_non_move_closure_not_supported =\n+    `async` non-`move` closures with parameters are not currently supported\n+    .help = consider using `let` statements to manually capture variables by reference before entering an `async move` closure\n \n-ast_lowering_base_expression_double_dot =\n-    base expression required after `..`\n-    .label = add a base expression here\n+ast_lowering_att_syntax_only_x86 =\n+    the `att_syntax` option is only supported on x86\n \n ast_lowering_await_only_in_async_fn_and_blocks =\n     `await` is only allowed inside `async` functions and blocks\n     .label = only allowed inside `async` functions and blocks\n \n-ast_lowering_this_not_async = this is not `async`\n+ast_lowering_bad_return_type_notation_inputs =\n+    argument types not allowed with return type notation\n+    .suggestion = remove the input types\n \n-ast_lowering_generator_too_many_parameters =\n-    too many parameters for a generator (expected 0 or 1 parameters)\n+ast_lowering_bad_return_type_notation_needs_dots =\n+    return type notation arguments must be elided with `..`\n+    .suggestion = add `..`\n+\n+ast_lowering_bad_return_type_notation_output =\n+    return type not allowed with return type notation\n+    .suggestion = remove the return type\n+\n+ast_lowering_base_expression_double_dot =\n+    base expression required after `..`\n+    .label = add a base expression here\n+\n+ast_lowering_clobber_abi_not_supported =\n+    `clobber_abi` is not supported on this target\n \n ast_lowering_closure_cannot_be_static = closures cannot be static\n \n-ast_lowering_async_non_move_closure_not_supported =\n-    `async` non-`move` closures with parameters are not currently supported\n-    .help = consider using `let` statements to manually capture variables by reference before entering an `async move` closure\n+ast_lowering_does_not_support_modifiers =\n+    the `{$class_name}` register class does not support template modifiers\n+\n+ast_lowering_extra_double_dot =\n+    `..` can only be used once per {$ctx} pattern\n+    .label = can only be used once per {$ctx} pattern\n \n ast_lowering_functional_record_update_destructuring_assignment =\n     functional record updates are not allowed in destructuring assignments\n     .suggestion = consider removing the trailing pattern\n \n-ast_lowering_async_generators_not_supported =\n-    `async` generators are not yet supported\n+ast_lowering_generator_too_many_parameters =\n+    too many parameters for a generator (expected 0 or 1 parameters)\n \n-ast_lowering_inline_asm_unsupported_target =\n-    inline assembly is unsupported on this target\n+ast_lowering_generic_type_with_parentheses =\n+    parenthesized type parameters may only be used with a `Fn` trait\n+    .label = only `Fn` traits may use parentheses\n \n-ast_lowering_att_syntax_only_x86 =\n-    the `att_syntax` option is only supported on x86\n+ast_lowering_inclusive_range_with_no_end = inclusive range with no end\n \n-ast_lowering_abi_specified_multiple_times =\n-    `{$prev_name}` ABI specified multiple times\n-    .label = previously specified here\n-    .note = these ABIs are equivalent on the current target\n+ast_lowering_inline_asm_unsupported_target =\n+    inline assembly is unsupported on this target\n \n-ast_lowering_clobber_abi_not_supported =\n-    `clobber_abi` is not supported on this target\n+ast_lowering_invalid_abi =\n+    invalid ABI: found `{$abi}`\n+    .label = invalid ABI\n+    .note = invoke `{$command}` for a full list of supported calling conventions.\n \n ast_lowering_invalid_abi_clobber_abi =\n     invalid ABI for `clobber_abi`\n     .note = the following ABIs are supported on this target: {$supported_abis}\n \n+ast_lowering_invalid_abi_suggestion = did you mean\n+\n+ast_lowering_invalid_asm_template_modifier_const =\n+    asm template modifiers are not allowed for `const` arguments\n+\n+ast_lowering_invalid_asm_template_modifier_reg_class =\n+    invalid asm template modifier for this register class\n+\n+ast_lowering_invalid_asm_template_modifier_sym =\n+    asm template modifiers are not allowed for `sym` arguments\n+\n ast_lowering_invalid_register =\n     invalid register `{$reg}`: {$error}\n \n ast_lowering_invalid_register_class =\n     invalid register class `{$reg_class}`: {$error}\n \n-ast_lowering_invalid_asm_template_modifier_reg_class =\n-    invalid asm template modifier for this register class\n+ast_lowering_misplaced_assoc_ty_binding =\n+    associated type bounds are only allowed in where clauses and function signatures, not in {$position}\n \n-ast_lowering_argument = argument\n+ast_lowering_misplaced_double_dot =\n+    `..` patterns are not allowed here\n+    .note = only allowed in tuple, tuple struct, and slice patterns\n \n-ast_lowering_template_modifier = template modifier\n+ast_lowering_misplaced_impl_trait =\n+    `impl Trait` only allowed in function and inherent method return types, not in {$position}\n \n-ast_lowering_support_modifiers =\n-    the `{$class_name}` register class supports the following template modifiers: {$modifiers}\n+ast_lowering_misplaced_relax_trait_bound =\n+    `?Trait` bounds are only permitted at the point where a type parameter is declared\n \n-ast_lowering_does_not_support_modifiers =\n-    the `{$class_name}` register class does not support template modifiers\n+ast_lowering_not_supported_for_lifetime_binder_async_closure =\n+    `for<...>` binders on `async` closures are not currently supported\n \n-ast_lowering_invalid_asm_template_modifier_const =\n-    asm template modifiers are not allowed for `const` arguments\n+ast_lowering_previously_used_here = previously used here\n \n-ast_lowering_invalid_asm_template_modifier_sym =\n-    asm template modifiers are not allowed for `sym` arguments\n+ast_lowering_register1 = register `{$reg1_name}`\n+\n+ast_lowering_register2 = register `{$reg2_name}`\n \n ast_lowering_register_class_only_clobber =\n     register class `{$reg_class_name}` can only be used as a clobber, not as an input or output\n@@ -102,9 +124,7 @@ ast_lowering_register_conflict =\n     register `{$reg1_name}` conflicts with register `{$reg2_name}`\n     .help = use `lateout` instead of `out` to avoid conflict\n \n-ast_lowering_register1 = register `{$reg1_name}`\n-\n-ast_lowering_register2 = register `{$reg2_name}`\n+ast_lowering_remove_parentheses = remove these parentheses\n \n ast_lowering_sub_tuple_binding =\n     `{$ident_name} @` is not allowed in a {$ctx}\n@@ -113,41 +133,21 @@ ast_lowering_sub_tuple_binding =\n \n ast_lowering_sub_tuple_binding_suggestion = if you don't need to use the contents of {$ident}, discard the tuple's remaining fields\n \n-ast_lowering_extra_double_dot =\n-    `..` can only be used once per {$ctx} pattern\n-    .label = can only be used once per {$ctx} pattern\n-\n-ast_lowering_previously_used_here = previously used here\n-\n-ast_lowering_misplaced_double_dot =\n-    `..` patterns are not allowed here\n-    .note = only allowed in tuple, tuple struct, and slice patterns\n-\n-ast_lowering_misplaced_relax_trait_bound =\n-    `?Trait` bounds are only permitted at the point where a type parameter is declared\n-\n-ast_lowering_not_supported_for_lifetime_binder_async_closure =\n-    `for<...>` binders on `async` closures are not currently supported\n+ast_lowering_support_modifiers =\n+    the `{$class_name}` register class supports the following template modifiers: {$modifiers}\n \n-ast_lowering_arbitrary_expression_in_pattern =\n-    arbitrary expressions aren't allowed in patterns\n+ast_lowering_template_modifier = template modifier\n \n-ast_lowering_inclusive_range_with_no_end = inclusive range with no end\n+ast_lowering_this_not_async = this is not `async`\n \n ast_lowering_trait_fn_async =\n     functions in traits cannot be declared `async`\n     .label = `async` because of this\n     .note = `async` trait functions are not currently supported\n     .note2 = consider using the `async-trait` crate: https://crates.io/crates/async-trait\n \n-ast_lowering_bad_return_type_notation_inputs =\n-    argument types not allowed with return type notation\n-    .suggestion = remove the input types\n-\n-ast_lowering_bad_return_type_notation_needs_dots =\n-    return type notation arguments must be elided with `..`\n-    .suggestion = add `..`\n+ast_lowering_underscore_expr_lhs_assign =\n+    in expressions, `_` can only be used on the left-hand side of an assignment\n+    .label = `_` not allowed here\n \n-ast_lowering_bad_return_type_notation_output =\n-    return type not allowed with return type notation\n-    .suggestion = remove the return type\n+ast_lowering_use_angle_brackets = use angle brackets instead"}, {"sha": "8d4f96639efbd0d64a6553311d72b385bf900a88", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1425,7 +1425,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             DefPathData::ImplTrait,\n                             span,\n                         );\n-                        let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n+\n+                        // HACK: pprust breaks strings with newlines when the type\n+                        // gets too long. We don't want these to show up in compiler\n+                        // output or built artifacts, so replace them here...\n+                        // Perhaps we should instead format APITs more robustly.\n+                        let ident = Ident::from_str_and_span(\n+                            &pprust::ty_to_string(t).replace('\\n', \" \"),\n+                            span,\n+                        );\n+\n                         let (param, bounds, path) = self.lower_universal_param_and_bounds(\n                             *def_node_id,\n                             span,"}, {"sha": "2f0ac0c2b1987e3c78b0421c8070cc80fb43a9ac", "filename": "compiler/rustc_ast_passes/messages.ftl", "status": "modified", "additions": 150, "deletions": 150, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,64 +1,3 @@\n-ast_passes_forbidden_let =\n-    `let` expressions are not supported here\n-    .note = only supported directly in conditions of `if` and `while` expressions\n-    .not_supported_or = `||` operators are not supported in let chain expressions\n-    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n-\n-ast_passes_forbidden_let_stable =\n-    expected expression, found statement (`let`)\n-    .note = variable declaration using `let` is a statement\n-\n-ast_passes_deprecated_where_clause_location =\n-    where clause not allowed here\n-\n-ast_passes_keyword_lifetime =\n-    lifetimes cannot use keyword names\n-\n-ast_passes_invalid_label =\n-    invalid label name `{$name}`\n-\n-ast_passes_visibility_not_permitted =\n-    visibility qualifiers are not permitted here\n-    .enum_variant = enum variants and their fields always share the visibility of the enum they are in\n-    .trait_impl = trait items always share the visibility of their trait\n-    .individual_impl_items = place qualifiers on individual impl items instead\n-    .individual_foreign_items = place qualifiers on individual foreign items instead\n-\n-ast_passes_trait_fn_const =\n-    functions in traits cannot be declared const\n-    .label = functions in traits cannot be const\n-\n-ast_passes_forbidden_lifetime_bound =\n-    lifetime bounds cannot be used in this context\n-\n-ast_passes_forbidden_non_lifetime_param =\n-    only lifetime parameters can be used in this context\n-\n-ast_passes_fn_param_too_many =\n-    function can not have more than {$max_num_args} arguments\n-\n-ast_passes_fn_param_c_var_args_only =\n-    C-variadic function must be declared with at least one named argument\n-\n-ast_passes_fn_param_c_var_args_not_last =\n-    `...` must be the last argument of a C-variadic function\n-\n-ast_passes_fn_param_doc_comment =\n-    documentation comments cannot be applied to function parameters\n-    .label = doc comments are not allowed here\n-\n-ast_passes_fn_param_forbidden_attr =\n-    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n-\n-ast_passes_fn_param_forbidden_self =\n-    `self` parameter is only allowed in associated functions\n-    .label = not semantically valid as function parameter\n-    .note = associated functions are those in `impl` or `trait` definitions\n-\n-ast_passes_forbidden_default =\n-    `default` is only allowed on items in trait impls\n-    .label = `default` because of this\n-\n ast_passes_assoc_const_without_body =\n     associated constant in `impl` without body\n     .suggestion = provide a definition for the constant\n@@ -71,72 +10,124 @@ ast_passes_assoc_type_without_body =\n     associated type in `impl` without body\n     .suggestion = provide a definition for the type\n \n+ast_passes_at_least_one_trait = at least one trait must be specified\n+\n+ast_passes_auto_generic = auto traits cannot have generic parameters\n+    .label = auto trait cannot have generic parameters\n+    .suggestion = remove the parameters\n+\n+ast_passes_auto_items = auto traits cannot have associated items\n+    .label = {ast_passes_auto_items}\n+    .suggestion = remove these associated items\n+\n+ast_passes_auto_super_lifetime = auto traits cannot have super traits or lifetime bounds\n+    .label = {ast_passes_auto_super_lifetime}\n+    .suggestion = remove the super traits or lifetime bounds\n+\n+ast_passes_bad_c_variadic = only foreign or `unsafe extern \"C\"` functions may be C-variadic\n+\n+ast_passes_body_in_extern = incorrect `{$kind}` inside `extern` block\n+    .cannot_have = cannot have a body\n+    .invalid = the invalid body\n+    .existing = `extern` blocks define existing foreign {$kind}s and {$kind}s inside of them cannot have a body\n+\n+ast_passes_bound_in_context = bounds on `type`s in {$ctx} have no effect\n+\n+ast_passes_const_and_async = functions cannot be both `const` and `async`\n+    .const = `const` because of this\n+    .async = `async` because of this\n+    .label = {\"\"}\n+\n ast_passes_const_without_body =\n     free constant item without body\n     .suggestion = provide a definition for the constant\n \n-ast_passes_static_without_body =\n-    free static item without body\n-    .suggestion = provide a definition for the static\n+ast_passes_constraint_on_negative_bound =\n+    associated type constraints not allowed on negative bounds\n \n-ast_passes_ty_alias_without_body =\n-    free type alias without body\n-    .suggestion = provide a definition for the type\n+ast_passes_deprecated_where_clause_location =\n+    where clause not allowed here\n \n-ast_passes_fn_without_body =\n-    free function without a body\n-    .suggestion = provide a definition for the function\n+ast_passes_equality_in_where = equality constraints are not yet supported in `where` clauses\n+    .label = not supported\n+    .suggestion = if `{$ident}` is an associated type you're trying to set, use the associated type binding syntax\n+    .suggestion_path = if `{$trait_segment}::{$potential_assoc}` is an associated type you're trying to set, use the associated type binding syntax\n+    .note = see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n \n ast_passes_extern_block_suggestion = if you meant to declare an externally defined function, use an `extern` block\n \n-ast_passes_bound_in_context = bounds on `type`s in {$ctx} have no effect\n+ast_passes_extern_fn_qualifiers = functions in `extern` blocks cannot have qualifiers\n+    .label = in this `extern` block\n+    .suggestion = remove the qualifiers\n+\n+ast_passes_extern_item_ascii = items in `extern` blocks cannot use non-ascii identifiers\n+    .label = in this `extern` block\n+    .note = this limitation may be lifted in the future; see issue #83942 <https://github.com/rust-lang/rust/issues/83942> for more information\n+\n+ast_passes_extern_keyword_link = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n \n ast_passes_extern_types_cannot = `type`s inside `extern` blocks cannot have {$descr}\n     .suggestion = remove the {$remove_descr}\n     .label = `extern` block begins here\n \n-ast_passes_extern_keyword_link = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+ast_passes_extern_without_abi = extern declarations without an explicit ABI are deprecated\n \n-ast_passes_body_in_extern = incorrect `{$kind}` inside `extern` block\n-    .cannot_have = cannot have a body\n-    .invalid = the invalid body\n-    .existing = `extern` blocks define existing foreign {$kind}s and {$kind}s inside of them cannot have a body\n+ast_passes_feature_on_non_nightly = `#![feature]` may not be used on the {$channel} release channel\n+    .suggestion = remove the attribute\n+    .stable_since = the feature `{$name}` has been stable since `{$since}` and no longer requires an attribute to enable\n+\n+ast_passes_fieldless_union = unions cannot have zero fields\n \n ast_passes_fn_body_extern = incorrect function inside `extern` block\n     .cannot_have = cannot have a body\n     .suggestion = remove the invalid body\n     .help = you might have meant to write a function accessible through FFI, which can be done by writing `extern fn` outside of the `extern` block\n     .label = `extern` blocks define existing foreign functions and functions inside of them cannot have a body\n \n-ast_passes_extern_fn_qualifiers = functions in `extern` blocks cannot have qualifiers\n-    .label = in this `extern` block\n-    .suggestion = remove the qualifiers\n+ast_passes_fn_param_c_var_args_not_last =\n+    `...` must be the last argument of a C-variadic function\n \n-ast_passes_extern_item_ascii = items in `extern` blocks cannot use non-ascii identifiers\n-    .label = in this `extern` block\n-    .note = this limitation may be lifted in the future; see issue #83942 <https://github.com/rust-lang/rust/issues/83942> for more information\n+ast_passes_fn_param_c_var_args_only =\n+    C-variadic function must be declared with at least one named argument\n \n-ast_passes_bad_c_variadic = only foreign or `unsafe extern \"C\"` functions may be C-variadic\n+ast_passes_fn_param_doc_comment =\n+    documentation comments cannot be applied to function parameters\n+    .label = doc comments are not allowed here\n \n-ast_passes_item_underscore = `{$kind}` items in this context need a name\n-    .label = `_` is not a valid name for this `{$kind}` item\n+ast_passes_fn_param_forbidden_attr =\n+    allow, cfg, cfg_attr, deny, expect, forbid, and warn are the only allowed built-in attributes in function parameters\n \n-ast_passes_nomangle_ascii = `#[no_mangle]` requires ASCII identifier\n+ast_passes_fn_param_forbidden_self =\n+    `self` parameter is only allowed in associated functions\n+    .label = not semantically valid as function parameter\n+    .note = associated functions are those in `impl` or `trait` definitions\n \n-ast_passes_module_nonascii = trying to load file for module `{$name}` with non-ascii identifier name\n-    .help = consider using the `#[path]` attribute to specify filesystem path\n+ast_passes_fn_param_too_many =\n+    function can not have more than {$max_num_args} arguments\n \n-ast_passes_auto_generic = auto traits cannot have generic parameters\n-    .label = auto trait cannot have generic parameters\n-    .suggestion = remove the parameters\n+ast_passes_fn_without_body =\n+    free function without a body\n+    .suggestion = provide a definition for the function\n \n-ast_passes_auto_super_lifetime = auto traits cannot have super traits or lifetime bounds\n-    .label = {ast_passes_auto_super_lifetime}\n-    .suggestion = remove the super traits or lifetime bounds\n+ast_passes_forbidden_default =\n+    `default` is only allowed on items in trait impls\n+    .label = `default` because of this\n \n-ast_passes_auto_items = auto traits cannot have associated items\n-    .label = {ast_passes_auto_items}\n-    .suggestion = remove these associated items\n+ast_passes_forbidden_let =\n+    `let` expressions are not supported here\n+    .note = only supported directly in conditions of `if` and `while` expressions\n+    .not_supported_or = `||` operators are not supported in let chain expressions\n+    .not_supported_parentheses = `let`s wrapped in parentheses are not supported in a context with let chains\n+\n+ast_passes_forbidden_let_stable =\n+    expected expression, found statement (`let`)\n+    .note = variable declaration using `let` is a statement\n+\n+ast_passes_forbidden_lifetime_bound =\n+    lifetime bounds cannot be used in this context\n+\n+ast_passes_forbidden_non_lifetime_param =\n+    only lifetime parameters can be used in this context\n \n ast_passes_generic_before_constraints = generic arguments must come before the first constraint\n     .constraints = {$constraint_len ->\n@@ -156,88 +147,97 @@ ast_passes_generic_before_constraints = generic arguments must come before the f\n     *[other] arguments\n     }\n \n-ast_passes_pattern_in_fn_pointer = patterns aren't allowed in function pointer types\n-\n-ast_passes_trait_object_single_bound = only a single explicit lifetime bound is permitted\n+ast_passes_generic_default_trailing = generic parameters with a default must be trailing\n \n ast_passes_impl_trait_path = `impl Trait` is not allowed in path parameters\n \n+ast_passes_incompatible_features = `{$f1}` and `{$f2}` are incompatible, using them at the same time is not allowed\n+    .help = remove one of these features\n+\n+ast_passes_inherent_cannot_be = inherent impls cannot be {$annotation}\n+    .because = {$annotation} because of this\n+    .type = inherent impl for this type\n+    .only_trait = only trait implementations may be annotated with {$annotation}\n+\n+ast_passes_invalid_label =\n+    invalid label name `{$name}`\n+\n+ast_passes_item_underscore = `{$kind}` items in this context need a name\n+    .label = `_` is not a valid name for this `{$kind}` item\n+\n+ast_passes_keyword_lifetime =\n+    lifetimes cannot use keyword names\n+\n+ast_passes_module_nonascii = trying to load file for module `{$name}` with non-ascii identifier name\n+    .help = consider using the `#[path]` attribute to specify filesystem path\n+\n+ast_passes_negative_bound_not_supported =\n+    negative bounds are not supported\n+\n ast_passes_nested_impl_trait = nested `impl Trait` is not allowed\n     .outer = outer `impl Trait`\n     .inner = nested `impl Trait` here\n \n-ast_passes_at_least_one_trait = at least one trait must be specified\n-\n-ast_passes_extern_without_abi = extern declarations without an explicit ABI are deprecated\n+ast_passes_nested_lifetimes = nested quantification of lifetimes\n \n-ast_passes_out_of_order_params = {$param_ord} parameters must be declared prior to {$max_param} parameters\n-    .suggestion = reorder the parameters: lifetimes, then consts and types\n+ast_passes_nomangle_ascii = `#[no_mangle]` requires ASCII identifier\n \n ast_passes_obsolete_auto = `impl Trait for .. {\"{}\"}` is an obsolete syntax\n     .help = use `auto trait Trait {\"{}\"}` instead\n \n-ast_passes_unsafe_negative_impl = negative impls cannot be unsafe\n-    .negative = negative because of this\n-    .unsafe = unsafe because of this\n+ast_passes_optional_const_exclusive = `~const` and `{$modifier}` are mutually exclusive\n \n-ast_passes_inherent_cannot_be = inherent impls cannot be {$annotation}\n-    .because = {$annotation} because of this\n-    .type = inherent impl for this type\n-    .only_trait = only trait implementations may be annotated with {$annotation}\n+ast_passes_optional_trait_object = `?Trait` is not permitted in trait object types\n \n-ast_passes_unsafe_item = {$kind} cannot be declared unsafe\n+ast_passes_optional_trait_supertrait = `?Trait` is not permitted in supertraits\n+    .note = traits are `?{$path_str}` by default\n \n-ast_passes_fieldless_union = unions cannot have zero fields\n+ast_passes_out_of_order_params = {$param_ord} parameters must be declared prior to {$max_param} parameters\n+    .suggestion = reorder the parameters: lifetimes, then consts and types\n \n-ast_passes_where_after_type_alias = where clauses are not allowed after the type for type aliases\n-    .note = see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information\n+ast_passes_pattern_in_bodiless = patterns aren't allowed in functions without bodies\n+    .label = pattern not allowed in function without body\n \n-ast_passes_generic_default_trailing = generic parameters with a default must be trailing\n+ast_passes_pattern_in_fn_pointer = patterns aren't allowed in function pointer types\n \n-ast_passes_nested_lifetimes = nested quantification of lifetimes\n+ast_passes_pattern_in_foreign = patterns aren't allowed in foreign function declarations\n+    .label = pattern not allowed in foreign function\n \n-ast_passes_optional_trait_supertrait = `?Trait` is not permitted in supertraits\n-    .note = traits are `?{$path_str}` by default\n+ast_passes_show_span = {$msg}\n \n-ast_passes_optional_trait_object = `?Trait` is not permitted in trait object types\n+ast_passes_stability_outside_std = stability attributes may not be used outside of the standard library\n+\n+ast_passes_static_without_body =\n+    free static item without body\n+    .suggestion = provide a definition for the static\n \n ast_passes_tilde_const_disallowed = `~const` is not allowed here\n     .trait = trait objects cannot have `~const` trait bounds\n     .closure = closures cannot have `~const` trait bounds\n     .function = this function is not `const`, so it cannot have `~const` trait bounds\n \n-ast_passes_optional_const_exclusive = `~const` and `{$modifier}` are mutually exclusive\n-\n-ast_passes_const_and_async = functions cannot be both `const` and `async`\n-    .const = `const` because of this\n-    .async = `async` because of this\n-    .label = {\"\"}\n-\n-ast_passes_pattern_in_foreign = patterns aren't allowed in foreign function declarations\n-    .label = pattern not allowed in foreign function\n-\n-ast_passes_pattern_in_bodiless = patterns aren't allowed in functions without bodies\n-    .label = pattern not allowed in function without body\n-\n-ast_passes_equality_in_where = equality constraints are not yet supported in `where` clauses\n-    .label = not supported\n-    .suggestion = if `{$ident}` is an associated type you're trying to set, use the associated type binding syntax\n-    .suggestion_path = if `{$trait_segment}::{$potential_assoc}` is an associated type you're trying to set, use the associated type binding syntax\n-    .note = see issue #20041 <https://github.com/rust-lang/rust/issues/20041> for more information\n+ast_passes_trait_fn_const =\n+    functions in traits cannot be declared const\n+    .label = functions in traits cannot be const\n \n-ast_passes_stability_outside_std = stability attributes may not be used outside of the standard library\n+ast_passes_trait_object_single_bound = only a single explicit lifetime bound is permitted\n \n-ast_passes_feature_on_non_nightly = `#![feature]` may not be used on the {$channel} release channel\n-    .suggestion = remove the attribute\n-    .stable_since = the feature `{$name}` has been stable since `{$since}` and no longer requires an attribute to enable\n+ast_passes_ty_alias_without_body =\n+    free type alias without body\n+    .suggestion = provide a definition for the type\n \n-ast_passes_incompatible_features = `{$f1}` and `{$f2}` are incompatible, using them at the same time is not allowed\n-    .help = remove one of these features\n+ast_passes_unsafe_item = {$kind} cannot be declared unsafe\n \n-ast_passes_show_span = {$msg}\n+ast_passes_unsafe_negative_impl = negative impls cannot be unsafe\n+    .negative = negative because of this\n+    .unsafe = unsafe because of this\n \n-ast_passes_negative_bound_not_supported =\n-    negative bounds are not supported\n+ast_passes_visibility_not_permitted =\n+    visibility qualifiers are not permitted here\n+    .enum_variant = enum variants and their fields always share the visibility of the enum they are in\n+    .trait_impl = trait items always share the visibility of their trait\n+    .individual_impl_items = place qualifiers on individual impl items instead\n+    .individual_foreign_items = place qualifiers on individual foreign items instead\n \n-ast_passes_constraint_on_negative_bound =\n-    associated type constraints not allowed on negative bounds\n+ast_passes_where_after_type_alias = where clauses are not allowed after the type for type aliases\n+    .note = see issue #89122 <https://github.com/rust-lang/rust/issues/89122> for more information"}, {"sha": "04ed27678765259a9cc47ce1eec644b3699a9f2b", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -348,7 +348,7 @@ impl<'a> AstValidator<'a> {\n         let source_map = self.session.source_map();\n         let end = source_map.end_point(sp);\n \n-        if source_map.span_to_snippet(end).map(|s| s == \";\").unwrap_or(false) {\n+        if source_map.span_to_snippet(end).is_ok_and(|s| s == \";\") {\n             end\n         } else {\n             sp.shrink_to_hi()\n@@ -736,11 +736,10 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                         this.visit_expr(&arm.body);\n                         this.visit_pat(&arm.pat);\n                         walk_list!(this, visit_attribute, &arm.attrs);\n-                        if let Some(guard) = &arm.guard && let ExprKind::Let(_, guard_expr, _) = &guard.kind {\n+                        if let Some(guard) = &arm.guard {\n                             this.with_let_management(None, |this, _| {\n-                                this.visit_expr(guard_expr)\n+                                this.visit_expr(guard)\n                             });\n-                            return;\n                         }\n                     }\n                 }"}, {"sha": "274f931e43f9dcb683bd1af2cbb27079d739c4d1", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -317,8 +317,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match i.kind {\n             ast::ForeignItemKind::Fn(..) | ast::ForeignItemKind::Static(..) => {\n                 let link_name = attr::first_attr_value_str_by_name(&i.attrs, sym::link_name);\n-                let links_to_llvm =\n-                    link_name.map_or(false, |val| val.as_str().starts_with(\"llvm.\"));\n+                let links_to_llvm = link_name.is_some_and(|val| val.as_str().starts_with(\"llvm.\"));\n                 if links_to_llvm {\n                     gate_feature_post!(\n                         &self,"}, {"sha": "e6cbbaf3704bc3e63e75458a67b76fe3e52475b2", "filename": "compiler/rustc_attr/messages.ftl", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_attr%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_attr%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,27 +1,38 @@\n+attr_cfg_predicate_identifier =\n+    `cfg` predicate key must be an identifier\n+\n+attr_deprecated_item_suggestion =\n+    suggestions on deprecated items are unstable\n+    .help = add `#![feature(deprecated_suggestion)]` to the crate root\n+    .note = see #94785 for more details\n+\n attr_expected_one_cfg_pattern =\n     expected 1 cfg-pattern\n \n-attr_invalid_predicate =\n-    invalid predicate `{$predicate}`\n+attr_expected_single_version_literal =\n+    expected single version literal\n \n-attr_multiple_item =\n-    multiple '{$item}' items\n+attr_expected_version_literal =\n+    expected a version literal\n+\n+attr_expects_feature_list =\n+    `{$name}` expects a list of feature names\n+\n+attr_expects_features =\n+    `{$name}` expects feature names\n \n attr_incorrect_meta_item =\n     incorrect meta item\n \n-attr_unknown_meta_item =\n-    unknown meta item '{$item}'\n-    .label = expected one of {$expected}\n-\n-attr_missing_since =\n-    missing 'since'\n+attr_incorrect_repr_format_align_one_arg =\n+    incorrect `repr(align)` attribute format: `align` takes exactly one argument in parentheses\n \n-attr_missing_note =\n-    missing 'note'\n+attr_incorrect_repr_format_generic =\n+    incorrect `repr({$repr_arg})` attribute format\n+    .suggestion = use parentheses instead\n \n-attr_multiple_stability_levels =\n-    multiple stability levels\n+attr_incorrect_repr_format_packed_one_or_zero_arg =\n+    incorrect `repr(packed)` attribute format: `packed` takes exactly one parenthesized argument, or no parentheses at all\n \n attr_invalid_issue_string =\n     `issue` must be a non-zero numeric string or \"none\"\n@@ -31,77 +42,66 @@ attr_invalid_issue_string =\n     .pos_overflow = number too large to fit in target type\n     .neg_overflow = number too small to fit in target type\n \n-attr_missing_feature =\n-    missing 'feature'\n-\n-attr_non_ident_feature =\n-    'feature' is not an identifier\n+attr_invalid_predicate =\n+    invalid predicate `{$predicate}`\n \n-attr_missing_issue =\n-    missing 'issue'\n+attr_invalid_repr_align_need_arg =\n+    invalid `repr(align)` attribute: `align` needs an argument\n+    .suggestion = supply an argument here\n \n-attr_incorrect_repr_format_packed_one_or_zero_arg =\n-    incorrect `repr(packed)` attribute format: `packed` takes exactly one parenthesized argument, or no parentheses at all\n+attr_invalid_repr_generic =\n+    invalid `repr({$repr_arg})` attribute: {$error_part}\n \n attr_invalid_repr_hint_no_paren =\n     invalid representation hint: `{$name}` does not take a parenthesized argument list\n \n attr_invalid_repr_hint_no_value =\n     invalid representation hint: `{$name}` does not take a value\n \n-attr_unsupported_literal_generic =\n-    unsupported literal\n-attr_unsupported_literal_cfg_string =\n-    literal in `cfg` predicate value must be a string\n-attr_unsupported_literal_deprecated_string =\n-    literal in `deprecated` value must be a string\n-attr_unsupported_literal_deprecated_kv_pair =\n-    item in `deprecated` must be a key/value pair\n-attr_unsupported_literal_suggestion =\n-    consider removing the prefix\n+attr_missing_feature =\n+    missing 'feature'\n \n-attr_invalid_repr_align_need_arg =\n-    invalid `repr(align)` attribute: `align` needs an argument\n-    .suggestion = supply an argument here\n+attr_missing_issue =\n+    missing 'issue'\n \n-attr_invalid_repr_generic =\n-    invalid `repr({$repr_arg})` attribute: {$error_part}\n+attr_missing_note =\n+    missing 'note'\n \n-attr_incorrect_repr_format_align_one_arg =\n-    incorrect `repr(align)` attribute format: `align` takes exactly one argument in parentheses\n+attr_missing_since =\n+    missing 'since'\n \n-attr_incorrect_repr_format_generic =\n-    incorrect `repr({$repr_arg})` attribute format\n-    .suggestion = use parentheses instead\n+attr_multiple_item =\n+    multiple '{$item}' items\n \n-attr_rustc_promotable_pairing =\n-    `rustc_promotable` attribute must be paired with either a `rustc_const_unstable` or a `rustc_const_stable` attribute\n+attr_multiple_stability_levels =\n+    multiple stability levels\n+\n+attr_non_ident_feature =\n+    'feature' is not an identifier\n \n attr_rustc_allowed_unstable_pairing =\n     `rustc_allowed_through_unstable_modules` attribute must be paired with a `stable` attribute\n \n-attr_cfg_predicate_identifier =\n-    `cfg` predicate key must be an identifier\n-\n-attr_deprecated_item_suggestion =\n-    suggestions on deprecated items are unstable\n-    .help = add `#![feature(deprecated_suggestion)]` to the crate root\n-    .note = see #94785 for more details\n-\n-attr_expected_single_version_literal =\n-    expected single version literal\n-\n-attr_expected_version_literal =\n-    expected a version literal\n-\n-attr_expects_feature_list =\n-    `{$name}` expects a list of feature names\n-\n-attr_expects_features =\n-    `{$name}` expects feature names\n+attr_rustc_promotable_pairing =\n+    `rustc_promotable` attribute must be paired with either a `rustc_const_unstable` or a `rustc_const_stable` attribute\n \n attr_soft_no_args =\n     `soft` should not have any arguments\n \n+attr_unknown_meta_item =\n+    unknown meta item '{$item}'\n+    .label = expected one of {$expected}\n+\n attr_unknown_version_literal =\n     unknown version literal format, assuming it refers to a future version\n+\n+attr_unsupported_literal_cfg_string =\n+    literal in `cfg` predicate value must be a string\n+attr_unsupported_literal_deprecated_kv_pair =\n+    item in `deprecated` must be a key/value pair\n+attr_unsupported_literal_deprecated_string =\n+    literal in `deprecated` value must be a string\n+attr_unsupported_literal_generic =\n+    unsupported literal\n+attr_unsupported_literal_suggestion =\n+    consider removing the prefix"}, {"sha": "67fdb671742da838921bd3d5daf9df1c3d6fc1b6", "filename": "compiler/rustc_borrowck/messages.ftl", "status": "modified", "additions": 173, "deletions": 173, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,188 +1,108 @@\n-borrowck_move_unsized =\n-    cannot move a value of type `{$ty}`\n-    .label = the size of `{$ty}` cannot be statically determined\n-\n-borrowck_higher_ranked_lifetime_error =\n-    higher-ranked lifetime error\n-\n-borrowck_could_not_prove =\n-    could not prove `{$predicate}`\n-\n-borrowck_could_not_normalize =\n-    could not normalize `{$value}`\n-\n-borrowck_higher_ranked_subtype_error =\n-    higher-ranked subtype error\n-\n-borrowck_generic_does_not_live_long_enough =\n-    `{$kind}` does not live long enough\n-\n-borrowck_move_borrowed =\n-    cannot move out of `{$desc}` because it is borrowed\n-\n-borrowck_var_does_not_need_mut =\n-    variable does not need to be mutable\n-    .suggestion = remove this `mut`\n-\n-borrowck_var_cannot_escape_closure =\n-    captured variable cannot escape `FnMut` closure body\n-    .note = `FnMut` closures only have access to their captured variables while they are executing...\n-    .cannot_escape = ...therefore, they cannot allow references to captured variables to escape\n-\n-borrowck_var_here_defined = variable defined here\n-\n-borrowck_var_here_captured = variable captured here\n-\n-borrowck_closure_inferred_mut = inferred to be a `FnMut` closure\n-\n-borrowck_returned_closure_escaped =\n-    returns a closure that contains a reference to a captured variable, which then escapes the closure body\n-\n-borrowck_returned_async_block_escaped =\n-    returns an `async` block that contains a reference to a captured variable, which then escapes the closure body\n-\n-borrowck_returned_ref_escaped =\n-    returns a reference to a captured variable which escapes the closure body\n-\n-borrowck_lifetime_constraints_error =\n-    lifetime may not live long enough\n-\n-borrowck_returned_lifetime_wrong =\n-    {$mir_def_name} was supposed to return data with lifetime `{$outlived_fr_name}` but it is returning data with lifetime `{$fr_name}`\n-\n-borrowck_returned_lifetime_short =\n-    {$category_desc}requires that `{$free_region_name}` must outlive `{$outlived_fr_name}`\n-\n-borrowck_used_impl_require_static =\n-    the used `impl` has a `'static` requirement\n-\n-borrowck_borrow_due_to_use_generator =\n-    borrow occurs due to use in generator\n-\n-borrowck_use_due_to_use_generator =\n-    use occurs due to use in generator\n+borrowck_assign_due_to_use_closure =\n+    assignment occurs due to use in closure\n \n borrowck_assign_due_to_use_generator =\n     assign occurs due to use in generator\n \n+borrowck_assign_part_due_to_use_closure =\n+    assignment to part occurs due to use in closure\n+\n borrowck_assign_part_due_to_use_generator =\n     assign to part occurs due to use in generator\n \n borrowck_borrow_due_to_use_closure =\n     borrow occurs due to use in closure\n \n-borrowck_use_due_to_use_closure =\n-    use occurs due to use in closure\n+borrowck_borrow_due_to_use_generator =\n+    borrow occurs due to use in generator\n \n-borrowck_assign_due_to_use_closure =\n-    assignment occurs due to use in closure\n+borrowck_calling_operator_moves_lhs =\n+    calling this operator moves the left-hand side\n \n-borrowck_assign_part_due_to_use_closure =\n-    assignment to part occurs due to use in closure\n+borrowck_cannot_move_when_borrowed =\n+    cannot move out of {$place ->\n+        [value] value\n+        *[other] {$place}\n+    } because it is borrowed\n+    .label = borrow of {$borrow_place ->\n+        [value] value\n+        *[other] {$borrow_place}\n+    } occurs here\n+    .move_label = move out of {$value_place ->\n+        [value] value\n+        *[other] {$value_place}\n+    } occurs here\n \n borrowck_capture_immute =\n     capture is immutable because of use here\n \n-borrowck_capture_mut =\n-    capture is mutable because of use here\n-\n borrowck_capture_move =\n     capture is moved because of use here\n \n-borrowck_var_borrow_by_use_place_in_generator =\n-    {$is_single_var ->\n-        *[true] borrow occurs\n-        [false] borrows occur\n-    } due to use of {$place} in generator\n-\n-borrowck_var_borrow_by_use_place_in_closure =\n-    {$is_single_var ->\n-        *[true] borrow occurs\n-        [false] borrows occur\n-    } due to use of {$place} in closure\n+borrowck_capture_mut =\n+    capture is mutable because of use here\n \n-borrowck_var_borrow_by_use_in_generator =\n-    borrow occurs due to use in generator\n+borrowck_closure_inferred_mut = inferred to be a `FnMut` closure\n \n-borrowck_var_borrow_by_use_in_closure =\n-    borrow occurs due to use in closure\n+borrowck_closure_invoked_twice =\n+    closure cannot be invoked more than once because it moves the variable `{$place_name}` out of its environment\n \n-borrowck_var_move_by_use_place_in_generator =\n-    move occurs due to use of {$place} in generator\n+borrowck_closure_moved_twice =\n+    closure cannot be moved more than once as it is not `Copy` due to moving the variable `{$place_name}` out of its environment\n \n-borrowck_var_move_by_use_place_in_closure =\n-    move occurs due to use of {$place} in closure\n+borrowck_consider_borrow_type_contents =\n+    help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\n \n-borrowck_var_move_by_use_in_generator =\n-    move occurs due to use in generator\n+borrowck_could_not_normalize =\n+    could not normalize `{$value}`\n \n-borrowck_var_move_by_use_in_closure =\n-    move occurs due to use in closure\n+borrowck_could_not_prove =\n+    could not prove `{$predicate}`\n \n-borrowck_partial_var_move_by_use_in_generator =\n-    variable {$is_partial ->\n-        [true] partially moved\n-        *[false] moved\n-    } due to use in generator\n+borrowck_func_take_self_moved_place =\n+    `{$func}` takes ownership of the receiver `self`, which moves {$place_name}\n \n-borrowck_partial_var_move_by_use_in_closure =\n-    variable {$is_partial ->\n-        [true] partially moved\n-        *[false] moved\n-    } due to use in closure\n+borrowck_generic_does_not_live_long_enough =\n+    `{$kind}` does not live long enough\n \n-borrowck_var_first_borrow_by_use_place_in_generator =\n-    first borrow occurs due to use of {$place} in generator\n+borrowck_higher_ranked_lifetime_error =\n+    higher-ranked lifetime error\n \n-borrowck_var_first_borrow_by_use_place_in_closure =\n-    first borrow occurs due to use of {$place} in closure\n+borrowck_higher_ranked_subtype_error =\n+    higher-ranked subtype error\n \n-borrowck_var_second_borrow_by_use_place_in_generator =\n-    second borrow occurs due to use of {$place} in generator\n+borrowck_lifetime_constraints_error =\n+    lifetime may not live long enough\n \n-borrowck_var_second_borrow_by_use_place_in_closure =\n-    second borrow occurs due to use of {$place} in closure\n+borrowck_move_borrowed =\n+    cannot move out of `{$desc}` because it is borrowed\n \n-borrowck_var_mutable_borrow_by_use_place_in_closure =\n-    mutable borrow occurs due to use of {$place} in closure\n+borrowck_move_out_place_here =\n+    {$place} is moved here\n \n-borrowck_cannot_move_when_borrowed =\n-    cannot move out of {$place ->\n-        [value] value\n-        *[other] {$place}\n-    } because it is borrowed\n-    .label = borrow of {$borrow_place ->\n-        [value] value\n-        *[other] {$borrow_place}\n-    } occurs here\n-    .move_label = move out of {$value_place ->\n-        [value] value\n-        *[other] {$value_place}\n-    } occurs here\n+borrowck_move_unsized =\n+    cannot move a value of type `{$ty}`\n+    .label = the size of `{$ty}` cannot be statically determined\n \n-borrowck_opaque_type_non_generic_param =\n-    expected generic {$kind} parameter, found `{$ty}`\n-    .label = {STREQ($ty, \"'static\") ->\n-        [true] cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n-        *[other] this generic parameter must be used with a generic {$kind} parameter\n-    }\n+borrowck_moved_a_fn_once_in_call =\n+    this value implements `FnOnce`, which causes it to be moved when called\n \n-borrowck_moved_due_to_call =\n+borrowck_moved_due_to_await =\n     {$place_name} {$is_partial ->\n         [true] partially moved\n         *[false] moved\n     } due to this {$is_loop_message ->\n-        [true] call, in previous iteration of loop\n-        *[false] call\n+        [true] await, in previous iteration of loop\n+        *[false] await\n     }\n \n-borrowck_moved_due_to_usage_in_operator =\n+borrowck_moved_due_to_call =\n     {$place_name} {$is_partial ->\n         [true] partially moved\n         *[false] moved\n-    } due to usage in {$is_loop_message ->\n-        [true] operator, in previous iteration of loop\n-        *[false] operator\n+    } due to this {$is_loop_message ->\n+        [true] call, in previous iteration of loop\n+        *[false] call\n     }\n \n borrowck_moved_due_to_implicit_into_iter_call =\n@@ -203,13 +123,74 @@ borrowck_moved_due_to_method_call =\n         *[false] call\n     }\n \n-borrowck_moved_due_to_await =\n+borrowck_moved_due_to_usage_in_operator =\n     {$place_name} {$is_partial ->\n         [true] partially moved\n         *[false] moved\n-    } due to this {$is_loop_message ->\n-        [true] await, in previous iteration of loop\n-        *[false] await\n+    } due to usage in {$is_loop_message ->\n+        [true] operator, in previous iteration of loop\n+        *[false] operator\n+    }\n+\n+borrowck_opaque_type_non_generic_param =\n+    expected generic {$kind} parameter, found `{$ty}`\n+    .label = {STREQ($ty, \"'static\") ->\n+        [true] cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type\n+        *[other] this generic parameter must be used with a generic {$kind} parameter\n+    }\n+\n+borrowck_partial_var_move_by_use_in_closure =\n+    variable {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to use in closure\n+\n+borrowck_partial_var_move_by_use_in_generator =\n+    variable {$is_partial ->\n+        [true] partially moved\n+        *[false] moved\n+    } due to use in generator\n+\n+borrowck_returned_async_block_escaped =\n+    returns an `async` block that contains a reference to a captured variable, which then escapes the closure body\n+\n+borrowck_returned_closure_escaped =\n+    returns a closure that contains a reference to a captured variable, which then escapes the closure body\n+\n+borrowck_returned_lifetime_short =\n+    {$category_desc}requires that `{$free_region_name}` must outlive `{$outlived_fr_name}`\n+\n+borrowck_returned_lifetime_wrong =\n+    {$mir_def_name} was supposed to return data with lifetime `{$outlived_fr_name}` but it is returning data with lifetime `{$fr_name}`\n+\n+borrowck_returned_ref_escaped =\n+    returns a reference to a captured variable which escapes the closure body\n+\n+borrowck_suggest_create_freash_reborrow =\n+    consider reborrowing the `Pin` instead of moving it\n+\n+borrowck_suggest_iterate_over_slice =\n+    consider iterating over a slice of the `{$ty}`'s content to avoid moving into the `for` loop\n+\n+borrowck_ty_no_impl_copy =\n+    {$is_partial_move ->\n+        [true] partial move\n+        *[false] move\n+    } occurs because {$place} has type `{$ty}`, which does not implement the `Copy` trait\n+\n+borrowck_use_due_to_use_closure =\n+    use occurs due to use in closure\n+\n+borrowck_use_due_to_use_generator =\n+    use occurs due to use in generator\n+\n+borrowck_used_impl_require_static =\n+    the used `impl` has a `'static` requirement\n+\n+borrowck_value_capture_here =\n+    value captured {$is_within ->\n+        [true] here by generator\n+        *[false] here\n     }\n \n borrowck_value_moved_here =\n@@ -224,41 +205,60 @@ borrowck_value_moved_here =\n         *[false] {\"\"}\n     }\n \n-borrowck_consider_borrow_type_contents =\n-    help: consider calling `.as_ref()` or `.as_mut()` to borrow the type's contents\n+borrowck_var_borrow_by_use_in_closure =\n+    borrow occurs due to use in closure\n \n-borrowck_moved_a_fn_once_in_call =\n-    this value implements `FnOnce`, which causes it to be moved when called\n+borrowck_var_borrow_by_use_in_generator =\n+    borrow occurs due to use in generator\n \n-borrowck_calling_operator_moves_lhs =\n-    calling this operator moves the left-hand side\n+borrowck_var_borrow_by_use_place_in_closure =\n+    {$is_single_var ->\n+        *[true] borrow occurs\n+        [false] borrows occur\n+    } due to use of {$place} in closure\n \n-borrowck_func_take_self_moved_place =\n-    `{$func}` takes ownership of the receiver `self`, which moves {$place_name}\n+borrowck_var_borrow_by_use_place_in_generator =\n+    {$is_single_var ->\n+        *[true] borrow occurs\n+        [false] borrows occur\n+    } due to use of {$place} in generator\n \n-borrowck_suggest_iterate_over_slice =\n-    consider iterating over a slice of the `{$ty}`'s content to avoid moving into the `for` loop\n+borrowck_var_cannot_escape_closure =\n+    captured variable cannot escape `FnMut` closure body\n+    .note = `FnMut` closures only have access to their captured variables while they are executing...\n+    .cannot_escape = ...therefore, they cannot allow references to captured variables to escape\n \n-borrowck_suggest_create_freash_reborrow =\n-    consider reborrowing the `Pin` instead of moving it\n+borrowck_var_does_not_need_mut =\n+    variable does not need to be mutable\n+    .suggestion = remove this `mut`\n \n-borrowck_value_capture_here =\n-    value captured {$is_within ->\n-        [true] here by generator\n-        *[false] here\n-    }\n+borrowck_var_first_borrow_by_use_place_in_closure =\n+    first borrow occurs due to use of {$place} in closure\n \n-borrowck_move_out_place_here =\n-    {$place} is moved here\n+borrowck_var_first_borrow_by_use_place_in_generator =\n+    first borrow occurs due to use of {$place} in generator\n \n-borrowck_closure_invoked_twice =\n-    closure cannot be invoked more than once because it moves the variable `{$place_name}` out of its environment\n+borrowck_var_here_captured = variable captured here\n \n-borrowck_closure_moved_twice =\n-    closure cannot be moved more than once as it is not `Copy` due to moving the variable `{$place_name}` out of its environment\n+borrowck_var_here_defined = variable defined here\n \n-borrowck_ty_no_impl_copy =\n-    {$is_partial_move ->\n-        [true] partial move\n-        *[false] move\n-    } occurs because {$place} has type `{$ty}`, which does not implement the `Copy` trait\n+borrowck_var_move_by_use_in_closure =\n+    move occurs due to use in closure\n+\n+borrowck_var_move_by_use_in_generator =\n+    move occurs due to use in generator\n+\n+borrowck_var_move_by_use_place_in_closure =\n+    move occurs due to use of {$place} in closure\n+\n+borrowck_var_move_by_use_place_in_generator =\n+    move occurs due to use of {$place} in generator\n+\n+borrowck_var_mutable_borrow_by_use_place_in_closure =\n+    mutable borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_second_borrow_by_use_place_in_closure =\n+    second borrow occurs due to use of {$place} in closure\n+\n+borrowck_var_second_borrow_by_use_place_in_generator =\n+    second borrow occurs due to use of {$place} in generator"}, {"sha": "6be20b0974ddb6c74e74650401b72dc2da8bf533", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -30,7 +30,7 @@ pub struct BorrowSet<'tcx> {\n     /// Map from local to all the borrows on that local.\n     pub local_map: FxIndexMap<mir::Local, FxIndexSet<BorrowIndex>>,\n \n-    pub(crate) locals_state_at_exit: LocalsStateAtExit,\n+    pub locals_state_at_exit: LocalsStateAtExit,\n }\n \n impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n@@ -153,7 +153,7 @@ impl<'tcx> BorrowSet<'tcx> {\n         self.activation_map.get(&location).map_or(&[], |activations| &activations[..])\n     }\n \n-    pub(crate) fn len(&self) -> usize {\n+    pub fn len(&self) -> usize {\n         self.location_map.len()\n     }\n "}, {"sha": "d257145373f72e9a562c4f7802771b966387c2d0", "filename": "compiler/rustc_borrowck/src/consumers.rs", "status": "modified", "additions": 88, "deletions": 10, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fconsumers.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -3,22 +3,96 @@\n //! This file provides API for compiler consumers.\n \n use rustc_hir::def_id::LocalDefId;\n-use rustc_index::IndexSlice;\n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n-use rustc_middle::mir::Body;\n+use rustc_index::{IndexSlice, IndexVec};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::mir::{Body, Promoted};\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::TyCtxt;\n+use std::rc::Rc;\n+\n+use crate::borrow_set::BorrowSet;\n \n pub use super::{\n+    constraints::OutlivesConstraint,\n+    dataflow::{calculate_borrows_out_of_scope_at_location, BorrowIndex, Borrows},\n     facts::{AllFacts as PoloniusInput, RustcFacts},\n     location::{LocationTable, RichLocation},\n     nll::PoloniusOutput,\n-    BodyWithBorrowckFacts,\n+    place_ext::PlaceExt,\n+    places_conflict::{places_conflict, PlaceConflictBias},\n+    region_infer::RegionInferenceContext,\n };\n \n-/// This function computes Polonius facts for the given body. It makes a copy of\n-/// the body because it needs to regenerate the region identifiers. This function\n-/// should never be invoked during a typical compilation session due to performance\n-/// issues with Polonius.\n+/// Options determining the output behavior of [`get_body_with_borrowck_facts`].\n+///\n+/// If executing under `-Z polonius` the choice here has no effect, and everything as if\n+/// [`PoloniusOutputFacts`](ConsumerOptions::PoloniusOutputFacts) had been selected\n+/// will be retrieved.\n+#[derive(Debug, Copy, Clone)]\n+pub enum ConsumerOptions {\n+    /// Retrieve the [`Body`] along with the [`BorrowSet`](super::borrow_set::BorrowSet)\n+    /// and [`RegionInferenceContext`]. If you would like the body only, use\n+    /// [`TyCtxt::mir_promoted`].\n+    ///\n+    /// These can be used in conjunction with [`calculate_borrows_out_of_scope_at_location`].\n+    RegionInferenceContext,\n+    /// The recommended option. Retrieves the maximal amount of information\n+    /// without significant slowdowns.\n+    ///\n+    /// Implies [`RegionInferenceContext`](ConsumerOptions::RegionInferenceContext),\n+    /// and additionally retrieve the [`LocationTable`] and [`PoloniusInput`] that\n+    /// would be given to Polonius. Critically, this does not run Polonius, which\n+    /// one may want to avoid due to performance issues on large bodies.\n+    PoloniusInputFacts,\n+    /// Implies [`PoloniusInputFacts`](ConsumerOptions::PoloniusInputFacts),\n+    /// and additionally runs Polonius to calculate the [`PoloniusOutput`].\n+    PoloniusOutputFacts,\n+}\n+\n+impl ConsumerOptions {\n+    /// Should the Polonius input facts be computed?\n+    pub(crate) fn polonius_input(&self) -> bool {\n+        matches!(self, Self::PoloniusInputFacts | Self::PoloniusOutputFacts)\n+    }\n+    /// Should we run Polonius and collect the output facts?\n+    pub(crate) fn polonius_output(&self) -> bool {\n+        matches!(self, Self::PoloniusOutputFacts)\n+    }\n+}\n+\n+/// A `Body` with information computed by the borrow checker. This struct is\n+/// intended to be consumed by compiler consumers.\n+///\n+/// We need to include the MIR body here because the region identifiers must\n+/// match the ones in the Polonius facts.\n+pub struct BodyWithBorrowckFacts<'tcx> {\n+    /// A mir body that contains region identifiers.\n+    pub body: Body<'tcx>,\n+    /// The mir bodies of promoteds.\n+    pub promoted: IndexVec<Promoted, Body<'tcx>>,\n+    /// The set of borrows occurring in `body` with data about them.\n+    pub borrow_set: Rc<BorrowSet<'tcx>>,\n+    /// Context generated during borrowck, intended to be passed to\n+    /// [`calculate_borrows_out_of_scope_at_location`].\n+    pub region_inference_context: Rc<RegionInferenceContext<'tcx>>,\n+    /// The table that maps Polonius points to locations in the table.\n+    /// Populated when using [`ConsumerOptions::PoloniusInputFacts`]\n+    /// or [`ConsumerOptions::PoloniusOutputFacts`].\n+    pub location_table: Option<LocationTable>,\n+    /// Polonius input facts.\n+    /// Populated when using [`ConsumerOptions::PoloniusInputFacts`]\n+    /// or [`ConsumerOptions::PoloniusOutputFacts`].\n+    pub input_facts: Option<Box<PoloniusInput>>,\n+    /// Polonius output facts. Populated when using\n+    /// [`ConsumerOptions::PoloniusOutputFacts`].\n+    pub output_facts: Option<Rc<PoloniusOutput>>,\n+}\n+\n+/// This function computes borrowck facts for the given body. The [`ConsumerOptions`]\n+/// determine which facts are returned. This function makes a copy of the body because\n+/// it needs to regenerate the region identifiers. It should never be invoked during a\n+/// typical compilation session due to the unnecessary overhead of returning\n+/// [`BodyWithBorrowckFacts`].\n ///\n /// Note:\n /// *   This function will panic if the required body was already stolen. This\n@@ -28,10 +102,14 @@ pub use super::{\n ///     that shows how to do this at `tests/run-make/obtain-borrowck/`.\n ///\n /// *   Polonius is highly unstable, so expect regular changes in its signature or other details.\n-pub fn get_body_with_borrowck_facts(tcx: TyCtxt<'_>, def: LocalDefId) -> BodyWithBorrowckFacts<'_> {\n+pub fn get_body_with_borrowck_facts(\n+    tcx: TyCtxt<'_>,\n+    def: LocalDefId,\n+    options: ConsumerOptions,\n+) -> BodyWithBorrowckFacts<'_> {\n     let (input_body, promoted) = tcx.mir_promoted(def);\n     let infcx = tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(def)).build();\n     let input_body: &Body<'_> = &input_body.borrow();\n     let promoted: &IndexSlice<_, _> = &promoted.borrow();\n-    *super::do_mir_borrowck(&infcx, input_body, promoted, true).1.unwrap()\n+    *super::do_mir_borrowck(&infcx, input_body, promoted, Some(options)).1.unwrap()\n }"}, {"sha": "2daa82aef39577dffab0dc4ae78410da408dc41e", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 66, "deletions": 64, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -156,10 +156,10 @@ impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n         &mut self,\n         borrow_index: BorrowIndex,\n         borrow_region: RegionVid,\n-        location: Location,\n+        first_location: Location,\n     ) {\n         // We visit one BB at a time. The complication is that we may start in the\n-        // middle of the first BB visited (the one containing `location`), in which\n+        // middle of the first BB visited (the one containing `first_location`), in which\n         // case we may have to later on process the first part of that BB if there\n         // is a path back to its start.\n \n@@ -168,61 +168,58 @@ impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n         // `visited` once they are added to `stack`, before they are actually\n         // processed, because this avoids the need to look them up again on\n         // completion.\n-        self.visited.insert(location.block);\n+        self.visited.insert(first_location.block);\n \n-        let mut first_lo = location.statement_index;\n-        let first_hi = self.body[location.block].statements.len();\n+        let first_block = first_location.block;\n+        let mut first_lo = first_location.statement_index;\n+        let first_hi = self.body[first_block].statements.len();\n \n-        self.visit_stack.push(StackEntry { bb: location.block, lo: first_lo, hi: first_hi });\n+        self.visit_stack.push(StackEntry { bb: first_block, lo: first_lo, hi: first_hi });\n \n-        while let Some(StackEntry { bb, lo, hi }) = self.visit_stack.pop() {\n-            // If we process the first part of the first basic block (i.e. we encounter that block\n-            // for the second time), we no longer have to visit its successors again.\n-            let mut finished_early = bb == location.block && hi != first_hi;\n-            for i in lo..=hi {\n-                let location = Location { block: bb, statement_index: i };\n+        'preorder: while let Some(StackEntry { bb, lo, hi }) = self.visit_stack.pop() {\n+            if let Some(kill_stmt) =\n+                self.regioncx.first_non_contained_inclusive(borrow_region, bb, lo, hi)\n+            {\n+                let kill_location = Location { block: bb, statement_index: kill_stmt };\n                 // If region does not contain a point at the location, then add to list and skip\n                 // successor locations.\n-                if !self.regioncx.region_contains(borrow_region, location) {\n-                    debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n-                    self.borrows_out_of_scope_at_location\n-                        .entry(location)\n-                        .or_default()\n-                        .push(borrow_index);\n-                    finished_early = true;\n-                    break;\n-                }\n+                debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, kill_location);\n+                self.borrows_out_of_scope_at_location\n+                    .entry(kill_location)\n+                    .or_default()\n+                    .push(borrow_index);\n+                continue 'preorder;\n             }\n \n-            if !finished_early {\n-                // Add successor BBs to the work list, if necessary.\n-                let bb_data = &self.body[bb];\n-                debug_assert!(hi == bb_data.statements.len());\n-                for succ_bb in bb_data.terminator().successors() {\n-                    if !self.visited.insert(succ_bb) {\n-                        if succ_bb == location.block && first_lo > 0 {\n-                            // `succ_bb` has been seen before. If it wasn't\n-                            // fully processed, add its first part to `stack`\n-                            // for processing.\n-                            self.visit_stack.push(StackEntry {\n-                                bb: succ_bb,\n-                                lo: 0,\n-                                hi: first_lo - 1,\n-                            });\n-\n-                            // And update this entry with 0, to represent the\n-                            // whole BB being processed.\n-                            first_lo = 0;\n-                        }\n-                    } else {\n-                        // succ_bb hasn't been seen before. Add it to\n-                        // `stack` for processing.\n-                        self.visit_stack.push(StackEntry {\n-                            bb: succ_bb,\n-                            lo: 0,\n-                            hi: self.body[succ_bb].statements.len(),\n-                        });\n+            // If we process the first part of the first basic block (i.e. we encounter that block\n+            // for the second time), we no longer have to visit its successors again.\n+            if bb == first_block && hi != first_hi {\n+                continue;\n+            }\n+\n+            // Add successor BBs to the work list, if necessary.\n+            let bb_data = &self.body[bb];\n+            debug_assert!(hi == bb_data.statements.len());\n+            for succ_bb in bb_data.terminator().successors() {\n+                if !self.visited.insert(succ_bb) {\n+                    if succ_bb == first_block && first_lo > 0 {\n+                        // `succ_bb` has been seen before. If it wasn't\n+                        // fully processed, add its first part to `stack`\n+                        // for processing.\n+                        self.visit_stack.push(StackEntry { bb: succ_bb, lo: 0, hi: first_lo - 1 });\n+\n+                        // And update this entry with 0, to represent the\n+                        // whole BB being processed.\n+                        first_lo = 0;\n                     }\n+                } else {\n+                    // succ_bb hasn't been seen before. Add it to\n+                    // `stack` for processing.\n+                    self.visit_stack.push(StackEntry {\n+                        bb: succ_bb,\n+                        lo: 0,\n+                        hi: self.body[succ_bb].statements.len(),\n+                    });\n                 }\n             }\n         }\n@@ -231,27 +228,32 @@ impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n     }\n }\n \n+pub fn calculate_borrows_out_of_scope_at_location<'tcx>(\n+    body: &Body<'tcx>,\n+    regioncx: &RegionInferenceContext<'tcx>,\n+    borrow_set: &BorrowSet<'tcx>,\n+) -> FxIndexMap<Location, Vec<BorrowIndex>> {\n+    let mut prec = OutOfScopePrecomputer::new(body, regioncx);\n+    for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n+        let borrow_region = borrow_data.region;\n+        let location = borrow_data.reserve_location;\n+\n+        prec.precompute_borrows_out_of_scope(borrow_index, borrow_region, location);\n+    }\n+\n+    prec.borrows_out_of_scope_at_location\n+}\n+\n impl<'a, 'tcx> Borrows<'a, 'tcx> {\n-    pub(crate) fn new(\n+    pub fn new(\n         tcx: TyCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n         nonlexical_regioncx: &'a RegionInferenceContext<'tcx>,\n         borrow_set: &'a BorrowSet<'tcx>,\n     ) -> Self {\n-        let mut prec = OutOfScopePrecomputer::new(body, nonlexical_regioncx);\n-        for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n-            let borrow_region = borrow_data.region;\n-            let location = borrow_data.reserve_location;\n-\n-            prec.precompute_borrows_out_of_scope(borrow_index, borrow_region, location);\n-        }\n-\n-        Borrows {\n-            tcx,\n-            body,\n-            borrow_set,\n-            borrows_out_of_scope_at_location: prec.borrows_out_of_scope_at_location,\n-        }\n+        let borrows_out_of_scope_at_location =\n+            calculate_borrows_out_of_scope_at_location(body, nonlexical_regioncx, borrow_set);\n+        Borrows { tcx, body, borrow_set, borrows_out_of_scope_at_location }\n     }\n \n     pub fn location(&self, idx: BorrowIndex) -> &Location {"}, {"sha": "f41795d60a0b4d219c2454888a6e6d7b488f66ee", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> ToUniverseInfo<'tcx>\n     }\n }\n \n-impl<'tcx, F, G> ToUniverseInfo<'tcx> for Canonical<'tcx, type_op::custom::CustomTypeOp<F, G>> {\n+impl<'tcx, F> ToUniverseInfo<'tcx> for Canonical<'tcx, type_op::custom::CustomTypeOp<F>> {\n     fn to_universe_info(self, _base_universe: ty::UniverseIndex) -> UniverseInfo<'tcx> {\n         // We can't rerun custom type ops.\n         UniverseInfo::other()"}, {"sha": "1d430a93a876d2c9588f2c50d7a52e7223977fc2", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -118,7 +118,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                     let path_span = path_span.unwrap();\n                     // path_span is only present in the case of closure capture\n                     assert!(matches!(later_use_kind, LaterUseKind::ClosureCapture));\n-                    if !borrow_span.map_or(false, |sp| sp.overlaps(var_or_use_span)) {\n+                    if !borrow_span.is_some_and(|sp| sp.overlaps(var_or_use_span)) {\n                         let path_label = \"used here by closure\";\n                         let capture_kind_label = message;\n                         err.span_label(\n@@ -224,12 +224,9 @@ impl<'tcx> BorrowExplanation<'tcx> {\n                             if info.tail_result_is_ignored {\n                                 // #85581: If the first mutable borrow's scope contains\n                                 // the second borrow, this suggestion isn't helpful.\n-                                if !multiple_borrow_span\n-                                    .map(|(old, new)| {\n-                                        old.to(info.span.shrink_to_hi()).contains(new)\n-                                    })\n-                                    .unwrap_or(false)\n-                                {\n+                                if !multiple_borrow_span.is_some_and(|(old, new)| {\n+                                    old.to(info.span.shrink_to_hi()).contains(new)\n+                                }) {\n                                     err.span_suggestion_verbose(\n                                         info.span.shrink_to_hi(),\n                                         \"consider adding semicolon after the expression so its \\"}, {"sha": "20370e4c6ac3cc17ff84876ab31bfeda4f5d9c4c", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1156,7 +1156,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 ty::Adt(def, ..) => Some(def.did()),\n                                 _ => None,\n                             });\n-                    let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n+                    let is_option_or_result = parent_self_ty.is_some_and(|def_id| {\n                         matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n                     });\n                     if is_option_or_result && maybe_reinitialized_locations_is_empty {"}, {"sha": "4bde372c847dd1b169ac2d3469f834430ec4c304", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -289,8 +289,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .body\n                     .local_decls\n                     .get(local)\n-                    .map(|l| mut_borrow_of_mutable_ref(l, self.local_names[local]))\n-                    .unwrap_or(false) =>\n+                    .is_some_and(|l| mut_borrow_of_mutable_ref(l, self.local_names[local])) =>\n             {\n                 let decl = &self.body.local_decls[local];\n                 err.span_label(span, format!(\"cannot {act}\"));\n@@ -443,7 +442,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .sess\n                     .source_map()\n                     .span_to_snippet(span)\n-                    .map_or(false, |snippet| snippet.starts_with(\"&mut \")) =>\n+                    .is_ok_and(|snippet| snippet.starts_with(\"&mut \")) =>\n             {\n                 err.span_label(span, format!(\"cannot {act}\"));\n                 err.span_suggestion("}, {"sha": "b6eb9ae980e4e28501d68ad28e8e91994ef76f03", "filename": "compiler/rustc_borrowck/src/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Foutlives_suggestion.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -125,8 +125,7 @@ impl OutlivesSuggestionBuilder {\n                     |(r, _)| {\n                         self.constraints_to_add\n                             .get(r)\n-                            .map(|r_outlived| r_outlived.as_slice().contains(fr))\n-                            .unwrap_or(false)\n+                            .is_some_and(|r_outlived| r_outlived.as_slice().contains(fr))\n                     },\n                 );\n "}, {"sha": "036391d074da846be9df2f31310b115aaebeec07", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -46,7 +46,7 @@ struct InvalidationGenerator<'cx, 'tcx> {\n     all_facts: &'cx mut AllFacts,\n     location_table: &'cx LocationTable,\n     body: &'cx Body<'tcx>,\n-    dominators: Dominators<BasicBlock>,\n+    dominators: &'cx Dominators<BasicBlock>,\n     borrow_set: &'cx BorrowSet<'tcx>,\n }\n "}, {"sha": "9277a262f97891e18c7036c5cc6f1ab63e3e4d2f", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -26,7 +26,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_index::bit_set::ChunkedBitSet;\n use rustc_index::{IndexSlice, IndexVec};\n use rustc_infer::infer::{\n-    DefiningAnchor, InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin, TyCtxtInferExt,\n+    InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin, TyCtxtInferExt,\n };\n use rustc_middle::mir::{\n     traversal, Body, ClearCrossCrate, Local, Location, Mutability, NonDivergingIntrinsic, Operand,\n@@ -36,14 +36,14 @@ use rustc_middle::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind\n use rustc_middle::mir::{InlineAsmOperand, Terminator, TerminatorKind};\n use rustc_middle::mir::{ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n use rustc_middle::query::Providers;\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::{self, CapturedPlace, ParamEnv, RegionVid, TyCtxt};\n use rustc_session::lint::builtin::UNUSED_MUT;\n use rustc_span::{Span, Symbol};\n use rustc_target::abi::FieldIdx;\n \n use either::Either;\n use smallvec::SmallVec;\n-use std::cell::OnceCell;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n use std::ops::Deref;\n@@ -62,7 +62,7 @@ use crate::session_diagnostics::VarNeedNotMut;\n use self::diagnostics::{AccessKind, RegionName};\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n-use facts::AllFacts;\n+use consumers::{BodyWithBorrowckFacts, ConsumerOptions};\n \n use self::path_utils::*;\n \n@@ -144,23 +144,23 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def: LocalDefId) -> &BorrowCheckResult<'_> {\n         tcx.infer_ctxt().with_opaque_type_inference(DefiningAnchor::Bind(hir_owner.def_id)).build();\n     let input_body: &Body<'_> = &input_body.borrow();\n     let promoted: &IndexSlice<_, _> = &promoted.borrow();\n-    let opt_closure_req = do_mir_borrowck(&infcx, input_body, promoted, false).0;\n+    let opt_closure_req = do_mir_borrowck(&infcx, input_body, promoted, None).0;\n     debug!(\"mir_borrowck done\");\n \n     tcx.arena.alloc(opt_closure_req)\n }\n \n /// Perform the actual borrow checking.\n ///\n-/// If `return_body_with_facts` is true, then return the body with non-erased\n-/// region ids on which the borrow checking was performed together with Polonius\n-/// facts.\n+/// Use `consumer_options: None` for the default behavior of returning\n+/// [`BorrowCheckResult`] only. Otherwise, return [`BodyWithBorrowckFacts`] according\n+/// to the given [`ConsumerOptions`].\n #[instrument(skip(infcx, input_body, input_promoted), fields(id=?input_body.source.def_id()), level = \"debug\")]\n fn do_mir_borrowck<'tcx>(\n     infcx: &InferCtxt<'tcx>,\n     input_body: &Body<'tcx>,\n     input_promoted: &IndexSlice<Promoted, Body<'tcx>>,\n-    return_body_with_facts: bool,\n+    consumer_options: Option<ConsumerOptions>,\n ) -> (BorrowCheckResult<'tcx>, Option<Box<BodyWithBorrowckFacts<'tcx>>>) {\n     let def = input_body.source.def_id().expect_local();\n     debug!(?def);\n@@ -241,8 +241,6 @@ fn do_mir_borrowck<'tcx>(\n     let borrow_set =\n         Rc::new(BorrowSet::build(tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n-    let use_polonius = return_body_with_facts || infcx.tcx.sess.opts.unstable_opts.polonius;\n-\n     // Compute non-lexical lifetimes.\n     let nll::NllOutput {\n         regioncx,\n@@ -262,7 +260,7 @@ fn do_mir_borrowck<'tcx>(\n         &mdpe.move_data,\n         &borrow_set,\n         &upvars,\n-        use_polonius,\n+        consumer_options,\n     );\n \n     // Dump MIR results into a file, if that is enabled. This let us\n@@ -331,7 +329,6 @@ fn do_mir_borrowck<'tcx>(\n                 used_mut: Default::default(),\n                 used_mut_upvars: SmallVec::new(),\n                 borrow_set: Rc::clone(&borrow_set),\n-                dominators: Default::default(),\n                 upvars: Vec::new(),\n                 local_names: IndexVec::from_elem(None, &promoted_body.local_decls),\n                 region_names: RefCell::default(),\n@@ -360,7 +357,6 @@ fn do_mir_borrowck<'tcx>(\n         used_mut: Default::default(),\n         used_mut_upvars: SmallVec::new(),\n         borrow_set: Rc::clone(&borrow_set),\n-        dominators: Default::default(),\n         upvars,\n         local_names,\n         region_names: RefCell::default(),\n@@ -444,13 +440,16 @@ fn do_mir_borrowck<'tcx>(\n         tainted_by_errors,\n     };\n \n-    let body_with_facts = if return_body_with_facts {\n-        let output_facts = mbcx.polonius_output.expect(\"Polonius output was not computed\");\n+    let body_with_facts = if consumer_options.is_some() {\n+        let output_facts = mbcx.polonius_output;\n         Some(Box::new(BodyWithBorrowckFacts {\n             body: body_owned,\n-            input_facts: *polonius_input.expect(\"Polonius input facts were not generated\"),\n+            promoted,\n+            borrow_set,\n+            region_inference_context: regioncx,\n+            location_table: polonius_input.as_ref().map(|_| location_table_owned),\n+            input_facts: polonius_input,\n             output_facts,\n-            location_table: location_table_owned,\n         }))\n     } else {\n         None\n@@ -461,22 +460,6 @@ fn do_mir_borrowck<'tcx>(\n     (result, body_with_facts)\n }\n \n-/// A `Body` with information computed by the borrow checker. This struct is\n-/// intended to be consumed by compiler consumers.\n-///\n-/// We need to include the MIR body here because the region identifiers must\n-/// match the ones in the Polonius facts.\n-pub struct BodyWithBorrowckFacts<'tcx> {\n-    /// A mir body that contains region identifiers.\n-    pub body: Body<'tcx>,\n-    /// Polonius input facts.\n-    pub input_facts: AllFacts,\n-    /// Polonius output facts.\n-    pub output_facts: Rc<self::nll::PoloniusOutput>,\n-    /// The table that maps Polonius points to locations in the table.\n-    pub location_table: LocationTable,\n-}\n-\n pub struct BorrowckInferCtxt<'cx, 'tcx> {\n     pub(crate) infcx: &'cx InferCtxt<'tcx>,\n     pub(crate) reg_var_to_origin: RefCell<FxIndexMap<ty::RegionVid, RegionCtxt>>,\n@@ -591,9 +574,6 @@ struct MirBorrowckCtxt<'cx, 'tcx> {\n     /// The set of borrows extracted from the MIR\n     borrow_set: Rc<BorrowSet<'tcx>>,\n \n-    /// Dominators for MIR\n-    dominators: OnceCell<Dominators<BasicBlock>>,\n-\n     /// Information about upvars not necessarily preserved in types or MIR\n     upvars: Vec<Upvar<'tcx>>,\n \n@@ -2269,7 +2249,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n \n     fn dominators(&self) -> &Dominators<BasicBlock> {\n-        self.dominators.get_or_init(|| self.body.basic_blocks.dominators())\n+        // `BasicBlocks` computes dominators on-demand and caches them.\n+        self.body.basic_blocks.dominators()\n     }\n }\n "}, {"sha": "889acb3acbed7579183ead34a160356bab333fe1", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -27,6 +27,7 @@ use rustc_mir_dataflow::ResultsCursor;\n use crate::{\n     borrow_set::BorrowSet,\n     constraint_generation,\n+    consumers::ConsumerOptions,\n     diagnostics::RegionErrors,\n     facts::{AllFacts, AllFactsExt, RustcFacts},\n     invalidation,\n@@ -165,10 +166,14 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n     upvars: &[Upvar<'tcx>],\n-    use_polonius: bool,\n+    consumer_options: Option<ConsumerOptions>,\n ) -> NllOutput<'tcx> {\n+    let polonius_input = consumer_options.map(|c| c.polonius_input()).unwrap_or_default()\n+        || infcx.tcx.sess.opts.unstable_opts.polonius;\n+    let polonius_output = consumer_options.map(|c| c.polonius_output()).unwrap_or_default()\n+        || infcx.tcx.sess.opts.unstable_opts.polonius;\n     let mut all_facts =\n-        (use_polonius || AllFacts::enabled(infcx.tcx)).then_some(AllFacts::default());\n+        (polonius_input || AllFacts::enabled(infcx.tcx)).then_some(AllFacts::default());\n \n     let universal_regions = Rc::new(universal_regions);\n \n@@ -189,7 +194,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n             move_data,\n             elements,\n             upvars,\n-            use_polonius,\n+            polonius_input,\n         );\n \n     if let Some(all_facts) = &mut all_facts {\n@@ -284,7 +289,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n             all_facts.write_to_dir(dir_path, location_table).unwrap();\n         }\n \n-        if use_polonius {\n+        if polonius_output {\n             let algorithm =\n                 env::var(\"POLONIUS_ALGORITHM\").unwrap_or_else(|_| String::from(\"Hybrid\"));\n             let algorithm = Algorithm::from_str(&algorithm).unwrap();"}, {"sha": "d521d0db21323df8526d25c5309cf5302f122dc3", "filename": "compiler/rustc_borrowck/src/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::mir::{Body, Mutability, Place};\n use rustc_middle::ty::{self, TyCtxt};\n \n /// Extension methods for the `Place` type.\n-pub(crate) trait PlaceExt<'tcx> {\n+pub trait PlaceExt<'tcx> {\n     /// Returns `true` if we can safely ignore borrows of this place.\n     /// This is true whenever there is no action that the user can do\n     /// to the place `self` that would invalidate the borrow. This is true"}, {"sha": "25c485b814f4a1ae1220bce79757c8d2e5dab821", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -16,15 +16,15 @@ use std::iter;\n /// being run in the calling context, the conservative choice is to assume the compared indices\n /// are disjoint (and therefore, do not overlap).\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n-pub(crate) enum PlaceConflictBias {\n+pub enum PlaceConflictBias {\n     Overlap,\n     NoOverlap,\n }\n \n /// Helper function for checking if places conflict with a mutable borrow and deep access depth.\n /// This is used to check for places conflicting outside of the borrow checking code (such as in\n /// dataflow).\n-pub(crate) fn places_conflict<'tcx>(\n+pub fn places_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n     borrow_place: Place<'tcx>,"}, {"sha": "50b246b1478fcb2109a8968a995140ac082054c4", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::outlives::test_type_match;\n use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound, VerifyIfEq};\n use rustc_infer::infer::{InferCtxt, NllRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n-    Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureOutlivesSubjectTy,\n+    BasicBlock, Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureOutlivesSubjectTy,\n     ClosureRegionRequirements, ConstraintCategory, Local, Location, ReturnConstraint,\n     TerminatorKind,\n };\n@@ -585,6 +585,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.universal_regions.to_region_vid(r)\n     }\n \n+    /// Returns an iterator over all the outlives constraints.\n+    pub fn outlives_constraints(&self) -> impl Iterator<Item = OutlivesConstraint<'tcx>> + '_ {\n+        self.constraints.outlives().iter().copied()\n+    }\n+\n     /// Adds annotations for `#[rustc_regions]`; see `UniversalRegions::annotate`.\n     pub(crate) fn annotate(&self, tcx: TyCtxt<'tcx>, err: &mut Diagnostic) {\n         self.universal_regions.annotate(tcx, err)\n@@ -598,6 +603,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_values.contains(scc, p)\n     }\n \n+    /// Returns the lowest statement index in `start..=end` which is not contained by `r`.\n+    ///\n+    /// Panics if called before `solve()` executes.\n+    pub(crate) fn first_non_contained_inclusive(\n+        &self,\n+        r: RegionVid,\n+        block: BasicBlock,\n+        start: usize,\n+        end: usize,\n+    ) -> Option<usize> {\n+        let scc = self.constraint_sccs.scc(r);\n+        self.scc_values.first_non_contained_inclusive(scc, block, start, end)\n+    }\n+\n     /// Returns access to the value of `r` for debugging purposes.\n     pub(crate) fn region_value_str(&self, r: RegionVid) -> String {\n         let scc = self.constraint_sccs.scc(r);\n@@ -698,7 +717,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     #[instrument(skip(self, _body), level = \"debug\")]\n     fn propagate_constraints(&mut self, _body: &Body<'tcx>) {\n         debug!(\"constraints={:#?}\", {\n-            let mut constraints: Vec<_> = self.constraints.outlives().iter().collect();\n+            let mut constraints: Vec<_> = self.outlives_constraints().collect();\n             constraints.sort_by_key(|c| (c.sup, c.sub));\n             constraints\n                 .into_iter()"}, {"sha": "7fc89e89a359951633aad842df8270232a861018", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -2,9 +2,10 @@ use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n+use rustc_infer::infer::InferCtxt;\n use rustc_infer::infer::TyCtxtInferExt as _;\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt};\n use rustc_infer::traits::{Obligation, ObligationCause};\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, OpaqueHiddenType, OpaqueTypeKey, Ty, TyCtxt, TypeFoldable};\n@@ -152,8 +153,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     let guar = ty.error_reported().err().unwrap_or_else(|| {\n                         prev.report_mismatch(\n                             &OpaqueHiddenType { ty, span: concrete_type.span },\n+                            opaque_type_key.def_id,\n                             infcx.tcx,\n                         )\n+                        .emit()\n                     });\n                     prev.ty = infcx.tcx.ty_error(guar);\n                 }"}, {"sha": "9290e7479144ade256caeb11b57b91bca5b8ca1b", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -159,7 +159,7 @@ impl<N: Idx> LivenessValues<N> {\n     /// Returns `true` if the region `r` contains the given element.\n     pub(crate) fn contains(&self, row: N, location: Location) -> bool {\n         let index = self.elements.point_from_location(location);\n-        self.points.row(row).map_or(false, |r| r.contains(index))\n+        self.points.row(row).is_some_and(|r| r.contains(index))\n     }\n \n     /// Returns an iterator of all the elements contained by the region `r`\n@@ -283,6 +283,22 @@ impl<N: Idx> RegionValues<N> {\n         elem.contained_in_row(self, r)\n     }\n \n+    /// Returns the lowest statement index in `start..=end` which is not contained by `r`.\n+    pub(crate) fn first_non_contained_inclusive(\n+        &self,\n+        r: N,\n+        block: BasicBlock,\n+        start: usize,\n+        end: usize,\n+    ) -> Option<usize> {\n+        let row = self.points.row(r)?;\n+        let block = self.elements.entry_point(block);\n+        let start = block.plus(start);\n+        let end = block.plus(end);\n+        let first_unset = row.first_unset_in(start..=end)?;\n+        Some(first_unset.index() - block.index())\n+    }\n+\n     /// `self[to] |= values[from]`, essentially: that is, take all the\n     /// elements for the region `from` from `values` and add them to\n     /// the region `to` in `self`."}, {"sha": "f527eee7bda054f217087d039864942e803139f8", "filename": "compiler/rustc_borrowck/src/type_check/canonical.rs", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fcanonical.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,13 +1,13 @@\n use std::fmt;\n \n-use rustc_infer::infer::{canonical::Canonical, InferOk};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_infer::infer::canonical::Canonical;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use rustc_span::def_id::DefId;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::type_op::{self, TypeOpOutput};\n-use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n-use rustc_trait_selection::traits::{ObligationCause, ObligationCtxt};\n+use rustc_trait_selection::traits::ObligationCause;\n \n use crate::diagnostics::{ToUniverseInfo, UniverseInfo};\n \n@@ -30,14 +30,15 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n         op: Op,\n-    ) -> Fallible<R>\n+    ) -> Result<R, ErrorGuaranteed>\n     where\n         Op: type_op::TypeOp<'tcx, Output = R>,\n         Op::ErrorInfo: ToUniverseInfo<'tcx>,\n     {\n         let old_universe = self.infcx.universe();\n \n-        let TypeOpOutput { output, constraints, error_info } = op.fully_perform(self.infcx)?;\n+        let TypeOpOutput { output, constraints, error_info } =\n+            op.fully_perform(self.infcx, locations.span(self.body))?;\n \n         debug!(?output, ?constraints);\n \n@@ -135,14 +136,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     ) {\n         let param_env = self.param_env;\n         let predicate = predicate.to_predicate(self.tcx());\n-        self.fully_perform_op(\n+        let _: Result<_, ErrorGuaranteed> = self.fully_perform_op(\n             locations,\n             category,\n             param_env.and(type_op::prove_predicate::ProvePredicate::new(predicate)),\n-        )\n-        .unwrap_or_else(|NoSolution| {\n-            span_mirbug!(self, NoSolution, \"could not prove {:?}\", predicate);\n-        })\n+        );\n     }\n \n     pub(super) fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n@@ -163,15 +161,12 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         T: type_op::normalize::Normalizable<'tcx> + fmt::Display + Copy + 'tcx,\n     {\n         let param_env = self.param_env;\n-        self.fully_perform_op(\n+        let result: Result<_, ErrorGuaranteed> = self.fully_perform_op(\n             location.to_locations(),\n             category,\n             param_env.and(type_op::normalize::Normalize::new(value)),\n-        )\n-        .unwrap_or_else(|NoSolution| {\n-            span_mirbug!(self, NoSolution, \"failed to normalize `{:?}`\", value);\n-            value\n-        })\n+        );\n+        result.unwrap_or(value)\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -181,18 +176,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         user_ty: ty::UserType<'tcx>,\n         span: Span,\n     ) {\n-        self.fully_perform_op(\n+        let _: Result<_, ErrorGuaranteed> = self.fully_perform_op(\n             Locations::All(span),\n             ConstraintCategory::Boring,\n             self.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(mir_ty, user_ty)),\n-        )\n-        .unwrap_or_else(|err| {\n-            span_mirbug!(\n-                self,\n-                span,\n-                \"ascribe_user_type `{mir_ty:?}=={user_ty:?}` failed with `{err:?}`\",\n-            );\n-        });\n+        );\n     }\n \n     /// *Incorrectly* skips the WF checks we normally do in `ascribe_user_type`.\n@@ -219,27 +207,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n         let cause = ObligationCause::dummy_with_span(span);\n         let param_env = self.param_env;\n-        let op = |infcx: &'_ _| {\n-            let ocx = ObligationCtxt::new_in_snapshot(infcx);\n-            let user_ty = ocx.normalize(&cause, param_env, user_ty);\n-            ocx.eq(&cause, param_env, user_ty, mir_ty)?;\n-            if !ocx.select_all_or_error().is_empty() {\n-                return Err(NoSolution);\n-            }\n-            Ok(InferOk { value: (), obligations: vec![] })\n-        };\n-\n-        self.fully_perform_op(\n+        let _: Result<_, ErrorGuaranteed> = self.fully_perform_op(\n             Locations::All(span),\n             ConstraintCategory::Boring,\n-            type_op::custom::CustomTypeOp::new(op, || \"ascribe_user_type_skip_wf\".to_string()),\n-        )\n-        .unwrap_or_else(|err| {\n-            span_mirbug!(\n-                self,\n-                span,\n-                \"ascribe_user_type_skip_wf `{mir_ty:?}=={user_ty:?}` failed with `{err:?}`\",\n-            );\n-        });\n+            type_op::custom::CustomTypeOp::new(\n+                |ocx| {\n+                    let user_ty = ocx.normalize(&cause, param_env, user_ty);\n+                    ocx.eq(&cause, param_env, user_ty, mir_ty)?;\n+                    Ok(())\n+                },\n+                \"ascribe_user_type_skip_wf\",\n+            ),\n+        );\n     }\n }"}, {"sha": "c8ec1257d376ef4faf78995507244cd60b111f14", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -8,7 +8,7 @@ use rustc_infer::infer::InferCtxt;\n use rustc_middle::mir::ConstraintCategory;\n use rustc_middle::traits::query::OutlivesBound;\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::Span;\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::traits::query::type_op::{self, TypeOp};\n use std::rc::Rc;\n use type_op::TypeOpOutput;\n@@ -243,18 +243,11 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n             let TypeOpOutput { output: norm_ty, constraints: constraints_normalize, .. } = self\n                 .param_env\n                 .and(type_op::normalize::Normalize::new(ty))\n-                .fully_perform(self.infcx)\n-                .unwrap_or_else(|_| {\n-                    let guar = self\n-                        .infcx\n-                        .tcx\n-                        .sess\n-                        .delay_span_bug(span, format!(\"failed to normalize {:?}\", ty));\n-                    TypeOpOutput {\n-                        output: self.infcx.tcx.ty_error(guar),\n-                        constraints: None,\n-                        error_info: None,\n-                    }\n+                .fully_perform(self.infcx, span)\n+                .unwrap_or_else(|guar| TypeOpOutput {\n+                    output: self.infcx.tcx.ty_error(guar),\n+                    constraints: None,\n+                    error_info: None,\n                 });\n             if let Some(c) = constraints_normalize {\n                 constraints.push(c)\n@@ -324,7 +317,7 @@ impl<'tcx> UniversalRegionRelationsBuilder<'_, 'tcx> {\n         let TypeOpOutput { output: bounds, constraints, .. } = self\n             .param_env\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n-            .fully_perform(self.infcx)\n+            .fully_perform(self.infcx, DUMMY_SP)\n             .unwrap_or_else(|_| bug!(\"failed to compute implied bounds {:?}\", ty));\n         debug!(?bounds, ?constraints);\n         self.add_outlives_bounds(bounds);"}, {"sha": "fd94ac86d7dc2729f4e593304c273bccff802837", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -4,6 +4,7 @@ use rustc_index::interval::IntervalSet;\n use rustc_infer::infer::canonical::QueryRegionConstraints;\n use rustc_middle::mir::{BasicBlock, Body, ConstraintCategory, Local, Location};\n use rustc_middle::ty::{Ty, TyCtxt, TypeVisitable, TypeVisitableExt};\n+use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::query::dropck_outlives::DropckOutlivesResult;\n use rustc_trait_selection::traits::query::type_op::outlives::DropckOutlives;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n@@ -568,10 +569,15 @@ impl<'tcx> LivenessContext<'_, '_, '_, 'tcx> {\n     ) -> DropData<'tcx> {\n         debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n \n-        let param_env = typeck.param_env;\n-        let TypeOpOutput { output, constraints, .. } =\n-            param_env.and(DropckOutlives::new(dropped_ty)).fully_perform(typeck.infcx).unwrap();\n-\n-        DropData { dropck_result: output, region_constraint_data: constraints }\n+        match typeck\n+            .param_env\n+            .and(DropckOutlives::new(dropped_ty))\n+            .fully_perform(typeck.infcx, DUMMY_SP)\n+        {\n+            Ok(TypeOpOutput { output, constraints, .. }) => {\n+                DropData { dropck_result: output, region_constraint_data: constraints }\n+            }\n+            Err(_) => DropData { dropck_result: Default::default(), region_constraint_data: None },\n+        }\n     }\n }"}, {"sha": "51a84ce6cadeac2914e5f5745362639dfbab5338", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 106, "deletions": 53, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -10,6 +10,7 @@ use either::Either;\n use hir::OpaqueTyOrigin;\n use rustc_data_structures::frozen::Frozen;\n use rustc_data_structures::fx::{FxIndexMap, FxIndexSet};\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n@@ -20,12 +21,13 @@ use rustc_infer::infer::outlives::env::RegionBoundPairs;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n-    InferCtxt, InferOk, LateBoundRegion, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n+    InferCtxt, LateBoundRegion, LateBoundRegionConversionTime, NllRegionVariableOrigin,\n };\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::AssertKind;\n use rustc_middle::mir::*;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::subst::{SubstsRef, UserSubsts};\n@@ -41,13 +43,14 @@ use rustc_target::abi::{FieldIdx, FIRST_VARIANT};\n use rustc_trait_selection::traits::query::type_op::custom::scrape_region_constraints;\n use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::type_op::{TypeOp, TypeOpOutput};\n-use rustc_trait_selection::traits::query::Fallible;\n+\n use rustc_trait_selection::traits::PredicateObligation;\n \n use rustc_mir_dataflow::impls::MaybeInitializedPlaces;\n use rustc_mir_dataflow::move_paths::MoveData;\n use rustc_mir_dataflow::ResultsCursor;\n \n+use crate::renumber::RegionCtxt;\n use crate::session_diagnostics::MoveUnsized;\n use crate::{\n     borrow_set::BorrowSet,\n@@ -183,17 +186,19 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         &mut borrowck_context,\n     );\n \n-    let errors_reported = {\n-        let mut verifier = TypeVerifier::new(&mut checker, promoted);\n-        verifier.visit_body(&body);\n-        verifier.errors_reported\n-    };\n-\n-    if !errors_reported {\n-        // if verifier failed, don't do further checks to avoid ICEs\n-        checker.typeck_mir(body);\n+    // FIXME(-Ztrait-solver=next): A bit dubious that we're only registering\n+    // predefined opaques in the typeck root.\n+    // FIXME(-Ztrait-solver=next): This is also totally wrong for TAITs, since\n+    // the HIR typeck map defining usages back to their definition params,\n+    // they won't actually match up with the usages in this body...\n+    if infcx.tcx.trait_solver_next() && !infcx.tcx.is_typeck_child(body.source.def_id()) {\n+        checker.register_predefined_opaques_in_new_solver();\n     }\n \n+    let mut verifier = TypeVerifier::new(&mut checker, promoted);\n+    verifier.visit_body(&body);\n+\n+    checker.typeck_mir(body);\n     checker.equate_inputs_and_outputs(&body, universal_regions, &normalized_inputs_and_output);\n     checker.check_signature_annotation(&body);\n \n@@ -213,24 +218,22 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     let opaque_type_values = opaque_type_values\n         .into_iter()\n         .map(|(opaque_type_key, decl)| {\n-            checker\n-                .fully_perform_op(\n-                    Locations::All(body.span),\n-                    ConstraintCategory::OpaqueType,\n-                    CustomTypeOp::new(\n-                        |infcx| {\n-                            infcx.register_member_constraints(\n-                                param_env,\n-                                opaque_type_key,\n-                                decl.hidden_type.ty,\n-                                decl.hidden_type.span,\n-                            );\n-                            Ok(InferOk { value: (), obligations: vec![] })\n-                        },\n-                        || \"opaque_type_map\".to_string(),\n-                    ),\n-                )\n-                .unwrap();\n+            let _: Result<_, ErrorGuaranteed> = checker.fully_perform_op(\n+                Locations::All(body.span),\n+                ConstraintCategory::OpaqueType,\n+                CustomTypeOp::new(\n+                    |ocx| {\n+                        ocx.infcx.register_member_constraints(\n+                            param_env,\n+                            opaque_type_key,\n+                            decl.hidden_type.ty,\n+                            decl.hidden_type.span,\n+                        );\n+                        Ok(())\n+                    },\n+                    \"opaque_type_map\",\n+                ),\n+            );\n             let mut hidden_type = infcx.resolve_vars_if_possible(decl.hidden_type);\n             trace!(\"finalized opaque type {:?} to {:#?}\", opaque_type_key, hidden_type.ty.kind());\n             if hidden_type.has_non_region_infer() {\n@@ -294,7 +297,6 @@ struct TypeVerifier<'a, 'b, 'tcx> {\n     cx: &'a mut TypeChecker<'b, 'tcx>,\n     promoted: &'b IndexSlice<Promoted, Body<'tcx>>,\n     last_span: Span,\n-    errors_reported: bool,\n }\n \n impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n@@ -383,13 +385,11 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                         };\n                     };\n \n-                    if !self.errors_reported {\n-                        let promoted_body = &self.promoted[promoted];\n-                        self.sanitize_promoted(promoted_body, location);\n+                    let promoted_body = &self.promoted[promoted];\n+                    self.sanitize_promoted(promoted_body, location);\n \n-                        let promoted_ty = promoted_body.return_ty();\n-                        check_err(self, promoted_body, ty, promoted_ty);\n-                    }\n+                    let promoted_ty = promoted_body.return_ty();\n+                    check_err(self, promoted_body, ty, promoted_ty);\n                 } else {\n                     self.cx.ascribe_user_type(\n                         constant.literal.ty(),\n@@ -483,9 +483,6 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n         for local_decl in &body.local_decls {\n             self.sanitize_type(local_decl, local_decl.ty);\n         }\n-        if self.errors_reported {\n-            return;\n-        }\n         self.super_body(body);\n     }\n }\n@@ -495,7 +492,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         cx: &'a mut TypeChecker<'b, 'tcx>,\n         promoted: &'b IndexSlice<Promoted, Body<'tcx>>,\n     ) -> Self {\n-        TypeVerifier { promoted, last_span: cx.body.span, cx, errors_reported: false }\n+        TypeVerifier { promoted, last_span: cx.body.span, cx }\n     }\n \n     fn body(&self) -> &Body<'tcx> {\n@@ -529,7 +526,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         for elem in place.projection.iter() {\n             if place_ty.variant_index.is_none() {\n                 if let Err(guar) = place_ty.ty.error_reported() {\n-                    assert!(self.errors_reported);\n                     return PlaceTy::from_ty(self.tcx().ty_error(guar));\n                 }\n             }\n@@ -593,10 +589,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         self.visit_body(&promoted_body);\n \n-        if !self.errors_reported {\n-            // if verifier failed, don't do further checks to avoid ICEs\n-            self.cx.typeck_mir(promoted_body);\n-        }\n+        self.cx.typeck_mir(promoted_body);\n \n         self.cx.body = parent_body;\n         // Merge the outlives constraints back in, at the given location.\n@@ -762,7 +755,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n     }\n \n     fn error(&mut self) -> Ty<'tcx> {\n-        self.errors_reported = true;\n         self.tcx().ty_error_misc()\n     }\n \n@@ -1041,6 +1033,57 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         checker\n     }\n \n+    pub(super) fn register_predefined_opaques_in_new_solver(&mut self) {\n+        // OK to use the identity substitutions for each opaque type key, since\n+        // we remap opaques from HIR typeck back to their definition params.\n+        let opaques: Vec<_> = self\n+            .infcx\n+            .tcx\n+            .typeck(self.body.source.def_id().expect_local())\n+            .concrete_opaque_types\n+            .iter()\n+            .map(|(&def_id, &hidden_ty)| {\n+                let substs = ty::InternalSubsts::identity_for_item(self.infcx.tcx, def_id);\n+                (ty::OpaqueTypeKey { def_id, substs }, hidden_ty)\n+            })\n+            .collect();\n+\n+        let renumbered_opaques = self.infcx.tcx.fold_regions(opaques, |_, _| {\n+            self.infcx.next_nll_region_var(\n+                NllRegionVariableOrigin::Existential { from_forall: false },\n+                || RegionCtxt::Unknown,\n+            )\n+        });\n+\n+        let param_env = self.param_env;\n+        let result = self.fully_perform_op(\n+            Locations::All(self.body.span),\n+            ConstraintCategory::OpaqueType,\n+            CustomTypeOp::new(\n+                |ocx| {\n+                    for (key, hidden_ty) in renumbered_opaques {\n+                        ocx.register_infer_ok_obligations(\n+                            ocx.infcx.register_hidden_type_in_new_solver(\n+                                key,\n+                                param_env,\n+                                hidden_ty.ty,\n+                            )?,\n+                        );\n+                    }\n+                    Ok(())\n+                },\n+                \"register pre-defined opaques\",\n+            ),\n+        );\n+\n+        if result.is_err() {\n+            self.infcx.tcx.sess.delay_span_bug(\n+                self.body.span,\n+                \"failed re-defining predefined opaques in mir typeck\",\n+            );\n+        }\n+    }\n+\n     fn body(&self) -> &Body<'tcx> {\n         self.body\n     }\n@@ -1091,7 +1134,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         sup: Ty<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n-    ) -> Fallible<()> {\n+    ) -> Result<(), NoSolution> {\n         // Use this order of parameters because the sup type is usually the\n         // \"expected\" type in diagnostics.\n         self.relate_types(sup, ty::Variance::Contravariant, sub, locations, category)\n@@ -1104,7 +1147,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         found: Ty<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n-    ) -> Fallible<()> {\n+    ) -> Result<(), NoSolution> {\n         self.relate_types(expected, ty::Variance::Invariant, found, locations, category)\n     }\n \n@@ -1116,7 +1159,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         user_ty: &UserTypeProjection,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n-    ) -> Fallible<()> {\n+    ) -> Result<(), NoSolution> {\n         let annotated_type = self.user_type_annotations[user_ty.base].inferred_ty;\n         trace!(?annotated_type);\n         let mut curr_projected_ty = PlaceTy::from_ty(annotated_type);\n@@ -2712,10 +2755,20 @@ impl<'tcx> TypeOp<'tcx> for InstantiateOpaqueType<'tcx> {\n     /// constraints in our `InferCtxt`\n     type ErrorInfo = InstantiateOpaqueType<'tcx>;\n \n-    fn fully_perform(mut self, infcx: &InferCtxt<'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n-        let (mut output, region_constraints) = scrape_region_constraints(infcx, || {\n-            Ok(InferOk { value: (), obligations: self.obligations.clone() })\n-        })?;\n+    fn fully_perform(\n+        mut self,\n+        infcx: &InferCtxt<'tcx>,\n+        span: Span,\n+    ) -> Result<TypeOpOutput<'tcx, Self>, ErrorGuaranteed> {\n+        let (mut output, region_constraints) = scrape_region_constraints(\n+            infcx,\n+            |ocx| {\n+                ocx.register_obligations(self.obligations.clone());\n+                Ok(())\n+            },\n+            \"InstantiateOpaqueType\",\n+            span,\n+        )?;\n         self.region_constraints = Some(region_constraints);\n         output.error_info = Some(self);\n         Ok(output)"}, {"sha": "8c4bfb2c6e0d30721edb6459c35c95292bcb6cb8", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,12 +1,13 @@\n+use rustc_errors::ErrorGuaranteed;\n use rustc_infer::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::relate::TypeRelation;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::sym;\n use rustc_span::{Span, Symbol};\n-use rustc_trait_selection::traits::query::Fallible;\n \n use crate::constraints::OutlivesConstraint;\n use crate::diagnostics::UniverseInfo;\n@@ -30,7 +31,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         b: Ty<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n-    ) -> Fallible<()> {\n+    ) -> Result<(), NoSolution> {\n         TypeRelating::new(\n             self.infcx,\n             NllTypeRelatingDelegate::new(self, locations, category, UniverseInfo::relate(a, b)),\n@@ -47,7 +48,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         b: ty::SubstsRef<'tcx>,\n         locations: Locations,\n         category: ConstraintCategory<'tcx>,\n-    ) -> Fallible<()> {\n+    ) -> Result<(), NoSolution> {\n         TypeRelating::new(\n             self.infcx,\n             NllTypeRelatingDelegate::new(self, locations, category, UniverseInfo::other()),\n@@ -185,17 +186,15 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n     }\n \n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n-        self.type_checker\n-            .fully_perform_op(\n-                self.locations,\n-                self.category,\n-                InstantiateOpaqueType {\n-                    obligations,\n-                    // These fields are filled in during execution of the operation\n-                    base_universe: None,\n-                    region_constraints: None,\n-                },\n-            )\n-            .unwrap();\n+        let _: Result<_, ErrorGuaranteed> = self.type_checker.fully_perform_op(\n+            self.locations,\n+            self.category,\n+            InstantiateOpaqueType {\n+                obligations,\n+                // These fields are filled in during execution of the operation\n+                base_universe: None,\n+                region_constraints: None,\n+            },\n+        );\n     }\n }"}, {"sha": "f00cd39cbc82a3613b42078e8a4b9fd1ce02cc98", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 116, "deletions": 116, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,129 +1,140 @@\n-builtin_macros_requires_cfg_pattern =\n-    macro requires a cfg-pattern as an argument\n-    .label = cfg-pattern required\n+builtin_macros_alloc_error_must_be_fn = alloc_error_handler must be a function\n \n-builtin_macros_expected_one_cfg_pattern = expected 1 cfg-pattern\n+builtin_macros_asm_clobber_abi = clobber_abi\n+builtin_macros_asm_clobber_no_reg = asm with `clobber_abi` must specify explicit registers for outputs\n+builtin_macros_asm_clobber_outputs = generic outputs\n \n-builtin_macros_alloc_error_must_be_fn = alloc_error_handler must be a function\n+builtin_macros_asm_duplicate_arg = duplicate argument named `{$name}`\n+    .label = previously here\n+    .arg = duplicate argument\n+\n+builtin_macros_asm_expected_comma = expected token: `,`\n+    .label = expected `,`\n+\n+builtin_macros_asm_expected_other = expected operand, {$is_global_asm ->\n+    [true] options\n+    *[false] clobber_abi, options\n+    }, or additional template string\n+\n+builtin_macros_asm_explicit_register_name = explicit register arguments cannot have names\n+\n+builtin_macros_asm_modifier_invalid = asm template modifier must be a single character\n+\n+builtin_macros_asm_mutually_exclusive = the `{$opt1}` and `{$opt2}` options are mutually exclusive\n+\n+builtin_macros_asm_noreturn = asm outputs are not allowed with the `noreturn` option\n+\n+builtin_macros_asm_opt_already_provided = the `{$symbol}` option was already provided\n+    .label = this option was already provided\n+    .suggestion = remove this option\n+\n+builtin_macros_asm_pos_after = positional arguments cannot follow named arguments or explicit register arguments\n+    .pos = positional argument\n+    .named = named argument\n+    .explicit = explicit register argument\n+\n+builtin_macros_asm_pure_combine = the `pure` option must be combined with either `nomem` or `readonly`\n+\n+builtin_macros_asm_pure_no_output = asm with the `pure` option must have at least one output\n+\n+builtin_macros_asm_requires_template = requires at least a template string argument\n+\n+builtin_macros_asm_sym_no_path = expected a path for argument to `sym`\n+\n+builtin_macros_asm_underscore_input = _ cannot be used for input operands\n+\n+builtin_macros_assert_missing_comma = unexpected string literal\n+    .suggestion = try adding a comma\n \n builtin_macros_assert_requires_boolean = macro requires a boolean expression as an argument\n     .label = boolean expression required\n \n builtin_macros_assert_requires_expression = macro requires an expression as an argument\n     .suggestion = try removing semicolon\n \n-builtin_macros_assert_missing_comma = unexpected string literal\n-    .suggestion = try adding a comma\n+builtin_macros_bad_derive_target = `derive` may only be applied to `struct`s, `enum`s and `union`s\n+    .label = not applicable here\n+    .label2 = not a `struct`, `enum` or `union`\n+\n+builtin_macros_cannot_derive_union = this trait cannot be derived for unions\n \n-builtin_macros_cfg_accessible_unspecified_path = `cfg_accessible` path is not specified\n-builtin_macros_cfg_accessible_multiple_paths = multiple `cfg_accessible` paths are specified\n-builtin_macros_cfg_accessible_literal_path = `cfg_accessible` path cannot be a literal\n builtin_macros_cfg_accessible_has_args = `cfg_accessible` path cannot accept arguments\n \n builtin_macros_cfg_accessible_indeterminate = cannot determine whether the path is accessible or not\n \n-builtin_macros_concat_bytestr = cannot concatenate a byte string literal\n-\n-builtin_macros_concat_missing_literal = expected a literal\n-    .note = only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n+builtin_macros_cfg_accessible_literal_path = `cfg_accessible` path cannot be a literal\n+builtin_macros_cfg_accessible_multiple_paths = multiple `cfg_accessible` paths are specified\n+builtin_macros_cfg_accessible_unspecified_path = `cfg_accessible` path is not specified\n+builtin_macros_concat_bytes_array = cannot concatenate doubly nested array\n+    .note = byte strings are treated as arrays of bytes\n+    .help = try flattening the array\n \n-builtin_macros_concat_bytes_missing_literal = expected a byte literal\n-    .note = only byte literals (like `b\"foo\"`, `b's'` and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n+builtin_macros_concat_bytes_bad_repeat = repeat count is not a positive number\n \n builtin_macros_concat_bytes_invalid = cannot concatenate {$lit_kind} literals\n     .byte_char = try using a byte character\n     .byte_str = try using a byte string\n     .number_array = try wrapping the number in an array\n \n-builtin_macros_concat_bytes_oob = numeric literal is out of bounds\n+builtin_macros_concat_bytes_missing_literal = expected a byte literal\n+    .note = only byte literals (like `b\"foo\"`, `b's'` and `[3, 4, 5]`) can be passed to `concat_bytes!()`\n \n builtin_macros_concat_bytes_non_u8 = numeric literal is not a `u8`\n \n-builtin_macros_concat_bytes_array = cannot concatenate doubly nested array\n-    .note = byte strings are treated as arrays of bytes\n-    .help = try flattening the array\n+builtin_macros_concat_bytes_oob = numeric literal is out of bounds\n \n-builtin_macros_concat_bytes_bad_repeat = repeat count is not a positive number\n+builtin_macros_concat_bytestr = cannot concatenate a byte string literal\n+\n+builtin_macros_concat_idents_ident_args = `concat_idents!()` requires ident args\n \n builtin_macros_concat_idents_missing_args = `concat_idents!()` takes 1 or more arguments\n builtin_macros_concat_idents_missing_comma = `concat_idents!()` expecting comma\n-builtin_macros_concat_idents_ident_args = `concat_idents!()` requires ident args\n+builtin_macros_concat_missing_literal = expected a literal\n+    .note = only literals (like `\"foo\"`, `-42` and `3.14`) can be passed to `concat!()`\n \n-builtin_macros_bad_derive_target = `derive` may only be applied to `struct`s, `enum`s and `union`s\n-    .label = not applicable here\n-    .label2 = not a `struct`, `enum` or `union`\n+builtin_macros_default_arg = `#[default]` attribute does not accept a value\n+    .suggestion = try using `#[default]`\n \n-builtin_macros_unexpected_lit = expected path to a trait, found literal\n-    .label = not a trait\n-    .str_lit = try using `#[derive({$sym})]`\n-    .other = for example, write `#[derive(Debug)]` for `Debug`\n+builtin_macros_derive_macro_call = `derive` cannot be used on items with type macros\n \n builtin_macros_derive_path_args_list = traits in `#[derive(...)]` don't accept arguments\n     .suggestion = remove the arguments\n \n builtin_macros_derive_path_args_value = traits in `#[derive(...)]` don't accept values\n     .suggestion = remove the value\n \n-builtin_macros_derive_macro_call = `derive` cannot be used on items with type macros\n-\n-builtin_macros_cannot_derive_union = this trait cannot be derived for unions\n-\n-builtin_macros_no_default_variant = no default declared\n-    .help = make a unit variant default by placing `#[default]` above it\n-    .suggestion = make `{$ident}` default\n-\n-builtin_macros_multiple_defaults = multiple declared defaults\n-    .label = first default\n-    .additional = additional default\n-    .note = only one variant can be default\n-    .suggestion = make `{$ident}` default\n-\n-builtin_macros_non_unit_default = the `#[default]` attribute may only be used on unit enum variants\n-    .help = consider a manual implementation of `Default`\n-\n-builtin_macros_non_exhaustive_default = default variant must be exhaustive\n-    .label = declared `#[non_exhaustive]` here\n-    .help = consider a manual implementation of `Default`\n-\n-builtin_macros_multiple_default_attrs = multiple `#[default]` attributes\n-    .note = only one `#[default]` attribute is needed\n-    .label = `#[default]` used here\n-    .label_again = `#[default]` used again here\n-    .help = try removing {$only_one ->\n-    [true] this\n-    *[false] these\n-    }\n-\n-builtin_macros_default_arg = `#[default]` attribute does not accept a value\n-    .suggestion = try using `#[default]`\n-\n-builtin_macros_env_takes_args = `env!()` takes 1 or 2 arguments\n-\n builtin_macros_env_not_defined = environment variable `{$var}` not defined at compile time\n     .cargo = Cargo sets build script variables at run time. Use `std::env::var(\"{$var}\")` instead\n     .other = use `std::env::var(\"{$var}\")` to read the variable at run time\n \n-builtin_macros_format_requires_string = requires at least a format string argument\n+builtin_macros_env_takes_args = `env!()` takes 1 or 2 arguments\n+\n+builtin_macros_expected_one_cfg_pattern = expected 1 cfg-pattern\n \n builtin_macros_format_duplicate_arg = duplicate argument named `{$ident}`\n     .label1 = previously here\n     .label2 = duplicate argument\n \n+builtin_macros_format_no_arg_named = there is no argument named `{$name}`\n+    .note = did you intend to capture a variable `{$name}` from the surrounding scope?\n+    .note2 = to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\n+\n+builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n+    [one] argument\n+    *[more] arguments\n+    } in format string, but {$desc}\n+\n builtin_macros_format_positional_after_named = positional arguments cannot follow named arguments\n     .label = positional arguments must be before named arguments\n     .named_args = named argument\n \n+builtin_macros_format_requires_string = requires at least a format string argument\n+\n builtin_macros_format_string_invalid = invalid format string: {$desc}\n     .label = {$label1} in format string\n     .note = {$note}\n     .second_label = {$label}\n \n-builtin_macros_sugg = consider using a positional formatting argument instead\n-\n-builtin_macros_format_no_arg_named = there is no argument named `{$name}`\n-    .note = did you intend to capture a variable `{$name}` from the surrounding scope?\n-    .note2 = to avoid ambiguity, `format_args!` cannot capture variables when the format string is expanded from a macro\n-\n builtin_macros_format_unknown_trait = unknown format trait `{$ty}`\n     .note = the only appropriate formatting traits are:\n                                             - ``, which uses the `Display` trait\n@@ -145,60 +156,49 @@ builtin_macros_format_unused_arg = {$named ->\n builtin_macros_format_unused_args = multiple unused formatting arguments\n     .label = multiple missing formatting specifiers\n \n-builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n-    [one] argument\n-    *[more] arguments\n-    } in format string, but {$desc}\n-\n-builtin_macros_test_case_non_item = `#[test_case]` attribute is only allowed on items\n-\n-builtin_macros_test_bad_fn = {$kind} functions cannot be used for tests\n-    .label = `{$kind}` because of this\n-\n-builtin_macros_asm_explicit_register_name = explicit register arguments cannot have names\n-\n-builtin_macros_asm_mutually_exclusive = the `{$opt1}` and `{$opt2}` options are mutually exclusive\n-\n-builtin_macros_asm_pure_combine = the `pure` option must be combined with either `nomem` or `readonly`\n-\n-builtin_macros_asm_pure_no_output = asm with the `pure` option must have at least one output\n-\n-builtin_macros_asm_modifier_invalid = asm template modifier must be a single character\n-\n-builtin_macros_asm_requires_template = requires at least a template string argument\n-\n-builtin_macros_asm_expected_comma = expected token: `,`\n-    .label = expected `,`\n+builtin_macros_global_asm_clobber_abi = `clobber_abi` cannot be used with `global_asm!`\n \n-builtin_macros_asm_underscore_input = _ cannot be used for input operands\n+builtin_macros_multiple_default_attrs = multiple `#[default]` attributes\n+    .note = only one `#[default]` attribute is needed\n+    .label = `#[default]` used here\n+    .label_again = `#[default]` used again here\n+    .help = try removing {$only_one ->\n+    [true] this\n+    *[false] these\n+    }\n \n-builtin_macros_asm_sym_no_path = expected a path for argument to `sym`\n+builtin_macros_multiple_defaults = multiple declared defaults\n+    .label = first default\n+    .additional = additional default\n+    .note = only one variant can be default\n+    .suggestion = make `{$ident}` default\n \n-builtin_macros_asm_expected_other = expected operand, {$is_global_asm ->\n-    [true] options\n-    *[false] clobber_abi, options\n-    }, or additional template string\n+builtin_macros_no_default_variant = no default declared\n+    .help = make a unit variant default by placing `#[default]` above it\n+    .suggestion = make `{$ident}` default\n \n-builtin_macros_asm_duplicate_arg = duplicate argument named `{$name}`\n-    .label = previously here\n-    .arg = duplicate argument\n+builtin_macros_non_exhaustive_default = default variant must be exhaustive\n+    .label = declared `#[non_exhaustive]` here\n+    .help = consider a manual implementation of `Default`\n \n-builtin_macros_asm_pos_after = positional arguments cannot follow named arguments or explicit register arguments\n-    .pos = positional argument\n-    .named = named argument\n-    .explicit = explicit register argument\n+builtin_macros_non_unit_default = the `#[default]` attribute may only be used on unit enum variants\n+    .help = consider a manual implementation of `Default`\n \n-builtin_macros_asm_noreturn = asm outputs are not allowed with the `noreturn` option\n+builtin_macros_requires_cfg_pattern =\n+    macro requires a cfg-pattern as an argument\n+    .label = cfg-pattern required\n \n-builtin_macros_global_asm_clobber_abi = `clobber_abi` cannot be used with `global_asm!`\n+builtin_macros_sugg = consider using a positional formatting argument instead\n \n-builtin_macros_asm_clobber_no_reg = asm with `clobber_abi` must specify explicit registers for outputs\n-builtin_macros_asm_clobber_abi = clobber_abi\n-builtin_macros_asm_clobber_outputs = generic outputs\n+builtin_macros_test_bad_fn = {$kind} functions cannot be used for tests\n+    .label = `{$kind}` because of this\n \n-builtin_macros_asm_opt_already_provided = the `{$symbol}` option was already provided\n-    .label = this option was already provided\n-    .suggestion = remove this option\n+builtin_macros_test_case_non_item = `#[test_case]` attribute is only allowed on items\n \n builtin_macros_test_runner_invalid = `test_runner` argument must be a path\n builtin_macros_test_runner_nargs = `#![test_runner(..)]` accepts exactly 1 argument\n+\n+builtin_macros_unexpected_lit = expected path to a trait, found literal\n+    .label = not a trait\n+    .str_lit = try using `#[derive({$sym})]`\n+    .other = for example, write `#[derive(Debug)]` for `Debug`"}, {"sha": "49401e9ca94960669b17ba704360074b6009ed72", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -119,7 +119,7 @@ impl<'ast> visit::Visitor<'ast> for CfgFinder {\n         self.has_cfg_or_cfg_attr = self.has_cfg_or_cfg_attr\n             || attr\n                 .ident()\n-                .map_or(false, |ident| ident.name == sym::cfg || ident.name == sym::cfg_attr);\n+                .is_some_and(|ident| ident.name == sym::cfg || ident.name == sym::cfg_attr);\n     }\n }\n "}, {"sha": "f0d378d12f71245de599e0eef72767b08b210170", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,7 +1,7 @@\n use crate::util::check_builtin_macro_attribute;\n \n use rustc_ast::expand::allocator::{\n-    AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS,\n+    global_fn_name, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS,\n };\n use rustc_ast::ptr::P;\n use rustc_ast::{self as ast, AttrVec, Expr, FnHeader, FnSig, Generics, Param, StmtKind};\n@@ -40,8 +40,7 @@ pub fn expand(\n \n     // Generate a bunch of new items using the AllocFnFactory\n     let span = ecx.with_def_site_ctxt(item.span);\n-    let f =\n-        AllocFnFactory { span, ty_span, kind: AllocatorKind::Global, global: item.ident, cx: ecx };\n+    let f = AllocFnFactory { span, ty_span, global: item.ident, cx: ecx };\n \n     // Generate item statements for the allocator methods.\n     let stmts = ALLOCATOR_METHODS.iter().map(|method| f.allocator_fn(method)).collect();\n@@ -63,7 +62,6 @@ pub fn expand(\n struct AllocFnFactory<'a, 'b> {\n     span: Span,\n     ty_span: Span,\n-    kind: AllocatorKind,\n     global: Ident,\n     cx: &'b ExtCtxt<'a>,\n }\n@@ -92,7 +90,7 @@ impl AllocFnFactory<'_, '_> {\n         }));\n         let item = self.cx.item(\n             self.span,\n-            Ident::from_str_and_span(&self.kind.fn_name(method.name), self.span),\n+            Ident::from_str_and_span(&global_fn_name(method.name), self.span),\n             self.attrs(),\n             kind,\n         );"}, {"sha": "84e09cf0abe4fe54d1f82263d110a1f8c0c733b5", "filename": "compiler/rustc_codegen_cranelift/src/abi/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fabi%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -432,11 +432,9 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     let is_cold = if fn_sig.abi() == Abi::RustCold {\n         true\n     } else {\n-        instance\n-            .map(|inst| {\n-                fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD)\n-            })\n-            .unwrap_or(false)\n+        instance.is_some_and(|inst| {\n+            fx.tcx.codegen_fn_attrs(inst.def_id()).flags.contains(CodegenFnAttrFlags::COLD)\n+        })\n     };\n     if is_cold {\n         fx.bcx.set_cold_block(fx.bcx.current_block().unwrap());\n@@ -470,7 +468,7 @@ pub(crate) fn codegen_terminator_call<'tcx>(\n     };\n \n     // Pass the caller location for `#[track_caller]`.\n-    if instance.map(|inst| inst.def.requires_caller_location(fx.tcx)).unwrap_or(false) {\n+    if instance.is_some_and(|inst| inst.def.requires_caller_location(fx.tcx)) {\n         let caller_location = fx.get_caller_location(source_info);\n         args.push(CallArgument { value: caller_location, is_owned: false });\n     }"}, {"sha": "d4b1ae2b61383e655bf1cc832f853769187711e2", "filename": "compiler/rustc_codegen_cranelift/src/allocator.rs", "status": "modified", "additions": 45, "deletions": 34, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fallocator.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -3,10 +3,12 @@\n \n use crate::prelude::*;\n \n-use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_ast::expand::allocator::{\n+    alloc_error_handler_name, default_fn_name, global_fn_name, AllocatorKind, AllocatorTy,\n+    ALLOCATOR_METHODS, NO_ALLOC_SHIM_IS_UNSTABLE,\n+};\n use rustc_codegen_ssa::base::allocator_kind_for_codegen;\n use rustc_session::config::OomStrategy;\n-use rustc_span::symbol::sym;\n \n /// Returns whether an allocator shim was created\n pub(crate) fn codegen(\n@@ -34,41 +36,43 @@ fn codegen_inner(\n ) {\n     let usize_ty = module.target_config().pointer_type();\n \n-    for method in ALLOCATOR_METHODS {\n-        let mut arg_tys = Vec::with_capacity(method.inputs.len());\n-        for ty in method.inputs.iter() {\n-            match *ty {\n-                AllocatorTy::Layout => {\n-                    arg_tys.push(usize_ty); // size\n-                    arg_tys.push(usize_ty); // align\n-                }\n-                AllocatorTy::Ptr => arg_tys.push(usize_ty),\n-                AllocatorTy::Usize => arg_tys.push(usize_ty),\n+    if kind == AllocatorKind::Default {\n+        for method in ALLOCATOR_METHODS {\n+            let mut arg_tys = Vec::with_capacity(method.inputs.len());\n+            for ty in method.inputs.iter() {\n+                match *ty {\n+                    AllocatorTy::Layout => {\n+                        arg_tys.push(usize_ty); // size\n+                        arg_tys.push(usize_ty); // align\n+                    }\n+                    AllocatorTy::Ptr => arg_tys.push(usize_ty),\n+                    AllocatorTy::Usize => arg_tys.push(usize_ty),\n \n-                AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n+                    AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n+                }\n             }\n-        }\n-        let output = match method.output {\n-            AllocatorTy::ResultPtr => Some(usize_ty),\n-            AllocatorTy::Unit => None,\n+            let output = match method.output {\n+                AllocatorTy::ResultPtr => Some(usize_ty),\n+                AllocatorTy::Unit => None,\n \n-            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n-                panic!(\"invalid allocator output\")\n-            }\n-        };\n+                AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n+                    panic!(\"invalid allocator output\")\n+                }\n+            };\n \n-        let sig = Signature {\n-            call_conv: module.target_config().default_call_conv,\n-            params: arg_tys.iter().cloned().map(AbiParam::new).collect(),\n-            returns: output.into_iter().map(AbiParam::new).collect(),\n-        };\n-        crate::common::create_wrapper_function(\n-            module,\n-            unwind_context,\n-            sig,\n-            &format!(\"__rust_{}\", method.name),\n-            &kind.fn_name(method.name),\n-        );\n+            let sig = Signature {\n+                call_conv: module.target_config().default_call_conv,\n+                params: arg_tys.iter().cloned().map(AbiParam::new).collect(),\n+                returns: output.into_iter().map(AbiParam::new).collect(),\n+            };\n+            crate::common::create_wrapper_function(\n+                module,\n+                unwind_context,\n+                sig,\n+                &global_fn_name(method.name),\n+                &default_fn_name(method.name),\n+            );\n+        }\n     }\n \n     let sig = Signature {\n@@ -81,7 +85,7 @@ fn codegen_inner(\n         unwind_context,\n         sig,\n         \"__rust_alloc_error_handler\",\n-        &alloc_error_handler_kind.fn_name(sym::oom),\n+        &alloc_error_handler_name(alloc_error_handler_kind),\n     );\n \n     let data_id = module.declare_data(OomStrategy::SYMBOL, Linkage::Export, false, false).unwrap();\n@@ -90,4 +94,11 @@ fn codegen_inner(\n     let val = oom_strategy.should_panic();\n     data_ctx.define(Box::new([val]));\n     module.define_data(data_id, &data_ctx).unwrap();\n+\n+    let data_id =\n+        module.declare_data(NO_ALLOC_SHIM_IS_UNSTABLE, Linkage::Export, false, false).unwrap();\n+    let mut data_ctx = DataContext::new();\n+    data_ctx.set_align(1);\n+    data_ctx.define(Box::new([0]));\n+    module.define_data(data_id, &data_ctx).unwrap();\n }"}, {"sha": "9c6a0fae327cf2999c680095bfbb6b74bcc9415d", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -630,11 +630,11 @@ fn codegen_stmt<'tcx>(\n                     let to_ty = fx.monomorphize(to_ty);\n \n                     fn is_fat_ptr<'tcx>(fx: &FunctionCx<'_, '_, 'tcx>, ty: Ty<'tcx>) -> bool {\n-                        ty.builtin_deref(true)\n-                            .map(|ty::TypeAndMut { ty: pointee_ty, mutbl: _ }| {\n+                        ty.builtin_deref(true).is_some_and(\n+                            |ty::TypeAndMut { ty: pointee_ty, mutbl: _ }| {\n                                 has_ptr_meta(fx.tcx, pointee_ty)\n-                            })\n-                            .unwrap_or(false)\n+                            },\n+                        )\n                     }\n \n                     if is_fat_ptr(fx, from_ty) {"}, {"sha": "5eaa988dd09298d0236ac93cf3a7a025dd3ad159", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -413,11 +413,7 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n \n     // Note: must be kept in sync with get_caller_location from cg_ssa\n     pub(crate) fn get_caller_location(&mut self, mut source_info: mir::SourceInfo) -> CValue<'tcx> {\n-        let span_to_caller_location = |fx: &mut FunctionCx<'_, '_, 'tcx>, mut span: Span| {\n-            // Remove `Inlined` marks as they pollute `expansion_cause`.\n-            while span.is_inlined() {\n-                span.remove_mark();\n-            }\n+        let span_to_caller_location = |fx: &mut FunctionCx<'_, '_, 'tcx>, span: Span| {\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n             let caller = fx.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n             let const_loc = fx.tcx.const_caller_location(("}, {"sha": "97bc8ef9d1bbaf755d4d508f15cb2727662f4826", "filename": "compiler/rustc_codegen_gcc/messages.ftl", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_gcc%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_gcc%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,68 +1,68 @@\n-codegen_gcc_unwinding_inline_asm =\n-    GCC backend does not support unwinding from inline asm\n-\n-codegen_gcc_lto_not_supported =\n-    LTO is not supported. You may get a linker error.\n+codegen_gcc_invalid_minimum_alignment =\n+    invalid minimum global alignment: {$err}\n \n codegen_gcc_invalid_monomorphization_basic_integer =\n     invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n \n-codegen_gcc_invalid_monomorphization_invalid_float_vector =\n-    invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$elem_ty}` of floating-point vector `{$vec_ty}`\n-\n-codegen_gcc_invalid_monomorphization_not_float =\n-    invalid monomorphization of `{$name}` intrinsic: `{$ty}` is not a floating-point type\n-\n-codegen_gcc_invalid_monomorphization_unrecognized =\n-    invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n-\n codegen_gcc_invalid_monomorphization_expected_signed_unsigned =\n     invalid monomorphization of `{$name}` intrinsic: expected element type `{$elem_ty}` of vector type `{$vec_ty}` to be a signed or unsigned integer type\n \n-codegen_gcc_invalid_monomorphization_unsupported_element =\n-    invalid monomorphization of `{$name}` intrinsic: unsupported {$name} from `{$in_ty}` with element `{$elem_ty}` to `{$ret_ty}`\n+codegen_gcc_invalid_monomorphization_expected_simd =\n+    invalid monomorphization of `{$name}` intrinsic: expected SIMD {$expected_ty} type, found non-SIMD `{$found_ty}`\n+\n+codegen_gcc_invalid_monomorphization_inserted_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n \n codegen_gcc_invalid_monomorphization_invalid_bitmask =\n     invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n \n-codegen_gcc_invalid_monomorphization_simd_shuffle =\n-    invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n-\n-codegen_gcc_invalid_monomorphization_expected_simd =\n-    invalid monomorphization of `{$name}` intrinsic: expected SIMD {$expected_ty} type, found non-SIMD `{$found_ty}`\n+codegen_gcc_invalid_monomorphization_invalid_float_vector =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$elem_ty}` of floating-point vector `{$vec_ty}`\n \n codegen_gcc_invalid_monomorphization_mask_type =\n     invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n \n+codegen_gcc_invalid_monomorphization_mismatched_lengths =\n+    invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_gcc_invalid_monomorphization_not_float =\n+    invalid monomorphization of `{$name}` intrinsic: `{$ty}` is not a floating-point type\n+\n+codegen_gcc_invalid_monomorphization_return_element =\n+    invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_integer_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n codegen_gcc_invalid_monomorphization_return_length =\n     invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n \n codegen_gcc_invalid_monomorphization_return_length_input_type =\n     invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n \n-codegen_gcc_invalid_monomorphization_return_element =\n-    invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n-\n codegen_gcc_invalid_monomorphization_return_type =\n     invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n \n-codegen_gcc_invalid_monomorphization_inserted_type =\n-    invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n-\n-codegen_gcc_invalid_monomorphization_return_integer_type =\n-    invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+codegen_gcc_invalid_monomorphization_simd_shuffle =\n+    invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n \n-codegen_gcc_invalid_monomorphization_mismatched_lengths =\n-    invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+codegen_gcc_invalid_monomorphization_unrecognized =\n+    invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n \n codegen_gcc_invalid_monomorphization_unsupported_cast =\n     invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n \n+codegen_gcc_invalid_monomorphization_unsupported_element =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported {$name} from `{$in_ty}` with element `{$elem_ty}` to `{$ret_ty}`\n+\n codegen_gcc_invalid_monomorphization_unsupported_operation =\n     invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n \n-codegen_gcc_invalid_minimum_alignment =\n-    invalid minimum global alignment: {$err}\n+codegen_gcc_lto_not_supported =\n+    LTO is not supported. You may get a linker error.\n \n codegen_gcc_tied_target_features = the target features {$features} must all be either enabled or disabled together\n     .help = add the missing features in a `target_feature` attribute\n+\n+codegen_gcc_unwinding_inline_asm =\n+    GCC backend does not support unwinding from inline asm"}, {"sha": "13f88192bbc9005e9665ac0851dded4ac581e0ec", "filename": "compiler/rustc_codegen_gcc/src/allocator.rs", "status": "modified", "additions": 67, "deletions": 58, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fallocator.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,11 +1,13 @@\n #[cfg(feature=\"master\")]\n use gccjit::FnAttribute;\n use gccjit::{FunctionType, GlobalKind, ToRValue};\n-use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_ast::expand::allocator::{\n+    alloc_error_handler_name, default_fn_name, global_fn_name, AllocatorKind, AllocatorTy,\n+    ALLOCATOR_METHODS, NO_ALLOC_SHIM_IS_UNSTABLE,\n+};\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::OomStrategy;\n-use rustc_span::symbol::sym;\n \n use crate::GccContext;\n \n@@ -22,69 +24,71 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n     let i8p = i8.make_pointer();\n     let void = context.new_type::<()>();\n \n-    for method in ALLOCATOR_METHODS {\n-        let mut types = Vec::with_capacity(method.inputs.len());\n-        for ty in method.inputs.iter() {\n-            match *ty {\n-                AllocatorTy::Layout => {\n-                    types.push(usize);\n-                    types.push(usize);\n+    if kind == AllocatorKind::Default {\n+        for method in ALLOCATOR_METHODS {\n+            let mut types = Vec::with_capacity(method.inputs.len());\n+            for ty in method.inputs.iter() {\n+                match *ty {\n+                    AllocatorTy::Layout => {\n+                        types.push(usize);\n+                        types.push(usize);\n+                    }\n+                    AllocatorTy::Ptr => types.push(i8p),\n+                    AllocatorTy::Usize => types.push(usize),\n+\n+                    AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n                 }\n-                AllocatorTy::Ptr => types.push(i8p),\n-                AllocatorTy::Usize => types.push(usize),\n-\n-                AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n             }\n-        }\n-        let output = match method.output {\n-            AllocatorTy::ResultPtr => Some(i8p),\n-            AllocatorTy::Unit => None,\n+            let output = match method.output {\n+                AllocatorTy::ResultPtr => Some(i8p),\n+                AllocatorTy::Unit => None,\n \n-            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n-                panic!(\"invalid allocator output\")\n-            }\n-        };\n-        let name = format!(\"__rust_{}\", method.name);\n+                AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n+                    panic!(\"invalid allocator output\")\n+                }\n+            };\n+            let name = global_fn_name(method.name);\n \n-        let args: Vec<_> = types.iter().enumerate()\n-            .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n-            .collect();\n-        let func = context.new_function(None, FunctionType::Exported, output.unwrap_or(void), &args, name, false);\n+            let args: Vec<_> = types.iter().enumerate()\n+                .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n+                .collect();\n+            let func = context.new_function(None, FunctionType::Exported, output.unwrap_or(void), &args, name, false);\n \n-        if tcx.sess.target.options.default_hidden_visibility {\n+            if tcx.sess.target.options.default_hidden_visibility {\n+                #[cfg(feature=\"master\")]\n+                func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+            }\n+            if tcx.sess.must_emit_unwind_tables() {\n+                // TODO(antoyo): emit unwind tables.\n+            }\n+\n+            let callee = default_fn_name(method.name);\n+            let args: Vec<_> = types.iter().enumerate()\n+                .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n+                .collect();\n+            let callee = context.new_function(None, FunctionType::Extern, output.unwrap_or(void), &args, callee, false);\n             #[cfg(feature=\"master\")]\n-            func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n-        }\n-        if tcx.sess.must_emit_unwind_tables() {\n-            // TODO(antoyo): emit unwind tables.\n-        }\n+            callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n+\n+            let block = func.new_block(\"entry\");\n+\n+            let args = args\n+                .iter()\n+                .enumerate()\n+                .map(|(i, _)| func.get_param(i as i32).to_rvalue())\n+                .collect::<Vec<_>>();\n+            let ret = context.new_call(None, callee, &args);\n+            //llvm::LLVMSetTailCall(ret, True);\n+            if output.is_some() {\n+                block.end_with_return(None, ret);\n+            }\n+            else {\n+                block.end_with_void_return(None);\n+            }\n \n-        let callee = kind.fn_name(method.name);\n-        let args: Vec<_> = types.iter().enumerate()\n-            .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n-            .collect();\n-        let callee = context.new_function(None, FunctionType::Extern, output.unwrap_or(void), &args, callee, false);\n-        #[cfg(feature=\"master\")]\n-        callee.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n-\n-        let block = func.new_block(\"entry\");\n-\n-        let args = args\n-            .iter()\n-            .enumerate()\n-            .map(|(i, _)| func.get_param(i as i32).to_rvalue())\n-            .collect::<Vec<_>>();\n-        let ret = context.new_call(None, callee, &args);\n-        //llvm::LLVMSetTailCall(ret, True);\n-        if output.is_some() {\n-            block.end_with_return(None, ret);\n-        }\n-        else {\n-            block.end_with_void_return(None);\n+            // TODO(@Commeownist): Check if we need to emit some extra debugging info in certain circumstances\n+            // as described in https://github.com/rust-lang/rust/commit/77a96ed5646f7c3ee8897693decc4626fe380643\n         }\n-\n-        // TODO(@Commeownist): Check if we need to emit some extra debugging info in certain circumstances\n-        // as described in https://github.com/rust-lang/rust/commit/77a96ed5646f7c3ee8897693decc4626fe380643\n     }\n \n     let types = [usize, usize];\n@@ -99,7 +103,7 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n         func.add_attribute(FnAttribute::Visibility(gccjit::Visibility::Hidden));\n     }\n \n-    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_name(alloc_error_handler_kind);\n     let args: Vec<_> = types.iter().enumerate()\n         .map(|(index, typ)| context.new_parameter(None, *typ, &format!(\"param{}\", index)))\n         .collect();\n@@ -123,4 +127,9 @@ pub(crate) unsafe fn codegen(tcx: TyCtxt<'_>, mods: &mut GccContext, _module_nam\n     let value = tcx.sess.opts.unstable_opts.oom.should_panic();\n     let value = context.new_rvalue_from_int(i8, value as i32);\n     global.global_set_initializer_rvalue(value);\n+\n+    let name = NO_ALLOC_SHIM_IS_UNSTABLE.to_string();\n+    let global = context.new_global(None, GlobalKind::Exported, i8, name);\n+    let value = context.new_rvalue_from_int(i8, 0);\n+    global.global_set_initializer_rvalue(value);\n }"}, {"sha": "55622fdb20ad9136604051c00308c86f0b2aec2d", "filename": "compiler/rustc_codegen_llvm/messages.ftl", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,90 +1,90 @@\n-codegen_llvm_unknown_ctarget_feature =\n-    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n-    .note = it is still passed through to the codegen backend\n-    .possible_feature = you might have meant: `{$rust_feature}`\n-    .consider_filing_feature_request = consider filing a feature request\n+codegen_llvm_copy_bitcode = failed to copy bitcode to object file: {$err}\n \n-codegen_llvm_unknown_ctarget_feature_prefix =\n-    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n-    .note = features must begin with a `+` to enable or `-` to disable it\n+codegen_llvm_dlltool_fail_import_library =\n+    Dlltool could not create import library: {$stdout}\n+    {$stderr}\n+\n+codegen_llvm_dynamic_linking_with_lto =\n+    cannot prefer dynamic linking when performing LTO\n+    .note = only 'staticlib', 'bin', and 'cdylib' outputs are supported with LTO\n+\n+codegen_llvm_error_calling_dlltool =\n+    Error calling dlltool '{$dlltool_path}': {$error}\n \n codegen_llvm_error_creating_import_library =\n     Error creating import library for {$lib_name}: {$error}\n \n-codegen_llvm_symbol_already_defined =\n-    symbol `{$symbol_name}` is already defined\n+codegen_llvm_error_writing_def_file =\n+    Error writing .DEF file: {$error}\n+\n+codegen_llvm_from_llvm_diag = {$message}\n \n+codegen_llvm_from_llvm_optimization_diag = {$filename}:{$line}:{$column} {$pass_name} ({$kind}): {$message}\n codegen_llvm_invalid_minimum_alignment =\n     invalid minimum global alignment: {$err}\n \n-codegen_llvm_sanitizer_memtag_requires_mte =\n-    `-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\n-\n-codegen_llvm_error_writing_def_file =\n-    Error writing .DEF file: {$error}\n+codegen_llvm_load_bitcode = failed to load bitcode of module \"{$name}\"\n+codegen_llvm_load_bitcode_with_llvm_err = failed to load bitcode of module \"{$name}\": {$llvm_err}\n \n-codegen_llvm_error_calling_dlltool =\n-    Error calling dlltool '{$dlltool_path}': {$error}\n+codegen_llvm_lto_bitcode_from_rlib = failed to get bitcode from object file for LTO ({$llvm_err})\n \n-codegen_llvm_dlltool_fail_import_library =\n-    Dlltool could not create import library: {$stdout}\n-    {$stderr}\n+codegen_llvm_lto_disallowed = lto can only be run for executables, cdylibs and static library outputs\n \n-codegen_llvm_target_feature_disable_or_enable =\n-    the target features {$features} must all be either enabled or disabled together\n+codegen_llvm_lto_dylib = lto cannot be used for `dylib` crate type without `-Zdylib-lto`\n \n codegen_llvm_missing_features =\n     add the missing features in a `target_feature` attribute\n \n-codegen_llvm_dynamic_linking_with_lto =\n-    cannot prefer dynamic linking when performing LTO\n-    .note = only 'staticlib', 'bin', and 'cdylib' outputs are supported with LTO\n+codegen_llvm_multiple_source_dicompileunit = multiple source DICompileUnits found\n+codegen_llvm_multiple_source_dicompileunit_with_llvm_err = multiple source DICompileUnits found: {$llvm_err}\n+\n+codegen_llvm_parse_bitcode = failed to parse bitcode for LTO module\n+codegen_llvm_parse_bitcode_with_llvm_err = failed to parse bitcode for LTO module: {$llvm_err}\n \n codegen_llvm_parse_target_machine_config =\n     failed to parse target machine config to target machine: {$error}\n \n-codegen_llvm_lto_disallowed = lto can only be run for executables, cdylibs and static library outputs\n-\n-codegen_llvm_lto_dylib = lto cannot be used for `dylib` crate type without `-Zdylib-lto`\n-\n-codegen_llvm_lto_bitcode_from_rlib = failed to get bitcode from object file for LTO ({$llvm_err})\n-\n-codegen_llvm_write_output = could not write output to {$path}\n-codegen_llvm_write_output_with_llvm_err = could not write output to {$path}: {$llvm_err}\n+codegen_llvm_prepare_thin_lto_context = failed to prepare thin LTO context\n+codegen_llvm_prepare_thin_lto_context_with_llvm_err = failed to prepare thin LTO context: {$llvm_err}\n \n-codegen_llvm_target_machine = could not create LLVM TargetMachine for triple: {$triple}\n-codegen_llvm_target_machine_with_llvm_err = could not create LLVM TargetMachine for triple: {$triple}: {$llvm_err}\n+codegen_llvm_prepare_thin_lto_module = failed to prepare thin LTO module\n+codegen_llvm_prepare_thin_lto_module_with_llvm_err = failed to prepare thin LTO module: {$llvm_err}\n \n codegen_llvm_run_passes = failed to run LLVM passes\n codegen_llvm_run_passes_with_llvm_err = failed to run LLVM passes: {$llvm_err}\n \n+codegen_llvm_sanitizer_memtag_requires_mte =\n+    `-Zsanitizer=memtag` requires `-Ctarget-feature=+mte`\n+\n codegen_llvm_serialize_module = failed to serialize module {$name}\n codegen_llvm_serialize_module_with_llvm_err = failed to serialize module {$name}: {$llvm_err}\n \n-codegen_llvm_write_ir = failed to write LLVM IR to {$path}\n-codegen_llvm_write_ir_with_llvm_err = failed to write LLVM IR to {$path}: {$llvm_err}\n-\n-codegen_llvm_prepare_thin_lto_context = failed to prepare thin LTO context\n-codegen_llvm_prepare_thin_lto_context_with_llvm_err = failed to prepare thin LTO context: {$llvm_err}\n+codegen_llvm_symbol_already_defined =\n+    symbol `{$symbol_name}` is already defined\n \n-codegen_llvm_load_bitcode = failed to load bitcode of module \"{$name}\"\n-codegen_llvm_load_bitcode_with_llvm_err = failed to load bitcode of module \"{$name}\": {$llvm_err}\n+codegen_llvm_target_feature_disable_or_enable =\n+    the target features {$features} must all be either enabled or disabled together\n \n-codegen_llvm_write_thinlto_key = error while writing ThinLTO key data: {$err}\n-codegen_llvm_write_thinlto_key_with_llvm_err = error while writing ThinLTO key data: {$err}: {$llvm_err}\n+codegen_llvm_target_machine = could not create LLVM TargetMachine for triple: {$triple}\n+codegen_llvm_target_machine_with_llvm_err = could not create LLVM TargetMachine for triple: {$triple}: {$llvm_err}\n \n-codegen_llvm_multiple_source_dicompileunit = multiple source DICompileUnits found\n-codegen_llvm_multiple_source_dicompileunit_with_llvm_err = multiple source DICompileUnits found: {$llvm_err}\n+codegen_llvm_unknown_ctarget_feature =\n+    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n+    .note = it is still passed through to the codegen backend\n+    .possible_feature = you might have meant: `{$rust_feature}`\n+    .consider_filing_feature_request = consider filing a feature request\n \n-codegen_llvm_prepare_thin_lto_module = failed to prepare thin LTO module\n-codegen_llvm_prepare_thin_lto_module_with_llvm_err = failed to prepare thin LTO module: {$llvm_err}\n+codegen_llvm_unknown_ctarget_feature_prefix =\n+    unknown feature specified for `-Ctarget-feature`: `{$feature}`\n+    .note = features must begin with a `+` to enable or `-` to disable it\n \n-codegen_llvm_parse_bitcode = failed to parse bitcode for LTO module\n-codegen_llvm_parse_bitcode_with_llvm_err = failed to parse bitcode for LTO module: {$llvm_err}\n+codegen_llvm_write_bytecode = failed to write bytecode to {$path}: {$err}\n \n-codegen_llvm_from_llvm_optimization_diag = {$filename}:{$line}:{$column} {$pass_name} ({$kind}): {$message}\n-codegen_llvm_from_llvm_diag = {$message}\n+codegen_llvm_write_ir = failed to write LLVM IR to {$path}\n+codegen_llvm_write_ir_with_llvm_err = failed to write LLVM IR to {$path}: {$llvm_err}\n \n-codegen_llvm_write_bytecode = failed to write bytecode to {$path}: {$err}\n+codegen_llvm_write_output = could not write output to {$path}\n+codegen_llvm_write_output_with_llvm_err = could not write output to {$path}: {$llvm_err}\n \n-codegen_llvm_copy_bitcode = failed to copy bitcode to object file: {$err}\n+codegen_llvm_write_thinlto_key = error while writing ThinLTO key data: {$err}\n+codegen_llvm_write_thinlto_key_with_llvm_err = error while writing ThinLTO key data: {$err}: {$llvm_err}"}, {"sha": "a57508815d6f81ac9fdc5e61d4eddbb3d2b2b3a5", "filename": "compiler/rustc_codegen_llvm/src/allocator.rs", "status": "modified", "additions": 79, "deletions": 66, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fallocator.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,10 +1,12 @@\n use crate::attributes;\n use libc::c_uint;\n-use rustc_ast::expand::allocator::{AllocatorKind, AllocatorTy, ALLOCATOR_METHODS};\n+use rustc_ast::expand::allocator::{\n+    alloc_error_handler_name, default_fn_name, global_fn_name, AllocatorKind, AllocatorTy,\n+    ALLOCATOR_METHODS, NO_ALLOC_SHIM_IS_UNSTABLE,\n+};\n use rustc_middle::bug;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::config::{DebugInfo, OomStrategy};\n-use rustc_span::symbol::sym;\n \n use crate::debuginfo;\n use crate::llvm::{self, False, True};\n@@ -29,75 +31,78 @@ pub(crate) unsafe fn codegen(\n     let i8p = llvm::LLVMPointerType(i8, 0);\n     let void = llvm::LLVMVoidTypeInContext(llcx);\n \n-    for method in ALLOCATOR_METHODS {\n-        let mut args = Vec::with_capacity(method.inputs.len());\n-        for ty in method.inputs.iter() {\n-            match *ty {\n-                AllocatorTy::Layout => {\n-                    args.push(usize); // size\n-                    args.push(usize); // align\n+    if kind == AllocatorKind::Default {\n+        for method in ALLOCATOR_METHODS {\n+            let mut args = Vec::with_capacity(method.inputs.len());\n+            for ty in method.inputs.iter() {\n+                match *ty {\n+                    AllocatorTy::Layout => {\n+                        args.push(usize); // size\n+                        args.push(usize); // align\n+                    }\n+                    AllocatorTy::Ptr => args.push(i8p),\n+                    AllocatorTy::Usize => args.push(usize),\n+\n+                    AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n                 }\n-                AllocatorTy::Ptr => args.push(i8p),\n-                AllocatorTy::Usize => args.push(usize),\n-\n-                AllocatorTy::ResultPtr | AllocatorTy::Unit => panic!(\"invalid allocator arg\"),\n             }\n-        }\n-        let output = match method.output {\n-            AllocatorTy::ResultPtr => Some(i8p),\n-            AllocatorTy::Unit => None,\n+            let output = match method.output {\n+                AllocatorTy::ResultPtr => Some(i8p),\n+                AllocatorTy::Unit => None,\n \n-            AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n-                panic!(\"invalid allocator output\")\n+                AllocatorTy::Layout | AllocatorTy::Usize | AllocatorTy::Ptr => {\n+                    panic!(\"invalid allocator output\")\n+                }\n+            };\n+            let ty = llvm::LLVMFunctionType(\n+                output.unwrap_or(void),\n+                args.as_ptr(),\n+                args.len() as c_uint,\n+                False,\n+            );\n+            let name = global_fn_name(method.name);\n+            let llfn =\n+                llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n+\n+            if tcx.sess.target.default_hidden_visibility {\n+                llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n+            }\n+            if tcx.sess.must_emit_unwind_tables() {\n+                let uwtable = attributes::uwtable_attr(llcx);\n+                attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n             }\n-        };\n-        let ty = llvm::LLVMFunctionType(\n-            output.unwrap_or(void),\n-            args.as_ptr(),\n-            args.len() as c_uint,\n-            False,\n-        );\n-        let name = format!(\"__rust_{}\", method.name);\n-        let llfn = llvm::LLVMRustGetOrInsertFunction(llmod, name.as_ptr().cast(), name.len(), ty);\n-\n-        if tcx.sess.target.default_hidden_visibility {\n-            llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n-        }\n-        if tcx.sess.must_emit_unwind_tables() {\n-            let uwtable = attributes::uwtable_attr(llcx);\n-            attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n-        }\n \n-        let callee = kind.fn_name(method.name);\n-        let callee =\n-            llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n-        llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n-\n-        let llbb = llvm::LLVMAppendBasicBlockInContext(llcx, llfn, \"entry\\0\".as_ptr().cast());\n-\n-        let llbuilder = llvm::LLVMCreateBuilderInContext(llcx);\n-        llvm::LLVMPositionBuilderAtEnd(llbuilder, llbb);\n-        let args = args\n-            .iter()\n-            .enumerate()\n-            .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n-            .collect::<Vec<_>>();\n-        let ret = llvm::LLVMRustBuildCall(\n-            llbuilder,\n-            ty,\n-            callee,\n-            args.as_ptr(),\n-            args.len() as c_uint,\n-            [].as_ptr(),\n-            0 as c_uint,\n-        );\n-        llvm::LLVMSetTailCall(ret, True);\n-        if output.is_some() {\n-            llvm::LLVMBuildRet(llbuilder, ret);\n-        } else {\n-            llvm::LLVMBuildRetVoid(llbuilder);\n+            let callee = default_fn_name(method.name);\n+            let callee =\n+                llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n+            llvm::LLVMRustSetVisibility(callee, llvm::Visibility::Hidden);\n+\n+            let llbb = llvm::LLVMAppendBasicBlockInContext(llcx, llfn, \"entry\\0\".as_ptr().cast());\n+\n+            let llbuilder = llvm::LLVMCreateBuilderInContext(llcx);\n+            llvm::LLVMPositionBuilderAtEnd(llbuilder, llbb);\n+            let args = args\n+                .iter()\n+                .enumerate()\n+                .map(|(i, _)| llvm::LLVMGetParam(llfn, i as c_uint))\n+                .collect::<Vec<_>>();\n+            let ret = llvm::LLVMRustBuildCall(\n+                llbuilder,\n+                ty,\n+                callee,\n+                args.as_ptr(),\n+                args.len() as c_uint,\n+                [].as_ptr(),\n+                0 as c_uint,\n+            );\n+            llvm::LLVMSetTailCall(ret, True);\n+            if output.is_some() {\n+                llvm::LLVMBuildRet(llbuilder, ret);\n+            } else {\n+                llvm::LLVMBuildRetVoid(llbuilder);\n+            }\n+            llvm::LLVMDisposeBuilder(llbuilder);\n         }\n-        llvm::LLVMDisposeBuilder(llbuilder);\n     }\n \n     // rust alloc error handler\n@@ -118,7 +123,7 @@ pub(crate) unsafe fn codegen(\n         attributes::apply_to_llfn(llfn, llvm::AttributePlace::Function, &[uwtable]);\n     }\n \n-    let callee = alloc_error_handler_kind.fn_name(sym::oom);\n+    let callee = alloc_error_handler_name(alloc_error_handler_kind);\n     let callee = llvm::LLVMRustGetOrInsertFunction(llmod, callee.as_ptr().cast(), callee.len(), ty);\n     // -> ! DIFlagNoReturn\n     attributes::apply_to_llfn(callee, llvm::AttributePlace::Function, &[no_return]);\n@@ -156,6 +161,14 @@ pub(crate) unsafe fn codegen(\n     let llval = llvm::LLVMConstInt(i8, val as u64, False);\n     llvm::LLVMSetInitializer(ll_g, llval);\n \n+    let name = NO_ALLOC_SHIM_IS_UNSTABLE;\n+    let ll_g = llvm::LLVMRustGetOrInsertGlobal(llmod, name.as_ptr().cast(), name.len(), i8);\n+    if tcx.sess.target.default_hidden_visibility {\n+        llvm::LLVMRustSetVisibility(ll_g, llvm::Visibility::Hidden);\n+    }\n+    let llval = llvm::LLVMConstInt(i8, 0, False);\n+    llvm::LLVMSetInitializer(ll_g, llval);\n+\n     if tcx.sess.opts.debuginfo != DebugInfo::None {\n         let dbg_cx = debuginfo::CodegenUnitDebugContext::new(llmod);\n         debuginfo::metadata::build_compile_unit_di_node(tcx, module_name, &dbg_cx);"}, {"sha": "21a1ac348443ecb74b639445b14544f3229343d6", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -163,7 +163,7 @@ impl CoverageMapGenerator {\n         counter_regions.sort_unstable_by_key(|(_counter, region)| *region);\n         for (counter, region) in counter_regions {\n             let CodeRegion { file_name, start_line, start_col, end_line, end_col } = *region;\n-            let same_file = current_file_name.map_or(false, |p| p == file_name);\n+            let same_file = current_file_name.is_some_and(|p| p == file_name);\n             if !same_file {\n                 if current_file_name.is_some() {\n                     current_file_id += 1;"}, {"sha": "805843e5863e641de8cd1b315c801ad1dd601c48", "filename": "compiler/rustc_codegen_llvm/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -10,6 +10,7 @@\n #![feature(iter_intersperse)]\n #![feature(let_chains)]\n #![feature(never_type)]\n+#![feature(impl_trait_in_assoc_type)]\n #![recursion_limit = \"256\"]\n #![allow(rustc::potential_query_instability)]\n #![deny(rustc::untranslatable_diagnostic)]"}, {"sha": "03be0654b50bbb94c577ed36e86c596db7d864e3", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 128, "deletions": 38, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -16,7 +16,6 @@ use rustc_session::config::PrintRequest;\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n use rustc_target::spec::{MergeFunctions, PanicStrategy};\n-use smallvec::{smallvec, SmallVec};\n use std::ffi::{CStr, CString};\n \n use std::path::Path;\n@@ -132,6 +131,60 @@ pub fn time_trace_profiler_finish(file_name: &Path) {\n     }\n }\n \n+pub enum TargetFeatureFoldStrength<'a> {\n+    // The feature is only tied when enabling the feature, disabling\n+    // this feature shouldn't disable the tied feature.\n+    EnableOnly(&'a str),\n+    // The feature is tied for both enabling and disabling this feature.\n+    Both(&'a str),\n+}\n+\n+impl<'a> TargetFeatureFoldStrength<'a> {\n+    fn as_str(&self) -> &'a str {\n+        match self {\n+            TargetFeatureFoldStrength::EnableOnly(feat) => feat,\n+            TargetFeatureFoldStrength::Both(feat) => feat,\n+        }\n+    }\n+}\n+\n+pub struct LLVMFeature<'a> {\n+    pub llvm_feature_name: &'a str,\n+    pub dependency: Option<TargetFeatureFoldStrength<'a>>,\n+}\n+\n+impl<'a> LLVMFeature<'a> {\n+    pub fn new(llvm_feature_name: &'a str) -> Self {\n+        Self { llvm_feature_name, dependency: None }\n+    }\n+\n+    pub fn with_dependency(\n+        llvm_feature_name: &'a str,\n+        dependency: TargetFeatureFoldStrength<'a>,\n+    ) -> Self {\n+        Self { llvm_feature_name, dependency: Some(dependency) }\n+    }\n+\n+    pub fn contains(&self, feat: &str) -> bool {\n+        self.iter().any(|dep| dep == feat)\n+    }\n+\n+    pub fn iter(&'a self) -> impl Iterator<Item = &'a str> {\n+        let dependencies = self.dependency.iter().map(|feat| feat.as_str());\n+        std::iter::once(self.llvm_feature_name).chain(dependencies)\n+    }\n+}\n+\n+impl<'a> IntoIterator for LLVMFeature<'a> {\n+    type Item = &'a str;\n+    type IntoIter = impl Iterator<Item = &'a str>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        let dependencies = self.dependency.into_iter().map(|feat| feat.as_str());\n+        std::iter::once(self.llvm_feature_name).chain(dependencies)\n+    }\n+}\n+\n // WARNING: the features after applying `to_llvm_features` must be known\n // to LLVM or the feature detection code will walk past the end of the feature\n // array, leading to crashes.\n@@ -147,36 +200,65 @@ pub fn time_trace_profiler_finish(file_name: &Path) {\n // Though note that Rust can also be build with an external precompiled version of LLVM\n // which might lead to failures if the oldest tested / supported LLVM version\n // doesn't yet support the relevant intrinsics\n-pub fn to_llvm_features<'a>(sess: &Session, s: &'a str) -> SmallVec<[&'a str; 2]> {\n+pub fn to_llvm_features<'a>(sess: &Session, s: &'a str) -> LLVMFeature<'a> {\n     let arch = if sess.target.arch == \"x86_64\" { \"x86\" } else { &*sess.target.arch };\n     match (arch, s) {\n-        (\"x86\", \"sse4.2\") => smallvec![\"sse4.2\", \"crc32\"],\n-        (\"x86\", \"pclmulqdq\") => smallvec![\"pclmul\"],\n-        (\"x86\", \"rdrand\") => smallvec![\"rdrnd\"],\n-        (\"x86\", \"bmi1\") => smallvec![\"bmi\"],\n-        (\"x86\", \"cmpxchg16b\") => smallvec![\"cx16\"],\n-        (\"aarch64\", \"rcpc2\") => smallvec![\"rcpc-immo\"],\n-        (\"aarch64\", \"dpb\") => smallvec![\"ccpp\"],\n-        (\"aarch64\", \"dpb2\") => smallvec![\"ccdp\"],\n-        (\"aarch64\", \"frintts\") => smallvec![\"fptoint\"],\n-        (\"aarch64\", \"fcma\") => smallvec![\"complxnum\"],\n-        (\"aarch64\", \"pmuv3\") => smallvec![\"perfmon\"],\n-        (\"aarch64\", \"paca\") => smallvec![\"pauth\"],\n-        (\"aarch64\", \"pacg\") => smallvec![\"pauth\"],\n-        // Rust ties fp and neon together. In LLVM neon implicitly enables fp,\n-        // but we manually enable neon when a feature only implicitly enables fp\n-        (\"aarch64\", \"f32mm\") => smallvec![\"f32mm\", \"neon\"],\n-        (\"aarch64\", \"f64mm\") => smallvec![\"f64mm\", \"neon\"],\n-        (\"aarch64\", \"fhm\") => smallvec![\"fp16fml\", \"neon\"],\n-        (\"aarch64\", \"fp16\") => smallvec![\"fullfp16\", \"neon\"],\n-        (\"aarch64\", \"jsconv\") => smallvec![\"jsconv\", \"neon\"],\n-        (\"aarch64\", \"sve\") => smallvec![\"sve\", \"neon\"],\n-        (\"aarch64\", \"sve2\") => smallvec![\"sve2\", \"neon\"],\n-        (\"aarch64\", \"sve2-aes\") => smallvec![\"sve2-aes\", \"neon\"],\n-        (\"aarch64\", \"sve2-sm4\") => smallvec![\"sve2-sm4\", \"neon\"],\n-        (\"aarch64\", \"sve2-sha3\") => smallvec![\"sve2-sha3\", \"neon\"],\n-        (\"aarch64\", \"sve2-bitperm\") => smallvec![\"sve2-bitperm\", \"neon\"],\n-        (_, s) => smallvec![s],\n+        (\"x86\", \"sse4.2\") => {\n+            LLVMFeature::with_dependency(\"sse4.2\", TargetFeatureFoldStrength::EnableOnly(\"crc32\"))\n+        }\n+        (\"x86\", \"pclmulqdq\") => LLVMFeature::new(\"pclmul\"),\n+        (\"x86\", \"rdrand\") => LLVMFeature::new(\"rdrnd\"),\n+        (\"x86\", \"bmi1\") => LLVMFeature::new(\"bmi\"),\n+        (\"x86\", \"cmpxchg16b\") => LLVMFeature::new(\"cx16\"),\n+        (\"aarch64\", \"rcpc2\") => LLVMFeature::new(\"rcpc-immo\"),\n+        (\"aarch64\", \"dpb\") => LLVMFeature::new(\"ccpp\"),\n+        (\"aarch64\", \"dpb2\") => LLVMFeature::new(\"ccdp\"),\n+        (\"aarch64\", \"frintts\") => LLVMFeature::new(\"fptoint\"),\n+        (\"aarch64\", \"fcma\") => LLVMFeature::new(\"complxnum\"),\n+        (\"aarch64\", \"pmuv3\") => LLVMFeature::new(\"perfmon\"),\n+        (\"aarch64\", \"paca\") => LLVMFeature::new(\"pauth\"),\n+        (\"aarch64\", \"pacg\") => LLVMFeature::new(\"pauth\"),\n+        // Rust ties fp and neon together.\n+        (\"aarch64\", \"neon\") => {\n+            LLVMFeature::with_dependency(\"neon\", TargetFeatureFoldStrength::Both(\"fp-armv8\"))\n+        }\n+        // In LLVM neon implicitly enables fp, but we manually enable\n+        // neon when a feature only implicitly enables fp\n+        (\"aarch64\", \"f32mm\") => {\n+            LLVMFeature::with_dependency(\"f32mm\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"f64mm\") => {\n+            LLVMFeature::with_dependency(\"f64mm\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"fhm\") => {\n+            LLVMFeature::with_dependency(\"fp16fml\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"fp16\") => {\n+            LLVMFeature::with_dependency(\"fullfp16\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"jsconv\") => {\n+            LLVMFeature::with_dependency(\"jsconv\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve\") => {\n+            LLVMFeature::with_dependency(\"sve\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve2\") => {\n+            LLVMFeature::with_dependency(\"sve2\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve2-aes\") => {\n+            LLVMFeature::with_dependency(\"sve2-aes\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve2-sm4\") => {\n+            LLVMFeature::with_dependency(\"sve2-sm4\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve2-sha3\") => {\n+            LLVMFeature::with_dependency(\"sve2-sha3\", TargetFeatureFoldStrength::EnableOnly(\"neon\"))\n+        }\n+        (\"aarch64\", \"sve2-bitperm\") => LLVMFeature::with_dependency(\n+            \"sve2-bitperm\",\n+            TargetFeatureFoldStrength::EnableOnly(\"neon\"),\n+        ),\n+        (_, s) => LLVMFeature::new(s),\n     }\n }\n \n@@ -274,18 +356,17 @@ fn print_target_features(sess: &Session, tm: &llvm::TargetMachine) {\n     let mut rustc_target_features = supported_target_features(sess)\n         .iter()\n         .map(|(feature, _gate)| {\n-            let desc = if let Some(llvm_feature) = to_llvm_features(sess, *feature).first() {\n-                // LLVM asserts that these are sorted. LLVM and Rust both use byte comparison for these strings.\n+            // LLVM asserts that these are sorted. LLVM and Rust both use byte comparison for these strings.\n+            let llvm_feature = to_llvm_features(sess, *feature).llvm_feature_name;\n+            let desc =\n                 match llvm_target_features.binary_search_by_key(&llvm_feature, |(f, _d)| f).ok() {\n                     Some(index) => {\n                         known_llvm_target_features.insert(llvm_feature);\n                         llvm_target_features[index].1\n                     }\n                     None => \"\",\n-                }\n-            } else {\n-                \"\"\n-            };\n+                };\n+\n             (*feature, desc)\n         })\n         .collect::<Vec<_>>();\n@@ -469,10 +550,19 @@ pub(crate) fn global_llvm_features(sess: &Session, diagnostics: bool) -> Vec<Str\n             // passing requests down to LLVM. This means that all in-language\n             // features also work on the command line instead of having two\n             // different names when the LLVM name and the Rust name differ.\n+            let llvm_feature = to_llvm_features(sess, feature);\n+\n             Some(\n-                to_llvm_features(sess, feature)\n-                    .into_iter()\n-                    .map(move |f| format!(\"{}{}\", enable_disable, f)),\n+                std::iter::once(format!(\"{}{}\", enable_disable, llvm_feature.llvm_feature_name))\n+                    .chain(llvm_feature.dependency.into_iter().filter_map(move |feat| {\n+                        match (enable_disable, feat) {\n+                            ('-' | '+', TargetFeatureFoldStrength::Both(f))\n+                            | ('+', TargetFeatureFoldStrength::EnableOnly(f)) => {\n+                                Some(format!(\"{}{}\", enable_disable, f))\n+                            }\n+                            _ => None,\n+                        }\n+                    })),\n             )\n         })\n         .flatten();"}, {"sha": "c24854b27a02e9095e106ed9c271478fae11e3b8", "filename": "compiler/rustc_codegen_llvm/src/mono_item.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fmono_item.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -125,8 +125,7 @@ impl CodegenCx<'_, '_> {\n \n         // Thread-local variables generally don't support copy relocations.\n         let is_thread_local_var = llvm::LLVMIsAGlobalVariable(llval)\n-            .map(|v| llvm::LLVMIsThreadLocal(v) == llvm::True)\n-            .unwrap_or(false);\n+            .is_some_and(|v| llvm::LLVMIsThreadLocal(v) == llvm::True);\n         if is_thread_local_var {\n             return false;\n         }"}, {"sha": "9aa2b2e2b2ed020013f9a6aaa3bbc89275a776c6", "filename": "compiler/rustc_codegen_ssa/messages.ftl", "status": "modified", "additions": 162, "deletions": 162, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,306 +1,306 @@\n-codegen_ssa_lib_def_write_failure = failed to write lib.def file: {$error}\n-\n-codegen_ssa_version_script_write_failure = failed to write version script: {$error}\n+codegen_ssa_L4Bender_exporting_symbols_unimplemented = exporting symbols not implemented yet for L4Bender\n \n-codegen_ssa_symbol_file_write_failure = failed to write symbols file: {$error}\n+codegen_ssa_add_native_library = failed to add native library {$library_path}: {$error}\n \n-codegen_ssa_ld64_unimplemented_modifier = `as-needed` modifier not implemented yet for ld64\n+codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {$error}\n \n-codegen_ssa_linker_unsupported_modifier = `as-needed` modifier not supported for current linker\n+codegen_ssa_archive_build_failure =\n+    failed to build archive: {$error}\n \n-codegen_ssa_L4Bender_exporting_symbols_unimplemented = exporting symbols not implemented yet for L4Bender\n+codegen_ssa_atomic_compare_exchange = Atomic compare-exchange intrinsic missing failure memory ordering\n \n-codegen_ssa_no_natvis_directory = error enumerating natvis directory: {$error}\n+codegen_ssa_check_installed_visual_studio = please ensure that Visual Studio 2017 or later, or Build Tools for Visual Studio were installed with the Visual C++ option.\n \n codegen_ssa_copy_path = could not copy {$from} to {$to}: {$error}\n \n codegen_ssa_copy_path_buf = unable to copy {$source_file} to {$output_path}: {$error}\n \n+codegen_ssa_create_temp_dir = couldn't create a temp dir: {$error}\n+\n+codegen_ssa_erroneous_constant = erroneous constant encountered\n+\n+codegen_ssa_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+\n+codegen_ssa_extern_funcs_not_found = some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n+\n+codegen_ssa_extract_bundled_libs_archive_member = failed to get data from archive member '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_convert_name = failed to convert name '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_mmap_file = failed to mmap file '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_open_file = failed to open file '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_parse_archive = failed to parse archive '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_read_entry = failed to read entry '{$rlib}': {$error}\n+codegen_ssa_extract_bundled_libs_write_file = failed to write file '{$rlib}': {$error}\n+\n+codegen_ssa_failed_to_write = failed to write {$path}: {$error}\n+\n codegen_ssa_ignoring_emit_path = ignoring emit path because multiple .{$extension} files were produced\n \n codegen_ssa_ignoring_output = ignoring -o because multiple .{$extension} files were produced\n \n-codegen_ssa_create_temp_dir = couldn't create a temp dir: {$error}\n+codegen_ssa_illegal_link_ordinal_format = illegal ordinal format in `link_ordinal`\n+    .note = an unsuffixed integer value, e.g., `1`, is expected\n \n codegen_ssa_incompatible_linking_modifiers = link modifiers combination `+bundle,+whole-archive` is unstable when generating rlibs\n \n-codegen_ssa_add_native_library = failed to add native library {$library_path}: {$error}\n-\n-codegen_ssa_multiple_external_func_decl = multiple declarations of external function `{$function}` from library `{$library_name}` have different calling conventions\n+codegen_ssa_insufficient_vs_code_product = VS Code is a different product, and is not sufficient.\n \n-codegen_ssa_rlib_missing_format = could not find formats for rlibs\n+codegen_ssa_invalid_link_ordinal_nargs = incorrect number of arguments to `#[link_ordinal]`\n+    .note = the attribute requires exactly one argument\n \n-codegen_ssa_rlib_only_rmeta_found = could not find rlib for: `{$crate_name}`, found rmeta (metadata) file\n+codegen_ssa_invalid_monomorphization_basic_float_type = invalid monomorphization of `{$name}` intrinsic: expected basic float type, found `{$ty}`\n \n-codegen_ssa_rlib_not_found = could not find rlib for: `{$crate_name}`\n+codegen_ssa_invalid_monomorphization_basic_integer_type = invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n \n-codegen_ssa_rlib_incompatible_dependency_formats = `{$ty1}` and `{$ty2}` do not have equivalent dependency formats (`{$list1}` vs `{$list2}`)\n+codegen_ssa_invalid_monomorphization_cannot_return = invalid monomorphization of `{$name}` intrinsic: cannot return `{$ret_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n \n-codegen_ssa_linking_failed = linking with `{$linker_path}` failed: {$exit_status}\n+codegen_ssa_invalid_monomorphization_cast_fat_pointer = invalid monomorphization of `{$name}` intrinsic: cannot cast fat pointer `{$ty}`\n \n-codegen_ssa_extern_funcs_not_found = some `extern` functions couldn't be found; some native libraries may need to be installed or have their path specified\n+codegen_ssa_invalid_monomorphization_expected_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of second argument `{$second_arg}` to be a pointer to the element type `{$in_elem}` of the first argument `{$in_ty}`, found `{$expected_element}` != `{$mutability} {$in_elem}`\n \n-codegen_ssa_specify_libraries_to_link = use the `-l` flag to specify native libraries to link\n+codegen_ssa_invalid_monomorphization_expected_pointer = invalid monomorphization of `{$name}` intrinsic: expected pointer, got `{$ty}`\n \n-codegen_ssa_use_cargo_directive = use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)\n+codegen_ssa_invalid_monomorphization_expected_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_ty}`, found `{$ret_ty}`\n \n-codegen_ssa_thorin_read_input_failure = failed to read input file\n+codegen_ssa_invalid_monomorphization_expected_usize = invalid monomorphization of `{$name}` intrinsic: expected `usize`, got `{$ty}`\n \n-codegen_ssa_thorin_parse_input_file_kind = failed to parse input file kind\n+codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type\n \n-codegen_ssa_thorin_parse_input_object_file = failed to parse input object file\n+codegen_ssa_invalid_monomorphization_float_to_int_unchecked = invalid monomorphization of `float_to_int_unchecked` intrinsic: expected basic float type, found `{$ty}`\n \n-codegen_ssa_thorin_parse_input_archive_file = failed to parse input archive file\n+codegen_ssa_invalid_monomorphization_floating_point_type = invalid monomorphization of `{$name}` intrinsic: `{$in_ty}` is not a floating-point type\n \n-codegen_ssa_thorin_parse_archive_member = failed to parse archive member\n+codegen_ssa_invalid_monomorphization_floating_point_vector = invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$f_ty}` of floating-point vector `{$in_ty}`\n \n-codegen_ssa_thorin_invalid_input_kind = input is not an archive or elf object\n+codegen_ssa_invalid_monomorphization_inserted_type = invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n \n-codegen_ssa_thorin_decompress_data = failed to decompress compressed section\n+codegen_ssa_invalid_monomorphization_invalid_bitmask = invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$mask_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n \n-codegen_ssa_thorin_section_without_name = section without name at offset {$offset}\n+codegen_ssa_invalid_monomorphization_mask_type = invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n \n-codegen_ssa_thorin_relocation_with_invalid_symbol = relocation with invalid symbol for section `{$section}` at offset {$offset}\n+codegen_ssa_invalid_monomorphization_mismatched_lengths = invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n \n-codegen_ssa_thorin_multiple_relocations = multiple relocations for section `{$section}` at offset {$offset}\n+codegen_ssa_invalid_monomorphization_return_element = invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n \n-codegen_ssa_thorin_unsupported_relocation = unsupported relocation for section {$section} at offset {$offset}\n+codegen_ssa_invalid_monomorphization_return_integer_type = invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n \n-codegen_ssa_thorin_missing_dwo_name = missing path attribute to DWARF object ({$id})\n+codegen_ssa_invalid_monomorphization_return_length = invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n \n-codegen_ssa_thorin_no_compilation_units = input object has no compilation units\n+codegen_ssa_invalid_monomorphization_return_length_input_type = invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n \n-codegen_ssa_thorin_no_die = no top-level debugging information entry in compilation/type unit\n+codegen_ssa_invalid_monomorphization_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n \n-codegen_ssa_thorin_top_level_die_not_unit = top-level debugging information entry is not a compilation/type unit\n+codegen_ssa_invalid_monomorphization_second_argument_length = invalid monomorphization of `{$name}` intrinsic: expected second argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n \n-codegen_ssa_thorin_missing_required_section = input object missing required section `{$section}`\n+codegen_ssa_invalid_monomorphization_shuffle_index_not_constant = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is not a constant\n \n-codegen_ssa_thorin_parse_unit_abbreviations = failed to parse unit abbreviations\n+codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is out of bounds (limit {$total_len})\n \n-codegen_ssa_thorin_parse_unit_attribute = failed to parse unit attribute\n+codegen_ssa_invalid_monomorphization_simd_argument = invalid monomorphization of `{$name}` intrinsic: expected SIMD argument type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_parse_unit_header = failed to parse unit header\n+codegen_ssa_invalid_monomorphization_simd_first = invalid monomorphization of `{$name}` intrinsic: expected SIMD first type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_parse_unit = failed to parse unit\n+codegen_ssa_invalid_monomorphization_simd_input = invalid monomorphization of `{$name}` intrinsic: expected SIMD input type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_incompatible_index_version = incompatible `{$section}` index version: found version {$actual}, expected version {$format}\n+codegen_ssa_invalid_monomorphization_simd_return = invalid monomorphization of `{$name}` intrinsic: expected SIMD return type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_offset_at_index = read offset at index {$index} of `.debug_str_offsets.dwo` section\n+codegen_ssa_invalid_monomorphization_simd_second = invalid monomorphization of `{$name}` intrinsic: expected SIMD second type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_str_at_offset = read string at offset {$offset} of `.debug_str.dwo` section\n+codegen_ssa_invalid_monomorphization_simd_shuffle = invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n \n-codegen_ssa_thorin_parse_index = failed to parse `{$section}` index section\n+codegen_ssa_invalid_monomorphization_simd_third = invalid monomorphization of `{$name}` intrinsic: expected SIMD third type, found non-SIMD `{$ty}`\n \n-codegen_ssa_thorin_unit_not_in_index = unit {$unit} from input package is not in its index\n+codegen_ssa_invalid_monomorphization_third_arg_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of third argument `{$third_arg}` to be a signed integer type\n \n-codegen_ssa_thorin_row_not_in_index = row {$row} found in index's hash table not present in index\n+codegen_ssa_invalid_monomorphization_third_argument_length = invalid monomorphization of `{$name}` intrinsic: expected third argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n \n-codegen_ssa_thorin_section_not_in_row = section not found in unit's row in index\n+codegen_ssa_invalid_monomorphization_unrecognized_intrinsic = invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n \n-codegen_ssa_thorin_empty_unit = unit {$unit} in input DWARF object with no data\n+codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n \n-codegen_ssa_thorin_multiple_debug_info_section = multiple `.debug_info.dwo` sections\n+codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n \n-codegen_ssa_thorin_multiple_debug_types_section = multiple `.debug_types.dwo` sections in a package\n+codegen_ssa_invalid_monomorphization_unsupported_symbol = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}`\n \n-codegen_ssa_thorin_not_split_unit = regular compilation unit in object (missing dwo identifier)\n+codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` of size `{$size}` to `{$ret_ty}`\n \n-codegen_ssa_thorin_duplicate_unit = duplicate split compilation unit ({$unit})\n+codegen_ssa_invalid_monomorphization_vector_argument = invalid monomorphization of `{$name}` intrinsic: vector argument `{$in_ty}`'s element type `{$in_elem}`, expected integer element type\n \n-codegen_ssa_thorin_missing_referenced_unit = unit {$unit} referenced by executable was not found\n+codegen_ssa_invalid_no_sanitize = invalid argument for `no_sanitize`\n+    .note = expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\n \n-codegen_ssa_thorin_not_output_object_created = no output object was created from inputs\n+codegen_ssa_invalid_windows_subsystem = invalid windows subsystem `{$subsystem}`, only `windows` and `console` are allowed\n \n-codegen_ssa_thorin_mixed_input_encodings = input objects haved mixed encodings\n+codegen_ssa_ld64_unimplemented_modifier = `as-needed` modifier not implemented yet for ld64\n \n-codegen_ssa_thorin_io = {$error}\n-codegen_ssa_thorin_object_read = {$error}\n-codegen_ssa_thorin_object_write = {$error}\n-codegen_ssa_thorin_gimli_read = {$error}\n-codegen_ssa_thorin_gimli_write = {$error}\n+codegen_ssa_lib_def_write_failure = failed to write lib.def file: {$error}\n \n codegen_ssa_link_exe_unexpected_error = `link.exe` returned an unexpected error\n \n-codegen_ssa_repair_vs_build_tools = the Visual Studio build tools may need to be repaired using the Visual Studio installer\n-\n-codegen_ssa_missing_cpp_build_tool_component = or a necessary component may be missing from the \"C++ build tools\" workload\n+codegen_ssa_link_script_unavailable = can only use link script when linking with GNU-like linker\n \n-codegen_ssa_select_cpp_build_tool_workload = in the Visual Studio installer, ensure the \"C++ build tools\" workload is selected\n+codegen_ssa_link_script_write_failure = failed to write link script to {$path}: {$error}\n \n-codegen_ssa_visual_studio_not_installed = you may need to install Visual Studio build tools with the \"C++ build tools\" workload\n+codegen_ssa_linker_file_stem = couldn't extract file stem from specified linker\n \n codegen_ssa_linker_not_found = linker `{$linker_path}` not found\n     .note = {$error}\n \n-codegen_ssa_unable_to_exe_linker = could not exec the linker `{$linker_path}`\n-    .note = {$error}\n-    .command_note = {$command_formatted}\n+codegen_ssa_linker_unsupported_modifier = `as-needed` modifier not supported for current linker\n \n-codegen_ssa_msvc_missing_linker = the msvc targets depend on the msvc linker but `link.exe` was not found\n+codegen_ssa_linking_failed = linking with `{$linker_path}` failed: {$exit_status}\n \n-codegen_ssa_check_installed_visual_studio = please ensure that Visual Studio 2017 or later, or Build Tools for Visual Studio were installed with the Visual C++ option.\n+codegen_ssa_metadata_object_file_write = error writing metadata object file: {$error}\n \n-codegen_ssa_insufficient_vs_code_product = VS Code is a different product, and is not sufficient.\n+codegen_ssa_missing_cpp_build_tool_component = or a necessary component may be missing from the \"C++ build tools\" workload\n \n-codegen_ssa_processing_dymutil_failed = processing debug info with `dsymutil` failed: {$status}\n-    .note = {$output}\n+codegen_ssa_missing_memory_ordering = Atomic intrinsic missing memory ordering\n \n-codegen_ssa_unable_to_run_dsymutil = unable to run `dsymutil`: {$error}\n+codegen_ssa_msvc_missing_linker = the msvc targets depend on the msvc linker but `link.exe` was not found\n \n-codegen_ssa_stripping_debug_info_failed = stripping debug info with `{$util}` failed: {$status}\n-    .note = {$output}\n+codegen_ssa_multiple_external_func_decl = multiple declarations of external function `{$function}` from library `{$library_name}` have different calling conventions\n \n-codegen_ssa_unable_to_run = unable to run `{$util}`: {$error}\n+codegen_ssa_multiple_main_functions = entry symbol `main` declared multiple times\n+    .help = did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\n \n-codegen_ssa_linker_file_stem = couldn't extract file stem from specified linker\n+codegen_ssa_no_natvis_directory = error enumerating natvis directory: {$error}\n \n-codegen_ssa_static_library_native_artifacts = Link against the following native artifacts when linking against this static library. The order and any duplication can be significant on some platforms.\n+codegen_ssa_option_gcc_only = option `-Z gcc-ld` is used even though linker flavor is not gcc\n \n-codegen_ssa_link_script_unavailable = can only use link script when linking with GNU-like linker\n+codegen_ssa_polymorphic_constant_too_generic = codegen encountered polymorphic constant: TooGeneric\n \n-codegen_ssa_link_script_write_failure = failed to write link script to {$path}: {$error}\n+codegen_ssa_processing_dymutil_failed = processing debug info with `dsymutil` failed: {$status}\n+    .note = {$output}\n \n-codegen_ssa_failed_to_write = failed to write {$path}: {$error}\n+codegen_ssa_read_file = failed to read file: {$message}\n \n-codegen_ssa_unable_to_write_debugger_visualizer = Unable to write debugger visualizer file `{$path}`: {$error}\n+codegen_ssa_repair_vs_build_tools = the Visual Studio build tools may need to be repaired using the Visual Studio installer\n \n codegen_ssa_rlib_archive_build_failure = failed to build archive from rlib: {$error}\n \n-codegen_ssa_option_gcc_only = option `-Z gcc-ld` is used even though linker flavor is not gcc\n-\n-codegen_ssa_extract_bundled_libs_open_file = failed to open file '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_mmap_file = failed to mmap file '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_parse_archive = failed to parse archive '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_read_entry = failed to read entry '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_archive_member = failed to get data from archive member '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_convert_name = failed to convert name '{$rlib}': {$error}\n-codegen_ssa_extract_bundled_libs_write_file = failed to write file '{$rlib}': {$error}\n-\n-codegen_ssa_unsupported_arch = unsupported arch `{$arch}` for os `{$os}`\n-\n-codegen_ssa_apple_sdk_error_sdk_path = failed to get {$sdk_name} SDK path: {$error}\n+codegen_ssa_rlib_incompatible_dependency_formats = `{$ty1}` and `{$ty2}` do not have equivalent dependency formats (`{$list1}` vs `{$list2}`)\n \n-codegen_ssa_read_file = failed to read file: {$message}\n+codegen_ssa_rlib_missing_format = could not find formats for rlibs\n \n-codegen_ssa_unsupported_link_self_contained = option `-C link-self-contained` is not supported on this target\n+codegen_ssa_rlib_not_found = could not find rlib for: `{$crate_name}`\n \n-codegen_ssa_archive_build_failure =\n-    failed to build archive: {$error}\n+codegen_ssa_rlib_only_rmeta_found = could not find rlib for: `{$crate_name}`, found rmeta (metadata) file\n \n-codegen_ssa_unknown_archive_kind =\n-    Don't know how to build archive of type: {$kind}\n+codegen_ssa_select_cpp_build_tool_workload = in the Visual Studio installer, ensure the \"C++ build tools\" workload is selected\n \n-codegen_ssa_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+codegen_ssa_shuffle_indices_evaluation = could not evaluate shuffle_indices at compile time\n \n-codegen_ssa_multiple_main_functions = entry symbol `main` declared multiple times\n-    .help = did you use `#[no_mangle]` on `fn main`? Use `#[start]` instead\n+codegen_ssa_specify_libraries_to_link = use the `-l` flag to specify native libraries to link\n \n-codegen_ssa_metadata_object_file_write = error writing metadata object file: {$error}\n+codegen_ssa_static_library_native_artifacts = Link against the following native artifacts when linking against this static library. The order and any duplication can be significant on some platforms.\n \n-codegen_ssa_invalid_windows_subsystem = invalid windows subsystem `{$subsystem}`, only `windows` and `console` are allowed\n+codegen_ssa_stripping_debug_info_failed = stripping debug info with `{$util}` failed: {$status}\n+    .note = {$output}\n \n-codegen_ssa_erroneous_constant = erroneous constant encountered\n+codegen_ssa_symbol_file_write_failure = failed to write symbols file: {$error}\n \n-codegen_ssa_shuffle_indices_evaluation = could not evaluate shuffle_indices at compile time\n+codegen_ssa_target_feature_safe_trait = `#[target_feature(..)]` cannot be applied to safe trait method\n+    .label = cannot be applied to safe trait method\n+    .label_def = not an `unsafe` function\n \n-codegen_ssa_missing_memory_ordering = Atomic intrinsic missing memory ordering\n+codegen_ssa_thorin_decompress_data = failed to decompress compressed section\n \n-codegen_ssa_unknown_atomic_ordering = unknown ordering in atomic intrinsic\n+codegen_ssa_thorin_duplicate_unit = duplicate split compilation unit ({$unit})\n \n-codegen_ssa_atomic_compare_exchange = Atomic compare-exchange intrinsic missing failure memory ordering\n+codegen_ssa_thorin_empty_unit = unit {$unit} in input DWARF object with no data\n \n-codegen_ssa_unknown_atomic_operation = unknown atomic operation\n+codegen_ssa_thorin_gimli_read = {$error}\n+codegen_ssa_thorin_gimli_write = {$error}\n \n-codegen_ssa_invalid_monomorphization_basic_integer_type = invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n+codegen_ssa_thorin_incompatible_index_version = incompatible `{$section}` index version: found version {$actual}, expected version {$format}\n \n-codegen_ssa_invalid_monomorphization_basic_float_type = invalid monomorphization of `{$name}` intrinsic: expected basic float type, found `{$ty}`\n+codegen_ssa_thorin_invalid_input_kind = input is not an archive or elf object\n \n-codegen_ssa_invalid_monomorphization_float_to_int_unchecked = invalid monomorphization of `float_to_int_unchecked` intrinsic: expected basic float type, found `{$ty}`\n+codegen_ssa_thorin_io = {$error}\n+codegen_ssa_thorin_missing_dwo_name = missing path attribute to DWARF object ({$id})\n \n-codegen_ssa_invalid_monomorphization_floating_point_vector = invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$f_ty}` of floating-point vector `{$in_ty}`\n+codegen_ssa_thorin_missing_referenced_unit = unit {$unit} referenced by executable was not found\n \n-codegen_ssa_invalid_monomorphization_floating_point_type = invalid monomorphization of `{$name}` intrinsic: `{$in_ty}` is not a floating-point type\n+codegen_ssa_thorin_missing_required_section = input object missing required section `{$section}`\n \n-codegen_ssa_invalid_monomorphization_unrecognized_intrinsic = invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n+codegen_ssa_thorin_mixed_input_encodings = input objects haved mixed encodings\n \n-codegen_ssa_invalid_monomorphization_simd_argument = invalid monomorphization of `{$name}` intrinsic: expected SIMD argument type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_multiple_debug_info_section = multiple `.debug_info.dwo` sections\n \n-codegen_ssa_invalid_monomorphization_simd_input = invalid monomorphization of `{$name}` intrinsic: expected SIMD input type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_multiple_debug_types_section = multiple `.debug_types.dwo` sections in a package\n \n-codegen_ssa_invalid_monomorphization_simd_first = invalid monomorphization of `{$name}` intrinsic: expected SIMD first type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_multiple_relocations = multiple relocations for section `{$section}` at offset {$offset}\n \n-codegen_ssa_invalid_monomorphization_simd_second = invalid monomorphization of `{$name}` intrinsic: expected SIMD second type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_no_compilation_units = input object has no compilation units\n \n-codegen_ssa_invalid_monomorphization_simd_third = invalid monomorphization of `{$name}` intrinsic: expected SIMD third type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_no_die = no top-level debugging information entry in compilation/type unit\n \n-codegen_ssa_invalid_monomorphization_simd_return = invalid monomorphization of `{$name}` intrinsic: expected SIMD return type, found non-SIMD `{$ty}`\n+codegen_ssa_thorin_not_output_object_created = no output object was created from inputs\n \n-codegen_ssa_invalid_monomorphization_invalid_bitmask = invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{$mask_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+codegen_ssa_thorin_not_split_unit = regular compilation unit in object (missing dwo identifier)\n \n-codegen_ssa_polymorphic_constant_too_generic = codegen encountered polymorphic constant: TooGeneric\n+codegen_ssa_thorin_object_read = {$error}\n+codegen_ssa_thorin_object_write = {$error}\n+codegen_ssa_thorin_offset_at_index = read offset at index {$index} of `.debug_str_offsets.dwo` section\n \n-codegen_ssa_invalid_monomorphization_return_length_input_type = invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+codegen_ssa_thorin_parse_archive_member = failed to parse archive member\n \n-codegen_ssa_invalid_monomorphization_second_argument_length = invalid monomorphization of `{$name}` intrinsic: expected second argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+codegen_ssa_thorin_parse_index = failed to parse `{$section}` index section\n \n-codegen_ssa_invalid_monomorphization_third_argument_length = invalid monomorphization of `{$name}` intrinsic: expected third argument with length {$in_len} (same as input type `{$in_ty}`), found `{$arg_ty}` with length {$out_len}\n+codegen_ssa_thorin_parse_input_archive_file = failed to parse input archive file\n \n-codegen_ssa_invalid_monomorphization_return_integer_type = invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+codegen_ssa_thorin_parse_input_file_kind = failed to parse input file kind\n \n-codegen_ssa_invalid_monomorphization_simd_shuffle = invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+codegen_ssa_thorin_parse_input_object_file = failed to parse input object file\n \n-codegen_ssa_invalid_monomorphization_return_length = invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+codegen_ssa_thorin_parse_unit = failed to parse unit\n \n-codegen_ssa_invalid_monomorphization_return_element = invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+codegen_ssa_thorin_parse_unit_abbreviations = failed to parse unit abbreviations\n \n-codegen_ssa_invalid_monomorphization_shuffle_index_not_constant = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is not a constant\n+codegen_ssa_thorin_parse_unit_attribute = failed to parse unit attribute\n \n-codegen_ssa_invalid_monomorphization_shuffle_index_out_of_bounds = invalid monomorphization of `{$name}` intrinsic: shuffle index #{$arg_idx} is out of bounds (limit {$total_len})\n+codegen_ssa_thorin_parse_unit_header = failed to parse unit header\n \n-codegen_ssa_invalid_monomorphization_inserted_type = invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+codegen_ssa_thorin_read_input_failure = failed to read input file\n \n-codegen_ssa_invalid_monomorphization_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+codegen_ssa_thorin_relocation_with_invalid_symbol = relocation with invalid symbol for section `{$section}` at offset {$offset}\n \n-codegen_ssa_invalid_monomorphization_expected_return_type = invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_ty}`, found `{$ret_ty}`\n+codegen_ssa_thorin_row_not_in_index = row {$row} found in index's hash table not present in index\n \n-codegen_ssa_invalid_monomorphization_mismatched_lengths = invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+codegen_ssa_thorin_section_not_in_row = section not found in unit's row in index\n \n-codegen_ssa_invalid_monomorphization_mask_type = invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+codegen_ssa_thorin_section_without_name = section without name at offset {$offset}\n \n-codegen_ssa_invalid_monomorphization_vector_argument = invalid monomorphization of `{$name}` intrinsic: vector argument `{$in_ty}`'s element type `{$in_elem}`, expected integer element type\n+codegen_ssa_thorin_str_at_offset = read string at offset {$offset} of `.debug_str.dwo` section\n \n-codegen_ssa_invalid_monomorphization_cannot_return = invalid monomorphization of `{$name}` intrinsic: cannot return `{$ret_ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+codegen_ssa_thorin_top_level_die_not_unit = top-level debugging information entry is not a compilation/type unit\n \n-codegen_ssa_invalid_monomorphization_expected_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of second argument `{$second_arg}` to be a pointer to the element type `{$in_elem}` of the first argument `{$in_ty}`, found `{$expected_element}` != `{$mutability} {$in_elem}`\n+codegen_ssa_thorin_unit_not_in_index = unit {$unit} from input package is not in its index\n \n-codegen_ssa_invalid_monomorphization_third_arg_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of third argument `{$third_arg}` to be a signed integer type\n+codegen_ssa_thorin_unsupported_relocation = unsupported relocation for section {$section} at offset {$offset}\n \n-codegen_ssa_invalid_monomorphization_unsupported_symbol_of_size = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` of size `{$size}` to `{$ret_ty}`\n+codegen_ssa_unable_to_exe_linker = could not exec the linker `{$linker_path}`\n+    .note = {$error}\n+    .command_note = {$command_formatted}\n \n-codegen_ssa_invalid_monomorphization_unsupported_symbol = invalid monomorphization of `{$name}` intrinsic: unsupported {$symbol} from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}`\n+codegen_ssa_unable_to_run = unable to run `{$util}`: {$error}\n \n-codegen_ssa_invalid_monomorphization_cast_fat_pointer = invalid monomorphization of `{$name}` intrinsic: cannot cast fat pointer `{$ty}`\n+codegen_ssa_unable_to_run_dsymutil = unable to run `dsymutil`: {$error}\n \n-codegen_ssa_invalid_monomorphization_expected_pointer = invalid monomorphization of `{$name}` intrinsic: expected pointer, got `{$ty}`\n+codegen_ssa_unable_to_write_debugger_visualizer = Unable to write debugger visualizer file `{$path}`: {$error}\n \n-codegen_ssa_invalid_monomorphization_expected_usize = invalid monomorphization of `{$name}` intrinsic: expected `usize`, got `{$ty}`\n+codegen_ssa_unknown_archive_kind =\n+    Don't know how to build archive of type: {$kind}\n \n-codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+codegen_ssa_unknown_atomic_operation = unknown atomic operation\n \n-codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n+codegen_ssa_unknown_atomic_ordering = unknown ordering in atomic intrinsic\n \n-codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type\n+codegen_ssa_unsupported_arch = unsupported arch `{$arch}` for os `{$os}`\n \n-codegen_ssa_invalid_no_sanitize = invalid argument for `no_sanitize`\n-    .note = expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\n+codegen_ssa_unsupported_link_self_contained = option `-C link-self-contained` is not supported on this target\n \n-codegen_ssa_invalid_link_ordinal_nargs = incorrect number of arguments to `#[link_ordinal]`\n-    .note = the attribute requires exactly one argument\n+codegen_ssa_use_cargo_directive = use the `cargo:rustc-link-lib` directive to specify the native libraries to link with Cargo (see https://doc.rust-lang.org/cargo/reference/build-scripts.html#cargorustc-link-libkindname)\n \n-codegen_ssa_illegal_link_ordinal_format = illegal ordinal format in `link_ordinal`\n-    .note = an unsuffixed integer value, e.g., `1`, is expected\n+codegen_ssa_version_script_write_failure = failed to write version script: {$error}\n \n-codegen_ssa_target_feature_safe_trait = `#[target_feature(..)]` cannot be applied to safe trait method\n-    .label = cannot be applied to safe trait method\n-    .label_def = not an `unsafe` function\n+codegen_ssa_visual_studio_not_installed = you may need to install Visual Studio build tools with the \"C++ build tools\" workload"}, {"sha": "cd56f85cccdea850c77fb093253a1c1c5c794da2", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -144,7 +144,7 @@ pub fn get_linker<'a>(\n             cmd,\n             sess,\n             target_cpu,\n-            hinted_static: false,\n+            hinted_static: None,\n             is_ld: cc == Cc::No,\n             is_gnu: flavor.is_gnu(),\n         }) as Box<dyn Linker>,\n@@ -214,7 +214,7 @@ pub struct GccLinker<'a> {\n     cmd: Command,\n     sess: &'a Session,\n     target_cpu: &'a str,\n-    hinted_static: bool, // Keeps track of the current hinting mode.\n+    hinted_static: Option<bool>, // Keeps track of the current hinting mode.\n     // Link as ld\n     is_ld: bool,\n     is_gnu: bool,\n@@ -275,19 +275,19 @@ impl<'a> GccLinker<'a> {\n         if !self.takes_hints() {\n             return;\n         }\n-        if !self.hinted_static {\n+        if self.hinted_static != Some(true) {\n             self.linker_arg(\"-Bstatic\");\n-            self.hinted_static = true;\n+            self.hinted_static = Some(true);\n         }\n     }\n \n     fn hint_dynamic(&mut self) {\n         if !self.takes_hints() {\n             return;\n         }\n-        if self.hinted_static {\n+        if self.hinted_static != Some(false) {\n             self.linker_arg(\"-Bdynamic\");\n-            self.hinted_static = false;\n+            self.hinted_static = Some(false);\n         }\n     }\n \n@@ -1484,25 +1484,25 @@ impl<'a> L4Bender<'a> {\n pub struct AixLinker<'a> {\n     cmd: Command,\n     sess: &'a Session,\n-    hinted_static: bool,\n+    hinted_static: Option<bool>,\n }\n \n impl<'a> AixLinker<'a> {\n     pub fn new(cmd: Command, sess: &'a Session) -> AixLinker<'a> {\n-        AixLinker { cmd: cmd, sess: sess, hinted_static: false }\n+        AixLinker { cmd: cmd, sess: sess, hinted_static: None }\n     }\n \n     fn hint_static(&mut self) {\n-        if !self.hinted_static {\n+        if self.hinted_static != Some(true) {\n             self.cmd.arg(\"-bstatic\");\n-            self.hinted_static = true;\n+            self.hinted_static = Some(true);\n         }\n     }\n \n     fn hint_dynamic(&mut self) {\n-        if self.hinted_static {\n+        if self.hinted_static != Some(false) {\n             self.cmd.arg(\"-bdynamic\");\n-            self.hinted_static = false;\n+            self.hinted_static = Some(false);\n         }\n     }\n "}, {"sha": "ad27b854d59a2553f240cc1ed00b3a93d5162a99", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -188,6 +188,11 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n     };\n \n     let mut file = write::Object::new(binary_format, architecture, endianness);\n+    if sess.target.is_like_osx {\n+        if let Some(build_version) = macho_object_build_version_for_target(&sess.target) {\n+            file.set_macho_build_version(build_version)\n+        }\n+    }\n     let e_flags = match architecture {\n         Architecture::Mips => {\n             let arch = match sess.target.options.cpu.as_ref() {\n@@ -258,6 +263,33 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n     Some(file)\n }\n \n+/// Apple's LD, when linking for Mac Catalyst, requires object files to\n+/// contain information about what they were built for (LC_BUILD_VERSION):\n+/// the platform (macOS/watchOS etc), minimum OS version, and SDK version.\n+/// This returns a `MachOBuildVersion` if necessary for the target.\n+fn macho_object_build_version_for_target(\n+    target: &Target,\n+) -> Option<object::write::MachOBuildVersion> {\n+    if !target.llvm_target.ends_with(\"-macabi\") {\n+        return None;\n+    }\n+    /// The `object` crate demands \"X.Y.Z encoded in nibbles as xxxx.yy.zz\"\n+    /// e.g. minOS 14.0 = 0x000E0000, or SDK 16.2 = 0x00100200\n+    fn pack_version((major, minor): (u32, u32)) -> u32 {\n+        (major << 16) | (minor << 8)\n+    }\n+\n+    let platform = object::macho::PLATFORM_MACCATALYST;\n+    let min_os = (14, 0);\n+    let sdk = (16, 2);\n+\n+    let mut build_version = object::write::MachOBuildVersion::default();\n+    build_version.platform = platform;\n+    build_version.minos = pack_version(min_os);\n+    build_version.sdk = pack_version(sdk);\n+    Some(build_version)\n+}\n+\n pub enum MetadataPosition {\n     First,\n     Last,"}, {"sha": "a8b6030ac85c3a50f4eb4f13e19e541b98a5b9cb", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -2,7 +2,7 @@ use crate::base::allocator_kind_for_codegen;\n \n use std::collections::hash_map::Entry::*;\n \n-use rustc_ast::expand::allocator::ALLOCATOR_METHODS;\n+use rustc_ast::expand::allocator::{ALLOCATOR_METHODS, NO_ALLOC_SHIM_IS_UNSTABLE};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n@@ -241,6 +241,17 @@ fn exported_symbols_provider_local(\n                 used: false,\n             },\n         ));\n+\n+        let exported_symbol =\n+            ExportedSymbol::NoDefId(SymbolName::new(tcx, NO_ALLOC_SHIM_IS_UNSTABLE));\n+        symbols.push((\n+            exported_symbol,\n+            SymbolExportInfo {\n+                level: SymbolExportLevel::Rust,\n+                kind: SymbolExportKind::Data,\n+                used: false,\n+            },\n+        ))\n     }\n \n     if tcx.sess.instrument_coverage() || tcx.sess.opts.cg.profile_generate.enabled() {"}, {"sha": "835074806e90f159acb9b547cfcc38d21073770d", "filename": "compiler/rustc_codegen_ssa/src/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fanalyze.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -84,7 +84,7 @@ impl DefLocation {\n \n struct LocalAnalyzer<'mir, 'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     fx: &'mir FunctionCx<'a, 'tcx, Bx>,\n-    dominators: Dominators<mir::BasicBlock>,\n+    dominators: &'mir Dominators<mir::BasicBlock>,\n     locals: IndexVec<mir::Local, LocalKind>,\n }\n "}, {"sha": "d516ac4ebb749aea478937d443439f605d1233ac", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1031,7 +1031,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         });\n \n         let needs_location =\n-            instance.map_or(false, |i| i.def.requires_caller_location(self.cx.tcx()));\n+            instance.is_some_and(|i| i.def.requires_caller_location(self.cx.tcx()));\n         if needs_location {\n             let mir_args = if let Some(num_untupled) = num_untupled {\n                 first_args.len() + num_untupled\n@@ -1450,11 +1450,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> OperandRef<'tcx, Bx::Value> {\n         let tcx = bx.tcx();\n \n-        let mut span_to_caller_location = |mut span: Span| {\n-            // Remove `Inlined` marks as they pollute `expansion_cause`.\n-            while span.is_inlined() {\n-                span.remove_mark();\n-            }\n+        let mut span_to_caller_location = |span: Span| {\n             let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n             let caller = tcx.sess.source_map().lookup_char_pos(topmost.lo());\n             let const_loc = tcx.const_caller_location(("}, {"sha": "7d56cf0aa0701a6c4a73772413350cd1b800cb63", "filename": "compiler/rustc_const_eval/messages.ftl", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,40 +1,60 @@\n-const_eval_unstable_in_stable =\n-    const-stable function cannot use `#[feature({$gate})]`\n-    .unstable_sugg = if it is not part of the public API, make this function unstably const\n-    .bypass_sugg = otherwise `#[rustc_allow_const_fn_unstable]` can be used to bypass stability checks\n+const_eval_interior_mutability_borrow =\n+    cannot borrow here, since the borrowed element may contain interior mutability\n \n-const_eval_thread_local_access =\n-    thread-local statics cannot be accessed at compile-time\n+const_eval_interior_mutable_data_refer =\n+    {$kind}s cannot refer to interior mutable data\n+    .label = this borrow of an interior mutable value may end up in the final value\n+    .help = to fix this, the value can be extracted to a separate `static` item and then referenced\n+    .teach_note =\n+        A constant containing interior mutable data behind a reference can allow you to modify that data.\n+        This would make multiple uses of a constant to be able to see different values and allow circumventing\n+        the `Send` and `Sync` requirements for shared mutable data, which is unsound.\n \n-const_eval_static_access =\n-    {$kind}s cannot refer to statics\n-    .help = consider extracting the value of the `static` to a `const`, and referring to that\n-    .teach_note = `static` and `const` variables can refer to other `const` variables. A `const` variable, however, cannot refer to a `static` variable.\n-    .teach_help = To fix this, the value can be extracted to a `const` and then used.\n+const_eval_max_num_nodes_in_const = maximum number of nodes exceeded in constant {$global_const_id}\n \n-const_eval_raw_ptr_to_int =\n-    pointers cannot be cast to integers during const eval\n-    .note = at compile-time, pointers do not have an integer value\n-    .note2 = avoiding this restriction via `transmute`, `union`, or raw pointers leads to compile-time undefined behavior\n+const_eval_mut_deref =\n+    mutation through a reference is not allowed in {$kind}s\n+\n+const_eval_non_const_fmt_macro_call =\n+    cannot call non-const formatting macro in {$kind}s\n+\n+const_eval_non_const_fn_call =\n+    cannot call non-const fn `{$def_path_str}` in {$kind}s\n+\n+const_eval_panic_non_str = argument to `panic!()` in a const context must have type `&str`\n \n const_eval_raw_ptr_comparison =\n     pointers cannot be reliably compared during const eval\n     .note = see issue #53020 <https://github.com/rust-lang/rust/issues/53020> for more information\n \n-const_eval_panic_non_str = argument to `panic!()` in a const context must have type `&str`\n+const_eval_raw_ptr_to_int =\n+    pointers cannot be cast to integers during const eval\n+    .note = at compile-time, pointers do not have an integer value\n+    .note2 = avoiding this restriction via `transmute`, `union`, or raw pointers leads to compile-time undefined behavior\n \n-const_eval_mut_deref =\n-    mutation through a reference is not allowed in {$kind}s\n+const_eval_static_access =\n+    {$kind}s cannot refer to statics\n+    .help = consider extracting the value of the `static` to a `const`, and referring to that\n+    .teach_note = `static` and `const` variables can refer to other `const` variables. A `const` variable, however, cannot refer to a `static` variable.\n+    .teach_help = To fix this, the value can be extracted to a `const` and then used.\n+\n+const_eval_thread_local_access =\n+    thread-local statics cannot be accessed at compile-time\n \n const_eval_transient_mut_borrow = mutable references are not allowed in {$kind}s\n \n const_eval_transient_mut_borrow_raw = raw mutable references are not allowed in {$kind}s\n \n-const_eval_max_num_nodes_in_const = maximum number of nodes exceeded in constant {$global_const_id}\n-\n const_eval_unallowed_fn_pointer_call = function pointer calls are not allowed in {$kind}s\n \n-const_eval_unstable_const_fn = `{$def_path}` is not yet stable as a const fn\n+const_eval_unallowed_heap_allocations =\n+    allocations are not allowed in {$kind}s\n+    .label = allocation not allowed in {$kind}s\n+    .teach_note =\n+        The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.\n+\n+const_eval_unallowed_inline_asm =\n+    inline assembly is not allowed in {$kind}s\n \n const_eval_unallowed_mutable_refs =\n     mutable references are not allowed in the final value of {$kind}s\n@@ -60,32 +80,12 @@ const_eval_unallowed_mutable_refs_raw =\n \n         If you really want global mutable state, try using static mut or a global UnsafeCell.\n \n-const_eval_non_const_fmt_macro_call =\n-    cannot call non-const formatting macro in {$kind}s\n-\n-const_eval_non_const_fn_call =\n-    cannot call non-const fn `{$def_path_str}` in {$kind}s\n-\n const_eval_unallowed_op_in_const_context =\n     {$msg}\n \n-const_eval_unallowed_heap_allocations =\n-    allocations are not allowed in {$kind}s\n-    .label = allocation not allowed in {$kind}s\n-    .teach_note =\n-        The value of statics and constants must be known at compile time, and they live for the entire lifetime of a program. Creating a boxed value allocates memory on the heap at runtime, and therefore cannot be done at compile time.\n-\n-const_eval_unallowed_inline_asm =\n-    inline assembly is not allowed in {$kind}s\n-\n-const_eval_interior_mutable_data_refer =\n-    {$kind}s cannot refer to interior mutable data\n-    .label = this borrow of an interior mutable value may end up in the final value\n-    .help = to fix this, the value can be extracted to a separate `static` item and then referenced\n-    .teach_note =\n-        A constant containing interior mutable data behind a reference can allow you to modify that data.\n-        This would make multiple uses of a constant to be able to see different values and allow circumventing\n-        the `Send` and `Sync` requirements for shared mutable data, which is unsound.\n+const_eval_unstable_const_fn = `{$def_path}` is not yet stable as a const fn\n \n-const_eval_interior_mutability_borrow =\n-    cannot borrow here, since the borrowed element may contain interior mutability\n+const_eval_unstable_in_stable =\n+    const-stable function cannot use `#[feature({$gate})]`\n+    .unstable_sugg = if it is not part of the public API, make this function unstably const\n+    .bypass_sugg = otherwise `#[rustc_allow_const_fn_unstable]` can be used to bypass stability checks"}, {"sha": "7e94578003ebfc13159f14c17f5e949348041a3c", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -949,7 +949,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This deliberately does *not* honor `requires_caller_location` since it is used for much\n         // more than just panics.\n         for frame in stack.iter().rev() {\n-            let span = frame.current_span();\n+            let span = match frame.loc {\n+                Left(loc) => {\n+                    // If the stacktrace passes through MIR-inlined source scopes, add them.\n+                    let mir::SourceInfo { mut span, scope } = *frame.body.source_info(loc);\n+                    let mut scope_data = &frame.body.source_scopes[scope];\n+                    while let Some((instance, call_span)) = scope_data.inlined {\n+                        frames.push(FrameInfo { span, instance });\n+                        span = call_span;\n+                        scope_data = &frame.body.source_scopes[scope_data.parent_scope.unwrap()];\n+                    }\n+                    span\n+                }\n+                Right(span) => span,\n+            };\n             frames.push(FrameInfo { span, instance: frame.instance });\n         }\n         trace!(\"generate stacktrace: {:#?}\", frames);"}, {"sha": "df5b581000b7d155242e9282b535ba56d31730bf", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -111,11 +111,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         location\n     }\n \n-    pub(crate) fn location_triple_for_span(&self, mut span: Span) -> (Symbol, u32, u32) {\n-        // Remove `Inlined` marks as they pollute `expansion_cause`.\n-        while span.is_inlined() {\n-            span.remove_mark();\n-        }\n+    pub(crate) fn location_triple_for_span(&self, span: Span) -> (Symbol, u32, u32) {\n         let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n         let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n         ("}, {"sha": "138bc3eb74a4fb350209435f025c192737c8403e", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -944,7 +944,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                         tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == gate)\n                     };\n                     let feature_gate_declared = gate_declared(gate);\n-                    let implied_gate_declared = implied_by.map(gate_declared).unwrap_or(false);\n+                    let implied_gate_declared = implied_by.is_some_and(gate_declared);\n                     if !feature_gate_declared && !implied_gate_declared {\n                         self.check_op(ops::FnCallUnstable(callee, Some(gate)));\n                         return;\n@@ -971,7 +971,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 // have no `rustc_const_stable` attributes to be const-unstable as well. This\n                 // should be fixed later.\n                 let callee_is_unstable_unmarked = tcx.lookup_const_stability(callee).is_none()\n-                    && tcx.lookup_stability(callee).map_or(false, |s| s.is_unstable());\n+                    && tcx.lookup_stability(callee).is_some_and(|s| s.is_unstable());\n                 if callee_is_unstable_unmarked {\n                     trace!(\"callee_is_unstable_unmarked\");\n                     // We do not use `const` modifiers for intrinsic \"functions\", as intrinsics are"}, {"sha": "8ebfee8878cbbc8ccc506178be688a610c3cf4a6", "filename": "compiler/rustc_const_eval/src/transform/check_consts/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -139,5 +139,5 @@ fn is_parent_const_stable_trait(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n         return false;\n     }\n \n-    tcx.lookup_const_stability(parent.owner).map_or(false, |stab| stab.is_const_stable())\n+    tcx.lookup_const_stability(parent.owner).is_some_and(|stab| stab.is_const_stable())\n }"}, {"sha": "d6a2ffb75111a1b9794d701fe91a66cc9be199b9", "filename": "compiler/rustc_const_eval/src/util/compare_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcompare_types.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -3,8 +3,8 @@\n //! FIXME: Move this to a more general place. The utility of this extends to\n //! other areas of the compiler as well.\n \n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n-use rustc_infer::traits::ObligationCause;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_middle::traits::{DefiningAnchor, ObligationCause};\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_trait_selection::traits::ObligationCtxt;\n "}, {"sha": "11ad5b49df2ef24d766123e3d0bdaa52570f3648", "filename": "compiler/rustc_const_eval/src/util/type_name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Ftype_name.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -58,11 +58,12 @@ impl<'tcx> Printer<'tcx> for AbsolutePathPrinter<'tcx> {\n             // Types with identity (print the module path).\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did: def_id, .. }, _)), substs)\n             | ty::FnDef(def_id, substs)\n-            | ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n+            | ty::Alias(ty::Projection | ty::Opaque, ty::AliasTy { def_id, substs, .. })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => self.print_def_path(def_id, substs),\n             ty::Foreign(def_id) => self.print_def_path(def_id, &[]),\n \n+            ty::Alias(ty::Inherent, _) => bug!(\"type_name: unexpected inherent projection\"),\n             ty::GeneratorWitness(_) => bug!(\"type_name: unexpected `GeneratorWitness`\"),\n             ty::GeneratorWitnessMIR(..) => bug!(\"type_name: unexpected `GeneratorWitnessMIR`\"),\n         }"}, {"sha": "a5db14d9102c44dc199098bd5e5389635e469503", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 85, "deletions": 10, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -26,7 +26,7 @@ rustc_index::newtype_index! {\n     struct PreorderIndex {}\n }\n \n-pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n+pub fn dominators<G: ControlFlowGraph>(graph: &G) -> Dominators<G::Node> {\n     // compute the post order index (rank) for each node\n     let mut post_order_rank = IndexVec::from_elem_n(0, graph.num_nodes());\n \n@@ -244,7 +244,10 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n \n     let start_node = graph.start_node();\n     immediate_dominators[start_node] = None;\n-    Dominators { start_node, post_order_rank, immediate_dominators }\n+\n+    let time = compute_access_time(start_node, &immediate_dominators);\n+\n+    Dominators { start_node, post_order_rank, immediate_dominators, time }\n }\n \n /// Evaluate the link-eval virtual forest, providing the currently minimum semi\n@@ -316,6 +319,7 @@ pub struct Dominators<N: Idx> {\n     // possible to get its full list of dominators by looking up the dominator\n     // of each dominator. (See the `impl Iterator for Iter` definition).\n     immediate_dominators: IndexVec<N, Option<N>>,\n+    time: IndexVec<N, Time>,\n }\n \n impl<Node: Idx> Dominators<Node> {\n@@ -333,12 +337,7 @@ impl<Node: Idx> Dominators<Node> {\n     /// See the `impl Iterator for Iter` definition to understand how this works.\n     pub fn dominators(&self, node: Node) -> Iter<'_, Node> {\n         assert!(self.is_reachable(node), \"node {node:?} is not reachable\");\n-        Iter { dominators: self, node: Some(node) }\n-    }\n-\n-    pub fn dominates(&self, dom: Node, node: Node) -> bool {\n-        // FIXME -- could be optimized by using post-order-rank\n-        self.dominators(node).any(|n| n == dom)\n+        Iter { dom_tree: self, node: Some(node) }\n     }\n \n     /// Provide deterministic ordering of nodes such that, if any two nodes have a dominator\n@@ -348,10 +347,22 @@ impl<Node: Idx> Dominators<Node> {\n     pub fn rank_partial_cmp(&self, lhs: Node, rhs: Node) -> Option<Ordering> {\n         self.post_order_rank[rhs].partial_cmp(&self.post_order_rank[lhs])\n     }\n+\n+    /// Returns true if `a` dominates `b`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `b` is unreachable.\n+    pub fn dominates(&self, a: Node, b: Node) -> bool {\n+        let a = self.time[a];\n+        let b = self.time[b];\n+        assert!(b.start != 0, \"node {b:?} is not reachable\");\n+        a.start <= b.start && b.finish <= a.finish\n+    }\n }\n \n pub struct Iter<'dom, Node: Idx> {\n-    dominators: &'dom Dominators<Node>,\n+    dom_tree: &'dom Dominators<Node>,\n     node: Option<Node>,\n }\n \n@@ -360,10 +371,74 @@ impl<'dom, Node: Idx> Iterator for Iter<'dom, Node> {\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if let Some(node) = self.node {\n-            self.node = self.dominators.immediate_dominator(node);\n+            self.node = self.dom_tree.immediate_dominator(node);\n             Some(node)\n         } else {\n             None\n         }\n     }\n }\n+\n+/// Describes the number of vertices discovered at the time when processing of a particular vertex\n+/// started and when it finished. Both values are zero for unreachable vertices.\n+#[derive(Copy, Clone, Default, Debug)]\n+struct Time {\n+    start: u32,\n+    finish: u32,\n+}\n+\n+fn compute_access_time<N: Idx>(\n+    start_node: N,\n+    immediate_dominators: &IndexSlice<N, Option<N>>,\n+) -> IndexVec<N, Time> {\n+    // Transpose the dominator tree edges, so that child nodes of vertex v are stored in\n+    // node[edges[v].start..edges[v].end].\n+    let mut edges: IndexVec<N, std::ops::Range<u32>> =\n+        IndexVec::from_elem(0..0, immediate_dominators);\n+    for &idom in immediate_dominators.iter() {\n+        if let Some(idom) = idom {\n+            edges[idom].end += 1;\n+        }\n+    }\n+    let mut m = 0;\n+    for e in edges.iter_mut() {\n+        m += e.end;\n+        e.start = m;\n+        e.end = m;\n+    }\n+    let mut node = IndexVec::from_elem_n(Idx::new(0), m.try_into().unwrap());\n+    for (i, &idom) in immediate_dominators.iter_enumerated() {\n+        if let Some(idom) = idom {\n+            edges[idom].start -= 1;\n+            node[edges[idom].start] = i;\n+        }\n+    }\n+\n+    // Perform a depth-first search of the dominator tree. Record the number of vertices discovered\n+    // when vertex v is discovered first as time[v].start, and when its processing is finished as\n+    // time[v].finish.\n+    let mut time: IndexVec<N, Time> = IndexVec::from_elem(Time::default(), immediate_dominators);\n+    let mut stack = Vec::new();\n+\n+    let mut discovered = 1;\n+    stack.push(start_node);\n+    time[start_node].start = discovered;\n+\n+    while let Some(&i) = stack.last() {\n+        let e = &mut edges[i];\n+        if e.start == e.end {\n+            // Finish processing vertex i.\n+            time[i].finish = discovered;\n+            stack.pop();\n+        } else {\n+            let j = node[e.start];\n+            e.start += 1;\n+            // Start processing vertex j.\n+            discovered += 1;\n+            time[j].start = discovered;\n+            stack.push(j);\n+        }\n+    }\n+\n+    time\n+}"}, {"sha": "859e384d8b529c5985c54a419e4b09558d180363", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -102,21 +102,27 @@ pub mod unord;\n pub use ena::undo_log;\n pub use ena::unify;\n \n-pub struct OnDrop<F: Fn()>(pub F);\n+/// Returns a structure that calls `f` when dropped.\n+pub fn defer<F: FnOnce()>(f: F) -> OnDrop<F> {\n+    OnDrop(Some(f))\n+}\n+\n+pub struct OnDrop<F: FnOnce()>(Option<F>);\n \n-impl<F: Fn()> OnDrop<F> {\n-    /// Forgets the function which prevents it from running.\n-    /// Ensure that the function owns no memory, otherwise it will be leaked.\n+impl<F: FnOnce()> OnDrop<F> {\n+    /// Disables on-drop call.\n     #[inline]\n-    pub fn disable(self) {\n-        std::mem::forget(self);\n+    pub fn disable(mut self) {\n+        self.0.take();\n     }\n }\n \n-impl<F: Fn()> Drop for OnDrop<F> {\n+impl<F: FnOnce()> Drop for OnDrop<F> {\n     #[inline]\n     fn drop(&mut self) {\n-        (self.0)();\n+        if let Some(f) = self.0.take() {\n+            f();\n+        }\n     }\n }\n "}, {"sha": "a47908648ba16531299cee070f182bc4a141dae9", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -366,7 +366,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     && self\n                         .error_cache\n                         .get(&obligation_tree_id)\n-                        .map_or(false, |errors| errors.contains(v.key()));\n+                        .is_some_and(|errors| errors.contains(v.key()));\n \n                 if already_failed {\n                     Err(())"}, {"sha": "520871a12be99d210ccaa28f3eb323e224e0ecfb", "filename": "compiler/rustc_data_structures/src/owned_slice/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fowned_slice%2Ftests.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -7,8 +7,8 @@ use std::{\n };\n \n use crate::{\n+    defer,\n     owned_slice::{slice_owned, try_slice_owned, OwnedSlice},\n-    OnDrop,\n };\n \n #[test]\n@@ -66,7 +66,7 @@ fn boxed() {\n fn drop_drops() {\n     let flag = Arc::new(AtomicBool::new(false));\n     let flag_prime = Arc::clone(&flag);\n-    let d = OnDrop(move || flag_prime.store(true, atomic::Ordering::Relaxed));\n+    let d = defer(move || flag_prime.store(true, atomic::Ordering::Relaxed));\n \n     let slice = slice_owned(d, |_| &[]);\n "}, {"sha": "22b4ec6b0d1b1ba1b053bdecbc76df36982c8aa9", "filename": "compiler/rustc_driver_impl/messages.ftl", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_driver_impl%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_driver_impl%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,19 +1,19 @@\n-driver_impl_rlink_unable_to_read = failed to read rlink file: `{$err}`\n-\n-driver_impl_rlink_wrong_file_type = The input does not look like a .rlink file\n+driver_impl_ice = the compiler unexpectedly panicked. this is a bug.\n+driver_impl_ice_bug_report = we would appreciate a bug report: {$bug_report_url}\n+driver_impl_ice_exclude_cargo_defaults = some of the compiler flags provided by cargo are hidden\n \n+driver_impl_ice_flags = compiler flags: {$flags}\n+driver_impl_ice_version = rustc {$version} running on {$triple}\n driver_impl_rlink_empty_version_number = The input does not contain version number\n \n driver_impl_rlink_encoding_version_mismatch = .rlink file was produced with encoding version `{$version_array}`, but the current version is `{$rlink_version}`\n \n+driver_impl_rlink_no_a_file = rlink must be a file\n+\n driver_impl_rlink_rustc_version_mismatch = .rlink file was produced by rustc version `{$rustc_version}`, but the current version is `{$current_version}`\n \n-driver_impl_rlink_no_a_file = rlink must be a file\n+driver_impl_rlink_unable_to_read = failed to read rlink file: `{$err}`\n \n-driver_impl_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`\n+driver_impl_rlink_wrong_file_type = The input does not look like a .rlink file\n \n-driver_impl_ice = the compiler unexpectedly panicked. this is a bug.\n-driver_impl_ice_bug_report = we would appreciate a bug report: {$bug_report_url}\n-driver_impl_ice_version = rustc {$version} running on {$triple}\n-driver_impl_ice_flags = compiler flags: {$flags}\n-driver_impl_ice_exclude_cargo_defaults = some of the compiler flags provided by cargo are hidden\n+driver_impl_unpretty_dump_fail = pretty-print failed to write `{$path}` due to error `{$err}`"}, {"sha": "40aa69e5a41058826a92195611eda17712009509", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1315,7 +1315,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str, extra_info:\n     }\n \n     // If backtraces are enabled, also print the query stack\n-    let backtrace = env::var_os(\"RUST_BACKTRACE\").map_or(false, |x| &x != \"0\");\n+    let backtrace = env::var_os(\"RUST_BACKTRACE\").is_some_and(|x| &x != \"0\");\n \n     let num_frames = if backtrace { None } else { Some(2) };\n "}, {"sha": "33709734322b6b9a309be5dab7bd44dfbcf1c758", "filename": "compiler/rustc_errors/messages.ftl", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_errors%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_errors%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,19 +1,19 @@\n-errors_target_invalid_address_space =\n-    invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n+errors_target_inconsistent_architecture =\n+    inconsistent target specification: \"data-layout\" claims architecture is {$dl}-endian, while \"target-endian\" is `{$target}`\n \n-errors_target_invalid_bits =\n-    invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}\n+errors_target_inconsistent_pointer_width =\n+    inconsistent target specification: \"data-layout\" claims pointers are {$pointer_size}-bit, while \"target-pointer-width\" is `{$target}`\n \n-errors_target_missing_alignment =\n-    missing alignment for `{$cause}` in \"data-layout\"\n+errors_target_invalid_address_space =\n+    invalid address space `{$addr_space}` for `{$cause}` in \"data-layout\": {$err}\n \n errors_target_invalid_alignment =\n     invalid alignment for `{$cause}` in \"data-layout\": {$err}\n \n-errors_target_inconsistent_architecture =\n-    inconsistent target specification: \"data-layout\" claims architecture is {$dl}-endian, while \"target-endian\" is `{$target}`\n-\n-errors_target_inconsistent_pointer_width =\n-    inconsistent target specification: \"data-layout\" claims pointers are {$pointer_size}-bit, while \"target-pointer-width\" is `{$target}`\n+errors_target_invalid_bits =\n+    invalid {$kind} `{$bit}` for `{$cause}` in \"data-layout\": {$err}\n \n errors_target_invalid_bits_size = {$err}\n+\n+errors_target_missing_alignment =\n+    missing alignment for `{$cause}` in \"data-layout\""}, {"sha": "e8cd7eaa60f1acb02a3dcacb2b9290ce77dc0236", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -285,15 +285,11 @@ pub trait Emitter: Translate {\n                     format!(\n                         \"help: {}{}: `{}`\",\n                         &msg,\n-                        if self\n-                            .source_map()\n-                            .map(|sm| is_case_difference(\n-                                sm,\n-                                substitution,\n-                                sugg.substitutions[0].parts[0].span,\n-                            ))\n-                            .unwrap_or(false)\n-                        {\n+                        if self.source_map().is_some_and(|sm| is_case_difference(\n+                            sm,\n+                            substitution,\n+                            sugg.substitutions[0].parts[0].span,\n+                        )) {\n                             \" (notice the capitalization)\"\n                         } else {\n                             \"\"\n@@ -336,7 +332,7 @@ pub trait Emitter: Translate {\n \n                     // Skip past non-macro entries, just in case there\n                     // are some which do actually involve macros.\n-                    ExpnKind::Inlined | ExpnKind::Desugaring(..) | ExpnKind::AstPass(..) => None,\n+                    ExpnKind::Desugaring(..) | ExpnKind::AstPass(..) => None,\n \n                     ExpnKind::Macro(macro_kind, name) => Some((macro_kind, name)),\n                 }\n@@ -407,7 +403,7 @@ pub trait Emitter: Translate {\n                     continue;\n                 }\n \n-                if always_backtrace && !matches!(trace.kind, ExpnKind::Inlined) {\n+                if always_backtrace {\n                     new_labels.push((\n                         trace.def_site,\n                         format!(\n@@ -446,7 +442,6 @@ pub trait Emitter: Translate {\n                             \"this derive macro expansion\".into()\n                         }\n                         ExpnKind::Macro(MacroKind::Bang, _) => \"this macro invocation\".into(),\n-                        ExpnKind::Inlined => \"this inlined function call\".into(),\n                         ExpnKind::Root => \"the crate root\".into(),\n                         ExpnKind::AstPass(kind) => kind.descr().into(),\n                         ExpnKind::Desugaring(kind) => {"}, {"sha": "3dec0d9299c4ebcfa377dda41829e6d632382295", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -478,6 +478,7 @@ pub enum StashKey {\n     MaybeFruTypo,\n     CallAssocMethod,\n     TraitMissingMethod,\n+    OpaqueHiddenTypeMismatch,\n }\n \n fn default_track_diagnostic(d: &mut Diagnostic, f: &mut dyn FnMut(&mut Diagnostic)) {\n@@ -1436,7 +1437,7 @@ impl HandlerInner {\n     }\n \n     fn treat_err_as_bug(&self) -> bool {\n-        self.flags.treat_err_as_bug.map_or(false, |c| {\n+        self.flags.treat_err_as_bug.is_some_and(|c| {\n             self.err_count() + self.lint_err_count + self.delayed_bug_count() >= c.get()\n         })\n     }\n@@ -1602,7 +1603,7 @@ impl HandlerInner {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n-        if self.flags.treat_err_as_bug.map_or(false, |c| {\n+        if self.flags.treat_err_as_bug.is_some_and(|c| {\n             self.err_count() + self.lint_err_count + self.delayed_bug_count() + 1 >= c.get()\n         }) {\n             // FIXME: don't abort here if report_delayed_bugs is off"}, {"sha": "6c7e68246ea5f431026c1a20355bc51b317828f3", "filename": "compiler/rustc_expand/messages.ftl", "status": "modified", "additions": 89, "deletions": 89, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_expand%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_expand%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,142 +1,142 @@\n-expand_explain_doc_comment_outer =\n-    outer doc comments expand to `#[doc = \"...\"]`, which is what this macro attempted to match\n-\n-expand_explain_doc_comment_inner =\n-    inner doc comments expand to `#![doc = \"...\"]`, which is what this macro attempted to match\n-\n-expand_expr_repeat_no_syntax_vars =\n-    attempted to repeat an expression containing no syntax variables matched as repeating at this depth\n-\n-expand_must_repeat_once =\n-    this must repeat at least once\n-\n-expand_count_repetition_misplaced =\n-    `count` can not be placed inside the inner-most repetition\n-\n-expand_meta_var_expr_unrecognized_var =\n-    variable `{$key}` is not recognized in meta-variable expression\n-\n-expand_var_still_repeating =\n-    variable '{$ident}' is still repeating at this depth\n-\n-expand_meta_var_dif_seq_matchers = {$msg}\n-\n-expand_macro_const_stability =\n-    macros cannot have const stability attributes\n-    .label = invalid const stability attribute\n-    .label2 = const stability attribute affects this macro\n-\n-expand_macro_body_stability =\n-    macros cannot have body stability attributes\n-    .label = invalid body stability attribute\n-    .label2 = body stability attribute affects this macro\n-\n-expand_resolve_relative_path =\n-    cannot resolve relative path in non-file source `{$path}`\n+expand_arg_not_attributes =\n+    second argument must be `attributes`\n \n expand_attr_no_arguments =\n     attribute must have either one or two arguments\n \n-expand_not_a_meta_item =\n-    not a meta item\n-\n-expand_only_one_word =\n-    must only be one word\n-\n-expand_cannot_be_name_of_macro =\n-    `{$trait_ident}` cannot be a name of {$macro_type} macro\n+expand_attribute_meta_item =\n+    attribute must be a meta item, not a literal\n \n-expand_arg_not_attributes =\n-    second argument must be `attributes`\n+expand_attribute_single_word =\n+    attribute must only be a single word\n \n expand_attributes_wrong_form =\n     attribute must be of form: `attributes(foo, bar)`\n \n-expand_attribute_meta_item =\n-    attribute must be a meta item, not a literal\n+expand_cannot_be_name_of_macro =\n+    `{$trait_ident}` cannot be a name of {$macro_type} macro\n \n-expand_attribute_single_word =\n-    attribute must only be a single word\n+expand_count_repetition_misplaced =\n+    `count` can not be placed inside the inner-most repetition\n \n-expand_helper_attribute_name_invalid =\n-    `{$name}` cannot be a name of derive helper attribute\n+expand_duplicate_matcher_binding = duplicate matcher binding\n+    .label = duplicate binding\n+    .label2 = previous binding\n \n expand_expected_comma_in_list =\n     expected token: `,`\n \n-expand_only_one_argument =\n-    {$name} takes 1 argument\n+expand_explain_doc_comment_inner =\n+    inner doc comments expand to `#![doc = \"...\"]`, which is what this macro attempted to match\n \n-expand_takes_no_arguments =\n-    {$name} takes no arguments\n+expand_explain_doc_comment_outer =\n+    outer doc comments expand to `#[doc = \"...\"]`, which is what this macro attempted to match\n+\n+expand_expr_repeat_no_syntax_vars =\n+    attempted to repeat an expression containing no syntax variables matched as repeating at this depth\n \n expand_feature_included_in_edition =\n     the feature `{$feature}` is included in the Rust {$edition} edition\n \n+expand_feature_not_allowed =\n+    the feature `{$name}` is not in the list of allowed features\n+\n expand_feature_removed =\n     feature has been removed\n     .label = feature has been removed\n     .reason = {$reason}\n \n-expand_feature_not_allowed =\n-    the feature `{$name}` is not in the list of allowed features\n-\n-expand_recursion_limit_reached =\n-    recursion limit reached while expanding `{$descr}`\n-    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n+expand_helper_attribute_name_invalid =\n+    `{$name}` cannot be a name of derive helper attribute\n \n-expand_malformed_feature_attribute =\n-    malformed `feature` attribute input\n-    .expected = expected just one word\n+expand_incomplete_parse =\n+    macro expansion ignores token `{$token}` and any following\n+    .label = caused by the macro expansion here\n+    .note = the usage of `{$macro_path}!` is likely invalid in {$kind_name} context\n+    .suggestion_add_semi = you might be missing a semicolon here\n \n-expand_remove_expr_not_supported =\n-    removing an expression is not supported in this position\n+expand_invalid_cfg_expected_syntax = expected syntax is\n \n+expand_invalid_cfg_multiple_predicates = multiple `cfg` predicates are specified\n expand_invalid_cfg_no_parens = `cfg` is not followed by parentheses\n expand_invalid_cfg_no_predicate = `cfg` predicate is not specified\n-expand_invalid_cfg_multiple_predicates = multiple `cfg` predicates are specified\n expand_invalid_cfg_predicate_literal = `cfg` predicate key cannot be a literal\n-expand_invalid_cfg_expected_syntax = expected syntax is\n+expand_macro_body_stability =\n+    macros cannot have body stability attributes\n+    .label = invalid body stability attribute\n+    .label2 = body stability attribute affects this macro\n \n-expand_wrong_fragment_kind =\n-    non-{$kind} macro in {$kind} position: {$name}\n+expand_macro_const_stability =\n+    macros cannot have const stability attributes\n+    .label = invalid const stability attribute\n+    .label2 = const stability attribute affects this macro\n \n-expand_unsupported_key_value =\n-    key-value macro attributes are not supported\n+expand_malformed_feature_attribute =\n+    malformed `feature` attribute input\n+    .expected = expected just one word\n \n-expand_incomplete_parse =\n-    macro expansion ignores token `{$token}` and any following\n-    .label = caused by the macro expansion here\n-    .note = the usage of `{$macro_path}!` is likely invalid in {$kind_name} context\n-    .suggestion_add_semi = you might be missing a semicolon here\n+expand_meta_var_dif_seq_matchers = {$msg}\n \n-expand_remove_node_not_supported =\n-    removing {$descr} is not supported in this position\n+expand_meta_var_expr_unrecognized_var =\n+    variable `{$key}` is not recognized in meta-variable expression\n \n expand_module_circular =\n     circular modules: {$modules}\n \n-expand_module_in_block =\n-    cannot declare a non-inline module inside a block unless it has a path attribute\n-    .note = maybe `use` the module `{$name}` instead of redeclaring it\n-\n expand_module_file_not_found =\n     file not found for module `{$name}`\n     .help = to create the module `{$name}`, create file \"{$default_path}\" or \"{$secondary_path}\"\n \n+expand_module_in_block =\n+    cannot declare a non-inline module inside a block unless it has a path attribute\n+    .note = maybe `use` the module `{$name}` instead of redeclaring it\n+\n expand_module_multiple_candidates =\n     file for module `{$name}` found at both \"{$default_path}\" and \"{$secondary_path}\"\n     .help = delete or rename one of them to remove the ambiguity\n \n-expand_trace_macro = trace_macro\n+expand_must_repeat_once =\n+    this must repeat at least once\n+\n+expand_not_a_meta_item =\n+    not a meta item\n+\n+expand_only_one_argument =\n+    {$name} takes 1 argument\n+\n+expand_only_one_word =\n+    must only be one word\n+\n+expand_proc_macro_derive_tokens =\n+    proc-macro derive produced unparsable tokens\n \n expand_proc_macro_panicked =\n     proc macro panicked\n     .help = message: {$message}\n \n-expand_proc_macro_derive_tokens =\n-    proc-macro derive produced unparsable tokens\n+expand_recursion_limit_reached =\n+    recursion limit reached while expanding `{$descr}`\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n \n-expand_duplicate_matcher_binding = duplicate matcher binding\n-    .label = duplicate binding\n-    .label2 = previous binding\n+expand_remove_expr_not_supported =\n+    removing an expression is not supported in this position\n+\n+expand_remove_node_not_supported =\n+    removing {$descr} is not supported in this position\n+\n+expand_resolve_relative_path =\n+    cannot resolve relative path in non-file source `{$path}`\n+\n+expand_takes_no_arguments =\n+    {$name} takes no arguments\n+\n+expand_trace_macro = trace_macro\n+\n+expand_unsupported_key_value =\n+    key-value macro attributes are not supported\n+\n+expand_var_still_repeating =\n+    variable '{$ident}' is still repeating at this depth\n+\n+expand_wrong_fragment_kind =\n+    non-{$kind} macro in {$kind} position: {$name}"}, {"sha": "4671adccc54160437305107ee36669c41f7b158d", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -780,7 +780,7 @@ impl SyntaxExtension {\n         let allow_internal_unsafe = attr::contains_name(attrs, sym::allow_internal_unsafe);\n         let local_inner_macros = attr::find_by_name(attrs, sym::macro_export)\n             .and_then(|macro_export| macro_export.meta_item_list())\n-            .map_or(false, |l| attr::list_contains_name(&l, sym::local_inner_macros));\n+            .is_some_and(|l| attr::list_contains_name(&l, sym::local_inner_macros));\n         let collapse_debuginfo = attr::contains_name(attrs, sym::collapse_debuginfo);\n         tracing::debug!(?local_inner_macros, ?collapse_debuginfo, ?allow_internal_unsafe);\n \n@@ -1449,7 +1449,7 @@ fn pretty_printing_compatibility_hack(item: &Item, sess: &ParseSess) -> bool {\n                                     && version\n                                         .next()\n                                         .and_then(|c| c.parse::<u32>().ok())\n-                                        .map_or(false, |v| v < 6)\n+                                        .is_some_and(|v| v < 6)\n                             };\n \n                             if crate_matches {"}, {"sha": "ce0093c7d4c0ee723a75d080b4ad30552ad41bb3", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1599,7 +1599,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                     cfg_pos = Some(pos); // a cfg attr found, no need to search anymore\n                     break;\n                 } else if attr_pos.is_none()\n-                    && !name.map_or(false, rustc_feature::is_builtin_attr_name)\n+                    && !name.is_some_and(rustc_feature::is_builtin_attr_name)\n                 {\n                     attr_pos = Some(pos); // a non-cfg attr found, still may find a cfg attr\n                 }\n@@ -1647,7 +1647,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n             let current_span = if let Some(sp) = span { sp.to(attr.span) } else { attr.span };\n             span = Some(current_span);\n \n-            if attrs.peek().map_or(false, |next_attr| next_attr.doc_str().is_some()) {\n+            if attrs.peek().is_some_and(|next_attr| next_attr.doc_str().is_some()) {\n                 continue;\n             }\n \n@@ -1950,6 +1950,6 @@ impl<'feat> ExpansionConfig<'feat> {\n     }\n \n     fn proc_macro_hygiene(&self) -> bool {\n-        self.features.map_or(false, |features| features.proc_macro_hygiene)\n+        self.features.is_some_and(|features| features.proc_macro_hygiene)\n     }\n }"}, {"sha": "06f4a0b5eef847846099010442dfdb27efa00673", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -861,11 +861,11 @@ pub fn is_builtin_attr_name(name: Symbol) -> bool {\n /// Whether this builtin attribute is only used in the local crate.\n /// If so, it is not encoded in the crate metadata.\n pub fn is_builtin_only_local(name: Symbol) -> bool {\n-    BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| attr.only_local)\n+    BUILTIN_ATTRIBUTE_MAP.get(&name).is_some_and(|attr| attr.only_local)\n }\n \n pub fn is_valid_for_get_attr(name: Symbol) -> bool {\n-    BUILTIN_ATTRIBUTE_MAP.get(&name).map_or(false, |attr| match attr.duplicates {\n+    BUILTIN_ATTRIBUTE_MAP.get(&name).is_some_and(|attr| match attr.duplicates {\n         WarnFollowing | ErrorFollowing | ErrorPreceding | FutureWarnFollowing\n         | FutureWarnPreceding => true,\n         DuplicatesOk | WarnFollowingWordOnly => false,"}, {"sha": "beb6307846d3e8d0e1ee683f60157b11e2ffa77a", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -84,14 +84,13 @@ impl UnstableFeatures {\n     pub fn from_environment(krate: Option<&str>) -> Self {\n         // `true` if this is a feature-staged build, i.e., on the beta or stable channel.\n         let disable_unstable_features =\n-            option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").map(|s| s != \"0\").unwrap_or(false);\n+            option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some_and(|s| s != \"0\");\n         // Returns whether `krate` should be counted as unstable\n-        let is_unstable_crate = |var: &str| {\n-            krate.map_or(false, |name| var.split(',').any(|new_krate| new_krate == name))\n-        };\n+        let is_unstable_crate =\n+            |var: &str| krate.is_some_and(|name| var.split(',').any(|new_krate| new_krate == name));\n         // `true` if we should enable unstable features for bootstrapping.\n-        let bootstrap = std::env::var(\"RUSTC_BOOTSTRAP\")\n-            .map_or(false, |var| var == \"1\" || is_unstable_crate(&var));\n+        let bootstrap =\n+            std::env::var(\"RUSTC_BOOTSTRAP\").is_ok_and(|var| var == \"1\" || is_unstable_crate(&var));\n         match (disable_unstable_features, bootstrap) {\n             (_, true) => UnstableFeatures::Cheat,\n             (true, _) => UnstableFeatures::Disallow,"}, {"sha": "e84473109176150b147e501235885bb0d9b81e45", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -787,7 +787,7 @@ pub struct WhereBoundPredicate<'hir> {\n impl<'hir> WhereBoundPredicate<'hir> {\n     /// Returns `true` if `param_def_id` matches the `bounded_ty` of this predicate.\n     pub fn is_param_bound(&self, param_def_id: DefId) -> bool {\n-        self.bounded_ty.as_generic_param().map_or(false, |(def_id, _)| def_id == param_def_id)\n+        self.bounded_ty.as_generic_param().is_some_and(|(def_id, _)| def_id == param_def_id)\n     }\n }\n "}, {"sha": "02d1dfcd1134c4885fa27bb42486e8588b094c1d", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 183, "deletions": 183, "changes": 366, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,77 +1,144 @@\n-hir_analysis_unrecognized_atomic_operation =\n-    unrecognized atomic operation function: `{$op}`\n-    .label = unrecognized atomic operation\n+hir_analysis_ambiguous_lifetime_bound =\n+    ambiguous lifetime bound, explicit lifetime bound required\n \n-hir_analysis_wrong_number_of_generic_arguments_to_intrinsic =\n-    intrinsic has wrong number of {$descr} parameters: found {$found}, expected {$expected}\n-    .label = expected {$expected} {$descr} {$expected ->\n-        [one] parameter\n-        *[other] parameters\n-    }\n+hir_analysis_assoc_type_binding_not_allowed =\n+    associated type bindings are not allowed here\n+    .label = associated type not allowed here\n \n-hir_analysis_unrecognized_intrinsic_function =\n-    unrecognized intrinsic function: `{$name}`\n-    .label = unrecognized intrinsic\n+hir_analysis_associated_type_trait_uninferred_generic_params = cannot use the associated type of a trait with uninferred generic parameters\n+    .suggestion = use a fully qualified path with inferred lifetimes\n \n-hir_analysis_lifetimes_or_bounds_mismatch_on_trait =\n-    lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n-    .label = lifetimes do not match {$item_kind} in trait\n-    .generics_label = lifetimes in impl do not match this {$item_kind} in trait\n-    .where_label = this `where` clause might not match the one in the trait\n-    .bounds_label = this bound might be missing in the impl\n+hir_analysis_associated_type_trait_uninferred_generic_params_multipart_suggestion = use a fully qualified path with explicit lifetimes\n \n hir_analysis_async_trait_impl_should_be_async =\n     method `{$method_name}` should be async because the method from the trait is async\n     .trait_item_label = required because the trait method is async\n \n+hir_analysis_auto_deref_reached_recursion_limit = reached the recursion limit while auto-dereferencing `{$ty}`\n+    .label = deref recursion limit reached\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n+\n+hir_analysis_cannot_capture_late_bound_const_in_anon_const =\n+    cannot capture late-bound const parameter in a constant\n+    .label = parameter defined here\n+\n+hir_analysis_cannot_capture_late_bound_ty_in_anon_const =\n+    cannot capture late-bound type parameter in a constant\n+    .label = parameter defined here\n+\n+hir_analysis_cast_thin_pointer_to_fat_pointer = cannot cast thin pointer `{$expr_ty}` to fat pointer `{$cast_ty}`\n+\n+hir_analysis_closure_implicit_hrtb = implicit types in closure signatures are forbidden when `for<...>` is present\n+    .label = `for<...>` is here\n+\n+hir_analysis_const_bound_for_non_const_trait =\n+    ~const can only be applied to `#[const_trait]` traits\n+\n+hir_analysis_const_impl_for_non_const_trait =\n+    const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n+    .suggestion = mark `{$trait_name}` as const\n+    .note = marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n+    .adding = adding a non-const method body in the future would be a breaking change\n+\n+hir_analysis_const_param_ty_impl_on_non_adt =\n+    the trait `ConstParamTy` may not be implemented for this type\n+    .label = type is not a structure or enumeration\n+\n+hir_analysis_const_specialize = cannot specialize on const impl with non-const impl\n+\n+hir_analysis_copy_impl_on_non_adt =\n+    the trait `Copy` cannot be implemented for this type\n+    .label = type is not a structure or enumeration\n+\n+hir_analysis_copy_impl_on_type_with_dtor =\n+    the trait `Copy` cannot be implemented for this type; the type has a destructor\n+    .label = `Copy` not allowed on types with destructors\n+\n+hir_analysis_drop_impl_negative = negative `Drop` impls are not supported\n+\n hir_analysis_drop_impl_on_wrong_item =\n     the `Drop` trait may only be implemented for local structs, enums, and unions\n     .label = must be a struct, enum, or union in the current crate\n \n+hir_analysis_drop_impl_reservation = reservation `Drop` impls are not supported\n+\n+hir_analysis_empty_specialization = specialization impl does not specialize any associated items\n+    .note = impl is a specialization of this impl\n+\n+hir_analysis_enum_discriminant_overflowed = enum discriminant overflowed\n+    .label = overflowed on value after {$discr}\n+    .note = explicitly set `{$item_name} = {$wrapped_discr}` if that is desired outcome\n+\n+hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+\n hir_analysis_field_already_declared =\n     field `{$field_name}` is already declared\n     .label = field already declared\n     .previous_decl_label = `{$field_name}` first declared here\n \n-hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+hir_analysis_function_not_found_in_trait = function not found in this trait\n \n-hir_analysis_const_param_ty_impl_on_non_adt =\n-    the trait `ConstParamTy` may not be implemented for this type\n-    .label = type is not a structure or enumeration\n+hir_analysis_function_not_have_default_implementation = function doesn't have a default implementation\n+    .note = required by this annotation\n \n-hir_analysis_ambiguous_lifetime_bound =\n-    ambiguous lifetime bound, explicit lifetime bound required\n+hir_analysis_functions_names_duplicated = functions names are duplicated\n+    .note = all `#[rustc_must_implement_one_of]` arguments must be unique\n \n-hir_analysis_assoc_type_binding_not_allowed =\n-    associated type bindings are not allowed here\n-    .label = associated type not allowed here\n+hir_analysis_impl_not_marked_default = `{$ident}` specializes an item from a parent `impl`, but that item is not marked `default`\n+    .label = cannot specialize default item `{$ident}`\n+    .ok_label = parent `impl` is here\n+    .note = to specialize, `{$ident}` in the parent `impl` must be marked `default`\n \n-hir_analysis_parenthesized_fn_trait_expansion =\n-    parenthesized trait syntax expands to `{$expanded_type}`\n+hir_analysis_impl_not_marked_default_err = `{$ident}` specializes an item from a parent `impl`, but that item is not marked `default`\n+    .note = parent implementation is in crate `{$cname}`\n \n-hir_analysis_typeof_reserved_keyword_used =\n-    `typeof` is a reserved keyword but unimplemented\n-    .suggestion = consider replacing `typeof(...)` with an actual type\n-    .label = reserved keyword\n+hir_analysis_invalid_union_field =\n+    field must implement `Copy` or be wrapped in `ManuallyDrop<...>` to be used in a union\n+    .note = union fields must not have drop side-effects, which is currently enforced via either `Copy` or `ManuallyDrop<...>`\n \n-hir_analysis_value_of_associated_struct_already_specified =\n-    the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n-    .label = re-bound here\n-    .previous_bound_label = `{$item_name}` bound here first\n+hir_analysis_invalid_union_field_sugg =\n+    wrap the field type in `ManuallyDrop<...>`\n \n-hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n-    .note = `{$name}` must be used in combination with a concrete type within the same {$what}\n+hir_analysis_lifetimes_or_bounds_mismatch_on_trait =\n+    lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n+    .label = lifetimes do not match {$item_kind} in trait\n+    .generics_label = lifetimes in impl do not match this {$item_kind} in trait\n+    .where_label = this `where` clause might not match the one in the trait\n+    .bounds_label = this bound might be missing in the impl\n+\n+hir_analysis_linkage_type =\n+    invalid type for variable with `#[linkage]` attribute\n+\n+hir_analysis_main_function_async = `main` function is not allowed to be `async`\n+    .label = `main` function is not allowed to be `async`\n+\n+hir_analysis_main_function_generic_parameters = `main` function is not allowed to have generic parameters\n+    .label = `main` cannot have generic parameters\n+\n+hir_analysis_main_function_return_type_generic = `main` function return type is not allowed to have generic parameters\n \n hir_analysis_manual_implementation =\n     manual implementations of `{$trait_name}` are experimental\n     .label = manual implementations of `{$trait_name}` are experimental\n     .help = add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-hir_analysis_substs_on_overridden_impl = could not resolve substs on overridden impl\n+hir_analysis_missing_one_of_trait_item = not all trait items implemented, missing one of: `{$missing_items_msg}`\n+    .label = missing one of `{$missing_items_msg}` in implementation\n+    .note = required because of this annotation\n \n-hir_analysis_trait_object_declared_with_no_traits =\n-    at least one trait is required for an object type\n-    .alias_span = this alias does not contain a trait\n+hir_analysis_missing_tilde_const = missing `~const` qualifier for specialization\n+\n+hir_analysis_missing_trait_item = not all trait items implemented, missing: `{$missing_items_msg}`\n+    .label = missing `{$missing_items_msg}` in implementation\n+\n+hir_analysis_missing_trait_item_label = `{$item}` from trait\n+\n+hir_analysis_missing_trait_item_suggestion = implement the missing item: `{$snippet}`\n+\n+hir_analysis_missing_trait_item_unstable = not all trait items implemented, missing: `{$missing_item_name}`\n+    .note = default implementation of `{$missing_item_name}` is unstable\n+    .some_note = use of unstable library feature '{$feature}': {$r}\n+    .none_note = use of unstable library feature '{$feature}'\n \n hir_analysis_missing_type_params =\n     the type {$parameterCount ->\n@@ -95,199 +162,132 @@ hir_analysis_missing_type_params =\n     } to {$parameters}\n     .note = because of the default `Self` reference, type parameters must be specified on object types\n \n-hir_analysis_copy_impl_on_type_with_dtor =\n-    the trait `Copy` cannot be implemented for this type; the type has a destructor\n-    .label = `Copy` not allowed on types with destructors\n-\n hir_analysis_multiple_relaxed_default_bounds =\n     type parameter has more than one relaxed default bound, only one is supported\n \n-hir_analysis_copy_impl_on_non_adt =\n-    the trait `Copy` cannot be implemented for this type\n-    .label = type is not a structure or enumeration\n-\n-hir_analysis_const_impl_for_non_const_trait =\n-    const `impl` for trait `{$trait_name}` which is not marked with `#[const_trait]`\n-    .suggestion = mark `{$trait_name}` as const\n-    .note = marking a trait with `#[const_trait]` ensures all default method bodies are `const`\n-    .adding = adding a non-const method body in the future would be a breaking change\n-\n-hir_analysis_const_bound_for_non_const_trait =\n-    ~const can only be applied to `#[const_trait]` traits\n-\n-hir_analysis_self_in_impl_self =\n-    `Self` is not valid in the self type of an impl block\n-    .note = replace `Self` with a different type\n-\n-hir_analysis_linkage_type =\n-    invalid type for variable with `#[linkage]` attribute\n-\n-hir_analysis_auto_deref_reached_recursion_limit = reached the recursion limit while auto-dereferencing `{$ty}`\n-    .label = deref recursion limit reached\n-    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n-\n-hir_analysis_where_clause_on_main = `main` function is not allowed to have a `where` clause\n-    .label = `main` cannot have a `where` clause\n-\n-hir_analysis_track_caller_on_main = `main` function is not allowed to be `#[track_caller]`\n-    .suggestion = remove this annotation\n-\n-hir_analysis_target_feature_on_main = `main` function is not allowed to have `#[target_feature]`\n-\n-hir_analysis_start_not_track_caller = `start` is not allowed to be `#[track_caller]`\n-    .label = `start` is not allowed to be `#[track_caller]`\n-\n-hir_analysis_start_not_target_feature = `start` is not allowed to have `#[target_feature]`\n-    .label = `start` is not allowed to have `#[target_feature]`\n-\n-hir_analysis_start_not_async = `start` is not allowed to be `async`\n-    .label = `start` is not allowed to be `async`\n-\n-hir_analysis_start_function_where = start function is not allowed to have a `where` clause\n-    .label = start function cannot have a `where` clause\n-\n-hir_analysis_start_function_parameters = start function is not allowed to have type parameters\n-    .label = start function cannot have type parameters\n-\n-hir_analysis_main_function_return_type_generic = `main` function return type is not allowed to have generic parameters\n+hir_analysis_must_be_name_of_associated_function = must be a name of an associated function\n \n-hir_analysis_main_function_async = `main` function is not allowed to be `async`\n-    .label = `main` function is not allowed to be `async`\n+hir_analysis_must_implement_not_function = not a function\n \n-hir_analysis_main_function_generic_parameters = `main` function is not allowed to have generic parameters\n-    .label = `main` cannot have generic parameters\n+hir_analysis_must_implement_not_function_note = all `#[rustc_must_implement_one_of]` arguments must be associated function names\n \n-hir_analysis_variadic_function_compatible_convention = C-variadic function must have a compatible calling convention, like {$conventions}\n-    .label = C-variadic function must have a compatible calling convention\n+hir_analysis_must_implement_not_function_span_note = required by this annotation\n \n-hir_analysis_cannot_capture_late_bound_ty_in_anon_const =\n-    cannot capture late-bound type parameter in a constant\n-    .label = parameter defined here\n+hir_analysis_must_implement_one_of_attribute = the `#[rustc_must_implement_one_of]` attribute must be used with at least 2 args\n \n-hir_analysis_cannot_capture_late_bound_const_in_anon_const =\n-    cannot capture late-bound const parameter in a constant\n-    .label = parameter defined here\n+hir_analysis_paren_sugar_attribute = the `#[rustc_paren_sugar]` attribute is a temporary means of controlling which traits can use parenthetical notation\n+    .help = add `#![feature(unboxed_closures)]` to the crate attributes to use it\n \n-hir_analysis_variances_of = {$variances_of}\n+hir_analysis_parenthesized_fn_trait_expansion =\n+    parenthesized trait syntax expands to `{$expanded_type}`\n \n hir_analysis_pass_to_variadic_function = can't pass `{$ty}` to variadic function\n     .suggestion = cast the value to `{$cast_ty}`\n     .help = cast the value to `{$cast_ty}`\n \n-hir_analysis_cast_thin_pointer_to_fat_pointer = cannot cast thin pointer `{$expr_ty}` to fat pointer `{$cast_ty}`\n-\n-hir_analysis_invalid_union_field =\n-    field must implement `Copy` or be wrapped in `ManuallyDrop<...>` to be used in a union\n-    .note = union fields must not have drop side-effects, which is currently enforced via either `Copy` or `ManuallyDrop<...>`\n-\n-hir_analysis_invalid_union_field_sugg =\n-    wrap the field type in `ManuallyDrop<...>`\n+hir_analysis_placeholder_not_allowed_item_signatures = the placeholder `_` is not allowed within types on item signatures for {$kind}\n+    .label = not allowed in type signatures\n \n-hir_analysis_return_type_notation_on_non_rpitit =\n-    return type notation used on function that is not `async` and does not return `impl Trait`\n-    .note = function returns `{$ty}`, which is not compatible with associated type return bounds\n-    .label = this function must be `async` or return `impl Trait`\n+hir_analysis_return_type_notation_conflicting_bound =\n+    ambiguous associated function `{$assoc_name}` for `{$ty_name}`\n+    .note = `{$assoc_name}` is declared in two supertraits: `{$first_bound}` and `{$second_bound}`\n \n hir_analysis_return_type_notation_equality_bound =\n     return type notation is not allowed to use type equality\n \n hir_analysis_return_type_notation_missing_method =\n     cannot find associated function `{$assoc_name}` for `{$ty_name}`\n \n-hir_analysis_return_type_notation_conflicting_bound =\n-    ambiguous associated function `{$assoc_name}` for `{$ty_name}`\n-    .note = `{$assoc_name}` is declared in two supertraits: `{$first_bound}` and `{$second_bound}`\n-\n-hir_analysis_placeholder_not_allowed_item_signatures = the placeholder `_` is not allowed within types on item signatures for {$kind}\n-    .label = not allowed in type signatures\n-\n-hir_analysis_associated_type_trait_uninferred_generic_params = cannot use the associated type of a trait with uninferred generic parameters\n-    .suggestion = use a fully qualified path with inferred lifetimes\n-\n-hir_analysis_associated_type_trait_uninferred_generic_params_multipart_suggestion = use a fully qualified path with explicit lifetimes\n-\n-hir_analysis_enum_discriminant_overflowed = enum discriminant overflowed\n-    .label = overflowed on value after {$discr}\n-    .note = explicitly set `{$item_name} = {$wrapped_discr}` if that is desired outcome\n-\n-hir_analysis_paren_sugar_attribute = the `#[rustc_paren_sugar]` attribute is a temporary means of controlling which traits can use parenthetical notation\n-    .help = add `#![feature(unboxed_closures)]` to the crate attributes to use it\n-\n-hir_analysis_must_implement_one_of_attribute = the `#[rustc_must_implement_one_of]` attribute must be used with at least 2 args\n-\n-hir_analysis_must_be_name_of_associated_function = must be a name of an associated function\n+hir_analysis_return_type_notation_on_non_rpitit =\n+    return type notation used on function that is not `async` and does not return `impl Trait`\n+    .note = function returns `{$ty}`, which is not compatible with associated type return bounds\n+    .label = this function must be `async` or return `impl Trait`\n \n-hir_analysis_function_not_have_default_implementation = function doesn't have a default implementation\n-    .note = required by this annotation\n+hir_analysis_self_in_impl_self =\n+    `Self` is not valid in the self type of an impl block\n+    .note = replace `Self` with a different type\n \n-hir_analysis_must_implement_not_function = not a function\n+hir_analysis_simd_ffi_highly_experimental = use of SIMD type{$snip} in FFI is highly experimental and may result in invalid code\n+    .help = add `#![feature(simd_ffi)]` to the crate attributes to enable\n \n-hir_analysis_must_implement_not_function_span_note = required by this annotation\n+hir_analysis_specialization_trait = implementing `rustc_specialization_trait` traits is unstable\n+    .help = add `#![feature(min_specialization)]` to the crate attributes to enable\n \n-hir_analysis_must_implement_not_function_note = all `#[rustc_must_implement_one_of]` arguments must be associated function names\n+hir_analysis_start_function_parameters = start function is not allowed to have type parameters\n+    .label = start function cannot have type parameters\n \n-hir_analysis_function_not_found_in_trait = function not found in this trait\n+hir_analysis_start_function_where = start function is not allowed to have a `where` clause\n+    .label = start function cannot have a `where` clause\n \n-hir_analysis_functions_names_duplicated = functions names are duplicated\n-    .note = all `#[rustc_must_implement_one_of]` arguments must be unique\n+hir_analysis_start_not_async = `start` is not allowed to be `async`\n+    .label = `start` is not allowed to be `async`\n \n-hir_analysis_simd_ffi_highly_experimental = use of SIMD type{$snip} in FFI is highly experimental and may result in invalid code\n-    .help = add `#![feature(simd_ffi)]` to the crate attributes to enable\n+hir_analysis_start_not_target_feature = `start` is not allowed to have `#[target_feature]`\n+    .label = `start` is not allowed to have `#[target_feature]`\n \n-hir_analysis_impl_not_marked_default = `{$ident}` specializes an item from a parent `impl`, but that item is not marked `default`\n-    .label = cannot specialize default item `{$ident}`\n-    .ok_label = parent `impl` is here\n-    .note = to specialize, `{$ident}` in the parent `impl` must be marked `default`\n+hir_analysis_start_not_track_caller = `start` is not allowed to be `#[track_caller]`\n+    .label = `start` is not allowed to be `#[track_caller]`\n \n-hir_analysis_impl_not_marked_default_err = `{$ident}` specializes an item from a parent `impl`, but that item is not marked `default`\n-    .note = parent implementation is in crate `{$cname}`\n+hir_analysis_static_specialize = cannot specialize on `'static` lifetime\n \n-hir_analysis_missing_trait_item = not all trait items implemented, missing: `{$missing_items_msg}`\n-    .label = missing `{$missing_items_msg}` in implementation\n+hir_analysis_substs_on_overridden_impl = could not resolve substs on overridden impl\n \n-hir_analysis_missing_trait_item_suggestion = implement the missing item: `{$snippet}`\n+hir_analysis_target_feature_on_main = `main` function is not allowed to have `#[target_feature]`\n \n-hir_analysis_missing_trait_item_label = `{$item}` from trait\n+hir_analysis_too_large_static = extern static is too large for the current architecture\n \n-hir_analysis_missing_one_of_trait_item = not all trait items implemented, missing one of: `{$missing_items_msg}`\n-    .label = missing one of `{$missing_items_msg}` in implementation\n-    .note = required because of this annotation\n+hir_analysis_track_caller_on_main = `main` function is not allowed to be `#[track_caller]`\n+    .suggestion = remove this annotation\n \n-hir_analysis_missing_trait_item_unstable = not all trait items implemented, missing: `{$missing_item_name}`\n-    .note = default implementation of `{$missing_item_name}` is unstable\n-    .some_note = use of unstable library feature '{$feature}': {$r}\n-    .none_note = use of unstable library feature '{$feature}'\n+hir_analysis_trait_object_declared_with_no_traits =\n+    at least one trait is required for an object type\n+    .alias_span = this alias does not contain a trait\n \n hir_analysis_transparent_enum_variant = transparent enum needs exactly one variant, but has {$number}\n     .label = needs exactly one variant, but has {$number}\n     .many_label = too many variants in `{$path}`\n     .multi_label = variant here\n \n-hir_analysis_transparent_non_zero_sized_enum = the variant of a transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n+hir_analysis_transparent_non_zero_sized = transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n     .label = needs at most one non-zero-sized field, but has {$field_count}\n     .labels = this field is non-zero-sized\n \n-hir_analysis_transparent_non_zero_sized = transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n+hir_analysis_transparent_non_zero_sized_enum = the variant of a transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n     .label = needs at most one non-zero-sized field, but has {$field_count}\n     .labels = this field is non-zero-sized\n \n-hir_analysis_too_large_static = extern static is too large for the current architecture\n+hir_analysis_typeof_reserved_keyword_used =\n+    `typeof` is a reserved keyword but unimplemented\n+    .suggestion = consider replacing `typeof(...)` with an actual type\n+    .label = reserved keyword\n \n-hir_analysis_specialization_trait = implementing `rustc_specialization_trait` traits is unstable\n-    .help = add `#![feature(min_specialization)]` to the crate attributes to enable\n+hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n+    .note = `{$name}` must be used in combination with a concrete type within the same {$what}\n \n-hir_analysis_closure_implicit_hrtb = implicit types in closure signatures are forbidden when `for<...>` is present\n-    .label = `for<...>` is here\n+hir_analysis_unrecognized_atomic_operation =\n+    unrecognized atomic operation function: `{$op}`\n+    .label = unrecognized atomic operation\n \n-hir_analysis_empty_specialization = specialization impl does not specialize any associated items\n-    .note = impl is a specialization of this impl\n+hir_analysis_unrecognized_intrinsic_function =\n+    unrecognized intrinsic function: `{$name}`\n+    .label = unrecognized intrinsic\n \n-hir_analysis_const_specialize = cannot specialize on const impl with non-const impl\n+hir_analysis_value_of_associated_struct_already_specified =\n+    the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n+    .label = re-bound here\n+    .previous_bound_label = `{$item_name}` bound here first\n \n-hir_analysis_static_specialize = cannot specialize on `'static` lifetime\n+hir_analysis_variadic_function_compatible_convention = C-variadic function must have a compatible calling convention, like {$conventions}\n+    .label = C-variadic function must have a compatible calling convention\n \n-hir_analysis_missing_tilde_const = missing `~const` qualifier for specialization\n+hir_analysis_variances_of = {$variances_of}\n \n-hir_analysis_drop_impl_negative = negative `Drop` impls are not supported\n+hir_analysis_where_clause_on_main = `main` function is not allowed to have a `where` clause\n+    .label = `main` cannot have a `where` clause\n \n-hir_analysis_drop_impl_reservation = reservation `Drop` impls are not supported\n+hir_analysis_wrong_number_of_generic_arguments_to_intrinsic =\n+    intrinsic has wrong number of {$descr} parameters: found {$found}, expected {$expected}\n+    .label = expected {$expected} {$descr} {$expected ->\n+        [one] parameter\n+        *[other] parameters\n+    }"}, {"sha": "5fb06cf94652ea5d9876ac80512e1be8bb5a39ac", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -2625,7 +2625,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     && tcx.all_impls(*trait_def_id)\n                         .any(|impl_def_id| {\n                             let trait_ref = tcx.impl_trait_ref(impl_def_id);\n-                            trait_ref.map_or(false, |trait_ref| {\n+                            trait_ref.is_some_and(|trait_ref| {\n                                 let impl_ = trait_ref.subst(\n                                     tcx,\n                                     infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id),\n@@ -3654,7 +3654,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ..\n         }) = tcx.hir().get_by_def_id(parent_id) && self_ty.hir_id == impl_self_ty.hir_id\n         {\n-            if !of_trait_ref.trait_def_id().map_or(false, |def_id| def_id.is_local()) {\n+            if !of_trait_ref.trait_def_id().is_some_and(|def_id| def_id.is_local()) {\n                 return;\n             }\n             let of_trait_span = of_trait_ref.path.span;\n@@ -3693,7 +3693,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .source_map()\n                     .span_to_prev_source(self_ty.span)\n                     .ok()\n-                    .map_or(false, |s| s.trim_end().ends_with('<'));\n+                    .is_some_and(|s| s.trim_end().ends_with('<'));\n \n             let is_global = poly_trait_ref.trait_ref.path.is_global();\n "}, {"sha": "d6d1498d708eda8e4008041a146cdf724811d178", "filename": "compiler/rustc_hir_analysis/src/autoderef.rs", "status": "modified", "additions": 54, "deletions": 22, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fautoderef.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,6 +1,5 @@\n use crate::errors::AutoDerefReachedRecursionLimit;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n-use crate::traits::NormalizeExt;\n use crate::traits::{self, TraitEngine, TraitEngineExt};\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::TypeVisitableExt;\n@@ -9,6 +8,7 @@ use rustc_session::Limit;\n use rustc_span::def_id::LocalDefId;\n use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::Span;\n+use rustc_trait_selection::traits::StructurallyNormalizeExt;\n \n #[derive(Copy, Clone, Debug)]\n pub enum AutoderefKind {\n@@ -66,14 +66,27 @@ impl<'a, 'tcx> Iterator for Autoderef<'a, 'tcx> {\n         }\n \n         // Otherwise, deref if type is derefable:\n-        let (kind, new_ty) =\n-            if let Some(mt) = self.state.cur_ty.builtin_deref(self.include_raw_pointers) {\n-                (AutoderefKind::Builtin, mt.ty)\n-            } else if let Some(ty) = self.overloaded_deref_ty(self.state.cur_ty) {\n-                (AutoderefKind::Overloaded, ty)\n+        let (kind, new_ty) = if let Some(ty::TypeAndMut { ty, .. }) =\n+            self.state.cur_ty.builtin_deref(self.include_raw_pointers)\n+        {\n+            debug_assert_eq!(ty, self.infcx.resolve_vars_if_possible(ty));\n+            // NOTE: we may still need to normalize the built-in deref in case\n+            // we have some type like `&<Ty as Trait>::Assoc`, since users of\n+            // autoderef expect this type to have been structurally normalized.\n+            if self.infcx.tcx.trait_solver_next()\n+                && let ty::Alias(ty::Projection, _) = ty.kind()\n+            {\n+                let (normalized_ty, obligations) = self.structurally_normalize(ty)?;\n+                self.state.obligations.extend(obligations);\n+                (AutoderefKind::Builtin, normalized_ty)\n             } else {\n-                return None;\n-            };\n+                (AutoderefKind::Builtin, ty)\n+            }\n+        } else if let Some(ty) = self.overloaded_deref_ty(self.state.cur_ty) {\n+            (AutoderefKind::Overloaded, ty)\n+        } else {\n+            return None;\n+        };\n \n         if new_ty.references_error() {\n             return None;\n@@ -119,14 +132,11 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n \n     fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n         debug!(\"overloaded_deref_ty({:?})\", ty);\n-\n         let tcx = self.infcx.tcx;\n \n         // <ty as Deref>\n         let trait_ref = ty::TraitRef::new(tcx, tcx.lang_items().deref_trait()?, [ty]);\n-\n         let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-\n         let obligation = traits::Obligation::new(\n             tcx,\n             cause.clone(),\n@@ -138,26 +148,48 @@ impl<'a, 'tcx> Autoderef<'a, 'tcx> {\n             return None;\n         }\n \n-        let normalized_ty = self\n+        let (normalized_ty, obligations) =\n+            self.structurally_normalize(tcx.mk_projection(tcx.lang_items().deref_target()?, [ty]))?;\n+        debug!(\"overloaded_deref_ty({:?}) = ({:?}, {:?})\", ty, normalized_ty, obligations);\n+        self.state.obligations.extend(obligations);\n+\n+        Some(self.infcx.resolve_vars_if_possible(normalized_ty))\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub fn structurally_normalize(\n+        &self,\n+        ty: Ty<'tcx>,\n+    ) -> Option<(Ty<'tcx>, Vec<traits::PredicateObligation<'tcx>>)> {\n+        let tcx = self.infcx.tcx;\n+        let mut fulfill_cx = <dyn TraitEngine<'tcx>>::new_in_snapshot(tcx);\n+\n+        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+        let normalized_ty = match self\n             .infcx\n             .at(&cause, self.param_env)\n-            .normalize(tcx.mk_projection(tcx.lang_items().deref_target()?, trait_ref.substs));\n-        let mut fulfillcx = <dyn TraitEngine<'tcx>>::new_in_snapshot(tcx);\n-        let normalized_ty =\n-            normalized_ty.into_value_registering_obligations(self.infcx, &mut *fulfillcx);\n-        let errors = fulfillcx.select_where_possible(&self.infcx);\n+            .structurally_normalize(ty, &mut *fulfill_cx)\n+        {\n+            Ok(normalized_ty) => normalized_ty,\n+            Err(errors) => {\n+                // This shouldn't happen, except for evaluate/fulfill mismatches,\n+                // but that's not a reason for an ICE (`predicate_may_hold` is conservative\n+                // by design).\n+                debug!(?errors, \"encountered errors while fulfilling\");\n+                return None;\n+            }\n+        };\n+\n+        let errors = fulfill_cx.select_where_possible(&self.infcx);\n         if !errors.is_empty() {\n             // This shouldn't happen, except for evaluate/fulfill mismatches,\n             // but that's not a reason for an ICE (`predicate_may_hold` is conservative\n             // by design).\n-            debug!(\"overloaded_deref_ty: encountered errors {:?} while fulfilling\", errors);\n+            debug!(?errors, \"encountered errors while fulfilling\");\n             return None;\n         }\n-        let obligations = fulfillcx.pending_obligations();\n-        debug!(\"overloaded_deref_ty({:?}) = ({:?}, {:?})\", ty, normalized_ty, obligations);\n-        self.state.obligations.extend(obligations);\n \n-        Some(self.infcx.resolve_vars_if_possible(normalized_ty))\n+        Some((normalized_ty, fulfill_cx.pending_obligations()))\n     }\n \n     /// Returns the final type we ended up with, which may be an inference"}, {"sha": "3b2c052e8f459d4492107de25f18b1ce02acbd01", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -13,11 +13,12 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ItemKind, Node, PathSegment};\n use rustc_infer::infer::opaque_types::ConstrainOpaqueTypeRegionVisitor;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n+use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::{Obligation, TraitEngineExt as _};\n use rustc_lint_defs::builtin::REPR_TRANSPARENT_EXTERNAL_PRIVATE_FIELDS;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::stability::EvalResult;\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::layout::{LayoutError, MAX_SIMD_LANES};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt};\n@@ -800,16 +801,15 @@ fn check_impl_items_against_trait<'tcx>(\n \n             let is_implemented = leaf_def\n                 .as_ref()\n-                .map_or(false, |node_item| node_item.item.defaultness(tcx).has_value());\n+                .is_some_and(|node_item| node_item.item.defaultness(tcx).has_value());\n \n             if !is_implemented && tcx.impl_defaultness(impl_id).is_final() {\n                 missing_items.push(tcx.associated_item(trait_item_id));\n             }\n \n             // true if this item is specifically implemented in this impl\n-            let is_implemented_here = leaf_def\n-                .as_ref()\n-                .map_or(false, |node_item| !node_item.defining_node.is_from_trait());\n+            let is_implemented_here =\n+                leaf_def.as_ref().is_some_and(|node_item| !node_item.defining_node.is_from_trait());\n \n             if !is_implemented_here {\n                 let full_impl_span =\n@@ -1082,8 +1082,8 @@ pub(super) fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, adt: ty::AdtDef<'tcx>)\n         let layout = tcx.layout_of(param_env.and(ty));\n         // We are currently checking the type this field came from, so it must be local\n         let span = tcx.hir().span_if_local(field.did).unwrap();\n-        let zst = layout.map_or(false, |layout| layout.is_zst());\n-        let align1 = layout.map_or(false, |layout| layout.align.abi.bytes() == 1);\n+        let zst = layout.is_ok_and(|layout| layout.is_zst());\n+        let align1 = layout.is_ok_and(|layout| layout.align.abi.bytes() == 1);\n         if !zst {\n             return (span, zst, align1, None);\n         }"}, {"sha": "b403ee96b42298df750bed96dc856f19c9991d5e", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -179,7 +179,7 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         hir::ItemKind::Impl(impl_) => {\n             let is_auto = tcx\n                 .impl_trait_ref(def_id)\n-                .map_or(false, |trait_ref| tcx.trait_is_auto(trait_ref.skip_binder().def_id));\n+                .is_some_and(|trait_ref| tcx.trait_is_auto(trait_ref.skip_binder().def_id));\n             if let (hir::Defaultness::Default { .. }, true) = (impl_.defaultness, is_auto) {\n                 let sp = impl_.of_trait.as_ref().map_or(item.span, |t| t.path.span);\n                 let mut err ="}, {"sha": "ca0d5509c5768e761a3de5c9ec40a222f6ad7655", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -819,7 +819,7 @@ fn convert_variant(\n         recovered,\n         adt_kind == AdtKind::Struct && tcx.has_attr(parent_did, sym::non_exhaustive)\n             || variant_did\n-                .map_or(false, |variant_did| tcx.has_attr(variant_did, sym::non_exhaustive)),\n+                .is_some_and(|variant_did| tcx.has_attr(variant_did, sym::non_exhaustive)),\n     )\n }\n \n@@ -1025,7 +1025,7 @@ fn is_suggestable_infer_ty(ty: &hir::Ty<'_>) -> bool {\n             is_suggestable_infer_ty(ty) || are_suggestable_generic_args(segment.args().args)\n         }\n         Path(hir::QPath::Resolved(ty_opt, hir::Path { segments, .. })) => {\n-            ty_opt.map_or(false, is_suggestable_infer_ty)\n+            ty_opt.is_some_and(is_suggestable_infer_ty)\n                 || segments.iter().any(|segment| are_suggestable_generic_args(segment.args().args))\n         }\n         _ => false,"}, {"sha": "e5b5dae551e875c2d4635b8e5b3a65d398cd3765", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -427,6 +427,8 @@ pub(super) fn explicit_predicates_of<'tcx>(\n             //   supertrait).\n             if let ty::Alias(ty::Projection, projection) = ty.kind() {\n                 projection.substs == trait_identity_substs\n+                    // FIXME(return_type_notation): This check should be more robust\n+                    && !tcx.is_impl_trait_in_trait(projection.def_id)\n                     && tcx.associated_item(projection.def_id).container_id(tcx)\n                         == def_id.to_def_id()\n             } else {"}, {"sha": "8e082d3c5328b786faf1e5d07767072b278d9503", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 304, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,10 +1,7 @@\n use rustc_errors::{Applicability, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::intravisit;\n-use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{HirId, Node};\n-use rustc_middle::hir::nested_filter;\n+use rustc_hir::HirId;\n use rustc_middle::ty::print::with_forced_trimmed_paths;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::IntTypeExt;\n@@ -14,7 +11,8 @@ use rustc_span::{Span, DUMMY_SP};\n \n use super::ItemCtxt;\n use super::{bad_placeholder, is_suggestable_infer_ty};\n-use crate::errors::UnconstrainedOpaqueType;\n+\n+mod opaque;\n \n fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n     use hir::*;\n@@ -429,7 +427,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n                 ItemKind::OpaqueTy(OpaqueTy {\n                     origin: hir::OpaqueTyOrigin::TyAlias { .. },\n                     ..\n-                }) => find_opaque_ty_constraints_for_tait(tcx, def_id),\n+                }) => opaque::find_opaque_ty_constraints_for_tait(tcx, def_id),\n                 // Opaque types desugared from `impl Trait`.\n                 ItemKind::OpaqueTy(OpaqueTy {\n                     origin:\n@@ -443,7 +441,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n                             \"tried to get type of this RPITIT with no definition\"\n                         );\n                     }\n-                    find_opaque_ty_constraints_for_rpit(tcx, def_id, owner)\n+                    opaque::find_opaque_ty_constraints_for_rpit(tcx, def_id, owner)\n                 }\n                 ItemKind::Trait(..)\n                 | ItemKind::TraitAlias(..)\n@@ -502,303 +500,6 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n     ty::EarlyBinder(output)\n }\n \n-#[instrument(skip(tcx), level = \"debug\")]\n-/// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n-/// laid for \"higher-order pattern unification\".\n-/// This ensures that inference is tractable.\n-/// In particular, definitions of opaque types can only use other generics as arguments,\n-/// and they cannot repeat an argument. Example:\n-///\n-/// ```ignore (illustrative)\n-/// type Foo<A, B> = impl Bar<A, B>;\n-///\n-/// // Okay -- `Foo` is applied to two distinct, generic types.\n-/// fn a<T, U>() -> Foo<T, U> { .. }\n-///\n-/// // Not okay -- `Foo` is applied to `T` twice.\n-/// fn b<T>() -> Foo<T, T> { .. }\n-///\n-/// // Not okay -- `Foo` is applied to a non-generic type.\n-/// fn b<T>() -> Foo<T, u32> { .. }\n-/// ```\n-///\n-fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n-    use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n-\n-    struct ConstraintLocator<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        /// def_id of the opaque type whose defining uses are being checked\n-        def_id: LocalDefId,\n-\n-        /// as we walk the defining uses, we are checking that all of them\n-        /// define the same hidden type. This variable is set to `Some`\n-        /// with the first type that we find, and then later types are\n-        /// checked against it (we also carry the span of that first\n-        /// type).\n-        found: Option<ty::OpaqueHiddenType<'tcx>>,\n-\n-        /// In the presence of dead code, typeck may figure out a hidden type\n-        /// while borrowck will not. We collect these cases here and check at\n-        /// the end that we actually found a type that matches (modulo regions).\n-        typeck_types: Vec<ty::OpaqueHiddenType<'tcx>>,\n-    }\n-\n-    impl ConstraintLocator<'_> {\n-        #[instrument(skip(self), level = \"debug\")]\n-        fn check(&mut self, item_def_id: LocalDefId) {\n-            // Don't try to check items that cannot possibly constrain the type.\n-            if !self.tcx.has_typeck_results(item_def_id) {\n-                debug!(\"no constraint: no typeck results\");\n-                return;\n-            }\n-            // Calling `mir_borrowck` can lead to cycle errors through\n-            // const-checking, avoid calling it if we don't have to.\n-            // ```rust\n-            // type Foo = impl Fn() -> usize; // when computing type for this\n-            // const fn bar() -> Foo {\n-            //     || 0usize\n-            // }\n-            // const BAZR: Foo = bar(); // we would mir-borrowck this, causing cycles\n-            // // because we again need to reveal `Foo` so we can check whether the\n-            // // constant does not contain interior mutability.\n-            // ```\n-            let tables = self.tcx.typeck(item_def_id);\n-            if let Some(guar) = tables.tainted_by_errors {\n-                self.found =\n-                    Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n-                return;\n-            }\n-            let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n-                debug!(\"no constraints in typeck results\");\n-                return;\n-            };\n-            if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n-                self.typeck_types.push(typeck_hidden_ty);\n-            }\n-\n-            // Use borrowck to get the type with unerased regions.\n-            let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n-            debug!(?concrete_opaque_types);\n-            if let Some(&concrete_type) = concrete_opaque_types.get(&self.def_id) {\n-                debug!(?concrete_type, \"found constraint\");\n-                if let Some(prev) = &mut self.found {\n-                    if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n-                        let guar = prev.report_mismatch(&concrete_type, self.tcx);\n-                        prev.ty = self.tcx.ty_error(guar);\n-                    }\n-                } else {\n-                    self.found = Some(concrete_type);\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'tcx> {\n-        type NestedFilter = nested_filter::All;\n-\n-        fn nested_visit_map(&mut self) -> Self::Map {\n-            self.tcx.hir()\n-        }\n-        fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-            if let hir::ExprKind::Closure(closure) = ex.kind {\n-                self.check(closure.def_id);\n-            }\n-            intravisit::walk_expr(self, ex);\n-        }\n-        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_item(self, it);\n-            }\n-        }\n-        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_impl_item(self, it);\n-            }\n-        }\n-        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            self.check(it.owner_id.def_id);\n-            intravisit::walk_trait_item(self, it);\n-        }\n-    }\n-\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-    let scope = tcx.hir().get_defining_scope(hir_id);\n-    let mut locator = ConstraintLocator { def_id, tcx, found: None, typeck_types: vec![] };\n-\n-    debug!(?scope);\n-\n-    if scope == hir::CRATE_HIR_ID {\n-        tcx.hir().walk_toplevel_module(&mut locator);\n-    } else {\n-        trace!(\"scope={:#?}\", tcx.hir().get(scope));\n-        match tcx.hir().get(scope) {\n-            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n-            // This allows our visitor to process the defining item itself, causing\n-            // it to pick up any 'sibling' defining uses.\n-            //\n-            // For example, this code:\n-            // ```\n-            // fn foo() {\n-            //     type Blah = impl Debug;\n-            //     let my_closure = || -> Blah { true };\n-            // }\n-            // ```\n-            //\n-            // requires us to explicitly process `foo()` in order\n-            // to notice the defining usage of `Blah`.\n-            Node::Item(it) => locator.visit_item(it),\n-            Node::ImplItem(it) => locator.visit_impl_item(it),\n-            Node::TraitItem(it) => locator.visit_trait_item(it),\n-            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n-        }\n-    }\n-\n-    let Some(hidden) = locator.found else {\n-        let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n-            span: tcx.def_span(def_id),\n-            name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n-            what: match tcx.hir().get(scope) {\n-                _ if scope == hir::CRATE_HIR_ID => \"module\",\n-                Node::Item(hir::Item { kind: hir::ItemKind::Mod(_), .. }) => \"module\",\n-                Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }) => \"impl\",\n-                _ => \"item\",\n-            },\n-        });\n-        return tcx.ty_error(reported);\n-    };\n-\n-    // Only check against typeck if we didn't already error\n-    if !hidden.ty.references_error() {\n-        for concrete_type in locator.typeck_types {\n-            if tcx.erase_regions(concrete_type.ty) != tcx.erase_regions(hidden.ty)\n-                && !(concrete_type, hidden).references_error()\n-            {\n-                hidden.report_mismatch(&concrete_type, tcx);\n-            }\n-        }\n-    }\n-\n-    hidden.ty\n-}\n-\n-fn find_opaque_ty_constraints_for_rpit(\n-    tcx: TyCtxt<'_>,\n-    def_id: LocalDefId,\n-    owner_def_id: LocalDefId,\n-) -> Ty<'_> {\n-    use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n-\n-    struct ConstraintChecker<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-\n-        /// def_id of the opaque type whose defining uses are being checked\n-        def_id: LocalDefId,\n-\n-        found: ty::OpaqueHiddenType<'tcx>,\n-    }\n-\n-    impl ConstraintChecker<'_> {\n-        #[instrument(skip(self), level = \"debug\")]\n-        fn check(&self, def_id: LocalDefId) {\n-            // Use borrowck to get the type with unerased regions.\n-            let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n-            debug!(?concrete_opaque_types);\n-            for (&def_id, &concrete_type) in concrete_opaque_types {\n-                if def_id != self.def_id {\n-                    // Ignore constraints for other opaque types.\n-                    continue;\n-                }\n-\n-                debug!(?concrete_type, \"found constraint\");\n-\n-                if concrete_type.ty != self.found.ty\n-                    && !(concrete_type, self.found).references_error()\n-                {\n-                    self.found.report_mismatch(&concrete_type, self.tcx);\n-                }\n-            }\n-        }\n-    }\n-\n-    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintChecker<'tcx> {\n-        type NestedFilter = nested_filter::OnlyBodies;\n-\n-        fn nested_visit_map(&mut self) -> Self::Map {\n-            self.tcx.hir()\n-        }\n-        fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-            if let hir::ExprKind::Closure(closure) = ex.kind {\n-                self.check(closure.def_id);\n-            }\n-            intravisit::walk_expr(self, ex);\n-        }\n-        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_item(self, it);\n-            }\n-        }\n-        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if it.owner_id.def_id != self.def_id {\n-                self.check(it.owner_id.def_id);\n-                intravisit::walk_impl_item(self, it);\n-            }\n-        }\n-        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.owner_id);\n-            self.check(it.owner_id.def_id);\n-            intravisit::walk_trait_item(self, it);\n-        }\n-    }\n-\n-    let concrete = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n-\n-    if let Some(concrete) = concrete {\n-        let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n-        debug!(?scope);\n-        let mut locator = ConstraintChecker { def_id, tcx, found: concrete };\n-\n-        match tcx.hir().get(scope) {\n-            Node::Item(it) => intravisit::walk_item(&mut locator, it),\n-            Node::ImplItem(it) => intravisit::walk_impl_item(&mut locator, it),\n-            Node::TraitItem(it) => intravisit::walk_trait_item(&mut locator, it),\n-            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n-        }\n-    }\n-\n-    concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n-        let table = tcx.typeck(owner_def_id);\n-        if let Some(guar) = table.tainted_by_errors {\n-            // Some error in the\n-            // owner fn prevented us from populating\n-            // the `concrete_opaque_types` table.\n-            tcx.ty_error(guar)\n-        } else {\n-            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n-                // We failed to resolve the opaque type or it\n-                // resolves to itself. We interpret this as the\n-                // no values of the hidden type ever being constructed,\n-                // so we can just make the hidden type be `!`.\n-                // For backwards compatibility reasons, we fall back to\n-                // `()` until we the diverging default is changed.\n-                tcx.mk_diverging_default()\n-            })\n-        }\n-    })\n-}\n-\n fn infer_placeholder_type<'a>(\n     tcx: TyCtxt<'a>,\n     def_id: LocalDefId,"}, {"sha": "f7c5b44678f72f0877ceab58f1175f72e1f5c29b", "filename": "compiler/rustc_hir_analysis/src/collect/type_of/opaque.rs", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of%2Fopaque.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -0,0 +1,298 @@\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir::{self as hir, Expr, ImplItem, Item, Node, TraitItem};\n+use rustc_middle::hir::nested_filter;\n+use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n+use rustc_span::DUMMY_SP;\n+\n+use crate::errors::UnconstrainedOpaqueType;\n+\n+/// Checks \"defining uses\" of opaque `impl Trait` types to ensure that they meet the restrictions\n+/// laid for \"higher-order pattern unification\".\n+/// This ensures that inference is tractable.\n+/// In particular, definitions of opaque types can only use other generics as arguments,\n+/// and they cannot repeat an argument. Example:\n+///\n+/// ```ignore (illustrative)\n+/// type Foo<A, B> = impl Bar<A, B>;\n+///\n+/// // Okay -- `Foo` is applied to two distinct, generic types.\n+/// fn a<T, U>() -> Foo<T, U> { .. }\n+///\n+/// // Not okay -- `Foo` is applied to `T` twice.\n+/// fn b<T>() -> Foo<T, T> { .. }\n+///\n+/// // Not okay -- `Foo` is applied to a non-generic type.\n+/// fn b<T>() -> Foo<T, u32> { .. }\n+/// ```\n+#[instrument(skip(tcx), level = \"debug\")]\n+pub(super) fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let scope = tcx.hir().get_defining_scope(hir_id);\n+    let mut locator = TaitConstraintLocator { def_id, tcx, found: None, typeck_types: vec![] };\n+\n+    debug!(?scope);\n+\n+    if scope == hir::CRATE_HIR_ID {\n+        tcx.hir().walk_toplevel_module(&mut locator);\n+    } else {\n+        trace!(\"scope={:#?}\", tcx.hir().get(scope));\n+        match tcx.hir().get(scope) {\n+            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n+            // This allows our visitor to process the defining item itself, causing\n+            // it to pick up any 'sibling' defining uses.\n+            //\n+            // For example, this code:\n+            // ```\n+            // fn foo() {\n+            //     type Blah = impl Debug;\n+            //     let my_closure = || -> Blah { true };\n+            // }\n+            // ```\n+            //\n+            // requires us to explicitly process `foo()` in order\n+            // to notice the defining usage of `Blah`.\n+            Node::Item(it) => locator.visit_item(it),\n+            Node::ImplItem(it) => locator.visit_impl_item(it),\n+            Node::TraitItem(it) => locator.visit_trait_item(it),\n+            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n+        }\n+    }\n+\n+    let Some(hidden) = locator.found else {\n+        let reported = tcx.sess.emit_err(UnconstrainedOpaqueType {\n+            span: tcx.def_span(def_id),\n+            name: tcx.item_name(tcx.local_parent(def_id).to_def_id()),\n+            what: match tcx.hir().get(scope) {\n+                _ if scope == hir::CRATE_HIR_ID => \"module\",\n+                Node::Item(hir::Item { kind: hir::ItemKind::Mod(_), .. }) => \"module\",\n+                Node::Item(hir::Item { kind: hir::ItemKind::Impl(_), .. }) => \"impl\",\n+                _ => \"item\",\n+            },\n+        });\n+        return tcx.ty_error(reported);\n+    };\n+\n+    // Only check against typeck if we didn't already error\n+    if !hidden.ty.references_error() {\n+        for concrete_type in locator.typeck_types {\n+            if concrete_type.ty != tcx.erase_regions(hidden.ty)\n+                && !(concrete_type, hidden).references_error()\n+            {\n+                hidden.report_mismatch(&concrete_type, def_id, tcx).emit();\n+            }\n+        }\n+    }\n+\n+    hidden.ty\n+}\n+\n+struct TaitConstraintLocator<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    /// def_id of the opaque type whose defining uses are being checked\n+    def_id: LocalDefId,\n+\n+    /// as we walk the defining uses, we are checking that all of them\n+    /// define the same hidden type. This variable is set to `Some`\n+    /// with the first type that we find, and then later types are\n+    /// checked against it (we also carry the span of that first\n+    /// type).\n+    found: Option<ty::OpaqueHiddenType<'tcx>>,\n+\n+    /// In the presence of dead code, typeck may figure out a hidden type\n+    /// while borrowck will not. We collect these cases here and check at\n+    /// the end that we actually found a type that matches (modulo regions).\n+    typeck_types: Vec<ty::OpaqueHiddenType<'tcx>>,\n+}\n+\n+impl TaitConstraintLocator<'_> {\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn check(&mut self, item_def_id: LocalDefId) {\n+        // Don't try to check items that cannot possibly constrain the type.\n+        if !self.tcx.has_typeck_results(item_def_id) {\n+            debug!(\"no constraint: no typeck results\");\n+            return;\n+        }\n+        // Calling `mir_borrowck` can lead to cycle errors through\n+        // const-checking, avoid calling it if we don't have to.\n+        // ```rust\n+        // type Foo = impl Fn() -> usize; // when computing type for this\n+        // const fn bar() -> Foo {\n+        //     || 0usize\n+        // }\n+        // const BAZR: Foo = bar(); // we would mir-borrowck this, causing cycles\n+        // // because we again need to reveal `Foo` so we can check whether the\n+        // // constant does not contain interior mutability.\n+        // ```\n+        let tables = self.tcx.typeck(item_def_id);\n+        if let Some(guar) = tables.tainted_by_errors {\n+            self.found = Some(ty::OpaqueHiddenType { span: DUMMY_SP, ty: self.tcx.ty_error(guar) });\n+            return;\n+        }\n+        let Some(&typeck_hidden_ty) = tables.concrete_opaque_types.get(&self.def_id) else {\n+            debug!(\"no constraints in typeck results\");\n+            return;\n+        };\n+        if self.typeck_types.iter().all(|prev| prev.ty != typeck_hidden_ty.ty) {\n+            self.typeck_types.push(typeck_hidden_ty);\n+        }\n+\n+        // Use borrowck to get the type with unerased regions.\n+        let concrete_opaque_types = &self.tcx.mir_borrowck(item_def_id).concrete_opaque_types;\n+        debug!(?concrete_opaque_types);\n+        if let Some(&concrete_type) = concrete_opaque_types.get(&self.def_id) {\n+            debug!(?concrete_type, \"found constraint\");\n+            if let Some(prev) = &mut self.found {\n+                if concrete_type.ty != prev.ty && !(concrete_type, prev.ty).references_error() {\n+                    let guar = prev.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n+                    prev.ty = self.tcx.ty_error(guar);\n+                }\n+            } else {\n+                self.found = Some(concrete_type);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> intravisit::Visitor<'tcx> for TaitConstraintLocator<'tcx> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.tcx.hir()\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if let hir::ExprKind::Closure(closure) = ex.kind {\n+            self.check(closure.def_id);\n+        }\n+        intravisit::walk_expr(self, ex);\n+    }\n+    fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_item(self, it);\n+        }\n+    }\n+    fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_impl_item(self, it);\n+        }\n+    }\n+    fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        self.check(it.owner_id.def_id);\n+        intravisit::walk_trait_item(self, it);\n+    }\n+}\n+\n+pub(super) fn find_opaque_ty_constraints_for_rpit(\n+    tcx: TyCtxt<'_>,\n+    def_id: LocalDefId,\n+    owner_def_id: LocalDefId,\n+) -> Ty<'_> {\n+    let concrete = tcx.mir_borrowck(owner_def_id).concrete_opaque_types.get(&def_id).copied();\n+\n+    if let Some(concrete) = concrete {\n+        let scope = tcx.hir().local_def_id_to_hir_id(owner_def_id);\n+        debug!(?scope);\n+        let mut locator = RpitConstraintChecker { def_id, tcx, found: concrete };\n+\n+        match tcx.hir().get(scope) {\n+            Node::Item(it) => intravisit::walk_item(&mut locator, it),\n+            Node::ImplItem(it) => intravisit::walk_impl_item(&mut locator, it),\n+            Node::TraitItem(it) => intravisit::walk_trait_item(&mut locator, it),\n+            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n+        }\n+    }\n+\n+    concrete.map(|concrete| concrete.ty).unwrap_or_else(|| {\n+        let table = tcx.typeck(owner_def_id);\n+        if let Some(guar) = table.tainted_by_errors {\n+            // Some error in the\n+            // owner fn prevented us from populating\n+            // the `concrete_opaque_types` table.\n+            tcx.ty_error(guar)\n+        } else {\n+            table.concrete_opaque_types.get(&def_id).map(|ty| ty.ty).unwrap_or_else(|| {\n+                // We failed to resolve the opaque type or it\n+                // resolves to itself. We interpret this as the\n+                // no values of the hidden type ever being constructed,\n+                // so we can just make the hidden type be `!`.\n+                // For backwards compatibility reasons, we fall back to\n+                // `()` until we the diverging default is changed.\n+                tcx.mk_diverging_default()\n+            })\n+        }\n+    })\n+}\n+\n+struct RpitConstraintChecker<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    /// def_id of the opaque type whose defining uses are being checked\n+    def_id: LocalDefId,\n+\n+    found: ty::OpaqueHiddenType<'tcx>,\n+}\n+\n+impl RpitConstraintChecker<'_> {\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn check(&self, def_id: LocalDefId) {\n+        // Use borrowck to get the type with unerased regions.\n+        let concrete_opaque_types = &self.tcx.mir_borrowck(def_id).concrete_opaque_types;\n+        debug!(?concrete_opaque_types);\n+        for (&def_id, &concrete_type) in concrete_opaque_types {\n+            if def_id != self.def_id {\n+                // Ignore constraints for other opaque types.\n+                continue;\n+            }\n+\n+            debug!(?concrete_type, \"found constraint\");\n+\n+            if concrete_type.ty != self.found.ty && !(concrete_type, self.found).references_error()\n+            {\n+                self.found.report_mismatch(&concrete_type, self.def_id, self.tcx).emit();\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> intravisit::Visitor<'tcx> for RpitConstraintChecker<'tcx> {\n+    type NestedFilter = nested_filter::OnlyBodies;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.tcx.hir()\n+    }\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if let hir::ExprKind::Closure(closure) = ex.kind {\n+            self.check(closure.def_id);\n+        }\n+        intravisit::walk_expr(self, ex);\n+    }\n+    fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_item(self, it);\n+        }\n+    }\n+    fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        // The opaque type itself or its children are not within its reveal scope.\n+        if it.owner_id.def_id != self.def_id {\n+            self.check(it.owner_id.def_id);\n+            intravisit::walk_impl_item(self, it);\n+        }\n+    }\n+    fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n+        trace!(?it.owner_id);\n+        self.check(it.owner_id.def_id);\n+        intravisit::walk_trait_item(self, it);\n+    }\n+}"}, {"sha": "ee3457282d3311a7df19a88f63d54a99b3bbc792", "filename": "compiler/rustc_hir_analysis/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -395,7 +395,7 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     ) -> String {\n         let fn_sig = self.tcx.hir().get_if_local(self.def_id).and_then(hir::Node::fn_sig);\n         let is_used_in_input = |def_id| {\n-            fn_sig.map_or(false, |fn_sig| {\n+            fn_sig.is_some_and(|fn_sig| {\n                 fn_sig.decl.inputs.iter().any(|ty| match ty.kind {\n                     hir::TyKind::Path(hir::QPath::Resolved(\n                         None,"}, {"sha": "9761b1d3facabe36016f4c37a962e5b57ca6b81e", "filename": "compiler/rustc_hir_typeck/messages.ftl", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,92 +1,92 @@\n-hir_typeck_field_multiply_specified_in_initializer =\n-    field `{$ident}` specified more than once\n-    .label = used more than once\n-    .previous_use_label = first use of `{$ident}`\n+hir_typeck_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n \n-hir_typeck_functional_record_update_on_non_struct =\n-    functional record update syntax requires a struct\n+hir_typeck_add_return_type_add = try adding a return type\n \n-hir_typeck_return_stmt_outside_of_fn_body =\n-    return statement outside of function body\n-    .encl_body_label = the return is part of this body...\n-    .encl_fn_label = ...not the enclosing function body\n+hir_typeck_add_return_type_missing_here = a return type might be missing here\n \n-hir_typeck_yield_expr_outside_of_generator =\n-    yield expression outside of generator literal\n+hir_typeck_address_of_temporary_taken = cannot take address of a temporary\n+    .label = temporary value\n \n-hir_typeck_struct_expr_non_exhaustive =\n-    cannot create non-exhaustive {$what} using struct expression\n+hir_typeck_arg_mismatch_indeterminate = argument type mismatch was detected, but rustc had trouble determining where\n+    .note = we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new\n \n-hir_typeck_method_call_on_unknown_type =\n-    the type of this value must be known to call a method on a raw pointer on it\n+hir_typeck_candidate_trait_note = `{$trait_name}` defines an item `{$item_name}`{$action_or_ty ->\n+    [NONE] {\"\"}\n+    [implement] , perhaps you need to implement it\n+    *[other] , perhaps you need to restrict type parameter `{$action_or_ty}` with it\n+}\n \n-hir_typeck_address_of_temporary_taken = cannot take address of a temporary\n-    .label = temporary value\n+hir_typeck_const_select_must_be_const = this argument must be a `const fn`\n+    .help = consult the documentation on `const_eval_select` for more information\n \n-hir_typeck_add_return_type_add = try adding a return type\n+hir_typeck_const_select_must_be_fn = this argument must be a function item\n+    .note = expected a function item, found {$ty}\n+    .help = consult the documentation on `const_eval_select` for more information\n \n-hir_typeck_add_return_type_missing_here = a return type might be missing here\n+hir_typeck_convert_to_str = try converting the passed type into a `&str`\n \n hir_typeck_expected_default_return_type = expected `()` because of default return type\n \n hir_typeck_expected_return_type = expected `{$expected}` because of return type\n \n-hir_typeck_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n+hir_typeck_field_multiply_specified_in_initializer =\n+    field `{$ident}` specified more than once\n+    .label = used more than once\n+    .previous_use_label = first use of `{$ident}`\n \n-hir_typeck_add_missing_parentheses_in_range = you must surround the range in parentheses to call its `{$func_name}` function\n+hir_typeck_fru_expr = this expression does not end in a comma...\n+hir_typeck_fru_expr2 = ... so this is interpreted as a `..` range expression, instead of functional record update syntax\n+hir_typeck_fru_note = this expression may have been misinterpreted as a `..` range expression\n+hir_typeck_fru_suggestion =\n+    to set the remaining fields{$expr ->\n+        [NONE]{\"\"}\n+        *[other] {\" \"}from `{$expr}`\n+    }, separate the last named field with a comma\n \n-hir_typeck_lang_start_incorrect_number_params = incorrect number of parameters for the `start` lang item\n-hir_typeck_lang_start_incorrect_number_params_note_expected_count = the `start` lang item should have four parameters, but found {$found_param_count}\n+hir_typeck_functional_record_update_on_non_struct =\n+    functional record update syntax requires a struct\n \n+hir_typeck_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n+hir_typeck_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n hir_typeck_lang_start_expected_sig_note = the `start` lang item should have the signature `fn(fn() -> T, isize, *const *const u8, u8) -> isize`\n \n+hir_typeck_lang_start_incorrect_number_params = incorrect number of parameters for the `start` lang item\n+hir_typeck_lang_start_incorrect_number_params_note_expected_count = the `start` lang item should have four parameters, but found {$found_param_count}\n+\n hir_typeck_lang_start_incorrect_param = parameter {$param_num} of the `start` lang item is incorrect\n     .suggestion = change the type from `{$found_ty}` to `{$expected_ty}`\n \n hir_typeck_lang_start_incorrect_ret_ty = the return type of the `start` lang item is incorrect\n     .suggestion = change the type from `{$found_ty}` to `{$expected_ty}`\n \n-hir_typeck_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n-hir_typeck_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n-hir_typeck_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n-\n-hir_typeck_convert_to_str = try converting the passed type into a `&str`\n+hir_typeck_method_call_on_unknown_type =\n+    the type of this value must be known to call a method on a raw pointer on it\n \n-hir_typeck_op_trait_generic_params = `{$method_name}` must not have any generic parameters\n+hir_typeck_missing_parentheses_in_range = can't call method `{$method_name}` on type `{$ty_str}`\n \n-hir_typeck_fru_note = this expression may have been misinterpreted as a `..` range expression\n-hir_typeck_fru_expr = this expression does not end in a comma...\n-hir_typeck_fru_expr2 = ... so this is interpreted as a `..` range expression, instead of functional record update syntax\n-hir_typeck_fru_suggestion =\n-    to set the remaining fields{$expr ->\n-        [NONE]{\"\"}\n-        *[other] {\" \"}from `{$expr}`\n-    }, separate the last named field with a comma\n+hir_typeck_no_associated_item = no {$item_kind} named `{$item_name}` found for {$ty_prefix} `{$ty_str}`{$trait_missing_method ->\n+    [true] {\"\"}\n+    *[other] {\" \"}in the current scope\n+}\n \n-hir_typeck_const_select_must_be_const = this argument must be a `const fn`\n-    .help = consult the documentation on `const_eval_select` for more information\n+hir_typeck_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n \n-hir_typeck_const_select_must_be_fn = this argument must be a function item\n-    .note = expected a function item, found {$ty}\n-    .help = consult the documentation on `const_eval_select` for more information\n+hir_typeck_op_trait_generic_params = `{$method_name}` must not have any generic parameters\n \n-hir_typeck_union_pat_multiple_fields = union patterns should have exactly one field\n-hir_typeck_union_pat_dotdot = `..` cannot be used in union patterns\n+hir_typeck_return_stmt_outside_of_fn_body =\n+    return statement outside of function body\n+    .encl_body_label = the return is part of this body...\n+    .encl_fn_label = ...not the enclosing function body\n \n-hir_typeck_arg_mismatch_indeterminate = argument type mismatch was detected, but rustc had trouble determining where\n-    .note = we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new\n+hir_typeck_struct_expr_non_exhaustive =\n+    cannot create non-exhaustive {$what} using struct expression\n \n hir_typeck_suggest_boxing_note = for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n \n hir_typeck_suggest_boxing_when_appropriate = store this in the heap by calling `Box::new`\n \n-hir_typeck_no_associated_item = no {$item_kind} named `{$item_name}` found for {$ty_prefix} `{$ty_str}`{$trait_missing_method ->\n-    [true] {\"\"}\n-    *[other] {\" \"}in the current scope\n-}\n+hir_typeck_union_pat_dotdot = `..` cannot be used in union patterns\n \n-hir_typeck_candidate_trait_note = `{$trait_name}` defines an item `{$item_name}`{$action_or_ty ->\n-    [NONE] {\"\"}\n-    [implement] , perhaps you need to implement it\n-    *[other] , perhaps you need to restrict type parameter `{$action_or_ty}` with it\n-}\n+hir_typeck_union_pat_multiple_fields = union patterns should have exactly one field\n+hir_typeck_yield_expr_outside_of_generator =\n+    yield expression outside of generator literal"}, {"sha": "98c683f0200a3edfad24de17995e8406d24cc4ed", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -465,7 +465,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                         .sess\n                         .source_map()\n                         .span_to_snippet(self.expr_span)\n-                        .map_or(false, |snip| snip.starts_with('('));\n+                        .is_ok_and(|snip| snip.starts_with('('));\n \n                     // Very crude check to see whether the expression must be wrapped\n                     // in parentheses for the suggestion to work (issue #89497)."}, {"sha": "bfabd44bb579227c442d31e82942162dc4d216e8", "filename": "compiler/rustc_hir_typeck/src/check.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcheck.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -32,6 +32,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n     fn_def_id: LocalDefId,\n     body: &'tcx hir::Body<'tcx>,\n     can_be_generator: Option<hir::Movability>,\n+    params_can_be_unsized: bool,\n ) -> Option<GeneratorTypes<'tcx>> {\n     let fn_id = fcx.tcx.hir().local_def_id_to_hir_id(fn_def_id);\n \n@@ -94,7 +95,7 @@ pub(super) fn check_fn<'a, 'tcx>(\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n         // for simple cases like `fn foo(x: Trait)`,\n         // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if param.pat.simple_ident().is_none() && !tcx.features().unsized_fn_params {\n+        if param.pat.simple_ident().is_none() && !params_can_be_unsized {\n             fcx.require_type_is_sized(param_ty, param.pat.span, traits::SizedArgumentType(ty_span));\n         }\n \n@@ -103,24 +104,8 @@ pub(super) fn check_fn<'a, 'tcx>(\n \n     fcx.typeck_results.borrow_mut().liberated_fn_sigs_mut().insert(fn_id, fn_sig);\n \n-    if let ty::Dynamic(_, _, ty::Dyn) = declared_ret_ty.kind() {\n-        // FIXME: We need to verify that the return type is `Sized` after the return expression has\n-        // been evaluated so that we have types available for all the nodes being returned, but that\n-        // requires the coerced evaluated type to be stored. Moving `check_return_expr` before this\n-        // causes unsized errors caused by the `declared_ret_ty` to point at the return expression,\n-        // while keeping the current ordering we will ignore the tail expression's type because we\n-        // don't know it yet. We can't do `check_expr_kind` while keeping `check_return_expr`\n-        // because we will trigger \"unreachable expression\" lints unconditionally.\n-        // Because of all of this, we perform a crude check to know whether the simplest `!Sized`\n-        // case that a newcomer might make, returning a bare trait, and in that case we populate\n-        // the tail expression's type so that the suggestion will be correct, but ignore all other\n-        // possible cases.\n-        fcx.check_expr(&body.value);\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-    } else {\n-        fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n-        fcx.check_return_expr(&body.value, false);\n-    }\n+    fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n+    fcx.check_return_expr(&body.value, false);\n \n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator."}, {"sha": "9659a0ec13d4029324bd61e909b180622db7a2d6", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -89,6 +89,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expr_def_id,\n             body,\n             closure.movability,\n+            // Closure \"rust-call\" ABI doesn't support unsized params\n+            false,\n         );\n \n         let parent_substs = InternalSubsts::identity_for_item("}, {"sha": "08c4082e885d9109f2a51b23a7e50aee405ebf5c", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1814,7 +1814,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             .span_to_snippet(return_sp)\n             .unwrap_or_else(|_| \"dyn Trait\".to_string());\n         let mut snippet_iter = snippet.split_whitespace();\n-        let has_impl = snippet_iter.next().map_or(false, |s| s == \"impl\");\n+        let has_impl = snippet_iter.next().is_some_and(|s| s == \"impl\");\n         // Only suggest `Box<dyn Trait>` if `Trait` in `impl Trait` is object safe.\n         let mut is_object_safe = false;\n         if let hir::FnRetTy::Return(ty) = fn_output\n@@ -1834,7 +1834,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     bound\n                         .trait_ref()\n                         .and_then(|t| t.trait_def_id())\n-                        .map_or(false, |def_id| {\n+                        .is_some_and(|def_id| {\n                             fcx.tcx.check_is_object_safe(def_id)\n                         })\n                 })"}, {"sha": "b50630e636b2ea2b6588e2a532564bfd8dfc3be2", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1748,8 +1748,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             |err: &mut Diagnostic,\n              found_to_exp_is_fallible: bool,\n              exp_to_found_is_fallible: bool| {\n-                let exp_is_lhs =\n-                    expected_ty_expr.map(|e| self.tcx.hir().is_lhs(e.hir_id)).unwrap_or(false);\n+                let exp_is_lhs = expected_ty_expr.is_some_and(|e| self.tcx.hir().is_lhs(e.hir_id));\n \n                 if exp_is_lhs {\n                     return;"}, {"sha": "19ff77d8349aaba921b6df447d9bb2ac4dce3c3c", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -497,7 +497,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .borrow()\n                 .adjustments()\n                 .get(base.hir_id)\n-                .map_or(false, |x| x.iter().any(|adj| matches!(adj.kind, Adjust::Deref(_))))\n+                .is_some_and(|x| x.iter().any(|adj| matches!(adj.kind, Adjust::Deref(_))))\n         });\n         if !is_named {\n             self.tcx.sess.emit_err(AddressOfTemporaryTaken { span: oprnd.span });"}, {"sha": "e14e8ac2ce0007fe4ff53c2f83cdedebcfc2f1cb", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -438,12 +438,19 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                         // to borrow discr.\n                         needs_to_be_read = true;\n                     }\n-                    PatKind::Or(_)\n-                    | PatKind::Box(_)\n-                    | PatKind::Slice(..)\n-                    | PatKind::Ref(..)\n-                    | PatKind::Wild => {\n-                        // If the PatKind is Or, Box, Slice or Ref, the decision is made later\n+                    PatKind::Slice(lhs, wild, rhs) => {\n+                        // We don't need to test the length if the pattern is `[..]`\n+                        if matches!((lhs, wild, rhs), (&[], Some(_), &[]))\n+                            // Arrays have a statically known size, so\n+                            // there is no need to read their length\n+                            || discr_place.place.base_ty.is_array()\n+                        {\n+                        } else {\n+                            needs_to_be_read = true;\n+                        }\n+                    }\n+                    PatKind::Or(_) | PatKind::Box(_) | PatKind::Ref(..) | PatKind::Wild => {\n+                        // If the PatKind is Or, Box, or Ref, the decision is made later\n                         // as these patterns contains subpatterns\n                         // If the PatKind is Wild, the decision is made based on the other patterns being\n                         // examined"}, {"sha": "2fdcd09b9a2f46893b1b5c8c59965d2768d28daf", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -35,7 +35,9 @@ use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n use rustc_target::abi::FieldIdx;\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt as _;\n-use rustc_trait_selection::traits::{self, NormalizeExt, ObligationCauseCode, ObligationCtxt};\n+use rustc_trait_selection::traits::{\n+    self, NormalizeExt, ObligationCauseCode, ObligationCtxt, StructurallyNormalizeExt,\n+};\n \n use std::collections::hash_map::Entry;\n use std::slice;\n@@ -1015,23 +1017,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .typeck_results\n             .borrow()\n             .expr_ty_adjusted_opt(rcvr)\n-            .and_then(|ty| expected.map(|expected_ty| expected_ty.peel_refs() == ty.peel_refs()))\n-            .unwrap_or(false);\n+            .zip(expected)\n+            .is_some_and(|(ty, expected_ty)| expected_ty.peel_refs() == ty.peel_refs());\n \n         let prev_call_mutates_and_returns_unit = || {\n             self.typeck_results\n                 .borrow()\n                 .type_dependent_def_id(expr.hir_id)\n                 .map(|def_id| self.tcx.fn_sig(def_id).skip_binder().skip_binder())\n                 .and_then(|sig| sig.inputs_and_output.split_last())\n-                .map(|(output, inputs)| {\n+                .is_some_and(|(output, inputs)| {\n                     output.is_unit()\n                         && inputs\n                             .get(0)\n                             .and_then(|self_ty| self_ty.ref_mutability())\n-                            .map_or(false, rustc_ast::Mutability::is_mut)\n+                            .is_some_and(rustc_ast::Mutability::is_mut)\n                 })\n-                .unwrap_or(false)\n         };\n \n         if !(rcvr_has_the_expected_type || prev_call_mutates_and_returns_unit()) {\n@@ -1198,10 +1199,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let has_self = path_segs\n-            .last()\n-            .map(|PathSeg(def_id, _)| tcx.generics_of(*def_id).has_self)\n-            .unwrap_or(false);\n+        let has_self =\n+            path_segs.last().is_some_and(|PathSeg(def_id, _)| tcx.generics_of(*def_id).has_self);\n \n         let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n             let ty = self.handle_raw_ty(span, tcx.at(span).type_of(impl_def_id).subst_identity());\n@@ -1460,10 +1459,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     /// Resolves `typ` by a single level if `typ` is a type variable.\n+    ///\n+    /// When the new solver is enabled, this will also attempt to normalize\n+    /// the type if it's a projection (note that it will not deeply normalize\n+    /// projections within the type, just the outermost layer of the type).\n+    ///\n     /// If no resolution is possible, then an error is reported.\n     /// Numeric inference variables may be left unresolved.\n     pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let ty = self.resolve_vars_with_obligations(ty);\n+        let mut ty = self.resolve_vars_with_obligations(ty);\n+\n+        if self.tcx.trait_solver_next()\n+            && let ty::Alias(ty::Projection, _) = ty.kind()\n+        {\n+            match self\n+                .at(&self.misc(sp), self.param_env)\n+                .structurally_normalize(ty, &mut **self.fulfillment_cx.borrow_mut())\n+            {\n+                Ok(normalized_ty) => {\n+                    ty = normalized_ty;\n+                },\n+                Err(errors) => {\n+                    let guar = self.err_ctxt().report_fulfillment_errors(&errors);\n+                    return self.tcx.ty_error(guar);\n+                }\n+            }\n+        }\n+\n         if !ty.is_ty_var() {\n             ty\n         } else {"}, {"sha": "72c42f8e78952a710b9113b36c1d772291a5ea29", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -876,7 +876,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut errors = errors.into_iter().peekable();\n         let mut only_extras_so_far = errors\n             .peek()\n-            .map_or(false, |first| matches!(first, Error::Extra(arg_idx) if arg_idx.index() == 0));\n+            .is_some_and(|first| matches!(first, Error::Extra(arg_idx) if arg_idx.index() == 0));\n         let mut suggestions = vec![];\n         while let Some(error) = errors.next() {\n             only_extras_so_far &= matches!(error, Error::Extra(_));"}, {"sha": "ecafbd668e22de207d8d3dbf78121bafb72949f1", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -193,7 +193,7 @@ impl DropRanges {\n             .get(&TrackedValue::Temporary(hir_id))\n             .or(self.tracked_value_map.get(&TrackedValue::Variable(hir_id)))\n             .cloned()\n-            .map_or(false, |tracked_value_id| {\n+            .is_some_and(|tracked_value_id| {\n                 self.expect_node(location.into()).drop_state.contains(tracked_value_id)\n             })\n     }"}, {"sha": "294c3bb78a5ba9524f65a92512fc7d33ff571927", "filename": "compiler/rustc_hir_typeck/src/inherited.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Finherited.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -4,7 +4,8 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::HirIdMap;\n-use rustc_infer::infer::{DefiningAnchor, InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::visit::TypeVisitableExt;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::def_id::LocalDefIdMap;\n@@ -130,7 +131,7 @@ impl<'tcx> Inherited<'tcx> {\n         // (*) binder skipped\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(tpred)) = obligation.predicate.kind().skip_binder()\n             && let Some(ty) = self.shallow_resolve(tpred.self_ty()).ty_vid().map(|t| self.root_var(t))\n-            && self.tcx.lang_items().sized_trait().map_or(false, |st| st != tpred.trait_ref.def_id)\n+            && self.tcx.lang_items().sized_trait().is_some_and(|st| st != tpred.trait_ref.def_id)\n         {\n             let new_self_ty = self.tcx.types.unit;\n "}, {"sha": "b97b55d8f7ee824e50327ff9ce8f7e9bfebc9020", "filename": "compiler/rustc_hir_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -212,7 +212,7 @@ fn typeck_with_fallback<'tcx>(\n         let fn_sig = tcx.liberate_late_bound_regions(def_id.to_def_id(), fn_sig);\n         let fn_sig = fcx.normalize(body.value.span, fn_sig);\n \n-        check_fn(&mut fcx, fn_sig, decl, def_id, body, None);\n+        check_fn(&mut fcx, fn_sig, decl, def_id, body, None, tcx.features().unsized_fn_params);\n     } else {\n         let expected_type = if let Some(&hir::Ty { kind: hir::TyKind::Infer, span, .. }) = body_ty {\n             Some(fcx.next_ty_var(TypeVariableOrigin {"}, {"sha": "78171e0b20e8cc2cf11f303830fc567954d661f1", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -411,7 +411,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n \n             Res::Local(var_id) => {\n-                if self.upvars.map_or(false, |upvars| upvars.contains_key(&var_id)) {\n+                if self.upvars.is_some_and(|upvars| upvars.contains_key(&var_id)) {\n                     self.cat_upvar(hir_id, var_id)\n                 } else {\n                     Ok(PlaceWithHirId::new(hir_id, expr_ty, PlaceBase::Local(var_id), Vec::new()))"}, {"sha": "98529b66602faa30df3f4bd6a883ab179386a961", "filename": "compiler/rustc_hir_typeck/src/method/confirm.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fconfirm.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -471,7 +471,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             self_ty, method_self_ty, self.span, pick\n         );\n         let cause = self.cause(\n-            self.span,\n+            self.self_expr.span,\n             ObligationCauseCode::UnifyReceiver(Box::new(UnifyReceiverContext {\n                 assoc_item: pick.item,\n                 param_env: self.param_env,\n@@ -482,13 +482,22 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n             }\n-            Err(_) => {\n-                span_bug!(\n-                    self.span,\n-                    \"{} was a subtype of {} but now is not?\",\n-                    self_ty,\n-                    method_self_ty\n-                );\n+            Err(terr) => {\n+                // FIXME(arbitrary_self_types): We probably should limit the\n+                // situations where this can occur by adding additional restrictions\n+                // to the feature, like the self type can't reference method substs.\n+                if self.tcx.features().arbitrary_self_types {\n+                    self.err_ctxt()\n+                        .report_mismatched_types(&cause, method_self_ty, self_ty, terr)\n+                        .emit();\n+                } else {\n+                    span_bug!(\n+                        self.span,\n+                        \"{} was a subtype of {} but now is not?\",\n+                        self_ty,\n+                        method_self_ty\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "ba21edea30b1cb5cffeb6b3af3706c11f9ef1814", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1194,7 +1194,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     pick.autoderefs += 1;\n                     pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::Autoref {\n                         mutbl,\n-                        unsize: pick.autoref_or_ptr_adjustment.map_or(false, |a| a.get_unsize()),\n+                        unsize: pick.autoref_or_ptr_adjustment.is_some_and(|a| a.get_unsize()),\n                     })\n                 }\n "}, {"sha": "9ee967dc7a97ef14ec1e6f9bd7d4f1ea18768b76", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -356,7 +356,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let is_write = sugg_span.ctxt().outer_expn_data().macro_def_id.map_or(false, |def_id| {\n+        let is_write = sugg_span.ctxt().outer_expn_data().macro_def_id.is_some_and(|def_id| {\n             tcx.is_diagnostic_item(sym::write_macro, def_id)\n                 || tcx.is_diagnostic_item(sym::writeln_macro, def_id)\n         }) && item_name.name == Symbol::intern(\"write_fmt\");\n@@ -473,6 +473,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut custom_span_label = false;\n \n         let static_candidates = &mut no_match_data.static_candidates;\n+\n+        // `static_candidates` may have same candidates appended by\n+        // inherent and extension, which may result in incorrect\n+        // diagnostic.\n+        static_candidates.dedup();\n+\n         if !static_candidates.is_empty() {\n             err.note(\n                 \"found the following associated functions; to be used as methods, \\\n@@ -1522,7 +1528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n                     let span_included = match parent_expr.kind {\n                         hir::ExprKind::Struct(_, eps, _) => {\n-                            eps.len() > 0 && eps.last().map_or(false, |ep| ep.span.contains(span))\n+                            eps.len() > 0 && eps.last().is_some_and(|ep| ep.span.contains(span))\n                         }\n                         // `..=` desugars into `::std::ops::RangeInclusive::new(...)`.\n                         hir::ExprKind::Call(ref func, ..) => func.span.contains(span),\n@@ -1781,7 +1787,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 ProbeScope::TraitsInScope,\n                                 return_type,\n                             )\n-                            .map_or(false, |pick| {\n+                            .is_ok_and(|pick| {\n                                 !never_mention_traits\n                                     .iter()\n                                     .flatten()\n@@ -2468,7 +2474,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // implement the `AsRef` trait.\n                         let skip = skippable.contains(&did)\n                             || ((\"Pin::new\" == *pre) && (sym::as_ref == item_name.name))\n-                            || inputs_len.map_or(false, |inputs_len| pick.item.kind == ty::AssocKind::Fn && self.tcx.fn_sig(pick.item.def_id).skip_binder().skip_binder().inputs().len() != inputs_len);\n+                            || inputs_len.is_some_and(|inputs_len| pick.item.kind == ty::AssocKind::Fn && self.tcx.fn_sig(pick.item.def_id).skip_binder().skip_binder().inputs().len() != inputs_len);\n                         // Make sure the method is defined for the *actual* receiver: we don't\n                         // want to treat `Box<Self>` as a receiver if it only works because of\n                         // an autoderef to `&self`\n@@ -2755,7 +2761,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let imp = self.tcx.impl_trait_ref(imp_did).unwrap().subst_identity();\n                             let imp_simp =\n                                 simplify_type(self.tcx, imp.self_ty(), TreatParams::ForLookup);\n-                            imp_simp.map_or(false, |s| s == simp_rcvr_ty)\n+                            imp_simp.is_some_and(|s| s == simp_rcvr_ty)\n                         })\n                     {\n                         explicitly_negative.push(candidate);\n@@ -2893,7 +2899,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match ty.kind() {\n                 ty::Adt(def, _) => def.did().is_local(),\n                 ty::Foreign(did) => did.is_local(),\n-                ty::Dynamic(tr, ..) => tr.principal().map_or(false, |d| d.def_id().is_local()),\n+                ty::Dynamic(tr, ..) => tr.principal().is_some_and(|d| d.def_id().is_local()),\n                 ty::Param(_) => true,\n \n                 // Everything else (primitive types, etc.) is effectively"}, {"sha": "b8bf2b6912039bfd4ea217dab1b18289494d9ea4", "filename": "compiler/rustc_hir_typeck/src/op.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fop.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -549,9 +549,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let to_owned_msg = \"create an owned `String` from a string reference\";\n \n         let string_type = self.tcx.lang_items().string();\n-        let is_std_string = |ty: Ty<'tcx>| {\n-            ty.ty_adt_def().map_or(false, |ty_def| Some(ty_def.did()) == string_type)\n-        };\n+        let is_std_string =\n+            |ty: Ty<'tcx>| ty.ty_adt_def().is_some_and(|ty_def| Some(ty_def.did()) == string_type);\n \n         match (lhs_ty.kind(), rhs_ty.kind()) {\n             (&Ref(_, l_ty, _), &Ref(_, r_ty, _)) // &str or &String + &str, &String or &&str\n@@ -760,8 +759,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             span,\n             traits::BinOp {\n                 rhs_span: opt_rhs_expr.map(|expr| expr.span),\n-                is_lit: opt_rhs_expr\n-                    .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n+                is_lit: opt_rhs_expr.is_some_and(|expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n                 output_ty: expected.only_has_type(self),\n             },\n         );"}, {"sha": "e2b1dc007ba6d0e2b270986c8895a25fdb0a1a2b", "filename": "compiler/rustc_hir_typeck/src/place_op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fplace_op.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -329,7 +329,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // If this is a union field, also throw an error for `DerefMut` of `ManuallyDrop` (see RFC 2514).\n                         // This helps avoid accidental drops.\n                         if inside_union\n-                            && source.ty_adt_def().map_or(false, |adt| adt.is_manually_drop())\n+                            && source.ty_adt_def().is_some_and(|adt| adt.is_manually_drop())\n                         {\n                             let mut err = self.tcx.sess.struct_span_err(\n                                 expr.span,"}, {"sha": "9458099f56ff97600be27412c3c308b79547e717", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -972,15 +972,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut obligations_should_hold = Vec::new();\n         // Checks if a root variable implements any of the auto traits\n         for check_trait in auto_traits_def_id.iter() {\n-            obligations_should_hold.push(\n-                check_trait\n-                    .map(|check_trait| {\n-                        self.infcx\n-                            .type_implements_trait(check_trait, [ty], self.param_env)\n-                            .must_apply_modulo_regions()\n-                    })\n-                    .unwrap_or(false),\n-            );\n+            obligations_should_hold.push(check_trait.is_some_and(|check_trait| {\n+                self.infcx\n+                    .type_implements_trait(check_trait, [ty], self.param_env)\n+                    .must_apply_modulo_regions()\n+            }));\n         }\n \n         let mut problematic_captures = FxHashMap::default();\n@@ -996,15 +992,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // Checks if a capture implements any of the auto traits\n             let mut obligations_holds_for_capture = Vec::new();\n             for check_trait in auto_traits_def_id.iter() {\n-                obligations_holds_for_capture.push(\n-                    check_trait\n-                        .map(|check_trait| {\n-                            self.infcx\n-                                .type_implements_trait(check_trait, [ty], self.param_env)\n-                                .must_apply_modulo_regions()\n-                        })\n-                        .unwrap_or(false),\n-                );\n+                obligations_holds_for_capture.push(check_trait.is_some_and(|check_trait| {\n+                    self.infcx\n+                        .type_implements_trait(check_trait, [ty], self.param_env)\n+                        .must_apply_modulo_regions()\n+                }));\n             }\n \n             let mut capture_problems = FxHashSet::default();"}, {"sha": "0f21fc1e662380d506c248a8290fdc474c7f52a1", "filename": "compiler/rustc_hir_typeck/src/writeback.rs", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fwriteback.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -5,11 +5,10 @@\n use crate::FnCtxt;\n use hir::def_id::LocalDefId;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::{ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n-use rustc_infer::infer::InferCtxt;\n use rustc_middle::hir::place::Place as HirPlace;\n use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, PointerCast};\n@@ -83,10 +82,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         wbcx.typeck_results.treat_byte_string_as_slice =\n             mem::take(&mut self.typeck_results.borrow_mut().treat_byte_string_as_slice);\n \n-        if let Some(e) = self.tainted_by_errors() {\n-            wbcx.typeck_results.tainted_by_errors = Some(e);\n-        }\n-\n         debug!(\"writeback: typeck results for {:?} are {:#?}\", item_def_id, wbcx.typeck_results);\n \n         self.tcx.arena.alloc(wbcx.typeck_results)\n@@ -119,12 +114,21 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     ) -> WritebackCx<'cx, 'tcx> {\n         let owner = body.id().hir_id.owner;\n \n-        WritebackCx {\n+        let mut wbcx = WritebackCx {\n             fcx,\n             typeck_results: ty::TypeckResults::new(owner),\n             body,\n             rustc_dump_user_substs,\n+        };\n+\n+        // HACK: We specifically don't want the (opaque) error from tainting our\n+        // inference context. That'll prevent us from doing opaque type inference\n+        // later on in borrowck, which affects diagnostic spans pretty negatively.\n+        if let Some(e) = fcx.tainted_by_errors() {\n+            wbcx.typeck_results.tainted_by_errors = Some(e);\n         }\n+\n+        wbcx\n     }\n \n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -579,13 +583,26 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n                 continue;\n             }\n \n-            let hidden_type = hidden_type.remap_generic_params_to_declaration_params(\n-                opaque_type_key,\n-                self.fcx.infcx.tcx,\n-                true,\n-            );\n-\n-            self.typeck_results.concrete_opaque_types.insert(opaque_type_key.def_id, hidden_type);\n+            let hidden_type =\n+                self.tcx().erase_regions(hidden_type.remap_generic_params_to_declaration_params(\n+                    opaque_type_key,\n+                    self.tcx(),\n+                    true,\n+                ));\n+\n+            if let Some(last_opaque_ty) = self\n+                .typeck_results\n+                .concrete_opaque_types\n+                .insert(opaque_type_key.def_id, hidden_type)\n+                && last_opaque_ty.ty != hidden_type.ty\n+            {\n+                hidden_type\n+                    .report_mismatch(&last_opaque_ty, opaque_type_key.def_id, self.tcx())\n+                    .stash(\n+                        self.tcx().def_span(opaque_type_key.def_id),\n+                        StashKey::OpaqueHiddenTypeMismatch,\n+                    );\n+            }\n         }\n     }\n \n@@ -737,8 +754,7 @@ impl Locatable for hir::HirId {\n /// The Resolver. This is the type folding engine that detects\n /// unresolved types and so forth.\n struct Resolver<'cx, 'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    infcx: &'cx InferCtxt<'tcx>,\n+    fcx: &'cx FnCtxt<'cx, 'tcx>,\n     span: &'cx dyn Locatable,\n     body: &'tcx hir::Body<'tcx>,\n \n@@ -752,18 +768,18 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n         span: &'cx dyn Locatable,\n         body: &'tcx hir::Body<'tcx>,\n     ) -> Resolver<'cx, 'tcx> {\n-        Resolver { tcx: fcx.tcx, infcx: fcx, span, body, replaced_with_error: None }\n+        Resolver { fcx, span, body, replaced_with_error: None }\n     }\n \n     fn report_error(&self, p: impl Into<ty::GenericArg<'tcx>>) -> ErrorGuaranteed {\n-        match self.tcx.sess.has_errors() {\n+        match self.fcx.tcx.sess.has_errors() {\n             Some(e) => e,\n             None => self\n-                .infcx\n+                .fcx\n                 .err_ctxt()\n                 .emit_inference_failure_err(\n-                    self.tcx.hir().body_owner_def_id(self.body.id()),\n-                    self.span.to_span(self.tcx),\n+                    self.fcx.tcx.hir().body_owner_def_id(self.body.id()),\n+                    self.span.to_span(self.fcx.tcx),\n                     p.into(),\n                     E0282,\n                     false,\n@@ -795,40 +811,46 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for EraseEarlyRegions<'tcx> {\n \n impl<'cx, 'tcx> TypeFolder<TyCtxt<'tcx>> for Resolver<'cx, 'tcx> {\n     fn interner(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n+        self.fcx.tcx\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        match self.infcx.fully_resolve(t) {\n+        match self.fcx.fully_resolve(t) {\n+            Ok(t) if self.fcx.tcx.trait_solver_next() => {\n+                // We must normalize erasing regions here, since later lints\n+                // expect that types that show up in the typeck are fully\n+                // normalized.\n+                self.fcx.tcx.try_normalize_erasing_regions(self.fcx.param_env, t).unwrap_or(t)\n+            }\n             Ok(t) => {\n                 // Do not anonymize late-bound regions\n                 // (e.g. keep `for<'a>` named `for<'a>`).\n                 // This allows NLL to generate error messages that\n                 // refer to the higher-ranked lifetime names written by the user.\n-                EraseEarlyRegions { tcx: self.tcx }.fold_ty(t)\n+                EraseEarlyRegions { tcx: self.fcx.tcx }.fold_ty(t)\n             }\n             Err(_) => {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 let e = self.report_error(t);\n                 self.replaced_with_error = Some(e);\n-                self.interner().ty_error(e)\n+                self.fcx.tcx.ty_error(e)\n             }\n         }\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         debug_assert!(!r.is_late_bound(), \"Should not be resolving bound region.\");\n-        self.tcx.lifetimes.re_erased\n+        self.fcx.tcx.lifetimes.re_erased\n     }\n \n     fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n-        match self.infcx.fully_resolve(ct) {\n-            Ok(ct) => self.tcx.erase_regions(ct),\n+        match self.fcx.fully_resolve(ct) {\n+            Ok(ct) => self.fcx.tcx.erase_regions(ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 let e = self.report_error(ct);\n                 self.replaced_with_error = Some(e);\n-                self.interner().const_error(ct.ty(), e)\n+                self.fcx.tcx.const_error(ct.ty(), e)\n             }\n         }\n     }"}, {"sha": "9fa4e0fb27cf1dd66cb85cb94bd4ebd3c166b689", "filename": "compiler/rustc_incremental/messages.ftl", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_incremental%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_incremental%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,118 +1,118 @@\n-incremental_unrecognized_depnode = unrecognized `DepNode` variant: {$name}\n+incremental_assert_loaded =\n+    we asserted that an existing incremental cache directory should be successfully loaded, but it was not\n \n-incremental_missing_depnode = missing `DepNode` variant\n+incremental_assert_not_loaded =\n+    we asserted that the incremental cache should not be loaded, but it was loaded\n \n-incremental_missing_if_this_changed = no `#[rustc_if_this_changed]` annotation detected\n+incremental_assertion_auto =\n+    `except` specified DepNodes that can not be affected for \"{$name}\": \"{$e}\"\n \n-incremental_no_path = no path from `{$source}` to `{$target}`\n+incremental_associated_value_expected = expected an associated value\n \n-incremental_ok = OK\n+incremental_associated_value_expected_for = associated value expected for `{$ident}`\n \n-incremental_unknown_reuse_kind = unknown cgu-reuse-kind `{$kind}` specified\n+incremental_canonicalize_path = incremental compilation: error canonicalizing path `{$path}`: {$err}\n \n-incremental_missing_query_depgraph =\n-    found CGU-reuse attribute but `-Zquery-dep-graph` was not specified\n+incremental_cargo_help_1 =\n+    incremental compilation can be disabled by setting the environment variable CARGO_INCREMENTAL=0 (see https://doc.rust-lang.org/cargo/reference/profiles.html#incremental)\n+incremental_cargo_help_2 =\n+    the entire build directory can be changed to a different filesystem by setting the environment variable CARGO_TARGET_DIR to a different path (see https://doc.rust-lang.org/cargo/reference/config.html#buildtarget-dir)\n \n-incremental_malformed_cgu_name =\n-    found malformed codegen unit name `{$user_path}`. codegen units names must always start with the name of the crate (`{$crate_name}` in this case).\n+incremental_copy_workproduct_to_cache =\n+    error copying object file `{$from}` to incremental directory as `{$to}`: {$err}\n \n-incremental_no_module_named =\n-    no module named `{$user_path}` (mangled: {$cgu_name}). available modules: {$cgu_names}\n+incremental_create_dep_graph = failed to create dependency graph at `{$path}`: {$err}\n \n-incremental_field_associated_value_expected = associated value expected for `{$name}`\n+incremental_create_incr_comp_dir =\n+    could not create incremental compilation {$tag} directory `{$path}`: {$err}\n \n-incremental_no_field = no field `{$name}`\n+incremental_create_lock =\n+    incremental compilation: could not create session directory lock file: {$lock_err}\n+incremental_create_new = failed to create {$name} at `{$path}`: {$err}\n \n-incremental_assertion_auto =\n-    `except` specified DepNodes that can not be affected for \"{$name}\": \"{$e}\"\n+incremental_decode_incr_cache = could not decode incremental cache: {$err}\n \n-incremental_undefined_clean_dirty_assertions_item =\n-    clean/dirty auto-assertions not yet defined for Node::Item.node={$kind}\n+incremental_delete_full = error deleting incremental compilation session directory `{$path}`: {$err}\n \n-incremental_undefined_clean_dirty_assertions =\n-    clean/dirty auto-assertions not yet defined for {$kind}\n+incremental_delete_incompatible =\n+    failed to delete invalidated or incompatible incremental compilation session directory contents `{$path}`: {$err}\n \n-incremental_repeated_depnode_label = dep-node label `{$label}` is repeated\n+incremental_delete_lock =\n+    error deleting lock file for incremental compilation session directory `{$path}`: {$err}\n \n-incremental_unrecognized_depnode_label = dep-node label `{$label}` not recognized\n+incremental_delete_old = unable to delete old {$name} at `{$path}`: {$err}\n \n-incremental_not_dirty = `{$dep_node_str}` should be dirty but is not\n+incremental_delete_partial = failed to delete partly initialized session dir `{$path}`: {$err}\n \n-incremental_not_clean = `{$dep_node_str}` should be clean but is not\n+incremental_delete_workproduct = file-system error deleting outdated file `{$path}`: {$err}\n \n-incremental_not_loaded = `{$dep_node_str}` should have been loaded from disk but it was not\n+incremental_field_associated_value_expected = associated value expected for `{$name}`\n \n-incremental_unknown_item = unknown item `{$name}`\n+incremental_finalize = error finalizing incremental compilation session directory `{$path}`: {$err}\n \n-incremental_no_cfg = no cfg attribute\n+incremental_finalized_gc_failed =\n+    failed to garbage collect finalized incremental compilation session directory `{$path}`: {$err}\n \n-incremental_associated_value_expected_for = associated value expected for `{$ident}`\n+incremental_hard_link_failed =\n+    hard linking files in the incremental compilation cache failed. copying files instead. consider moving the cache directory to a file system which supports hard linking in session dir `{$path}`\n \n-incremental_associated_value_expected = expected an associated value\n+incremental_invalid_gc_failed =\n+    failed to garbage collect invalid incremental compilation session directory `{$path}`: {$err}\n \n-incremental_unchecked_clean = found unchecked `#[rustc_clean]` attribute\n+incremental_load_dep_graph = could not load dep-graph from `{$path}`: {$err}\n \n-incremental_delete_old = unable to delete old {$name} at `{$path}`: {$err}\n+incremental_lock_unsupported =\n+    the filesystem for the incremental path at {$session_dir} does not appear to support locking, consider changing the incremental path to a filesystem that supports locking or disable incremental compilation\n+incremental_malformed_cgu_name =\n+    found malformed codegen unit name `{$user_path}`. codegen units names must always start with the name of the crate (`{$crate_name}` in this case).\n \n-incremental_create_new = failed to create {$name} at `{$path}`: {$err}\n+incremental_missing_depnode = missing `DepNode` variant\n \n-incremental_write_new = failed to write {$name} to `{$path}`: {$err}\n+incremental_missing_if_this_changed = no `#[rustc_if_this_changed]` annotation detected\n \n-incremental_canonicalize_path = incremental compilation: error canonicalizing path `{$path}`: {$err}\n+incremental_missing_query_depgraph =\n+    found CGU-reuse attribute but `-Zquery-dep-graph` was not specified\n \n-incremental_create_incr_comp_dir =\n-    could not create incremental compilation {$tag} directory `{$path}`: {$err}\n+incremental_move_dep_graph = failed to move dependency graph from `{$from}` to `{$to}`: {$err}\n \n-incremental_create_lock =\n-    incremental compilation: could not create session directory lock file: {$lock_err}\n-incremental_lock_unsupported =\n-    the filesystem for the incremental path at {$session_dir} does not appear to support locking, consider changing the incremental path to a filesystem that supports locking or disable incremental compilation\n-incremental_cargo_help_1 =\n-    incremental compilation can be disabled by setting the environment variable CARGO_INCREMENTAL=0 (see https://doc.rust-lang.org/cargo/reference/profiles.html#incremental)\n-incremental_cargo_help_2 =\n-    the entire build directory can be changed to a different filesystem by setting the environment variable CARGO_TARGET_DIR to a different path (see https://doc.rust-lang.org/cargo/reference/config.html#buildtarget-dir)\n+incremental_no_cfg = no cfg attribute\n \n-incremental_delete_lock =\n-    error deleting lock file for incremental compilation session directory `{$path}`: {$err}\n+incremental_no_field = no field `{$name}`\n \n-incremental_hard_link_failed =\n-    hard linking files in the incremental compilation cache failed. copying files instead. consider moving the cache directory to a file system which supports hard linking in session dir `{$path}`\n+incremental_no_module_named =\n+    no module named `{$user_path}` (mangled: {$cgu_name}). available modules: {$cgu_names}\n \n-incremental_delete_partial = failed to delete partly initialized session dir `{$path}`: {$err}\n+incremental_no_path = no path from `{$source}` to `{$target}`\n \n-incremental_delete_full = error deleting incremental compilation session directory `{$path}`: {$err}\n+incremental_not_clean = `{$dep_node_str}` should be clean but is not\n \n-incremental_finalize = error finalizing incremental compilation session directory `{$path}`: {$err}\n+incremental_not_dirty = `{$dep_node_str}` should be dirty but is not\n \n-incremental_invalid_gc_failed =\n-    failed to garbage collect invalid incremental compilation session directory `{$path}`: {$err}\n+incremental_not_loaded = `{$dep_node_str}` should have been loaded from disk but it was not\n \n-incremental_finalized_gc_failed =\n-    failed to garbage collect finalized incremental compilation session directory `{$path}`: {$err}\n+incremental_ok = OK\n+\n+incremental_repeated_depnode_label = dep-node label `{$label}` is repeated\n \n incremental_session_gc_failed =\n     failed to garbage collect incremental compilation session directory `{$path}`: {$err}\n \n-incremental_assert_not_loaded =\n-    we asserted that the incremental cache should not be loaded, but it was loaded\n-\n-incremental_assert_loaded =\n-    we asserted that an existing incremental cache directory should be successfully loaded, but it was not\n+incremental_unchecked_clean = found unchecked `#[rustc_clean]` attribute\n \n-incremental_delete_incompatible =\n-    failed to delete invalidated or incompatible incremental compilation session directory contents `{$path}`: {$err}\n+incremental_undefined_clean_dirty_assertions =\n+    clean/dirty auto-assertions not yet defined for {$kind}\n \n-incremental_load_dep_graph = could not load dep-graph from `{$path}`: {$err}\n+incremental_undefined_clean_dirty_assertions_item =\n+    clean/dirty auto-assertions not yet defined for Node::Item.node={$kind}\n \n-incremental_decode_incr_cache = could not decode incremental cache: {$err}\n+incremental_unknown_item = unknown item `{$name}`\n \n-incremental_write_dep_graph = failed to write dependency graph to `{$path}`: {$err}\n+incremental_unknown_reuse_kind = unknown cgu-reuse-kind `{$kind}` specified\n \n-incremental_move_dep_graph = failed to move dependency graph from `{$from}` to `{$to}`: {$err}\n+incremental_unrecognized_depnode = unrecognized `DepNode` variant: {$name}\n \n-incremental_create_dep_graph = failed to create dependency graph at `{$path}`: {$err}\n+incremental_unrecognized_depnode_label = dep-node label `{$label}` not recognized\n \n-incremental_copy_workproduct_to_cache =\n-    error copying object file `{$from}` to incremental directory as `{$to}`: {$err}\n+incremental_write_dep_graph = failed to write dependency graph to `{$path}`: {$err}\n \n-incremental_delete_workproduct = file-system error deleting outdated file `{$path}`: {$err}\n+incremental_write_new = failed to write {$name} to `{$path}`: {$err}"}, {"sha": "15bc3b4e388dc444ac0b14979cef323d40ea7520", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1544,7 +1544,7 @@ impl<T: Idx> GrowableBitSet<T> {\n     #[inline]\n     pub fn contains(&self, elem: T) -> bool {\n         let (word_index, mask) = word_index_and_mask(elem);\n-        self.bit_set.words.get(word_index).map_or(false, |word| (word & mask) != 0)\n+        self.bit_set.words.get(word_index).is_some_and(|word| (word & mask) != 0)\n     }\n \n     #[inline]\n@@ -1818,7 +1818,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n     pub fn contains(&self, row: R, column: C) -> bool {\n-        self.row(row).map_or(false, |r| r.contains(column))\n+        self.row(row).is_some_and(|r| r.contains(column))\n     }\n \n     /// Adds the bits from row `read` to the bits from row `write`, and"}, {"sha": "d3cf267dc9d79c8894257de1794166cad13ee3ee", "filename": "compiler/rustc_index/src/interval.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_index%2Fsrc%2Finterval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Finterval.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -181,6 +181,30 @@ impl<I: Idx> IntervalSet<I> {\n         self.map.is_empty()\n     }\n \n+    /// Equivalent to `range.iter().find(|i| !self.contains(i))`.\n+    pub fn first_unset_in(&self, range: impl RangeBounds<I> + Clone) -> Option<I> {\n+        let start = inclusive_start(range.clone());\n+        let Some(end) = inclusive_end(self.domain, range) else {\n+            // empty range\n+            return None;\n+        };\n+        if start > end {\n+            return None;\n+        }\n+        let Some(last) = self.map.partition_point(|r| r.0 <= start).checked_sub(1) else {\n+            // All ranges in the map start after the new range's end\n+            return Some(I::new(start as usize));\n+        };\n+        let (_, prev_end) = self.map[last];\n+        if start > prev_end {\n+            Some(I::new(start as usize))\n+        } else if prev_end < end {\n+            Some(I::new(prev_end as usize + 1))\n+        } else {\n+            None\n+        }\n+    }\n+\n     /// Returns the maximum (last) element present in the set from `range`.\n     pub fn last_set_in(&self, range: impl RangeBounds<I> + Clone) -> Option<I> {\n         let start = inclusive_start(range.clone());\n@@ -224,7 +248,7 @@ impl<I: Idx> IntervalSet<I> {\n     fn check_invariants(&self) -> bool {\n         let mut current: Option<u32> = None;\n         for (start, end) in &self.map {\n-            if start > end || current.map_or(false, |x| x + 1 >= *start) {\n+            if start > end || current.is_some_and(|x| x + 1 >= *start) {\n                 return false;\n             }\n             current = Some(*end);\n@@ -297,6 +321,6 @@ impl<R: Idx, C: Step + Idx> SparseIntervalMatrix<R, C> {\n     }\n \n     pub fn contains(&self, row: R, point: C) -> bool {\n-        self.row(row).map_or(false, |r| r.contains(point))\n+        self.row(row).is_some_and(|r| r.contains(point))\n     }\n }"}, {"sha": "f44c4a7c1e33cd317c257e3dbed18b4a9405acfa", "filename": "compiler/rustc_infer/messages.ftl", "status": "modified", "additions": 296, "deletions": 295, "changes": 591, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,285 +1,72 @@\n-infer_opaque_hidden_type =\n-    opaque type's hidden type cannot be another opaque type from the same scope\n-    .label = one of the two opaque types used here has to be outside its defining scope\n-    .opaque_type = opaque type whose hidden type is being assigned\n-    .hidden_type = opaque type being used as hidden type\n-\n-infer_type_annotations_needed = {$source_kind ->\n-    [closure] type annotations needed for the closure `{$source_name}`\n-    [normal] type annotations needed for `{$source_name}`\n-    *[other] type annotations needed\n-}\n-    .label = type must be known at this point\n-\n-infer_label_bad = {$bad_kind ->\n-    *[other] cannot infer type\n-    [more_info] cannot infer {$prefix_kind ->\n-        *[type] type for {$prefix}\n-        [const_with_param] the value of const parameter\n-        [const] the value of the constant\n-    } `{$name}`{$has_parent ->\n-        [true] {\" \"}declared on the {$parent_prefix} `{$parent_name}`\n-        *[false] {\"\"}\n-    }\n-}\n-\n-infer_source_kind_subdiag_let = {$kind ->\n-    [with_pattern] consider giving `{$name}` an explicit type\n-    [closure] consider giving this closure parameter an explicit type\n-    *[other] consider giving this pattern a type\n-}{$x_kind ->\n-    [has_name] , where the {$prefix_kind ->\n-        *[type] type for {$prefix}\n-        [const_with_param] value of const parameter\n-        [const] value of the constant\n-    } `{$arg_name}` is specified\n-    [underscore] , where the placeholders `_` are specified\n-    *[empty] {\"\"}\n-}\n-\n-infer_source_kind_subdiag_generic_label =\n-    cannot infer {$is_type ->\n-    [true] type\n-    *[false] the value\n-    } of the {$is_type ->\n-    [true] type\n-    *[false] const\n-    } {$parent_exists ->\n-    [true] parameter `{$param_name}` declared on the {$parent_prefix} `{$parent_name}`\n-    *[false] parameter {$param_name}\n-    }\n-\n-infer_source_kind_subdiag_generic_suggestion =\n-    consider specifying the generic {$arg_count ->\n-    [one] argument\n-    *[other] arguments\n-    }\n-\n-infer_source_kind_fully_qualified =\n-    try using a fully qualified path to specify the expected types\n-\n-infer_source_kind_closure_return =\n-    try giving this closure an explicit return type\n-\n-# generator_kind  may need to be translated\n-infer_need_type_info_in_generator =\n-    type inside {$generator_kind ->\n-    [async_block] `async` block\n-    [async_closure] `async` closure\n-    [async_fn] `async fn` body\n-    *[generator] generator\n-    } must be known in this context\n-\n-\n-infer_subtype = ...so that the {$requirement ->\n-    [method_compat] method type is compatible with trait\n-    [type_compat] associated type is compatible with trait\n-    [const_compat] const is compatible with trait\n-    [expr_assignable] expression is assignable\n-    [if_else_different] `if` and `else` have incompatible types\n-    [no_else] `if` missing an `else` returns `()`\n-    [fn_main_correct_type] `main` function has the correct type\n-    [fn_start_correct_type] `#[start]` function has the correct type\n-    [intrinsic_correct_type] intrinsic has the correct type\n-    [method_correct_type] method receiver has the correct type\n-    *[other] types are compatible\n-}\n-infer_subtype_2 = ...so that {$requirement ->\n-    [method_compat] method type is compatible with trait\n-    [type_compat] associated type is compatible with trait\n-    [const_compat] const is compatible with trait\n-    [expr_assignable] expression is assignable\n-    [if_else_different] `if` and `else` have incompatible types\n-    [no_else] `if` missing an `else` returns `()`\n-    [fn_main_correct_type] `main` function has the correct type\n-    [fn_start_correct_type] `#[start]` function has the correct type\n-    [intrinsic_correct_type] intrinsic has the correct type\n-    [method_correct_type] method receiver has the correct type\n-    *[other] types are compatible\n-}\n-\n-infer_reborrow = ...so that reference does not outlive borrowed content\n-infer_reborrow_upvar = ...so that closure can access `{$name}`\n-infer_relate_object_bound = ...so that it can be closed over into an object\n-infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n-infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n-    [true] ...\n+infer_actual_impl_expl_but_actually_implemented_for_ty = ...but `{$trait_path}` is actually implemented for the type `{$ty}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n     *[false] {\"\"}\n }\n-infer_relate_param_bound_2 = ...that is required by this bound\n-infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n-infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n-infer_ascribe_user_type_prove_predicate = ...so that the where clause holds\n-\n-infer_nothing = {\"\"}\n-\n-infer_lifetime_mismatch = lifetime mismatch\n-\n-infer_declared_different = this parameter and the return type are declared with different lifetimes...\n-infer_data_returned = ...but data{$label_var1_exists ->\n-    [true] {\" \"}from `{$label_var1}`\n-    *[false] {\"\"}\n-} is returned here\n-\n-infer_data_lifetime_flow = ...but data with one lifetime flows into the other here\n-infer_declared_multiple = this type is declared with multiple lifetimes...\n-infer_types_declared_different = these two types are declared with different lifetimes...\n-infer_data_flows = ...but data{$label_var1_exists ->\n-    [true] {\" \"}from `{$label_var1}`\n-    *[false] -> {\"\"}\n-} flows{$label_var2_exists ->\n-    [true] {\" \"}into `{$label_var2}`\n-    *[false] -> {\"\"}\n-} here\n-\n-infer_lifetime_param_suggestion = consider introducing a named lifetime parameter{$is_impl ->\n-    [true] {\" \"}and update trait if needed\n+infer_actual_impl_expl_but_actually_implements_trait = ...but it actually implements `{$trait_path}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n     *[false] {\"\"}\n }\n-infer_lifetime_param_suggestion_elided = each elided lifetime in input position becomes a distinct lifetime\n-\n-infer_region_explanation = {$pref_kind ->\n-    *[should_not_happen] [{$pref_kind}]\n-    [ref_valid_for] ...the reference is valid for\n-    [content_valid_for] ...but the borrowed content is only valid for\n-    [type_obj_valid_for] object type is valid for\n-    [source_pointer_valid_for] source pointer is only valid for\n-    [type_satisfy] type must satisfy\n-    [type_outlive] type must outlive\n-    [lf_param_instantiated_with] lifetime parameter instantiated with\n-    [lf_param_must_outlive] but lifetime parameter must outlive\n-    [lf_instantiated_with] lifetime instantiated with\n-    [lf_must_outlive] but lifetime must outlive\n-    [pointer_valid_for] the pointer is valid for\n-    [data_valid_for] but the referenced data is only valid for\n-    [empty] {\"\"}\n-}{$pref_kind ->\n-    [empty] {\"\"}\n-    *[other] {\" \"}\n-}{$desc_kind ->\n-    *[should_not_happen] [{$desc_kind}]\n-    [restatic] the static lifetime\n-    [revar] lifetime {$desc_arg}\n-    [as_defined] the lifetime `{$desc_arg}` as defined here\n-    [as_defined_anon] the anonymous lifetime as defined here\n-    [defined_here] the anonymous lifetime defined here\n-    [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n-}{$suff_kind ->\n-    *[should_not_happen] [{$suff_kind}]\n-    [empty]{\"\"}\n-    [continues] ...\n-    [req_by_binding] {\" \"}as required by this binding\n+infer_actual_impl_expl_but_actually_ty_implements = ...but `{$ty}` actually implements `{$trait_path}`{$has_lifetime ->\n+    [true] , for some specific lifetime `'{$lifetime}`\n+    *[false] {\"\"}\n }\n \n-infer_outlives_content = lifetime of reference outlives lifetime of borrowed content...\n-infer_outlives_bound = lifetime of the source pointer does not outlive lifetime bound of the object type\n-infer_fulfill_req_lifetime = the type `{$ty}` does not fulfill the required lifetime\n-infer_lf_bound_not_satisfied = lifetime bound not satisfied\n-infer_borrowed_too_long = a value of type `{$ty}` is borrowed for too long\n-infer_ref_longer_than_data = in type `{$ty}`, reference has a longer lifetime than the data it references\n-\n-infer_mismatched_static_lifetime = incompatible lifetime on type\n-infer_does_not_outlive_static_from_impl = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n-infer_implicit_static_lifetime_note = this has an implicit `'static` lifetime requirement\n-infer_implicit_static_lifetime_suggestion = consider relaxing the implicit `'static` requirement\n-infer_msl_introduces_static = introduces a `'static` lifetime requirement\n-infer_msl_unmet_req = because this has an unmet lifetime requirement\n-infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n-infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement\n-infer_suggest_add_let_for_letchains = consider adding `let`\n-\n-infer_explicit_lifetime_required_with_ident = explicit lifetime required in the type of `{$simple_ident}`\n-    .label = lifetime `{$named}` required\n-\n-infer_explicit_lifetime_required_with_param_type = explicit lifetime required in parameter type\n-    .label = lifetime `{$named}` required\n-\n-infer_explicit_lifetime_required_sugg_with_ident = add explicit lifetime `{$named}` to the type of `{$simple_ident}`\n-\n-infer_explicit_lifetime_required_sugg_with_param_type = add explicit lifetime `{$named}` to type\n-\n-infer_actual_impl_expl_expected_signature_two = {$leading_ellipsis ->\n-    [true] ...\n-    *[false] {\"\"}\n-}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n-infer_actual_impl_expl_expected_signature_any = {$leading_ellipsis ->\n+infer_actual_impl_expl_expected_other_any = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n-infer_actual_impl_expl_expected_signature_some = {$leading_ellipsis ->\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_other_nothing = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{$lifetime_1}`...\n-infer_actual_impl_expl_expected_signature_nothing = {$leading_ellipsis ->\n+}`{$ty_or_sig}` must implement `{$trait_path}`\n+\n+infer_actual_impl_expl_expected_other_some = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`\n-infer_actual_impl_expl_expected_passive_two = {$leading_ellipsis ->\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_other_two = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+}`{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n infer_actual_impl_expl_expected_passive_any = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n }`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_passive_nothing = {$leading_ellipsis ->\n+    [true] ...\n+    *[false] {\"\"}\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`\n infer_actual_impl_expl_expected_passive_some = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n }`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for some specific lifetime `'{$lifetime_1}`...\n-infer_actual_impl_expl_expected_passive_nothing = {$leading_ellipsis ->\n+infer_actual_impl_expl_expected_passive_two = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`\n-infer_actual_impl_expl_expected_other_two = {$leading_ellipsis ->\n+}`{$trait_path}` would have to be implemented for the type `{$ty_or_sig}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_actual_impl_expl_expected_signature_any = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n-infer_actual_impl_expl_expected_other_any = {$leading_ellipsis ->\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_signature_nothing = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$ty_or_sig}` must implement `{$trait_path}`, for any lifetime `'{$lifetime_1}`...\n-infer_actual_impl_expl_expected_other_some = {$leading_ellipsis ->\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`\n+infer_actual_impl_expl_expected_signature_some = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{$lifetime_1}`...\n-infer_actual_impl_expl_expected_other_nothing = {$leading_ellipsis ->\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for some specific lifetime `'{$lifetime_1}`...\n+infer_actual_impl_expl_expected_signature_two = {$leading_ellipsis ->\n     [true] ...\n     *[false] {\"\"}\n-}`{$ty_or_sig}` must implement `{$trait_path}`\n+}closure with signature `{$ty_or_sig}` must implement `{$trait_path}`, for any two lifetimes `'{$lifetime_1}` and `'{$lifetime_2}`...\n+infer_ascribe_user_type_prove_predicate = ...so that the where clause holds\n \n-infer_actual_impl_expl_but_actually_implements_trait = ...but it actually implements `{$trait_path}`{$has_lifetime ->\n-    [true] , for some specific lifetime `'{$lifetime}`\n-    *[false] {\"\"}\n-}\n-infer_actual_impl_expl_but_actually_implemented_for_ty = ...but `{$trait_path}` is actually implemented for the type `{$ty}`{$has_lifetime ->\n-    [true] , for some specific lifetime `'{$lifetime}`\n-    *[false] {\"\"}\n-}\n-infer_actual_impl_expl_but_actually_ty_implements = ...but `{$ty}` actually implements `{$trait_path}`{$has_lifetime ->\n-    [true] , for some specific lifetime `'{$lifetime}`\n-    *[false] {\"\"}\n-}\n-\n-infer_trait_placeholder_mismatch = implementation of `{$trait_def_id}` is not general enough\n-    .label_satisfy = doesn't satisfy where-clause\n-    .label_where = due to a where-clause on `{$def_id}`...\n-    .label_dup = implementation of `{$trait_def_id}` is not general enough\n-\n-infer_trait_impl_diff = `impl` item signature doesn't match `trait` item signature\n-    .found = found `{$found}`\n-    .expected = expected `{$expected}`\n-    .expected_found = expected signature `{$expected}`\n-               {\"   \"}found signature `{$found}`\n-\n-infer_tid_rel_help = verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n-infer_tid_consider_borrowing = consider borrowing this type parameter in the trait\n-infer_tid_param_help = the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n-\n-infer_dtcs_has_lifetime_req_label = this has an implicit `'static` lifetime requirement\n-infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s `'static` requirement\n-infer_dtcs_has_req_note = the used `impl` has a `'static` requirement\n-infer_dtcs_suggestion = consider relaxing the implicit `'static` requirement\n+infer_await_both_futures = consider `await`ing on both `Future`s\n+infer_await_future = consider `await`ing on the `Future`\n+infer_await_note = calling an async function returns a future\n \n+infer_borrowed_too_long = a value of type `{$ty}` is borrowed for too long\n infer_but_calling_introduces = {$has_param_name ->\n     [true] `{$param_name}`\n     *[false] `fn` parameter\n@@ -314,6 +101,77 @@ infer_but_needs_to_satisfy = {$has_param_name ->\n     .used_here = ...is used here...\n     .introduced_by_bound = `'static` lifetime requirement introduced by this bound\n \n+infer_compare_impl_item_obligation = ...so that the definition in impl matches the definition from the trait\n+infer_consider_specifying_length = consider specifying the actual array length\n+infer_data_flows = ...but data{$label_var1_exists ->\n+    [true] {\" \"}from `{$label_var1}`\n+    *[false] -> {\"\"}\n+} flows{$label_var2_exists ->\n+    [true] {\" \"}into `{$label_var2}`\n+    *[false] -> {\"\"}\n+} here\n+\n+infer_data_lifetime_flow = ...but data with one lifetime flows into the other here\n+infer_data_returned = ...but data{$label_var1_exists ->\n+    [true] {\" \"}from `{$label_var1}`\n+    *[false] {\"\"}\n+} is returned here\n+\n+infer_declared_different = this parameter and the return type are declared with different lifetimes...\n+infer_declared_multiple = this type is declared with multiple lifetimes...\n+infer_does_not_outlive_static_from_impl = ...does not necessarily outlive the static lifetime introduced by the compatible `impl`\n+infer_dtcs_has_lifetime_req_label = this has an implicit `'static` lifetime requirement\n+infer_dtcs_has_req_note = the used `impl` has a `'static` requirement\n+infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s `'static` requirement\n+infer_dtcs_suggestion = consider relaxing the implicit `'static` requirement\n+\n+infer_explicit_lifetime_required_sugg_with_ident = add explicit lifetime `{$named}` to the type of `{$simple_ident}`\n+\n+infer_explicit_lifetime_required_sugg_with_param_type = add explicit lifetime `{$named}` to type\n+\n+infer_explicit_lifetime_required_with_ident = explicit lifetime required in the type of `{$simple_ident}`\n+    .label = lifetime `{$named}` required\n+\n+infer_explicit_lifetime_required_with_param_type = explicit lifetime required in parameter type\n+    .label = lifetime `{$named}` required\n+\n+infer_fn_consider_casting = consider casting the fn item to a fn pointer: `{$casting}`\n+\n+infer_fn_uniq_types = different fn items have unique types, even if their signatures are the same\n+infer_fps_cast = consider casting to a fn pointer\n+infer_fps_cast_both = consider casting both fn items to fn pointers using `as {$expected_sig}`\n+\n+infer_fps_items_are_distinct = fn items are distinct from fn pointers\n+infer_fps_remove_ref = consider removing the reference\n+infer_fps_use_ref = consider using a reference\n+infer_fulfill_req_lifetime = the type `{$ty}` does not fulfill the required lifetime\n+infer_implicit_static_lifetime_note = this has an implicit `'static` lifetime requirement\n+infer_implicit_static_lifetime_suggestion = consider relaxing the implicit `'static` requirement\n+infer_label_bad = {$bad_kind ->\n+    *[other] cannot infer type\n+    [more_info] cannot infer {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] the value of const parameter\n+        [const] the value of the constant\n+    } `{$name}`{$has_parent ->\n+        [true] {\" \"}declared on the {$parent_prefix} `{$parent_name}`\n+        *[false] {\"\"}\n+    }\n+}\n+\n+infer_lf_bound_not_satisfied = lifetime bound not satisfied\n+infer_lifetime_mismatch = lifetime mismatch\n+\n+infer_lifetime_param_suggestion = consider introducing a named lifetime parameter{$is_impl ->\n+    [true] {\" \"}and update trait if needed\n+    *[false] {\"\"}\n+}\n+infer_lifetime_param_suggestion_elided = each elided lifetime in input position becomes a distinct lifetime\n+\n+infer_meant_byte_literal = if you meant to write a byte literal, prefix with `b`\n+infer_meant_char_literal = if you meant to write a `char` literal, use single quotes\n+infer_meant_str_literal = if you meant to write a `str` literal, use double quotes\n+infer_mismatched_static_lifetime = incompatible lifetime on type\n infer_more_targeted = {$has_param_name ->\n     [true] `{$param_name}`\n     *[false] `fn` parameter\n@@ -322,72 +180,215 @@ infer_more_targeted = {$has_param_name ->\n     *[false] an anonymous lifetime `'_`\n } but calling `{$ident}` introduces an implicit `'static` lifetime requirement\n \n-infer_ril_introduced_here = `'static` requirement introduced here\n-infer_ril_introduced_by = requirement introduced by this return type\n-infer_ril_because_of = because of this returned expression\n-infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type\n+infer_msl_introduces_static = introduces a `'static` lifetime requirement\n+infer_msl_trait_note = this has an implicit `'static` lifetime requirement\n+infer_msl_trait_sugg = consider relaxing the implicit `'static` requirement\n+infer_msl_unmet_req = because this has an unmet lifetime requirement\n+infer_need_type_info_in_generator =\n+    type inside {$generator_kind ->\n+    [async_block] `async` block\n+    [async_closure] `async` closure\n+    [async_fn] `async fn` body\n+    *[generator] generator\n+    } must be known in this context\n \n-infer_where_remove = remove the `where` clause\n-infer_where_copy_predicates = copy the `where` clause predicates from the trait\n \n-infer_srs_remove_and_box = consider removing this semicolon and boxing the expressions\n-infer_srs_remove = consider removing this semicolon\n-infer_srs_add = consider returning the local binding `{$ident}`\n-infer_srs_add_one = consider returning one of these bindings\n+infer_nothing = {\"\"}\n \n-infer_await_both_futures = consider `await`ing on both `Future`s\n-infer_await_future = consider `await`ing on the `Future`\n-infer_await_note = calling an async function returns a future\n+infer_oc_cant_coerce = cannot coerce intrinsics to function pointers\n+infer_oc_closure_selfref = closure/generator type that references itself\n+infer_oc_const_compat = const not compatible with trait\n+infer_oc_fn_main_correct_type = `main` function has wrong type\n+infer_oc_fn_start_correct_type = `#[start]` function has wrong type\n+infer_oc_generic = mismatched types\n+\n+infer_oc_if_else_different = `if` and `else` have incompatible types\n+infer_oc_intrinsic_correct_type = intrinsic has wrong type\n+infer_oc_match_compat = `match` arms have incompatible types\n+infer_oc_method_compat = method not compatible with trait\n+infer_oc_method_correct_type = mismatched `self` parameter type\n+infer_oc_no_diverge = `else` clause of `let...else` does not diverge\n+infer_oc_no_else = `if` may be missing an `else` clause\n+infer_oc_try_compat = `?` operator has incompatible types\n+infer_oc_type_compat = type not compatible with trait\n+infer_opaque_captures_lifetime = hidden type for `{$opaque_ty}` captures lifetime that does not appear in bounds\n+    .label = opaque type defined here\n+\n+infer_opaque_hidden_type =\n+    opaque type's hidden type cannot be another opaque type from the same scope\n+    .label = one of the two opaque types used here has to be outside its defining scope\n+    .opaque_type = opaque type whose hidden type is being assigned\n+    .hidden_type = opaque type being used as hidden type\n \n+infer_outlives_bound = lifetime of the source pointer does not outlive lifetime bound of the object type\n+infer_outlives_content = lifetime of reference outlives lifetime of borrowed content...\n infer_prlf_defined_with_sub = the lifetime `{$sub_symbol}` defined here...\n infer_prlf_defined_without_sub = the lifetime defined here...\n-infer_prlf_must_outlive_with_sup = ...must outlive the lifetime `{$sup_symbol}` defined here\n-infer_prlf_must_outlive_without_sup = ...must outlive the lifetime defined here\n infer_prlf_known_limitation = this is a known limitation that will be removed in the future (see issue #100013 <https://github.com/rust-lang/rust/issues/100013> for more information)\n \n-infer_opaque_captures_lifetime = hidden type for `{$opaque_ty}` captures lifetime that does not appear in bounds\n-    .label = opaque type defined here\n+infer_prlf_must_outlive_with_sup = ...must outlive the lifetime `{$sup_symbol}` defined here\n+infer_prlf_must_outlive_without_sup = ...must outlive the lifetime defined here\n+infer_reborrow = ...so that reference does not outlive borrowed content\n+infer_reborrow_upvar = ...so that closure can access `{$name}`\n+infer_ref_longer_than_data = in type `{$ty}`, reference has a longer lifetime than the data it references\n \n-infer_fps_use_ref = consider using a reference\n-infer_fps_remove_ref = consider removing the reference\n-infer_fps_cast = consider casting to a fn pointer\n-infer_fps_items_are_distinct = fn items are distinct from fn pointers\n-infer_fps_cast_both = consider casting both fn items to fn pointers using `as {$expected_sig}`\n+infer_reference_outlives_referent = ...so that the reference type `{$name}` does not outlive the data it points at\n+infer_region_explanation = {$pref_kind ->\n+    *[should_not_happen] [{$pref_kind}]\n+    [ref_valid_for] ...the reference is valid for\n+    [content_valid_for] ...but the borrowed content is only valid for\n+    [type_obj_valid_for] object type is valid for\n+    [source_pointer_valid_for] source pointer is only valid for\n+    [type_satisfy] type must satisfy\n+    [type_outlive] type must outlive\n+    [lf_param_instantiated_with] lifetime parameter instantiated with\n+    [lf_param_must_outlive] but lifetime parameter must outlive\n+    [lf_instantiated_with] lifetime instantiated with\n+    [lf_must_outlive] but lifetime must outlive\n+    [pointer_valid_for] the pointer is valid for\n+    [data_valid_for] but the referenced data is only valid for\n+    [empty] {\"\"}\n+}{$pref_kind ->\n+    [empty] {\"\"}\n+    *[other] {\" \"}\n+}{$desc_kind ->\n+    *[should_not_happen] [{$desc_kind}]\n+    [restatic] the static lifetime\n+    [revar] lifetime {$desc_arg}\n+    [as_defined] the lifetime `{$desc_arg}` as defined here\n+    [as_defined_anon] the anonymous lifetime as defined here\n+    [defined_here] the anonymous lifetime defined here\n+    [defined_here_reg] the lifetime `{$desc_arg}` as defined here\n+}{$suff_kind ->\n+    *[should_not_happen] [{$suff_kind}]\n+    [empty]{\"\"}\n+    [continues] ...\n+    [req_by_binding] {\" \"}as required by this binding\n+}\n \n-infer_fn_uniq_types = different fn items have unique types, even if their signatures are the same\n-infer_fn_consider_casting = consider casting the fn item to a fn pointer: `{$casting}`\n+infer_relate_object_bound = ...so that it can be closed over into an object\n+infer_relate_param_bound = ...so that the type `{$name}` will meet its required lifetime bounds{$continues ->\n+    [true] ...\n+    *[false] {\"\"}\n+}\n+infer_relate_param_bound_2 = ...that is required by this bound\n+infer_relate_region_param_bound = ...so that the declared lifetime parameter bounds are satisfied\n+infer_ril_because_of = because of this returned expression\n+infer_ril_introduced_by = requirement introduced by this return type\n+infer_ril_introduced_here = `'static` requirement introduced here\n+infer_ril_static_introduced_by = \"`'static` lifetime requirement introduced by the return type\n \n infer_sarwa_option = you can convert from `&Option<T>` to `Option<&T>` using `.as_ref()`\n infer_sarwa_result = you can convert from `&Result<T, E>` to `Result<&T, &E>` using `.as_ref()`\n \n-infer_suggest_accessing_field = you might have meant to use field `{$name}` whose type is `{$ty}`\n+infer_sbfrit_box_return_expr = if you change the return type to expect trait objects, box the returned expressions\n \n infer_sbfrit_change_return_type = you could change the return type to be a boxed trait object\n-infer_sbfrit_box_return_expr = if you change the return type to expect trait objects, box the returned expressions\n+infer_source_kind_closure_return =\n+    try giving this closure an explicit return type\n \n-infer_stp_wrap_one = try wrapping the pattern in `{$variant}`\n+# generator_kind  may need to be translated\n+infer_source_kind_fully_qualified =\n+    try using a fully qualified path to specify the expected types\n+\n+infer_source_kind_subdiag_generic_label =\n+    cannot infer {$is_type ->\n+    [true] type\n+    *[false] the value\n+    } of the {$is_type ->\n+    [true] type\n+    *[false] const\n+    } {$parent_exists ->\n+    [true] parameter `{$param_name}` declared on the {$parent_prefix} `{$parent_name}`\n+    *[false] parameter {$param_name}\n+    }\n+\n+infer_source_kind_subdiag_generic_suggestion =\n+    consider specifying the generic {$arg_count ->\n+    [one] argument\n+    *[other] arguments\n+    }\n+\n+infer_source_kind_subdiag_let = {$kind ->\n+    [with_pattern] consider giving `{$name}` an explicit type\n+    [closure] consider giving this closure parameter an explicit type\n+    *[other] consider giving this pattern a type\n+}{$x_kind ->\n+    [has_name] , where the {$prefix_kind ->\n+        *[type] type for {$prefix}\n+        [const_with_param] value of const parameter\n+        [const] value of the constant\n+    } `{$arg_name}` is specified\n+    [underscore] , where the placeholders `_` are specified\n+    *[empty] {\"\"}\n+}\n+\n+infer_srs_add = consider returning the local binding `{$ident}`\n+infer_srs_add_one = consider returning one of these bindings\n+\n+infer_srs_remove = consider removing this semicolon\n+infer_srs_remove_and_box = consider removing this semicolon and boxing the expressions\n infer_stp_wrap_many = try wrapping the pattern in a variant of `{$path}`\n \n-infer_tuple_trailing_comma = use a trailing comma to create a tuple with one element\n+infer_stp_wrap_one = try wrapping the pattern in `{$variant}`\n+infer_subtype = ...so that the {$requirement ->\n+    [method_compat] method type is compatible with trait\n+    [type_compat] associated type is compatible with trait\n+    [const_compat] const is compatible with trait\n+    [expr_assignable] expression is assignable\n+    [if_else_different] `if` and `else` have incompatible types\n+    [no_else] `if` missing an `else` returns `()`\n+    [fn_main_correct_type] `main` function has the correct type\n+    [fn_start_correct_type] `#[start]` function has the correct type\n+    [intrinsic_correct_type] intrinsic has the correct type\n+    [method_correct_type] method receiver has the correct type\n+    *[other] types are compatible\n+}\n+infer_subtype_2 = ...so that {$requirement ->\n+    [method_compat] method type is compatible with trait\n+    [type_compat] associated type is compatible with trait\n+    [const_compat] const is compatible with trait\n+    [expr_assignable] expression is assignable\n+    [if_else_different] `if` and `else` have incompatible types\n+    [no_else] `if` missing an `else` returns `()`\n+    [fn_main_correct_type] `main` function has the correct type\n+    [fn_start_correct_type] `#[start]` function has the correct type\n+    [intrinsic_correct_type] intrinsic has the correct type\n+    [method_correct_type] method receiver has the correct type\n+    *[other] types are compatible\n+}\n \n-infer_oc_method_compat = method not compatible with trait\n-infer_oc_type_compat = type not compatible with trait\n-infer_oc_const_compat = const not compatible with trait\n-infer_oc_try_compat = `?` operator has incompatible types\n-infer_oc_match_compat = `match` arms have incompatible types\n-infer_oc_if_else_different = `if` and `else` have incompatible types\n-infer_oc_no_else = `if` may be missing an `else` clause\n-infer_oc_no_diverge = `else` clause of `let...else` does not diverge\n-infer_oc_fn_main_correct_type = `main` function has wrong type\n-infer_oc_fn_start_correct_type = `#[start]` function has wrong type\n-infer_oc_intrinsic_correct_type = intrinsic has wrong type\n-infer_oc_method_correct_type = mismatched `self` parameter type\n-infer_oc_closure_selfref = closure/generator type that references itself\n-infer_oc_cant_coerce = cannot coerce intrinsics to function pointers\n-infer_oc_generic = mismatched types\n+infer_suggest_accessing_field = you might have meant to use field `{$name}` whose type is `{$ty}`\n+\n+infer_suggest_add_let_for_letchains = consider adding `let`\n+\n+infer_tid_consider_borrowing = consider borrowing this type parameter in the trait\n+infer_tid_param_help = the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+\n+infer_tid_rel_help = verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n+infer_trait_impl_diff = `impl` item signature doesn't match `trait` item signature\n+    .found = found `{$found}`\n+    .expected = expected `{$expected}`\n+    .expected_found = expected signature `{$expected}`\n+               {\"   \"}found signature `{$found}`\n+\n+infer_trait_placeholder_mismatch = implementation of `{$trait_def_id}` is not general enough\n+    .label_satisfy = doesn't satisfy where-clause\n+    .label_where = due to a where-clause on `{$def_id}`...\n+    .label_dup = implementation of `{$trait_def_id}` is not general enough\n \n-infer_meant_byte_literal = if you meant to write a byte literal, prefix with `b`\n-infer_meant_char_literal = if you meant to write a `char` literal, use single quotes\n-infer_meant_str_literal = if you meant to write a `str` literal, use double quotes\n-infer_consider_specifying_length = consider specifying the actual array length\n infer_try_cannot_convert = `?` operator cannot convert from `{$found}` to `{$expected}`\n+\n+infer_tuple_trailing_comma = use a trailing comma to create a tuple with one element\n+\n+infer_type_annotations_needed = {$source_kind ->\n+    [closure] type annotations needed for the closure `{$source_name}`\n+    [normal] type annotations needed for `{$source_name}`\n+    *[other] type annotations needed\n+}\n+    .label = type must be known at this point\n+\n+infer_types_declared_different = these two types are declared with different lifetimes...\n+infer_where_copy_predicates = copy the `where` clause predicates from the trait\n+\n+infer_where_remove = remove the `where` clause"}, {"sha": "88256c819f4d4a0976fa77aafb047b2b92e9f033", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -15,7 +15,7 @@ use crate::infer::canonical::{\n use crate::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::{DefineOpaqueTypes, InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n-use crate::traits::query::{Fallible, NoSolution};\n+use crate::traits::query::NoSolution;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::traits::{PredicateObligations, TraitEngine, TraitEngineExt};\n use rustc_data_structures::captures::Captures;\n@@ -57,7 +57,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, T>>\n+    ) -> Result<CanonicalQueryResponse<'tcx, T>, NoSolution>\n     where\n         T: Debug + TypeFoldable<TyCtxt<'tcx>>,\n         Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,"}, {"sha": "b6b935de68c8424d73f48d21208f7943c7d7047a", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -113,10 +113,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 bug!()\n             }\n \n-            (_, ty::Alias(AliasKind::Projection | AliasKind::Inherent, _))\n-            | (ty::Alias(AliasKind::Projection | AliasKind::Inherent, _), _)\n-                if self.tcx.trait_solver_next() =>\n-            {\n+            (_, ty::Alias(..)) | (ty::Alias(..), _) if self.tcx.trait_solver_next() => {\n                 relation.register_type_relate_obligation(a, b);\n                 Ok(a)\n             }"}, {"sha": "42dfe4f6bb81258b638aa6fdbbf9fd55f435bc0a", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -104,7 +104,8 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n                 if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n-                    && def_id.is_local() =>\n+                    && def_id.is_local()\n+                    && !self.tcx().trait_solver_next() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "35c05e80badeb7abe6e8a5ce39f666fb18cf0331", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1825,7 +1825,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         s\n                     };\n                     if !(values.expected.is_simple_text() && values.found.is_simple_text())\n-                        || (exp_found.map_or(false, |ef| {\n+                        || (exp_found.is_some_and(|ef| {\n                             // This happens when the type error is a subset of the expectation,\n                             // like when you have two references but one is `usize` and the other\n                             // is `f32`. In those cases we still want to show the `note`. If the\n@@ -1877,7 +1877,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         let exp_found = match terr {\n             // `terr` has more accurate type information than `exp_found` in match expressions.\n             ty::error::TypeError::Sorts(terr)\n-                if exp_found.map_or(false, |ef| terr.found == ef.found) =>\n+                if exp_found.is_some_and(|ef| terr.found == ef.found) =>\n             {\n                 Some(terr)\n             }\n@@ -1961,7 +1961,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                     if let Ok(code) = self.tcx.sess().source_map().span_to_snippet(span)\n                         && let Some(code) = code.strip_prefix('\\'').and_then(|s| s.strip_suffix('\\''))\n                         && !code.starts_with(\"\\\\u\") // forbid all Unicode escapes\n-                        && code.chars().next().map_or(false, |c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n+                        && code.chars().next().is_some_and(|c| c.is_ascii()) // forbids literal Unicode characters beyond ASCII\n                     {\n                         suggestions.push(TypeErrorAdditionalDiags::MeantByteLiteral { span, code: escape_literal(code) })\n                     }\n@@ -2329,7 +2329,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                         .source_map()\n                         .span_to_prev_source(p.span.shrink_to_hi())\n                         .ok()\n-                        .map_or(false, |s| *s.as_bytes().last().unwrap() == b'&')\n+                        .is_some_and(|s| *s.as_bytes().last().unwrap() == b'&')\n                     {\n                         add_lt_suggs\n                             .push(Some("}, {"sha": "f3b2ec4c5e3833599e37160525e9fcf13060717f", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -671,7 +671,7 @@ impl<'tcx> InferSource<'tcx> {\n                 receiver.span.from_expansion()\n             }\n             InferSourceKind::ClosureReturn { data, should_wrap_expr, .. } => {\n-                data.span().from_expansion() || should_wrap_expr.map_or(false, Span::from_expansion)\n+                data.span().from_expansion() || should_wrap_expr.is_some_and(Span::from_expansion)\n             }\n         };\n         source_from_expansion || self.span.from_expansion()\n@@ -984,7 +984,7 @@ impl<'a, 'tcx> FindInferSourceVisitor<'a, 'tcx> {\n     ) -> impl Iterator<Item = InsertableGenericArgs<'tcx>> + 'a {\n         let tcx = self.infcx.tcx;\n         let have_turbofish = path.segments.iter().any(|segment| {\n-            segment.args.map_or(false, |args| args.args.iter().any(|arg| arg.is_ty_or_const()))\n+            segment.args.is_some_and(|args| args.args.iter().any(|arg| arg.is_ty_or_const()))\n         });\n         // The last segment of a path often has `Res::Err` and the\n         // correct `Res` is the one of the whole path."}, {"sha": "7190d33d299b762de93dd83f2694b3e41f82b96c", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -108,9 +108,12 @@ where\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n             &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n         ) if a_def_id == b_def_id => infcx.super_combine_tys(this, a, b),\n+\n         (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n         | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-            if this.define_opaque_types() == DefineOpaqueTypes::Yes && def_id.is_local() =>\n+            if this.define_opaque_types() == DefineOpaqueTypes::Yes\n+                && def_id.is_local()\n+                && !this.tcx().trait_solver_next() =>\n         {\n             this.register_obligations(\n                 infcx"}, {"sha": "cd99fc312129b31257b5ea4df9ac854664245997", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -24,7 +24,7 @@ use rustc_middle::infer::unify_key::{ConstVarValue, ConstVariableValue};\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind, ToType};\n use rustc_middle::mir::interpret::{ErrorHandled, EvalToValTreeResult};\n use rustc_middle::mir::ConstraintCategory;\n-use rustc_middle::traits::select;\n+use rustc_middle::traits::{select, DefiningAnchor};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::BoundVarReplacerDelegate;\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n@@ -231,17 +231,6 @@ impl<'tcx> InferCtxtInner<'tcx> {\n     }\n }\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n-pub enum DefiningAnchor {\n-    /// `DefId` of the item.\n-    Bind(LocalDefId),\n-    /// When opaque types are not resolved, we `Bubble` up, meaning\n-    /// return the opaque/hidden type pair from query, for caller of query to handle it.\n-    Bubble,\n-    /// Used to catch type mismatch errors when handling opaque types.\n-    Error,\n-}\n-\n pub struct InferCtxt<'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n "}, {"sha": "d3fd01b964255bb241f7100d8ac1f89baf87cef0", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -491,16 +491,22 @@ where\n             (\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id: a_def_id, .. }),\n                 &ty::Alias(ty::Opaque, ty::AliasTy { def_id: b_def_id, .. }),\n-            ) if a_def_id == b_def_id => infcx.super_combine_tys(self, a, b).or_else(|err| {\n-                self.tcx().sess.delay_span_bug(\n-                    self.delegate.span(),\n-                    \"failure to relate an opaque to itself should result in an error later on\",\n-                );\n-                if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n-            }),\n+            ) if a_def_id == b_def_id || infcx.tcx.trait_solver_next() => {\n+                infcx.super_combine_tys(self, a, b).or_else(|err| {\n+                    // This behavior is only there for the old solver, the new solver\n+                    // shouldn't ever fail. Instead, it unconditionally emits an\n+                    // alias-relate goal.\n+                    assert!(!self.tcx().trait_solver_next());\n+                    self.tcx().sess.delay_span_bug(\n+                        self.delegate.span(),\n+                        \"failure to relate an opaque to itself should result in an error later on\",\n+                    );\n+                    if a_def_id.is_local() { self.relate_opaques(a, b) } else { Err(err) }\n+                })\n+            }\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n-                if def_id.is_local() =>\n+                if def_id.is_local() && !self.tcx().trait_solver_next() =>\n             {\n                 self.relate_opaques(a, b)\n             }"}, {"sha": "9d5ec228d827bd74eaf5c770b94d69af88e0ce9d", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 60, "deletions": 14, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,14 +1,14 @@\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::{DefineOpaqueTypes, InferResult};\n use crate::errors::OpaqueHiddenTypeDiag;\n-use crate::infer::{DefiningAnchor, InferCtxt, InferOk};\n-use crate::traits;\n+use crate::infer::{InferCtxt, InferOk};\n+use crate::traits::{self, PredicateObligation};\n use hir::def_id::{DefId, LocalDefId};\n use hir::OpaqueTyOrigin;\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n-use rustc_middle::traits::ObligationCause;\n+use rustc_middle::traits::{DefiningAnchor, ObligationCause};\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::fold::BottomUpFolder;\n use rustc_middle::ty::GenericArgKind;\n@@ -48,12 +48,18 @@ impl<'tcx> InferCtxt<'tcx> {\n         span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> InferOk<'tcx, T> {\n+        // We handle opaque types differently in the new solver.\n+        if self.tcx.trait_solver_next() {\n+            return InferOk { value, obligations: vec![] };\n+        }\n+\n         if !value.has_opaque_types() {\n             return InferOk { value, obligations: vec![] };\n         }\n+\n         let mut obligations = vec![];\n         let replace_opaque_type = |def_id: DefId| {\n-            def_id.as_local().map_or(false, |def_id| self.opaque_type_origin(def_id).is_some())\n+            def_id.as_local().is_some_and(|def_id| self.opaque_type_origin(def_id).is_some())\n         };\n         let value = value.fold_with(&mut BottomUpFolder {\n             tcx: self.tcx,\n@@ -521,17 +527,14 @@ impl<'tcx> InferCtxt<'tcx> {\n         origin: hir::OpaqueTyOrigin,\n         a_is_expected: bool,\n     ) -> InferResult<'tcx, ()> {\n-        let tcx = self.tcx;\n-        let OpaqueTypeKey { def_id, substs } = opaque_type_key;\n-\n         // Ideally, we'd get the span where *this specific `ty` came\n         // from*, but right now we just use the span from the overall\n         // value being folded. In simple cases like `-> impl Foo`,\n         // these are the same span, but not in cases like `-> (impl\n         // Foo, impl Bar)`.\n         let span = cause.span;\n         let prev = self.inner.borrow_mut().opaque_types().register(\n-            OpaqueTypeKey { def_id, substs },\n+            opaque_type_key,\n             OpaqueHiddenType { ty: hidden_ty, span },\n             origin,\n         );\n@@ -543,6 +546,49 @@ impl<'tcx> InferCtxt<'tcx> {\n             Vec::new()\n         };\n \n+        self.add_item_bounds_for_hidden_type(\n+            opaque_type_key,\n+            cause,\n+            param_env,\n+            hidden_ty,\n+            &mut obligations,\n+        );\n+\n+        Ok(InferOk { value: (), obligations })\n+    }\n+\n+    /// Registers an opaque's hidden type -- only should be used when the opaque\n+    /// can be defined. For something more fallible -- checks the anchors, tries\n+    /// to unify opaques in both dirs, etc. -- use `InferCtxt::handle_opaque_type`.\n+    pub fn register_hidden_type_in_new_solver(\n+        &self,\n+        opaque_type_key: OpaqueTypeKey<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n+        assert!(self.tcx.trait_solver_next());\n+        let origin = self\n+            .opaque_type_origin(opaque_type_key.def_id)\n+            .expect(\"should be called for defining usages only\");\n+        self.register_hidden_type(\n+            opaque_type_key,\n+            ObligationCause::dummy(),\n+            param_env,\n+            hidden_ty,\n+            origin,\n+            true,\n+        )\n+    }\n+\n+    pub fn add_item_bounds_for_hidden_type(\n+        &self,\n+        OpaqueTypeKey { def_id, substs }: OpaqueTypeKey<'tcx>,\n+        cause: ObligationCause<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        hidden_ty: Ty<'tcx>,\n+        obligations: &mut Vec<PredicateObligation<'tcx>>,\n+    ) {\n+        let tcx = self.tcx;\n         let item_bounds = tcx.explicit_item_bounds(def_id);\n \n         for (predicate, _) in item_bounds.subst_iter_copied(tcx, substs) {\n@@ -555,14 +601,15 @@ impl<'tcx> InferCtxt<'tcx> {\n                     // FIXME(inherent_associated_types): Extend this to support `ty::Inherent`, too.\n                     ty::Alias(ty::Projection, projection_ty)\n                         if !projection_ty.has_escaping_bound_vars()\n-                            && !tcx.is_impl_trait_in_trait(projection_ty.def_id) =>\n+                            && !tcx.is_impl_trait_in_trait(projection_ty.def_id)\n+                            && !tcx.trait_solver_next() =>\n                     {\n                         self.infer_projection(\n                             param_env,\n                             projection_ty,\n                             cause.clone(),\n                             0,\n-                            &mut obligations,\n+                            obligations,\n                         )\n                     }\n                     // Replace all other mentions of the same opaque type with the hidden type,\n@@ -588,10 +635,10 @@ impl<'tcx> InferCtxt<'tcx> {\n                 predicate.kind().skip_binder()\n             {\n                 if projection.term.references_error() {\n-                    // No point on adding these obligations since there's a type error involved.\n-                    return Ok(InferOk { value: (), obligations: vec![] });\n+                    // No point on adding any obligations since there's a type error involved.\n+                    obligations.clear();\n+                    return;\n                 }\n-                trace!(\"{:#?}\", projection.term);\n             }\n             // Require that the predicate holds for the concrete type.\n             debug!(?predicate);\n@@ -602,7 +649,6 @@ impl<'tcx> InferCtxt<'tcx> {\n                 predicate,\n             ));\n         }\n-        Ok(InferOk { value: (), obligations })\n     }\n }\n "}, {"sha": "ceafafb5582cd9d4ccadd13fdeb50fbc3058f023", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -131,7 +131,8 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n             (&ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }), _)\n             | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n                 if self.fields.define_opaque_types == DefineOpaqueTypes::Yes\n-                    && def_id.is_local() =>\n+                    && def_id.is_local()\n+                    && !self.tcx().trait_solver_next() =>\n             {\n                 self.fields.obligations.extend(\n                     infcx"}, {"sha": "be1a75f020b4d2f9f0ebe5434487ef19a02caa3e", "filename": "compiler/rustc_interface/messages.ftl", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_interface%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_interface%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,52 +1,52 @@\n-interface_ferris_identifier =\n-    Ferris cannot be used as an identifier\n-    .suggestion = try using their name instead\n+interface_cant_emit_mir =\n+    could not emit MIR: {$error}\n \n interface_emoji_identifier =\n     identifiers cannot contain emoji: `{$ident}`\n \n-interface_mixed_bin_crate =\n-    cannot mix `bin` crate type with others\n-\n-interface_mixed_proc_macro_crate =\n-    cannot mix `proc-macro` crate type with others\n-\n interface_error_writing_dependencies =\n     error writing dependencies to `{$path}`: {$error}\n \n-interface_input_file_would_be_overwritten =\n-    the input file \"{$path}\" would be overwritten by the generated executable\n+interface_failed_writing_file =\n+    failed to write file {$path}: {$error}\"\n+\n+interface_ferris_identifier =\n+    Ferris cannot be used as an identifier\n+    .suggestion = try using their name instead\n \n interface_generated_file_conflicts_with_directory =\n     the generated executable for the input file \"{$input_path}\" conflicts with the existing directory \"{$dir_path}\"\n \n-interface_temps_dir_error =\n-    failed to find or create the directory specified by `--temps-dir`\n+interface_ignoring_extra_filename = ignoring -C extra-filename flag due to -o flag\n+\n+interface_ignoring_out_dir = ignoring --out-dir flag due to -o flag\n+\n+interface_input_file_would_be_overwritten =\n+    the input file \"{$path}\" would be overwritten by the generated executable\n+\n+interface_mixed_bin_crate =\n+    cannot mix `bin` crate type with others\n+\n+interface_mixed_proc_macro_crate =\n+    cannot mix `proc-macro` crate type with others\n+\n+interface_multiple_output_types_adaption =\n+    due to multiple output types requested, the explicitly specified output file name will be adapted for each output type\n \n interface_out_dir_error =\n     failed to find or create the directory specified by `--out-dir`\n \n-interface_cant_emit_mir =\n-    could not emit MIR: {$error}\n+interface_proc_macro_crate_panic_abort =\n+    building proc macro crate with `panic=abort` may crash the compiler should the proc-macro panic\n \n interface_rustc_error_fatal =\n     fatal error triggered by #[rustc_error]\n \n interface_rustc_error_unexpected_annotation =\n     unexpected annotation used with `#[rustc_error(...)]`!\n \n-interface_failed_writing_file =\n-    failed to write file {$path}: {$error}\"\n-\n-interface_proc_macro_crate_panic_abort =\n-    building proc macro crate with `panic=abort` may crash the compiler should the proc-macro panic\n+interface_temps_dir_error =\n+    failed to find or create the directory specified by `--temps-dir`\n \n interface_unsupported_crate_type_for_target =\n     dropping unsupported crate type `{$crate_type}` for target `{$target_triple}`\n-\n-interface_multiple_output_types_adaption =\n-    due to multiple output types requested, the explicitly specified output file name will be adapted for each output type\n-\n-interface_ignoring_extra_filename = ignoring -C extra-filename flag due to -o flag\n-\n-interface_ignoring_out_dir = ignoring --out-dir flag due to -o flag"}, {"sha": "39d56897999d9be18d710686c46474f945545e0a", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -3,9 +3,9 @@ use crate::util;\n use rustc_ast::token;\n use rustc_ast::{self as ast, LitKind, MetaItemKind};\n use rustc_codegen_ssa::traits::CodegenBackend;\n+use rustc_data_structures::defer;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n-use rustc_data_structures::OnDrop;\n use rustc_errors::registry::Registry;\n use rustc_errors::{ErrorGuaranteed, Handler};\n use rustc_lint::LintStore;\n@@ -325,7 +325,7 @@ pub fn run_compiler<R: Send>(config: Config, f: impl FnOnce(&Compiler) -> R + Se\n \n             rustc_span::set_source_map(compiler.sess.parse_sess.clone_source_map(), move || {\n                 let r = {\n-                    let _sess_abort_error = OnDrop(|| {\n+                    let _sess_abort_error = defer(|| {\n                         compiler.sess.finish_diagnostics(registry);\n                     });\n "}, {"sha": "d34a3afcba53a345c559a5263248848581e6daaf", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 372, "deletions": 373, "changes": 745, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -5,534 +5,533 @@ lint_array_into_iter =\n     .use_explicit_into_iter_suggestion =\n         or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n \n-lint_enum_intrinsics_mem_discriminant =\n-    the return value of `mem::discriminant` is unspecified when called with a non-enum type\n-    .note = the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `{$ty_param}`, which is not an enum.\n+lint_atomic_ordering_fence = memory fences cannot have `Relaxed` ordering\n+    .help = consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\n \n-lint_enum_intrinsics_mem_variant =\n-    the return value of `mem::variant_count` is unspecified when called with a non-enum type\n-    .note = the type parameter of `variant_count` should be an enum, but it was instantiated with the type `{$ty_param}`, which is not an enum.\n+lint_atomic_ordering_invalid = `{$method}`'s failure ordering may not be `Release` or `AcqRel`, since a failed `{$method}` does not result in a write\n+    .label = invalid failure ordering\n+    .help = consider using `Acquire` or `Relaxed` failure ordering instead\n \n-lint_expectation = this lint expectation is unfulfilled\n-    .note = the `unfulfilled_lint_expectations` lint can't be expected and will always produce this message\n-    .rationale = {$rationale}\n+lint_atomic_ordering_load = atomic loads cannot have `Release` or `AcqRel` ordering\n+    .help = consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n \n-lint_for_loops_over_fallibles =\n-    for loop over {$article} `{$ty}`. This is more readably written as an `if let` statement\n-    .suggestion = consider using `if let` to clear intent\n-    .remove_next = to iterate over `{$recv_snip}` remove the call to `next`\n-    .use_while_let = to check pattern in a loop use `while let`\n-    .use_question_mark = consider unwrapping the `Result` with `?` to iterate over its contents\n+lint_atomic_ordering_store = atomic stores cannot have `Acquire` or `AcqRel` ordering\n+    .help = consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n \n-lint_map_unit_fn = `Iterator::map` call that discard the iterator's values\n-    .note = `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n-    .function_label = this function returns `()`, which is likely not what you wanted\n-    .argument_label = called `Iterator::map` with callable that returns `()`\n-    .map_label = after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n-    .suggestion = you might have meant to use `Iterator::for_each`\n+lint_bad_attribute_argument = bad attribute argument\n \n-lint_non_binding_let_on_sync_lock =\n-    non-binding let on a synchronization lock\n+lint_bad_opt_access = {$msg}\n \n-lint_non_binding_let_on_drop_type =\n-    non-binding let on a type that implements `Drop`\n+lint_builtin_allow_internal_unsafe =\n+    `allow_internal_unsafe` allows defining macros using unsafe without triggering the `unsafe_code` lint at their call site\n \n-lint_non_binding_let_suggestion =\n-    consider binding to an unused variable to avoid immediately dropping the value\n+lint_builtin_anonymous_params = anonymous parameters are deprecated and will be removed in the next edition\n+    .suggestion = try naming the parameter or explicitly ignoring it\n \n-lint_non_binding_let_multi_suggestion =\n-    consider immediately dropping the value\n+lint_builtin_asm_labels = avoid using named labels in inline assembly\n \n-lint_deprecated_lint_name =\n-    lint name `{$name}` is deprecated and may not have an effect in the future.\n-    .suggestion = change it to\n+lint_builtin_box_pointers = type uses owned (Box type) pointers: {$ty}\n \n-lint_renamed_or_removed_lint = {$msg}\n-    .suggestion = use the new name\n+lint_builtin_clashing_extern_diff_name = `{$this}` redeclares `{$orig}` with a different signature\n+    .previous_decl_label = `{$orig}` previously declared here\n+    .mismatch_label = this signature doesn't match the previous declaration\n \n-lint_suspicious_double_ref_op =\n-    using `.{$call}()` on a double reference, which returns `{$ty}` instead of {$op ->\n-        *[should_not_happen] [{$op}]\n-        [deref] dereferencing\n-        [borrow] borrowing\n-        [clone] cloning\n-    } the inner type\n+lint_builtin_clashing_extern_same_name = `{$this}` redeclared with a different signature\n+    .previous_decl_label = `{$orig}` previously declared here\n+    .mismatch_label = this signature doesn't match the previous declaration\n+lint_builtin_const_no_mangle = const items should never be `#[no_mangle]`\n+    .suggestion = try a static value\n \n-lint_unknown_lint =\n-    unknown lint: `{$name}`\n-    .suggestion = did you mean\n+lint_builtin_decl_unsafe_fn = declaration of an `unsafe` function\n+lint_builtin_decl_unsafe_method = declaration of an `unsafe` method\n+lint_builtin_deprecated_attr_default_suggestion = remove this attribute\n \n-lint_ignored_unless_crate_specified = {$level}({$name}) is ignored unless specified at crate level\n+lint_builtin_deprecated_attr_link = use of deprecated attribute `{$name}`: {$reason}. See {$link}\n+    .msg_suggestion = {$msg}\n+    .default_suggestion = remove this attribute\n+lint_builtin_deprecated_attr_used = use of deprecated attribute `{$name}`: no longer used.\n+lint_builtin_deref_nullptr = dereferencing a null pointer\n+    .label = this code causes undefined behavior when executed\n \n-lint_unknown_gated_lint =\n-    unknown lint: `{$name}`\n-    .note = the `{$name}` lint is unstable\n+lint_builtin_ellipsis_inclusive_range_patterns = `...` range patterns are deprecated\n+    .suggestion = use `..=` for an inclusive range\n \n-lint_hidden_unicode_codepoints = unicode codepoint changing visible direction of text present in {$label}\n-    .label = this {$label} contains {$count ->\n-        [one] an invisible\n-        *[other] invisible\n-    } unicode text flow control {$count ->\n-        [one] codepoint\n-        *[other] codepoints\n+lint_builtin_explicit_outlives = outlives requirements can be inferred\n+    .suggestion = remove {$count ->\n+        [one] this bound\n+        *[other] these bounds\n     }\n-    .note = these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n-    .suggestion_remove = if their presence wasn't intentional, you can remove them\n-    .suggestion_escape = if you want to keep them but make them visible in your source code, you can escape them\n-    .no_suggestion_note_escape = if you want to keep them but make them visible in your source code, you can escape them: {$escaped}\n \n-lint_default_hash_types = prefer `{$preferred}` over `{$used}`, it has better performance\n-    .note = a `use rustc_data_structures::fx::{$preferred}` may be necessary\n-\n-lint_query_instability = using `{$query}` can result in unstable query results\n-    .note = if you believe this case to be fine, allow this lint and add a comment explaining your rationale\n+lint_builtin_export_name_fn = declaration of a function with `export_name`\n+lint_builtin_export_name_method = declaration of a method with `export_name`\n \n-lint_tykind_kind = usage of `ty::TyKind::<kind>`\n-    .suggestion = try using `ty::<kind>` directly\n+lint_builtin_export_name_static = declaration of a static with `export_name`\n+lint_builtin_impl_unsafe_method = implementation of an `unsafe` method\n \n-lint_tykind = usage of `ty::TyKind`\n-    .help = try using `Ty` instead\n+lint_builtin_incomplete_features = the feature `{$name}` is incomplete and may not be safe to use and/or cause compiler crashes\n+    .note = see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n+    .help = consider using `min_{$name}` instead, which is more stable and complete\n \n-lint_ty_qualified = usage of qualified `ty::{$ty}`\n-    .suggestion = try importing it and using it unqualified\n+lint_builtin_keyword_idents = `{$kw}` is a keyword in the {$next} edition\n+    .suggestion = you can use a raw identifier to stay compatible\n \n-lint_lintpass_by_hand = implementing `LintPass` by hand\n-    .help = try using `declare_lint_pass!` or `impl_lint_pass!` instead\n+lint_builtin_link_section_fn = declaration of a function with `link_section`\n \n-lint_non_existent_doc_keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \"...\")]`\n-    .help = only existing keywords are allowed in core/std\n+lint_builtin_link_section_static = declaration of a static with `link_section`\n \n-lint_diag_out_of_impl =\n-    diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n+lint_builtin_missing_copy_impl = type could implement `Copy`; consider adding `impl Copy`\n \n-lint_untranslatable_diag = diagnostics should be created using translatable messages\n+lint_builtin_missing_debug_impl =\n+    type does not implement `{$debug}`; consider adding `#[derive(Debug)]` or a manual implementation\n \n-lint_trivial_untranslatable_diag = diagnostic with static strings only\n+lint_builtin_missing_doc = missing documentation for {$article} {$desc}\n \n-lint_bad_opt_access = {$msg}\n+lint_builtin_mutable_transmutes =\n+    transmuting &T to &mut T is undefined behavior, even if the reference is unused, consider instead using an UnsafeCell\n \n-lint_cstring_ptr = getting the inner pointer of a temporary `CString`\n-    .as_ptr_label = this pointer will be invalid\n-    .unwrap_label = this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n-    .note = pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\n-    .help = for more information, see https://doc.rust-lang.org/reference/destructors.html\n+lint_builtin_no_mangle_fn = declaration of a `no_mangle` function\n+lint_builtin_no_mangle_generic = functions generic over types or consts must be mangled\n+    .suggestion = remove this attribute\n \n-lint_multiple_supertrait_upcastable = `{$ident}` is object-safe and has multiple supertraits\n+lint_builtin_no_mangle_method = declaration of a `no_mangle` method\n+lint_builtin_no_mangle_static = declaration of a `no_mangle` static\n+lint_builtin_non_shorthand_field_patterns = the `{$ident}:` in this pattern is redundant\n+    .suggestion = use shorthand field pattern\n \n-lint_identifier_non_ascii_char = identifier contains non-ASCII characters\n+lint_builtin_overridden_symbol_name =\n+    the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n \n-lint_identifier_uncommon_codepoints = identifier contains uncommon Unicode codepoints\n+lint_builtin_overridden_symbol_section =\n+    the program's behavior with overridden link sections on items is unpredictable and Rust cannot provide guarantees when you manually override them\n \n-lint_confusable_identifier_pair = identifier pair considered confusable between `{$existing_sym}` and `{$sym}`\n-    .label = this is where the previous identifier occurred\n+lint_builtin_special_module_name_used_lib = found module declaration for lib.rs\n+    .note = lib.rs is the root of this crate's library target\n+    .help = to refer to it from other targets, use the library's name as the path\n \n-lint_mixed_script_confusables =\n-    the usage of Script Group `{$set}` in this crate consists solely of mixed script confusables\n-    .includes_note = the usage includes {$includes}\n-    .note = please recheck to make sure their usages are indeed what you want\n+lint_builtin_special_module_name_used_main = found module declaration for main.rs\n+    .note = a binary crate cannot be used as library\n \n-lint_non_fmt_panic = panic message is not a string literal\n-    .note = this usage of `{$name}!()` is deprecated; it will be a hard error in Rust 2021\n-    .more_info_note = for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n-    .supports_fmt_note = the `{$name}!()` macro supports formatting, so there's no need for the `format!()` macro here\n-    .supports_fmt_suggestion = remove the `format!(..)` macro call\n-    .display_suggestion = add a \"{\"{\"}{\"}\"}\" format string to `Display` the message\n-    .debug_suggestion =\n-        add a \"{\"{\"}:?{\"}\"}\" format string to use the `Debug` implementation of `{$ty}`\n-    .panic_suggestion = {$already_suggested ->\n-        [true] or use\n-        *[false] use\n-    } std::panic::panic_any instead\n+lint_builtin_trivial_bounds = {$predicate_kind_name} bound {$predicate} does not depend on any type or lifetime parameters\n \n-lint_non_fmt_panic_unused =\n-    panic message contains {$count ->\n-        [one] an unused\n-        *[other] unused\n-    } formatting {$count ->\n-        [one] placeholder\n-        *[other] placeholders\n-    }\n-    .note = this message is not used as a format string when given without arguments, but will be in Rust 2021\n-    .add_args_suggestion = add the missing {$count ->\n-        [one] argument\n-        *[other] arguments\n-    }\n-    .add_fmt_suggestion = or add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n+lint_builtin_type_alias_bounds_help = use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to associated types in type aliases\n \n-lint_non_fmt_panic_braces =\n-    panic message contains {$count ->\n-        [one] a brace\n-        *[other] braces\n-    }\n-    .note = this message is not used as a format string, but will be in Rust 2021\n-    .suggestion = add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n+lint_builtin_type_alias_generic_bounds = bounds on generic parameters are not enforced in type aliases\n+    .suggestion = the bound will not be checked when the type alias is used, and should be removed\n \n-lint_non_camel_case_type = {$sort} `{$name}` should have an upper camel case name\n-    .suggestion = convert the identifier to upper camel case\n-    .label = should have an UpperCamelCase name\n+lint_builtin_type_alias_where_clause = where clauses are not enforced in type aliases\n+    .suggestion = the clause will not be checked when the type alias is used, and should be removed\n \n-lint_non_snake_case = {$sort} `{$name}` should have a snake case name\n-    .rename_or_convert_suggestion = rename the identifier or convert it to a snake case raw identifier\n-    .cannot_convert_note = `{$sc}` cannot be used as a raw identifier\n-    .rename_suggestion = rename the identifier\n-    .convert_suggestion = convert the identifier to snake case\n-    .help = convert the identifier to snake case: `{$sc}`\n-    .label = should have a snake_case name\n+lint_builtin_unexpected_cli_config_name = unexpected `{$name}` as condition name\n+    .help = was set with `--cfg` but isn't in the `--check-cfg` expected names\n \n-lint_non_upper_case_global = {$sort} `{$name}` should have an upper case name\n-    .suggestion = convert the identifier to upper case\n-    .label = should have an UPPER_CASE name\n+lint_builtin_unexpected_cli_config_value = unexpected condition value `{$value}` for condition name `{$name}`\n+    .help = was set with `--cfg` but isn't in the `--check-cfg` expected values\n \n-lint_noop_method_call = call to `.{$method}()` on a reference in this situation does nothing\n-    .label = unnecessary method call\n-    .note = the type `{$receiver_ty}` which `{$method}` is being called on is the same as the type returned from `{$method}`, so the method call does not do anything and can be removed\n+lint_builtin_unnameable_test_items = cannot test inner items\n \n-lint_pass_by_value = passing `{$ty}` by reference\n-    .suggestion = try passing by value\n+lint_builtin_unpermitted_type_init_label = this code causes undefined behavior when executed\n+lint_builtin_unpermitted_type_init_label_suggestion = help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n \n-lint_redundant_semicolons =\n-    unnecessary trailing {$multiple ->\n-        [true] semicolons\n-        *[false] semicolon\n-    }\n-    .suggestion = remove {$multiple ->\n-        [true] these semicolons\n-        *[false] this semicolon\n-    }\n+lint_builtin_unpermitted_type_init_uninit = the type `{$ty}` does not permit being left uninitialized\n \n-lint_drop_trait_constraints =\n-    bounds on `{$predicate}` are most likely incorrect, consider instead using `{$needs_drop}` to detect whether a type can be trivially dropped\n+lint_builtin_unpermitted_type_init_zeroed = the type `{$ty}` does not permit zero-initialization\n+lint_builtin_unreachable_pub = unreachable `pub` {$what}\n+    .suggestion = consider restricting its visibility\n+    .help = or consider exporting it for use by other crates\n \n-lint_drop_glue =\n-    types that do not implement `Drop` can still have drop glue, consider instead using `{$needs_drop}` to detect whether a type is trivially dropped\n+lint_builtin_unsafe_block = usage of an `unsafe` block\n \n-lint_range_endpoint_out_of_range = range endpoint is out of range for `{$ty}`\n+lint_builtin_unsafe_impl = implementation of an `unsafe` trait\n \n-lint_range_use_inclusive_range = use an inclusive range instead\n+lint_builtin_unsafe_trait = declaration of an `unsafe` trait\n \n+lint_builtin_unstable_features = unstable feature\n \n-lint_overflowing_bin_hex = literal out of range for `{$ty}`\n-    .negative_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}`\n-    .negative_becomes_note = and the value `-{$lit}` will become `{$actually}{$ty}`\n-    .positive_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}` and will become `{$actually}{$ty}`\n-    .suggestion = consider using the type `{$suggestion_ty}` instead\n-    .help = consider using the type `{$suggestion_ty}` instead\n+lint_builtin_unused_doc_comment = unused doc comment\n+    .label = rustdoc does not generate documentation for {$kind}\n+    .plain_help = use `//` for a plain comment\n+    .block_help = use `/* */` for a plain comment\n \n-lint_overflowing_int = literal out of range for `{$ty}`\n-    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n-    .help = consider using the type `{$suggestion_ty}` instead\n+lint_builtin_while_true = denote infinite loops with `loop {\"{\"} ... {\"}\"}`\n+    .suggestion = use `loop`\n \n-lint_only_cast_u8_to_char = only `u8` can be cast into `char`\n-    .suggestion = use a `char` literal instead\n+lint_check_name_deprecated = lint name `{$lint_name}` is deprecated and does not have an effect anymore. Use: {$new_name}\n \n-lint_overflowing_uint = literal out of range for `{$ty}`\n-    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n+lint_check_name_unknown = unknown lint: `{$lint_name}`\n+    .help = did you mean: `{$suggestion}`\n \n-lint_overflowing_literal = literal out of range for `{$ty}`\n-    .note = the literal `{$lit}` does not fit into the type `{$ty}` and will be converted to `{$ty}::INFINITY`\n+lint_check_name_unknown_tool = unknown lint tool: `{$tool_name}`\n \n-lint_unused_comparisons = comparison is useless due to type limits\n+lint_check_name_warning = {$msg}\n \n-lint_improper_ctypes = `extern` {$desc} uses type `{$ty}`, which is not FFI-safe\n-    .label = not FFI-safe\n-    .note = the type is defined here\n+lint_command_line_source = `forbid` lint level was set on command line\n \n-lint_improper_ctypes_opaque = opaque types have no C equivalent\n+lint_confusable_identifier_pair = identifier pair considered confusable between `{$existing_sym}` and `{$sym}`\n+    .label = this is where the previous identifier occurred\n \n-lint_improper_ctypes_fnptr_reason = this function pointer has Rust-specific calling convention\n-lint_improper_ctypes_fnptr_help = consider using an `extern fn(...) -> ...` function pointer instead\n+lint_cstring_ptr = getting the inner pointer of a temporary `CString`\n+    .as_ptr_label = this pointer will be invalid\n+    .unwrap_label = this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime\n+    .note = pointers do not have a lifetime; when calling `as_ptr` the `CString` will be deallocated at the end of the statement because nothing is referencing it as far as the type system is concerned\n+    .help = for more information, see https://doc.rust-lang.org/reference/destructors.html\n \n-lint_improper_ctypes_tuple_reason = tuples have unspecified layout\n-lint_improper_ctypes_tuple_help = consider using a struct instead\n+lint_default_hash_types = prefer `{$preferred}` over `{$used}`, it has better performance\n+    .note = a `use rustc_data_structures::fx::{$preferred}` may be necessary\n \n-lint_improper_ctypes_str_reason = string slices have no C equivalent\n-lint_improper_ctypes_str_help = consider using `*const u8` and a length instead\n+lint_default_source = `forbid` lint level is the default for {$id}\n \n-lint_improper_ctypes_dyn = trait objects have no C equivalent\n+lint_deprecated_lint_name =\n+    lint name `{$name}` is deprecated and may not have an effect in the future.\n+    .suggestion = change it to\n \n-lint_improper_ctypes_slice_reason = slices have no C equivalent\n-lint_improper_ctypes_slice_help = consider using a raw pointer instead\n+lint_diag_out_of_impl =\n+    diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n \n-lint_improper_ctypes_128bit = 128-bit integers don't currently have a known stable ABI\n+lint_drop_glue =\n+    types that do not implement `Drop` can still have drop glue, consider instead using `{$needs_drop}` to detect whether a type is trivially dropped\n \n-lint_improper_ctypes_char_reason = the `char` type has no C equivalent\n-lint_improper_ctypes_char_help = consider using `u32` or `libc::wchar_t` instead\n+lint_drop_trait_constraints =\n+    bounds on `{$predicate}` are most likely incorrect, consider instead using `{$needs_drop}` to detect whether a type can be trivially dropped\n \n-lint_improper_ctypes_non_exhaustive = this enum is non-exhaustive\n-lint_improper_ctypes_non_exhaustive_variant = this enum has non-exhaustive variants\n+lint_dropping_copy_types = calls to `std::mem::drop` with a value that implements `Copy` does nothing\n+    .label = argument has type `{$arg_ty}`\n+    .note = use `let _ = ...` to ignore the expression or result\n \n-lint_improper_ctypes_enum_repr_reason = enum has no representation hint\n-lint_improper_ctypes_enum_repr_help =\n-    consider adding a `#[repr(C)]`, `#[repr(transparent)]`, or integer `#[repr(...)]` attribute to this enum\n+lint_dropping_references = calls to `std::mem::drop` with a reference instead of an owned value does nothing\n+    .label = argument has type `{$arg_ty}`\n+    .note = use `let _ = ...` to ignore the expression or result\n \n-lint_improper_ctypes_struct_fieldless_reason = this struct has no fields\n-lint_improper_ctypes_struct_fieldless_help = consider adding a member to this struct\n+lint_enum_intrinsics_mem_discriminant =\n+    the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+    .note = the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `{$ty_param}`, which is not an enum.\n \n-lint_improper_ctypes_union_fieldless_reason = this union has no fields\n-lint_improper_ctypes_union_fieldless_help = consider adding a member to this union\n+lint_enum_intrinsics_mem_variant =\n+    the return value of `mem::variant_count` is unspecified when called with a non-enum type\n+    .note = the type parameter of `variant_count` should be an enum, but it was instantiated with the type `{$ty_param}`, which is not an enum.\n \n-lint_improper_ctypes_struct_non_exhaustive = this struct is non-exhaustive\n-lint_improper_ctypes_union_non_exhaustive = this union is non-exhaustive\n+lint_expectation = this lint expectation is unfulfilled\n+    .note = the `unfulfilled_lint_expectations` lint can't be expected and will always produce this message\n+    .rationale = {$rationale}\n \n-lint_improper_ctypes_struct_layout_reason = this struct has unspecified layout\n-lint_improper_ctypes_struct_layout_help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n+lint_for_loops_over_fallibles =\n+    for loop over {$article} `{$ty}`. This is more readably written as an `if let` statement\n+    .suggestion = consider using `if let` to clear intent\n+    .remove_next = to iterate over `{$recv_snip}` remove the call to `next`\n+    .use_while_let = to check pattern in a loop use `while let`\n+    .use_question_mark = consider unwrapping the `Result` with `?` to iterate over its contents\n \n-lint_improper_ctypes_union_layout_reason = this union has unspecified layout\n-lint_improper_ctypes_union_layout_help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this union\n+lint_forgetting_copy_types = calls to `std::mem::forget` with a value that implements `Copy` does nothing\n+    .label = argument has type `{$arg_ty}`\n+    .note = use `let _ = ...` to ignore the expression or result\n+lint_forgetting_references = calls to `std::mem::forget` with a reference instead of an owned value does nothing\n+    .label = argument has type `{$arg_ty}`\n+    .note = use `let _ = ...` to ignore the expression or result\n \n-lint_improper_ctypes_box = box cannot be represented as a single pointer\n+lint_hidden_unicode_codepoints = unicode codepoint changing visible direction of text present in {$label}\n+    .label = this {$label} contains {$count ->\n+        [one] an invisible\n+        *[other] invisible\n+    } unicode text flow control {$count ->\n+        [one] codepoint\n+        *[other] codepoints\n+    }\n+    .note = these kind of unicode codepoints change the way text flows on applications that support them, but can cause confusion because they change the order of characters on the screen\n+    .suggestion_remove = if their presence wasn't intentional, you can remove them\n+    .suggestion_escape = if you want to keep them but make them visible in your source code, you can escape them\n+    .no_suggestion_note_escape = if you want to keep them but make them visible in your source code, you can escape them: {$escaped}\n \n-lint_improper_ctypes_enum_phantomdata = this enum contains a PhantomData field\n+lint_identifier_non_ascii_char = identifier contains non-ASCII characters\n \n-lint_improper_ctypes_struct_zst = this struct contains only zero-sized fields\n+lint_identifier_uncommon_codepoints = identifier contains uncommon Unicode codepoints\n \n-lint_improper_ctypes_array_reason = passing raw arrays by value is not FFI-safe\n-lint_improper_ctypes_array_help = consider passing a pointer to the array\n+lint_ignored_unless_crate_specified = {$level}({$name}) is ignored unless specified at crate level\n \n-lint_improper_ctypes_only_phantomdata = composed only of `PhantomData`\n+lint_improper_ctypes = `extern` {$desc} uses type `{$ty}`, which is not FFI-safe\n+    .label = not FFI-safe\n+    .note = the type is defined here\n \n-lint_variant_size_differences =\n-    enum variant is more than three times larger ({$largest} bytes) than the next largest\n+lint_improper_ctypes_128bit = 128-bit integers don't currently have a known stable ABI\n \n-lint_atomic_ordering_load = atomic loads cannot have `Release` or `AcqRel` ordering\n-    .help = consider using ordering modes `Acquire`, `SeqCst` or `Relaxed`\n+lint_improper_ctypes_array_help = consider passing a pointer to the array\n \n-lint_atomic_ordering_store = atomic stores cannot have `Acquire` or `AcqRel` ordering\n-    .help = consider using ordering modes `Release`, `SeqCst` or `Relaxed`\n+lint_improper_ctypes_array_reason = passing raw arrays by value is not FFI-safe\n+lint_improper_ctypes_box = box cannot be represented as a single pointer\n \n-lint_atomic_ordering_fence = memory fences cannot have `Relaxed` ordering\n-    .help = consider using ordering modes `Acquire`, `Release`, `AcqRel` or `SeqCst`\n+lint_improper_ctypes_char_help = consider using `u32` or `libc::wchar_t` instead\n \n-lint_atomic_ordering_invalid = `{$method}`'s failure ordering may not be `Release` or `AcqRel`, since a failed `{$method}` does not result in a write\n-    .label = invalid failure ordering\n-    .help = consider using `Acquire` or `Relaxed` failure ordering instead\n+lint_improper_ctypes_char_reason = the `char` type has no C equivalent\n+lint_improper_ctypes_dyn = trait objects have no C equivalent\n \n-lint_unused_op = unused {$op} that must be used\n-    .label = the {$op} produces a value\n-    .suggestion = use `let _ = ...` to ignore the resulting value\n+lint_improper_ctypes_enum_phantomdata = this enum contains a PhantomData field\n \n-lint_unused_result = unused result of type `{$ty}`\n+lint_improper_ctypes_enum_repr_help =\n+    consider adding a `#[repr(C)]`, `#[repr(transparent)]`, or integer `#[repr(...)]` attribute to this enum\n \n-lint_unused_closure =\n-    unused {$pre}{$count ->\n-        [one] closure\n-        *[other] closures\n-    }{$post} that must be used\n-    .note = closures are lazy and do nothing unless called\n+lint_improper_ctypes_enum_repr_reason = enum has no representation hint\n+lint_improper_ctypes_fnptr_help = consider using an `extern fn(...) -> ...` function pointer instead\n \n-lint_unused_generator =\n-    unused {$pre}{$count ->\n-        [one] generator\n-        *[other] generator\n-    }{$post} that must be used\n-    .note = generators are lazy and do nothing unless resumed\n+lint_improper_ctypes_fnptr_reason = this function pointer has Rust-specific calling convention\n+lint_improper_ctypes_non_exhaustive = this enum is non-exhaustive\n+lint_improper_ctypes_non_exhaustive_variant = this enum has non-exhaustive variants\n \n-lint_unused_def = unused {$pre}`{$def}`{$post} that must be used\n-    .suggestion = use `let _ = ...` to ignore the resulting value\n+lint_improper_ctypes_only_phantomdata = composed only of `PhantomData`\n \n-lint_path_statement_drop = path statement drops value\n-    .suggestion = use `drop` to clarify the intent\n+lint_improper_ctypes_opaque = opaque types have no C equivalent\n \n-lint_path_statement_no_effect = path statement with no effect\n+lint_improper_ctypes_slice_help = consider using a raw pointer instead\n \n-lint_unused_delim = unnecessary {$delim} around {$item}\n-    .suggestion = remove these {$delim}\n+lint_improper_ctypes_slice_reason = slices have no C equivalent\n+lint_improper_ctypes_str_help = consider using `*const u8` and a length instead\n \n-lint_unused_import_braces = braces around {$node} is unnecessary\n+lint_improper_ctypes_str_reason = string slices have no C equivalent\n+lint_improper_ctypes_struct_fieldless_help = consider adding a member to this struct\n \n-lint_unused_allocation = unnecessary allocation, use `&` instead\n-lint_unused_allocation_mut = unnecessary allocation, use `&mut` instead\n+lint_improper_ctypes_struct_fieldless_reason = this struct has no fields\n+lint_improper_ctypes_struct_layout_help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this struct\n \n-lint_builtin_while_true = denote infinite loops with `loop {\"{\"} ... {\"}\"}`\n-    .suggestion = use `loop`\n+lint_improper_ctypes_struct_layout_reason = this struct has unspecified layout\n+lint_improper_ctypes_struct_non_exhaustive = this struct is non-exhaustive\n+lint_improper_ctypes_struct_zst = this struct contains only zero-sized fields\n \n-lint_builtin_box_pointers = type uses owned (Box type) pointers: {$ty}\n+lint_improper_ctypes_tuple_help = consider using a struct instead\n \n-lint_builtin_non_shorthand_field_patterns = the `{$ident}:` in this pattern is redundant\n-    .suggestion = use shorthand field pattern\n+lint_improper_ctypes_tuple_reason = tuples have unspecified layout\n+lint_improper_ctypes_union_fieldless_help = consider adding a member to this union\n \n-lint_builtin_overridden_symbol_name =\n-    the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+lint_improper_ctypes_union_fieldless_reason = this union has no fields\n+lint_improper_ctypes_union_layout_help = consider adding a `#[repr(C)]` or `#[repr(transparent)]` attribute to this union\n \n-lint_builtin_overridden_symbol_section =\n-    the program's behavior with overridden link sections on items is unpredictable and Rust cannot provide guarantees when you manually override them\n+lint_improper_ctypes_union_layout_reason = this union has unspecified layout\n+lint_improper_ctypes_union_non_exhaustive = this union is non-exhaustive\n \n-lint_builtin_allow_internal_unsafe =\n-    `allow_internal_unsafe` allows defining macros using unsafe without triggering the `unsafe_code` lint at their call site\n+lint_lintpass_by_hand = implementing `LintPass` by hand\n+    .help = try using `declare_lint_pass!` or `impl_lint_pass!` instead\n \n-lint_builtin_unsafe_block = usage of an `unsafe` block\n+lint_malformed_attribute = malformed lint attribute input\n \n-lint_builtin_unsafe_trait = declaration of an `unsafe` trait\n+lint_map_unit_fn = `Iterator::map` call that discard the iterator's values\n+    .note = `Iterator::map`, like many of the methods on `Iterator`, gets executed lazily, meaning that its effects won't be visible until it is iterated\n+    .function_label = this function returns `()`, which is likely not what you wanted\n+    .argument_label = called `Iterator::map` with callable that returns `()`\n+    .map_label = after this call to map, the resulting iterator is `impl Iterator<Item = ()>`, which means the only information carried by the iterator is the number of items\n+    .suggestion = you might have meant to use `Iterator::for_each`\n \n-lint_builtin_unsafe_impl = implementation of an `unsafe` trait\n+lint_mixed_script_confusables =\n+    the usage of Script Group `{$set}` in this crate consists solely of mixed script confusables\n+    .includes_note = the usage includes {$includes}\n+    .note = please recheck to make sure their usages are indeed what you want\n \n-lint_builtin_no_mangle_fn = declaration of a `no_mangle` function\n-lint_builtin_export_name_fn = declaration of a function with `export_name`\n-lint_builtin_link_section_fn = declaration of a function with `link_section`\n+lint_multiple_supertrait_upcastable = `{$ident}` is object-safe and has multiple supertraits\n \n-lint_builtin_no_mangle_static = declaration of a `no_mangle` static\n-lint_builtin_export_name_static = declaration of a static with `export_name`\n-lint_builtin_link_section_static = declaration of a static with `link_section`\n+lint_node_source = `forbid` level set here\n+    .note = {$reason}\n \n-lint_builtin_no_mangle_method = declaration of a `no_mangle` method\n-lint_builtin_export_name_method = declaration of a method with `export_name`\n+lint_non_binding_let_multi_suggestion =\n+    consider immediately dropping the value\n \n-lint_builtin_decl_unsafe_fn = declaration of an `unsafe` function\n-lint_builtin_decl_unsafe_method = declaration of an `unsafe` method\n-lint_builtin_impl_unsafe_method = implementation of an `unsafe` method\n+lint_non_binding_let_on_drop_type =\n+    non-binding let on a type that implements `Drop`\n \n-lint_builtin_missing_doc = missing documentation for {$article} {$desc}\n+lint_non_binding_let_on_sync_lock =\n+    non-binding let on a synchronization lock\n \n-lint_builtin_missing_copy_impl = type could implement `Copy`; consider adding `impl Copy`\n+lint_non_binding_let_suggestion =\n+    consider binding to an unused variable to avoid immediately dropping the value\n \n-lint_builtin_missing_debug_impl =\n-    type does not implement `{$debug}`; consider adding `#[derive(Debug)]` or a manual implementation\n+lint_non_camel_case_type = {$sort} `{$name}` should have an upper camel case name\n+    .suggestion = convert the identifier to upper camel case\n+    .label = should have an UpperCamelCase name\n \n-lint_builtin_anonymous_params = anonymous parameters are deprecated and will be removed in the next edition\n-    .suggestion = try naming the parameter or explicitly ignoring it\n+lint_non_existent_doc_keyword = found non-existing keyword `{$keyword}` used in `#[doc(keyword = \"...\")]`\n+    .help = only existing keywords are allowed in core/std\n \n-lint_builtin_deprecated_attr_link = use of deprecated attribute `{$name}`: {$reason}. See {$link}\n-    .msg_suggestion = {$msg}\n-    .default_suggestion = remove this attribute\n-lint_builtin_deprecated_attr_used = use of deprecated attribute `{$name}`: no longer used.\n-lint_builtin_deprecated_attr_default_suggestion = remove this attribute\n+lint_non_fmt_panic = panic message is not a string literal\n+    .note = this usage of `{$name}!()` is deprecated; it will be a hard error in Rust 2021\n+    .more_info_note = for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/panic-macro-consistency.html>\n+    .supports_fmt_note = the `{$name}!()` macro supports formatting, so there's no need for the `format!()` macro here\n+    .supports_fmt_suggestion = remove the `format!(..)` macro call\n+    .display_suggestion = add a \"{\"{\"}{\"}\"}\" format string to `Display` the message\n+    .debug_suggestion =\n+        add a \"{\"{\"}:?{\"}\"}\" format string to use the `Debug` implementation of `{$ty}`\n+    .panic_suggestion = {$already_suggested ->\n+        [true] or use\n+        *[false] use\n+    } std::panic::panic_any instead\n \n-lint_builtin_unused_doc_comment = unused doc comment\n-    .label = rustdoc does not generate documentation for {$kind}\n-    .plain_help = use `//` for a plain comment\n-    .block_help = use `/* */` for a plain comment\n+lint_non_fmt_panic_braces =\n+    panic message contains {$count ->\n+        [one] a brace\n+        *[other] braces\n+    }\n+    .note = this message is not used as a format string, but will be in Rust 2021\n+    .suggestion = add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n \n-lint_builtin_no_mangle_generic = functions generic over types or consts must be mangled\n-    .suggestion = remove this attribute\n+lint_non_fmt_panic_unused =\n+    panic message contains {$count ->\n+        [one] an unused\n+        *[other] unused\n+    } formatting {$count ->\n+        [one] placeholder\n+        *[other] placeholders\n+    }\n+    .note = this message is not used as a format string when given without arguments, but will be in Rust 2021\n+    .add_args_suggestion = add the missing {$count ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+    .add_fmt_suggestion = or add a \"{\"{\"}{\"}\"}\" format string to use the message literally\n \n-lint_builtin_const_no_mangle = const items should never be `#[no_mangle]`\n-    .suggestion = try a static value\n+lint_non_snake_case = {$sort} `{$name}` should have a snake case name\n+    .rename_or_convert_suggestion = rename the identifier or convert it to a snake case raw identifier\n+    .cannot_convert_note = `{$sc}` cannot be used as a raw identifier\n+    .rename_suggestion = rename the identifier\n+    .convert_suggestion = convert the identifier to snake case\n+    .help = convert the identifier to snake case: `{$sc}`\n+    .label = should have a snake_case name\n \n-lint_builtin_mutable_transmutes =\n-    transmuting &T to &mut T is undefined behavior, even if the reference is unused, consider instead using an UnsafeCell\n+lint_non_upper_case_global = {$sort} `{$name}` should have an upper case name\n+    .suggestion = convert the identifier to upper case\n+    .label = should have an UPPER_CASE name\n \n-lint_builtin_unstable_features = unstable feature\n+lint_noop_method_call = call to `.{$method}()` on a reference in this situation does nothing\n+    .label = unnecessary method call\n+    .note = the type `{$receiver_ty}` which `{$method}` is being called on is the same as the type returned from `{$method}`, so the method call does not do anything and can be removed\n \n-lint_ungated_async_fn_track_caller = `#[track_caller]` on async functions is a no-op\n-     .label = this function will not propagate the caller location\n+lint_only_cast_u8_to_char = only `u8` can be cast into `char`\n+    .suggestion = use a `char` literal instead\n \n-lint_builtin_unreachable_pub = unreachable `pub` {$what}\n-    .suggestion = consider restricting its visibility\n-    .help = or consider exporting it for use by other crates\n+lint_opaque_hidden_inferred_bound = opaque type `{$ty}` does not satisfy its associated type bounds\n+    .specifically = this associated type bound is unsatisfied for `{$proj_ty}`\n \n-lint_builtin_unexpected_cli_config_name = unexpected `{$name}` as condition name\n-    .help = was set with `--cfg` but isn't in the `--check-cfg` expected names\n+lint_opaque_hidden_inferred_bound_sugg = add this bound\n \n-lint_builtin_unexpected_cli_config_value = unexpected condition value `{$value}` for condition name `{$name}`\n-    .help = was set with `--cfg` but isn't in the `--check-cfg` expected values\n+lint_overflowing_bin_hex = literal out of range for `{$ty}`\n+    .negative_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}`\n+    .negative_becomes_note = and the value `-{$lit}` will become `{$actually}{$ty}`\n+    .positive_note = the literal `{$lit}` (decimal `{$dec}`) does not fit into the type `{$ty}` and will become `{$actually}{$ty}`\n+    .suggestion = consider using the type `{$suggestion_ty}` instead\n+    .help = consider using the type `{$suggestion_ty}` instead\n \n-lint_builtin_type_alias_bounds_help = use fully disambiguated paths (i.e., `<T as Trait>::Assoc`) to refer to associated types in type aliases\n+lint_overflowing_int = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n+    .help = consider using the type `{$suggestion_ty}` instead\n \n-lint_builtin_type_alias_where_clause = where clauses are not enforced in type aliases\n-    .suggestion = the clause will not be checked when the type alias is used, and should be removed\n+lint_overflowing_literal = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` and will be converted to `{$ty}::INFINITY`\n \n-lint_builtin_type_alias_generic_bounds = bounds on generic parameters are not enforced in type aliases\n-    .suggestion = the bound will not be checked when the type alias is used, and should be removed\n+lint_overflowing_uint = literal out of range for `{$ty}`\n+    .note = the literal `{$lit}` does not fit into the type `{$ty}` whose range is `{$min}..={$max}`\n \n-lint_builtin_trivial_bounds = {$predicate_kind_name} bound {$predicate} does not depend on any type or lifetime parameters\n+lint_overruled_attribute = {$lint_level}({$lint_source}) incompatible with previous forbid\n+    .label = overruled by previous forbid\n \n-lint_builtin_ellipsis_inclusive_range_patterns = `...` range patterns are deprecated\n-    .suggestion = use `..=` for an inclusive range\n+lint_pass_by_value = passing `{$ty}` by reference\n+    .suggestion = try passing by value\n \n-lint_builtin_unnameable_test_items = cannot test inner items\n+lint_path_statement_drop = path statement drops value\n+    .suggestion = use `drop` to clarify the intent\n \n-lint_builtin_keyword_idents = `{$kw}` is a keyword in the {$next} edition\n-    .suggestion = you can use a raw identifier to stay compatible\n+lint_path_statement_no_effect = path statement with no effect\n \n-lint_builtin_explicit_outlives = outlives requirements can be inferred\n-    .suggestion = remove {$count ->\n-        [one] this bound\n-        *[other] these bounds\n-    }\n+lint_query_instability = using `{$query}` can result in unstable query results\n+    .note = if you believe this case to be fine, allow this lint and add a comment explaining your rationale\n \n-lint_builtin_incomplete_features = the feature `{$name}` is incomplete and may not be safe to use and/or cause compiler crashes\n-    .note = see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n-    .help = consider using `min_{$name}` instead, which is more stable and complete\n+lint_range_endpoint_out_of_range = range endpoint is out of range for `{$ty}`\n \n-lint_builtin_unpermitted_type_init_zeroed = the type `{$ty}` does not permit zero-initialization\n-lint_builtin_unpermitted_type_init_uninit = the type `{$ty}` does not permit being left uninitialized\n+lint_range_use_inclusive_range = use an inclusive range instead\n \n-lint_builtin_unpermitted_type_init_label = this code causes undefined behavior when executed\n-lint_builtin_unpermitted_type_init_label_suggestion = help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n \n-lint_builtin_clashing_extern_same_name = `{$this}` redeclared with a different signature\n-    .previous_decl_label = `{$orig}` previously declared here\n-    .mismatch_label = this signature doesn't match the previous declaration\n-lint_builtin_clashing_extern_diff_name = `{$this}` redeclares `{$orig}` with a different signature\n-    .previous_decl_label = `{$orig}` previously declared here\n-    .mismatch_label = this signature doesn't match the previous declaration\n+lint_reason_must_be_string_literal = reason must be a string literal\n \n-lint_builtin_deref_nullptr = dereferencing a null pointer\n-    .label = this code causes undefined behavior when executed\n+lint_reason_must_come_last = reason in lint attribute must come last\n \n-lint_builtin_asm_labels = avoid using named labels in inline assembly\n+lint_redundant_semicolons =\n+    unnecessary trailing {$multiple ->\n+        [true] semicolons\n+        *[false] semicolon\n+    }\n+    .suggestion = remove {$multiple ->\n+        [true] these semicolons\n+        *[false] this semicolon\n+    }\n \n-lint_builtin_special_module_name_used_lib = found module declaration for lib.rs\n-    .note = lib.rs is the root of this crate's library target\n-    .help = to refer to it from other targets, use the library's name as the path\n+lint_renamed_or_removed_lint = {$msg}\n+    .suggestion = use the new name\n \n-lint_builtin_special_module_name_used_main = found module declaration for main.rs\n-    .note = a binary crate cannot be used as library\n+lint_requested_level = requested on the command line with `{$level} {$lint_name}`\n \n lint_supertrait_as_deref_target = `{$t}` implements `Deref` with supertrait `{$target_principal}` as target\n     .label = target type is set here\n \n-lint_overruled_attribute = {$lint_level}({$lint_source}) incompatible with previous forbid\n-    .label = overruled by previous forbid\n+lint_suspicious_double_ref_op =\n+    using `.{$call}()` on a double reference, which returns `{$ty}` instead of {$op ->\n+        *[should_not_happen] [{$op}]\n+        [deref] dereferencing\n+        [borrow] borrowing\n+        [clone] cloning\n+    } the inner type\n \n-lint_default_source = `forbid` lint level is the default for {$id}\n+lint_trivial_untranslatable_diag = diagnostic with static strings only\n \n-lint_node_source = `forbid` level set here\n-    .note = {$reason}\n+lint_ty_qualified = usage of qualified `ty::{$ty}`\n+    .suggestion = try importing it and using it unqualified\n \n-lint_command_line_source = `forbid` lint level was set on command line\n+lint_tykind = usage of `ty::TyKind`\n+    .help = try using `Ty` instead\n \n-lint_malformed_attribute = malformed lint attribute input\n+lint_tykind_kind = usage of `ty::TyKind::<kind>`\n+    .suggestion = try using `ty::<kind>` directly\n \n-lint_bad_attribute_argument = bad attribute argument\n+lint_ungated_async_fn_track_caller = `#[track_caller]` on async functions is a no-op\n+     .label = this function will not propagate the caller location\n \n-lint_reason_must_be_string_literal = reason must be a string literal\n+lint_unknown_gated_lint =\n+    unknown lint: `{$name}`\n+    .note = the `{$name}` lint is unstable\n \n-lint_reason_must_come_last = reason in lint attribute must come last\n+lint_unknown_lint =\n+    unknown lint: `{$name}`\n+    .suggestion = did you mean\n \n lint_unknown_tool_in_scoped_lint = unknown tool name `{$tool_name}` found in scoped lint: `{$tool_name}::{$lint_name}`\n     .help = add `#![register_tool({$tool_name})]` to the crate root\n \n lint_unsupported_group = `{$lint_group}` lint group is not supported with \u00b4--force-warn\u00b4\n \n-lint_requested_level = requested on the command line with `{$level} {$lint_name}`\n+lint_untranslatable_diag = diagnostics should be created using translatable messages\n \n-lint_check_name_unknown = unknown lint: `{$lint_name}`\n-    .help = did you mean: `{$suggestion}`\n+lint_unused_allocation = unnecessary allocation, use `&` instead\n+lint_unused_allocation_mut = unnecessary allocation, use `&mut` instead\n \n-lint_check_name_unknown_tool = unknown lint tool: `{$tool_name}`\n+lint_unused_closure =\n+    unused {$pre}{$count ->\n+        [one] closure\n+        *[other] closures\n+    }{$post} that must be used\n+    .note = closures are lazy and do nothing unless called\n \n-lint_check_name_warning = {$msg}\n+lint_unused_comparisons = comparison is useless due to type limits\n \n-lint_check_name_deprecated = lint name `{$lint_name}` is deprecated and does not have an effect anymore. Use: {$new_name}\n+lint_unused_def = unused {$pre}`{$def}`{$post} that must be used\n+    .suggestion = use `let _ = ...` to ignore the resulting value\n \n-lint_opaque_hidden_inferred_bound = opaque type `{$ty}` does not satisfy its associated type bounds\n-    .specifically = this associated type bound is unsatisfied for `{$proj_ty}`\n+lint_unused_delim = unnecessary {$delim} around {$item}\n+    .suggestion = remove these {$delim}\n \n-lint_opaque_hidden_inferred_bound_sugg = add this bound\n+lint_unused_generator =\n+    unused {$pre}{$count ->\n+        [one] generator\n+        *[other] generator\n+    }{$post} that must be used\n+    .note = generators are lazy and do nothing unless resumed\n \n-lint_dropping_references = calls to `std::mem::drop` with a reference instead of an owned value does nothing\n-    .label = argument has type `{$arg_ty}`\n-    .note = use `let _ = ...` to ignore the expression or result\n+lint_unused_import_braces = braces around {$node} is unnecessary\n \n-lint_dropping_copy_types = calls to `std::mem::drop` with a value that implements `Copy` does nothing\n-    .label = argument has type `{$arg_ty}`\n-    .note = use `let _ = ...` to ignore the expression or result\n+lint_unused_op = unused {$op} that must be used\n+    .label = the {$op} produces a value\n+    .suggestion = use `let _ = ...` to ignore the resulting value\n \n-lint_forgetting_references = calls to `std::mem::forget` with a reference instead of an owned value does nothing\n-    .label = argument has type `{$arg_ty}`\n-    .note = use `let _ = ...` to ignore the expression or result\n+lint_unused_result = unused result of type `{$ty}`\n \n-lint_forgetting_copy_types = calls to `std::mem::forget` with a value that implements `Copy` does nothing\n-    .label = argument has type `{$arg_ty}`\n-    .note = use `let _ = ...` to ignore the expression or result\n+lint_variant_size_differences =\n+    enum variant is more than three times larger ({$largest} bytes) than the next largest"}, {"sha": "358d412a4d8e20271e100138fa77f7e7b72743a3", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -961,7 +961,7 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n                 Some(sugared_span.map_or(attr.span, |span| span.with_hi(attr.span.hi())));\n         }\n \n-        if attrs.peek().map_or(false, |next_attr| next_attr.is_doc_comment()) {\n+        if attrs.peek().is_some_and(|next_attr| next_attr.is_doc_comment()) {\n             continue;\n         }\n "}, {"sha": "6f773e04a97d78a368f295dff4a21b641a834ec9", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -383,9 +383,8 @@ impl LateLintPass<'_> for Diagnostics {\n         debug!(?span, ?def_id, ?substs);\n         let has_attr = ty::Instance::resolve(cx.tcx, cx.param_env, def_id, substs)\n             .ok()\n-            .and_then(|inst| inst)\n-            .map(|inst| cx.tcx.has_attr(inst.def_id(), sym::rustc_lint_diagnostics))\n-            .unwrap_or(false);\n+            .flatten()\n+            .is_some_and(|inst| cx.tcx.has_attr(inst.def_id(), sym::rustc_lint_diagnostics));\n         if !has_attr {\n             return;\n         }"}, {"sha": "8a4a451f8a837377ff2f6fa4e9d2a442937b3541", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -240,8 +240,10 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        lint_callback!(self, check_arm, a);\n-        hir_visit::walk_arm(self, a);\n+        self.with_lint_attrs(a.hir_id, |cx| {\n+            lint_callback!(cx, check_arm, a);\n+            hir_visit::walk_arm(cx, a);\n+        })\n     }\n \n     fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {"}, {"sha": "b218cc5789df1f9e72303e431130be9cb253d2c8", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -128,7 +128,7 @@ fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tc\n             // No clue where this argument is coming from.\n             return lint;\n         }\n-        if arg_macro.map_or(false, |id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n+        if arg_macro.is_some_and(|id| cx.tcx.is_diagnostic_item(sym::format_macro, id)) {\n             // A case of `panic!(format!(..))`.\n             lint.note(fluent::lint_supports_fmt_note);\n             if let Some((open, close, _)) = find_delimiters(cx, arg_span) {"}, {"sha": "4bf4fda8292b629671ef26d47c583ff62fda212e", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -677,7 +677,7 @@ pub fn transparent_newtype_field<'a, 'tcx>(\n     let param_env = tcx.param_env(variant.def_id);\n     variant.fields.iter().find(|field| {\n         let field_ty = tcx.type_of(field.did).subst_identity();\n-        let is_zst = tcx.layout_of(param_env.and(field_ty)).map_or(false, |layout| layout.is_zst());\n+        let is_zst = tcx.layout_of(param_env.and(field_ty)).is_ok_and(|layout| layout.is_zst());\n         !is_zst\n     })\n }"}, {"sha": "8f75fa11dd9a2e70cf73f7b174b591994f577f95", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -664,8 +664,8 @@ trait UnusedDelimLint {\n             _ => return,\n         };\n         let keep_space = (\n-            left_pos.map_or(false, |s| s >= value.span.lo()),\n-            right_pos.map_or(false, |s| s <= value.span.hi()),\n+            left_pos.is_some_and(|s| s >= value.span.lo()),\n+            right_pos.is_some_and(|s| s <= value.span.hi()),\n         );\n         self.emit_unused_delims(cx, value.span, spans, ctx.into(), keep_space);\n     }"}, {"sha": "6d8601b9e2bc5e1ce4d1a936c22df3e91f94032a", "filename": "compiler/rustc_metadata/messages.ftl", "status": "modified", "additions": 191, "deletions": 191, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,288 +1,288 @@\n-metadata_rlib_required =\n-    crate `{$crate_name}` required to be available in rlib format, but was not found in this form\n-\n-metadata_lib_required =\n-    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n+metadata_as_needed_compatibility =\n+    linking modifier `as-needed` is only compatible with `dylib` and `framework` linking kinds\n \n-metadata_rustc_lib_required =\n-    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n-    .note = only .rmeta files are distributed for `rustc_private` crates other than `rustc_driver`\n-    .help = try adding `extern crate rustc_driver;` at the top level of this crate\n+metadata_bad_panic_strategy =\n+    the linked panic runtime `{$runtime}` is not compiled with this crate's panic strategy `{$strategy}`\n \n-metadata_crate_dep_multiple =\n-    cannot satisfy dependencies so `{$crate_name}` only shows up once\n-    .help = having upstream crates all available in one format will likely make this go away\n+metadata_bundle_needs_static =\n+    linking modifier `bundle` is only compatible with `static` linking kind\n \n-metadata_two_panic_runtimes =\n-    cannot link together two panic runtimes: {$prev_name} and {$cur_name}\n+metadata_cannot_find_crate =\n+    can't find crate for `{$crate_name}`{$add_info}\n \n-metadata_bad_panic_strategy =\n-    the linked panic runtime `{$runtime}` is not compiled with this crate's panic strategy `{$strategy}`\n+metadata_cant_find_crate =\n+    can't find crate\n \n-metadata_required_panic_strategy =\n-    the crate `{$crate_name}` requires panic strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+metadata_compiler_missing_profiler =\n+    the compiler may have been built without the profiler runtime\n \n-metadata_incompatible_panic_in_drop_strategy =\n-    the crate `{$crate_name}` is compiled with the panic-in-drop strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+metadata_conflicting_alloc_error_handler =\n+    the `#[alloc_error_handler]` in {$other_crate_name} conflicts with allocation error handler in: {$crate_name}\n \n-metadata_multiple_names_in_link =\n-    multiple `name` arguments in a single `#[link]` attribute\n+metadata_conflicting_global_alloc =\n+    the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n \n-metadata_multiple_kinds_in_link =\n-    multiple `kind` arguments in a single `#[link]` attribute\n+metadata_consider_building_std =\n+    consider building the standard library from source with `cargo build -Zbuild-std`\n \n-metadata_link_name_form =\n-    link name must be of the form `name = \"string\"`\n+metadata_consider_downloading_target =\n+    consider downloading the target with `rustup target add {$locator_triple}`\n \n-metadata_link_kind_form =\n-    link kind must be of the form `kind = \"string\"`\n+metadata_crate_dep_multiple =\n+    cannot satisfy dependencies so `{$crate_name}` only shows up once\n+    .help = having upstream crates all available in one format will likely make this go away\n \n-metadata_link_modifiers_form =\n-    link modifiers must be of the form `modifiers = \"string\"`\n+metadata_crate_location_unknown_type =\n+    extern location for {$crate_name} is of an unknown type: {$path}\n \n-metadata_link_cfg_form =\n-    link cfg must be of the form `cfg(/* predicate */)`\n+metadata_crate_not_panic_runtime =\n+    the crate `{$crate_name}` is not a panic runtime\n \n-metadata_wasm_import_form =\n-    wasm import module must be of the form `wasm_import_module = \"string\"`\n+metadata_dl_error =\n+    {$err}\n \n metadata_empty_link_name =\n     link name must not be empty\n     .label = empty link name\n \n-metadata_link_framework_apple =\n-    link kind `framework` is only supported on Apple targets\n+metadata_empty_renaming_target =\n+    an empty renaming target was specified for library `{$lib_name}`\n \n-metadata_framework_only_windows =\n-    link kind `raw-dylib` is only supported on Windows targets\n+metadata_extern_location_not_exist =\n+    extern location for {$crate_name} does not exist: {$location}\n \n-metadata_unknown_link_kind =\n-    unknown link kind `{$kind}`, expected one of: static, dylib, framework, raw-dylib\n-    .label = unknown link kind\n+metadata_extern_location_not_file =\n+    extern location for {$crate_name} is not a file: {$location}\n \n-metadata_multiple_link_modifiers =\n-    multiple `modifiers` arguments in a single `#[link]` attribute\n+metadata_fail_create_file_encoder =\n+    failed to create file encoder: {$err}\n \n-metadata_multiple_cfgs =\n-    multiple `cfg` arguments in a single `#[link]` attribute\n+metadata_fail_seek_file =\n+    failed to seek the file: {$err}\n \n-metadata_link_cfg_single_predicate =\n-    link cfg must have a single predicate argument\n+metadata_fail_write_file =\n+    failed to write to the file: {$err}\n \n-metadata_multiple_wasm_import =\n-    multiple `wasm_import_module` arguments in a single `#[link]` attribute\n+metadata_failed_create_encoded_metadata =\n+    failed to create encoded metadata from file: {$err}\n \n-metadata_unexpected_link_arg =\n-    unexpected `#[link]` argument, expected one of: name, kind, modifiers, cfg, wasm_import_module, import_name_type\n+metadata_failed_create_file =\n+    failed to create the file {$filename}: {$err}\n \n-metadata_invalid_link_modifier =\n-    invalid linking modifier syntax, expected '+' or '-' prefix before one of: bundle, verbatim, whole-archive, as-needed\n+metadata_failed_create_tempdir =\n+    couldn't create a temp dir: {$err}\n \n-metadata_multiple_modifiers =\n-    multiple `{$modifier}` modifiers in a single `modifiers` argument\n+metadata_failed_write_error =\n+    failed to write {$filename}: {$err}\n \n-metadata_bundle_needs_static =\n-    linking modifier `bundle` is only compatible with `static` linking kind\n+metadata_found_crate_versions =\n+    the following crate versions were found:{$found_crates}\n \n-metadata_whole_archive_needs_static =\n-    linking modifier `whole-archive` is only compatible with `static` linking kind\n+metadata_found_staticlib =\n+    found staticlib `{$crate_name}` instead of rlib or dylib{$add_info}\n+    .help = please recompile that crate using --crate-type lib\n \n-metadata_as_needed_compatibility =\n-    linking modifier `as-needed` is only compatible with `dylib` and `framework` linking kinds\n+metadata_framework_only_windows =\n+    link kind `raw-dylib` is only supported on Windows targets\n \n-metadata_unknown_link_modifier =\n-    unknown linking modifier `{$modifier}`, expected one of: bundle, verbatim, whole-archive, as-needed\n+metadata_global_alloc_required =\n+    no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n+\n+metadata_import_name_type_form =\n+    import name type must be of the form `import_name_type = \"string\"`\n+\n+metadata_import_name_type_raw =\n+    import name type can only be used with link kind `raw-dylib`\n+\n+metadata_import_name_type_x86 =\n+    import name type is only supported on x86\n+\n+metadata_incompatible_panic_in_drop_strategy =\n+    the crate `{$crate_name}` is compiled with the panic-in-drop strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n+\n+metadata_incompatible_rustc =\n+    found crate `{$crate_name}` compiled by an incompatible version of rustc{$add_info}\n+    .help = please recompile that crate using this compiler ({$rustc_version}) (consider running `cargo clean` first)\n \n metadata_incompatible_wasm_link =\n     `wasm_import_module` is incompatible with other arguments in `#[link]` attributes\n \n-metadata_link_requires_name =\n-    `#[link]` attribute requires a `name = \"string\"` argument\n-    .label = missing `name` argument\n+metadata_install_missing_components =\n+    maybe you need to install the missing components with: `rustup component add rust-src rustc-dev llvm-tools-preview`\n \n-metadata_raw_dylib_no_nul =\n-    link name must not contain NUL characters if link kind is `raw-dylib`\n+metadata_invalid_link_modifier =\n+    invalid linking modifier syntax, expected '+' or '-' prefix before one of: bundle, verbatim, whole-archive, as-needed\n \n-metadata_link_ordinal_raw_dylib =\n-    `#[link_ordinal]` is only supported if link kind is `raw-dylib`\n+metadata_invalid_meta_files =\n+    found invalid metadata files for crate `{$crate_name}`{$add_info}\n+\n+metadata_lib_filename_form =\n+    file name should be lib*.rlib or {$dll_prefix}*{$dll_suffix}\n \n metadata_lib_framework_apple =\n     library kind `framework` is only supported on Apple targets\n \n-metadata_empty_renaming_target =\n-    an empty renaming target was specified for library `{$lib_name}`\n+metadata_lib_required =\n+    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n \n-metadata_renaming_no_link =\n-    renaming of the library `{$lib_name}` was specified, however this crate contains no `#[link(...)]` attributes referencing this library\n+metadata_link_cfg_form =\n+    link cfg must be of the form `cfg(/* predicate */)`\n \n-metadata_multiple_renamings =\n-    multiple renamings were specified for library `{$lib_name}`\n+metadata_link_cfg_single_predicate =\n+    link cfg must have a single predicate argument\n \n-metadata_no_link_mod_override =\n-    overriding linking modifiers from command line is not supported\n+metadata_link_framework_apple =\n+    link kind `framework` is only supported on Apple targets\n \n-metadata_unsupported_abi_i686 =\n-    ABI not supported by `#[link(kind = \"raw-dylib\")]` on i686\n+metadata_link_kind_form =\n+    link kind must be of the form `kind = \"string\"`\n \n-metadata_unsupported_abi =\n-    ABI not supported by `#[link(kind = \"raw-dylib\")]` on this architecture\n+metadata_link_modifiers_form =\n+    link modifiers must be of the form `modifiers = \"string\"`\n \n-metadata_fail_create_file_encoder =\n-    failed to create file encoder: {$err}\n+metadata_link_name_form =\n+    link name must be of the form `name = \"string\"`\n \n-metadata_fail_seek_file =\n-    failed to seek the file: {$err}\n+metadata_link_ordinal_raw_dylib =\n+    `#[link_ordinal]` is only supported if link kind is `raw-dylib`\n \n-metadata_fail_write_file =\n-    failed to write to the file: {$err}\n+metadata_link_requires_name =\n+    `#[link]` attribute requires a `name = \"string\"` argument\n+    .label = missing `name` argument\n \n-metadata_crate_not_panic_runtime =\n-    the crate `{$crate_name}` is not a panic runtime\n+metadata_missing_native_library =\n+    could not find native static library `{$libname}`, perhaps an -L flag is missing?\n \n-metadata_no_panic_strategy =\n-    the crate `{$crate_name}` does not have the panic strategy `{$strategy}`\n+metadata_multiple_candidates =\n+    multiple candidates for `{$flavor}` dependency `{$crate_name}` found\n \n-metadata_profiler_builtins_needs_core =\n-    `profiler_builtins` crate (required by compiler options) is not compatible with crate attribute `#![no_core]`\n+metadata_multiple_cfgs =\n+    multiple `cfg` arguments in a single `#[link]` attribute\n \n-metadata_not_profiler_runtime =\n-    the crate `{$crate_name}` is not a profiler runtime\n+metadata_multiple_import_name_type =\n+    multiple `import_name_type` arguments in a single `#[link]` attribute\n \n-metadata_no_multiple_global_alloc =\n-    cannot define multiple global allocators\n-    .label = cannot define a new global allocator\n+metadata_multiple_kinds_in_link =\n+    multiple `kind` arguments in a single `#[link]` attribute\n \n-metadata_prev_global_alloc =\n-    previous global allocator defined here\n+metadata_multiple_link_modifiers =\n+    multiple `modifiers` arguments in a single `#[link]` attribute\n \n-metadata_no_multiple_alloc_error_handler =\n-    cannot define multiple allocation error handlers\n-    .label = cannot define a new allocation error handler\n+metadata_multiple_modifiers =\n+    multiple `{$modifier}` modifiers in a single `modifiers` argument\n \n-metadata_prev_alloc_error_handler =\n-    previous allocation error handler defined here\n+metadata_multiple_names_in_link =\n+    multiple `name` arguments in a single `#[link]` attribute\n \n-metadata_conflicting_global_alloc =\n-    the `#[global_allocator]` in {$other_crate_name} conflicts with global allocator in: {$crate_name}\n+metadata_multiple_renamings =\n+    multiple renamings were specified for library `{$lib_name}`\n \n-metadata_conflicting_alloc_error_handler =\n-    the `#[alloc_error_handler]` in {$other_crate_name} conflicts with allocation error handler in: {$crate_name}\n+metadata_multiple_wasm_import =\n+    multiple `wasm_import_module` arguments in a single `#[link]` attribute\n \n-metadata_global_alloc_required =\n-    no global memory allocator found but one is required; link to std or add `#[global_allocator]` to a static item that implements the GlobalAlloc trait\n+metadata_newer_crate_version =\n+    found possibly newer version of crate `{$crate_name}`{$add_info}\n+    .note = perhaps that crate needs to be recompiled?\n \n-metadata_no_transitive_needs_dep =\n-    the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`\n+metadata_no_crate_with_triple =\n+    couldn't find crate `{$crate_name}` with expected target triple {$locator_triple}{$add_info}\n \n-metadata_failed_write_error =\n-    failed to write {$filename}: {$err}\n+metadata_no_dylib_plugin =\n+    plugin `{$crate_name}` only found in rlib format, but must be available in dylib format\n \n-metadata_missing_native_library =\n-    could not find native static library `{$libname}`, perhaps an -L flag is missing?\n+metadata_no_link_mod_override =\n+    overriding linking modifiers from command line is not supported\n \n-metadata_only_provide_library_name = only provide the library name `{$suggested_name}`, not the full filename\n+metadata_no_multiple_alloc_error_handler =\n+    cannot define multiple allocation error handlers\n+    .label = cannot define a new allocation error handler\n \n-metadata_failed_create_tempdir =\n-    couldn't create a temp dir: {$err}\n+metadata_no_multiple_global_alloc =\n+    cannot define multiple global allocators\n+    .label = cannot define a new global allocator\n \n-metadata_failed_create_file =\n-    failed to create the file {$filename}: {$err}\n+metadata_no_panic_strategy =\n+    the crate `{$crate_name}` does not have the panic strategy `{$strategy}`\n \n-metadata_failed_create_encoded_metadata =\n-    failed to create encoded metadata from file: {$err}\n+metadata_no_transitive_needs_dep =\n+    the crate `{$crate_name}` cannot depend on a crate that needs {$needs_crate_name}, but it depends on `{$deps_crate_name}`\n \n metadata_non_ascii_name =\n     cannot load a crate with a non-ascii name `{$crate_name}`\n \n-metadata_extern_location_not_exist =\n-    extern location for {$crate_name} does not exist: {$location}\n-\n-metadata_extern_location_not_file =\n-    extern location for {$crate_name} is not a file: {$location}\n-\n-metadata_multiple_candidates =\n-    multiple candidates for `{$flavor}` dependency `{$crate_name}` found\n+metadata_not_profiler_runtime =\n+    the crate `{$crate_name}` is not a profiler runtime\n \n-metadata_symbol_conflicts_current =\n-    the current crate is indistinguishable from one of its dependencies: it has the same crate-name `{$crate_name}` and was compiled with the same `-C metadata` arguments. This will result in symbol conflicts between the two.\n+metadata_only_provide_library_name = only provide the library name `{$suggested_name}`, not the full filename\n \n-metadata_symbol_conflicts_others =\n-    found two different crates with name `{$crate_name}` that are not distinguished by differing `-C metadata`. This will result in symbol conflicts between the two.\n+metadata_prev_alloc_error_handler =\n+    previous allocation error handler defined here\n \n-metadata_stable_crate_id_collision =\n-    found crates (`{$crate_name0}` and `{$crate_name1}`) with colliding StableCrateId values.\n+metadata_prev_global_alloc =\n+    previous global allocator defined here\n \n-metadata_dl_error =\n-    {$err}\n+metadata_profiler_builtins_needs_core =\n+    `profiler_builtins` crate (required by compiler options) is not compatible with crate attribute `#![no_core]`\n \n-metadata_newer_crate_version =\n-    found possibly newer version of crate `{$crate_name}`{$add_info}\n-    .note = perhaps that crate needs to be recompiled?\n+metadata_raw_dylib_no_nul =\n+    link name must not contain NUL characters if link kind is `raw-dylib`\n \n-metadata_found_crate_versions =\n-    the following crate versions were found:{$found_crates}\n+metadata_renaming_no_link =\n+    renaming of the library `{$lib_name}` was specified, however this crate contains no `#[link(...)]` attributes referencing this library\n \n-metadata_no_crate_with_triple =\n-    couldn't find crate `{$crate_name}` with expected target triple {$locator_triple}{$add_info}\n+metadata_required_panic_strategy =\n+    the crate `{$crate_name}` requires panic strategy `{$found_strategy}` which is incompatible with this crate's strategy of `{$desired_strategy}`\n \n-metadata_found_staticlib =\n-    found staticlib `{$crate_name}` instead of rlib or dylib{$add_info}\n-    .help = please recompile that crate using --crate-type lib\n+metadata_rlib_required =\n+    crate `{$crate_name}` required to be available in rlib format, but was not found in this form\n \n-metadata_incompatible_rustc =\n-    found crate `{$crate_name}` compiled by an incompatible version of rustc{$add_info}\n-    .help = please recompile that crate using this compiler ({$rustc_version}) (consider running `cargo clean` first)\n+metadata_rustc_lib_required =\n+    crate `{$crate_name}` required to be available in {$kind} format, but was not found in this form\n+    .note = only .rmeta files are distributed for `rustc_private` crates other than `rustc_driver`\n+    .help = try adding `extern crate rustc_driver;` at the top level of this crate\n \n-metadata_invalid_meta_files =\n-    found invalid metadata files for crate `{$crate_name}`{$add_info}\n+metadata_stable_crate_id_collision =\n+    found crates (`{$crate_name0}` and `{$crate_name1}`) with colliding StableCrateId values.\n \n-metadata_cannot_find_crate =\n-    can't find crate for `{$crate_name}`{$add_info}\n+metadata_std_required =\n+    `std` is required by `{$current_crate}` because it does not declare `#![no_std]`\n \n-metadata_no_dylib_plugin =\n-    plugin `{$crate_name}` only found in rlib format, but must be available in dylib format\n+metadata_symbol_conflicts_current =\n+    the current crate is indistinguishable from one of its dependencies: it has the same crate-name `{$crate_name}` and was compiled with the same `-C metadata` arguments. This will result in symbol conflicts between the two.\n \n-metadata_target_not_installed =\n-    the `{$locator_triple}` target may not be installed\n+metadata_symbol_conflicts_others =\n+    found two different crates with name `{$crate_name}` that are not distinguished by differing `-C metadata`. This will result in symbol conflicts between the two.\n \n metadata_target_no_std_support =\n     the `{$locator_triple}` target may not support the standard library\n \n-metadata_consider_downloading_target =\n-    consider downloading the target with `rustup target add {$locator_triple}`\n-\n-metadata_std_required =\n-    `std` is required by `{$current_crate}` because it does not declare `#![no_std]`\n-\n-metadata_consider_building_std =\n-    consider building the standard library from source with `cargo build -Zbuild-std`\n-\n-metadata_compiler_missing_profiler =\n-    the compiler may have been built without the profiler runtime\n+metadata_target_not_installed =\n+    the `{$locator_triple}` target may not be installed\n \n-metadata_install_missing_components =\n-    maybe you need to install the missing components with: `rustup component add rust-src rustc-dev llvm-tools-preview`\n+metadata_two_panic_runtimes =\n+    cannot link together two panic runtimes: {$prev_name} and {$cur_name}\n \n-metadata_cant_find_crate =\n-    can't find crate\n+metadata_unexpected_link_arg =\n+    unexpected `#[link]` argument, expected one of: name, kind, modifiers, cfg, wasm_import_module, import_name_type\n \n-metadata_crate_location_unknown_type =\n-    extern location for {$crate_name} is of an unknown type: {$path}\n+metadata_unknown_import_name_type =\n+    unknown import name type `{$import_name_type}`, expected one of: decorated, noprefix, undecorated\n \n-metadata_lib_filename_form =\n-    file name should be lib*.rlib or {$dll_prefix}*{$dll_suffix}\n+metadata_unknown_link_kind =\n+    unknown link kind `{$kind}`, expected one of: static, dylib, framework, raw-dylib\n+    .label = unknown link kind\n \n-metadata_multiple_import_name_type =\n-    multiple `import_name_type` arguments in a single `#[link]` attribute\n+metadata_unknown_link_modifier =\n+    unknown linking modifier `{$modifier}`, expected one of: bundle, verbatim, whole-archive, as-needed\n \n-metadata_import_name_type_form =\n-    import name type must be of the form `import_name_type = \"string\"`\n+metadata_unsupported_abi =\n+    ABI not supported by `#[link(kind = \"raw-dylib\")]` on this architecture\n \n-metadata_import_name_type_x86 =\n-    import name type is only supported on x86\n+metadata_unsupported_abi_i686 =\n+    ABI not supported by `#[link(kind = \"raw-dylib\")]` on i686\n \n-metadata_unknown_import_name_type =\n-    unknown import name type `{$import_name_type}`, expected one of: decorated, noprefix, undecorated\n+metadata_wasm_import_form =\n+    wasm import module must be of the form `wasm_import_module = \"string\"`\n \n-metadata_import_name_type_raw =\n-    import name type can only be used with link kind `raw-dylib`\n+metadata_whole_archive_needs_static =\n+    linking modifier `whole-archive` is only compatible with `static` linking kind"}, {"sha": "aaf72ab94e71123920c9d5fa20e4cfac0b342fb6", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -4,7 +4,7 @@ use crate::errors;\n use crate::locator::{CrateError, CrateLocator, CratePaths};\n use crate::rmeta::{CrateDep, CrateMetadata, CrateNumMap, CrateRoot, MetadataBlob};\n \n-use rustc_ast::expand::allocator::AllocatorKind;\n+use rustc_ast::expand::allocator::{alloc_error_handler_name, global_fn_name, AllocatorKind};\n use rustc_ast::{self as ast, *};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::svh::Svh;\n@@ -148,11 +148,15 @@ impl CStore {\n         assert_eq!(self.metas.len(), self.stable_crate_ids.len());\n         let num = CrateNum::new(self.stable_crate_ids.len());\n         if let Some(&existing) = self.stable_crate_ids.get(&root.stable_crate_id()) {\n-            let crate_name0 = root.name();\n-            if let Some(crate_name1) = self.metas[existing].as_ref().map(|data| data.name()) {\n+            // Check for (potential) conflicts with the local crate\n+            if existing == LOCAL_CRATE {\n+                Err(CrateError::SymbolConflictsCurrent(root.name()))\n+            } else if let Some(crate_name1) = self.metas[existing].as_ref().map(|data| data.name())\n+            {\n+                let crate_name0 = root.name();\n                 Err(CrateError::StableCrateIdCollision(crate_name0, crate_name1))\n             } else {\n-                Err(CrateError::SymbolConflictsCurrent(crate_name0))\n+                Err(CrateError::NotFound(root.name()))\n             }\n         } else {\n             self.metas.push(None);\n@@ -369,7 +373,7 @@ impl<'a, 'tcx> CrateLoader<'a, 'tcx> {\n         let host_hash = host_lib.as_ref().map(|lib| lib.metadata.get_root().hash());\n \n         let private_dep =\n-            self.sess.opts.externs.get(name.as_str()).map_or(false, |e| e.is_private_dep);\n+            self.sess.opts.externs.get(name.as_str()).is_some_and(|e| e.is_private_dep);\n \n         // Claim this crate number and cache it\n         let cnum = self.cstore.intern_stable_crate_id(&crate_root)?;\n@@ -1044,7 +1048,7 @@ fn global_allocator_spans(krate: &ast::Crate) -> Vec<Span> {\n         }\n     }\n \n-    let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::alloc));\n+    let name = Symbol::intern(&global_fn_name(sym::alloc));\n     let mut f = Finder { name, spans: Vec::new() };\n     visit::walk_crate(&mut f, krate);\n     f.spans\n@@ -1066,7 +1070,7 @@ fn alloc_error_handler_spans(krate: &ast::Crate) -> Vec<Span> {\n         }\n     }\n \n-    let name = Symbol::intern(&AllocatorKind::Global.fn_name(sym::oom));\n+    let name = Symbol::intern(alloc_error_handler_name(AllocatorKind::Global));\n     let mut f = Finder { name, spans: Vec::new() };\n     visit::walk_crate(&mut f, krate);\n     f.spans"}, {"sha": "ceb348f34690e307eae30302d55406886169ad77", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -567,7 +567,7 @@ impl<'a> CrateLocator<'a> {\n         let mut err_data: Option<Vec<PathBuf>> = None;\n         for (lib, kind) in m {\n             info!(\"{} reading metadata from: {}\", flavor, lib.display());\n-            if flavor == CrateFlavor::Rmeta && lib.metadata().map_or(false, |m| m.len() == 0) {\n+            if flavor == CrateFlavor::Rmeta && lib.metadata().is_ok_and(|m| m.len() == 0) {\n                 // Empty files will cause get_metadata_section to fail. Rmeta\n                 // files can be empty, for example with binaries (which can\n                 // often appear with `cargo check` when checking a library as\n@@ -602,7 +602,7 @@ impl<'a> CrateLocator<'a> {\n                     }\n                 };\n             // If we see multiple hashes, emit an error about duplicate candidates.\n-            if slot.as_ref().map_or(false, |s| s.0 != hash) {\n+            if slot.as_ref().is_some_and(|s| s.0 != hash) {\n                 if let Some(candidates) = err_data {\n                     return Err(CrateError::MultipleCandidates(\n                         self.crate_name,\n@@ -961,6 +961,7 @@ pub(crate) enum CrateError {\n     DlSym(String),\n     LocatorCombined(Box<CombinedLocatorError>),\n     NonDylibPlugin(Symbol),\n+    NotFound(Symbol),\n }\n \n enum MetadataError<'a> {\n@@ -1131,6 +1132,18 @@ impl CrateError {\n             CrateError::NonDylibPlugin(crate_name) => {\n                 sess.emit_err(errors::NoDylibPlugin { span, crate_name });\n             }\n+            CrateError::NotFound(crate_name) => {\n+                sess.emit_err(errors::CannotFindCrate {\n+                    span,\n+                    crate_name,\n+                    add_info: String::new(),\n+                    missing_core,\n+                    current_crate: sess.opts.crate_name.clone().unwrap_or(\"<unknown>\".to_string()),\n+                    is_nightly_build: sess.is_nightly_build(),\n+                    profiler_runtime: Symbol::intern(&sess.opts.unstable_opts.profiler_runtime),\n+                    locator_triple: sess.opts.target_triple.clone(),\n+                });\n+            }\n         }\n     }\n }"}, {"sha": "cc4e60cf6ac589d9e3e83e7a0fe0b7e61bd40a84", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1060,7 +1060,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .expect(\"argument names not encoded for a function\")\n             .decode((self, sess))\n             .nth(0)\n-            .map_or(false, |ident| ident.name == kw::SelfLower)\n+            .is_some_and(|ident| ident.name == kw::SelfLower)\n     }\n \n     fn get_associated_item_or_field_def_ids("}, {"sha": "7425963d30ff811b7a93dd99a6e40cb694d71ba3", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -323,7 +323,7 @@ provide! { tcx, def_id, other, cdata,\n \n     extra_filename => { cdata.root.extra_filename.clone() }\n \n-    traits_in_crate => { tcx.arena.alloc_from_iter(cdata.get_traits()) }\n+    traits => { tcx.arena.alloc_from_iter(cdata.get_traits()) }\n     trait_impls_in_crate => { tcx.arena.alloc_from_iter(cdata.get_trait_impls()) }\n     implementations_of_trait => { cdata.get_implementations_of_trait(tcx, other) }\n     crate_incoherent_impls => { cdata.get_incoherent_impls(tcx, other) }"}, {"sha": "f067bca4b0b396846f1837c3da0014eefeabb7ec", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1938,7 +1938,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_traits(&mut self) -> LazyArray<DefIndex> {\n         empty_proc_macro!(self);\n-        self.lazy_array(self.tcx.traits_in_crate(LOCAL_CRATE).iter().map(|def_id| def_id.index))\n+        self.lazy_array(self.tcx.traits(LOCAL_CRATE).iter().map(|def_id| def_id.index))\n     }\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n@@ -2329,7 +2329,7 @@ pub fn provide(providers: &mut Providers) {\n                 .get(&def_id)\n                 .expect(\"no traits in scope for a doc link\")\n         },\n-        traits_in_crate: |tcx, LocalCrate| {\n+        traits: |tcx, LocalCrate| {\n             let mut traits = Vec::new();\n             for id in tcx.hir().items() {\n                 if matches!(tcx.def_kind(id.owner_id), DefKind::Trait | DefKind::TraitAlias) {"}, {"sha": "3d581daa9259d2ffa11cea81f11e858af8e029a5", "filename": "compiler/rustc_middle/messages.ftl", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,45 +1,45 @@\n+middle_cannot_be_normalized =\n+    unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized\n+\n+middle_conflict_types =\n+    this expression supplies two conflicting concrete types for the same opaque type\n+\n+middle_const_eval_non_int =\n+    constant evaluation of enum discriminant resulted in non-integer\n+\n+middle_const_not_used_in_type_alias =\n+    const parameter `{$ct}` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+\n+middle_cycle =\n+    a cycle occurred during layout computation\n+\n middle_drop_check_overflow =\n     overflow while adding drop-check rules for {$ty}\n     .note = overflowed on {$overflow_ty}\n \n+middle_limit_invalid =\n+    `limit` must be a non-negative integer\n+    .label = {$error_str}\n+\n middle_opaque_hidden_type_mismatch =\n     concrete type differs from previous defining opaque type use\n     .label = expected `{$self_ty}`, got `{$other_ty}`\n \n-middle_conflict_types =\n-    this expression supplies two conflicting concrete types for the same opaque type\n-\n middle_previous_use_here =\n     previous use here\n \n-middle_limit_invalid =\n-    `limit` must be a non-negative integer\n-    .label = {$error_str}\n-\n middle_recursion_limit_reached =\n     reached the recursion limit finding the struct tail for `{$ty}`\n     .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]`\n \n-middle_const_eval_non_int =\n-    constant evaluation of enum discriminant resulted in non-integer\n-\n-middle_unknown_layout =\n-    the type `{$ty}` has an unknown layout\n-\n-middle_values_too_big =\n-    values of the type `{$ty}` are too big for the current architecture\n-\n-middle_cannot_be_normalized =\n-    unable to determine layout for `{$ty}` because `{$failure_ty}` cannot be normalized\n-\n-middle_cycle =\n-    a cycle occurred during layout computation\n+middle_requires_lang_item = requires `{$name}` lang_item\n \n middle_strict_coherence_needs_negative_coherence =\n     to use `strict_coherence` on this trait, the `with_negative_coherence` feature must be enabled\n     .label = due to this attribute\n \n-middle_requires_lang_item = requires `{$name}` lang_item\n+middle_unknown_layout =\n+    the type `{$ty}` has an unknown layout\n \n-middle_const_not_used_in_type_alias =\n-    const parameter `{$ct}` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n+middle_values_too_big =\n+    values of the type `{$ty}` are too big for the current architecture"}, {"sha": "a149a61ec136e0feb2c15ed7e59e65f66d298773", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -121,6 +121,7 @@ macro_rules! arena_types {\n                 >,\n             [] bit_set_u32: rustc_index::bit_set::BitSet<u32>,\n             [] external_constraints: rustc_middle::traits::solve::ExternalConstraintsData<'tcx>,\n+            [] predefined_opaques_in_body: rustc_middle::traits::solve::PredefinedOpaquesData<'tcx>,\n             [decode] doc_link_resolutions: rustc_hir::def::DocLinkResMap,\n             [] closure_kind_origin: (rustc_span::Span, rustc_middle::hir::place::Place<'tcx>),\n             [] mod_child: rustc_middle::metadata::ModChild,"}, {"sha": "d1ddc8fc1fd2e38ff483b28b05d6e6be06af7bbf", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -410,7 +410,7 @@ impl<'hir> Map<'hir> {\n     /// item (possibly associated), a closure, or a `hir::AnonConst`.\n     pub fn body_owner(self, BodyId { hir_id }: BodyId) -> HirId {\n         let parent = self.parent_id(hir_id);\n-        assert!(self.find(parent).map_or(false, |n| is_body_owner(n, hir_id)), \"{hir_id:?}\");\n+        assert!(self.find(parent).is_some_and(|n| is_body_owner(n, hir_id)), \"{hir_id:?}\");\n         parent\n     }\n "}, {"sha": "45a07fdd29327ba54417f025ef61bbded1dc8fd6", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -115,7 +115,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Returns `true` if this is a foreign item (i.e., linked via `extern { ... }`).\n     pub fn is_foreign_item(self, def_id: impl Into<DefId>) -> bool {\n         self.opt_parent(def_id.into())\n-            .map_or(false, |parent| matches!(self.def_kind(parent), DefKind::ForeignMod))\n+            .is_some_and(|parent| matches!(self.def_kind(parent), DefKind::ForeignMod))\n     }\n }\n "}, {"sha": "14343ac1108b2dfb1269e57b61aa616d6d2c0e2e", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -468,8 +468,7 @@ pub fn struct_lint_level(\n pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n-        ExpnKind::Inlined\n-        | ExpnKind::Root\n+        ExpnKind::Root\n         | ExpnKind::Desugaring(\n             DesugaringKind::ForLoop | DesugaringKind::WhileLoop | DesugaringKind::OpaqueTy,\n         ) => false,"}, {"sha": "f45cf788dd91cf24ee2962e0d6b8b6b2c2849060", "filename": "compiler/rustc_middle/src/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fprivacy.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -94,8 +94,7 @@ pub struct EffectiveVisibilities<Id = LocalDefId> {\n \n impl EffectiveVisibilities {\n     pub fn is_public_at_level(&self, id: LocalDefId, level: Level) -> bool {\n-        self.effective_vis(id)\n-            .map_or(false, |effective_vis| effective_vis.is_public_at_level(level))\n+        self.effective_vis(id).is_some_and(|effective_vis| effective_vis.is_public_at_level(level))\n     }\n \n     /// See `Level::Reachable`."}, {"sha": "6354c0aabde7c9b1325bb36ea6253ff568272155", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -375,7 +375,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let parent_def_id = self.hir().get_parent_item(id);\n                 let skip = self\n                     .lookup_deprecation_entry(parent_def_id.to_def_id())\n-                    .map_or(false, |parent_depr| parent_depr.same_origin(&depr_entry));\n+                    .is_some_and(|parent_depr| parent_depr.same_origin(&depr_entry));\n \n                 // #[deprecated] doesn't emit a notice if we're not on the\n                 // topmost deprecation. For example, if a struct is deprecated,"}, {"sha": "9d70dbfa0722120bc7f01738abd2ecc5e82242ab", "filename": "compiler/rustc_middle/src/mir/basic_blocks.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fbasic_blocks.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -27,6 +27,7 @@ struct Cache {\n     switch_sources: OnceCell<SwitchSources>,\n     is_cyclic: OnceCell<bool>,\n     postorder: OnceCell<Vec<BasicBlock>>,\n+    dominators: OnceCell<Dominators<BasicBlock>>,\n }\n \n impl<'tcx> BasicBlocks<'tcx> {\n@@ -41,8 +42,8 @@ impl<'tcx> BasicBlocks<'tcx> {\n         *self.cache.is_cyclic.get_or_init(|| graph::is_cyclic(self))\n     }\n \n-    pub fn dominators(&self) -> Dominators<BasicBlock> {\n-        dominators(&self)\n+    pub fn dominators(&self) -> &Dominators<BasicBlock> {\n+        self.cache.dominators.get_or_init(|| dominators(self))\n     }\n \n     /// Returns predecessors for each basic block."}, {"sha": "f31b343c94704bc2ba3bbf22483d1209eb67c29c", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -334,10 +334,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn modify_size_estimate(&mut self, delta: usize) {\n-        assert!(self.size_estimate.is_some());\n-        if let Some(size_estimate) = self.size_estimate {\n-            self.size_estimate = Some(size_estimate + delta);\n-        }\n+        *self.size_estimate.as_mut().unwrap() += delta;\n     }\n \n     pub fn contains_item(&self, item: &MonoItem<'tcx>) -> bool {"}, {"sha": "1528be42f6a188251c9b8bb14e2e0b6cd6aae639", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -38,7 +38,10 @@ use crate::traits::query::{\n     OutlivesBound,\n };\n use crate::traits::specialization_graph;\n-use crate::traits::{self, ImplSource};\n+use crate::traits::{\n+    CanonicalChalkEnvironmentAndGoal, CodegenObligationError, EvaluationResult, ImplSource,\n+    ObjectSafetyViolation, ObligationCause, OverflowError, WellFormedLoc,\n+};\n use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::layout::ValidityRequirement;\n use crate::ty::subst::{GenericArg, SubstsRef};\n@@ -1273,7 +1276,7 @@ rustc_queries! {\n \n     query codegen_select_candidate(\n         key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n-    ) -> Result<&'tcx ImplSource<'tcx, ()>, traits::CodegenObligationError> {\n+    ) -> Result<&'tcx ImplSource<'tcx, ()>, CodegenObligationError> {\n         cache_on_disk_if { true }\n         desc { |tcx| \"computing candidate for `{}`\", key.1 }\n     }\n@@ -1294,7 +1297,7 @@ rustc_queries! {\n         desc { |tcx| \"building specialization graph of trait `{}`\", tcx.def_path_str(trait_id) }\n         cache_on_disk_if { true }\n     }\n-    query object_safety_violations(trait_id: DefId) -> &'tcx [traits::ObjectSafetyViolation] {\n+    query object_safety_violations(trait_id: DefId) -> &'tcx [ObjectSafetyViolation] {\n         desc { |tcx| \"determining object safety of trait `{}`\", tcx.def_path_str(trait_id) }\n     }\n     query check_is_object_safe(trait_id: DefId) -> bool {\n@@ -1838,8 +1841,7 @@ rustc_queries! {\n     }\n \n     /// A list of all traits in a crate, used by rustdoc and error reporting.\n-    /// NOTE: Not named just `traits` due to a naming conflict.\n-    query traits_in_crate(_: CrateNum) -> &'tcx [DefId] {\n+    query traits(_: CrateNum) -> &'tcx [DefId] {\n         desc { \"fetching all traits in a crate\" }\n         separate_provide_extern\n     }\n@@ -1953,12 +1955,12 @@ rustc_queries! {\n     /// `infcx.predicate_must_hold()` instead.\n     query evaluate_obligation(\n         goal: CanonicalPredicateGoal<'tcx>\n-    ) -> Result<traits::EvaluationResult, traits::OverflowError> {\n+    ) -> Result<EvaluationResult, OverflowError> {\n         desc { \"evaluating trait selection obligation `{}`\", goal.value.value }\n     }\n \n     query evaluate_goal(\n-        goal: traits::CanonicalChalkEnvironmentAndGoal<'tcx>\n+        goal: CanonicalChalkEnvironmentAndGoal<'tcx>\n     ) -> Result<\n         &'tcx Canonical<'tcx, canonical::QueryResponse<'tcx, ()>>,\n         NoSolution\n@@ -2128,8 +2130,8 @@ rustc_queries! {\n     /// all of the cases that the normal `ty::Ty`-based wfcheck does. This is fine,\n     /// because the `ty::Ty`-based wfcheck is always run.\n     query diagnostic_hir_wf_check(\n-        key: (ty::Predicate<'tcx>, traits::WellFormedLoc)\n-    ) -> &'tcx Option<traits::ObligationCause<'tcx>> {\n+        key: (ty::Predicate<'tcx>, WellFormedLoc)\n+    ) -> &'tcx Option<ObligationCause<'tcx>> {\n         arena_cache\n         eval_always\n         no_hash"}, {"sha": "0a903a76974da3db000477f1c66148137145a6ba", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1108,3 +1108,14 @@ pub enum CodegenObligationError {\n     Unimplemented,\n     FulfillmentError,\n }\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum DefiningAnchor {\n+    /// `DefId` of the item.\n+    Bind(LocalDefId),\n+    /// When opaque types are not resolved, we `Bubble` up, meaning\n+    /// return the opaque/hidden type pair from query, for caller of query to handle it.\n+    Bubble,\n+    /// Used to catch type mismatch errors when handling opaque types.\n+    Error,\n+}"}, {"sha": "eae5a280e114d0a9aa953b6a7212a6ca58ffdbd0", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -95,8 +95,6 @@ pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n #[derive(Copy, Clone, Debug, HashStable, PartialEq, Eq)]\n pub struct NoSolution;\n \n-pub type Fallible<T> = Result<T, NoSolution>;\n-\n impl<'tcx> From<TypeError<'tcx>> for NoSolution {\n     fn from(_: TypeError<'tcx>) -> NoSolution {\n         NoSolution"}, {"sha": "2c5b64a59cdb9f7fc2bccfca3365c2ce50574e4c", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -5,13 +5,13 @@ use rustc_query_system::cache::Cache;\n \n use crate::infer::canonical::{CanonicalVarValues, QueryRegionConstraints};\n use crate::traits::query::NoSolution;\n-use crate::traits::Canonical;\n+use crate::traits::{Canonical, DefiningAnchor};\n use crate::ty::{\n     self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable,\n     TypeVisitor,\n };\n \n-pub type EvaluationCache<'tcx> = Cache<CanonicalGoal<'tcx>, QueryResult<'tcx>>;\n+pub type EvaluationCache<'tcx> = Cache<CanonicalInput<'tcx>, QueryResult<'tcx>>;\n \n /// A goal is a statement, i.e. `predicate`, we want to prove\n /// given some assumptions, i.e. `param_env`.\n@@ -96,7 +96,31 @@ pub enum MaybeCause {\n     Overflow,\n }\n \n-pub type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct QueryInput<'tcx, T> {\n+    pub goal: Goal<'tcx, T>,\n+    pub anchor: DefiningAnchor,\n+    pub predefined_opaques_in_body: PredefinedOpaques<'tcx>,\n+}\n+\n+/// Additional constraints returned on success.\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, Default)]\n+pub struct PredefinedOpaquesData<'tcx> {\n+    pub opaque_types: Vec<(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)>,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n+pub struct PredefinedOpaques<'tcx>(pub(crate) Interned<'tcx, PredefinedOpaquesData<'tcx>>);\n+\n+impl<'tcx> std::ops::Deref for PredefinedOpaques<'tcx> {\n+    type Target = PredefinedOpaquesData<'tcx>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+pub type CanonicalInput<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, QueryInput<'tcx, T>>;\n \n pub type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n \n@@ -165,3 +189,40 @@ impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n         ControlFlow::Continue(())\n     }\n }\n+\n+// FIXME: Having to clone `region_constraints` for folding feels bad and\n+// probably isn't great wrt performance.\n+//\n+// Not sure how to fix this, maybe we should also intern `opaque_types` and\n+// `region_constraints` here or something.\n+impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for PredefinedOpaques<'tcx> {\n+    fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n+        self,\n+        folder: &mut F,\n+    ) -> Result<Self, F::Error> {\n+        Ok(FallibleTypeFolder::interner(folder).mk_predefined_opaques_in_body(\n+            PredefinedOpaquesData {\n+                opaque_types: self\n+                    .opaque_types\n+                    .iter()\n+                    .map(|opaque| opaque.try_fold_with(folder))\n+                    .collect::<Result<_, F::Error>>()?,\n+            },\n+        ))\n+    }\n+\n+    fn fold_with<F: TypeFolder<TyCtxt<'tcx>>>(self, folder: &mut F) -> Self {\n+        TypeFolder::interner(folder).mk_predefined_opaques_in_body(PredefinedOpaquesData {\n+            opaque_types: self.opaque_types.iter().map(|opaque| opaque.fold_with(folder)).collect(),\n+        })\n+    }\n+}\n+\n+impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for PredefinedOpaques<'tcx> {\n+    fn visit_with<V: TypeVisitor<TyCtxt<'tcx>>>(\n+        &self,\n+        visitor: &mut V,\n+    ) -> std::ops::ControlFlow<V::BreakTy> {\n+        self.opaque_types.visit_with(visitor)\n+    }\n+}"}, {"sha": "2bde55bc4fd31922d411f43e607882e782b374ac", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -21,7 +21,9 @@ use crate::query::{IntoQueryParam, TyCtxtAt};\n use crate::thir::Thir;\n use crate::traits;\n use crate::traits::solve;\n-use crate::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n+use crate::traits::solve::{\n+    ExternalConstraints, ExternalConstraintsData, PredefinedOpaques, PredefinedOpaquesData,\n+};\n use crate::ty::{\n     self, AdtDef, AdtDefData, AdtKind, Binder, Const, ConstData, FloatTy, FloatVar, FloatVid,\n     GenericParamDefKind, ImplPolarity, InferTy, IntTy, IntVar, IntVid, List, ParamConst, ParamTy,\n@@ -140,6 +142,7 @@ pub struct CtxtInterners<'tcx> {\n     layout: InternedSet<'tcx, LayoutS>,\n     adt_def: InternedSet<'tcx, AdtDefData>,\n     external_constraints: InternedSet<'tcx, ExternalConstraintsData<'tcx>>,\n+    predefined_opaques_in_body: InternedSet<'tcx, PredefinedOpaquesData<'tcx>>,\n     fields: InternedSet<'tcx, List<FieldIdx>>,\n }\n \n@@ -164,6 +167,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             layout: Default::default(),\n             adt_def: Default::default(),\n             external_constraints: Default::default(),\n+            predefined_opaques_in_body: Default::default(),\n             fields: Default::default(),\n         }\n     }\n@@ -1199,7 +1203,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn all_traits(self) -> impl Iterator<Item = DefId> + 'tcx {\n         iter::once(LOCAL_CRATE)\n             .chain(self.crates(()).iter().copied())\n-            .flat_map(move |cnum| self.traits_in_crate(cnum).iter().copied())\n+            .flat_map(move |cnum| self.traits(cnum).iter().copied())\n     }\n \n     #[inline]\n@@ -1520,6 +1524,8 @@ direct_interners! {\n     adt_def: pub mk_adt_def_from_data(AdtDefData): AdtDef -> AdtDef<'tcx>,\n     external_constraints: pub mk_external_constraints(ExternalConstraintsData<'tcx>):\n         ExternalConstraints -> ExternalConstraints<'tcx>,\n+    predefined_opaques_in_body: pub mk_predefined_opaques_in_body(PredefinedOpaquesData<'tcx>):\n+        PredefinedOpaques -> PredefinedOpaques<'tcx>,\n }\n \n macro_rules! slice_interners {\n@@ -2341,7 +2347,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn is_late_bound(self, id: HirId) -> bool {\n-        self.is_late_bound_map(id.owner).map_or(false, |set| set.contains(&id.local_id))\n+        self.is_late_bound_map(id.owner).is_some_and(|set| set.contains(&id.local_id))\n     }\n \n     pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n@@ -2474,7 +2480,7 @@ pub fn provide(providers: &mut Providers) {\n         |tcx, LocalCrate| attr::contains_name(tcx.hir().krate_attrs(), sym::compiler_builtins);\n     providers.has_panic_handler = |tcx, LocalCrate| {\n         // We want to check if the panic handler was defined in this crate\n-        tcx.lang_items().panic_impl().map_or(false, |did| did.is_local())\n+        tcx.lang_items().panic_impl().is_some_and(|did| did.is_local())\n     };\n     providers.source_span = |tcx, def_id| tcx.untracked.source_span.get(def_id).unwrap_or(DUMMY_SP);\n }"}, {"sha": "9de77b9fda11a20372c00507b7f3e5dfcdc95534", "filename": "compiler/rustc_middle/src/ty/context/tls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext%2Ftls.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -78,7 +78,7 @@ where\n {\n     TLV.with(|tlv| {\n         let old = tlv.replace(erase(context));\n-        let _reset = rustc_data_structures::OnDrop(move || tlv.set(old));\n+        let _reset = rustc_data_structures::defer(move || tlv.set(old));\n         f()\n     })\n }"}, {"sha": "b0ffe78299de91b451ab2a4a901eb22a9b118820", "filename": "compiler/rustc_middle/src/ty/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fgenerics.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -298,7 +298,7 @@ impl<'tcx> Generics {\n             .iter()\n             .rev()\n             .take_while(|param| {\n-                param.default_value(tcx).map_or(false, |default| {\n+                param.default_value(tcx).is_some_and(|default| {\n                     default.subst(tcx, substs) == substs[param.index as usize]\n                 })\n             })"}, {"sha": "e641d1ef1be6fdafaa0bda14c2c1afdefb040e9f", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -659,7 +659,7 @@ fn polymorphize<'tcx>(\n     } else {\n         None\n     };\n-    let has_upvars = upvars_ty.map_or(false, |ty| !ty.tuple_fields().is_empty());\n+    let has_upvars = upvars_ty.is_some_and(|ty| !ty.tuple_fields().is_empty());\n     debug!(\"polymorphize: upvars_ty={:?} has_upvars={:?}\", upvars_ty, has_upvars);\n \n     struct PolymorphizationFolder<'tcx> {"}, {"sha": "a8d0dca37ff99e43049d3409db9306c435083402", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -37,7 +37,7 @@ use rustc_data_structures::intern::Interned;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::steal::Steal;\n use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n-use rustc_errors::ErrorGuaranteed;\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, DocLinkResMap, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LocalDefIdMap};\n@@ -996,17 +996,11 @@ impl<'tcx> Term<'tcx> {\n         }\n     }\n \n-    /// This function returns the inner `AliasTy` if this term is a projection.\n-    ///\n-    /// FIXME: rename `AliasTy` to `AliasTerm` and make sure we correctly\n-    /// deal with constants.\n-    pub fn to_projection_term(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n+    /// This function returns the inner `AliasTy` for a `ty::Alias` or `ConstKind::Unevaluated`.\n+    pub fn to_alias_ty(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n         match self.unpack() {\n-            TermKind::Ty(ty) => match ty.kind() {\n-                ty::Alias(kind, alias_ty) => match kind {\n-                    AliasKind::Projection | AliasKind::Inherent => Some(*alias_ty),\n-                    AliasKind::Opaque => None,\n-                },\n+            TermKind::Ty(ty) => match *ty.kind() {\n+                ty::Alias(_kind, alias_ty) => Some(alias_ty),\n                 _ => None,\n             },\n             TermKind::Const(ct) => match ct.kind() {\n@@ -1439,14 +1433,26 @@ pub struct OpaqueHiddenType<'tcx> {\n }\n \n impl<'tcx> OpaqueHiddenType<'tcx> {\n-    pub fn report_mismatch(&self, other: &Self, tcx: TyCtxt<'tcx>) -> ErrorGuaranteed {\n+    pub fn report_mismatch(\n+        &self,\n+        other: &Self,\n+        opaque_def_id: LocalDefId,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> DiagnosticBuilder<'tcx, ErrorGuaranteed> {\n+        if let Some(diag) = tcx\n+            .sess\n+            .diagnostic()\n+            .steal_diagnostic(tcx.def_span(opaque_def_id), StashKey::OpaqueHiddenTypeMismatch)\n+        {\n+            diag.cancel();\n+        }\n         // Found different concrete types for the opaque type.\n         let sub_diag = if self.span == other.span {\n             TypeMismatchReason::ConflictType { span: self.span }\n         } else {\n             TypeMismatchReason::PreviousUse { span: self.span }\n         };\n-        tcx.sess.emit_err(OpaqueHiddenTypeMismatch {\n+        tcx.sess.create_err(OpaqueHiddenTypeMismatch {\n             self_ty: self.ty,\n             other_ty: other.ty,\n             other_span: other.span,\n@@ -2208,8 +2214,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         let impl_trait_ref2 = self.impl_trait_ref(def_id2);\n         // If either trait impl references an error, they're allowed to overlap,\n         // as one of them essentially doesn't exist.\n-        if impl_trait_ref1.map_or(false, |tr| tr.subst_identity().references_error())\n-            || impl_trait_ref2.map_or(false, |tr| tr.subst_identity().references_error())\n+        if impl_trait_ref1.is_some_and(|tr| tr.subst_identity().references_error())\n+            || impl_trait_ref2.is_some_and(|tr| tr.subst_identity().references_error())\n         {\n             return Some(ImplOverlapKind::Permitted { marker: false });\n         }\n@@ -2230,7 +2236,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let is_marker_overlap = {\n             let is_marker_impl = |trait_ref: Option<EarlyBinder<TraitRef<'_>>>| -> bool {\n-                trait_ref.map_or(false, |tr| self.trait_def(tr.skip_binder().def_id).is_marker)\n+                trait_ref.is_some_and(|tr| self.trait_def(tr.skip_binder().def_id).is_marker)\n             };\n             is_marker_impl(impl_trait_ref1) && is_marker_impl(impl_trait_ref2)\n         };\n@@ -2482,9 +2488,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             && if self.features().collapse_debuginfo {\n                 span.in_macro_expansion_with_collapse_debuginfo()\n             } else {\n-                // Inlined spans should not be collapsed as that leads to all of the\n-                // inlined code being attributed to the inline callsite.\n-                span.from_expansion() && !span.is_inlined()\n+                span.from_expansion()\n             }\n     }\n "}, {"sha": "a064174e2616b6514c798309bfcf7809e3fd99b4", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1164,6 +1164,22 @@ pub trait PrettyPrinter<'tcx>:\n         traits.entry(trait_ref).or_default().extend(proj_ty);\n     }\n \n+    fn pretty_print_inherent_projection(\n+        self,\n+        alias_ty: &ty::AliasTy<'tcx>,\n+    ) -> Result<Self::Path, Self::Error> {\n+        let def_key = self.tcx().def_key(alias_ty.def_id);\n+        self.path_generic_args(\n+            |cx| {\n+                cx.path_append(\n+                    |cx| cx.path_qualified(alias_ty.self_ty(), None),\n+                    &def_key.disambiguated_data,\n+                )\n+            },\n+            &alias_ty.substs[1..],\n+        )\n+    }\n+\n     fn ty_infer_name(&self, _: ty::TyVid) -> Option<Symbol> {\n         None\n     }\n@@ -2821,7 +2837,11 @@ define_print_and_forward_display! {\n     }\n \n     ty::AliasTy<'tcx> {\n-        p!(print_def_path(self.def_id, self.substs));\n+        if let DefKind::Impl { of_trait: false } = cx.tcx().def_kind(cx.tcx().parent(self.def_id)) {\n+            p!(pretty_print_inherent_projection(self))\n+        } else {\n+            p!(print_def_path(self.def_id, self.substs));\n+        }\n     }\n \n     ty::ClosureKind {"}, {"sha": "e04dbbff9a777b452c85195d369e0744caf72229", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -151,10 +151,14 @@ pub struct TypeckResults<'tcx> {\n     /// this field will be set to `Some(ErrorGuaranteed)`.\n     pub tainted_by_errors: Option<ErrorGuaranteed>,\n \n-    /// All the opaque types that have hidden types set\n-    /// by this function. We also store the\n-    /// type here, so that mir-borrowck can use it as a hint for figuring out hidden types,\n-    /// even if they are only set in dead code (which doesn't show up in MIR).\n+    /// All the opaque types that have hidden types set by this function.\n+    /// We also store the type here, so that the compiler can use it as a hint\n+    /// for figuring out hidden types, even if they are only set in dead code\n+    /// (which doesn't show up in MIR).\n+    ///\n+    /// These types are mapped back to the opaque's identity substitutions\n+    /// (with erased regions), which is why we don't associated substs with any\n+    /// of these usages.\n     pub concrete_opaque_types: FxIndexMap<LocalDefId, ty::OpaqueHiddenType<'tcx>>,\n \n     /// Tracks the minimum captures required for a closure;"}, {"sha": "ba05135638e1f6f1e965dcd227fa08d6cfc94221", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -518,6 +518,42 @@ impl<'tcx> TyCtxt<'tcx> {\n         Ok(())\n     }\n \n+    /// Checks whether each generic argument is simply a unique generic placeholder.\n+    ///\n+    /// This is used in the new solver, which canonicalizes params to placeholders\n+    /// for better caching.\n+    pub fn uses_unique_placeholders_ignoring_regions(\n+        self,\n+        substs: SubstsRef<'tcx>,\n+    ) -> Result<(), NotUniqueParam<'tcx>> {\n+        let mut seen = GrowableBitSet::default();\n+        for arg in substs {\n+            match arg.unpack() {\n+                // Ignore regions, since we can't resolve those in a canonicalized\n+                // query in the trait solver.\n+                GenericArgKind::Lifetime(_) => {}\n+                GenericArgKind::Type(t) => match t.kind() {\n+                    ty::Placeholder(p) => {\n+                        if !seen.insert(p.bound.var) {\n+                            return Err(NotUniqueParam::DuplicateParam(t.into()));\n+                        }\n+                    }\n+                    _ => return Err(NotUniqueParam::NotParam(t.into())),\n+                },\n+                GenericArgKind::Const(c) => match c.kind() {\n+                    ty::ConstKind::Placeholder(p) => {\n+                        if !seen.insert(p.bound) {\n+                            return Err(NotUniqueParam::DuplicateParam(c.into()));\n+                        }\n+                    }\n+                    _ => return Err(NotUniqueParam::NotParam(c.into())),\n+                },\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     /// Returns `true` if `def_id` refers to a closure (e.g., `|x| x * 2`). Note\n     /// that closures have a `DefId`, but the closure *expression* also\n     /// has a `HirId` that is located within the context where the"}, {"sha": "cb265cf2c6acb696bfd2de1d3a75dfd0dc6a49d8", "filename": "compiler/rustc_mir_build/messages.ftl", "status": "modified", "additions": 239, "deletions": 237, "changes": 476, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,62 +1,40 @@\n-mir_build_unconditional_recursion = function cannot return without recursing\n-    .label = cannot return without recursing\n-    .help = a `loop` may express intention better if this is on purpose\n-\n-mir_build_unconditional_recursion_call_site_label = recursive call site\n-\n-mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe =\n-    call to unsafe function `{$function}` is unsafe and requires unsafe block (error E0133)\n-    .note = consult the function's documentation for information on how to avoid undefined behavior\n-    .label = call to unsafe function\n-\n-mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe_nameless =\n-    call to unsafe function is unsafe and requires unsafe block (error E0133)\n-    .note = consult the function's documentation for information on how to avoid undefined behavior\n-    .label = call to unsafe function\n-\n-mir_build_unsafe_op_in_unsafe_fn_inline_assembly_requires_unsafe =\n-    use of inline assembly is unsafe and requires unsafe block (error E0133)\n-    .note = inline assembly is entirely unchecked and can cause undefined behavior\n-    .label = use of inline assembly\n+mir_build_adt_defined_here = `{$ty}` defined here\n \n-mir_build_unsafe_op_in_unsafe_fn_initializing_type_with_requires_unsafe =\n-    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe\n-    block (error E0133)\n-    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n-    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+mir_build_already_borrowed = cannot borrow value as mutable because it is also borrowed as immutable\n \n-mir_build_unsafe_op_in_unsafe_fn_mutable_static_requires_unsafe =\n-    use of mutable static is unsafe and requires unsafe block (error E0133)\n-    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n-    .label = use of mutable static\n+mir_build_already_mut_borrowed = cannot borrow value as immutable because it is also borrowed as mutable\n \n-mir_build_unsafe_op_in_unsafe_fn_extern_static_requires_unsafe =\n-    use of extern static is unsafe and requires unsafe block (error E0133)\n-    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n-    .label = use of extern static\n+mir_build_assoc_const_in_pattern = associated consts cannot be referenced in patterns\n \n-mir_build_unsafe_op_in_unsafe_fn_deref_raw_pointer_requires_unsafe =\n-    dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n-    .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n-    .label = dereference of raw pointer\n+mir_build_bindings_with_variant_name =\n+    pattern binding `{$name}` is named the same as one of the variants of the type `{$ty_path}`\n+    .suggestion = to match on the variant, qualify the path\n \n-mir_build_unsafe_op_in_unsafe_fn_union_field_requires_unsafe =\n-    access to union field is unsafe and requires unsafe block (error E0133)\n-    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n-    .label = access to union field\n+mir_build_borrow = value is borrowed by `{$name}` here\n \n-mir_build_unsafe_op_in_unsafe_fn_mutation_of_layout_constrained_field_requires_unsafe =\n-    mutation of layout constrained field is unsafe and requires unsafe block (error E0133)\n-    .note = mutating layout constrained fields cannot statically be checked for valid values\n-    .label = mutation of layout constrained field\n+mir_build_borrow_of_layout_constrained_field_requires_unsafe =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block\n+    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+    .label = borrow of layout constrained field with interior mutability\n \n-mir_build_unsafe_op_in_unsafe_fn_borrow_of_layout_constrained_field_requires_unsafe =\n-    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block (error E0133)\n+mir_build_borrow_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe function or block\n     .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n     .label = borrow of layout constrained field with interior mutability\n \n-mir_build_unsafe_op_in_unsafe_fn_call_to_fn_with_requires_unsafe =\n-    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block (error E0133)\n+mir_build_borrow_of_moved_value = borrow of moved value\n+    .label = value moved into `{$name}` here\n+    .occurs_because_label = move occurs because `{$name}` has type `{$ty}` which does not implement the `Copy` trait\n+    .value_borrowed_label = value borrowed here after move\n+    .suggestion = borrow this binding in the pattern to avoid moving the value\n+\n+mir_build_call_to_fn_with_requires_unsafe =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block\n+    .note = can only be called if the required target features are available\n+    .label = call to function with `#[target_feature]`\n+\n+mir_build_call_to_fn_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe function or block\n     .note = can only be called if the required target features are available\n     .label = call to function with `#[target_feature]`\n \n@@ -70,55 +48,24 @@ mir_build_call_to_unsafe_fn_requires_unsafe_nameless =\n     .note = consult the function's documentation for information on how to avoid undefined behavior\n     .label = call to unsafe function\n \n-mir_build_call_to_unsafe_fn_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    call to unsafe function `{$function}` is unsafe and requires unsafe function or block\n-    .note = consult the function's documentation for information on how to avoid undefined behavior\n-    .label = call to unsafe function\n-\n mir_build_call_to_unsafe_fn_requires_unsafe_nameless_unsafe_op_in_unsafe_fn_allowed =\n     call to unsafe function is unsafe and requires unsafe function or block\n     .note = consult the function's documentation for information on how to avoid undefined behavior\n     .label = call to unsafe function\n \n-mir_build_inline_assembly_requires_unsafe =\n-    use of inline assembly is unsafe and requires unsafe block\n-    .note = inline assembly is entirely unchecked and can cause undefined behavior\n-    .label = use of inline assembly\n-\n-mir_build_inline_assembly_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    use of inline assembly is unsafe and requires unsafe function or block\n-    .note = inline assembly is entirely unchecked and can cause undefined behavior\n-    .label = use of inline assembly\n-\n-mir_build_initializing_type_with_requires_unsafe =\n-    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe block\n-    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n-    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n-\n-mir_build_initializing_type_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe function or block\n-    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n-    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+mir_build_call_to_unsafe_fn_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    call to unsafe function `{$function}` is unsafe and requires unsafe function or block\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n \n-mir_build_mutable_static_requires_unsafe =\n-    use of mutable static is unsafe and requires unsafe block\n-    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n-    .label = use of mutable static\n+mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as a constant pattern, not a new variable\n \n-mir_build_mutable_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    use of mutable static is unsafe and requires unsafe function or block\n-    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n-    .label = use of mutable static\n+mir_build_const_param_in_pattern = const parameters cannot be referenced in patterns\n \n-mir_build_extern_static_requires_unsafe =\n-    use of extern static is unsafe and requires unsafe block\n-    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n-    .label = use of extern static\n+mir_build_const_pattern_depends_on_generic_parameter =\n+    constant pattern depends on a generic parameter\n \n-mir_build_extern_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    use of extern static is unsafe and requires unsafe function or block\n-    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n-    .label = use of extern static\n+mir_build_could_not_eval_const_pattern = could not evaluate constant pattern\n \n mir_build_deref_raw_pointer_requires_unsafe =\n     dereference of raw pointer is unsafe and requires unsafe block\n@@ -130,117 +77,46 @@ mir_build_deref_raw_pointer_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n     .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n     .label = dereference of raw pointer\n \n-mir_build_union_field_requires_unsafe =\n-    access to union field is unsafe and requires unsafe block\n-    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n-    .label = access to union field\n-\n-mir_build_union_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    access to union field is unsafe and requires unsafe function or block\n-    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n-    .label = access to union field\n-\n-mir_build_mutation_of_layout_constrained_field_requires_unsafe =\n-    mutation of layout constrained field is unsafe and requires unsafe block\n-    .note = mutating layout constrained fields cannot statically be checked for valid values\n-    .label = mutation of layout constrained field\n-\n-mir_build_mutation_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    mutation of layout constrained field is unsafe and requires unsafe function or block\n-    .note = mutating layout constrained fields cannot statically be checked for valid values\n-    .label = mutation of layout constrained field\n-\n-mir_build_borrow_of_layout_constrained_field_requires_unsafe =\n-    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block\n-    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n-    .label = borrow of layout constrained field with interior mutability\n-\n-mir_build_borrow_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    borrow of layout constrained field with interior mutability is unsafe and requires unsafe function or block\n-    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n-    .label = borrow of layout constrained field with interior mutability\n-\n-mir_build_call_to_fn_with_requires_unsafe =\n-    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block\n-    .note = can only be called if the required target features are available\n-    .label = call to function with `#[target_feature]`\n-\n-mir_build_call_to_fn_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n-    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe function or block\n-    .note = can only be called if the required target features are available\n-    .label = call to function with `#[target_feature]`\n-\n-mir_build_unused_unsafe = unnecessary `unsafe` block\n-    .label = unnecessary `unsafe` block\n-\n-mir_build_unused_unsafe_enclosing_block_label = because it's nested under this `unsafe` block\n-mir_build_unused_unsafe_enclosing_fn_label = because it's nested under this `unsafe` fn\n-\n-mir_build_non_exhaustive_patterns_type_not_empty = non-exhaustive patterns: type `{$ty}` is non-empty\n-    .def_note = `{$peeled_ty}` defined here\n-    .type_note = the matched value is of type `{$ty}`\n-    .non_exhaustive_type_note = the matched value is of type `{$ty}`, which is marked as non-exhaustive\n-    .reference_note = references are always considered inhabited\n-    .suggestion = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n-    .help = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n-\n-mir_build_static_in_pattern = statics cannot be referenced in patterns\n-\n-mir_build_assoc_const_in_pattern = associated consts cannot be referenced in patterns\n-\n-mir_build_const_param_in_pattern = const parameters cannot be referenced in patterns\n+mir_build_extern_static_requires_unsafe =\n+    use of extern static is unsafe and requires unsafe block\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n \n-mir_build_non_const_path = runtime values cannot be referenced in patterns\n+mir_build_extern_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of extern static is unsafe and requires unsafe function or block\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n \n-mir_build_unreachable_pattern = unreachable pattern\n-    .label = unreachable pattern\n-    .catchall_label = matches any value\n+mir_build_float_pattern = floating-point types cannot be used in patterns\n \n-mir_build_const_pattern_depends_on_generic_parameter =\n-    constant pattern depends on a generic parameter\n+mir_build_indirect_structural_match =\n+    to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n \n-mir_build_could_not_eval_const_pattern = could not evaluate constant pattern\n+mir_build_inform_irrefutable = `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n \n-mir_build_lower_range_bound_must_be_less_than_or_equal_to_upper =\n-    lower range bound must be less than or equal to upper\n-    .label = lower bound larger than upper bound\n-    .teach_note = When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.\n+mir_build_initializing_type_with_requires_unsafe =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe block\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n \n-mir_build_literal_in_range_out_of_bounds =\n-    literal out of range for `{$ty}`\n-    .label = this value doesn't fit in `{$ty}` whose maximum value is `{$max}`\n+mir_build_initializing_type_with_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe function or block\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n \n-mir_build_lower_range_bound_must_be_less_than_upper = lower range bound must be less than upper\n+mir_build_inline_assembly_requires_unsafe =\n+    use of inline assembly is unsafe and requires unsafe block\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n \n-mir_build_leading_irrefutable_let_patterns = leading irrefutable {$count ->\n-        [one] pattern\n-        *[other] patterns\n-    } in let chain\n-    .note = {$count ->\n-        [one] this pattern\n-        *[other] these patterns\n-    } will always match\n-    .help = consider moving {$count ->\n-        [one] it\n-        *[other] them\n-    } outside of the construct\n+mir_build_inline_assembly_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of inline assembly is unsafe and requires unsafe function or block\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n \n-mir_build_trailing_irrefutable_let_patterns = trailing irrefutable {$count ->\n-        [one] pattern\n-        *[other] patterns\n-    } in let chain\n-    .note = {$count ->\n-        [one] this pattern\n-        *[other] these patterns\n-    } will always match\n-    .help = consider moving {$count ->\n-        [one] it\n-        *[other] them\n-    } into the body\n+mir_build_interpreted_as_const = introduce a variable instead\n \n-mir_build_bindings_with_variant_name =\n-    pattern binding `{$name}` is named the same as one of the variants of the type `{$ty_path}`\n-    .suggestion = to match on the variant, qualify the path\n+mir_build_invalid_pattern = `{$non_sm_ty}` cannot be used in patterns\n \n mir_build_irrefutable_let_patterns_if_let = irrefutable `if let` {$count ->\n         [one] pattern\n@@ -282,78 +158,97 @@ mir_build_irrefutable_let_patterns_while_let = irrefutable `while let` {$count -\n     } will always match, so the loop will never exit\n     .help = consider instead using a `loop {\"{\"} ... {\"}\"}` with a `let` inside it\n \n-mir_build_borrow_of_moved_value = borrow of moved value\n-    .label = value moved into `{$name}` here\n-    .occurs_because_label = move occurs because `{$name}` has type `{$ty}` which does not implement the `Copy` trait\n-    .value_borrowed_label = value borrowed here after move\n-    .suggestion = borrow this binding in the pattern to avoid moving the value\n+mir_build_leading_irrefutable_let_patterns = leading irrefutable {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    } in let chain\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match\n+    .help = consider moving {$count ->\n+        [one] it\n+        *[other] them\n+    } outside of the construct\n \n-mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once at a time\n+mir_build_literal_in_range_out_of_bounds =\n+    literal out of range for `{$ty}`\n+    .label = this value doesn't fit in `{$ty}` whose maximum value is `{$max}`\n \n-mir_build_already_borrowed = cannot borrow value as mutable because it is also borrowed as immutable\n+mir_build_lower_range_bound_must_be_less_than_or_equal_to_upper =\n+    lower range bound must be less than or equal to upper\n+    .label = lower bound larger than upper bound\n+    .teach_note = When matching against a range, the compiler verifies that the range is non-empty. Range patterns include both end-points, so this is equivalent to requiring the start of the range to be less than or equal to the end of the range.\n \n-mir_build_already_mut_borrowed = cannot borrow value as immutable because it is also borrowed as mutable\n+mir_build_lower_range_bound_must_be_less_than_upper = lower range bound must be less than upper\n \n-mir_build_moved_while_borrowed = cannot move out of value because it is borrowed\n+mir_build_more_information = for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n \n-mir_build_mutable_borrow = value is mutably borrowed by `{$name}` here\n+mir_build_moved = value is moved into `{$name}` here\n \n-mir_build_borrow = value is borrowed by `{$name}` here\n+mir_build_moved_while_borrowed = cannot move out of value because it is borrowed\n \n-mir_build_moved = value is moved into `{$name}` here\n+mir_build_multiple_mut_borrows = cannot borrow value as mutable more than once at a time\n \n-mir_build_union_pattern = cannot use unions in constant patterns\n+mir_build_mutable_borrow = value is mutably borrowed by `{$name}` here\n \n-mir_build_type_not_structural =\n-     to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+mir_build_mutable_static_requires_unsafe =\n+    use of mutable static is unsafe and requires unsafe block\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n \n-mir_build_unsized_pattern = cannot use unsized non-slice type `{$non_sm_ty}` in constant patterns\n+mir_build_mutable_static_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    use of mutable static is unsafe and requires unsafe function or block\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n \n-mir_build_invalid_pattern = `{$non_sm_ty}` cannot be used in patterns\n+mir_build_mutation_of_layout_constrained_field_requires_unsafe =\n+    mutation of layout constrained field is unsafe and requires unsafe block\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n \n-mir_build_float_pattern = floating-point types cannot be used in patterns\n+mir_build_mutation_of_layout_constrained_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    mutation of layout constrained field is unsafe and requires unsafe function or block\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n \n-mir_build_pointer_pattern = function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n+mir_build_non_const_path = runtime values cannot be referenced in patterns\n \n-mir_build_indirect_structural_match =\n-    to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n+mir_build_non_exhaustive_omitted_pattern = some variants are not matched explicitly\n+    .help = ensure that all variants are matched explicitly by adding the suggested match arms\n+    .note = the matched value is of type `{$scrut_ty}` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+mir_build_non_exhaustive_patterns_type_not_empty = non-exhaustive patterns: type `{$ty}` is non-empty\n+    .def_note = `{$peeled_ty}` defined here\n+    .type_note = the matched value is of type `{$ty}`\n+    .non_exhaustive_type_note = the matched value is of type `{$ty}`, which is marked as non-exhaustive\n+    .reference_note = references are always considered inhabited\n+    .suggestion = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern as shown\n+    .help = ensure that all possible cases are being handled by adding a match arm with a wildcard pattern\n \n mir_build_nontrivial_structural_match =\n     to use a constant of type `{$non_sm_ty}` in a pattern, the constant's initializer must be trivial or `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n \n-mir_build_type_not_structural_tip = the traits must be derived, manual `impl`s are not sufficient\n-\n-mir_build_type_not_structural_more_info = see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n-\n mir_build_overlapping_range_endpoints = multiple patterns overlap on their endpoints\n     .range = ... with this range\n     .note = you likely meant to write mutually exclusive ranges\n \n-mir_build_non_exhaustive_omitted_pattern = some variants are not matched explicitly\n-    .help = ensure that all variants are matched explicitly by adding the suggested match arms\n-    .note = the matched value is of type `{$scrut_ty}` and the `non_exhaustive_omitted_patterns` attribute was found\n-\n-mir_build_uncovered = {$count ->\n-        [1] pattern `{$witness_1}`\n-        [2] patterns `{$witness_1}` and `{$witness_2}`\n-        [3] patterns `{$witness_1}`, `{$witness_2}` and `{$witness_3}`\n-        *[other] patterns `{$witness_1}`, `{$witness_2}`, `{$witness_3}` and {$remainder} more\n-    } not covered\n-\n mir_build_pattern_not_covered = refutable pattern in {$origin}\n     .pattern_ty = the matched value is of type `{$pattern_ty}`\n \n-mir_build_inform_irrefutable = `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+mir_build_pointer_pattern = function pointers and unsized pointers in patterns behave unpredictably and should not be relied upon. See https://github.com/rust-lang/rust/issues/70861 for details.\n \n-mir_build_more_information = for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+mir_build_privately_uninhabited = pattern `{$witness_1}` is currently uninhabited, but this variant contains private fields which may become inhabited in the future\n \n-mir_build_adt_defined_here = `{$ty}` defined here\n+mir_build_rustc_box_attribute_error = `#[rustc_box]` attribute used incorrectly\n+    .attributes = no other attributes may be applied\n+    .not_box = `#[rustc_box]` may only be applied to a `Box::new()` call\n+    .missing_box = `#[rustc_box]` requires the `owned_box` lang item\n \n-mir_build_variant_defined_here = not covered\n+mir_build_static_in_pattern = statics cannot be referenced in patterns\n \n-mir_build_interpreted_as_const = introduce a variable instead\n+mir_build_suggest_attempted_int_lit = alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n \n-mir_build_confused = missing patterns are not covered because `{$variable}` is interpreted as a constant pattern, not a new variable\n \n mir_build_suggest_if_let = you might want to use `if let` to ignore the {$count ->\n         [one] variant that isn't\n@@ -365,10 +260,117 @@ mir_build_suggest_let_else = you might want to use `let else` to handle the {$co\n         *[other] variants that aren't\n     } matched\n \n-mir_build_suggest_attempted_int_lit = alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n+mir_build_trailing_irrefutable_let_patterns = trailing irrefutable {$count ->\n+        [one] pattern\n+        *[other] patterns\n+    } in let chain\n+    .note = {$count ->\n+        [one] this pattern\n+        *[other] these patterns\n+    } will always match\n+    .help = consider moving {$count ->\n+        [one] it\n+        *[other] them\n+    } into the body\n+\n+mir_build_type_not_structural =\n+     to use a constant of type `{$non_sm_ty}` in a pattern, `{$non_sm_ty}` must be annotated with `#[derive(PartialEq, Eq)]`\n \n+mir_build_type_not_structural_more_info = see https://doc.rust-lang.org/stable/std/marker/trait.StructuralEq.html for details\n \n-mir_build_rustc_box_attribute_error = `#[rustc_box]` attribute used incorrectly\n-    .attributes = no other attributes may be applied\n-    .not_box = `#[rustc_box]` may only be applied to a `Box::new()` call\n-    .missing_box = `#[rustc_box]` requires the `owned_box` lang item\n+mir_build_type_not_structural_tip = the traits must be derived, manual `impl`s are not sufficient\n+\n+mir_build_unconditional_recursion = function cannot return without recursing\n+    .label = cannot return without recursing\n+    .help = a `loop` may express intention better if this is on purpose\n+\n+mir_build_unconditional_recursion_call_site_label = recursive call site\n+\n+mir_build_uncovered = {$count ->\n+        [1] pattern `{$witness_1}`\n+        [2] patterns `{$witness_1}` and `{$witness_2}`\n+        [3] patterns `{$witness_1}`, `{$witness_2}` and `{$witness_3}`\n+        *[other] patterns `{$witness_1}`, `{$witness_2}`, `{$witness_3}` and {$remainder} more\n+    } not covered\n+\n+mir_build_union_field_requires_unsafe =\n+    access to union field is unsafe and requires unsafe block\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_union_field_requires_unsafe_unsafe_op_in_unsafe_fn_allowed =\n+    access to union field is unsafe and requires unsafe function or block\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_union_pattern = cannot use unions in constant patterns\n+\n+mir_build_unreachable_pattern = unreachable pattern\n+    .label = unreachable pattern\n+    .catchall_label = matches any value\n+\n+mir_build_unsafe_op_in_unsafe_fn_borrow_of_layout_constrained_field_requires_unsafe =\n+    borrow of layout constrained field with interior mutability is unsafe and requires unsafe block (error E0133)\n+    .note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+    .label = borrow of layout constrained field with interior mutability\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_fn_with_requires_unsafe =\n+    call to function `{$function}` with `#[target_feature]` is unsafe and requires unsafe block (error E0133)\n+    .note = can only be called if the required target features are available\n+    .label = call to function with `#[target_feature]`\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe =\n+    call to unsafe function `{$function}` is unsafe and requires unsafe block (error E0133)\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_unsafe_op_in_unsafe_fn_call_to_unsafe_fn_requires_unsafe_nameless =\n+    call to unsafe function is unsafe and requires unsafe block (error E0133)\n+    .note = consult the function's documentation for information on how to avoid undefined behavior\n+    .label = call to unsafe function\n+\n+mir_build_unsafe_op_in_unsafe_fn_deref_raw_pointer_requires_unsafe =\n+    dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n+    .note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+    .label = dereference of raw pointer\n+\n+mir_build_unsafe_op_in_unsafe_fn_extern_static_requires_unsafe =\n+    use of extern static is unsafe and requires unsafe block (error E0133)\n+    .note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+    .label = use of extern static\n+\n+mir_build_unsafe_op_in_unsafe_fn_initializing_type_with_requires_unsafe =\n+    initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe\n+    block (error E0133)\n+    .note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+    .label = initializing type with `rustc_layout_scalar_valid_range` attr\n+\n+mir_build_unsafe_op_in_unsafe_fn_inline_assembly_requires_unsafe =\n+    use of inline assembly is unsafe and requires unsafe block (error E0133)\n+    .note = inline assembly is entirely unchecked and can cause undefined behavior\n+    .label = use of inline assembly\n+\n+mir_build_unsafe_op_in_unsafe_fn_mutable_static_requires_unsafe =\n+    use of mutable static is unsafe and requires unsafe block (error E0133)\n+    .note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+    .label = use of mutable static\n+\n+mir_build_unsafe_op_in_unsafe_fn_mutation_of_layout_constrained_field_requires_unsafe =\n+    mutation of layout constrained field is unsafe and requires unsafe block (error E0133)\n+    .note = mutating layout constrained fields cannot statically be checked for valid values\n+    .label = mutation of layout constrained field\n+\n+mir_build_unsafe_op_in_unsafe_fn_union_field_requires_unsafe =\n+    access to union field is unsafe and requires unsafe block (error E0133)\n+    .note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+    .label = access to union field\n+\n+mir_build_unsized_pattern = cannot use unsized non-slice type `{$non_sm_ty}` in constant patterns\n+\n+mir_build_unused_unsafe = unnecessary `unsafe` block\n+    .label = unnecessary `unsafe` block\n+\n+mir_build_unused_unsafe_enclosing_block_label = because it's nested under this `unsafe` block\n+mir_build_unused_unsafe_enclosing_fn_label = because it's nested under this `unsafe` fn\n+\n+mir_build_variant_defined_here = not covered"}, {"sha": "ab4cd24881f6a6e63c4bd4e42c413f2162bdd5c4", "filename": "compiler/rustc_mir_build/src/build/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fblock.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -351,7 +351,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n \n             let popped = this.block_context.pop();\n-            assert!(popped.map_or(false, |bf| bf.is_statement()));\n+            assert!(popped.is_some_and(|bf| bf.is_statement()));\n         }\n \n         // Then, the block may have an optional trailing expression which is a \u201creturn\u201d value\n@@ -367,7 +367,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             unpack!(block = this.expr_into_dest(destination, block, expr));\n             let popped = this.block_context.pop();\n \n-            assert!(popped.map_or(false, |bf| bf.is_tail_expr()));\n+            assert!(popped.is_some_and(|bf| bf.is_tail_expr()));\n         } else {\n             // If a block has no trailing expression, then it is given an implicit return type.\n             // This return type is usually `()`, unless the block is diverging, in which case the"}, {"sha": "744111edb84e4992f1cf85853258f849495d00ab", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -118,15 +118,19 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let category = Category::of(&expr.kind).unwrap();\n         debug!(?category, ?expr.kind);\n         match category {\n-            Category::Constant if let NeedsTemporary::No = needs_temporary || !expr.ty.needs_drop(this.tcx, this.param_env) => {\n+            Category::Constant\n+                if matches!(needs_temporary, NeedsTemporary::No)\n+                    || !expr.ty.needs_drop(this.tcx, this.param_env) =>\n+            {\n                 let constant = this.as_constant(expr);\n                 block.and(Operand::Constant(Box::new(constant)))\n             }\n             Category::Constant | Category::Place | Category::Rvalue(..) => {\n                 let operand = unpack!(block = this.as_temp(block, scope, expr, Mutability::Mut));\n                 // Overwrite temp local info if we have something more interesting to record.\n                 if !matches!(local_info, LocalInfo::Boring) {\n-                    let decl_info = this.local_decls[operand].local_info.as_mut().assert_crate_local();\n+                    let decl_info =\n+                        this.local_decls[operand].local_info.as_mut().assert_crate_local();\n                     if let LocalInfo::Boring | LocalInfo::BlockTailTemp(_) = **decl_info {\n                         **decl_info = local_info;\n                     }"}, {"sha": "bcab4c0d24b5fae0502df9e6f88a3f64462878b3", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -15,6 +15,7 @@ use rustc_middle::mir::Place;\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n use rustc_middle::ty::cast::{mir_cast_kind, CastTy};\n+use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Ty, UpvarSubsts};\n use rustc_span::Span;\n \n@@ -225,49 +226,63 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     );\n                     let (op,ty) = (Operand::Move(discr), discr_ty);\n \n-                    if let Abi::Scalar(scalar) = layout.unwrap().abi{\n-                        if let Primitive::Int(_, signed) = scalar.primitive() {\n-                            let range = scalar.valid_range(&this.tcx);\n-                            // FIXME: Handle wraparound cases too.\n-                            if range.end >= range.start {\n-                                let mut assumer = |range: u128, bin_op: BinOp| {\n-                                    // We will be overwriting this val if our scalar is signed value\n-                                    // because sign extension on unsigned types might cause unintended things\n-                                    let mut range_val =\n-                                        ConstantKind::from_bits(this.tcx, range, ty::ParamEnv::empty().and(discr_ty));\n-                                    let bool_ty = this.tcx.types.bool;\n-                                    if signed {\n-                                        let scalar_size_extend = scalar.size(&this.tcx).sign_extend(range);\n-                                        let discr_layout = this.tcx.layout_of(this.param_env.and(discr_ty));\n-                                        let truncated_val = discr_layout.unwrap().size.truncate(scalar_size_extend);\n-                                        range_val = ConstantKind::from_bits(\n-                                            this.tcx,\n-                                            truncated_val,\n-                                            ty::ParamEnv::empty().and(discr_ty),\n-                                        );\n-                                    }\n-                                    let lit_op = this.literal_operand(expr.span, range_val);\n-                                    let is_bin_op = this.temp(bool_ty, expr_span);\n-                                    this.cfg.push_assign(\n-                                        block,\n-                                        source_info,\n-                                        is_bin_op,\n-                                        Rvalue::BinaryOp(bin_op, Box::new(((lit_op), (Operand::Copy(discr))))),\n-                                    );\n-                                    this.cfg.push(\n-                                        block,\n-                                        Statement {\n-                                            source_info,\n-                                            kind: StatementKind::Intrinsic(Box::new(NonDivergingIntrinsic::Assume(\n-                                                Operand::Copy(is_bin_op),\n-                                            ))),\n-                                        },\n-                                    )\n-                                };\n-                                assumer(range.end, BinOp::Ge);\n-                                assumer(range.start, BinOp::Le);\n-                            }\n-                        }\n+                    if let Abi::Scalar(scalar) = layout.unwrap().abi\n+                        && !scalar.is_always_valid(&this.tcx)\n+                        && let Primitive::Int(int_width, _signed) = scalar.primitive()\n+                    {\n+                        let unsigned_ty = int_width.to_ty(this.tcx, false);\n+                        let unsigned_place = this.temp(unsigned_ty, expr_span);\n+                        this.cfg.push_assign(\n+                            block,\n+                            source_info,\n+                            unsigned_place,\n+                            Rvalue::Cast(CastKind::IntToInt, Operand::Copy(discr), unsigned_ty));\n+\n+                        let bool_ty = this.tcx.types.bool;\n+                        let range = scalar.valid_range(&this.tcx);\n+                        let merge_op =\n+                            if range.start <= range.end {\n+                                BinOp::BitAnd\n+                            } else {\n+                                BinOp::BitOr\n+                            };\n+\n+                        let mut comparer = |range: u128, bin_op: BinOp| -> Place<'tcx> {\n+                            let range_val =\n+                                ConstantKind::from_bits(this.tcx, range, ty::ParamEnv::empty().and(unsigned_ty));\n+                            let lit_op = this.literal_operand(expr.span, range_val);\n+                            let is_bin_op = this.temp(bool_ty, expr_span);\n+                            this.cfg.push_assign(\n+                                block,\n+                                source_info,\n+                                is_bin_op,\n+                                Rvalue::BinaryOp(bin_op, Box::new((Operand::Copy(unsigned_place), lit_op))),\n+                            );\n+                            is_bin_op\n+                        };\n+                        let assert_place = if range.start == 0 {\n+                            comparer(range.end, BinOp::Le)\n+                        } else {\n+                            let start_place = comparer(range.start, BinOp::Ge);\n+                            let end_place = comparer(range.end, BinOp::Le);\n+                            let merge_place = this.temp(bool_ty, expr_span);\n+                            this.cfg.push_assign(\n+                                block,\n+                                source_info,\n+                                merge_place,\n+                                Rvalue::BinaryOp(merge_op, Box::new((Operand::Move(start_place), Operand::Move(end_place)))),\n+                            );\n+                            merge_place\n+                        };\n+                        this.cfg.push(\n+                            block,\n+                            Statement {\n+                                source_info,\n+                                kind: StatementKind::Intrinsic(Box::new(NonDivergingIntrinsic::Assume(\n+                                    Operand::Move(assert_place),\n+                                ))),\n+                            },\n+                        );\n                     }\n \n                     (op,ty)"}, {"sha": "7331f8ecaa96502f4dcab3258f8fe43f7ddcd323", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -325,10 +325,10 @@ impl DropTree {\n         entry_points.sort();\n \n         for (drop_idx, drop_data) in self.drops.iter_enumerated().rev() {\n-            if entry_points.last().map_or(false, |entry_point| entry_point.0 == drop_idx) {\n+            if entry_points.last().is_some_and(|entry_point| entry_point.0 == drop_idx) {\n                 let block = *blocks[drop_idx].get_or_insert_with(|| T::make_block(cfg));\n                 needs_block[drop_idx] = Block::Own;\n-                while entry_points.last().map_or(false, |entry_point| entry_point.0 == drop_idx) {\n+                while entry_points.last().is_some_and(|entry_point| entry_point.0 == drop_idx) {\n                     let entry_block = entry_points.pop().unwrap().1;\n                     T::add_entry(cfg, entry_block, block);\n                 }\n@@ -731,7 +731,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     fn leave_top_scope(&mut self, block: BasicBlock) -> BasicBlock {\n         // If we are emitting a `drop` statement, we need to have the cached\n         // diverge cleanup pads ready in case that drop panics.\n-        let needs_cleanup = self.scopes.scopes.last().map_or(false, |scope| scope.needs_cleanup());\n+        let needs_cleanup = self.scopes.scopes.last().is_some_and(|scope| scope.needs_cleanup());\n         let is_generator = self.generator_kind.is_some();\n         let unwind_to = if needs_cleanup { self.diverge_cleanup() } else { DropIdx::MAX };\n "}, {"sha": "7c0df201bc25e96f6f1f43f09c0ba69d6e863c0d", "filename": "compiler/rustc_mir_build/src/errors.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Ferrors.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -781,6 +781,8 @@ pub(crate) struct PatternNotCovered<'s, 'tcx> {\n     pub interpreted_as_const: Option<InterpretedAsConst>,\n     #[subdiagnostic]\n     pub adt_defined_here: Option<AdtDefinedHere<'tcx>>,\n+    #[note(mir_build_privately_uninhabited)]\n+    pub witness_1_is_privately_uninhabited: Option<()>,\n     #[note(mir_build_pattern_ty)]\n     pub _p: (),\n     pub pattern_ty: Ty<'tcx>,"}, {"sha": "b20495d602e59562af7d9b171a782282b6af37a1", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -333,7 +333,7 @@ impl<'tcx> Cx<'tcx> {\n                         } else if let Some(box_item) = tcx.lang_items().owned_box() {\n                             if let hir::ExprKind::Path(hir::QPath::TypeRelative(ty, fn_path)) = fun.kind\n                                 && let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = ty.kind\n-                                && path.res.opt_def_id().map_or(false, |did| did == box_item)\n+                                && path.res.opt_def_id().is_some_and(|did| did == box_item)\n                                 && fn_path.ident.name == sym::new\n                                 && let [value] = args\n                             {\n@@ -956,7 +956,7 @@ impl<'tcx> Cx<'tcx> {\n         let is_upvar = self\n             .tcx\n             .upvars_mentioned(self.body_owner)\n-            .map_or(false, |upvars| upvars.contains_key(&var_hir_id));\n+            .is_some_and(|upvars| upvars.contains_key(&var_hir_id));\n \n         debug!(\n             \"convert_var({:?}): is_upvar={}, body_owner={:?}\","}, {"sha": "1e51cb9aa96e7360b8a992dfb728c34b48e83c2e", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 53, "deletions": 23, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -90,35 +90,34 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for MatchVisitor<'a, '_, 'tcx> {\n \n     #[instrument(level = \"trace\", skip(self))]\n     fn visit_arm(&mut self, arm: &Arm<'tcx>) {\n-        match arm.guard {\n-            Some(Guard::If(expr)) => {\n-                self.with_let_source(LetSource::IfLetGuard, |this| {\n-                    this.visit_expr(&this.thir[expr])\n-                });\n-            }\n-            Some(Guard::IfLet(ref pat, expr)) => {\n-                self.with_let_source(LetSource::IfLetGuard, |this| {\n-                    this.check_let(pat, expr, LetSource::IfLetGuard, pat.span);\n-                    this.visit_pat(pat);\n-                    this.visit_expr(&this.thir[expr]);\n-                });\n+        self.with_lint_level(arm.lint_level, |this| {\n+            match arm.guard {\n+                Some(Guard::If(expr)) => {\n+                    this.with_let_source(LetSource::IfLetGuard, |this| {\n+                        this.visit_expr(&this.thir[expr])\n+                    });\n+                }\n+                Some(Guard::IfLet(ref pat, expr)) => {\n+                    this.with_let_source(LetSource::IfLetGuard, |this| {\n+                        this.check_let(pat, expr, LetSource::IfLetGuard, pat.span);\n+                        this.visit_pat(pat);\n+                        this.visit_expr(&this.thir[expr]);\n+                    });\n+                }\n+                None => {}\n             }\n-            None => {}\n-        }\n-        self.visit_pat(&arm.pattern);\n-        self.visit_expr(&self.thir[arm.body]);\n+            this.visit_pat(&arm.pattern);\n+            this.visit_expr(&self.thir[arm.body]);\n+        });\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n     fn visit_expr(&mut self, ex: &Expr<'tcx>) {\n         match ex.kind {\n             ExprKind::Scope { value, lint_level, .. } => {\n-                let old_lint_level = self.lint_level;\n-                if let LintLevel::Explicit(hir_id) = lint_level {\n-                    self.lint_level = hir_id;\n-                }\n-                self.visit_expr(&self.thir[value]);\n-                self.lint_level = old_lint_level;\n+                self.with_lint_level(lint_level, |this| {\n+                    this.visit_expr(&this.thir[value]);\n+                });\n                 return;\n             }\n             ExprKind::If { cond, then, else_opt, if_then_scope: _ } => {\n@@ -190,6 +189,17 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         self.let_source = old_let_source;\n     }\n \n+    fn with_lint_level(&mut self, new_lint_level: LintLevel, f: impl FnOnce(&mut Self)) {\n+        if let LintLevel::Explicit(hir_id) = new_lint_level {\n+            let old_lint_level = self.lint_level;\n+            self.lint_level = hir_id;\n+            f(self);\n+            self.lint_level = old_lint_level;\n+        } else {\n+            f(self);\n+        }\n+    }\n+\n     fn check_patterns(&self, pat: &Pat<'tcx>, rf: RefutableFlag) {\n         pat.walk_always(|pat| check_borrow_conflicts_in_at_patterns(self, pat));\n         check_for_bindings_named_same_as_variants(self, pat, rf);\n@@ -236,7 +246,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         for &arm in arms {\n             // Check the arm for some things unrelated to exhaustiveness.\n             let arm = &self.thir.arms[arm];\n-            self.check_patterns(&arm.pattern, Refutable);\n+            self.with_lint_level(arm.lint_level, |this| {\n+                this.check_patterns(&arm.pattern, Refutable);\n+            });\n         }\n \n         let tarms: Vec<_> = arms\n@@ -479,12 +491,30 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             AdtDefinedHere { adt_def_span, ty, variants }\n         };\n \n+        // Emit an extra note if the first uncovered witness would be uninhabited\n+        // if we disregard visibility.\n+        let witness_1_is_privately_uninhabited =\n+            if cx.tcx.features().exhaustive_patterns\n+                && let Some(witness_1) = witnesses.get(0)\n+                && let ty::Adt(adt, substs) = witness_1.ty().kind()\n+                && adt.is_enum()\n+                && let Constructor::Variant(variant_index) = witness_1.ctor()\n+            {\n+                let variant = adt.variant(*variant_index);\n+                let inhabited = variant.inhabited_predicate(cx.tcx, *adt).subst(cx.tcx, substs);\n+                assert!(inhabited.apply(cx.tcx, cx.param_env, cx.module));\n+                !inhabited.apply_ignore_module(cx.tcx, cx.param_env)\n+            } else {\n+                false\n+            };\n+\n         self.error = Err(self.tcx.sess.emit_err(PatternNotCovered {\n             span: pat.span,\n             origin,\n             uncovered: Uncovered::new(pat.span, &cx, witnesses),\n             inform,\n             interpreted_as_const,\n+            witness_1_is_privately_uninhabited: witness_1_is_privately_uninhabited.then_some(()),\n             _p: (),\n             pattern_ty,\n             let_suggestion,"}, {"sha": "5698367e42ba5e7eb34a0798ea10adbc01d05cb2", "filename": "compiler/rustc_mir_dataflow/messages.ftl", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_dataflow%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_dataflow%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,29 +1,29 @@\n+mir_dataflow_duplicate_values_for =\n+    duplicate values for `{$name}`\n+\n mir_dataflow_path_must_end_in_filename =\n     path must end in a filename\n \n-mir_dataflow_unknown_formatter =\n-    unknown formatter\n+mir_dataflow_peek_argument_not_a_local =\n+    rustc_peek: argument was not a local\n \n-mir_dataflow_duplicate_values_for =\n-    duplicate values for `{$name}`\n+mir_dataflow_peek_argument_untracked =\n+    rustc_peek: argument untracked\n \n-mir_dataflow_requires_an_argument =\n-    `{$name}` requires an argument\n+mir_dataflow_peek_bit_not_set =\n+    rustc_peek: bit not set\n \n-mir_dataflow_stop_after_dataflow_ended_compilation =\n-    stop_after_dataflow ended compilation\n+mir_dataflow_peek_must_be_not_temporary =\n+    dataflow::sanity_check cannot feed a non-temp to rustc_peek\n \n mir_dataflow_peek_must_be_place_or_ref_place =\n     rustc_peek: argument expression must be either `place` or `&place`\n \n-mir_dataflow_peek_must_be_not_temporary =\n-    dataflow::sanity_check cannot feed a non-temp to rustc_peek\n-\n-mir_dataflow_peek_bit_not_set =\n-    rustc_peek: bit not set\n+mir_dataflow_requires_an_argument =\n+    `{$name}` requires an argument\n \n-mir_dataflow_peek_argument_not_a_local =\n-    rustc_peek: argument was not a local\n+mir_dataflow_stop_after_dataflow_ended_compilation =\n+    stop_after_dataflow ended compilation\n \n-mir_dataflow_peek_argument_untracked =\n-    rustc_peek: argument untracked\n+mir_dataflow_unknown_formatter =\n+    unknown formatter"}, {"sha": "b13429d121d10b14cc5ef7a56bce66d2dd47d423", "filename": "compiler/rustc_mir_transform/messages.ftl", "status": "modified", "additions": 41, "deletions": 40, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,3 +1,8 @@\n+mir_transform_arithmetic_overflow = this arithmetic operation will overflow\n+mir_transform_call_to_unsafe_label = call to unsafe function\n+mir_transform_call_to_unsafe_note = consult the function's documentation for information on how to avoid undefined behavior\n+mir_transform_const_defined_here = `const` item defined here\n+\n mir_transform_const_modify = attempting to modify a `const` item\n     .note = each usage of a `const` item creates a new temporary; the original `const` item will not be modified\n \n@@ -6,50 +11,10 @@ mir_transform_const_mut_borrow = taking a mutable reference to a `const` item\n     .note2 = the mutable reference will refer to this temporary, not the original `const` item\n     .note3 = mutable reference created due to call to this method\n \n-mir_transform_const_defined_here = `const` item defined here\n-\n-mir_transform_unaligned_packed_ref = reference to packed field is unaligned\n-    .note = packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\n-    .note_ub = creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n-    .help = copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n-\n-mir_transform_unused_unsafe = unnecessary `unsafe` block\n-    .label = because it's nested under this `unsafe` block\n-\n-mir_transform_requires_unsafe = {$details} is unsafe and requires unsafe {$op_in_unsafe_fn_allowed ->\n-    [true] function or block\n-    *[false] block\n-    }\n-    .not_inherited = items do not inherit unsafety from separate enclosing items\n-\n-mir_transform_call_to_unsafe_label = call to unsafe function\n-mir_transform_call_to_unsafe_note = consult the function's documentation for information on how to avoid undefined behavior\n-mir_transform_use_of_asm_label = use of inline assembly\n-mir_transform_use_of_asm_note = inline assembly is entirely unchecked and can cause undefined behavior\n-mir_transform_initializing_valid_range_label = initializing type with `rustc_layout_scalar_valid_range` attr\n-mir_transform_initializing_valid_range_note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n mir_transform_const_ptr2int_label = cast of pointer to int\n mir_transform_const_ptr2int_note = casting pointers to integers in constants\n-mir_transform_use_of_static_mut_label = use of mutable static\n-mir_transform_use_of_static_mut_note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n-mir_transform_use_of_extern_static_label = use of extern static\n-mir_transform_use_of_extern_static_note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n mir_transform_deref_ptr_label = dereference of raw pointer\n mir_transform_deref_ptr_note = raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n-mir_transform_union_access_label = access to union field\n-mir_transform_union_access_note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n-mir_transform_mutation_layout_constrained_label = mutation of layout constrained field\n-mir_transform_mutation_layout_constrained_note = mutating layout constrained fields cannot statically be checked for valid values\n-mir_transform_mutation_layout_constrained_borrow_label = borrow of layout constrained field with interior mutability\n-mir_transform_mutation_layout_constrained_borrow_note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n-mir_transform_target_feature_call_label = call to function with `#[target_feature]`\n-mir_transform_target_feature_call_note = can only be called if the required target features are available\n-\n-mir_transform_unsafe_op_in_unsafe_fn = {$details} is unsafe and requires unsafe block (error E0133)\n-\n-mir_transform_arithmetic_overflow = this arithmetic operation will overflow\n-mir_transform_operation_will_panic = this operation will panic at runtime\n-\n mir_transform_ffi_unwind_call = call to {$foreign ->\n     [true] foreign function\n     *[false] function pointer\n@@ -58,9 +23,45 @@ mir_transform_ffi_unwind_call = call to {$foreign ->\n mir_transform_fn_item_ref = taking a reference to a function item does not give a function pointer\n     .suggestion = cast `{$ident}` to obtain a function pointer\n \n+mir_transform_initializing_valid_range_label = initializing type with `rustc_layout_scalar_valid_range` attr\n+mir_transform_initializing_valid_range_note = initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n mir_transform_must_not_suspend = {$pre}`{$def_path}`{$post} held across a suspend point, but should not be\n     .label = the value is held across this suspend point\n     .note = {$reason}\n     .help = consider using a block (`{\"{ ... }\"}`) to shrink the value's scope, ending before the suspend point\n \n+mir_transform_mutation_layout_constrained_borrow_label = borrow of layout constrained field with interior mutability\n+mir_transform_mutation_layout_constrained_borrow_note = references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+mir_transform_mutation_layout_constrained_label = mutation of layout constrained field\n+mir_transform_mutation_layout_constrained_note = mutating layout constrained fields cannot statically be checked for valid values\n+mir_transform_operation_will_panic = this operation will panic at runtime\n+\n+mir_transform_requires_unsafe = {$details} is unsafe and requires unsafe {$op_in_unsafe_fn_allowed ->\n+    [true] function or block\n+    *[false] block\n+    }\n+    .not_inherited = items do not inherit unsafety from separate enclosing items\n+\n mir_transform_simd_shuffle_last_const = last argument of `simd_shuffle` is required to be a `const` item\n+\n+mir_transform_target_feature_call_label = call to function with `#[target_feature]`\n+mir_transform_target_feature_call_note = can only be called if the required target features are available\n+\n+mir_transform_unaligned_packed_ref = reference to packed field is unaligned\n+    .note = packed structs are only aligned by one byte, and many modern architectures penalize unaligned field accesses\n+    .note_ub = creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)\n+    .help = copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)\n+\n+mir_transform_union_access_label = access to union field\n+mir_transform_union_access_note = the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+mir_transform_unsafe_op_in_unsafe_fn = {$details} is unsafe and requires unsafe block (error E0133)\n+\n+mir_transform_unused_unsafe = unnecessary `unsafe` block\n+    .label = because it's nested under this `unsafe` block\n+\n+mir_transform_use_of_asm_label = use of inline assembly\n+mir_transform_use_of_asm_note = inline assembly is entirely unchecked and can cause undefined behavior\n+mir_transform_use_of_extern_static_label = use of extern static\n+mir_transform_use_of_extern_static_note = extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n+mir_transform_use_of_static_mut_label = use of mutable static\n+mir_transform_use_of_static_mut_note = mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior"}, {"sha": "0fe49b8a1bbf08b0ecc7250e0506c38dd3cc8170", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -363,7 +363,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             let left_size = self.ecx.layout_of(left_ty).ok()?.size;\n             let right_size = r.layout.size;\n             let r_bits = r.to_scalar().to_bits(right_size).ok();\n-            if r_bits.map_or(false, |b| b >= left_size.bits() as u128) {\n+            if r_bits.is_some_and(|b| b >= left_size.bits() as u128) {\n                 debug!(\"check_binary_op: reporting assert for {:?}\", location);\n                 let source_info = self.body().source_info(location);\n                 let panic = AssertKind::Overflow("}, {"sha": "6a3d42511ac1bbce6eb2a3cdad5b76e28235f435", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -639,7 +639,7 @@ pub(super) fn dump_coverage_spanview<'tcx>(\n     let def_id = mir_source.def_id();\n \n     let span_viewables = span_viewables(tcx, mir_body, basic_coverage_blocks, &coverage_spans);\n-    let mut file = create_dump_file(tcx, \"html\", false, pass_name, &0, mir_body)\n+    let mut file = create_dump_file(tcx, \"html\", false, pass_name, &0i32, mir_body)\n         .expect(\"Unexpected error creating MIR spanview HTML file\");\n     let crate_name = tcx.crate_name(def_id.krate);\n     let item_name = tcx.def_path(def_id).to_filename_friendly_no_crate();\n@@ -740,7 +740,7 @@ pub(super) fn dump_coverage_graphviz<'tcx>(\n                 .join(\"\\n  \")\n         ));\n     }\n-    let mut file = create_dump_file(tcx, \"dot\", false, pass_name, &0, mir_body)\n+    let mut file = create_dump_file(tcx, \"dot\", false, pass_name, &0i32, mir_body)\n         .expect(\"Unexpected error creating BasicCoverageBlock graphviz DOT file\");\n     graphviz_writer\n         .write_graphviz(tcx, &mut file)"}, {"sha": "ea1223fbca6429578865bcda48d9c04e6634f9df", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -9,6 +9,7 @@ use rustc_index::{IndexSlice, IndexVec};\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::{self, BasicBlock, BasicBlockData, Terminator, TerminatorKind};\n \n+use std::cmp::Ordering;\n use std::ops::{Index, IndexMut};\n \n const ID_SEPARATOR: &str = \",\";\n@@ -212,8 +213,12 @@ impl CoverageGraph {\n     }\n \n     #[inline(always)]\n-    pub fn dominators(&self) -> &Dominators<BasicCoverageBlock> {\n-        self.dominators.as_ref().unwrap()\n+    pub fn rank_partial_cmp(\n+        &self,\n+        a: BasicCoverageBlock,\n+        b: BasicCoverageBlock,\n+    ) -> Option<Ordering> {\n+        self.dominators.as_ref().unwrap().rank_partial_cmp(a, b)\n     }\n }\n \n@@ -650,26 +655,6 @@ pub(super) fn find_loop_backedges(\n     let mut backedges = IndexVec::from_elem_n(Vec::<BasicCoverageBlock>::new(), num_bcbs);\n \n     // Identify loops by their backedges.\n-    //\n-    // The computational complexity is bounded by: n(s) x d where `n` is the number of\n-    // `BasicCoverageBlock` nodes (the simplified/reduced representation of the CFG derived from the\n-    // MIR); `s` is the average number of successors per node (which is most likely less than 2, and\n-    // independent of the size of the function, so it can be treated as a constant);\n-    // and `d` is the average number of dominators per node.\n-    //\n-    // The average number of dominators depends on the size and complexity of the function, and\n-    // nodes near the start of the function's control flow graph typically have less dominators\n-    // than nodes near the end of the CFG. Without doing a detailed mathematical analysis, I\n-    // think the resulting complexity has the characteristics of O(n log n).\n-    //\n-    // The overall complexity appears to be comparable to many other MIR transform algorithms, and I\n-    // don't expect that this function is creating a performance hot spot, but if this becomes an\n-    // issue, there may be ways to optimize the `dominates` algorithm (as indicated by an\n-    // existing `FIXME` comment in that code), or possibly ways to optimize it's usage here, perhaps\n-    // by keeping track of results for visited `BasicCoverageBlock`s if they can be used to short\n-    // circuit downstream `dominates` checks.\n-    //\n-    // For now, that kind of optimization seems unnecessarily complicated.\n     for (bcb, _) in basic_coverage_blocks.iter_enumerated() {\n         for &successor in &basic_coverage_blocks.successors[bcb] {\n             if basic_coverage_blocks.dominates(successor, bcb) {"}, {"sha": "d27200419e2cbc3288a965764810063b43b0e552", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                         // before the dominated equal spans). When later comparing two spans in\n                         // order, the first will either dominate the second, or they will have no\n                         // dominator relationship.\n-                        self.basic_coverage_blocks.dominators().rank_partial_cmp(a.bcb, b.bcb)\n+                        self.basic_coverage_blocks.rank_partial_cmp(a.bcb, b.bcb)\n                     }\n                 } else {\n                     // Sort hi() in reverse order so shorter spans are attempted after longer spans."}, {"sha": "bf5722b3d00b2c393b98be2541709c04361960fc", "filename": "compiler/rustc_mir_transform/src/ctfe_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fctfe_limit.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -47,7 +47,7 @@ fn has_back_edge(\n         return false;\n     }\n     // Check if any of the dominators of the node are also the node's successor.\n-    doms.dominators(node).any(|dom| node_data.terminator().successors().any(|succ| succ == dom))\n+    node_data.terminator().successors().any(|succ| doms.dominates(succ, node))\n }\n \n fn insert_counter(basic_block_data: &mut BasicBlockData<'_>) {"}, {"sha": "1748b1bf4a02a513184523f163637bcd8f7c8890", "filename": "compiler/rustc_mir_transform/src/inline.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Finline.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -10,7 +10,6 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::TypeVisitableExt;\n use rustc_middle::ty::{self, Instance, InstanceDef, ParamEnv, Ty, TyCtxt};\n use rustc_session::config::OptLevel;\n-use rustc_span::{hygiene::ExpnKind, ExpnData, LocalExpnId, Span};\n use rustc_target::abi::{FieldIdx, FIRST_VARIANT};\n use rustc_target::spec::abi::Abi;\n \n@@ -551,16 +550,6 @@ impl<'tcx> Inliner<'tcx> {\n                 // Copy the arguments if needed.\n                 let args: Vec<_> = self.make_call_args(args, &callsite, caller_body, &callee_body);\n \n-                let mut expn_data = ExpnData::default(\n-                    ExpnKind::Inlined,\n-                    callsite.source_info.span,\n-                    self.tcx.sess.edition(),\n-                    None,\n-                    None,\n-                );\n-                expn_data.def_site = callee_body.span;\n-                let expn_data =\n-                    self.tcx.with_stable_hashing_context(|hcx| LocalExpnId::fresh(expn_data, hcx));\n                 let mut integrator = Integrator {\n                     args: &args,\n                     new_locals: Local::new(caller_body.local_decls.len())..,\n@@ -572,7 +561,6 @@ impl<'tcx> Inliner<'tcx> {\n                     cleanup_block: unwind,\n                     in_cleanup_block: false,\n                     tcx: self.tcx,\n-                    expn_data,\n                     always_live_locals: BitSet::new_filled(callee_body.local_decls.len()),\n                 };\n \n@@ -956,7 +944,6 @@ struct Integrator<'a, 'tcx> {\n     cleanup_block: UnwindAction,\n     in_cleanup_block: bool,\n     tcx: TyCtxt<'tcx>,\n-    expn_data: LocalExpnId,\n     always_live_locals: BitSet<Local>,\n }\n \n@@ -1042,11 +1029,6 @@ impl<'tcx> MutVisitor<'tcx> for Integrator<'_, 'tcx> {\n         *scope = self.map_scope(*scope);\n     }\n \n-    fn visit_span(&mut self, span: &mut Span) {\n-        // Make sure that all spans track the fact that they were inlined.\n-        *span = span.fresh_expansion(self.expn_data);\n-    }\n-\n     fn visit_basic_block_data(&mut self, block: BasicBlock, data: &mut BasicBlockData<'tcx>) {\n         self.in_cleanup_block = data.is_cleanup;\n         self.super_basic_block_data(block, data);"}, {"sha": "5ce96012b908662e49268a80c8da8c28a7c6951a", "filename": "compiler/rustc_mir_transform/src/nrvo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fnrvo.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -108,7 +108,7 @@ fn local_eligible_for_nrvo(body: &mut mir::Body<'_>) -> Option<Local> {\n \n         // If multiple different locals are copied to the return place. We can't pick a\n         // single one to rename.\n-        if copied_to_return_place.map_or(false, |old| old != returned_local) {\n+        if copied_to_return_place.is_some_and(|old| old != returned_local) {\n             return None;\n         }\n "}, {"sha": "e8e4246b7970fe41c7a5369118d0b6ec968c99ab", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -31,11 +31,11 @@ pub struct SsaLocals {\n /// We often encounter MIR bodies with 1 or 2 basic blocks. In those cases, it's unnecessary to\n /// actually compute dominators, we can just compare block indices because bb0 is always the first\n /// block, and in any body all other blocks are always dominated by bb0.\n-struct SmallDominators {\n-    inner: Option<Dominators<BasicBlock>>,\n+struct SmallDominators<'a> {\n+    inner: Option<&'a Dominators<BasicBlock>>,\n }\n \n-impl SmallDominators {\n+impl SmallDominators<'_> {\n     fn dominates(&self, first: Location, second: Location) -> bool {\n         if first.block == second.block {\n             first.statement_index <= second.statement_index\n@@ -198,14 +198,14 @@ enum LocationExtended {\n     Arg,\n }\n \n-struct SsaVisitor {\n-    dominators: SmallDominators,\n+struct SsaVisitor<'a> {\n+    dominators: SmallDominators<'a>,\n     assignments: IndexVec<Local, Set1<LocationExtended>>,\n     assignment_order: Vec<Local>,\n     direct_uses: IndexVec<Local, u32>,\n }\n \n-impl<'tcx> Visitor<'tcx> for SsaVisitor {\n+impl<'tcx> Visitor<'tcx> for SsaVisitor<'_> {\n     fn visit_local(&mut self, local: Local, ctxt: PlaceContext, loc: Location) {\n         match ctxt {\n             PlaceContext::MutatingUse(MutatingUseContext::Projection)"}, {"sha": "fdd47e6f79bd8c3f564031ac3dc08cafa379ff81", "filename": "compiler/rustc_monomorphize/messages.ftl", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_monomorphize%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_monomorphize%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,32 +1,32 @@\n-monomorphize_recursion_limit =\n-    reached the recursion limit while instantiating `{$shrunk}`\n-    .note = `{$def_path_str}` defined here\n-\n-monomorphize_written_to_path = the full type name has been written to '{$path}'\n-\n-monomorphize_type_length_limit = reached the type-length limit while instantiating `{$shrunk}`\n-\n monomorphize_consider_type_length_limit =\n     consider adding a `#![type_length_limit=\"{$type_length}\"]` attribute to your crate\n \n-monomorphize_fatal_error = {$error_message}\n-\n-monomorphize_unknown_partition_strategy = unknown partitioning strategy\n+monomorphize_couldnt_dump_mono_stats =\n+    unexpected error occurred while dumping monomorphization stats: {$error}\n \n-monomorphize_symbol_already_defined = symbol `{$symbol}` is already defined\n+monomorphize_encountered_error_while_instantiating =\n+    the above error was encountered while instantiating `{$formatted_item}`\n \n-monomorphize_unused_generic_params = item has unused generic parameters\n+monomorphize_fatal_error = {$error_message}\n \n monomorphize_large_assignments =\n     moving {$size} bytes\n     .label = value moved from here\n     .note = The current maximum size is {$limit}, but it can be customized with the move_size_limit attribute: `#![move_size_limit = \"...\"]`\n \n-monomorphize_couldnt_dump_mono_stats =\n-    unexpected error occurred while dumping monomorphization stats: {$error}\n+monomorphize_recursion_limit =\n+    reached the recursion limit while instantiating `{$shrunk}`\n+    .note = `{$def_path_str}` defined here\n \n-monomorphize_encountered_error_while_instantiating =\n-    the above error was encountered while instantiating `{$formatted_item}`\n+monomorphize_symbol_already_defined = symbol `{$symbol}` is already defined\n+\n+monomorphize_type_length_limit = reached the type-length limit while instantiating `{$shrunk}`\n \n monomorphize_unknown_cgu_collection_mode =\n     unknown codegen-item collection mode '{$mode}', falling back to 'lazy' mode\n+\n+monomorphize_unknown_partition_strategy = unknown partitioning strategy\n+\n+monomorphize_unused_generic_params = item has unused generic parameters\n+\n+monomorphize_written_to_path = the full type name has been written to '{$path}'"}, {"sha": "603b3ddc106e931ea2864506243a43b35fd9e819", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 113, "deletions": 37, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,3 +1,4 @@\n+use std::cmp;\n use std::collections::hash_map::Entry;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n@@ -14,10 +15,7 @@ use rustc_span::symbol::Symbol;\n \n use super::PartitioningCx;\n use crate::collector::InliningMap;\n-use crate::partitioning::merging;\n-use crate::partitioning::{\n-    MonoItemPlacement, Partition, PostInliningPartitioning, PreInliningPartitioning,\n-};\n+use crate::partitioning::{MonoItemPlacement, Partition, PlacedRootMonoItems};\n \n pub struct DefaultPartitioning;\n \n@@ -26,7 +24,7 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut I,\n-    ) -> PreInliningPartitioning<'tcx>\n+    ) -> PlacedRootMonoItems<'tcx>\n     where\n         I: Iterator<Item = MonoItem<'tcx>>,\n     {\n@@ -91,38 +89,120 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n             codegen_units.insert(codegen_unit_name, CodegenUnit::new(codegen_unit_name));\n         }\n \n-        PreInliningPartitioning {\n-            codegen_units: codegen_units.into_values().collect(),\n-            roots,\n-            internalization_candidates,\n-        }\n+        let codegen_units = codegen_units.into_values().collect();\n+        PlacedRootMonoItems { codegen_units, roots, internalization_candidates }\n     }\n \n     fn merge_codegen_units(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n     ) {\n-        merging::merge_codegen_units(cx, initial_partitioning);\n+        assert!(cx.target_cgu_count >= 1);\n+\n+        // Note that at this point in time the `codegen_units` here may not be\n+        // in a deterministic order (but we know they're deterministically the\n+        // same set). We want this merging to produce a deterministic ordering\n+        // of codegen units from the input.\n+        //\n+        // Due to basically how we've implemented the merging below (merge the\n+        // two smallest into each other) we're sure to start off with a\n+        // deterministic order (sorted by name). This'll mean that if two cgus\n+        // have the same size the stable sort below will keep everything nice\n+        // and deterministic.\n+        codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+\n+        // This map keeps track of what got merged into what.\n+        let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n+            codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n+\n+        // Merge the two smallest codegen units until the target size is\n+        // reached.\n+        while codegen_units.len() > cx.target_cgu_count {\n+            // Sort small cgus to the back\n+            codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n+            let mut smallest = codegen_units.pop().unwrap();\n+            let second_smallest = codegen_units.last_mut().unwrap();\n+\n+            // Move the mono-items from `smallest` to `second_smallest`\n+            second_smallest.modify_size_estimate(smallest.size_estimate());\n+            for (k, v) in smallest.items_mut().drain() {\n+                second_smallest.items_mut().insert(k, v);\n+            }\n+\n+            // Record that `second_smallest` now contains all the stuff that was\n+            // in `smallest` before.\n+            let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n+            cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n+\n+            debug!(\n+                \"CodegenUnit {} merged into CodegenUnit {}\",\n+                smallest.name(),\n+                second_smallest.name()\n+            );\n+        }\n+\n+        let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n+\n+        if cx.tcx.sess.opts.incremental.is_some() {\n+            // If we are doing incremental compilation, we want CGU names to\n+            // reflect the path of the source level module they correspond to.\n+            // For CGUs that contain the code of multiple modules because of the\n+            // merging done above, we use a concatenation of the names of all\n+            // contained CGUs.\n+            let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n+                .into_iter()\n+                // This `filter` makes sure we only update the name of CGUs that\n+                // were actually modified by merging.\n+                .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n+                .map(|(current_cgu_name, cgu_contents)| {\n+                    let mut cgu_contents: Vec<&str> =\n+                        cgu_contents.iter().map(|s| s.as_str()).collect();\n+\n+                    // Sort the names, so things are deterministic and easy to\n+                    // predict. We are sorting primitive `&str`s here so we can\n+                    // use unstable sort.\n+                    cgu_contents.sort_unstable();\n+\n+                    (current_cgu_name, cgu_contents.join(\"--\"))\n+                })\n+                .collect();\n+\n+            for cgu in codegen_units.iter_mut() {\n+                if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n+                    if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n+                        cgu.set_name(Symbol::intern(&new_cgu_name));\n+                    } else {\n+                        // If we don't require CGU names to be human-readable,\n+                        // we use a fixed length hash of the composite CGU name\n+                        // instead.\n+                        let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n+                        cgu.set_name(Symbol::intern(&new_cgu_name));\n+                    }\n+                }\n+            }\n+        } else {\n+            // If we are compiling non-incrementally we just generate simple CGU\n+            // names containing an index.\n+            for (index, cgu) in codegen_units.iter_mut().enumerate() {\n+                let numbered_codegen_unit_name =\n+                    cgu_name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index));\n+                cgu.set_name(numbered_codegen_unit_name);\n+            }\n+        }\n     }\n \n     fn place_inlined_mono_items(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: PreInliningPartitioning<'tcx>,\n-    ) -> PostInliningPartitioning<'tcx> {\n-        let mut new_partitioning = Vec::new();\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        roots: FxHashSet<MonoItem<'tcx>>,\n+    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n         let mut mono_item_placements = FxHashMap::default();\n \n-        let PreInliningPartitioning {\n-            codegen_units: initial_cgus,\n-            roots,\n-            internalization_candidates,\n-        } = initial_partitioning;\n-\n-        let single_codegen_unit = initial_cgus.len() == 1;\n+        let single_codegen_unit = codegen_units.len() == 1;\n \n-        for old_codegen_unit in initial_cgus {\n+        for old_codegen_unit in codegen_units.iter_mut() {\n             // Collect all items that need to be available in this codegen unit.\n             let mut reachable = FxHashSet::default();\n             for root in old_codegen_unit.items().keys() {\n@@ -174,14 +254,10 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n                 }\n             }\n \n-            new_partitioning.push(new_codegen_unit);\n+            *old_codegen_unit = new_codegen_unit;\n         }\n \n-        return PostInliningPartitioning {\n-            codegen_units: new_partitioning,\n-            mono_item_placements,\n-            internalization_candidates,\n-        };\n+        return mono_item_placements;\n \n         fn follow_inlining<'tcx>(\n             mono_item: MonoItem<'tcx>,\n@@ -201,14 +277,16 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n     fn internalize_symbols(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        partitioning: &mut PostInliningPartitioning<'tcx>,\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n     ) {\n-        if partitioning.codegen_units.len() == 1 {\n+        if codegen_units.len() == 1 {\n             // Fast path for when there is only one codegen unit. In this case we\n             // can internalize all candidates, since there is nowhere else they\n             // could be accessed from.\n-            for cgu in &mut partitioning.codegen_units {\n-                for candidate in &partitioning.internalization_candidates {\n+            for cgu in codegen_units {\n+                for candidate in &internalization_candidates {\n                     cgu.items_mut().insert(*candidate, (Linkage::Internal, Visibility::Default));\n                 }\n             }\n@@ -225,15 +303,13 @@ impl<'tcx> Partition<'tcx> for DefaultPartitioning {\n             }\n         });\n \n-        let mono_item_placements = &partitioning.mono_item_placements;\n-\n         // For each internalization candidates in each codegen unit, check if it is\n         // accessed from outside its defining codegen unit.\n-        for cgu in &mut partitioning.codegen_units {\n+        for cgu in codegen_units {\n             let home_cgu = MonoItemPlacement::SingleCgu { cgu_name: cgu.name() };\n \n             for (accessee, linkage_and_visibility) in cgu.items_mut() {\n-                if !partitioning.internalization_candidates.contains(accessee) {\n+                if !internalization_candidates.contains(accessee) {\n                     // This item is no candidate for internalizing, so skip it.\n                     continue;\n                 }"}, {"sha": "5c524a18454ec515026c68537cf84d1b0cccd5c8", "filename": "compiler/rustc_monomorphize/src/partitioning/merging.rs", "status": "removed", "additions": 0, "deletions": 111, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/9ffd3f941081b37f5c34afbaf62eb87af9b19b9d/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ffd3f941081b37f5c34afbaf62eb87af9b19b9d/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmerging.rs?ref=9ffd3f941081b37f5c34afbaf62eb87af9b19b9d", "patch": "@@ -1,111 +0,0 @@\n-use std::cmp;\n-\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_middle::mir::mono::{CodegenUnit, CodegenUnitNameBuilder};\n-use rustc_span::symbol::Symbol;\n-\n-use super::PartitioningCx;\n-use crate::partitioning::PreInliningPartitioning;\n-\n-pub fn merge_codegen_units<'tcx>(\n-    cx: &PartitioningCx<'_, 'tcx>,\n-    initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-) {\n-    assert!(cx.target_cgu_count >= 1);\n-    let codegen_units = &mut initial_partitioning.codegen_units;\n-\n-    // Note that at this point in time the `codegen_units` here may not be in a\n-    // deterministic order (but we know they're deterministically the same set).\n-    // We want this merging to produce a deterministic ordering of codegen units\n-    // from the input.\n-    //\n-    // Due to basically how we've implemented the merging below (merge the two\n-    // smallest into each other) we're sure to start off with a deterministic\n-    // order (sorted by name). This'll mean that if two cgus have the same size\n-    // the stable sort below will keep everything nice and deterministic.\n-    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n-\n-    // This map keeps track of what got merged into what.\n-    let mut cgu_contents: FxHashMap<Symbol, Vec<Symbol>> =\n-        codegen_units.iter().map(|cgu| (cgu.name(), vec![cgu.name()])).collect();\n-\n-    // Merge the two smallest codegen units until the target size is reached.\n-    while codegen_units.len() > cx.target_cgu_count {\n-        // Sort small cgus to the back\n-        codegen_units.sort_by_cached_key(|cgu| cmp::Reverse(cgu.size_estimate()));\n-        let mut smallest = codegen_units.pop().unwrap();\n-        let second_smallest = codegen_units.last_mut().unwrap();\n-\n-        // Move the mono-items from `smallest` to `second_smallest`\n-        second_smallest.modify_size_estimate(smallest.size_estimate());\n-        for (k, v) in smallest.items_mut().drain() {\n-            second_smallest.items_mut().insert(k, v);\n-        }\n-\n-        // Record that `second_smallest` now contains all the stuff that was in\n-        // `smallest` before.\n-        let mut consumed_cgu_names = cgu_contents.remove(&smallest.name()).unwrap();\n-        cgu_contents.get_mut(&second_smallest.name()).unwrap().append(&mut consumed_cgu_names);\n-\n-        debug!(\n-            \"CodegenUnit {} merged into CodegenUnit {}\",\n-            smallest.name(),\n-            second_smallest.name()\n-        );\n-    }\n-\n-    let cgu_name_builder = &mut CodegenUnitNameBuilder::new(cx.tcx);\n-\n-    if cx.tcx.sess.opts.incremental.is_some() {\n-        // If we are doing incremental compilation, we want CGU names to\n-        // reflect the path of the source level module they correspond to.\n-        // For CGUs that contain the code of multiple modules because of the\n-        // merging done above, we use a concatenation of the names of\n-        // all contained CGUs.\n-        let new_cgu_names: FxHashMap<Symbol, String> = cgu_contents\n-            .into_iter()\n-            // This `filter` makes sure we only update the name of CGUs that\n-            // were actually modified by merging.\n-            .filter(|(_, cgu_contents)| cgu_contents.len() > 1)\n-            .map(|(current_cgu_name, cgu_contents)| {\n-                let mut cgu_contents: Vec<&str> = cgu_contents.iter().map(|s| s.as_str()).collect();\n-\n-                // Sort the names, so things are deterministic and easy to\n-                // predict.\n-\n-                // We are sorting primitive &strs here so we can use unstable sort\n-                cgu_contents.sort_unstable();\n-\n-                (current_cgu_name, cgu_contents.join(\"--\"))\n-            })\n-            .collect();\n-\n-        for cgu in codegen_units.iter_mut() {\n-            if let Some(new_cgu_name) = new_cgu_names.get(&cgu.name()) {\n-                if cx.tcx.sess.opts.unstable_opts.human_readable_cgu_names {\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                } else {\n-                    // If we don't require CGU names to be human-readable, we\n-                    // use a fixed length hash of the composite CGU name\n-                    // instead.\n-                    let new_cgu_name = CodegenUnit::mangle_name(&new_cgu_name);\n-                    cgu.set_name(Symbol::intern(&new_cgu_name));\n-                }\n-            }\n-        }\n-    } else {\n-        // If we are compiling non-incrementally we just generate simple CGU\n-        // names containing an index.\n-        for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-            cgu.set_name(numbered_codegen_unit_name(cgu_name_builder, index));\n-        }\n-    }\n-}\n-\n-fn numbered_codegen_unit_name(\n-    name_builder: &mut CodegenUnitNameBuilder<'_>,\n-    index: usize,\n-) -> Symbol {\n-    name_builder.build_cgu_name_no_mangle(LOCAL_CRATE, &[\"cgu\"], Some(index))\n-}"}, {"sha": "d0b23ca9ea44494dcc9dbe891f998bda48a31dc4", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -93,7 +93,6 @@\n //! inlining, even when they are not marked `#[inline]`.\n \n mod default;\n-mod merging;\n \n use std::cmp;\n use std::fs::{self, File};\n@@ -129,7 +128,7 @@ impl<'tcx> Partition<'tcx> for Partitioner {\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut I,\n-    ) -> PreInliningPartitioning<'tcx>\n+    ) -> PlacedRootMonoItems<'tcx>\n     where\n         I: Iterator<Item = MonoItem<'tcx>>,\n     {\n@@ -142,24 +141,23 @@ impl<'tcx> Partition<'tcx> for Partitioner {\n     fn merge_codegen_units(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n     ) {\n         match self {\n-            Partitioner::Default(partitioner) => {\n-                partitioner.merge_codegen_units(cx, initial_partitioning)\n-            }\n+            Partitioner::Default(partitioner) => partitioner.merge_codegen_units(cx, codegen_units),\n             Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n         }\n     }\n \n     fn place_inlined_mono_items(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: PreInliningPartitioning<'tcx>,\n-    ) -> PostInliningPartitioning<'tcx> {\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        roots: FxHashSet<MonoItem<'tcx>>,\n+    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement> {\n         match self {\n             Partitioner::Default(partitioner) => {\n-                partitioner.place_inlined_mono_items(cx, initial_partitioning)\n+                partitioner.place_inlined_mono_items(cx, codegen_units, roots)\n             }\n             Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n         }\n@@ -168,48 +166,62 @@ impl<'tcx> Partition<'tcx> for Partitioner {\n     fn internalize_symbols(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        post_inlining_partitioning: &mut PostInliningPartitioning<'tcx>,\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n     ) {\n         match self {\n-            Partitioner::Default(partitioner) => {\n-                partitioner.internalize_symbols(cx, post_inlining_partitioning)\n-            }\n+            Partitioner::Default(partitioner) => partitioner.internalize_symbols(\n+                cx,\n+                codegen_units,\n+                mono_item_placements,\n+                internalization_candidates,\n+            ),\n             Partitioner::Unknown => cx.tcx.sess.emit_fatal(UnknownPartitionStrategy),\n         }\n     }\n }\n \n-pub struct PartitioningCx<'a, 'tcx> {\n+struct PartitioningCx<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     target_cgu_count: usize,\n     inlining_map: &'a InliningMap<'tcx>,\n }\n \n+pub struct PlacedRootMonoItems<'tcx> {\n+    codegen_units: Vec<CodegenUnit<'tcx>>,\n+    roots: FxHashSet<MonoItem<'tcx>>,\n+    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+}\n+\n trait Partition<'tcx> {\n     fn place_root_mono_items<I>(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n         mono_items: &mut I,\n-    ) -> PreInliningPartitioning<'tcx>\n+    ) -> PlacedRootMonoItems<'tcx>\n     where\n         I: Iterator<Item = MonoItem<'tcx>>;\n \n     fn merge_codegen_units(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+        codegen_units: &mut Vec<CodegenUnit<'tcx>>,\n     );\n \n     fn place_inlined_mono_items(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        initial_partitioning: PreInliningPartitioning<'tcx>,\n-    ) -> PostInliningPartitioning<'tcx>;\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        roots: FxHashSet<MonoItem<'tcx>>,\n+    ) -> FxHashMap<MonoItem<'tcx>, MonoItemPlacement>;\n \n     fn internalize_symbols(\n         &mut self,\n         cx: &PartitioningCx<'_, 'tcx>,\n-        partitioning: &mut PostInliningPartitioning<'tcx>,\n+        codegen_units: &mut [CodegenUnit<'tcx>],\n+        mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n+        internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n     );\n }\n \n@@ -225,7 +237,7 @@ fn get_partitioner(tcx: TyCtxt<'_>) -> Partitioner {\n     }\n }\n \n-pub fn partition<'tcx, I>(\n+fn partition<'tcx, I>(\n     tcx: TyCtxt<'tcx>,\n     mono_items: &mut I,\n     max_cgu_count: usize,\n@@ -241,52 +253,59 @@ where\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n-    let mut initial_partitioning = {\n+    let PlacedRootMonoItems { mut codegen_units, roots, internalization_candidates } = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_roots\");\n         partitioner.place_root_mono_items(cx, mono_items)\n     };\n \n-    for cgu in &mut initial_partitioning.codegen_units {\n+    for cgu in &mut codegen_units {\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"INITIAL PARTITIONING\", &initial_partitioning.codegen_units);\n+    debug_dump(tcx, \"INITIAL PARTITIONING\", &codegen_units);\n \n     // Merge until we have at most `max_cgu_count` codegen units.\n+    // `merge_codegen_units` is responsible for updating the CGU size\n+    // estimates.\n     {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_merge_cgus\");\n-        partitioner.merge_codegen_units(cx, &mut initial_partitioning);\n-        debug_dump(tcx, \"POST MERGING\", &initial_partitioning.codegen_units);\n+        partitioner.merge_codegen_units(cx, &mut codegen_units);\n+        debug_dump(tcx, \"POST MERGING\", &codegen_units);\n     }\n \n     // In the next step, we use the inlining map to determine which additional\n     // monomorphizations have to go into each codegen unit. These additional\n     // monomorphizations can be drop-glue, functions from external crates, and\n     // local functions the definition of which is marked with `#[inline]`.\n-    let mut post_inlining = {\n+    let mono_item_placements = {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_place_inline_items\");\n-        partitioner.place_inlined_mono_items(cx, initial_partitioning)\n+        partitioner.place_inlined_mono_items(cx, &mut codegen_units, roots)\n     };\n \n-    for cgu in &mut post_inlining.codegen_units {\n+    for cgu in &mut codegen_units {\n         cgu.create_size_estimate(tcx);\n     }\n \n-    debug_dump(tcx, \"POST INLINING\", &post_inlining.codegen_units);\n+    debug_dump(tcx, \"POST INLINING\", &codegen_units);\n \n     // Next we try to make as many symbols \"internal\" as possible, so LLVM has\n     // more freedom to optimize.\n     if !tcx.sess.link_dead_code() {\n         let _prof_timer = tcx.prof.generic_activity(\"cgu_partitioning_internalize_symbols\");\n-        partitioner.internalize_symbols(cx, &mut post_inlining);\n+        partitioner.internalize_symbols(\n+            cx,\n+            &mut codegen_units,\n+            mono_item_placements,\n+            internalization_candidates,\n+        );\n     }\n \n     let instrument_dead_code =\n         tcx.sess.instrument_coverage() && !tcx.sess.instrument_coverage_except_unused_functions();\n \n     if instrument_dead_code {\n         assert!(\n-            post_inlining.codegen_units.len() > 0,\n+            codegen_units.len() > 0,\n             \"There must be at least one CGU that code coverage data can be generated in.\"\n         );\n \n@@ -297,7 +316,7 @@ where\n         // the object file (CGU) containing the dead function stubs is included\n         // in the final binary. This will probably require forcing these\n         // function symbols to be included via `-u` or `/include` linker args.\n-        let mut cgus: Vec<_> = post_inlining.codegen_units.iter_mut().collect();\n+        let mut cgus: Vec<_> = codegen_units.iter_mut().collect();\n         cgus.sort_by_key(|cgu| cgu.size_estimate());\n \n         let dead_code_cgu =\n@@ -308,29 +327,17 @@ where\n             } else {\n                 // If there are no CGUs that have externally linked items,\n                 // then we just pick the first CGU as a fallback.\n-                &mut post_inlining.codegen_units[0]\n+                &mut codegen_units[0]\n             };\n         dead_code_cgu.make_code_coverage_dead_code_cgu();\n     }\n \n     // Finally, sort by codegen unit name, so that we get deterministic results.\n-    let PostInliningPartitioning {\n-        codegen_units: mut result,\n-        mono_item_placements: _,\n-        internalization_candidates: _,\n-    } = post_inlining;\n+    codegen_units.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n \n-    result.sort_by(|a, b| a.name().as_str().cmp(b.name().as_str()));\n+    debug_dump(tcx, \"FINAL\", &codegen_units);\n \n-    debug_dump(tcx, \"FINAL\", &result);\n-\n-    result\n-}\n-\n-pub struct PreInliningPartitioning<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    roots: FxHashSet<MonoItem<'tcx>>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n+    codegen_units\n }\n \n /// For symbol internalization, we need to know whether a symbol/mono-item is\n@@ -342,12 +349,6 @@ enum MonoItemPlacement {\n     MultipleCgus,\n }\n \n-struct PostInliningPartitioning<'tcx> {\n-    codegen_units: Vec<CodegenUnit<'tcx>>,\n-    mono_item_placements: FxHashMap<MonoItem<'tcx>, MonoItemPlacement>,\n-    internalization_candidates: FxHashSet<MonoItem<'tcx>>,\n-}\n-\n fn debug_dump<'a, 'tcx: 'a>(tcx: TyCtxt<'tcx>, label: &str, cgus: &[CodegenUnit<'tcx>]) {\n     let dump = move || {\n         use std::fmt::Write;"}, {"sha": "9263394508ee3e374838225f420692addc169b2e", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 605, "deletions": 605, "changes": 1210, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,230 +1,298 @@\n-parse_struct_literal_body_without_path =\n-    struct literal body without path\n-    .suggestion = you might have forgotten to add the struct literal inside the block\n+parse_add_paren = try adding parentheses\n \n-parse_struct_literal_needing_parens =\n-    invalid struct literal\n-    .suggestion = you might need to surround the struct literal in parentheses\n+parse_ambiguous_missing_keyword_for_item_definition = missing `fn` or `struct` for function or struct definition\n+    .suggestion = if you meant to call a macro, try\n+    .help = if you meant to call a macro, remove the `pub` and add a trailing `!` after the identifier\n \n-parse_maybe_report_ambiguous_plus =\n-    ambiguous `+` in a type\n-    .suggestion = use parentheses to disambiguate\n+parse_ambiguous_range_pattern = the range pattern here has ambiguous interpretation\n+    .suggestion = add parentheses to clarify the precedence\n \n-parse_maybe_recover_from_bad_type_plus =\n-    expected a path on the left-hand side of `+`, not `{$ty}`\n+parse_array_brackets_instead_of_braces = this is a block expression, not an array\n+    .suggestion = to make an array, use square brackets instead of curly braces\n \n-parse_add_paren = try adding parentheses\n+parse_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n \n-parse_forgot_paren = perhaps you forgot parentheses?\n+parse_assoc_lifetime = associated lifetimes are not supported\n+    .label = the lifetime is given here\n+    .help = if you meant to specify a trait object, write `dyn Trait + 'lifetime`\n \n-parse_expect_path = expected a path\n+parse_associated_static_item_not_allowed = associated `static` items are not allowed\n \n-parse_maybe_recover_from_bad_qpath_stage_2 =\n-    missing angle brackets in associated item path\n-    .suggestion = try: `{$ty}`\n+parse_async_block_in_2015 = `async` blocks are only allowed in Rust 2018 or later\n \n-parse_incorrect_semicolon =\n-    expected item, found `;`\n-    .suggestion = remove this semicolon\n-    .help = {$name} declarations are not followed by a semicolon\n+parse_async_fn_in_2015 = `async fn` is not permitted in Rust 2015\n+    .label = to use `async fn`, switch to Rust 2018 or later\n \n-parse_incorrect_use_of_await =\n-    incorrect use of `await`\n-    .parentheses_suggestion = `await` is not a method call, remove the parentheses\n-    .postfix_suggestion = `await` is a postfix operation\n+parse_async_move_order_incorrect = the order of `move` and `async` is incorrect\n+    .suggestion = try switching the order\n \n-parse_in_in_typo =\n-    expected iterable, found keyword `in`\n-    .suggestion = remove the duplicated `in`\n+parse_attr_after_generic = trailing attribute after generic parameter\n+    .label = attributes must go before parameters\n \n-parse_invalid_variable_declaration =\n-    invalid variable declaration\n+parse_attr_without_generics = attribute without generic parameters\n+    .label = attributes are only permitted when preceding parameters\n \n-parse_switch_mut_let_order =\n-    switch the order of `mut` and `let`\n-parse_missing_let_before_mut = missing keyword\n-parse_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n-parse_use_let_not_var = write `let` instead of `var` to introduce a new variable\n+parse_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n+    .label = attributes are not allowed here\n \n-parse_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n-    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n-    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n+parse_bad_assoc_type_bounds = bounds on associated types do not belong here\n+    .label = belongs in `where` clause\n \n-parse_invalid_logical_operator = `{$incorrect}` is not a logical operator\n-    .note = unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators\n-    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n-    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n+parse_bad_item_kind = {$descr} is not supported in {$ctx}\n+    .help = consider moving the {$descr} out to a nearby module scope\n \n-parse_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n-    .suggestion = use `!` to perform bitwise not\n+parse_bad_return_type_notation_dotdot =\n+    return type notation uses `()` instead of `(..)` for elided arguments\n+    .suggestion = remove the `..`\n \n-parse_unexpected_if_with_if = unexpected `if` in the condition expression\n-    .suggestion = remove the `if`\n+parse_bad_return_type_notation_output =\n+    return type not allowed with return type notation\n+    .suggestion = remove the return type\n \n-parse_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n-parse_unexpected_token_after_not_bitwise = use `!` to perform bitwise not\n-parse_unexpected_token_after_not_logical = use `!` to perform logical negation\n-parse_unexpected_token_after_not_default = use `!` to perform logical negation or bitwise not\n+parse_bare_cr = {$double_quotes ->\n+    [true] bare CR not allowed in string, use `\\r` instead\n+    *[false] character constant must be escaped: `\\r`\n+    }\n+    .escape = escape the character\n \n-parse_malformed_loop_label = malformed loop label\n-    .suggestion = use the correct loop label format\n+parse_bare_cr_in_raw_string = bare CR not allowed in raw string\n \n-parse_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n-    .suggestion = remove the lifetime annotation\n-    .label = annotated with lifetime here\n+parse_binary_float_literal_not_supported = binary float literal is not supported\n+parse_bounds_not_allowed_on_trait_aliases = bounds are not allowed on trait aliases\n \n-parse_field_expression_with_generic = field expressions cannot have generic arguments\n+parse_box_not_pat = expected pattern, found {$descr}\n+    .note = `box` is a reserved keyword\n+    .suggestion = escape `box` to use it as an identifier\n \n-parse_macro_invocation_with_qualified_path = macros cannot use qualified paths\n+parse_box_syntax_removed = `box_syntax` has been removed\n+    .suggestion = use `Box::new()` instead\n \n-parse_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n-    .suggestion_remove_label = consider removing the label\n-    .suggestion_enclose_in_block = consider enclosing expression in a block\n+parse_cannot_be_raw_ident = `{$ident}` cannot be a raw identifier\n \n-parse_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n-    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n-    .label = the label\n-    .suggestion = add `:` after the label\n+parse_catch_after_try = keyword `catch` cannot follow a `try` block\n+    .help = try using `match` on the result of the `try` block instead\n \n-parse_do_catch_syntax_removed = found removed `do catch` syntax\n-    .note = following RFC #2388, the new non-placeholder syntax is `try`\n-    .suggestion = replace with the new syntax\n+parse_cfg_attr_bad_delim = wrong `cfg_attr` delimiters\n+parse_colon_as_semi = statements are terminated with a semicolon\n+    .suggestion = use a semicolon instead\n \n-parse_float_literal_requires_integer_part = float literals must have an integer part\n-    .suggestion = must have an integer part\n+parse_comma_after_base_struct = cannot use a comma after the base struct\n+    .note = the base struct must always be the last field\n+    .suggestion = remove this comma\n \n-parse_invalid_int_literal_width = invalid width `{$width}` for integer literal\n-    .help = valid widths are 8, 16, 32, 64 and 128\n+parse_comparison_interpreted_as_generic =\n+    `<` is interpreted as a start of generic arguments for `{$type}`, not a comparison\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as comparison\n+    .suggestion = try comparing the cast value\n \n-parse_invalid_num_literal_base_prefix = invalid base prefix for number literal\n-    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n-    .suggestion = try making the prefix lowercase\n+parse_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n+    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n+    .sugg_split_comparison = split the comparison into two\n+    .sugg_parenthesize = parenthesize the comparison\n+parse_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n+    .suggestion = initialize the variable\n+    .help = if you meant to overwrite, remove the `let` binding\n \n-parse_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+parse_const_bounds_missing_tilde = const bounds must start with `~`\n+    .suggestion = add `~`\n \n-parse_invalid_float_literal_width = invalid width `{$width}` for float literal\n-    .help = valid widths are 32 and 64\n+parse_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n+    .suggestion = enclose the `const` expression in braces\n \n-parse_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = valid suffixes are `f32` and `f64`\n+parse_const_global_cannot_be_mutable = const globals cannot be mutable\n+    .label = cannot be mutable\n+    .suggestion = you might want to declare a static instead\n \n-parse_int_literal_too_large = integer literal is too large\n+parse_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n+    .suggestion = remove `let`\n \n-parse_missing_semicolon_before_array = expected `;`, found `[`\n-    .suggestion = consider adding `;` here\n+parse_cr_doc_comment = bare CR not allowed in {$block ->\n+    [true] block doc-comment\n+    *[false] doc-comment\n+}\n \n-parse_invalid_block_macro_segment = cannot use a `block` macro fragment here\n-    .label = the `block` fragment is within this context\n+parse_default_not_followed_by_item = `default` is not followed by an item\n+    .label = the `default` qualifier\n+    .note = only `fn`, `const`, `type`, or `impl` items may be prefixed by `default`\n \n-parse_expect_dotdot_not_dotdotdot = expected `..`, found `...`\n-    .suggestion = use `..` to fill in the rest of the fields\n+parse_do_catch_syntax_removed = found removed `do catch` syntax\n+    .note = following RFC #2388, the new non-placeholder syntax is `try`\n+    .suggestion = replace with the new syntax\n \n-parse_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n-    .add_then_block = add a block here\n-    .condition_possibly_unfinished = this binary operation is possibly unfinished\n+parse_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n+    .help = doc comments must come before what they document, if a comment was intended use `//`\n+    .suggestion = missing comma here\n \n-parse_if_expression_missing_condition = missing condition for `if` expression\n-    .condition_label = expected condition here\n-    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n+parse_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n+    .label = doc comments are not allowed here\n \n-parse_expected_expression_found_let = expected expression, found `let` statement\n+parse_dot_dot_dot_for_remaining_fields = expected field pattern, found `{$token_str}`\n+    .suggestion = to omit remaining fields, use `..`\n \n-parse_expect_eq_instead_of_eqeq = expected `=`, found `==`\n-    .suggestion = consider using `=` here\n+parse_dot_dot_dot_range_to_pattern_not_allowed = range-to patterns with `...` are not allowed\n+    .suggestion = use `..=` instead\n \n-parse_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n-    .label = expected an `if` or a block after this `else`\n-    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n+parse_dotdotdot = unexpected token: `...`\n+    .suggest_exclusive_range = use `..` for an exclusive range\n+    .suggest_inclusive_range = or `..=` for an inclusive range\n \n-parse_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n-    .branch_label = the attributes are attached to this branch\n-    .ctx_label = the branch belongs to this `{$ctx}`\n-    .suggestion = remove the attributes\n+parse_dotdotdot_rest_pattern = unexpected `...`\n+    .label = not a valid pattern\n+    .suggestion = for a rest pattern, use `..` instead of `...`\n \n-parse_missing_in_in_for_loop = missing `in` in `for` loop\n-    .use_in_not_of = try using `in` here instead\n-    .add_in = try adding `in` here\n+parse_double_colon_in_bound = expected `:` followed by trait or lifetime\n+    .suggestion = use single colon\n \n-parse_missing_expression_in_for_loop = missing expression to iterate on in `for` loop\n-    .suggestion = try adding an expression to the `for` loop\n+parse_dyn_after_mut = `mut` must precede `dyn`\n+    .suggestion = place `mut` before `dyn`\n \n-parse_loop_else = `{$loop_kind}...else` loops are not supported\n-    .note = consider moving this `else` clause to a separate `if` statement and use a `bool` variable to control if it should run\n-    .loop_keyword = `else` is attached to this loop\n+parse_empty_exponent_float = expected at least one digit in exponent\n \n-parse_missing_comma_after_match_arm = expected `,` following `match` arm\n-    .suggestion = missing a comma here to end this `match` arm\n+parse_empty_unicode_escape = empty unicode escape\n+    .label = this escape must have at least 1 hex digit\n \n-parse_catch_after_try = keyword `catch` cannot follow a `try` block\n-    .help = try using `match` on the result of the `try` block instead\n+parse_enum_pattern_instead_of_identifier = expected identifier, found enum pattern\n \n-parse_comma_after_base_struct = cannot use a comma after the base struct\n-    .note = the base struct must always be the last field\n-    .suggestion = remove this comma\n+parse_enum_struct_mutually_exclusive = `enum` and `struct` are mutually exclusive\n+    .suggestion = replace `enum struct` with\n \n parse_eq_field_init = expected `:`, found `=`\n     .suggestion = replace equals symbol with a colon\n \n-parse_dotdotdot = unexpected token: `...`\n-    .suggest_exclusive_range = use `..` for an exclusive range\n-    .suggest_inclusive_range = or `..=` for an inclusive range\n+parse_equals_struct_default = default values on `struct` fields aren't supported\n+    .suggestion = remove this unsupported default value\n \n-parse_left_arrow_operator = unexpected token: `<-`\n-    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`\n+parse_escape_only_char = {$byte ->\n+    [true] byte\n+    *[false] character\n+    } constant must be escaped: `{$escaped_msg}`\n+    .escape = escape the character\n \n-parse_remove_let = expected pattern, found `let`\n-    .suggestion = remove the unnecessary `let` keyword\n+parse_expect_dotdot_not_dotdotdot = expected `..`, found `...`\n+    .suggestion = use `..` to fill in the rest of the fields\n \n-parse_use_eq_instead = unexpected `==`\n-    .suggestion = try using `=` instead\n+parse_expect_eq_instead_of_eqeq = expected `=`, found `==`\n+    .suggestion = consider using `=` here\n \n-parse_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n-    .suggestion = try using { \"`{}`\" } instead\n+parse_expect_label_found_ident = expected a label, found an identifier\n+    .suggestion = labels start with a tick\n \n-parse_comparison_interpreted_as_generic =\n-    `<` is interpreted as a start of generic arguments for `{$type}`, not a comparison\n-    .label_args = interpreted as generic arguments\n-    .label_comparison = not interpreted as comparison\n-    .suggestion = try comparing the cast value\n+parse_expect_path = expected a path\n \n-parse_shift_interpreted_as_generic =\n-    `<<` is interpreted as a start of generic arguments for `{$type}`, not a shift\n-    .label_args = interpreted as generic arguments\n-    .label_comparison = not interpreted as shift\n-    .suggestion = try shifting the cast value\n+parse_expected_binding_left_of_at = left-hand side of `@` must be a binding\n+    .label_lhs = interpreted as a pattern, not a binding\n+    .label_rhs = also a pattern\n+    .note = bindings are `x`, `mut x`, `ref x`, and `ref mut x`\n+\n+parse_expected_builtin_ident = expected identifier after `builtin #`\n+\n+parse_expected_comma_after_pattern_field = expected `,`\n+\n+parse_expected_else_block = expected `{\"{\"}`, found {$first_tok}\n+    .label = expected an `if` or a block after this `else`\n+    .suggestion = add an `if` if this is the condition of a chained `else if` statement\n+\n+parse_expected_expression_found_let = expected expression, found `let` statement\n+\n+parse_expected_fn_path_found_fn_keyword = expected identifier, found keyword `fn`\n+    .suggestion = use `Fn` to refer to the trait\n+\n+parse_expected_identifier = expected identifier\n+\n+parse_expected_identifier_found_doc_comment = expected identifier, found doc comment\n+parse_expected_identifier_found_doc_comment_str = expected identifier, found doc comment `{$token}`\n+parse_expected_identifier_found_keyword = expected identifier, found keyword\n+parse_expected_identifier_found_keyword_str = expected identifier, found keyword `{$token}`\n+parse_expected_identifier_found_reserved_identifier = expected identifier, found reserved identifier\n+parse_expected_identifier_found_reserved_identifier_str = expected identifier, found reserved identifier `{$token}`\n+parse_expected_identifier_found_reserved_keyword = expected identifier, found reserved keyword\n+parse_expected_identifier_found_reserved_keyword_str = expected identifier, found reserved keyword `{$token}`\n+parse_expected_identifier_found_str = expected identifier, found `{$token}`\n+\n+parse_expected_mut_or_const_in_raw_pointer_type = expected `mut` or `const` keyword in raw pointer type\n+    .suggestion = add `mut` or `const` here\n+\n+parse_expected_semi_found_doc_comment_str = expected `;`, found doc comment `{$token}`\n+parse_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`\n+parse_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n+parse_expected_semi_found_reserved_keyword_str = expected `;`, found reserved keyword `{$token}`\n+parse_expected_semi_found_str = expected `;`, found `{$token}`\n+\n+parse_expected_statement_after_outer_attr = expected statement after outer attribute\n+\n+parse_expected_trait_in_trait_impl_found_type = expected a trait, found type\n+\n+parse_extern_crate_name_with_dashes = crate name using dashes are not valid in `extern crate` statements\n+    .label = dash-separated idents are not valid\n+    .suggestion = if the original crate name uses dashes you need to use underscores in the code\n+\n+parse_extern_item_cannot_be_const = extern items cannot be `const`\n+    .suggestion = try using a static value\n+    .note = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+\n+parse_extra_if_in_let_else = remove the `if` if you meant to write a `let...else` statement\n+\n+parse_extra_impl_keyword_in_trait_impl = unexpected `impl` keyword\n+    .suggestion = remove the extra `impl`\n+    .note = this is parsed as an `impl Trait` type, but a trait is expected at this position\n+\n+\n+parse_field_expression_with_generic = field expressions cannot have generic arguments\n+\n+parse_float_literal_requires_integer_part = float literals must have an integer part\n+    .suggestion = must have an integer part\n+\n+parse_float_literal_unsupported_base = {$base} float literal is not supported\n+\n+parse_fn_pointer_cannot_be_async = an `fn` pointer type cannot be `async`\n+    .label = `async` because of this\n+    .suggestion = remove the `async` qualifier\n+\n+parse_fn_pointer_cannot_be_const = an `fn` pointer type cannot be `const`\n+    .label = `const` because of this\n+    .suggestion = remove the `const` qualifier\n+\n+parse_fn_ptr_with_generics = function pointer types may not have generic parameters\n+    .suggestion = consider moving the lifetime {$arity ->\n+        [one] parameter\n+        *[other] parameters\n+    } to {$for_param_list_exists ->\n+        [true] the\n+        *[false] a\n+    } `for` parameter list\n+\n+parse_forgot_paren = perhaps you forgot parentheses?\n \n parse_found_expr_would_be_stmt = expected expression, found `{$token}`\n     .label = expected expression\n \n-parse_leading_plus_not_supported = leading `+` is not supported\n-    .label = unexpected `+`\n-    .suggestion_remove_plus = try removing the `+`\n+parse_function_body_equals_expr = function body cannot be `= expression;`\n+    .suggestion = surround the expression with `{\"{\"}` and `{\"}\"}` instead of `=` and `;`\n \n-parse_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n-    .suggestion_braces_for_struct = if `{$type}` is a struct, use braces as delimiters\n-    .suggestion_no_fields_for_fn = if `{$type}` is a function, use the arguments directly\n+parse_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n+    .suggestion = surround the type parameters with angle brackets\n \n-parse_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n+parse_generics_in_path = unexpected generic arguments in path\n \n-parse_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n+parse_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n+parse_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n+parse_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n+parse_if_expression_missing_condition = missing condition for `if` expression\n+    .condition_label = expected condition here\n+    .block_label = if this block is the condition of the `if` expression, then it must be followed by another block\n \n-parse_array_brackets_instead_of_braces = this is a block expression, not an array\n-    .suggestion = to make an array, use square brackets instead of curly braces\n+parse_if_expression_missing_then_block = this `if` expression is missing a block after the condition\n+    .add_then_block = add a block here\n+    .condition_possibly_unfinished = this binary operation is possibly unfinished\n \n-parse_match_arm_body_without_braces = `match` arm body without braces\n-    .label_statements = {$num_statements ->\n-            [one] this statement is not surrounded by a body\n-           *[other] these statements are not surrounded by a body\n-        }\n-    .label_arrow = while parsing the `match` arm starting here\n-    .suggestion_add_braces = surround the {$num_statements ->\n-            [one] statement\n-           *[other] statements\n-        } with a body\n-    .suggestion_use_comma_not_semicolon = replace `;` with `,` to end a `match` arm expression\n+parse_in_in_typo =\n+    expected iterable, found keyword `in`\n+    .suggestion = remove the duplicated `in`\n+\n+parse_inappropriate_default = {$article} {$descr} cannot be `default`\n+    .label = `default` because of this\n+    .note = only associated `fn`, `const`, and `type` items can be `default`\n \n parse_inclusive_range_extra_equals = unexpected `=` after inclusive range\n     .suggestion_remove_eq = use `..=` instead\n@@ -238,36 +306,18 @@ parse_inclusive_range_no_end = inclusive range with no end\n     .suggestion_open_range = use `..` instead\n     .note = inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\n \n-parse_struct_literal_not_allowed_here = struct literals are not allowed here\n-    .suggestion = surround the struct literal with parentheses\n-\n-parse_invalid_interpolated_expression = invalid interpolated expression\n-\n-parse_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n-parse_octal_float_literal_not_supported = octal float literal is not supported\n-parse_binary_float_literal_not_supported = binary float literal is not supported\n-parse_not_supported = not supported\n-\n-parse_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n-    .label = invalid suffix `{$suffix}`\n-\n-parse_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are invalid\n-    .label = invalid suffix `{$suffix}`\n-    .tuple_exception_line_1 = `{$suffix}` is *temporarily* accepted on tuple index fields as it was incorrectly accepted on stable for a few releases\n-    .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n-    .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n-\n-parse_expected_builtin_ident = expected identifier after `builtin #`\n-\n-parse_unknown_builtin_construct = unknown `builtin #` construct `{$name}`\n+parse_incorrect_braces_trait_bounds = incorrect braces around trait bounds\n+    .suggestion = remove the parentheses\n \n-parse_non_string_abi_literal = non-string ABI literal\n-    .suggestion = specify the ABI with a string literal\n+parse_incorrect_semicolon =\n+    expected item, found `;`\n+    .suggestion = remove this semicolon\n+    .help = {$name} declarations are not followed by a semicolon\n \n-parse_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n-    .label_unmatched = mismatched closing delimiter\n-    .label_opening_candidate = closing delimiter possibly meant for this\n-    .label_unclosed = unclosed delimiter\n+parse_incorrect_use_of_await =\n+    incorrect use of `await`\n+    .parentheses_suggestion = `await` is not a method call, remove the parentheses\n+    .postfix_suggestion = `await` is a postfix operation\n \n parse_incorrect_visibility_restriction = incorrect visibility restriction\n     .help = some possible visibility restrictions are:\n@@ -276,36 +326,8 @@ parse_incorrect_visibility_restriction = incorrect visibility restriction\n             `pub(in path::to::module)`: visible only on the specified path\n     .suggestion = make this visible only to module `{$inner_str}` with `in`\n \n-parse_assignment_else_not_allowed = <assignment> ... else {\"{\"} ... {\"}\"} is not allowed\n-\n-parse_expected_statement_after_outer_attr = expected statement after outer attribute\n-\n-parse_doc_comment_does_not_document_anything = found a documentation comment that doesn't document anything\n-    .help = doc comments must come before what they document, if a comment was intended use `//`\n-    .suggestion = missing comma here\n-\n-parse_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n-    .suggestion = remove `let`\n-\n-parse_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n-parse_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n-parse_extra_if_in_let_else = remove the `if` if you meant to write a `let...else` statement\n-\n-parse_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n-    .suggestion = initialize the variable\n-    .help = if you meant to overwrite, remove the `let` binding\n-\n-parse_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n-    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n-\n-parse_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`\n-\n-parse_label_inner_attr_does_not_annotate_this = the inner attribute doesn't annotate this {$item}\n-parse_sugg_change_inner_attr_to_outer = to annotate the {$item}, change the attribute from inner to outer style\n-\n-parse_inner_attr_not_permitted_after_outer_doc_comment = an inner attribute is not permitted following an outer doc comment\n-    .label_attr = not permitted following an outer doc comment\n-    .label_prev_doc_comment = previous doc comment\n+parse_inner_attr_explanation = inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n+parse_inner_attr_not_permitted = an inner attribute is not permitted in this context\n     .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n     .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n \n@@ -315,522 +337,480 @@ parse_inner_attr_not_permitted_after_outer_attr = an inner attribute is not perm\n     .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n     .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n \n-parse_inner_attr_not_permitted = an inner attribute is not permitted in this context\n+parse_inner_attr_not_permitted_after_outer_doc_comment = an inner attribute is not permitted following an outer doc comment\n+    .label_attr = not permitted following an outer doc comment\n+    .label_prev_doc_comment = previous doc comment\n     .label_does_not_annotate_this = {parse_label_inner_attr_does_not_annotate_this}\n     .sugg_change_inner_to_outer = {parse_sugg_change_inner_attr_to_outer}\n \n-parse_inner_attr_explanation = inner attributes, like `#![no_std]`, annotate the item enclosing them, and are usually found at the beginning of source files\n-parse_outer_attr_explanation = outer attributes, like `#[test]`, annotate the item following them\n-\n parse_inner_doc_comment_not_permitted = expected outer doc comment\n     .note = inner doc comments like this (starting with `//!` or `/*!`) can only appear before items\n     .suggestion = you might have meant to write a regular comment\n     .label_does_not_annotate_this = the inner doc comment doesn't annotate this {$item}\n     .sugg_change_inner_to_outer = to annotate the {$item}, change the doc comment from inner to outer style\n \n-parse_expected_identifier_found_reserved_identifier_str = expected identifier, found reserved identifier `{$token}`\n-parse_expected_identifier_found_keyword_str = expected identifier, found keyword `{$token}`\n-parse_expected_identifier_found_reserved_keyword_str = expected identifier, found reserved keyword `{$token}`\n-parse_expected_identifier_found_doc_comment_str = expected identifier, found doc comment `{$token}`\n-parse_expected_identifier_found_str = expected identifier, found `{$token}`\n+parse_int_literal_too_large = integer literal is too large\n \n-parse_expected_identifier_found_reserved_identifier = expected identifier, found reserved identifier\n-parse_expected_identifier_found_keyword = expected identifier, found keyword\n-parse_expected_identifier_found_reserved_keyword = expected identifier, found reserved keyword\n-parse_expected_identifier_found_doc_comment = expected identifier, found doc comment\n-parse_expected_identifier = expected identifier\n+parse_invalid_block_macro_segment = cannot use a `block` macro fragment here\n+    .label = the `block` fragment is within this context\n \n-parse_sugg_escape_identifier = escape `{$ident_name}` to use it as an identifier\n+parse_invalid_char_in_escape = {parse_invalid_char_in_escape_msg}: `{$ch}`\n+    .label = {parse_invalid_char_in_escape_msg}\n \n-parse_sugg_remove_comma = remove this comma\n-parse_sugg_add_let_for_stmt = you might have meant to introduce a new binding\n+parse_invalid_char_in_escape_msg = invalid character in {$is_hex ->\n+    [true] numeric character\n+    *[false] unicode\n+    } escape\n \n-parse_expected_semi_found_reserved_identifier_str = expected `;`, found reserved identifier `{$token}`\n-parse_expected_semi_found_keyword_str = expected `;`, found keyword `{$token}`\n-parse_expected_semi_found_reserved_keyword_str = expected `;`, found reserved keyword `{$token}`\n-parse_expected_semi_found_doc_comment_str = expected `;`, found doc comment `{$token}`\n-parse_expected_semi_found_str = expected `;`, found `{$token}`\n+parse_invalid_comparison_operator = invalid comparison operator `{$invalid}`\n+    .use_instead = `{$invalid}` is not a valid comparison operator, use `{$correct}`\n+    .spaceship_operator_invalid = `<=>` is not a valid comparison operator, use `std::cmp::Ordering`\n \n-parse_sugg_change_this_to_semi = change this to `;`\n-parse_sugg_add_semi = add `;` here\n-parse_label_unexpected_token = unexpected token\n+parse_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n+parse_invalid_digit_literal = invalid digit for a base {$base} literal\n \n-parse_unmatched_angle_brackets = {$num_extra_brackets ->\n-        [one] unmatched angle bracket\n-       *[other] unmatched angle brackets\n-    }\n-    .suggestion = {$num_extra_brackets ->\n-            [one] remove extra angle bracket\n-           *[other] remove extra angle brackets\n-        }\n-\n-parse_generic_parameters_without_angle_brackets = generic parameters without surrounding angle brackets\n-    .suggestion = surround the type parameters with angle brackets\n-\n-parse_comparison_operators_cannot_be_chained = comparison operators cannot be chained\n-    .sugg_parentheses_for_function_args = or use `(...)` if you meant to specify fn arguments\n-    .sugg_split_comparison = split the comparison into two\n-    .sugg_parenthesize = parenthesize the comparison\n-parse_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n-\n-parse_question_mark_in_type = invalid `?` in type\n-    .label = `?` is only allowed on expressions, not types\n-    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n+parse_invalid_dyn_keyword = invalid `dyn` keyword\n+    .help = `dyn` is only needed at the start of a trait `+`-separated list\n+    .suggestion = remove this keyword\n \n-parse_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n-    .suggestion = remove parentheses in `for` loop\n+parse_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n+parse_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = valid suffixes are `f32` and `f64`\n \n-parse_doc_comment_on_param_type = documentation comments cannot be applied to a function parameter's type\n-    .label = doc comments are not allowed here\n+parse_invalid_float_literal_width = invalid width `{$width}` for float literal\n+    .help = valid widths are 32 and 64\n \n-parse_attribute_on_param_type = attributes cannot be applied to a function parameter's type\n-    .label = attributes are not allowed here\n+parse_invalid_identifier_with_leading_number = identifiers cannot start with a number\n \n-parse_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n-    .suggestion = give this argument a name or use an underscore to ignore it\n+parse_invalid_int_literal_width = invalid width `{$width}` for integer literal\n+    .help = valid widths are 8, 16, 32, 64 and 128\n \n-parse_self_param_not_first = unexpected `self` parameter in function\n-    .label = must be the first parameter of an associated function\n+parse_invalid_interpolated_expression = invalid interpolated expression\n \n-parse_const_generic_without_braces = expressions must be enclosed in braces to be used as const generic arguments\n-    .suggestion = enclose the `const` expression in braces\n+parse_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n+    .label = invalid suffix `{$suffix}`\n \n-parse_unexpected_const_param_declaration = unexpected `const` parameter declaration\n-    .label = expected a `const` expression, not a parameter declaration\n-    .suggestion = `const` parameters must be declared for the `impl`\n+parse_invalid_literal_suffix_on_tuple_index = suffixes on a tuple index are invalid\n+    .label = invalid suffix `{$suffix}`\n+    .tuple_exception_line_1 = `{$suffix}` is *temporarily* accepted on tuple index fields as it was incorrectly accepted on stable for a few releases\n+    .tuple_exception_line_2 = on proc macros, you'll want to use `syn::Index::from` or `proc_macro::Literal::*_unsuffixed` for code that will desugar to tuple field access\n+    .tuple_exception_line_3 = see issue #60210 <https://github.com/rust-lang/rust/issues/60210> for more information\n \n-parse_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n-    .suggestion = the `const` keyword is only needed in the definition of the type\n+parse_invalid_logical_operator = `{$incorrect}` is not a logical operator\n+    .note = unlike in e.g., Python and PHP, `&&` and `||` are used for logical operators\n+    .use_amp_amp_for_conjunction = use `&&` to perform logical conjunction\n+    .use_pipe_pipe_for_disjunction = use `||` to perform logical disjunction\n \n-parse_async_move_order_incorrect = the order of `move` and `async` is incorrect\n-    .suggestion = try switching the order\n+parse_invalid_meta_item = expected unsuffixed literal or identifier, found `{$token}`\n \n-parse_double_colon_in_bound = expected `:` followed by trait or lifetime\n-    .suggestion = use single colon\n+parse_invalid_num_literal_base_prefix = invalid base prefix for number literal\n+    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n+    .suggestion = try making the prefix lowercase\n \n-parse_fn_ptr_with_generics = function pointer types may not have generic parameters\n-    .suggestion = consider moving the lifetime {$arity ->\n-        [one] parameter\n-        *[other] parameters\n-    } to {$for_param_list_exists ->\n-        [true] the\n-        *[false] a\n-    } `for` parameter list\n+parse_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n \n-parse_invalid_identifier_with_leading_number = identifiers cannot start with a number\n+parse_invalid_unicode_escape = invalid unicode character escape\n+    .label = invalid escape\n+    .help = unicode escape must {$surrogate ->\n+    [true] not be a surrogate\n+    *[false] be at most 10FFFF\n+    }\n \n-parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of `fn`\n-    .suggestion = replace `fn` with `impl` here\n+parse_invalid_variable_declaration =\n+    invalid variable declaration\n \n-parse_expected_fn_path_found_fn_keyword = expected identifier, found keyword `fn`\n-    .suggestion = use `Fn` to refer to the trait\n+parse_kw_bad_case = keyword `{$kw}` is written in the wrong case\n+    .suggestion = write it in the correct case\n \n-parse_path_single_colon = path separator must be a double colon\n-    .suggestion = use a double colon instead\n+parse_label_inner_attr_does_not_annotate_this = the inner attribute doesn't annotate this {$item}\n+parse_label_unexpected_token = unexpected token\n \n-parse_colon_as_semi = statements are terminated with a semicolon\n-    .suggestion = use a semicolon instead\n+parse_label_while_parsing_or_pattern_here = while parsing this or-pattern starting here\n \n-parse_type_ascription_removed =\n-    if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n+parse_labeled_loop_in_break = parentheses are required around this expression to avoid confusion with a labeled break expression\n \n-parse_where_clause_before_tuple_struct_body = where clauses are not allowed before tuple struct bodies\n-    .label = unexpected where clause\n-    .name_label = while parsing this tuple struct\n-    .body_label = the struct body\n-    .suggestion = move the body before the where clause\n+parse_leading_plus_not_supported = leading `+` is not supported\n+    .label = unexpected `+`\n+    .suggestion_remove_plus = try removing the `+`\n \n-parse_async_fn_in_2015 = `async fn` is not permitted in Rust 2015\n-    .label = to use `async fn`, switch to Rust 2018 or later\n+parse_leading_underscore_unicode_escape = {parse_leading_underscore_unicode_escape_label}: `_`\n+parse_leading_underscore_unicode_escape_label = invalid start of unicode escape\n \n-parse_async_block_in_2015 = `async` blocks are only allowed in Rust 2018 or later\n+parse_left_arrow_operator = unexpected token: `<-`\n+    .suggestion = if you meant to write a comparison against a negative value, add a space in between `<` and `-`\n \n-parse_self_argument_pointer = cannot pass `self` by raw pointer\n-    .label = cannot pass `self` by raw pointer\n+parse_lifetime_after_mut = lifetime must precede `mut`\n+    .suggestion = place the lifetime before `mut`\n \n-parse_visibility_not_followed_by_item = visibility `{$vis}` is not followed by an item\n-    .label = the visibility\n-    .help = you likely meant to define an item, e.g., `{$vis} fn foo() {\"{}\"}`\n+parse_lifetime_in_borrow_expression = borrow expressions cannot be annotated with lifetimes\n+    .suggestion = remove the lifetime annotation\n+    .label = annotated with lifetime here\n \n-parse_default_not_followed_by_item = `default` is not followed by an item\n-    .label = the `default` qualifier\n-    .note = only `fn`, `const`, `type`, or `impl` items may be prefixed by `default`\n+parse_lone_slash = invalid trailing slash in literal\n+    .label = {parse_lone_slash}\n \n-parse_missing_struct_for_struct_definition = missing `struct` for struct definition\n-    .suggestion = add `struct` here to parse `{$ident}` as a public struct\n+parse_loop_else = `{$loop_kind}...else` loops are not supported\n+    .note = consider moving this `else` clause to a separate `if` statement and use a `bool` variable to control if it should run\n+    .loop_keyword = `else` is attached to this loop\n \n-parse_missing_fn_for_function_definition = missing `fn` for function definition\n-    .suggestion = add `fn` here to parse `{$ident}` as a public function\n+parse_macro_invocation_visibility = can't qualify macro invocation with `pub`\n+    .suggestion = remove the visibility\n+    .help = try adjusting the macro to put `{$vis}` inside the invocation\n \n-parse_missing_fn_for_method_definition = missing `fn` for method definition\n-    .suggestion = add `fn` here to parse `{$ident}` as a public method\n+parse_macro_invocation_with_qualified_path = macros cannot use qualified paths\n \n-parse_ambiguous_missing_keyword_for_item_definition = missing `fn` or `struct` for function or struct definition\n-    .suggestion = if you meant to call a macro, try\n-    .help = if you meant to call a macro, remove the `pub` and add a trailing `!` after the identifier\n+parse_macro_name_remove_bang = macro names aren't followed by a `!`\n+    .suggestion = remove the `!`\n \n-parse_missing_trait_in_trait_impl = missing trait in a trait impl\n-    .suggestion_add_trait = add a trait here\n-    .suggestion_remove_for = for an inherent impl, drop this `for`\n+parse_macro_rules_missing_bang = expected `!` after `macro_rules`\n+    .suggestion = add a `!`\n \n-parse_missing_for_in_trait_impl = missing `for` in a trait impl\n-    .suggestion = add `for` here\n+parse_macro_rules_visibility = can't qualify macro_rules invocation with `{$vis}`\n+    .suggestion = try exporting the macro\n \n-parse_expected_trait_in_trait_impl_found_type = expected a trait, found type\n+parse_malformed_cfg_attr = malformed `cfg_attr` attribute input\n+    .suggestion = missing condition and attribute\n+    .note = for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n-parse_extra_impl_keyword_in_trait_impl = unexpected `impl` keyword\n-    .suggestion = remove the extra `impl`\n-    .note = this is parsed as an `impl Trait` type, but a trait is expected at this position\n+parse_malformed_loop_label = malformed loop label\n+    .suggestion = use the correct loop label format\n \n+parse_match_arm_body_without_braces = `match` arm body without braces\n+    .label_statements = {$num_statements ->\n+            [one] this statement is not surrounded by a body\n+           *[other] these statements are not surrounded by a body\n+        }\n+    .label_arrow = while parsing the `match` arm starting here\n+    .suggestion_add_braces = surround the {$num_statements ->\n+            [one] statement\n+           *[other] statements\n+        } with a body\n+    .suggestion_use_comma_not_semicolon = replace `;` with `,` to end a `match` arm expression\n \n-parse_non_item_in_item_list = non-item in item list\n-    .suggestion_use_const_not_let = consider using `const` instead of `let` for associated const\n-    .label_list_start = item list starts here\n-    .label_non_item = non-item starts here\n-    .label_list_end = item list ends here\n-    .suggestion_remove_semicolon = consider removing this semicolon\n+parse_maybe_fn_typo_with_impl = you might have meant to write `impl` instead of `fn`\n+    .suggestion = replace `fn` with `impl` here\n \n-parse_bounds_not_allowed_on_trait_aliases = bounds are not allowed on trait aliases\n+parse_maybe_recover_from_bad_qpath_stage_2 =\n+    missing angle brackets in associated item path\n+    .suggestion = try: `{$ty}`\n \n-parse_trait_alias_cannot_be_auto = trait aliases cannot be `auto`\n-parse_trait_alias_cannot_be_unsafe = trait aliases cannot be `unsafe`\n+parse_maybe_recover_from_bad_type_plus =\n+    expected a path on the left-hand side of `+`, not `{$ty}`\n \n-parse_associated_static_item_not_allowed = associated `static` items are not allowed\n+parse_maybe_report_ambiguous_plus =\n+    ambiguous `+` in a type\n+    .suggestion = use parentheses to disambiguate\n \n-parse_extern_crate_name_with_dashes = crate name using dashes are not valid in `extern crate` statements\n-    .label = dash-separated idents are not valid\n-    .suggestion = if the original crate name uses dashes you need to use underscores in the code\n+parse_meta_bad_delim = wrong meta list delimiters\n+parse_meta_bad_delim_suggestion = the delimiters should be `(` and `)`\n \n-parse_extern_item_cannot_be_const = extern items cannot be `const`\n-    .suggestion = try using a static value\n-    .note = for more information, visit https://doc.rust-lang.org/std/keyword.extern.html\n+parse_mismatched_closing_delimiter = mismatched closing delimiter: `{$delimiter}`\n+    .label_unmatched = mismatched closing delimiter\n+    .label_opening_candidate = closing delimiter possibly meant for this\n+    .label_unclosed = unclosed delimiter\n \n-parse_const_global_cannot_be_mutable = const globals cannot be mutable\n-    .label = cannot be mutable\n-    .suggestion = you might want to declare a static instead\n+parse_missing_comma_after_match_arm = expected `,` following `match` arm\n+    .suggestion = missing a comma here to end this `match` arm\n \n parse_missing_const_type = missing type for `{$kind}` item\n     .suggestion = provide a type for the item\n \n-parse_enum_struct_mutually_exclusive = `enum` and `struct` are mutually exclusive\n-    .suggestion = replace `enum struct` with\n-\n-parse_unexpected_token_after_struct_name = expected `where`, `{\"{\"}`, `(`, or `;` after struct name\n-parse_unexpected_token_after_struct_name_found_reserved_identifier = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved identifier `{$token}`\n-parse_unexpected_token_after_struct_name_found_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found keyword `{$token}`\n-parse_unexpected_token_after_struct_name_found_reserved_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved keyword `{$token}`\n-parse_unexpected_token_after_struct_name_found_doc_comment = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found doc comment `{$token}`\n-parse_unexpected_token_after_struct_name_found_other = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found `{$token}`\n-\n-parse_unexpected_self_in_generic_parameters = unexpected keyword `Self` in generic parameters\n-    .note = you cannot use `Self` as a generic parameter because it is reserved for associated items\n-\n-parse_unexpected_default_value_for_lifetime_in_generic_parameters = unexpected default lifetime parameter\n-    .label = lifetime parameters cannot have default values\n-\n-parse_multiple_where_clauses = cannot define duplicate `where` clauses on an item\n-    .label = previous `where` clause starts here\n-    .suggestion = consider joining the two `where` clauses into one\n-\n-parse_nonterminal_expected_item_keyword = expected an item keyword\n-parse_nonterminal_expected_statement = expected a statement\n-parse_nonterminal_expected_ident = expected ident, found `{$token}`\n-parse_nonterminal_expected_lifetime = expected a lifetime, found `{$token}`\n+parse_missing_expression_in_for_loop = missing expression to iterate on in `for` loop\n+    .suggestion = try adding an expression to the `for` loop\n \n-parse_or_pattern_not_allowed_in_let_binding = top-level or-patterns are not allowed in `let` bindings\n-parse_or_pattern_not_allowed_in_fn_parameters = top-level or-patterns are not allowed in function parameters\n-parse_sugg_remove_leading_vert_in_pattern = remove the `|`\n-parse_sugg_wrap_pattern_in_parens = wrap the pattern in parentheses\n+parse_missing_fn_for_function_definition = missing `fn` for function definition\n+    .suggestion = add `fn` here to parse `{$ident}` as a public function\n \n-parse_note_pattern_alternatives_use_single_vert = alternatives in or-patterns are separated with `|`, not `||`\n+parse_missing_fn_for_method_definition = missing `fn` for method definition\n+    .suggestion = add `fn` here to parse `{$ident}` as a public method\n \n-parse_unexpected_vert_vert_before_function_parameter = unexpected `||` before function parameter\n-    .suggestion = remove the `||`\n+parse_missing_for_in_trait_impl = missing `for` in a trait impl\n+    .suggestion = add `for` here\n \n-parse_label_while_parsing_or_pattern_here = while parsing this or-pattern starting here\n+parse_missing_in_in_for_loop = missing `in` in `for` loop\n+    .use_in_not_of = try using `in` here instead\n+    .add_in = try adding `in` here\n \n-parse_unexpected_vert_vert_in_pattern = unexpected token `||` in pattern\n-    .suggestion = use a single `|` to separate multiple alternative patterns\n+parse_missing_let_before_mut = missing keyword\n+parse_missing_plus_in_bounds = expected `+` between lifetime and {$sym}\n+    .suggestion = add `+`\n \n-parse_trailing_vert_not_allowed = a trailing `|` is not allowed in an or-pattern\n-    .suggestion = remove the `{$token}`\n+parse_missing_semicolon_before_array = expected `;`, found `[`\n+    .suggestion = consider adding `;` here\n \n-parse_dotdotdot_rest_pattern = unexpected `...`\n-    .label = not a valid pattern\n-    .suggestion = for a rest pattern, use `..` instead of `...`\n+parse_missing_struct_for_struct_definition = missing `struct` for struct definition\n+    .suggestion = add `struct` here to parse `{$ident}` as a public struct\n \n-parse_pattern_on_wrong_side_of_at = pattern on wrong side of `@`\n-    .label_pattern = pattern on the left, should be on the right\n-    .label_binding = binding on the right, should be on the left\n-    .suggestion = switch the order\n+parse_missing_trait_in_trait_impl = missing trait in a trait impl\n+    .suggestion_add_trait = add a trait here\n+    .suggestion_remove_for = for an inherent impl, drop this `for`\n \n-parse_expected_binding_left_of_at = left-hand side of `@` must be a binding\n-    .label_lhs = interpreted as a pattern, not a binding\n-    .label_rhs = also a pattern\n-    .note = bindings are `x`, `mut x`, `ref x`, and `ref mut x`\n+parse_modifier_lifetime = `{$sigil}` may only modify trait bounds, not lifetime bounds\n+    .suggestion = remove the `{$sigil}`\n \n-parse_ambiguous_range_pattern = the range pattern here has ambiguous interpretation\n-    .suggestion = add parentheses to clarify the precedence\n+parse_more_than_one_char = character literal may only contain one codepoint\n+    .followed_by = this `{$chr}` is followed by the combining {$len ->\n+        [one] mark\n+        *[other] marks\n+        } `{$escaped_marks}`\n+    .non_printing = there are non-printing characters, the full sequence is `{$escaped}`\n+    .consider_normalized = consider using the normalized form `{$ch}` of this character\n+    .remove_non = consider removing the non-printing characters\n+    .use_double_quotes = if you meant to write a {$is_byte ->\n+        [true] byte string\n+        *[false] `str`\n+        } literal, use double quotes\n \n-parse_unexpected_lifetime_in_pattern = unexpected lifetime `{$symbol}` in pattern\n-    .suggestion = remove the lifetime\n+parse_multiple_skipped_lines = multiple lines skipped by escaped newline\n+    .label = skipping everything up to and including this point\n \n-parse_ref_mut_order_incorrect = the order of `mut` and `ref` is incorrect\n-    .suggestion = try switching the order\n+parse_multiple_where_clauses = cannot define duplicate `where` clauses on an item\n+    .label = previous `where` clause starts here\n+    .suggestion = consider joining the two `where` clauses into one\n \n parse_mut_on_nested_ident_pattern = `mut` must be attached to each individual binding\n     .suggestion = add `mut` to each binding\n parse_mut_on_non_ident_pattern = `mut` must be followed by a named binding\n     .suggestion = remove the `mut` prefix\n-parse_note_mut_pattern_usage = `mut` may be followed by `variable` and `variable @ pattern`\n-\n-parse_repeated_mut_in_pattern = `mut` on a binding may not be repeated\n-    .suggestion = remove the additional `mut`s\n-\n-parse_dot_dot_dot_range_to_pattern_not_allowed = range-to patterns with `...` are not allowed\n-    .suggestion = use `..=` instead\n-\n-parse_enum_pattern_instead_of_identifier = expected identifier, found enum pattern\n-\n-parse_dot_dot_dot_for_remaining_fields = expected field pattern, found `{$token_str}`\n-    .suggestion = to omit remaining fields, use `..`\n+parse_need_plus_after_trait_object_lifetime = lifetime in trait object type must be followed by `+`\n \n-parse_expected_comma_after_pattern_field = expected `,`\n+parse_nested_adt = `{$kw_str}` definition cannot be nested inside `{$keyword}`\n+    .suggestion = consider creating a new `{$kw_str}` definition instead of nesting\n \n-parse_return_types_use_thin_arrow = return types are denoted using `->`\n-    .suggestion = use `->` instead\n+parse_nested_c_variadic_type = C-variadic type `...` may not be nested inside another type\n \n-parse_need_plus_after_trait_object_lifetime = lifetime in trait object type must be followed by `+`\n+parse_no_brace_unicode_escape = incorrect unicode escape sequence\n+    .label = {parse_no_brace_unicode_escape}\n+    .use_braces = format of unicode escape sequences uses braces\n+    .format_of_unicode = format of unicode escape sequences is `\\u{\"{...}\"}`\n \n-parse_expected_mut_or_const_in_raw_pointer_type = expected `mut` or `const` keyword in raw pointer type\n-    .suggestion = add `mut` or `const` here\n+parse_no_digits_literal = no valid digits found for number\n \n-parse_lifetime_after_mut = lifetime must precede `mut`\n-    .suggestion = place the lifetime before `mut`\n+parse_non_item_in_item_list = non-item in item list\n+    .suggestion_use_const_not_let = consider using `const` instead of `let` for associated const\n+    .label_list_start = item list starts here\n+    .label_non_item = non-item starts here\n+    .label_list_end = item list ends here\n+    .suggestion_remove_semicolon = consider removing this semicolon\n \n-parse_dyn_after_mut = `mut` must precede `dyn`\n-    .suggestion = place `mut` before `dyn`\n+parse_non_string_abi_literal = non-string ABI literal\n+    .suggestion = specify the ABI with a string literal\n \n-parse_fn_pointer_cannot_be_const = an `fn` pointer type cannot be `const`\n-    .label = `const` because of this\n-    .suggestion = remove the `const` qualifier\n+parse_nonterminal_expected_ident = expected ident, found `{$token}`\n+parse_nonterminal_expected_item_keyword = expected an item keyword\n+parse_nonterminal_expected_lifetime = expected a lifetime, found `{$token}`\n \n-parse_fn_pointer_cannot_be_async = an `fn` pointer type cannot be `async`\n-    .label = `async` because of this\n-    .suggestion = remove the `async` qualifier\n+parse_nonterminal_expected_statement = expected a statement\n+parse_not_supported = not supported\n \n-parse_nested_c_variadic_type = C-variadic type `...` may not be nested inside another type\n+parse_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n \n-parse_invalid_dyn_keyword = invalid `dyn` keyword\n-    .help = `dyn` is only needed at the start of a trait `+`-separated list\n-    .suggestion = remove this keyword\n+parse_note_mut_pattern_usage = `mut` may be followed by `variable` and `variable @ pattern`\n \n-parse_help_set_edition_cargo = set `edition = \"{$edition}\"` in `Cargo.toml`\n-parse_help_set_edition_standalone = pass `--edition {$edition}` to `rustc`\n-parse_note_edition_guide = for more on editions, read https://doc.rust-lang.org/edition-guide\n+parse_note_pattern_alternatives_use_single_vert = alternatives in or-patterns are separated with `|`, not `||`\n \n-parse_unexpected_token_after_dot = unexpected token: `{$actual}`\n+parse_octal_float_literal_not_supported = octal float literal is not supported\n+parse_or_pattern_not_allowed_in_fn_parameters = top-level or-patterns are not allowed in function parameters\n+parse_or_pattern_not_allowed_in_let_binding = top-level or-patterns are not allowed in `let` bindings\n+parse_out_of_range_hex_escape = out of range hex escape\n+    .label = must be a character in the range [\\x00-\\x7f]\n \n-parse_cannot_be_raw_ident = `{$ident}` cannot be a raw identifier\n+parse_outer_attr_explanation = outer attributes, like `#[test]`, annotate the item following them\n \n-parse_cr_doc_comment = bare CR not allowed in {$block ->\n-    [true] block doc-comment\n-    *[false] doc-comment\n-}\n+parse_outer_attribute_not_allowed_on_if_else = outer attributes are not allowed on `if` and `else` branches\n+    .branch_label = the attributes are attached to this branch\n+    .ctx_label = the branch belongs to this `{$ctx}`\n+    .suggestion = remove the attributes\n \n-parse_no_digits_literal = no valid digits found for number\n+parse_overlong_unicode_escape = overlong unicode escape\n+    .label = must have at most 6 hex digits\n \n-parse_invalid_digit_literal = invalid digit for a base {$base} literal\n+parse_parentheses_with_struct_fields = invalid `struct` delimiters or `fn` call arguments\n+    .suggestion_braces_for_struct = if `{$type}` is a struct, use braces as delimiters\n+    .suggestion_no_fields_for_fn = if `{$type}` is a function, use the arguments directly\n \n-parse_empty_exponent_float = expected at least one digit in exponent\n+parse_parenthesized_lifetime = parenthesized lifetime bounds are not supported\n+    .suggestion = remove the parentheses\n \n-parse_float_literal_unsupported_base = {$base} float literal is not supported\n+parse_path_single_colon = path separator must be a double colon\n+    .suggestion = use a double colon instead\n \n-parse_more_than_one_char = character literal may only contain one codepoint\n-    .followed_by = this `{$chr}` is followed by the combining {$len ->\n-        [one] mark\n-        *[other] marks\n-        } `{$escaped_marks}`\n-    .non_printing = there are non-printing characters, the full sequence is `{$escaped}`\n-    .consider_normalized = consider using the normalized form `{$ch}` of this character\n-    .remove_non = consider removing the non-printing characters\n-    .use_double_quotes = if you meant to write a {$is_byte ->\n-        [true] byte string\n-        *[false] `str`\n-        } literal, use double quotes\n+parse_pattern_method_param_without_body = patterns aren't allowed in methods without bodies\n+    .suggestion = give this argument a name or use an underscore to ignore it\n \n-parse_no_brace_unicode_escape = incorrect unicode escape sequence\n-    .label = {parse_no_brace_unicode_escape}\n-    .use_braces = format of unicode escape sequences uses braces\n-    .format_of_unicode = format of unicode escape sequences is `\\u{\"{...}\"}`\n+parse_pattern_on_wrong_side_of_at = pattern on wrong side of `@`\n+    .label_pattern = pattern on the left, should be on the right\n+    .label_binding = binding on the right, should be on the left\n+    .suggestion = switch the order\n \n-parse_invalid_unicode_escape = invalid unicode character escape\n-    .label = invalid escape\n-    .help = unicode escape must {$surrogate ->\n-    [true] not be a surrogate\n-    *[false] be at most 10FFFF\n-    }\n+parse_question_mark_in_type = invalid `?` in type\n+    .label = `?` is only allowed on expressions, not types\n+    .suggestion = if you meant to express that the type might not contain a value, use the `Option` wrapper type\n \n-parse_escape_only_char = {$byte ->\n-    [true] byte\n-    *[false] character\n-    } constant must be escaped: `{$escaped_msg}`\n-    .escape = escape the character\n+parse_recover_import_as_use = expected item, found {$token_name}\n+    .suggestion = items are imported using the `use` keyword\n \n-parse_bare_cr = {$double_quotes ->\n-    [true] bare CR not allowed in string, use `\\r` instead\n-    *[false] character constant must be escaped: `\\r`\n-    }\n-    .escape = escape the character\n+parse_ref_mut_order_incorrect = the order of `mut` and `ref` is incorrect\n+    .suggestion = try switching the order\n \n-parse_bare_cr_in_raw_string = bare CR not allowed in raw string\n+parse_remove_let = expected pattern, found `let`\n+    .suggestion = remove the unnecessary `let` keyword\n \n-parse_too_short_hex_escape = numeric character escape is too short\n+parse_repeated_mut_in_pattern = `mut` on a binding may not be repeated\n+    .suggestion = remove the additional `mut`s\n \n-parse_invalid_char_in_escape = {parse_invalid_char_in_escape_msg}: `{$ch}`\n-    .label = {parse_invalid_char_in_escape_msg}\n+parse_require_colon_after_labeled_expression = labeled expression must be followed by `:`\n+    .note = labels are used before loops and blocks, allowing e.g., `break 'label` to them\n+    .label = the label\n+    .suggestion = add `:` after the label\n \n-parse_invalid_char_in_escape_msg = invalid character in {$is_hex ->\n-    [true] numeric character\n-    *[false] unicode\n-    } escape\n+parse_return_types_use_thin_arrow = return types are denoted using `->`\n+    .suggestion = use `->` instead\n \n-parse_out_of_range_hex_escape = out of range hex escape\n-    .label = must be a character in the range [\\x00-\\x7f]\n+parse_self_argument_pointer = cannot pass `self` by raw pointer\n+    .label = cannot pass `self` by raw pointer\n \n-parse_leading_underscore_unicode_escape = {parse_leading_underscore_unicode_escape_label}: `_`\n-parse_leading_underscore_unicode_escape_label = invalid start of unicode escape\n+parse_self_param_not_first = unexpected `self` parameter in function\n+    .label = must be the first parameter of an associated function\n \n-parse_overlong_unicode_escape = overlong unicode escape\n-    .label = must have at most 6 hex digits\n+parse_shift_interpreted_as_generic =\n+    `<<` is interpreted as a start of generic arguments for `{$type}`, not a shift\n+    .label_args = interpreted as generic arguments\n+    .label_comparison = not interpreted as shift\n+    .suggestion = try shifting the cast value\n \n-parse_unclosed_unicode_escape = unterminated unicode escape\n-    .label = missing a closing `{\"}\"}`\n-    .terminate = terminate the unicode escape\n+parse_single_colon_import_path = expected `::`, found `:`\n+    .suggestion = use double colon\n+    .note = import paths are delimited using `::`\n \n-parse_unicode_escape_in_byte = unicode escape in byte string\n-    .label = {parse_unicode_escape_in_byte}\n-    .help = unicode escape sequences cannot be used as a byte or in a byte string\n+parse_single_colon_struct_type = found single colon in a struct field type path\n+    .suggestion = write a path separator here\n \n-parse_empty_unicode_escape = empty unicode escape\n-    .label = this escape must have at least 1 hex digit\n+parse_struct_literal_body_without_path =\n+    struct literal body without path\n+    .suggestion = you might have forgotten to add the struct literal inside the block\n \n-parse_zero_chars = empty character literal\n-    .label = {parse_zero_chars}\n+parse_struct_literal_needing_parens =\n+    invalid struct literal\n+    .suggestion = you might need to surround the struct literal in parentheses\n \n-parse_lone_slash = invalid trailing slash in literal\n-    .label = {parse_lone_slash}\n+parse_struct_literal_not_allowed_here = struct literals are not allowed here\n+    .suggestion = surround the struct literal with parentheses\n \n-parse_unskipped_whitespace = whitespace symbol '{$ch}' is not skipped\n-    .label = {parse_unskipped_whitespace}\n+parse_suffixed_literal_in_attribute = suffixed literals are not allowed in attributes\n+    .help = instead of using a suffixed literal (`1u8`, `1.0f32`, etc.), use an unsuffixed version (`1`, `1.0`, etc.)\n \n-parse_multiple_skipped_lines = multiple lines skipped by escaped newline\n-    .label = skipping everything up to and including this point\n+parse_sugg_add_let_for_stmt = you might have meant to introduce a new binding\n \n-parse_unknown_prefix = prefix `{$prefix}` is unknown\n-    .label = unknown prefix\n-    .note =  prefixed identifiers and literals are reserved since Rust 2021\n-    .suggestion_br = use `br` for a raw byte string\n-    .suggestion_whitespace = consider inserting whitespace here\n+parse_sugg_add_semi = add `;` here\n+parse_sugg_change_inner_attr_to_outer = to annotate the {$item}, change the attribute from inner to outer style\n \n-parse_too_many_hashes = too many `#` symbols: raw strings may be delimited by up to 255 `#` symbols, but found {$num}\n+parse_sugg_change_this_to_semi = change this to `;`\n+parse_sugg_escape_identifier = escape `{$ident_name}` to use it as an identifier\n \n-parse_unknown_start_of_token = unknown start of token: {$escaped}\n-    .sugg_quotes = Unicode characters '\u201c' (Left Double Quotation Mark) and '\u201d' (Right Double Quotation Mark) look like '{$ascii_str}' ({$ascii_name}), but are not\n-    .sugg_other = Unicode character '{$ch}' ({$u_name}) looks like '{$ascii_str}' ({$ascii_name}), but it is not\n-    .help_null = source files must contain UTF-8 encoded text, unexpected null bytes might occur when a different encoding is used\n-    .note_repeats = character appears {$repeats ->\n-        [one] once more\n-        *[other] {$repeats} more times\n-    }\n+parse_sugg_remove_comma = remove this comma\n+parse_sugg_remove_leading_vert_in_pattern = remove the `|`\n+parse_sugg_turbofish_syntax = use `::<...>` instead of `<...>` to specify lifetime, type, or const arguments\n \n-parse_box_syntax_removed = `box_syntax` has been removed\n-    .suggestion = use `Box::new()` instead\n+parse_sugg_wrap_expression_in_parentheses = wrap the expression in parentheses\n \n-parse_bad_return_type_notation_output =\n-    return type not allowed with return type notation\n-    .suggestion = remove the return type\n+parse_sugg_wrap_pattern_in_parens = wrap the pattern in parentheses\n \n-parse_bad_return_type_notation_dotdot =\n-    return type notation uses `()` instead of `(..)` for elided arguments\n-    .suggestion = remove the `..`\n+parse_switch_mut_let_order =\n+    switch the order of `mut` and `let`\n+parse_tilde_const_lifetime = `~const` may only modify trait bounds, not lifetime bounds\n \n-parse_bad_assoc_type_bounds = bounds on associated types do not belong here\n-    .label = belongs in `where` clause\n+parse_tilde_is_not_unary_operator = `~` cannot be used as a unary operator\n+    .suggestion = use `!` to perform bitwise not\n \n-parse_attr_after_generic = trailing attribute after generic parameter\n-    .label = attributes must go before parameters\n+parse_too_many_hashes = too many `#` symbols: raw strings may be delimited by up to 255 `#` symbols, but found {$num}\n \n-parse_attr_without_generics = attribute without generic parameters\n-    .label = attributes are only permitted when preceding parameters\n+parse_too_short_hex_escape = numeric character escape is too short\n \n-parse_where_generics = generic parameters on `where` clauses are reserved for future use\n-    .label = currently unsupported\n+parse_trailing_vert_not_allowed = a trailing `|` is not allowed in an or-pattern\n+    .suggestion = remove the `{$token}`\n \n-parse_generics_in_path = unexpected generic arguments in path\n+parse_trait_alias_cannot_be_auto = trait aliases cannot be `auto`\n+parse_trait_alias_cannot_be_unsafe = trait aliases cannot be `unsafe`\n \n-parse_assoc_lifetime = associated lifetimes are not supported\n-    .label = the lifetime is given here\n-    .help = if you meant to specify a trait object, write `dyn Trait + 'lifetime`\n+parse_type_ascription_removed =\n+    if you meant to annotate an expression with a type, the type ascription syntax has been removed, see issue #101728 <https://github.com/rust-lang/rust/issues/101728>\n \n-parse_tilde_const_lifetime = `~const` may only modify trait bounds, not lifetime bounds\n+parse_unclosed_unicode_escape = unterminated unicode escape\n+    .label = missing a closing `{\"}\"}`\n+    .terminate = terminate the unicode escape\n \n-parse_modifier_lifetime = `{$sigil}` may only modify trait bounds, not lifetime bounds\n-    .suggestion = remove the `{$sigil}`\n+parse_underscore_literal_suffix = underscore literal suffix is not allowed\n \n-parse_parenthesized_lifetime = parenthesized lifetime bounds are not supported\n-    .suggestion = remove the parentheses\n+parse_unexpected_const_in_generic_param = expected lifetime, type, or constant, found keyword `const`\n+    .suggestion = the `const` keyword is only needed in the definition of the type\n \n-parse_const_bounds_missing_tilde = const bounds must start with `~`\n-    .suggestion = add `~`\n+parse_unexpected_const_param_declaration = unexpected `const` parameter declaration\n+    .label = expected a `const` expression, not a parameter declaration\n+    .suggestion = `const` parameters must be declared for the `impl`\n \n-parse_underscore_literal_suffix = underscore literal suffix is not allowed\n+parse_unexpected_default_value_for_lifetime_in_generic_parameters = unexpected default lifetime parameter\n+    .label = lifetime parameters cannot have default values\n \n-parse_expect_label_found_ident = expected a label, found an identifier\n-    .suggestion = labels start with a tick\n+parse_unexpected_if_with_if = unexpected `if` in the condition expression\n+    .suggestion = remove the `if`\n \n-parse_inappropriate_default = {$article} {$descr} cannot be `default`\n-    .label = `default` because of this\n-    .note = only associated `fn`, `const`, and `type` items can be `default`\n+parse_unexpected_lifetime_in_pattern = unexpected lifetime `{$symbol}` in pattern\n+    .suggestion = remove the lifetime\n \n-parse_recover_import_as_use = expected item, found {$token_name}\n-    .suggestion = items are imported using the `use` keyword\n+parse_unexpected_parentheses_in_for_head = unexpected parentheses surrounding `for` loop head\n+    .suggestion = remove parentheses in `for` loop\n \n-parse_single_colon_import_path = expected `::`, found `:`\n-    .suggestion = use double colon\n-    .note = import paths are delimited using `::`\n+parse_unexpected_self_in_generic_parameters = unexpected keyword `Self` in generic parameters\n+    .note = you cannot use `Self` as a generic parameter because it is reserved for associated items\n \n-parse_bad_item_kind = {$descr} is not supported in {$ctx}\n-    .help = consider moving the {$descr} out to a nearby module scope\n+parse_unexpected_token_after_dot = unexpected token: `{$actual}`\n \n-parse_single_colon_struct_type = found single colon in a struct field type path\n-    .suggestion = write a path separator here\n+parse_unexpected_token_after_label = expected `while`, `for`, `loop` or `{\"{\"}` after a label\n+    .suggestion_remove_label = consider removing the label\n+    .suggestion_enclose_in_block = consider enclosing expression in a block\n \n-parse_equals_struct_default = default values on `struct` fields aren't supported\n-    .suggestion = remove this unsupported default value\n+parse_unexpected_token_after_not = unexpected {$negated_desc} after identifier\n+parse_unexpected_token_after_not_bitwise = use `!` to perform bitwise not\n+parse_unexpected_token_after_not_default = use `!` to perform logical negation or bitwise not\n \n-parse_macro_rules_missing_bang = expected `!` after `macro_rules`\n-    .suggestion = add a `!`\n+parse_unexpected_token_after_not_logical = use `!` to perform logical negation\n+parse_unexpected_token_after_struct_name = expected `where`, `{\"{\"}`, `(`, or `;` after struct name\n+parse_unexpected_token_after_struct_name_found_doc_comment = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found doc comment `{$token}`\n+parse_unexpected_token_after_struct_name_found_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found keyword `{$token}`\n+parse_unexpected_token_after_struct_name_found_other = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found `{$token}`\n \n-parse_macro_name_remove_bang = macro names aren't followed by a `!`\n-    .suggestion = remove the `!`\n+parse_unexpected_token_after_struct_name_found_reserved_identifier = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved identifier `{$token}`\n+parse_unexpected_token_after_struct_name_found_reserved_keyword = expected `where`, `{\"{\"}`, `(`, or `;` after struct name, found reserved keyword `{$token}`\n+parse_unexpected_vert_vert_before_function_parameter = unexpected `||` before function parameter\n+    .suggestion = remove the `||`\n \n-parse_macro_rules_visibility = can't qualify macro_rules invocation with `{$vis}`\n-    .suggestion = try exporting the macro\n+parse_unexpected_vert_vert_in_pattern = unexpected token `||` in pattern\n+    .suggestion = use a single `|` to separate multiple alternative patterns\n \n-parse_macro_invocation_visibility = can't qualify macro invocation with `pub`\n-    .suggestion = remove the visibility\n-    .help = try adjusting the macro to put `{$vis}` inside the invocation\n+parse_unicode_escape_in_byte = unicode escape in byte string\n+    .label = {parse_unicode_escape_in_byte}\n+    .help = unicode escape sequences cannot be used as a byte or in a byte string\n \n-parse_nested_adt = `{$kw_str}` definition cannot be nested inside `{$keyword}`\n-    .suggestion = consider creating a new `{$kw_str}` definition instead of nesting\n+parse_unknown_builtin_construct = unknown `builtin #` construct `{$name}`\n \n-parse_function_body_equals_expr = function body cannot be `= expression;`\n-    .suggestion = surround the expression with `{\"{\"}` and `{\"}\"}` instead of `=` and `;`\n+parse_unknown_prefix = prefix `{$prefix}` is unknown\n+    .label = unknown prefix\n+    .note =  prefixed identifiers and literals are reserved since Rust 2021\n+    .suggestion_br = use `br` for a raw byte string\n+    .suggestion_whitespace = consider inserting whitespace here\n \n-parse_box_not_pat = expected pattern, found {$descr}\n-    .note = `box` is a reserved keyword\n-    .suggestion = escape `box` to use it as an identifier\n+parse_unknown_start_of_token = unknown start of token: {$escaped}\n+    .sugg_quotes = Unicode characters '\u201c' (Left Double Quotation Mark) and '\u201d' (Right Double Quotation Mark) look like '{$ascii_str}' ({$ascii_name}), but are not\n+    .sugg_other = Unicode character '{$ch}' ({$u_name}) looks like '{$ascii_str}' ({$ascii_name}), but it is not\n+    .help_null = source files must contain UTF-8 encoded text, unexpected null bytes might occur when a different encoding is used\n+    .note_repeats = character appears {$repeats ->\n+        [one] once more\n+        *[other] {$repeats} more times\n+    }\n \n parse_unmatched_angle = unmatched angle {$plural ->\n     [true] brackets\n@@ -841,19 +821,39 @@ parse_unmatched_angle = unmatched angle {$plural ->\n     *[false] bracket\n     }\n \n-parse_missing_plus_in_bounds = expected `+` between lifetime and {$sym}\n-    .suggestion = add `+`\n+parse_unmatched_angle_brackets = {$num_extra_brackets ->\n+        [one] unmatched angle bracket\n+       *[other] unmatched angle brackets\n+    }\n+    .suggestion = {$num_extra_brackets ->\n+            [one] remove extra angle bracket\n+           *[other] remove extra angle brackets\n+        }\n \n-parse_incorrect_braces_trait_bounds = incorrect braces around trait bounds\n-    .suggestion = remove the parentheses\n+parse_unskipped_whitespace = whitespace symbol '{$ch}' is not skipped\n+    .label = {parse_unskipped_whitespace}\n \n-parse_kw_bad_case = keyword `{$kw}` is written in the wrong case\n-    .suggestion = write it in the correct case\n+parse_use_empty_block_not_semi = expected { \"`{}`\" }, found `;`\n+    .suggestion = try using { \"`{}`\" } instead\n \n-parse_meta_bad_delim = wrong meta list delimiters\n-parse_cfg_attr_bad_delim = wrong `cfg_attr` delimiters\n-parse_meta_bad_delim_suggestion = the delimiters should be `(` and `)`\n+parse_use_eq_instead = unexpected `==`\n+    .suggestion = try using `=` instead\n \n-parse_malformed_cfg_attr = malformed `cfg_attr` attribute input\n-    .suggestion = missing condition and attribute\n-    .note = for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n+parse_use_let_not_auto = write `let` instead of `auto` to introduce a new variable\n+parse_use_let_not_var = write `let` instead of `var` to introduce a new variable\n+\n+parse_visibility_not_followed_by_item = visibility `{$vis}` is not followed by an item\n+    .label = the visibility\n+    .help = you likely meant to define an item, e.g., `{$vis} fn foo() {\"{}\"}`\n+\n+parse_where_clause_before_tuple_struct_body = where clauses are not allowed before tuple struct bodies\n+    .label = unexpected where clause\n+    .name_label = while parsing this tuple struct\n+    .body_label = the struct body\n+    .suggestion = move the body before the where clause\n+\n+parse_where_generics = generic parameters on `where` clauses are reserved for future use\n+    .label = currently unsupported\n+\n+parse_zero_chars = empty character literal\n+    .label = {parse_zero_chars}"}, {"sha": "1e6ac54964f99146c1256fced271d4c8961ade3d", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -72,7 +72,7 @@ fn has_cfg_or_cfg_attr(attrs: &[Attribute]) -> bool {\n     // Therefore, the absence of a literal `cfg` or `cfg_attr` guarantees that\n     // we don't need to do any eager expansion.\n     attrs.iter().any(|attr| {\n-        attr.ident().map_or(false, |ident| ident.name == sym::cfg || ident.name == sym::cfg_attr)\n+        attr.ident().is_some_and(|ident| ident.name == sym::cfg || ident.name == sym::cfg_attr)\n     })\n }\n "}, {"sha": "c14540396857477dd3c73efea847dad01ef97572", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -845,7 +845,7 @@ impl<'a> Parser<'a> {\n         //\n         // `x.foo::<u32>>>(3)`\n         let parsed_angle_bracket_args =\n-            segment.args.as_ref().map_or(false, |args| args.is_angle_bracketed());\n+            segment.args.as_ref().is_some_and(|args| args.is_angle_bracketed());\n \n         debug!(\n             \"check_trailing_angle_brackets: parsed_angle_bracket_args={:?}\",\n@@ -2610,7 +2610,7 @@ impl<'a> Parser<'a> {\n         let TyKind::Path(qself, path) = &ty.kind else { return Ok(()) };\n         let qself_position = qself.as_ref().map(|qself| qself.position);\n         for (i, segments) in path.segments.windows(2).enumerate() {\n-            if qself_position.map(|pos| i < pos).unwrap_or(false) {\n+            if qself_position.is_some_and(|pos| i < pos) {\n                 continue;\n             }\n             if let [a, b] = segments {"}, {"sha": "1b28f3c97e8f674d2e6d94bc3f19fd2503ffb848", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1188,7 +1188,7 @@ impl<'a> Parser<'a> {\n                             // `token.kind` should not be compared here.\n                             // This is because the `snapshot.token.kind` is treated as the same as\n                             // that of the open delim in `TokenTreesReader::parse_token_tree`, even if they are different.\n-                            self.span_to_snippet(close_paren).map_or(false, |snippet| snippet == \")\")\n+                            self.span_to_snippet(close_paren).is_ok_and(|snippet| snippet == \")\")\n                         {\n                             let mut replacement_err = errors::ParenthesesWithStructFields {\n                                 span,\n@@ -2078,7 +2078,7 @@ impl<'a> Parser<'a> {\n                     // Therefore, `token.kind` should not be compared here.\n                     if snapshot\n                         .span_to_snippet(snapshot.token.span)\n-                        .map_or(false, |snippet| snippet == \"]\") =>\n+                        .is_ok_and(|snippet| snippet == \"]\") =>\n                 {\n                     return Err(errors::MissingSemicolonBeforeArray {\n                         open_delim: open_delim_span,\n@@ -2773,7 +2773,7 @@ impl<'a> Parser<'a> {\n                 // We might have a `=>` -> `=` or `->` typo (issue #89396).\n                 if TokenKind::FatArrow\n                     .similar_tokens()\n-                    .map_or(false, |similar_tokens| similar_tokens.contains(&this.token.kind))\n+                    .is_some_and(|similar_tokens| similar_tokens.contains(&this.token.kind))\n                 {\n                     err.span_suggestion(\n                         this.token.span,\n@@ -3059,7 +3059,7 @@ impl<'a> Parser<'a> {\n                 }\n             };\n \n-            let is_shorthand = parsed_field.as_ref().map_or(false, |f| f.is_shorthand);\n+            let is_shorthand = parsed_field.as_ref().is_some_and(|f| f.is_shorthand);\n             // A shorthand field can be turned into a full field with `:`.\n             // We should point this out.\n             self.check_or_expected(!is_shorthand, TokenType::Token(token::Colon));"}, {"sha": "3783ec41b7e23a7bb93b6c40afce6f3436ddf453", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -699,7 +699,7 @@ impl<'a> Parser<'a> {\n                         // ```\n                         && self\n                             .span_to_snippet(self.prev_token.span)\n-                            .map_or(false, |snippet| snippet == \"}\")\n+                            .is_ok_and(|snippet| snippet == \"}\")\n                         && self.token.kind == token::Semi;\n                     let mut semicolon_span = self.token.span;\n                     if !is_unnecessary_semicolon {"}, {"sha": "7f9222dac6c4c69c9aa7a11c25d955610a150327", "filename": "compiler/rustc_passes/messages.ftl", "status": "modified", "additions": 536, "deletions": 536, "changes": 1072, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -4,533 +4,489 @@\n -passes_see_issue =\n     see issue #{$issue} <https://github.com/rust-lang/rust/issues/{$issue}> for more information\n \n-passes_incorrect_do_not_recommend_location =\n-    `#[do_not_recommend]` can only be placed on trait implementations\n+passes_abi =\n+    abi: {$abi}\n \n-passes_outer_crate_level_attr =\n-    crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n+passes_align =\n+    align: {$align}\n \n-passes_inner_crate_level_attr =\n-    crate-level attribute should be in the root module\n+passes_allow_incoherent_impl =\n+    `rustc_allow_incoherent_impl` attribute should be applied to impl items.\n+    .label = the only currently supported targets are inherent methods\n \n-passes_ignored_attr_with_macro =\n-    `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n-    .warn = {-passes_previously_accepted}\n-    .note = {-passes_see_issue(issue: \"80564\")}\n+passes_allow_internal_unstable =\n+    attribute should be applied to a macro\n+    .label = not a macro\n \n-passes_ignored_attr =\n-    `#[{$sym}]` is ignored on struct fields and match arms\n-    .warn = {-passes_previously_accepted}\n-    .note = {-passes_see_issue(issue: \"80564\")}\n+passes_attr_application_enum =\n+    attribute should be applied to an enum\n+    .label = not an enum\n \n-passes_inline_ignored_function_prototype =\n-    `#[inline]` is ignored on function prototypes\n+passes_attr_application_struct =\n+    attribute should be applied to a struct\n+    .label = not a struct\n \n-passes_inline_ignored_constants =\n-    `#[inline]` is ignored on constants\n-    .warn = {-passes_previously_accepted}\n-    .note = {-passes_see_issue(issue: \"65833\")}\n+passes_attr_application_struct_enum_function_method_union =\n+    attribute should be applied to a struct, enum, function, associated function, or union\n+    .label = not a struct, enum, function, associated function, or union\n \n-passes_inline_not_fn_or_closure =\n-    attribute should be applied to function or closure\n-    .label = not a function or closure\n+passes_attr_application_struct_enum_union =\n+    attribute should be applied to a struct, enum, or union\n+    .label = not a struct, enum, or union\n \n-passes_no_coverage_ignored_function_prototype =\n-    `#[no_coverage]` is ignored on function prototypes\n+passes_attr_application_struct_union =\n+    attribute should be applied to a struct or union\n+    .label = not a struct or union\n \n-passes_no_coverage_propagate =\n-    `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n+passes_attr_crate_level =\n+    this attribute can only be applied at the crate level\n+    .suggestion = to apply to the crate, use an inner attribute\n+    .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n-passes_no_coverage_fn_defn =\n-    `#[no_coverage]` may only be applied to function definitions\n+passes_attr_only_in_functions =\n+    `{$attr}` attribute can only be used on functions\n \n-passes_no_coverage_not_coverable =\n-    `#[no_coverage]` must be applied to coverable code\n-    .label = not coverable code\n+passes_attr_only_on_main =\n+    `{$attr}` attribute can only be used on `fn main()`\n \n-passes_should_be_applied_to_fn =\n-    attribute should be applied to a function definition\n-    .label = {$on_crate ->\n-        [true] cannot be applied to crates\n-        *[false] not a function definition\n-    }\n+passes_attr_only_on_root_main =\n+    `{$attr}` attribute can only be used on root `fn main()`\n \n-passes_naked_tracked_caller =\n-    cannot use `#[track_caller]` with `#[naked]`\n+passes_both_ffi_const_and_pure =\n+    `#[ffi_const]` function cannot be `#[ffi_pure]`\n \n-passes_should_be_applied_to_struct_enum =\n-    attribute should be applied to a struct or enum\n-    .label = not a struct or enum\n+passes_break_inside_async_block =\n+    `{$name}` inside of an `async` block\n+    .label = cannot `{$name}` inside of an `async` block\n+    .async_block_label = enclosing `async` block\n \n-passes_should_be_applied_to_trait =\n-    attribute should be applied to a trait\n-    .label = not a trait\n+passes_break_inside_closure =\n+    `{$name}` inside of a closure\n+    .label = cannot `{$name}` inside of a closure\n+    .closure_label = enclosing closure\n \n-passes_target_feature_on_statement =\n+passes_break_non_loop =\n+    `break` with value from a `{$kind}` loop\n+    .label = can only break with a value inside `loop` or breakable block\n+    .label2 = you can't `break` with a value in a `{$kind}` loop\n+    .suggestion = use `break` on its own without a value inside this `{$kind}` loop\n+    .break_expr_suggestion = alternatively, you might have meant to use the available loop label\n+\n+passes_cannot_inline_naked_function =\n+    naked functions cannot be inlined\n+\n+passes_cannot_stabilize_deprecated =\n+    an API can't be stabilized after it is deprecated\n+    .label = invalid version\n+    .item = the stability attribute annotates this item\n+\n+passes_change_fields_to_be_of_unit_type =\n+    consider changing the { $num ->\n+      [one] field\n+     *[other] fields\n+    } to be of unit type to suppress this warning while preserving the field numbering, or remove the { $num ->\n+      [one] field\n+     *[other] fields\n+    }\n+\n+passes_cold =\n     {passes_should_be_applied_to_fn}\n     .warn = {-passes_previously_accepted}\n     .label = {passes_should_be_applied_to_fn.label}\n \n-passes_should_be_applied_to_static =\n-    attribute should be applied to a static\n-    .label = not a static\n+passes_collapse_debuginfo =\n+    `collapse_debuginfo` attribute should be applied to macro definitions\n+    .label = not a macro definition\n \n-passes_doc_expect_str =\n-    doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n+passes_const_impl_const_trait =\n+    const `impl`s must be for traits marked with `#[const_trait]`\n+    .note = this trait must be annotated with `#[const_trait]`\n \n-passes_doc_alias_empty =\n-    {$attr_str} attribute cannot have empty value\n+passes_const_trait =\n+    attribute should be applied to a trait\n+\n+passes_continue_labeled_block =\n+    `continue` pointing to a labeled block\n+    .label = labeled blocks cannot be `continue`'d\n+    .block_label = labeled block the `continue` points to\n+\n+passes_dead_codes =\n+    { $multiple ->\n+      *[true] multiple {$descr}s are\n+       [false] { $num ->\n+         [one] {$descr} {$name_list} is\n+        *[other] {$descr}s {$name_list} are\n+       }\n+    } never {$participle}\n+\n+passes_debug_visualizer_invalid =\n+    invalid argument\n+    .note_1 = expected: `natvis_file = \"...\"`\n+    .note_2 = OR\n+    .note_3 = expected: `gdb_script_file = \"...\"`\n+\n+passes_debug_visualizer_placement =\n+    attribute should be applied to a module\n+\n+passes_debug_visualizer_unreadable =\n+    couldn't read {$file}: {$error}\n+\n+passes_deprecated =\n+    attribute is ignored here\n+\n+passes_deprecated_annotation_has_no_effect =\n+    this `#[deprecated]` annotation has no effect\n+    .suggestion = remove the unnecessary deprecation attribute\n+\n+passes_deprecated_attribute =\n+    deprecated attribute must be paired with either stable or unstable attribute\n+\n+passes_diagnostic_item_first_defined =\n+    the diagnostic item is first defined here\n \n passes_doc_alias_bad_char =\n     {$char_} character isn't allowed in {$attr_str}\n \n-passes_doc_alias_start_end =\n-    {$attr_str} cannot start or end with ' '\n-\n passes_doc_alias_bad_location =\n     {$attr_str} isn't allowed on {$location}\n \n-passes_doc_alias_not_an_alias =\n-    {$attr_str} is the same as the item's name\n-\n passes_doc_alias_duplicated = doc alias is duplicated\n     .label = first defined here\n \n-passes_doc_alias_not_string_literal =\n-    `#[doc(alias(\"a\"))]` expects string literals\n+passes_doc_alias_empty =\n+    {$attr_str} attribute cannot have empty value\n \n passes_doc_alias_malformed =\n     doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n \n-passes_doc_keyword_empty_mod =\n-    `#[doc(keyword = \"...\")]` should be used on empty modules\n+passes_doc_alias_not_an_alias =\n+    {$attr_str} is the same as the item's name\n \n-passes_doc_keyword_not_mod =\n-    `#[doc(keyword = \"...\")]` should be used on modules\n+passes_doc_alias_not_string_literal =\n+    `#[doc(alias(\"a\"))]` expects string literals\n \n-passes_doc_keyword_invalid_ident =\n-    `{$doc_keyword}` is not a valid identifier\n+passes_doc_alias_start_end =\n+    {$attr_str} cannot start or end with ' '\n+\n+passes_doc_attr_not_crate_level =\n+    `#![doc({$attr_name} = \"...\")]` isn't allowed as a crate-level attribute\n+\n+passes_doc_cfg_hide_takes_list =\n+    `#[doc(cfg_hide(...)]` takes a list of attributes\n+\n+passes_doc_expect_str =\n+    doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n \n passes_doc_fake_variadic_not_valid =\n     `#[doc(fake_variadic)]` must be used on the first of a set of tuple or fn pointer trait impls with varying arity\n \n-passes_doc_keyword_only_impl =\n-    `#[doc(keyword = \"...\")]` should be used on impl blocks\n+passes_doc_inline_conflict =\n+    conflicting doc inlining attributes\n+    .help = remove one of the conflicting attributes\n \n passes_doc_inline_conflict_first =\n     this attribute...\n \n passes_doc_inline_conflict_second =\n     {\".\"}..conflicts with this attribute\n \n-passes_doc_inline_conflict =\n-    conflicting doc inlining attributes\n-    .help = remove one of the conflicting attributes\n-\n passes_doc_inline_only_use =\n     this attribute can only be applied to a `use` item\n     .label = only applicable on `use` items\n     .not_a_use_item_label = not a `use` item\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n-passes_doc_attr_not_crate_level =\n-    `#![doc({$attr_name} = \"...\")]` isn't allowed as a crate-level attribute\n+passes_doc_invalid =\n+    invalid `doc` attribute\n \n-passes_attr_crate_level =\n-    this attribute can only be applied at the crate level\n-    .suggestion = to apply to the crate, use an inner attribute\n-    .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n+passes_doc_keyword_empty_mod =\n+    `#[doc(keyword = \"...\")]` should be used on empty modules\n \n-passes_doc_test_unknown =\n-    unknown `doc(test)` attribute `{$path}`\n+passes_doc_keyword_invalid_ident =\n+    `{$doc_keyword}` is not a valid identifier\n+\n+passes_doc_keyword_not_mod =\n+    `#[doc(keyword = \"...\")]` should be used on modules\n+\n+passes_doc_keyword_only_impl =\n+    `#[doc(keyword = \"...\")]` should be used on impl blocks\n \n passes_doc_test_takes_list =\n     `#[doc(test(...)]` takes a list of attributes\n \n-passes_doc_cfg_hide_takes_list =\n-    `#[doc(cfg_hide(...)]` takes a list of attributes\n+passes_doc_test_unknown =\n+    unknown `doc(test)` attribute `{$path}`\n \n passes_doc_test_unknown_any =\n     unknown `doc` attribute `{$path}`\n \n+passes_doc_test_unknown_include =\n+    unknown `doc` attribute `{$path}`\n+    .suggestion = use `doc = include_str!` instead\n+\n passes_doc_test_unknown_spotlight =\n     unknown `doc` attribute `{$path}`\n     .note = `doc(spotlight)` was renamed to `doc(notable_trait)`\n     .suggestion = use `notable_trait` instead\n     .no_op_note = `doc(spotlight)` is now a no-op\n \n-passes_doc_test_unknown_include =\n-    unknown `doc` attribute `{$path}`\n-    .suggestion = use `doc = include_str!` instead\n-\n-passes_doc_invalid =\n-    invalid `doc` attribute\n+passes_duplicate_diagnostic_item_in_crate =\n+    duplicate diagnostic item in crate `{$crate_name}`: `{$name}`.\n+    .note = the diagnostic item is first defined in crate `{$orig_crate_name}`.\n \n-passes_pass_by_value =\n-    `pass_by_value` attribute should be applied to a struct, enum or type alias\n-    .label = is not a struct, enum or type alias\n+passes_duplicate_feature_err =\n+    the feature `{$feature}` has already been declared\n \n-passes_allow_incoherent_impl =\n-    `rustc_allow_incoherent_impl` attribute should be applied to impl items.\n-    .label = the only currently supported targets are inherent methods\n+passes_duplicate_lang_item =\n+    found duplicate lang item `{$lang_item_name}`\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n \n-passes_has_incoherent_inherent_impl =\n-    `rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\n-    .label = only adts, extern types and traits are supported\n+passes_duplicate_lang_item_crate =\n+    duplicate lang item in crate `{$crate_name}`: `{$lang_item_name}`.\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n \n-passes_both_ffi_const_and_pure =\n-    `#[ffi_const]` function cannot be `#[ffi_pure]`\n+passes_duplicate_lang_item_crate_depends =\n+    duplicate lang item in crate `{$crate_name}` (which `{$dependency_of}` depends on): `{$lang_item_name}`.\n+    .first_defined_span = the lang item is first defined here\n+    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n+    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n+    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n+    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n+    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n+    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n \n-passes_ffi_pure_invalid_target =\n-    `#[ffi_pure]` may only be used on foreign functions\n+passes_export_name =\n+    attribute should be applied to a free function, impl method or static\n+    .label = not a free function, impl method or static\n+\n+passes_expr_not_allowed_in_context =\n+    {$expr} is not allowed in a `{$context}`\n+\n+passes_extern_main =\n+    the `main` function cannot be declared in an `extern` block\n+\n+passes_feature_only_on_nightly =\n+    `#![feature]` may not be used on the {$release_channel} release channel\n+\n+passes_feature_previously_declared =\n+    feature `{$feature}` is declared {$declared}, but was previously declared {$prev_declared}\n+\n+passes_feature_stable_twice =\n+    feature `{$feature}` is declared stable since {$since}, but was previously declared stable since {$prev_since}\n \n passes_ffi_const_invalid_target =\n     `#[ffi_const]` may only be used on foreign functions\n \n+passes_ffi_pure_invalid_target =\n+    `#[ffi_pure]` may only be used on foreign functions\n+\n passes_ffi_returns_twice_invalid_target =\n     `#[ffi_returns_twice]` may only be used on foreign functions\n \n-passes_must_use_async =\n-    `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n-    .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`\n-\n-passes_must_use_no_effect =\n-    `#[must_use]` has no effect when applied to {$article} {$target}\n-\n-passes_must_not_suspend =\n-    `must_not_suspend` attribute should be applied to a struct, enum, or trait\n-    .label = is not a struct, enum, or trait\n+passes_has_incoherent_inherent_impl =\n+    `rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\n+    .label = only adts, extern types and traits are supported\n \n-passes_cold =\n-    {passes_should_be_applied_to_fn}\n-    .warn = {-passes_previously_accepted}\n-    .label = {passes_should_be_applied_to_fn.label}\n+passes_homogeneous_aggregate =\n+    homogeneous_aggregate: {$homogeneous_aggregate}\n \n-passes_link =\n-    attribute should be applied to an `extern` block with non-Rust ABI\n+passes_ignored_attr =\n+    `#[{$sym}]` is ignored on struct fields and match arms\n     .warn = {-passes_previously_accepted}\n-    .label = not an `extern` block\n+    .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes_link_name =\n-    attribute should be applied to a foreign function or static\n+passes_ignored_attr_with_macro =\n+    `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n     .warn = {-passes_previously_accepted}\n-    .label = not a foreign function or static\n-    .help = try `#[link(name = \"{$value}\")]` instead\n-\n-passes_no_link =\n-    attribute should be applied to an `extern crate` item\n-    .label = not an `extern crate` item\n-\n-passes_export_name =\n-    attribute should be applied to a free function, impl method or static\n-    .label = not a free function, impl method or static\n-\n-passes_rustc_layout_scalar_valid_range_not_struct =\n-    attribute should be applied to a struct\n-    .label = not a struct\n+    .note = {-passes_see_issue(issue: \"80564\")}\n \n-passes_rustc_layout_scalar_valid_range_arg =\n-    expected exactly one integer literal argument\n+passes_ignored_derived_impls =\n+    `{$name}` has {$trait_list_len ->\n+      [one] a derived impl\n+     *[other] derived impls\n+    } for the {$trait_list_len ->\n+      [one] trait {$trait_list}, but this is\n+     *[other] traits {$trait_list}, but these are\n+    } intentionally ignored during dead code analysis\n \n-passes_rustc_legacy_const_generics_only =\n-    #[rustc_legacy_const_generics] functions must only have const generics\n-    .label = non-const generic parameter\n+passes_implied_feature_not_exist =\n+    feature `{$implied_by}` implying `{$feature}` does not exist\n \n-passes_rustc_legacy_const_generics_index =\n-    #[rustc_legacy_const_generics] must have one index for each generic parameter\n-    .label = generic parameters\n+passes_incorrect_do_not_recommend_location =\n+    `#[do_not_recommend]` can only be placed on trait implementations\n \n-passes_rustc_legacy_const_generics_index_exceed =\n-    index exceeds number of arguments\n-    .label = there {$arg_count ->\n-        [one] is\n-        *[other] are\n-    } only {$arg_count} {$arg_count ->\n+passes_incorrect_target =\n+    `{$name}` language item must be applied to a {$kind} with {$at_least ->\n+        [true] at least {$num}\n+        *[false] {$num}\n+    } generic {$num ->\n+        [one] argument\n+        *[other] arguments\n+    }\n+    .label = this {$kind} has {$actual_num} generic {$actual_num ->\n         [one] argument\n         *[other] arguments\n     }\n \n-passes_rustc_legacy_const_generics_index_negative =\n-    arguments should be non-negative integers\n-\n-passes_rustc_dirty_clean =\n-    attribute requires -Z query-dep-graph to be enabled\n-\n-passes_link_section =\n-    attribute should be applied to a function or static\n-    .warn = {-passes_previously_accepted}\n-    .label = not a function or static\n-\n-passes_no_mangle_foreign =\n-    `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n-    .warn = {-passes_previously_accepted}\n-    .label = foreign {$foreign_item_kind}\n-    .note = symbol names in extern blocks are not mangled\n-    .suggestion = remove this attribute\n+passes_ineffective_unstable_impl = an `#[unstable]` annotation here has no effect\n+    .note = see issue #55436 <https://github.com/rust-lang/rust/issues/55436> for more information\n \n-passes_no_mangle =\n-    attribute should be applied to a free function, impl method or static\n+passes_inline_ignored_constants =\n+    `#[inline]` is ignored on constants\n     .warn = {-passes_previously_accepted}\n-    .label = not a free function, impl method or static\n-\n-passes_repr_ident =\n-    meta item in `repr` must be an identifier\n-\n-passes_repr_conflicting =\n-    conflicting representation hints\n-\n-passes_used_static =\n-    attribute must be applied to a `static` variable\n-\n-passes_used_compiler_linker =\n-    `used(compiler)` and `used(linker)` can't be used together\n-\n-passes_allow_internal_unstable =\n-    attribute should be applied to a macro\n-    .label = not a macro\n-\n-passes_debug_visualizer_placement =\n-    attribute should be applied to a module\n-\n-passes_debug_visualizer_invalid =\n-    invalid argument\n-    .note_1 = expected: `natvis_file = \"...\"`\n-    .note_2 = OR\n-    .note_3 = expected: `gdb_script_file = \"...\"`\n-\n-passes_debug_visualizer_unreadable =\n-    couldn't read {$file}: {$error}\n-\n-passes_rustc_allow_const_fn_unstable =\n-    attribute should be applied to `const fn`\n-    .label = not a `const fn`\n-\n-passes_rustc_std_internal_symbol =\n-    attribute should be applied to functions or statics\n-    .label = not a function or static\n-\n-passes_const_trait =\n-    attribute should be applied to a trait\n-\n-passes_stability_promotable =\n-    attribute cannot be applied to an expression\n-\n-passes_deprecated =\n-    attribute is ignored here\n-\n-passes_macro_use =\n-    `#[{$name}]` only has an effect on `extern crate` and modules\n-\n-passes_macro_export =\n-    `#[macro_export]` only has an effect on macro definitions\n-\n-passes_plugin_registrar =\n-    `#[plugin_registrar]` only has an effect on functions\n-\n-passes_unused_empty_lints_note =\n-    attribute `{$name}` with an empty list has no effect\n-\n-passes_unused_no_lints_note =\n-    attribute `{$name}` without any lints has no effect\n-\n-passes_unused_default_method_body_const_note =\n-    `default_method_body_is_const` has been replaced with `#[const_trait]` on traits\n+    .note = {-passes_see_issue(issue: \"65833\")}\n \n-passes_unused =\n-    unused attribute\n-    .suggestion = remove this attribute\n+passes_inline_ignored_function_prototype =\n+    `#[inline]` is ignored on function prototypes\n \n-passes_non_exported_macro_invalid_attrs =\n+passes_inline_not_fn_or_closure =\n     attribute should be applied to function or closure\n     .label = not a function or closure\n \n-passes_unused_duplicate =\n-    unused attribute\n-    .suggestion = remove this attribute\n-    .note = attribute also specified here\n-    .warn = {-passes_previously_accepted}\n-\n-passes_unused_multiple =\n-    multiple `{$name}` attributes\n-    .suggestion = remove this attribute\n-    .note = attribute also specified here\n-\n-passes_rustc_lint_opt_ty =\n-    `#[rustc_lint_opt_ty]` should be applied to a struct\n-    .label = not a struct\n-\n-passes_rustc_lint_opt_deny_field_access =\n-    `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n-    .label = not a field\n-\n-passes_link_ordinal =\n-    attribute should be applied to a foreign function or static\n-    .label = not a foreign function or static\n-\n-passes_collapse_debuginfo =\n-    `collapse_debuginfo` attribute should be applied to macro definitions\n-    .label = not a macro definition\n-\n-passes_deprecated_annotation_has_no_effect =\n-    this `#[deprecated]` annotation has no effect\n-    .suggestion = remove the unnecessary deprecation attribute\n-\n-passes_unknown_external_lang_item =\n-    unknown external lang item: `{$lang_item}`\n-\n-passes_missing_panic_handler =\n-    `#[panic_handler]` function required, but not found\n-\n-passes_missing_lang_item =\n-    language item required, but not found: `{$name}`\n-    .note = this can occur when a binary crate with `#![no_std]` is compiled for a target where `{$name}` is defined in the standard library\n-    .help = you may be able to compile for a target that doesn't need `{$name}`, specify a target with `--target` or in `.cargo/config`\n-\n-passes_lang_item_on_incorrect_target =\n-    `{$name}` language item must be applied to a {$expected_target}\n-    .label = attribute should be applied to a {$expected_target}, not a {$actual_target}\n-\n-passes_unknown_lang_item =\n-    definition of an unknown language item: `{$name}`\n-    .label = definition of unknown language item `{$name}`\n+passes_inner_crate_level_attr =\n+    crate-level attribute should be in the root module\n \n passes_invalid_attr_at_crate_level =\n     `{$name}` attribute cannot be used at crate level\n     .suggestion = perhaps you meant to use an outer attribute\n \n-passes_duplicate_diagnostic_item_in_crate =\n-    duplicate diagnostic item in crate `{$crate_name}`: `{$name}`.\n-    .note = the diagnostic item is first defined in crate `{$orig_crate_name}`.\n+passes_invalid_deprecation_version =\n+    invalid deprecation version found\n+    .label = invalid deprecation version\n+    .item = the stability attribute annotates this item\n \n-passes_diagnostic_item_first_defined =\n-    the diagnostic item is first defined here\n+passes_invalid_macro_export_arguments = `{$name}` isn't a valid `#[macro_export]` argument\n \n-passes_abi =\n-    abi: {$abi}\n+passes_invalid_macro_export_arguments_too_many_items = `#[macro_export]` can only take 1 or 0 arguments\n \n-passes_align =\n-    align: {$align}\n+passes_invalid_stability =\n+    invalid stability version found\n+    .label = invalid stability version\n+    .item = the stability attribute annotates this item\n \n-passes_size =\n-    size: {$size}\n+passes_lang_item_on_incorrect_target =\n+    `{$name}` language item must be applied to a {$expected_target}\n+    .label = attribute should be applied to a {$expected_target}, not a {$actual_target}\n \n-passes_homogeneous_aggregate =\n-    homogeneous_aggregate: {$homogeneous_aggregate}\n+passes_layout =\n+    layout error: {$layout_error}\n \n passes_layout_of =\n     layout_of({$normalized_ty}) = {$ty_layout}\n \n-passes_unrecognized_field =\n-    unrecognized field name `{$name}`\n-\n-passes_layout =\n-    layout error: {$layout_error}\n+passes_link =\n+    attribute should be applied to an `extern` block with non-Rust ABI\n+    .warn = {-passes_previously_accepted}\n+    .label = not an `extern` block\n \n-passes_feature_stable_twice =\n-    feature `{$feature}` is declared stable since {$since}, but was previously declared stable since {$prev_since}\n+passes_link_name =\n+    attribute should be applied to a foreign function or static\n+    .warn = {-passes_previously_accepted}\n+    .label = not a foreign function or static\n+    .help = try `#[link(name = \"{$value}\")]` instead\n \n-passes_feature_previously_declared =\n-    feature `{$feature}` is declared {$declared}, but was previously declared {$prev_declared}\n+passes_link_ordinal =\n+    attribute should be applied to a foreign function or static\n+    .label = not a foreign function or static\n \n-passes_expr_not_allowed_in_context =\n-    {$expr} is not allowed in a `{$context}`\n+passes_link_section =\n+    attribute should be applied to a function or static\n+    .warn = {-passes_previously_accepted}\n+    .label = not a function or static\n \n-passes_const_impl_const_trait =\n-    const `impl`s must be for traits marked with `#[const_trait]`\n-    .note = this trait must be annotated with `#[const_trait]`\n+passes_macro_export =\n+    `#[macro_export]` only has an effect on macro definitions\n \n-passes_break_non_loop =\n-    `break` with value from a `{$kind}` loop\n-    .label = can only break with a value inside `loop` or breakable block\n-    .label2 = you can't `break` with a value in a `{$kind}` loop\n-    .suggestion = use `break` on its own without a value inside this `{$kind}` loop\n-    .break_expr_suggestion = alternatively, you might have meant to use the available loop label\n+passes_macro_use =\n+    `#[{$name}]` only has an effect on `extern crate` and modules\n \n-passes_continue_labeled_block =\n-    `continue` pointing to a labeled block\n-    .label = labeled blocks cannot be `continue`'d\n-    .block_label = labeled block the `continue` points to\n+passes_maybe_string_interpolation = you might have meant to use string interpolation in this string literal\n+passes_missing_const_err =\n+    attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n+    .help = make the function or method const\n+    .label = attribute specified here\n \n-passes_break_inside_closure =\n-    `{$name}` inside of a closure\n-    .label = cannot `{$name}` inside of a closure\n-    .closure_label = enclosing closure\n+passes_missing_const_stab_attr =\n+    {$descr} has missing const stability attribute\n \n-passes_break_inside_async_block =\n-    `{$name}` inside of an `async` block\n-    .label = cannot `{$name}` inside of an `async` block\n-    .async_block_label = enclosing `async` block\n+passes_missing_lang_item =\n+    language item required, but not found: `{$name}`\n+    .note = this can occur when a binary crate with `#![no_std]` is compiled for a target where `{$name}` is defined in the standard library\n+    .help = you may be able to compile for a target that doesn't need `{$name}`, specify a target with `--target` or in `.cargo/config`\n \n-passes_outside_loop =\n-    `{$name}` outside of a loop{$is_break ->\n-        [true] {\" or labeled block\"}\n-        *[false] {\"\"}\n-    }\n-    .label = cannot `{$name}` outside of a loop{$is_break ->\n-        [true] {\" or labeled block\"}\n-        *[false] {\"\"}\n-    }\n+passes_missing_panic_handler =\n+    `#[panic_handler]` function required, but not found\n \n-passes_unlabeled_in_labeled_block =\n-    unlabeled `{$cf_type}` inside of a labeled block\n-    .label = `{$cf_type}` statements that would diverge to or through a labeled block need to bear a label\n+passes_missing_stability_attr =\n+    {$descr} has missing stability attribute\n \n-passes_unlabeled_cf_in_while_condition =\n-    `break` or `continue` with no label in the condition of a `while` loop\n-    .label = unlabeled `{$cf_type}` in the condition of a `while` loop\n+passes_multiple_rustc_main =\n+    multiple functions with a `#[rustc_main]` attribute\n+    .first = first `#[rustc_main]` function\n+    .additional = additional `#[rustc_main]` function\n \n-passes_cannot_inline_naked_function =\n-    naked functions cannot be inlined\n+passes_multiple_start_functions =\n+    multiple `start` functions\n+    .label = multiple `start` functions\n+    .previous = previous `#[start]` function here\n \n-passes_undefined_naked_function_abi =\n-    Rust ABI is unsupported in naked functions\n+passes_must_not_suspend =\n+    `must_not_suspend` attribute should be applied to a struct, enum, or trait\n+    .label = is not a struct, enum, or trait\n \n-passes_no_patterns =\n-    patterns not allowed in naked function parameters\n+passes_must_use_async =\n+    `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n+    .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`\n \n-passes_params_not_allowed =\n-    referencing function parameters is not allowed in naked functions\n-    .help = follow the calling convention in asm block to use parameters\n+passes_must_use_no_effect =\n+    `#[must_use]` has no effect when applied to {$article} {$target}\n \n passes_naked_functions_asm_block =\n     naked functions must contain a single asm block\n     .label_multiple_asm = multiple asm blocks are unsupported in naked functions\n     .label_non_asm = non-asm is unsupported in naked functions\n \n-passes_naked_functions_operands =\n-    only `const` and `sym` operands are supported in naked functions\n-\n passes_naked_functions_asm_options =\n     asm options unsupported in naked functions: {$unsupported_options}\n \n passes_naked_functions_must_use_noreturn =\n     asm in naked functions must use `noreturn` option\n     .suggestion = consider specifying that the asm block is responsible for returning from the function\n \n-passes_attr_only_on_main =\n-    `{$attr}` attribute can only be used on `fn main()`\n+passes_naked_functions_operands =\n+    only `const` and `sym` operands are supported in naked functions\n \n-passes_attr_only_on_root_main =\n-    `{$attr}` attribute can only be used on root `fn main()`\n+passes_naked_tracked_caller =\n+    cannot use `#[track_caller]` with `#[naked]`\n \n-passes_attr_only_in_functions =\n-    `{$attr}` attribute can only be used on functions\n+passes_no_coverage_fn_defn =\n+    `#[no_coverage]` may only be applied to function definitions\n \n-passes_multiple_rustc_main =\n-    multiple functions with a `#[rustc_main]` attribute\n-    .first = first `#[rustc_main]` function\n-    .additional = additional `#[rustc_main]` function\n+passes_no_coverage_ignored_function_prototype =\n+    `#[no_coverage]` is ignored on function prototypes\n \n-passes_multiple_start_functions =\n-    multiple `start` functions\n-    .label = multiple `start` functions\n-    .previous = previous `#[start]` function here\n+passes_no_coverage_not_coverable =\n+    `#[no_coverage]` must be applied to coverable code\n+    .label = not coverable code\n \n-passes_extern_main =\n-    the `main` function cannot be declared in an `extern` block\n+passes_no_coverage_propagate =\n+    `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n \n-passes_unix_sigpipe_values =\n-    valid values for `#[unix_sigpipe = \"...\"]` are `inherit`, `sig_ign`, or `sig_dfl`\n+passes_no_link =\n+    attribute should be applied to an `extern crate` item\n+    .label = not an `extern crate` item\n \n passes_no_main_function =\n     `main` function not found in crate `{$crate_name}`\n@@ -546,222 +502,266 @@ passes_no_main_function =\n     .teach_note = If you don't know the basics of Rust, you can go look to the Rust Book to get started: https://doc.rust-lang.org/book/\n     .non_function_main = non-function item at `crate::main` is found\n \n-passes_duplicate_lang_item =\n-    found duplicate lang item `{$lang_item_name}`\n-    .first_defined_span = the lang item is first defined here\n-    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n-    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n-    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n-    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n-    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n-    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+passes_no_mangle =\n+    attribute should be applied to a free function, impl method or static\n+    .warn = {-passes_previously_accepted}\n+    .label = not a free function, impl method or static\n \n-passes_duplicate_lang_item_crate =\n-    duplicate lang item in crate `{$crate_name}`: `{$lang_item_name}`.\n-    .first_defined_span = the lang item is first defined here\n-    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n-    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n-    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n-    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n-    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n-    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+passes_no_mangle_foreign =\n+    `#[no_mangle]` has no effect on a foreign {$foreign_item_kind}\n+    .warn = {-passes_previously_accepted}\n+    .label = foreign {$foreign_item_kind}\n+    .note = symbol names in extern blocks are not mangled\n+    .suggestion = remove this attribute\n \n-passes_duplicate_lang_item_crate_depends =\n-    duplicate lang item in crate `{$crate_name}` (which `{$dependency_of}` depends on): `{$lang_item_name}`.\n-    .first_defined_span = the lang item is first defined here\n-    .first_defined_crate_depends = the lang item is first defined in crate `{$orig_crate_name}` (which `{$orig_dependency_of}` depends on)\n-    .first_defined_crate = the lang item is first defined in crate `{$orig_crate_name}`.\n-    .first_definition_local = first definition in the local crate (`{$orig_crate_name}`)\n-    .second_definition_local = second definition in the local crate (`{$crate_name}`)\n-    .first_definition_path = first definition in `{$orig_crate_name}` loaded from {$orig_path}\n-    .second_definition_path = second definition in `{$crate_name}` loaded from {$path}\n+passes_no_patterns =\n+    patterns not allowed in naked function parameters\n \n-passes_incorrect_target =\n-    `{$name}` language item must be applied to a {$kind} with {$at_least ->\n-        [true] at least {$num}\n-        *[false] {$num}\n-    } generic {$num ->\n-        [one] argument\n-        *[other] arguments\n+passes_non_exported_macro_invalid_attrs =\n+    attribute should be applied to function or closure\n+    .label = not a function or closure\n+\n+passes_object_lifetime_err =\n+    {$repr}\n+\n+passes_only_has_effect_on =\n+    `#[{$attr_name}]` only has an effect on {$target_name ->\n+        [function] functions\n+        [module] modules\n+        [implementation_block] implementation blocks\n+        *[unspecified] (unspecified--this is a compiler bug)\n     }\n-    .label = this {$kind} has {$actual_num} generic {$actual_num ->\n-        [one] argument\n-        *[other] arguments\n+\n+passes_outer_crate_level_attr =\n+    crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n+\n+passes_outside_loop =\n+    `{$name}` outside of a loop{$is_break ->\n+        [true] {\" or labeled block\"}\n+        *[false] {\"\"}\n+    }\n+    .label = cannot `{$name}` outside of a loop{$is_break ->\n+        [true] {\" or labeled block\"}\n+        *[false] {\"\"}\n     }\n \n-passes_useless_assignment =\n-    useless assignment of {$is_field_assign ->\n-        [true] field\n-        *[false] variable\n-    } of type `{$ty}` to itself\n+passes_params_not_allowed =\n+    referencing function parameters is not allowed in naked functions\n+    .help = follow the calling convention in asm block to use parameters\n+\n+passes_parent_info =\n+    {$num ->\n+      [one] {$descr}\n+     *[other] {$descr}s\n+    } in this {$parent_descr}\n+\n+passes_pass_by_value =\n+    `pass_by_value` attribute should be applied to a struct, enum or type alias\n+    .label = is not a struct, enum or type alias\n+\n+passes_plugin_registrar =\n+    `#[plugin_registrar]` only has an effect on functions\n+\n+passes_proc_macro_bad_sig = {$kind} has incorrect signature\n+\n+passes_repr_conflicting =\n+    conflicting representation hints\n+\n+passes_repr_ident =\n+    meta item in `repr` must be an identifier\n+\n+passes_rustc_allow_const_fn_unstable =\n+    attribute should be applied to `const fn`\n+    .label = not a `const fn`\n+\n+passes_rustc_dirty_clean =\n+    attribute requires -Z query-dep-graph to be enabled\n+\n+passes_rustc_layout_scalar_valid_range_arg =\n+    expected exactly one integer literal argument\n+\n+passes_rustc_layout_scalar_valid_range_not_struct =\n+    attribute should be applied to a struct\n+    .label = not a struct\n \n-passes_only_has_effect_on =\n-    `#[{$attr_name}]` only has an effect on {$target_name ->\n-        [function] functions\n-        [module] modules\n-        [implementation_block] implementation blocks\n-        *[unspecified] (unspecified--this is a compiler bug)\n+passes_rustc_legacy_const_generics_index =\n+    #[rustc_legacy_const_generics] must have one index for each generic parameter\n+    .label = generic parameters\n+\n+passes_rustc_legacy_const_generics_index_exceed =\n+    index exceeds number of arguments\n+    .label = there {$arg_count ->\n+        [one] is\n+        *[other] are\n+    } only {$arg_count} {$arg_count ->\n+        [one] argument\n+        *[other] arguments\n     }\n \n-passes_object_lifetime_err =\n-    {$repr}\n+passes_rustc_legacy_const_generics_index_negative =\n+    arguments should be non-negative integers\n \n-passes_unrecognized_repr_hint =\n-    unrecognized representation hint\n-    .help = valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\n+passes_rustc_legacy_const_generics_only =\n+    #[rustc_legacy_const_generics] functions must only have const generics\n+    .label = non-const generic parameter\n \n-passes_attr_application_enum =\n-    attribute should be applied to an enum\n-    .label = not an enum\n+passes_rustc_lint_opt_deny_field_access =\n+    `#[rustc_lint_opt_deny_field_access]` should be applied to a field\n+    .label = not a field\n \n-passes_attr_application_struct =\n-    attribute should be applied to a struct\n+passes_rustc_lint_opt_ty =\n+    `#[rustc_lint_opt_ty]` should be applied to a struct\n     .label = not a struct\n \n-passes_attr_application_struct_union =\n-    attribute should be applied to a struct or union\n-    .label = not a struct or union\n-\n-passes_attr_application_struct_enum_union =\n-    attribute should be applied to a struct, enum, or union\n-    .label = not a struct, enum, or union\n+passes_rustc_std_internal_symbol =\n+    attribute should be applied to functions or statics\n+    .label = not a function or static\n \n-passes_attr_application_struct_enum_function_method_union =\n-    attribute should be applied to a struct, enum, function, associated function, or union\n-    .label = not a struct, enum, function, associated function, or union\n+passes_should_be_applied_to_fn =\n+    attribute should be applied to a function definition\n+    .label = {$on_crate ->\n+        [true] cannot be applied to crates\n+        *[false] not a function definition\n+    }\n \n-passes_transparent_incompatible =\n-    transparent {$target} cannot have other repr hints\n+passes_should_be_applied_to_static =\n+    attribute should be applied to a static\n+    .label = not a static\n \n-passes_deprecated_attribute =\n-    deprecated attribute must be paired with either stable or unstable attribute\n+passes_should_be_applied_to_struct_enum =\n+    attribute should be applied to a struct or enum\n+    .label = not a struct or enum\n \n-passes_useless_stability =\n-    this stability annotation is useless\n-    .label = useless stability annotation\n-    .item = the stability attribute annotates this item\n+passes_should_be_applied_to_trait =\n+    attribute should be applied to a trait\n+    .label = not a trait\n \n-passes_invalid_stability =\n-    invalid stability version found\n-    .label = invalid stability version\n-    .item = the stability attribute annotates this item\n+passes_size =\n+    size: {$size}\n \n-passes_cannot_stabilize_deprecated =\n-    an API can't be stabilized after it is deprecated\n-    .label = invalid version\n-    .item = the stability attribute annotates this item\n+passes_skipping_const_checks = skipping const checks\n \n-passes_invalid_deprecation_version =\n-    invalid deprecation version found\n-    .label = invalid deprecation version\n-    .item = the stability attribute annotates this item\n+passes_stability_promotable =\n+    attribute cannot be applied to an expression\n \n-passes_missing_stability_attr =\n-    {$descr} has missing stability attribute\n+passes_string_interpolation_only_works = string interpolation only works in `format!` invocations\n \n-passes_missing_const_stab_attr =\n-    {$descr} has missing const stability attribute\n+passes_target_feature_on_statement =\n+    {passes_should_be_applied_to_fn}\n+    .warn = {-passes_previously_accepted}\n+    .label = {passes_should_be_applied_to_fn.label}\n \n passes_trait_impl_const_stable =\n     trait implementations cannot be const stable yet\n     .note = see issue #67792 <https://github.com/rust-lang/rust/issues/67792> for more information\n \n-passes_feature_only_on_nightly =\n-    `#![feature]` may not be used on the {$release_channel} release channel\n-\n-passes_unknown_feature =\n-    unknown feature `{$feature}`\n-\n-passes_implied_feature_not_exist =\n-    feature `{$implied_by}` implying `{$feature}` does not exist\n-\n-passes_duplicate_feature_err =\n-    the feature `{$feature}` has already been declared\n+passes_transparent_incompatible =\n+    transparent {$target} cannot have other repr hints\n \n-passes_missing_const_err =\n-    attributes `#[rustc_const_unstable]` and `#[rustc_const_stable]` require the function or method to be `const`\n-    .help = make the function or method const\n-    .label = attribute specified here\n+passes_undefined_naked_function_abi =\n+    Rust ABI is unsupported in naked functions\n \n-passes_dead_codes =\n-    { $multiple ->\n-      *[true] multiple {$descr}s are\n-       [false] { $num ->\n-         [one] {$descr} {$name_list} is\n-        *[other] {$descr}s {$name_list} are\n-       }\n-    } never {$participle}\n+passes_unix_sigpipe_values =\n+    valid values for `#[unix_sigpipe = \"...\"]` are `inherit`, `sig_ign`, or `sig_dfl`\n \n-passes_change_fields_to_be_of_unit_type =\n-    consider changing the { $num ->\n-      [one] field\n-     *[other] fields\n-    } to be of unit type to suppress this warning while preserving the field numbering, or remove the { $num ->\n-      [one] field\n-     *[other] fields\n-    }\n+passes_unknown_external_lang_item =\n+    unknown external lang item: `{$lang_item}`\n \n-passes_parent_info =\n-    {$num ->\n-      [one] {$descr}\n-     *[other] {$descr}s\n-    } in this {$parent_descr}\n+passes_unknown_feature =\n+    unknown feature `{$feature}`\n \n-passes_ignored_derived_impls =\n-    `{$name}` has {$trait_list_len ->\n-      [one] a derived impl\n-     *[other] derived impls\n-    } for the {$trait_list_len ->\n-      [one] trait {$trait_list}, but this is\n-     *[other] traits {$trait_list}, but these are\n-    } intentionally ignored during dead code analysis\n+passes_unknown_lang_item =\n+    definition of an unknown language item: `{$name}`\n+    .label = definition of unknown language item `{$name}`\n \n-passes_proc_macro_bad_sig = {$kind} has incorrect signature\n+passes_unlabeled_cf_in_while_condition =\n+    `break` or `continue` with no label in the condition of a `while` loop\n+    .label = unlabeled `{$cf_type}` in the condition of a `while` loop\n \n-passes_skipping_const_checks = skipping const checks\n+passes_unlabeled_in_labeled_block =\n+    unlabeled `{$cf_type}` inside of a labeled block\n+    .label = `{$cf_type}` statements that would diverge to or through a labeled block need to bear a label\n \n-passes_invalid_macro_export_arguments = `{$name}` isn't a valid `#[macro_export]` argument\n+passes_unnecessary_partial_stable_feature = the feature `{$feature}` has been partially stabilized since {$since} and is succeeded by the feature `{$implies}`\n+    .suggestion = if you are using features which are still unstable, change to using `{$implies}`\n+    .suggestion_remove = if you are using features which are now stable, remove this line\n \n-passes_invalid_macro_export_arguments_too_many_items = `#[macro_export]` can only take 1 or 0 arguments\n+passes_unnecessary_stable_feature = the feature `{$feature}` has been stable since {$since} and no longer requires an attribute to enable\n \n passes_unreachable_due_to_uninhabited = unreachable {$descr}\n     .label = unreachable {$descr}\n     .label_orig = any code following this expression is unreachable\n     .note = this expression has type `{$ty}`, which is uninhabited\n \n-passes_unused_var_maybe_capture_ref = unused variable: `{$name}`\n-    .help = did you mean to capture by reference instead?\n+passes_unrecognized_field =\n+    unrecognized field name `{$name}`\n+\n+passes_unrecognized_repr_hint =\n+    unrecognized representation hint\n+    .help = valid reprs are `C`, `align`, `packed`, `transparent`, `simd`, `i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`\n+\n+passes_unused =\n+    unused attribute\n+    .suggestion = remove this attribute\n+\n+passes_unused_assign = value assigned to `{$name}` is never read\n+    .help = maybe it is overwritten before being read?\n+\n+passes_unused_assign_passed = value passed to `{$name}` is never read\n+    .help = maybe it is overwritten before being read?\n \n passes_unused_capture_maybe_capture_ref = value captured by `{$name}` is never read\n     .help = did you mean to capture by reference instead?\n \n-passes_unused_var_remove_field = unused variable: `{$name}`\n-passes_unused_var_remove_field_suggestion = try removing the field\n+passes_unused_default_method_body_const_note =\n+    `default_method_body_is_const` has been replaced with `#[const_trait]` on traits\n \n-passes_unused_var_assigned_only = variable `{$name}` is assigned to, but never used\n-    .note = consider using `_{$name}` instead\n+passes_unused_duplicate =\n+    unused attribute\n+    .suggestion = remove this attribute\n+    .note = attribute also specified here\n+    .warn = {-passes_previously_accepted}\n \n-passes_unnecessary_stable_feature = the feature `{$feature}` has been stable since {$since} and no longer requires an attribute to enable\n+passes_unused_empty_lints_note =\n+    attribute `{$name}` with an empty list has no effect\n \n-passes_unnecessary_partial_stable_feature = the feature `{$feature}` has been partially stabilized since {$since} and is succeeded by the feature `{$implies}`\n-    .suggestion = if you are using features which are still unstable, change to using `{$implies}`\n-    .suggestion_remove = if you are using features which are now stable, remove this line\n+passes_unused_multiple =\n+    multiple `{$name}` attributes\n+    .suggestion = remove this attribute\n+    .note = attribute also specified here\n \n-passes_ineffective_unstable_impl = an `#[unstable]` annotation here has no effect\n-    .note = see issue #55436 <https://github.com/rust-lang/rust/issues/55436> for more information\n+passes_unused_no_lints_note =\n+    attribute `{$name}` without any lints has no effect\n \n-passes_unused_assign = value assigned to `{$name}` is never read\n-    .help = maybe it is overwritten before being read?\n+passes_unused_var_assigned_only = variable `{$name}` is assigned to, but never used\n+    .note = consider using `_{$name}` instead\n \n-passes_unused_assign_passed = value passed to `{$name}` is never read\n-    .help = maybe it is overwritten before being read?\n+passes_unused_var_maybe_capture_ref = unused variable: `{$name}`\n+    .help = did you mean to capture by reference instead?\n \n-passes_maybe_string_interpolation = you might have meant to use string interpolation in this string literal\n-passes_string_interpolation_only_works = string interpolation only works in `format!` invocations\n+passes_unused_var_remove_field = unused variable: `{$name}`\n+passes_unused_var_remove_field_suggestion = try removing the field\n+\n+passes_unused_variable_try_ignore = unused variable: `{$name}`\n+    .suggestion = try ignoring the field\n \n passes_unused_variable_try_prefix = unused variable: `{$name}`\n     .label = unused variable\n     .suggestion = if this is intentional, prefix it with an underscore\n \n-passes_unused_variable_try_ignore = unused variable: `{$name}`\n-    .suggestion = try ignoring the field\n+passes_used_compiler_linker =\n+    `used(compiler)` and `used(linker)` can't be used together\n+\n+passes_used_static =\n+    attribute must be applied to a `static` variable\n+\n+passes_useless_assignment =\n+    useless assignment of {$is_field_assign ->\n+        [true] field\n+        *[false] variable\n+    } of type `{$ty}` to itself\n+\n+passes_useless_stability =\n+    this stability annotation is useless\n+    .label = useless stability annotation\n+    .item = the stability attribute annotates this item"}, {"sha": "c3189d1fefe40f4255b0158097cb111db85b6d36", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1816,7 +1816,7 @@ impl CheckAttrVisitor<'_> {\n             || (is_simd && is_c)\n             || (int_reprs == 1\n                 && is_c\n-                && item.map_or(false, |item| {\n+                && item.is_some_and(|item| {\n                     if let ItemLike::Item(item) = item {\n                         return is_c_like_enum(item);\n                     }\n@@ -2095,7 +2095,7 @@ impl CheckAttrVisitor<'_> {\n                 | sym::feature\n                 | sym::repr\n                 | sym::target_feature\n-        ) && attr.meta_item_list().map_or(false, |list| list.is_empty())\n+        ) && attr.meta_item_list().is_some_and(|list| list.is_empty())\n         {\n             errors::UnusedNote::EmptyList { name: attr.name_or_empty() }\n         } else if matches!("}, {"sha": "b81b7ad6013b5df0e354deed34001339304b9e92", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -554,10 +554,8 @@ impl<'tcx> MissingStabilityAnnotations<'tcx> {\n \n         let is_const = self.tcx.is_const_fn(def_id.to_def_id())\n             || self.tcx.is_const_trait_impl_raw(def_id.to_def_id());\n-        let is_stable = self\n-            .tcx\n-            .lookup_stability(def_id)\n-            .map_or(false, |stability| stability.level.is_stable());\n+        let is_stable =\n+            self.tcx.lookup_stability(def_id).is_some_and(|stability| stability.level.is_stable());\n         let missing_const_stability_attribute = self.tcx.lookup_const_stability(def_id).is_none();\n         let is_reachable = self.effective_visibilities.is_reachable(def_id);\n \n@@ -772,7 +770,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                     // needs to have an error emitted.\n                     if features.const_trait_impl\n                         && *constness == hir::Constness::Const\n-                        && const_stab.map_or(false, |(stab, _)| stab.is_const_stable())\n+                        && const_stab.is_some_and(|(stab, _)| stab.is_const_stable())\n                     {\n                         self.tcx.sess.emit_err(errors::TraitImplConstStable { span: item.span });\n                     }\n@@ -809,15 +807,12 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n             );\n \n             let is_allowed_through_unstable_modules = |def_id| {\n-                self.tcx\n-                    .lookup_stability(def_id)\n-                    .map(|stab| match stab.level {\n-                        StabilityLevel::Stable { allowed_through_unstable_modules, .. } => {\n-                            allowed_through_unstable_modules\n-                        }\n-                        _ => false,\n-                    })\n-                    .unwrap_or(false)\n+                self.tcx.lookup_stability(def_id).is_some_and(|stab| match stab.level {\n+                    StabilityLevel::Stable { allowed_through_unstable_modules, .. } => {\n+                        allowed_through_unstable_modules\n+                    }\n+                    _ => false,\n+                })\n             };\n \n             if item_is_allowed && !is_allowed_through_unstable_modules(def_id) {"}, {"sha": "b68e8a78aab86d68035cbc2619640041fe9d32ee", "filename": "compiler/rustc_privacy/messages.ftl", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_privacy%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_privacy%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -2,22 +2,22 @@ privacy_field_is_private = field `{$field_name}` of {$variant_descr} `{$def_path\n privacy_field_is_private_is_update_syntax_label = field `{$field_name}` is private\n privacy_field_is_private_label = private field\n \n-privacy_item_is_private = {$kind} `{$descr}` is private\n-    .label = private {$kind}\n-privacy_unnamed_item_is_private = {$kind} is private\n-    .label = private {$kind}\n+privacy_from_private_dep_in_public_interface =\n+    {$kind} `{$descr}` from private dependency '{$krate}' in public interface\n \n privacy_in_public_interface = {$vis_descr} {$kind} `{$descr}` in public interface\n     .label = can't leak {$vis_descr} {$kind}\n     .visibility_label = `{$descr}` declared as {$vis_descr}\n \n-privacy_report_effective_visibility = {$descr}\n-\n-privacy_from_private_dep_in_public_interface =\n-    {$kind} `{$descr}` from private dependency '{$krate}' in public interface\n-\n+privacy_item_is_private = {$kind} `{$descr}` is private\n+    .label = private {$kind}\n privacy_private_in_public_lint =\n     {$vis_descr} {$kind} `{$descr}` in public interface (error {$kind ->\n         [trait] E0445\n         *[other] E0446\n     })\n+\n+privacy_report_effective_visibility = {$descr}\n+\n+privacy_unnamed_item_is_private = {$kind} is private\n+    .label = private {$kind}"}, {"sha": "65dfdf31e5457c5ff4d5d1716bcdae9ae9ae9b07", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 100, "deletions": 163, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -454,12 +454,14 @@ struct EmbargoVisitor<'tcx> {\n     ///     n::p::f()\n     /// }\n     macro_reachable: FxHashSet<(LocalDefId, LocalDefId)>,\n+    /// Preliminary pass for marking all underlying types of `impl Trait`s as reachable.\n+    impl_trait_pass: bool,\n     /// Has something changed in the level map?\n     changed: bool,\n }\n \n struct ReachEverythingInTheInterfaceVisitor<'a, 'tcx> {\n-    effective_vis: Option<EffectiveVisibility>,\n+    effective_vis: EffectiveVisibility,\n     item_def_id: LocalDefId,\n     ev: &'a mut EmbargoVisitor<'tcx>,\n     level: Level,\n@@ -474,7 +476,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn update(\n         &mut self,\n         def_id: LocalDefId,\n-        inherited_effective_vis: Option<EffectiveVisibility>,\n+        inherited_effective_vis: EffectiveVisibility,\n         level: Level,\n     ) {\n         let nominal_vis = self.tcx.local_visibility(def_id);\n@@ -484,30 +486,27 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn update_eff_vis(\n         &mut self,\n         def_id: LocalDefId,\n-        inherited_effective_vis: Option<EffectiveVisibility>,\n+        inherited_effective_vis: EffectiveVisibility,\n         nominal_vis: Option<ty::Visibility>,\n         level: Level,\n     ) {\n-        if let Some(inherited_effective_vis) = inherited_effective_vis {\n-            let private_vis =\n-                ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id));\n-            if Some(private_vis) != nominal_vis {\n-                self.changed |= self.effective_visibilities.update(\n-                    def_id,\n-                    nominal_vis,\n-                    || private_vis,\n-                    inherited_effective_vis,\n-                    level,\n-                    self.tcx,\n-                );\n-            }\n+        let private_vis = ty::Visibility::Restricted(self.tcx.parent_module_from_def_id(def_id));\n+        if Some(private_vis) != nominal_vis {\n+            self.changed |= self.effective_visibilities.update(\n+                def_id,\n+                nominal_vis,\n+                || private_vis,\n+                inherited_effective_vis,\n+                level,\n+                self.tcx,\n+            );\n         }\n     }\n \n     fn reach(\n         &mut self,\n         def_id: LocalDefId,\n-        effective_vis: Option<EffectiveVisibility>,\n+        effective_vis: EffectiveVisibility,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             effective_vis,\n@@ -520,7 +519,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn reach_through_impl_trait(\n         &mut self,\n         def_id: LocalDefId,\n-        effective_vis: Option<EffectiveVisibility>,\n+        effective_vis: EffectiveVisibility,\n     ) -> ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n             effective_vis,\n@@ -532,9 +531,13 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n \n     // We have to make sure that the items that macros might reference\n     // are reachable, since they might be exported transitively.\n-    fn update_reachability_from_macro(&mut self, local_def_id: LocalDefId, md: &MacroDef) {\n+    fn update_reachability_from_macro(\n+        &mut self,\n+        local_def_id: LocalDefId,\n+        md: &MacroDef,\n+        macro_ev: EffectiveVisibility,\n+    ) {\n         // Non-opaque macros cannot make other items more accessible than they already are.\n-\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(local_def_id);\n         let attrs = self.tcx.hir().attrs(hir_id);\n         if attr::find_transparency(attrs, md.macro_rules).0 != Transparency::Opaque {\n@@ -554,8 +557,6 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         // Since we are starting from an externally visible module,\n         // all the parents in the loop below are also guaranteed to be modules.\n         let mut module_def_id = macro_module_def_id;\n-        let macro_ev = self.get(local_def_id);\n-        assert!(macro_ev.is_some());\n         loop {\n             let changed_reachability =\n                 self.update_macro_reachable(module_def_id, macro_module_def_id, macro_ev);\n@@ -572,7 +573,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         &mut self,\n         module_def_id: LocalDefId,\n         defining_mod: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n+        macro_ev: EffectiveVisibility,\n     ) -> bool {\n         if self.macro_reachable.insert((module_def_id, defining_mod)) {\n             self.update_macro_reachable_mod(module_def_id, defining_mod, macro_ev);\n@@ -586,7 +587,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         &mut self,\n         module_def_id: LocalDefId,\n         defining_mod: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n+        macro_ev: EffectiveVisibility,\n     ) {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n@@ -618,7 +619,7 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n         def_kind: DefKind,\n         vis: ty::Visibility,\n         module: LocalDefId,\n-        macro_ev: Option<EffectiveVisibility>,\n+        macro_ev: EffectiveVisibility,\n     ) {\n         self.update(def_id, macro_ev, Level::Reachable);\n         match def_kind {\n@@ -700,128 +701,53 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n }\n \n impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    /// We want to visit items in the context of their containing\n-    /// module and so forth, so supply a crate for doing a deep walk.\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n-\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let item_ev = match item.kind {\n-            hir::ItemKind::Impl { .. } => {\n-                let impl_ev = Option::<EffectiveVisibility>::of_impl(\n-                    item.owner_id.def_id,\n-                    self.tcx,\n-                    &self.effective_visibilities,\n-                );\n-\n-                self.update_eff_vis(item.owner_id.def_id, impl_ev, None, Level::Direct);\n-                impl_ev\n-            }\n-            _ => self.get(item.owner_id.def_id),\n-        };\n-\n-        // Update levels of nested things.\n-        match item.kind {\n-            hir::ItemKind::Enum(ref def, _) => {\n-                for variant in def.variants {\n-                    self.update(variant.def_id, item_ev, Level::Reachable);\n-                    let variant_ev = self.get(variant.def_id);\n-                    if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        self.update(ctor_def_id, variant_ev, Level::Reachable);\n-                    }\n-                    for field in variant.data.fields() {\n-                        self.update(field.def_id, variant_ev, Level::Reachable);\n-                    }\n-                }\n-            }\n-            hir::ItemKind::Impl(ref impl_) => {\n-                for impl_item_ref in impl_.items {\n-                    let def_id = impl_item_ref.id.owner_id.def_id;\n-                    let nominal_vis =\n-                        impl_.of_trait.is_none().then(|| self.tcx.local_visibility(def_id));\n-                    self.update_eff_vis(def_id, item_ev, nominal_vis, Level::Direct);\n-                }\n-            }\n-            hir::ItemKind::Trait(.., trait_item_refs) => {\n-                for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.owner_id.def_id, item_ev, Level::Reachable);\n-                }\n-            }\n-            hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n-                if let Some(ctor_def_id) = def.ctor_def_id() {\n-                    self.update(ctor_def_id, item_ev, Level::Reachable);\n-                }\n-                for field in def.fields() {\n-                    self.update(field.def_id, item_ev, Level::Reachable);\n-                }\n-            }\n-            hir::ItemKind::Macro(ref macro_def, _) => {\n-                self.update_reachability_from_macro(item.owner_id.def_id, macro_def);\n-            }\n-            hir::ItemKind::ForeignMod { items, .. } => {\n-                for foreign_item in items {\n-                    self.update(foreign_item.id.owner_id.def_id, item_ev, Level::Reachable);\n-                }\n-            }\n-\n-            hir::ItemKind::OpaqueTy(..)\n-            | hir::ItemKind::Use(..)\n-            | hir::ItemKind::Static(..)\n-            | hir::ItemKind::Const(..)\n-            | hir::ItemKind::GlobalAsm(..)\n-            | hir::ItemKind::TyAlias(..)\n-            | hir::ItemKind::Mod(..)\n-            | hir::ItemKind::TraitAlias(..)\n-            | hir::ItemKind::Fn(..)\n-            | hir::ItemKind::ExternCrate(..) => {}\n+        if self.impl_trait_pass\n+            && let hir::ItemKind::OpaqueTy(ref opaque) = item.kind\n+            && !opaque.in_trait {\n+            // FIXME: This is some serious pessimization intended to workaround deficiencies\n+            // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n+            // reachable if they are returned via `impl Trait`, even from private functions.\n+            let pub_ev = EffectiveVisibility::from_vis(ty::Visibility::Public);\n+            self.reach_through_impl_trait(item.owner_id.def_id, pub_ev)\n+                .generics()\n+                .predicates()\n+                .ty();\n+            return;\n         }\n \n-        // Mark all items in interfaces of reachable items as reachable.\n+        // Update levels of nested things and mark all items\n+        // in interfaces of reachable items as reachable.\n+        let item_ev = self.get(item.owner_id.def_id);\n         match item.kind {\n-            // The interface is empty.\n-            hir::ItemKind::Macro(..) | hir::ItemKind::ExternCrate(..) => {}\n-            // All nested items are checked by `visit_item`.\n-            hir::ItemKind::Mod(..) => {}\n-            // Handled in `rustc_resolve`.\n-            hir::ItemKind::Use(..) => {}\n-            // The interface is empty.\n-            hir::ItemKind::GlobalAsm(..) => {}\n-            hir::ItemKind::OpaqueTy(ref opaque) => {\n-                // HACK(jynelson): trying to infer the type of `impl trait` breaks `async-std` (and `pub async fn` in general)\n-                // Since rustdoc never needs to do codegen and doesn't care about link-time reachability,\n-                // mark this as unreachable.\n-                // See https://github.com/rust-lang/rust/issues/75100\n-                if !opaque.in_trait && !self.tcx.sess.opts.actually_rustdoc {\n-                    // FIXME: This is some serious pessimization intended to workaround deficiencies\n-                    // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n-                    // reachable if they are returned via `impl Trait`, even from private functions.\n-                    let exist_ev = Some(EffectiveVisibility::from_vis(ty::Visibility::Public));\n-                    self.reach_through_impl_trait(item.owner_id.def_id, exist_ev)\n-                        .generics()\n-                        .predicates()\n-                        .ty();\n+            // The interface is empty, and no nested items.\n+            hir::ItemKind::Use(..)\n+            | hir::ItemKind::ExternCrate(..)\n+            | hir::ItemKind::GlobalAsm(..) => {}\n+            // The interface is empty, and all nested items are processed by `visit_item`.\n+            hir::ItemKind::Mod(..) | hir::ItemKind::OpaqueTy(..) => {}\n+            hir::ItemKind::Macro(ref macro_def, _) => {\n+                if let Some(item_ev) = item_ev {\n+                    self.update_reachability_from_macro(item.owner_id.def_id, macro_def, item_ev);\n                 }\n             }\n-            // Visit everything.\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n+                        self.update(trait_item_ref.id.owner_id.def_id, item_ev, Level::Reachable);\n+\n                         let tcx = self.tcx;\n                         let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_ev);\n-\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n@@ -835,95 +761,94 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::TraitAlias(..) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n             }\n-            // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = Option::<EffectiveVisibility>::of_impl(\n+                    item.owner_id.def_id,\n+                    self.tcx,\n+                    &self.effective_visibilities,\n+                ) {\n+                    self.update_eff_vis(item.owner_id.def_id, item_ev, None, Level::Direct);\n+\n                     self.reach(item.owner_id.def_id, item_ev)\n                         .generics()\n                         .predicates()\n                         .ty()\n                         .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_ev = self.get(impl_item_ref.id.owner_id.def_id);\n+                        let def_id = impl_item_ref.id.owner_id.def_id;\n+                        let nominal_vis =\n+                            impl_.of_trait.is_none().then(|| self.tcx.local_visibility(def_id));\n+                        self.update_eff_vis(def_id, item_ev, nominal_vis, Level::Direct);\n \n-                        if impl_item_ev.is_some() {\n-                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_ev)\n-                                .generics()\n-                                .predicates()\n-                                .ty();\n+                        if let Some(impl_item_ev) = self.get(def_id) {\n+                            self.reach(def_id, impl_item_ev).generics().predicates().ty();\n                         }\n                     }\n                 }\n             }\n-\n-            // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                 }\n                 for variant in def.variants {\n-                    let variant_ev = self.get(variant.def_id);\n-                    if variant_ev.is_some() {\n+                    if let Some(item_ev) = item_ev {\n+                        self.update(variant.def_id, item_ev, Level::Reachable);\n+                    }\n+\n+                    if let Some(variant_ev) = self.get(variant.def_id) {\n+                        if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n+                            self.update(ctor_def_id, variant_ev, Level::Reachable);\n+                        }\n                         for field in variant.data.fields() {\n+                            self.update(field.def_id, variant_ev, Level::Reachable);\n                             self.reach(field.def_id, variant_ev).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n                         self.reach(item.owner_id.def_id, variant_ev).ty();\n                     }\n                     if let Some(ctor_def_id) = variant.data.ctor_def_id() {\n-                        let ctor_ev = self.get(ctor_def_id);\n-                        if ctor_ev.is_some() {\n+                        if let Some(ctor_ev) = self.get(ctor_def_id) {\n                             self.reach(item.owner_id.def_id, ctor_ev).ty();\n                         }\n                     }\n                 }\n             }\n-            // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_ev = self.get(foreign_item.id.owner_id.def_id);\n-                    if foreign_item_ev.is_some() {\n+                    if let Some(foreign_item_ev) = self.get(foreign_item.id.owner_id.def_id) {\n                         self.reach(foreign_item.id.owner_id.def_id, foreign_item_ev)\n                             .generics()\n                             .predicates()\n                             .ty();\n                     }\n                 }\n             }\n-            // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n-                if item_ev.is_some() {\n+                if let Some(item_ev) = item_ev {\n                     self.reach(item.owner_id.def_id, item_ev).generics().predicates();\n                     for field in struct_def.fields() {\n-                        let field_ev = self.get(field.def_id);\n-                        if field_ev.is_some() {\n+                        self.update(field.def_id, item_ev, Level::Reachable);\n+                        if let Some(field_ev) = self.get(field.def_id) {\n                             self.reach(field.def_id, field_ev).ty();\n                         }\n                     }\n                 }\n                 if let Some(ctor_def_id) = struct_def.ctor_def_id() {\n-                    let ctor_ev = self.get(ctor_def_id);\n-                    if ctor_ev.is_some() {\n+                    if let Some(item_ev) = item_ev {\n+                        self.update(ctor_def_id, item_ev, Level::Reachable);\n+                    }\n+                    if let Some(ctor_ev) = self.get(ctor_def_id) {\n                         self.reach(item.owner_id.def_id, ctor_ev).ty();\n                     }\n                 }\n             }\n         }\n-\n-        intravisit::walk_item(self, item);\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n-        // Blocks can have public items, for example impls, but they always\n-        // start as completely private regardless of publicity of a function,\n-        // constant, type, field, etc., in which this block resides.\n-        intravisit::walk_block(self, b);\n     }\n }\n \n@@ -2205,12 +2130,24 @@ fn effective_visibilities(tcx: TyCtxt<'_>, (): ()) -> &EffectiveVisibilities {\n         tcx,\n         effective_visibilities: tcx.resolutions(()).effective_visibilities.clone(),\n         macro_reachable: Default::default(),\n+        // HACK(jynelson): trying to infer the type of `impl Trait` breaks `async-std` (and\n+        // `pub async fn` in general). Since rustdoc never needs to do codegen and doesn't\n+        // care about link-time reachability, keep them unreachable (issue #75100).\n+        impl_trait_pass: !tcx.sess.opts.actually_rustdoc,\n         changed: false,\n     };\n \n     visitor.effective_visibilities.check_invariants(tcx, true);\n+    if visitor.impl_trait_pass {\n+        // Underlying types of `impl Trait`s are marked as reachable unconditionally,\n+        // so this pass doesn't need to be a part of the fixed point iteration below.\n+        tcx.hir().visit_all_item_likes_in_crate(&mut visitor);\n+        visitor.impl_trait_pass = false;\n+        visitor.changed = false;\n+    }\n+\n     loop {\n-        tcx.hir().walk_toplevel_module(&mut visitor);\n+        tcx.hir().visit_all_item_likes_in_crate(&mut visitor);\n         if visitor.changed {\n             visitor.changed = false;\n         } else {"}, {"sha": "49b423d1adeb5b4e8b6f12b278b09838fa47f5ce", "filename": "compiler/rustc_query_system/messages.ftl", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_query_system%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_query_system%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,30 +1,30 @@\n-query_system_reentrant = internal compiler error: reentrant incremental verify failure, suppressing message\n-\n-query_system_increment_compilation = internal compiler error: encountered incremental compilation error with {$dep_node}\n-    .help = This is a known issue with the compiler. Run {$run_cmd} to allow your project to compile\n-\n-query_system_increment_compilation_note1 = Please follow the instructions below to create a bug report with the provided information\n-query_system_increment_compilation_note2 = See <https://github.com/rust-lang/rust/issues/84970> for more information\n-\n query_system_cycle = cycle detected when {$stack_bottom}\n \n-query_system_cycle_usage = cycle used when {$usage}\n+query_system_cycle_recursive_trait_alias = trait aliases cannot be recursive\n \n-query_system_cycle_stack_single = ...which immediately requires {$stack_bottom} again\n+query_system_cycle_recursive_ty_alias = type aliases cannot be recursive\n+query_system_cycle_recursive_ty_alias_help1 = consider using a struct, enum, or union instead to break the cycle\n+query_system_cycle_recursive_ty_alias_help2 = see <https://doc.rust-lang.org/reference/types.html#recursive-types> for more information\n \n query_system_cycle_stack_middle = ...which requires {$desc}...\n \n query_system_cycle_stack_multiple = ...which again requires {$stack_bottom}, completing the cycle\n \n-query_system_cycle_recursive_ty_alias = type aliases cannot be recursive\n-query_system_cycle_recursive_ty_alias_help1 = consider using a struct, enum, or union instead to break the cycle\n-query_system_cycle_recursive_ty_alias_help2 = see <https://doc.rust-lang.org/reference/types.html#recursive-types> for more information\n+query_system_cycle_stack_single = ...which immediately requires {$stack_bottom} again\n \n-query_system_cycle_recursive_trait_alias = trait aliases cannot be recursive\n+query_system_cycle_usage = cycle used when {$usage}\n \n query_system_cycle_which_requires = ...which requires {$desc}...\n \n+query_system_increment_compilation = internal compiler error: encountered incremental compilation error with {$dep_node}\n+    .help = This is a known issue with the compiler. Run {$run_cmd} to allow your project to compile\n+\n+query_system_increment_compilation_note1 = Please follow the instructions below to create a bug report with the provided information\n+query_system_increment_compilation_note2 = See <https://github.com/rust-lang/rust/issues/84970> for more information\n+\n+query_system_layout_of_depth = query depth increased by {$depth} when {$desc}\n+\n query_system_query_overflow = queries overflow the depth limit!\n     .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n \n-query_system_layout_of_depth = query depth increased by {$depth} when {$desc}\n+query_system_reentrant = internal compiler error: reentrant incremental verify failure, suppressing message"}, {"sha": "c0d7386dd6adb88cc224b03177ab984a879406c7", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -656,7 +656,7 @@ impl<K: DepKind> DepGraphData<K> {\n     /// current compilation session. Used in various assertions\n     #[inline]\n     pub fn is_index_green(&self, prev_index: SerializedDepNodeIndex) -> bool {\n-        self.colors.get(prev_index).map_or(false, |c| c.is_green())\n+        self.colors.get(prev_index).is_some_and(|c| c.is_green())\n     }\n \n     #[inline]\n@@ -677,7 +677,7 @@ impl<K: DepKind> DepGraphData<K> {\n impl<K: DepKind> DepGraph<K> {\n     #[inline]\n     pub fn dep_node_exists(&self, dep_node: &DepNode<K>) -> bool {\n-        self.data.as_ref().map_or(false, |data| data.dep_node_exists(dep_node))\n+        self.data.as_ref().is_some_and(|data| data.dep_node_exists(dep_node))\n     }\n \n     /// Checks whether a previous work product exists for `v` and, if\n@@ -955,7 +955,7 @@ impl<K: DepKind> DepGraph<K> {\n     /// Returns true if the given node has been marked as green during the\n     /// current compilation session. Used in various assertions\n     pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n-        self.node_color(dep_node).map_or(false, |c| c.is_green())\n+        self.node_color(dep_node).is_some_and(|c| c.is_green())\n     }\n \n     /// This method loads all on-disk cacheable query results into memory, so"}, {"sha": "e673d5b8c6ee984da06b25db9117f32dfae7a693", "filename": "compiler/rustc_query_system/src/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -24,7 +24,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n             .iter()\n             .filter(|attr| {\n                 !attr.is_doc_comment()\n-                    && !attr.ident().map_or(false, |ident| hcx.is_ignored_attr(ident.name))\n+                    && !attr.ident().is_some_and(|ident| hcx.is_ignored_attr(ident.name))\n             })\n             .collect();\n \n@@ -38,7 +38,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n impl<'ctx> rustc_ast::HashStableContext for StableHashingContext<'ctx> {\n     fn hash_attr(&mut self, attr: &ast::Attribute, hasher: &mut StableHasher) {\n         // Make sure that these have been filtered out.\n-        debug_assert!(!attr.ident().map_or(false, |ident| self.is_ignored_attr(ident.name)));\n+        debug_assert!(!attr.ident().is_some_and(|ident| self.is_ignored_attr(ident.name)));\n         debug_assert!(!attr.is_doc_comment());\n \n         let ast::Attribute { kind, id: _, style, span } = attr;"}, {"sha": "f45f7ca5da6dd9d9dd6330a9898dae9cca078ea8", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -22,7 +22,7 @@ use {\n     rustc_data_structures::fx::FxHashSet,\n     rustc_data_structures::sync::Lock,\n     rustc_data_structures::sync::Lrc,\n-    rustc_data_structures::{jobserver, OnDrop},\n+    rustc_data_structures::{defer, jobserver},\n     rustc_span::DUMMY_SP,\n     std::iter,\n     std::process,\n@@ -530,7 +530,7 @@ fn remove_cycle<D: DepKind>(\n /// all active queries for cycles before finally resuming all the waiters at once.\n #[cfg(parallel_compiler)]\n pub fn deadlock<D: DepKind>(query_map: QueryMap<D>, registry: &rayon_core::Registry) {\n-    let on_panic = OnDrop(|| {\n+    let on_panic = defer(|| {\n         eprintln!(\"deadlock handler panicked, aborting process\");\n         process::abort();\n     });"}, {"sha": "46da0aa2853ef1fc10068fa9a57de016bf7d9791", "filename": "compiler/rustc_resolve/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2FCargo.toml?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -7,7 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n bitflags = \"1.2.1\"\n-pulldown-cmark = { version = \"0.9.2\", default-features = false }\n+pulldown-cmark = { version = \"0.9.3\", default-features = false }\n rustc_arena = { path = \"../rustc_arena\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_ast_pretty = { path = \"../rustc_ast_pretty\" }"}, {"sha": "539b88aa9d342efc4230558bc97d362870c39edb", "filename": "compiler/rustc_resolve/messages.ftl", "status": "modified", "additions": 175, "deletions": 175, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,79 +1,90 @@\n-resolve_parent_module_reset_for_binding =\n-    parent module is reset for binding\n+resolve_accessible_unsure = not sure whether the path is accessible or not\n+    .note = the type may have associated items, but we are currently not checking them\n+\n+resolve_add_as_non_derive =\n+    add as non-Derive macro\n+    `#[{$macro_path}]`\n \n resolve_ampersand_used_without_explicit_lifetime_name =\n     `&` without an explicit lifetime name cannot be used here\n     .note = explicit lifetime name needed here\n \n-resolve_underscore_lifetime_name_cannot_be_used_here =\n-    `'_` cannot be used here\n-    .note = `'_` is a reserved lifetime name\n+resolve_ancestor_only =\n+    visibilities can only be restricted to ancestor modules\n \n-resolve_crate_may_not_be_imported =\n-    `$crate` may not be imported\n+resolve_associated_const_with_similar_name_exists =\n+    there is an associated constant with a similar name\n \n-resolve_crate_root_imports_must_be_named_explicitly =\n-    crate root imports need to be explicitly named: `use crate as name;`\n+resolve_associated_fn_with_similar_name_exists =\n+    there is an associated function with a similar name\n \n-resolve_generic_params_from_outer_function =\n-    can't use generic parameters from outer function\n-    .label = use of generic parameter from outer function\n-    .suggestion = try using a local generic parameter instead\n+resolve_associated_type_with_similar_name_exists =\n+    there is an associated type with a similar name\n \n-resolve_self_type_implicitly_declared_by_impl =\n-    `Self` type implicitly declared here, by this `impl`\n+resolve_attempt_to_use_non_constant_value_in_constant =\n+    attempt to use a non-constant value in a constant\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_label_with_suggestion =\n+    non-constant value\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_with_suggestion =\n+    consider using `{$suggestion}` instead of `{$current}`\n+\n+resolve_attempt_to_use_non_constant_value_in_constant_without_suggestion =\n+    this would need to be a `{$suggestion}`\n+\n+resolve_binding_shadows_something_unacceptable =\n+    {$shadowing_binding}s cannot shadow {$shadowed_binding}s\n+    .label = cannot be named the same as {$article} {$shadowed_binding}\n+    .label_shadowed_binding = the {$shadowed_binding} `{$name}` is {$participle} here\n+\n+resolve_binding_shadows_something_unacceptable_suggestion =\n+    try specify the pattern arguments\n+\n+resolve_cannot_capture_dynamic_environment_in_fn_item =\n+    can't capture dynamic environment in a fn item\n+    .help = use the `|| {\"{\"} ... {\"}\"}` closure form instead\n \n resolve_cannot_use_self_type_here =\n     can't use `Self` here\n \n-resolve_use_a_type_here_instead =\n-    use a type here instead\n-\n-resolve_type_param_from_outer_fn =\n-    type parameter from outer function\n+resolve_const_not_member_of_trait =\n+    const `{$const_}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n \n resolve_const_param_from_outer_fn =\n     const parameter from outer function\n \n-resolve_try_using_local_generic_parameter =\n-    try using a local generic parameter instead\n-\n-resolve_try_adding_local_generic_param_on_method =\n-    try adding a local generic parameter in this method instead\n-\n-resolve_help_try_using_local_generic_param =\n-    try using a local generic parameter instead\n+resolve_const_param_in_enum_discriminant =\n+    const parameters may not be used in enum discriminant values\n \n-resolve_name_is_already_used_as_generic_parameter =\n-    the name `{$name}` is already used for a generic parameter in this item's generic parameters\n-    .label = already used\n-    .first_use_of_name = first use of `{$name}`\n+resolve_const_param_in_non_trivial_anon_const =\n+    const parameters may only be used as standalone arguments, i.e. `{$name}`\n \n-resolve_method_not_member_of_trait =\n-    method `{$method}` is not a member of trait `{$trait_}`\n-    .label = not a member of trait `{$trait_}`\n+resolve_const_param_in_ty_of_const_param =\n+    const parameters may not be used in the type of const parameters\n \n-resolve_associated_fn_with_similar_name_exists =\n-    there is an associated function with a similar name\n+resolve_crate_may_not_be_imported =\n+    `$crate` may not be imported\n \n-resolve_type_not_member_of_trait =\n-    type `{$type_}` is not a member of trait `{$trait_}`\n-    .label = not a member of trait `{$trait_}`\n+resolve_crate_root_imports_must_be_named_explicitly =\n+    crate root imports need to be explicitly named: `use crate as name;`\n \n-resolve_associated_type_with_similar_name_exists =\n-    there is an associated type with a similar name\n+resolve_expected_found =\n+    expected module, found {$res} `{$path_str}`\n+    .label = not a module\n \n-resolve_const_not_member_of_trait =\n-    const `{$const_}` is not a member of trait `{$trait_}`\n-    .label = not a member of trait `{$trait_}`\n+resolve_forward_declared_generic_param =\n+    generic parameters with a default cannot use forward declared identifiers\n+    .label = defaulted generic parameters cannot be forward declared\n \n-resolve_associated_const_with_similar_name_exists =\n-    there is an associated constant with a similar name\n+resolve_generic_params_from_outer_function =\n+    can't use generic parameters from outer function\n+    .label = use of generic parameter from outer function\n+    .suggestion = try using a local generic parameter instead\n \n-resolve_variable_bound_with_different_mode =\n-    variable `{$variable_name}` is bound inconsistently across alternatives separated by `|`\n-    .label = bound in different ways\n-    .first_binding_span = first binding\n+resolve_help_try_using_local_generic_param =\n+    try using a local generic parameter instead\n \n resolve_ident_bound_more_than_once_in_parameter_list =\n     identifier `{$identifier}` is bound more than once in this parameter list\n@@ -83,182 +94,171 @@ resolve_ident_bound_more_than_once_in_same_pattern =\n     identifier `{$identifier}` is bound more than once in the same pattern\n     .label = used in a pattern more than once\n \n-resolve_undeclared_label =\n-    use of undeclared label `{$name}`\n-    .label = undeclared label `{$name}`\n+resolve_imported_crate = `$crate` may not be imported\n \n-resolve_label_with_similar_name_reachable =\n-    a label with a similar name is reachable\n+resolve_indeterminate =\n+    cannot determine resolution for the visibility\n \n-resolve_try_using_similarly_named_label =\n-    try using similarly named label\n+resolve_invalid_asm_sym =\n+    invalid `sym` operand\n+    .label = is a local variable\n+    .help = `sym` operands must refer to either a function or a static\n \n-resolve_unreachable_label_with_similar_name_exists =\n-    a label with a similar name exists but is unreachable\n+resolve_label_with_similar_name_reachable =\n+    a label with a similar name is reachable\n \n-resolve_self_import_can_only_appear_once_in_the_list =\n-    `self` import can only appear once in an import list\n-    .label = can only appear once in an import list\n+resolve_lifetime_param_in_enum_discriminant =\n+    lifetime parameters may not be used in enum discriminant values\n \n-resolve_self_import_only_in_import_list_with_non_empty_prefix =\n-    `self` import can only appear in an import list with a non-empty prefix\n-    .label = can only appear in an import list with a non-empty prefix\n+resolve_lifetime_param_in_non_trivial_anon_const =\n+    lifetime parameters may not be used in const expressions\n \n-resolve_cannot_capture_dynamic_environment_in_fn_item =\n-    can't capture dynamic environment in a fn item\n-    .help = use the `|| {\"{\"} ... {\"}\"}` closure form instead\n+resolve_lifetime_param_in_ty_of_const_param =\n+    lifetime parameters may not be used in the type of const parameters\n \n-resolve_attempt_to_use_non_constant_value_in_constant =\n+resolve_lowercase_self =\n     attempt to use a non-constant value in a constant\n+    .suggestion = try using `Self`\n \n-resolve_attempt_to_use_non_constant_value_in_constant_with_suggestion =\n-    consider using `{$suggestion}` instead of `{$current}`\n-\n-resolve_attempt_to_use_non_constant_value_in_constant_label_with_suggestion =\n-    non-constant value\n+resolve_macro_expected_found =\n+    expected {$expected}, found {$found} `{$macro_path}`\n \n-resolve_attempt_to_use_non_constant_value_in_constant_without_suggestion =\n-    this would need to be a `{$suggestion}`\n+resolve_macro_use_extern_crate_self = `#[macro_use]` is not supported on `extern crate self`\n \n-resolve_self_imports_only_allowed_within =\n-    `self` imports are only allowed within a {\"{\"} {\"}\"} list\n+resolve_method_not_member_of_trait =\n+    method `{$method}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n \n-resolve_self_imports_only_allowed_within_suggestion =\n-    consider importing the module directly\n+resolve_module_only =\n+    visibility must resolve to a module\n \n-resolve_self_imports_only_allowed_within_multipart_suggestion =\n-    alternatively, use the multi-path `use` syntax to import `self`\n+resolve_name_is_already_used_as_generic_parameter =\n+    the name `{$name}` is already used for a generic parameter in this item's generic parameters\n+    .label = already used\n+    .first_use_of_name = first use of `{$name}`\n \n-resolve_binding_shadows_something_unacceptable =\n-    {$shadowing_binding}s cannot shadow {$shadowed_binding}s\n-    .label = cannot be named the same as {$article} {$shadowed_binding}\n-    .label_shadowed_binding = the {$shadowed_binding} `{$name}` is {$participle} here\n+resolve_param_in_enum_discriminant =\n+    generic parameters may not be used in enum discriminant values\n+    .label = cannot perform const operation using `{$name}`\n \n-resolve_binding_shadows_something_unacceptable_suggestion =\n-    try specify the pattern arguments\n+resolve_param_in_non_trivial_anon_const =\n+    generic parameters may not be used in const operations\n+    .label = cannot perform const operation using `{$name}`\n \n-resolve_forward_declared_generic_param =\n-    generic parameters with a default cannot use forward declared identifiers\n-    .label = defaulted generic parameters cannot be forward declared\n+resolve_param_in_non_trivial_anon_const_help =\n+    use `#![feature(generic_const_exprs)]` to allow generic const expressions\n \n resolve_param_in_ty_of_const_param =\n     the type of const parameters must not depend on other generic parameters\n     .label = the type must not depend on the parameter `{$name}`\n \n-resolve_type_param_in_ty_of_const_param =\n-    type parameters may not be used in the type of const parameters\n-\n-resolve_const_param_in_ty_of_const_param =\n-    const parameters may not be used in the type of const parameters\n-\n-resolve_lifetime_param_in_ty_of_const_param =\n-    lifetime parameters may not be used in the type of const parameters\n-\n-resolve_self_in_generic_param_default =\n-    generic parameters cannot use `Self` in their defaults\n-    .label = `Self` in generic parameter default\n-\n-resolve_param_in_non_trivial_anon_const =\n-    generic parameters may not be used in const operations\n-    .label = cannot perform const operation using `{$name}`\n+resolve_parent_module_reset_for_binding =\n+    parent module is reset for binding\n \n-resolve_param_in_non_trivial_anon_const_help =\n-    use `#![feature(generic_const_exprs)]` to allow generic const expressions\n+resolve_proc_macro_same_crate = can't use a procedural macro from the same crate that defines it\n+    .help = you can define integration tests in a directory named `tests`\n \n-resolve_type_param_in_non_trivial_anon_const =\n-    type parameters may not be used in const expressions\n+resolve_relative_2018 =\n+    relative paths are not supported in visibilities in 2018 edition or later\n+    .suggestion = try\n \n-resolve_const_param_in_non_trivial_anon_const =\n-    const parameters may only be used as standalone arguments, i.e. `{$name}`\n+resolve_remove_surrounding_derive =\n+    remove from the surrounding `derive()`\n \n-resolve_lifetime_param_in_non_trivial_anon_const =\n-    lifetime parameters may not be used in const expressions\n+resolve_self_import_can_only_appear_once_in_the_list =\n+    `self` import can only appear once in an import list\n+    .label = can only appear once in an import list\n \n-resolve_unreachable_label =\n-    use of unreachable label `{$name}`\n-    .label = unreachable label `{$name}`\n-    .label_definition_span = unreachable label defined here\n-    .note = labels are unreachable through functions, closures, async blocks and modules\n+resolve_self_import_only_in_import_list_with_non_empty_prefix =\n+    `self` import can only appear in an import list with a non-empty prefix\n+    .label = can only appear in an import list with a non-empty prefix\n \n-resolve_unreachable_label_suggestion_use_similarly_named =\n-    try using similarly named label\n+resolve_self_imports_only_allowed_within =\n+    `self` imports are only allowed within a {\"{\"} {\"}\"} list\n \n-resolve_unreachable_label_similar_name_reachable =\n-    a label with a similar name is reachable\n+resolve_self_imports_only_allowed_within_multipart_suggestion =\n+    alternatively, use the multi-path `use` syntax to import `self`\n \n-resolve_unreachable_label_similar_name_unreachable =\n-    a label with a similar name exists but is also unreachable\n+resolve_self_imports_only_allowed_within_suggestion =\n+    consider importing the module directly\n \n-resolve_trait_impl_mismatch =\n-    item `{$name}` is an associated {$kind}, which doesn't match its trait `{$trait_path}`\n-    .label = does not match trait\n-    .label_trait_item = item in trait\n+resolve_self_in_generic_param_default =\n+    generic parameters cannot use `Self` in their defaults\n+    .label = `Self` in generic parameter default\n \n-resolve_invalid_asm_sym =\n-    invalid `sym` operand\n-    .label = is a local variable\n-    .help = `sym` operands must refer to either a function or a static\n+resolve_self_type_implicitly_declared_by_impl =\n+    `Self` type implicitly declared here, by this `impl`\n \n-resolve_lowercase_self =\n-    attempt to use a non-constant value in a constant\n-    .suggestion = try using `Self`\n+resolve_tool_module_imported =\n+    cannot use a tool module through an import\n+    .note = the tool module imported here\n \n resolve_trait_impl_duplicate =\n     duplicate definitions with name `{$name}`:\n     .label = duplicate definition\n     .old_span_label = previous definition here\n     .trait_item_span = item in trait\n \n-resolve_relative_2018 =\n-    relative paths are not supported in visibilities in 2018 edition or later\n-    .suggestion = try\n+resolve_trait_impl_mismatch =\n+    item `{$name}` is an associated {$kind}, which doesn't match its trait `{$trait_path}`\n+    .label = does not match trait\n+    .label_trait_item = item in trait\n \n-resolve_ancestor_only =\n-    visibilities can only be restricted to ancestor modules\n+resolve_try_adding_local_generic_param_on_method =\n+    try adding a local generic parameter in this method instead\n \n-resolve_expected_found =\n-    expected module, found {$res} `{$path_str}`\n-    .label = not a module\n+resolve_try_using_local_generic_parameter =\n+    try using a local generic parameter instead\n \n-resolve_indeterminate =\n-    cannot determine resolution for the visibility\n+resolve_try_using_similarly_named_label =\n+    try using similarly named label\n \n-resolve_tool_module_imported =\n-    cannot use a tool module through an import\n-    .note = the tool module imported here\n+resolve_type_not_member_of_trait =\n+    type `{$type_}` is not a member of trait `{$trait_}`\n+    .label = not a member of trait `{$trait_}`\n \n-resolve_module_only =\n-    visibility must resolve to a module\n+resolve_type_param_from_outer_fn =\n+    type parameter from outer function\n \n-resolve_macro_expected_found =\n-    expected {$expected}, found {$found} `{$macro_path}`\n+resolve_type_param_in_enum_discriminant =\n+    type parameters may not be used in enum discriminant values\n \n-resolve_remove_surrounding_derive =\n-    remove from the surrounding `derive()`\n+resolve_type_param_in_non_trivial_anon_const =\n+    type parameters may not be used in const expressions\n \n-resolve_add_as_non_derive =\n-    add as non-Derive macro\n-    `#[{$macro_path}]`\n+resolve_type_param_in_ty_of_const_param =\n+    type parameters may not be used in the type of const parameters\n \n-resolve_proc_macro_same_crate = can't use a procedural macro from the same crate that defines it\n-    .help = you can define integration tests in a directory named `tests`\n+resolve_undeclared_label =\n+    use of undeclared label `{$name}`\n+    .label = undeclared label `{$name}`\n \n-resolve_imported_crate = `$crate` may not be imported\n+resolve_underscore_lifetime_name_cannot_be_used_here =\n+    `'_` cannot be used here\n+    .note = `'_` is a reserved lifetime name\n \n-resolve_macro_use_extern_crate_self = `#[macro_use]` is not supported on `extern crate self`\n+resolve_unreachable_label =\n+    use of unreachable label `{$name}`\n+    .label = unreachable label `{$name}`\n+    .label_definition_span = unreachable label defined here\n+    .note = labels are unreachable through functions, closures, async blocks and modules\n \n-resolve_accessible_unsure = not sure whether the path is accessible or not\n-    .note = the type may have associated items, but we are currently not checking them\n+resolve_unreachable_label_similar_name_reachable =\n+    a label with a similar name is reachable\n \n-resolve_param_in_enum_discriminant =\n-    generic parameters may not be used in enum discriminant values\n-    .label = cannot perform const operation using `{$name}`\n+resolve_unreachable_label_similar_name_unreachable =\n+    a label with a similar name exists but is also unreachable\n \n-resolve_type_param_in_enum_discriminant =\n-    type parameters may not be used in enum discriminant values\n+resolve_unreachable_label_suggestion_use_similarly_named =\n+    try using similarly named label\n \n-resolve_const_param_in_enum_discriminant =\n-    const parameters may not be used in enum discriminant values\n+resolve_unreachable_label_with_similar_name_exists =\n+    a label with a similar name exists but is unreachable\n \n-resolve_lifetime_param_in_enum_discriminant =\n-    lifetime parameters may not be used in enum discriminant values\n+resolve_use_a_type_here_instead =\n+    use a type here instead\n+\n+resolve_variable_bound_with_different_mode =\n+    variable `{$variable_name}` is bound inconsistently across alternatives separated by `|`\n+    .label = bound in different ways\n+    .first_binding_span = first binding"}, {"sha": "72777733345134f96f7d92ba9956523dc521cc2d", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -129,7 +129,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     expn_id,\n                     self.def_span(def_id),\n                     // FIXME: Account for `#[no_implicit_prelude]` attributes.\n-                    parent.map_or(false, |module| module.no_implicit_prelude),\n+                    parent.is_some_and(|module| module.no_implicit_prelude),\n                 ));\n             }\n         }\n@@ -873,6 +873,11 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                     let msg = \"macro-expanded `extern crate` items cannot \\\n                                        shadow names passed with `--extern`\";\n                     self.r.tcx.sess.span_err(item.span, msg);\n+                    // `return` is intended to discard this binding because it's an\n+                    // unregistered ambiguity error which would result in a panic\n+                    // caused by inconsistency `path_res`\n+                    // more details: https://github.com/rust-lang/rust/pull/111761\n+                    return;\n                 }\n             }\n             let entry = self.r.extern_prelude.entry(ident.normalize_to_macros_2_0()).or_insert("}, {"sha": "dc35c8b176f5cbb6de8c397378b5be6bdf4d9f8b", "filename": "compiler/rustc_resolve/src/check_unused.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fcheck_unused.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -117,16 +117,11 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n         match item.kind {\n             ast::UseTreeKind::Simple(Some(ident)) => {\n                 if ident.name == kw::Underscore\n-                    && !self\n-                        .r\n-                        .import_res_map\n-                        .get(&id)\n-                        .map(|per_ns| {\n-                            per_ns.iter().filter_map(|res| res.as_ref()).any(|res| {\n-                                matches!(res, Res::Def(DefKind::Trait | DefKind::TraitAlias, _))\n-                            })\n+                    && !self.r.import_res_map.get(&id).is_some_and(|per_ns| {\n+                        per_ns.iter().filter_map(|res| res.as_ref()).any(|res| {\n+                            matches!(res, Res::Def(DefKind::Trait | DefKind::TraitAlias, _))\n                         })\n-                        .unwrap_or(false)\n+                    })\n                 {\n                     self.unused_import(self.base_id).add(id);\n                 }\n@@ -469,7 +464,7 @@ impl Resolver<'_, '_> {\n                 .r\n                 .extern_prelude\n                 .get(&extern_crate.ident)\n-                .map_or(false, |entry| !entry.introduced_by_item)\n+                .is_some_and(|entry| !entry.introduced_by_item)\n             {\n                 continue;\n             }"}, {"sha": "8c6ac822a77a738dc7605d312c3cb8a88a7112f9", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1843,7 +1843,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None,\n                 )\n             }\n-        } else if ident.name.as_str().chars().next().map_or(false, |c| c.is_ascii_uppercase()) {\n+        } else if ident.name.as_str().chars().next().is_some_and(|c| c.is_ascii_uppercase()) {\n             // Check whether the name refers to an item in the value namespace.\n             let binding = if let Some(ribs) = ribs {\n                 self.resolve_ident_in_lexical_scope(\n@@ -2165,7 +2165,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let is_definitely_crate = import\n                     .module_path\n                     .first()\n-                    .map_or(false, |f| f.ident.name != kw::SelfLower && f.ident.name != kw::Super);\n+                    .is_some_and(|f| f.ident.name != kw::SelfLower && f.ident.name != kw::Super);\n \n                 // Add the import to the start, with a `{` if required.\n                 let start_point = source_map.start_point(after_crate_name);"}, {"sha": "e0611907613c4064ad23330e8f22c690354d4110", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -17,7 +17,7 @@ use rustc_ast::*;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_errors::{Applicability, DiagnosticArgValue, DiagnosticId, IntoDiagnosticArg};\n use rustc_hir::def::Namespace::{self, *};\n-use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, PartialRes, PerNS};\n+use rustc_hir::def::{self, CtorKind, DefKind, LifetimeRes, NonMacroAttrKind, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::{BindingAnnotation, PrimTy, TraitCandidate};\n use rustc_middle::middle::resolve_bound_vars::Set1;\n@@ -4287,12 +4287,12 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n         }\n     }\n \n-    fn resolve_and_cache_rustdoc_path(&mut self, path_str: &str, ns: Namespace) -> bool {\n+    fn resolve_and_cache_rustdoc_path(&mut self, path_str: &str, ns: Namespace) -> Option<Res> {\n         // FIXME: This caching may be incorrect in case of multiple `macro_rules`\n         // items with the same name in the same module.\n         // Also hygiene is not considered.\n         let mut doc_link_resolutions = std::mem::take(&mut self.r.doc_link_resolutions);\n-        let res = doc_link_resolutions\n+        let res = *doc_link_resolutions\n             .entry(self.parent_scope.module.nearest_parent_mod().expect_local())\n             .or_default()\n             .entry((Symbol::intern(path_str), ns))\n@@ -4307,8 +4307,7 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n                     return None;\n                 }\n                 res\n-            })\n-            .is_some();\n+            });\n         self.r.doc_link_resolutions = doc_link_resolutions;\n         res\n     }\n@@ -4343,8 +4342,10 @@ impl<'a: 'ast, 'b, 'ast, 'tcx> LateResolutionVisitor<'a, 'b, 'ast, 'tcx> {\n             let mut any_resolved = false;\n             let mut need_assoc = false;\n             for ns in [TypeNS, ValueNS, MacroNS] {\n-                if self.resolve_and_cache_rustdoc_path(&path_str, ns) {\n-                    any_resolved = true;\n+                if let Some(res) = self.resolve_and_cache_rustdoc_path(&path_str, ns) {\n+                    // Rustdoc ignores tool attribute resolutions and attempts\n+                    // to resolve their prefixes for diagnostics.\n+                    any_resolved = !matches!(res, Res::NonMacroAttr(NonMacroAttrKind::Tool));\n                 } else if ns != MacroNS {\n                     need_assoc = true;\n                 }"}, {"sha": "df65825802e126fd95736f41ac47e9aeac2c411e", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -197,8 +197,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             .sess\n                             .source_map()\n                             .span_to_snippet(span)\n-                            .map(|snippet| snippet.ends_with(')'))\n-                            .unwrap_or(false)\n+                            .is_ok_and(|snippet| snippet.ends_with(')'))\n                     }\n                     Res::Def(\n                         DefKind::Ctor(..) | DefKind::AssocFn | DefKind::Const | DefKind::AssocConst,\n@@ -722,7 +721,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         if let TypoCandidate::Shadowed(res, Some(sugg_span)) = typo_sugg\n             && res\n                 .opt_def_id()\n-                .map_or(false, |id| id.is_local() || is_in_same_file(span, sugg_span))\n+                .is_some_and(|id| id.is_local() || is_in_same_file(span, sugg_span))\n         {\n             err.span_label(\n                 sugg_span,\n@@ -856,7 +855,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n             // The current function has a `self` parameter, but we were unable to resolve\n             // a reference to `self`. This can only happen if the `self` identifier we\n             // are resolving came from a different hygiene context.\n-            if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {\n+            if fn_kind.decl().inputs.get(0).is_some_and(|p| p.is_self()) {\n                 err.span_label(*span, \"this function has a `self` parameter, but a macro invocation can only access identifiers it receives from parameters\");\n             } else {\n                 let doesnt = if is_assoc_fn {\n@@ -1632,7 +1631,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                             .tcx\n                             .fn_arg_names(def_id)\n                             .first()\n-                            .map_or(false, |ident| ident.name == kw::SelfLower),\n+                            .is_some_and(|ident| ident.name == kw::SelfLower),\n                     };\n                     if has_self {\n                         return Some(AssocSuggestion::MethodWithSelf { called });\n@@ -1931,10 +1930,9 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n                 let def_id = self.r.tcx.parent(ctor_def_id);\n                 match kind {\n                     CtorKind::Const => false,\n-                    CtorKind::Fn => !self\n-                        .r\n-                        .field_def_ids(def_id)\n-                        .map_or(false, |field_ids| field_ids.is_empty()),\n+                    CtorKind::Fn => {\n+                        !self.r.field_def_ids(def_id).is_some_and(|field_ids| field_ids.is_empty())\n+                    }\n                 }\n             };\n "}, {"sha": "3d2bd8429068e50c3cc147c16abe016fdeef2d81", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -106,7 +106,7 @@ impl Determinacy {\n /// A specific scope in which a name can be looked up.\n /// This enum is currently used only for early resolution (imports and macros),\n /// but not for late resolution yet.\n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, Debug)]\n enum Scope<'a> {\n     DeriveHelpers(LocalExpnId),\n     DeriveHelpersCompat,\n@@ -1477,7 +1477,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn is_builtin_macro(&mut self, res: Res) -> bool {\n-        self.get_macro(res).map_or(false, |macro_data| macro_data.ext.builtin_name.is_some())\n+        self.get_macro(res).is_some_and(|macro_data| macro_data.ext.builtin_name.is_some())\n     }\n \n     fn macro_def(&self, mut ctxt: SyntaxContext) -> DefId {"}, {"sha": "df5c16a9375fbf07773ff2320b9834c09a42dc6f", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -823,8 +823,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let is_allowed = |feature| {\n                     self.active_features.contains(&feature) || span.allows_unstable(feature)\n                 };\n-                let allowed_by_implication =\n-                    implied_by.map(|feature| is_allowed(feature)).unwrap_or(false);\n+                let allowed_by_implication = implied_by.is_some_and(|feature| is_allowed(feature));\n                 if !is_allowed(feature) && !allowed_by_implication {\n                     let lint_buffer = &mut self.lint_buffer;\n                     let soft_handler ="}, {"sha": "5a0b8f9f73cba4e73984a28acfabfc53e2a4fcca", "filename": "compiler/rustc_session/messages.ftl", "status": "modified", "additions": 62, "deletions": 62, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_session%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_session%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,105 +1,105 @@\n-session_incorrect_cgu_reuse_type =\n-    CGU-reuse for `{$cgu_user_name}` is `{$actual_reuse}` but should be {$at_least ->\n-    [one] {\"at least \"}\n-    *[other] {\"\"}\n-    }`{$expected_reuse}`\n+session_binary_float_literal_not_supported = binary float literal is not supported\n+session_branch_protection_requires_aarch64 = `-Zbranch-protection` is only supported on aarch64\n+\n+session_cannot_enable_crt_static_linux = sanitizer is incompatible with statically linked libc, disable it using `-C target-feature=-crt-static`\n+\n+session_cannot_mix_and_match_sanitizers = `-Zsanitizer={$first}` is incompatible with `-Zsanitizer={$second}`\n \n session_cgu_not_recorded =\n     CGU-reuse for `{$cgu_user_name}` is (mangled: `{$cgu_name}`) was not recorded\n \n-session_feature_gate_error = {$explain}\n+session_crate_name_does_not_match = `--crate-name` and `#[crate_name]` are required to match, but `{$s}` != `{$name}`\n+\n+session_crate_name_empty = crate name must not be empty\n+\n+session_crate_name_invalid = crate names cannot start with a `-`, but `{$s}` has a leading hyphen\n+\n+session_expr_parentheses_needed = parentheses are required to parse this as an expression\n \n session_feature_diagnostic_for_issue =\n     see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n \n session_feature_diagnostic_help =\n     add `#![feature({$feature})]` to the crate attributes to enable\n \n-session_not_circumvent_feature = `-Zunleash-the-miri-inside-of-you` may not be used to circumvent feature gates, except when testing error paths in the CTFE engine\n-\n-session_profile_use_file_does_not_exist = file `{$path}` passed to `-C profile-use` does not exist.\n-\n-session_linker_plugin_lto_windows_not_supported = linker plugin based LTO is not supported together with `-C prefer-dynamic` when targeting Windows-like targets\n+session_feature_gate_error = {$explain}\n \n-session_profile_sample_use_file_does_not_exist = file `{$path}` passed to `-C profile-sample-use` does not exist.\n+session_file_is_not_writeable = output file {$file} is not writeable -- check its permissions\n \n-session_target_requires_unwind_tables = target requires unwind tables, they cannot be disabled with `-C force-unwind-tables=no`\n+session_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n+session_incorrect_cgu_reuse_type =\n+    CGU-reuse for `{$cgu_user_name}` is `{$actual_reuse}` but should be {$at_least ->\n+    [one] {\"at least \"}\n+    *[other] {\"\"}\n+    }`{$expected_reuse}`\n \n session_instrumentation_not_supported = {$us} instrumentation is not supported for this target\n \n-session_sanitizer_not_supported = {$us} sanitizer is not supported for this target\n-\n-session_sanitizers_not_supported = {$us} sanitizers are not supported for this target\n-\n-session_cannot_mix_and_match_sanitizers = `-Zsanitizer={$first}` is incompatible with `-Zsanitizer={$second}`\n-\n-session_cannot_enable_crt_static_linux = sanitizer is incompatible with statically linked libc, disable it using `-C target-feature=-crt-static`\n+session_int_literal_too_large = integer literal is too large\n+    .note = value exceeds limit of `{$limit}`\n \n-session_sanitizer_cfi_requires_lto = `-Zsanitizer=cfi` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n+session_invalid_character_in_create_name = invalid character `{$character}` in crate name: `{$crate_name}`\n \n-session_sanitizer_cfi_canonical_jump_tables_requires_cfi = `-Zsanitizer-cfi-canonical-jump-tables` requires `-Zsanitizer=cfi`\n+session_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = valid suffixes are `f32` and `f64`\n \n-session_sanitizer_cfi_generalize_pointers_requires_cfi = `-Zsanitizer-cfi-generalize-pointers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n+session_invalid_float_literal_width = invalid width `{$width}` for float literal\n+    .help = valid widths are 32 and 64\n \n-session_sanitizer_cfi_normalize_integers_requires_cfi = `-Zsanitizer-cfi-normalize-integers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n+session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n+    .help = valid widths are 8, 16, 32, 64 and 128\n \n-session_split_lto_unit_requires_lto = `-Zsplit-lto-unit` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n+session_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n+    .label = invalid suffix `{$suffix}`\n \n-session_unstable_virtual_function_elimination = `-Zvirtual-function-elimination` requires `-Clto`\n+session_invalid_num_literal_base_prefix = invalid base prefix for number literal\n+    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n+    .suggestion = try making the prefix lowercase\n \n-session_unsupported_dwarf_version = requested DWARF version {$dwarf_version} is greater than 5\n+session_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n+    .label = invalid suffix `{$suffix}`\n+    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n \n-session_target_stack_protector_not_supported = `-Z stack-protector={$stack_protector}` is not supported for target {$target_triple} and will be ignored\n+session_linker_plugin_lto_windows_not_supported = linker plugin based LTO is not supported together with `-C prefer-dynamic` when targeting Windows-like targets\n \n-session_branch_protection_requires_aarch64 = `-Zbranch-protection` is only supported on aarch64\n+session_not_circumvent_feature = `-Zunleash-the-miri-inside-of-you` may not be used to circumvent feature gates, except when testing error paths in the CTFE engine\n \n-session_split_debuginfo_unstable_platform = `-Csplit-debuginfo={$debuginfo}` is unstable on this platform\n+session_not_supported = not supported\n \n-session_file_is_not_writeable = output file {$file} is not writeable -- check its permissions\n+session_nul_in_c_str = null characters in C string literals are not supported\n \n-session_crate_name_does_not_match = `--crate-name` and `#[crate_name]` are required to match, but `{$s}` != `{$name}`\n+session_octal_float_literal_not_supported = octal float literal is not supported\n+session_optimization_fuel_exhausted = optimization-fuel-exhausted: {$msg}\n \n-session_crate_name_invalid = crate names cannot start with a `-`, but `{$s}` has a leading hyphen\n+session_profile_sample_use_file_does_not_exist = file `{$path}` passed to `-C profile-sample-use` does not exist.\n \n-session_crate_name_empty = crate name must not be empty\n+session_profile_use_file_does_not_exist = file `{$path}` passed to `-C profile-use` does not exist.\n \n-session_invalid_character_in_create_name = invalid character `{$character}` in crate name: `{$crate_name}`\n+session_sanitizer_cfi_canonical_jump_tables_requires_cfi = `-Zsanitizer-cfi-canonical-jump-tables` requires `-Zsanitizer=cfi`\n \n-session_expr_parentheses_needed = parentheses are required to parse this as an expression\n+session_sanitizer_cfi_generalize_pointers_requires_cfi = `-Zsanitizer-cfi-generalize-pointers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n \n-session_skipping_const_checks = skipping const checks\n-session_unleashed_feature_help_named = skipping check for `{$gate}` feature\n-session_unleashed_feature_help_unnamed = skipping check that does not even have a feature gate\n+session_sanitizer_cfi_normalize_integers_requires_cfi = `-Zsanitizer-cfi-normalize-integers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n \n-session_hexadecimal_float_literal_not_supported = hexadecimal float literal is not supported\n-session_octal_float_literal_not_supported = octal float literal is not supported\n-session_binary_float_literal_not_supported = binary float literal is not supported\n-session_not_supported = not supported\n+session_sanitizer_cfi_requires_lto = `-Zsanitizer=cfi` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n \n-session_invalid_literal_suffix = suffixes on {$kind} literals are invalid\n-    .label = invalid suffix `{$suffix}`\n+session_sanitizer_not_supported = {$us} sanitizer is not supported for this target\n \n-session_invalid_num_literal_base_prefix = invalid base prefix for number literal\n-    .note = base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\n-    .suggestion = try making the prefix lowercase\n+session_sanitizers_not_supported = {$us} sanitizers are not supported for this target\n \n-session_invalid_num_literal_suffix = invalid suffix `{$suffix}` for number literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = the suffix must be one of the numeric types (`u32`, `isize`, `f32`, etc.)\n+session_skipping_const_checks = skipping const checks\n+session_split_debuginfo_unstable_platform = `-Csplit-debuginfo={$debuginfo}` is unstable on this platform\n \n-session_invalid_float_literal_width = invalid width `{$width}` for float literal\n-    .help = valid widths are 32 and 64\n+session_split_lto_unit_requires_lto = `-Zsplit-lto-unit` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n \n-session_invalid_float_literal_suffix = invalid suffix `{$suffix}` for float literal\n-    .label = invalid suffix `{$suffix}`\n-    .help = valid suffixes are `f32` and `f64`\n+session_target_requires_unwind_tables = target requires unwind tables, they cannot be disabled with `-C force-unwind-tables=no`\n \n-session_int_literal_too_large = integer literal is too large\n-    .note = value exceeds limit of `{$limit}`\n+session_target_stack_protector_not_supported = `-Z stack-protector={$stack_protector}` is not supported for target {$target_triple} and will be ignored\n \n-session_invalid_int_literal_width = invalid width `{$width}` for integer literal\n-    .help = valid widths are 8, 16, 32, 64 and 128\n+session_unleashed_feature_help_named = skipping check for `{$gate}` feature\n+session_unleashed_feature_help_unnamed = skipping check that does not even have a feature gate\n \n-session_optimization_fuel_exhausted = optimization-fuel-exhausted: {$msg}\n+session_unstable_virtual_function_elimination = `-Zvirtual-function-elimination` requires `-Clto`\n \n-session_nul_in_c_str = null characters in C string literals are not supported\n+session_unsupported_dwarf_version = requested DWARF version {$dwarf_version} is greater than 5"}, {"sha": "6c8c8e484f93954bd2d3f29ace28df1a4e04e900", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1907,7 +1907,7 @@ fn collect_print_requests(\n     error_format: ErrorOutputType,\n ) -> Vec<PrintRequest> {\n     let mut prints = Vec::<PrintRequest>::new();\n-    if cg.target_cpu.as_ref().map_or(false, |s| s == \"help\") {\n+    if cg.target_cpu.as_ref().is_some_and(|s| s == \"help\") {\n         prints.push(PrintRequest::TargetCPUs);\n         cg.target_cpu = None;\n     };"}, {"sha": "bbe52dbced071d93a477f2d2948864a8a00aeb91", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1378,8 +1378,8 @@ pub fn build_session(\n         .lint_opts\n         .iter()\n         .rfind(|&(key, _)| *key == \"warnings\")\n-        .map_or(false, |&(_, level)| level == lint::Allow);\n-    let cap_lints_allow = sopts.lint_cap.map_or(false, |cap| cap == lint::Allow);\n+        .is_some_and(|&(_, level)| level == lint::Allow);\n+    let cap_lints_allow = sopts.lint_cap.is_some_and(|cap| cap == lint::Allow);\n     let can_emit_warnings = !(warnings_allow || cap_lints_allow);\n \n     let sysroot = match &sopts.maybe_sysroot {"}, {"sha": "6755657c7276eb54fc5161e02f174ff7d0c68b93", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -320,7 +320,6 @@ impl ExpnId {\n             // Stop going up the backtrace once include! is encountered\n             if expn_data.is_root()\n                 || expn_data.kind == ExpnKind::Macro(MacroKind::Bang, sym::include)\n-                || expn_data.kind == ExpnKind::Inlined\n             {\n                 break;\n             }\n@@ -1058,8 +1057,6 @@ pub enum ExpnKind {\n     AstPass(AstPass),\n     /// Desugaring done by the compiler during HIR lowering.\n     Desugaring(DesugaringKind),\n-    /// MIR inlining\n-    Inlined,\n }\n \n impl ExpnKind {\n@@ -1073,7 +1070,6 @@ impl ExpnKind {\n             },\n             ExpnKind::AstPass(kind) => kind.descr().to_string(),\n             ExpnKind::Desugaring(kind) => format!(\"desugaring of {}\", kind.descr()),\n-            ExpnKind::Inlined => \"inlined source\".to_string(),\n         }\n     }\n }"}, {"sha": "eae3f0fa041dd1cd19ec750518d2e08eb9227e6b", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -594,12 +594,6 @@ impl Span {\n         matches!(outer_expn.kind, ExpnKind::Macro(..)) && outer_expn.collapse_debuginfo\n     }\n \n-    /// Returns `true` if this span comes from MIR inlining.\n-    pub fn is_inlined(self) -> bool {\n-        let outer_expn = self.ctxt().outer_expn_data();\n-        matches!(outer_expn.kind, ExpnKind::Inlined)\n-    }\n-\n     /// Returns `true` if `span` originates in a derive-macro's expansion.\n     pub fn in_derive_expansion(self) -> bool {\n         matches!(self.ctxt().outer_expn_data().kind, ExpnKind::Macro(MacroKind::Derive, _))\n@@ -754,7 +748,7 @@ impl Span {\n         self.ctxt()\n             .outer_expn_data()\n             .allow_internal_unstable\n-            .map_or(false, |features| features.iter().any(|&f| f == feature))\n+            .is_some_and(|features| features.iter().any(|&f| f == feature))\n     }\n \n     /// Checks if this span arises from a compiler desugaring of kind `kind`."}, {"sha": "1824510a9742e032660b3db7a920d2ca950096b2", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -639,7 +639,7 @@ impl SourceMap {\n         self.span_to_source(sp, |src, start_index, end_index| {\n             Ok(src.get(start_index..end_index).is_some())\n         })\n-        .map_or(false, |is_accessible| is_accessible)\n+        .is_ok_and(|is_accessible| is_accessible)\n     }\n \n     /// Returns the source snippet as `String` corresponding to the given `Span`.\n@@ -835,7 +835,7 @@ impl SourceMap {\n             }\n             return Ok(true);\n         })\n-        .map_or(false, |is_accessible| is_accessible)\n+        .is_ok_and(|is_accessible| is_accessible)\n     }\n \n     /// Given a `Span`, tries to get a shorter span ending just after the first occurrence of `char`\n@@ -967,7 +967,7 @@ impl SourceMap {\n         for _ in 0..limit.unwrap_or(100_usize) {\n             sp = self.next_point(sp);\n             if let Ok(ref snippet) = self.span_to_snippet(sp) {\n-                if expect.map_or(false, |es| snippet == es) {\n+                if expect.is_some_and(|es| snippet == es) {\n                     break;\n                 }\n                 if expect.is_none() && snippet.chars().any(|c| !c.is_whitespace()) {"}, {"sha": "254ede4e6a00af65133353711f580d2a300b4060", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -220,7 +220,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n         match *ty.kind() {\n             // Print all nominal types as paths (unlike `pretty_print_type`).\n             ty::FnDef(def_id, substs)\n-            | ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n+            | ty::Alias(ty::Projection | ty::Opaque, ty::AliasTy { def_id, substs, .. })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => self.print_def_path(def_id, substs),\n \n@@ -241,6 +241,8 @@ impl<'tcx> Printer<'tcx> for &mut SymbolPrinter<'tcx> {\n                 Ok(self)\n             }\n \n+            ty::Alias(ty::Inherent, _) => panic!(\"unexpected inherent projection\"),\n+\n             _ => self.pretty_print_type(ty),\n         }\n     }"}, {"sha": "9fa49123a868ec9b7725c88be22d635d922aedda", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -272,12 +272,11 @@ fn encode_region<'tcx>(\n             s.push('E');\n             compress(dict, DictKey::Region(region), &mut s);\n         }\n-        RegionKind::ReErased => {\n+        RegionKind::ReEarlyBound(..) | RegionKind::ReErased => {\n             s.push_str(\"u6region\");\n             compress(dict, DictKey::Region(region), &mut s);\n         }\n-        RegionKind::ReEarlyBound(..)\n-        | RegionKind::ReFree(..)\n+        RegionKind::ReFree(..)\n         | RegionKind::ReStatic\n         | RegionKind::ReError(_)\n         | RegionKind::ReVar(..)\n@@ -704,14 +703,15 @@ fn transform_predicates<'tcx>(\n ) -> &'tcx List<ty::PolyExistentialPredicate<'tcx>> {\n     let predicates: Vec<ty::PolyExistentialPredicate<'tcx>> = predicates\n         .iter()\n-        .map(|predicate| match predicate.skip_binder() {\n+        .filter_map(|predicate| match predicate.skip_binder() {\n             ty::ExistentialPredicate::Trait(trait_ref) => {\n                 let trait_ref = ty::TraitRef::identity(tcx, trait_ref.def_id);\n-                ty::Binder::dummy(ty::ExistentialPredicate::Trait(\n+                Some(ty::Binder::dummy(ty::ExistentialPredicate::Trait(\n                     ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref),\n-                ))\n+                )))\n             }\n-            _ => predicate,\n+            ty::ExistentialPredicate::Projection(..) => None,\n+            ty::ExistentialPredicate::AutoTrait(..) => Some(predicate),\n         })\n         .collect();\n     tcx.mk_poly_existential_predicates(&predicates)\n@@ -818,7 +818,7 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n                 let field = variant.fields.iter().find(|field| {\n                     let ty = tcx.type_of(field.did).subst_identity();\n                     let is_zst =\n-                        tcx.layout_of(param_env.and(ty)).map_or(false, |layout| layout.is_zst());\n+                        tcx.layout_of(param_env.and(ty)).is_ok_and(|layout| layout.is_zst());\n                     !is_zst\n                 });\n                 if let Some(field) = field {"}, {"sha": "4cccc6398927c331f1b2347bb5ab0c29cb4e8cc6", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -433,7 +433,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n             // Mangle all nominal types as paths.\n             ty::Adt(ty::AdtDef(Interned(&ty::AdtDefData { did: def_id, .. }, _)), substs)\n             | ty::FnDef(def_id, substs)\n-            | ty::Alias(_, ty::AliasTy { def_id, substs, .. })\n+            | ty::Alias(ty::Projection | ty::Opaque, ty::AliasTy { def_id, substs, .. })\n             | ty::Closure(def_id, substs)\n             | ty::Generator(def_id, substs, _) => {\n                 self = self.print_def_path(def_id, substs)?;\n@@ -482,6 +482,7 @@ impl<'tcx> Printer<'tcx> for &mut SymbolMangler<'tcx> {\n                 self = r.print(self)?;\n             }\n \n+            ty::Alias(ty::Inherent, _) => bug!(\"symbol_names: unexpected inherent projection\"),\n             ty::GeneratorWitness(_) => bug!(\"symbol_names: unexpected `GeneratorWitness`\"),\n             ty::GeneratorWitnessMIR(..) => bug!(\"symbol_names: unexpected `GeneratorWitnessMIR`\"),\n         }"}, {"sha": "9ac732351411c8df5b65b0816182d29eb85a2068", "filename": "compiler/rustc_target/src/spec/aarch64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -4,7 +4,7 @@ use crate::spec::{FramePointer, SanitizerSet, Target, TargetOptions};\n pub fn target() -> Target {\n     let arch = Arch::Arm64;\n     let mut base = opts(\"macos\", arch);\n-    base.cpu = \"apple-a14\".into();\n+    base.cpu = \"apple-m1\".into();\n     base.max_atomic_width = Some(128);\n \n     // FIXME: The leak sanitizer currently fails the tests, see #88132."}, {"sha": "e2df7e0bdcc790c7776eb04397a3714fde16c8f3", "filename": "compiler/rustc_target/src/spec/aarch64_apple_ios_macabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_ios_macabi.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -2,7 +2,7 @@ use super::apple_base::{opts, Arch};\n use crate::spec::{Cc, FramePointer, LinkerFlavor, Lld, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let llvm_target = \"arm64-apple-ios-macabi\";\n+    let llvm_target = \"arm64-apple-ios14.0-macabi\";\n \n     let arch = Arch::Arm64_macabi;\n     let mut base = opts(\"ios\", arch);"}, {"sha": "523eb6bd2fe22b0e748434d2c420781828f0245a", "filename": "compiler/rustc_target/src/spec/aarch64_unknown_linux_musl.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_unknown_linux_musl.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,10 +1,15 @@\n-use crate::spec::{Target, TargetOptions};\n+use crate::spec::{SanitizerSet, Target, TargetOptions};\n \n pub fn target() -> Target {\n     let mut base = super::linux_musl_base::opts();\n     base.max_atomic_width = Some(128);\n     base.supports_xray = true;\n     base.features = \"+v8a\".into();\n+    base.supported_sanitizers = SanitizerSet::ADDRESS\n+        | SanitizerSet::CFI\n+        | SanitizerSet::LEAK\n+        | SanitizerSet::MEMORY\n+        | SanitizerSet::THREAD;\n \n     Target {\n         llvm_target: \"aarch64-unknown-linux-musl\".into(),"}, {"sha": "9f3b0fab697e6718c6518c61b66044d170ed71b2", "filename": "compiler/rustc_target/src/spec/x86_64_apple_ios_macabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_ios_macabi.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -2,7 +2,7 @@ use super::apple_base::{opts, Arch};\n use crate::spec::{Cc, LinkerFlavor, Lld, StackProbeType, Target, TargetOptions};\n \n pub fn target() -> Target {\n-    let llvm_target = \"x86_64-apple-ios-macabi\";\n+    let llvm_target = \"x86_64-apple-ios14.0-macabi\";\n \n     let arch = Arch::X86_64_macabi;\n     let mut base = opts(\"ios\", arch);"}, {"sha": "217ba71b6310802f861486da088b57b4a36e46f6", "filename": "compiler/rustc_trait_selection/messages.ftl", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,17 +1,13 @@\n trait_selection_dump_vtable_entries = vtable entries for `{$trait_ref}`: {$entries}\n \n-trait_selection_unable_to_construct_constant_value = unable to construct a constant value for the unevaluated constant {$unevaluated}\n-\n trait_selection_empty_on_clause_in_rustc_on_unimplemented = empty `on`-clause in `#[rustc_on_unimplemented]`\n     .label = empty on-clause here\n \n+trait_selection_inherent_projection_normalization_overflow = overflow evaluating associated type `{$ty}`\n+\n trait_selection_invalid_on_clause_in_rustc_on_unimplemented = invalid `on`-clause in `#[rustc_on_unimplemented]`\n     .label = invalid on-clause here\n \n-trait_selection_no_value_in_rustc_on_unimplemented = this attribute must have a valid value\n-    .label = expected value here\n-    .note = eg `#[rustc_on_unimplemented(message=\"foo\")]`\n-\n trait_selection_negative_positive_conflict = found both positive and negative implementation of trait `{$trait_desc}`{$self_desc ->\n         [none] {\"\"}\n        *[default] {\" \"}for type `{$self_desc}`\n@@ -21,4 +17,8 @@ trait_selection_negative_positive_conflict = found both positive and negative im\n     .positive_implementation_here = positive implementation here\n     .positive_implementation_in_crate = positive implementation in crate `{$positive_impl_cname}`\n \n-trait_selection_inherent_projection_normalization_overflow = overflow evaluating associated type `{$ty}`\n+trait_selection_no_value_in_rustc_on_unimplemented = this attribute must have a valid value\n+    .label = expected value here\n+    .note = eg `#[rustc_on_unimplemented(message=\"foo\")]`\n+\n+trait_selection_unable_to_construct_constant_value = unable to construct a constant value for the unevaluated constant {$unevaluated}"}, {"sha": "312bd38178fdda3e18587a6a68aa879b711e6ee0", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::infer::canonical::{Canonical, CanonicalQueryResponse, QueryResponse};\n-use rustc_middle::traits::query::Fallible;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitableExt};\n use rustc_middle::ty::{GenericArg, ToPredicate};\n use rustc_span::DUMMY_SP;\n@@ -82,8 +82,8 @@ pub trait InferCtxtBuilderExt<'tcx> {\n     fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Fallible<R>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, R>>\n+        operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Result<R, NoSolution>,\n+    ) -> Result<CanonicalQueryResponse<'tcx, R>, NoSolution>\n     where\n         K: TypeFoldable<TyCtxt<'tcx>>,\n         R: Debug + TypeFoldable<TyCtxt<'tcx>>,\n@@ -110,8 +110,8 @@ impl<'tcx> InferCtxtBuilderExt<'tcx> for InferCtxtBuilder<'tcx> {\n     fn enter_canonical_trait_query<K, R>(\n         &mut self,\n         canonical_key: &Canonical<'tcx, K>,\n-        operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Fallible<R>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, R>>\n+        operation: impl FnOnce(&ObligationCtxt<'_, 'tcx>, K) -> Result<R, NoSolution>,\n+    ) -> Result<CanonicalQueryResponse<'tcx, R>, NoSolution>\n     where\n         K: TypeFoldable<TyCtxt<'tcx>>,\n         R: Debug + TypeFoldable<TyCtxt<'tcx>>,"}, {"sha": "f32ff0442a4c51bb73b7feb5a34039ab1c86587a", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -2,7 +2,6 @@\n \n use super::search_graph::OverflowHandler;\n use super::{EvalCtxt, SolverMode};\n-use crate::solve::CanonicalResponseExt;\n use crate::traits::coherence;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n@@ -333,8 +332,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         candidates: &mut Vec<Candidate<'tcx>>,\n     ) {\n         let tcx = self.tcx();\n-        // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n-        let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n+        let &ty::Alias(_, projection_ty) = goal.predicate.self_ty().kind() else {\n             return\n         };\n \n@@ -356,8 +354,11 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                         }),\n                     );\n                     ecx.add_goal(normalizes_to_goal);\n-                    let _ = ecx.try_evaluate_added_goals()?;\n+                    let _ = ecx.try_evaluate_added_goals().inspect_err(|_| {\n+                        debug!(\"self type normalization failed\");\n+                    })?;\n                     let normalized_ty = ecx.resolve_vars_if_possible(normalized_ty);\n+                    debug!(?normalized_ty, \"self type normalized\");\n                     // NOTE: Alternatively we could call `evaluate_goal` here and only\n                     // have a `Normalized` candidate. This doesn't work as long as we\n                     // use `CandidateSource` in winnowing.\n@@ -742,13 +743,18 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             SolverMode::Normal => {\n                 let param_env_responses = candidates\n                     .iter()\n-                    .filter(|c| matches!(c.source, CandidateSource::ParamEnv(_)))\n+                    .filter(|c| {\n+                        matches!(\n+                            c.source,\n+                            CandidateSource::ParamEnv(_) | CandidateSource::AliasBound\n+                        )\n+                    })\n                     .map(|c| c.result)\n                     .collect::<Vec<_>>();\n                 if let Some(result) = self.try_merge_responses(&param_env_responses) {\n-                    if result.has_only_region_constraints() {\n-                        return Ok(result);\n-                    }\n+                    // We strongly prefer alias and param-env bounds here, even if they affect inference.\n+                    // See https://github.com/rust-lang/trait-system-refactor-initiative/issues/11.\n+                    return Ok(result);\n                 }\n             }\n         }"}, {"sha": "f91c672775301610c630480bf89eed604317cc69", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 99, "deletions": 9, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,4 +1,4 @@\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_infer::infer::at::ToTrace;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n@@ -9,7 +9,11 @@ use rustc_infer::infer::{\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n-use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n+use rustc_middle::traits::solve::{\n+    CanonicalInput, CanonicalResponse, Certainty, MaybeCause, PredefinedOpaques,\n+    PredefinedOpaquesData, QueryResult,\n+};\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::{\n     self, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n     TypeVisitor,\n@@ -44,6 +48,9 @@ pub struct EvalCtxt<'a, 'tcx> {\n     infcx: &'a InferCtxt<'tcx>,\n \n     pub(super) var_values: CanonicalVarValues<'tcx>,\n+\n+    predefined_opaques_in_body: PredefinedOpaques<'tcx>,\n+\n     /// The highest universe index nameable by the caller.\n     ///\n     /// When we enter a new binder inside of the query we create new universes\n@@ -126,6 +133,11 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n         let mut ecx = EvalCtxt {\n             search_graph: &mut search_graph,\n             infcx: self,\n+            // Only relevant when canonicalizing the response,\n+            // which we don't do within this evaluation context.\n+            predefined_opaques_in_body: self\n+                .tcx\n+                .mk_predefined_opaques_in_body(PredefinedOpaquesData::default()),\n             // Only relevant when canonicalizing the response.\n             max_input_universe: ty::UniverseIndex::ROOT,\n             var_values: CanonicalVarValues::dummy(),\n@@ -162,29 +174,53 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n     fn evaluate_canonical_goal(\n         tcx: TyCtxt<'tcx>,\n         search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n+        canonical_input: CanonicalInput<'tcx>,\n     ) -> QueryResult<'tcx> {\n         // Deal with overflow, caching, and coinduction.\n         //\n         // The actual solver logic happens in `ecx.compute_goal`.\n-        search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n+        search_graph.with_new_goal(tcx, canonical_input, |search_graph| {\n             let intercrate = match search_graph.solver_mode() {\n                 SolverMode::Normal => false,\n                 SolverMode::Coherence => true,\n             };\n-            let (ref infcx, goal, var_values) = tcx\n+            let (ref infcx, input, var_values) = tcx\n                 .infer_ctxt()\n                 .intercrate(intercrate)\n-                .build_with_canonical(DUMMY_SP, &canonical_goal);\n+                .with_opaque_type_inference(canonical_input.value.anchor)\n+                .build_with_canonical(DUMMY_SP, &canonical_input);\n+\n+            for &(a, b) in &input.predefined_opaques_in_body.opaque_types {\n+                let InferOk { value: (), obligations } = infcx\n+                    .register_hidden_type_in_new_solver(a, input.goal.param_env, b)\n+                    .expect(\"expected opaque type instantiation to succeed\");\n+                // We're only registering opaques already defined by the caller,\n+                // so we're not responsible for proving that they satisfy their\n+                // item bounds, unless we use them in a normalizes-to goal,\n+                // which is handled in `EvalCtxt::unify_existing_opaque_tys`.\n+                let _ = obligations;\n+            }\n             let mut ecx = EvalCtxt {\n                 infcx,\n                 var_values,\n-                max_input_universe: canonical_goal.max_universe,\n+                predefined_opaques_in_body: input.predefined_opaques_in_body,\n+                max_input_universe: canonical_input.max_universe,\n                 search_graph,\n                 nested_goals: NestedGoals::new(),\n                 tainted: Ok(()),\n             };\n-            ecx.compute_goal(goal)\n+\n+            let result = ecx.compute_goal(input.goal);\n+\n+            // When creating a query response we clone the opaque type constraints\n+            // instead of taking them. This would cause an ICE here, since we have\n+            // assertions against dropping an `InferCtxt` without taking opaques.\n+            // FIXME: Once we remove support for the old impl we can remove this.\n+            if input.anchor != DefiningAnchor::Error {\n+                let _ = infcx.take_opaque_types();\n+            }\n+\n+            result\n         })\n     }\n \n@@ -199,7 +235,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n \n-        let has_changed = !canonical_response.value.var_values.is_identity();\n+        let has_changed = !canonical_response.value.var_values.is_identity()\n+            || !canonical_response.value.external_constraints.opaque_types.is_empty();\n         let (certainty, nested_goals) = self.instantiate_and_apply_query_response(\n             goal.param_env,\n             orig_values,\n@@ -418,6 +455,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let mut ecx = EvalCtxt {\n             infcx: self.infcx,\n             var_values: self.var_values,\n+            predefined_opaques_in_body: self.predefined_opaques_in_body,\n             max_input_universe: self.max_input_universe,\n             search_graph: self.search_graph,\n             nested_goals: self.nested_goals.clone(),\n@@ -682,4 +720,56 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             | rustc_transmute::Answer::IfAny(_) => Err(NoSolution),\n         }\n     }\n+\n+    pub(super) fn can_define_opaque_ty(&mut self, def_id: LocalDefId) -> bool {\n+        self.infcx.opaque_type_origin(def_id).is_some()\n+    }\n+\n+    pub(super) fn register_opaque_ty(\n+        &mut self,\n+        a: ty::OpaqueTypeKey<'tcx>,\n+        b: Ty<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Result<(), NoSolution> {\n+        let InferOk { value: (), obligations } =\n+            self.infcx.register_hidden_type_in_new_solver(a, param_env, b)?;\n+        self.add_goals(obligations.into_iter().map(|obligation| obligation.into()));\n+        Ok(())\n+    }\n+\n+    // Do something for each opaque/hidden pair defined with `def_id` in the\n+    // current inference context.\n+    pub(super) fn unify_existing_opaque_tys(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        key: ty::OpaqueTypeKey<'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> Vec<CanonicalResponse<'tcx>> {\n+        // FIXME: Super inefficient to be cloning this...\n+        let opaques = self.infcx.clone_opaque_types_for_query_response();\n+\n+        let mut values = vec![];\n+        for (candidate_key, candidate_ty) in opaques {\n+            if candidate_key.def_id != key.def_id {\n+                continue;\n+            }\n+            values.extend(self.probe(|ecx| {\n+                for (a, b) in std::iter::zip(candidate_key.substs, key.substs) {\n+                    ecx.eq(param_env, a, b)?;\n+                }\n+                ecx.eq(param_env, candidate_ty, ty)?;\n+                let mut obl = vec![];\n+                ecx.infcx.add_item_bounds_for_hidden_type(\n+                    candidate_key,\n+                    ObligationCause::dummy(),\n+                    param_env,\n+                    candidate_ty,\n+                    &mut obl,\n+                );\n+                ecx.add_goals(obl.into_iter().map(Into::into));\n+                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }));\n+        }\n+        values\n+    }\n }"}, {"sha": "fdb209fbff871cfd7d42c4da75ee28da10ac481f", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt/canonical.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt%2Fcanonical.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -8,16 +8,19 @@\n /// section of the [rustc-dev-guide][c].\n ///\n /// [c]: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n-use super::{CanonicalGoal, Certainty, EvalCtxt, Goal};\n+use super::{CanonicalInput, Certainty, EvalCtxt, Goal};\n use crate::solve::canonicalize::{CanonicalizeMode, Canonicalizer};\n use crate::solve::{CanonicalResponse, QueryResult, Response};\n use rustc_index::IndexVec;\n use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n+use rustc_infer::infer::InferOk;\n use rustc_middle::traits::query::NoSolution;\n-use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData, MaybeCause};\n-use rustc_middle::ty::{self, BoundVar, GenericArgKind};\n+use rustc_middle::traits::solve::{\n+    ExternalConstraints, ExternalConstraintsData, MaybeCause, PredefinedOpaquesData, QueryInput,\n+};\n+use rustc_middle::ty::{self, BoundVar, GenericArgKind, Ty};\n use rustc_span::DUMMY_SP;\n use std::iter;\n use std::ops::Deref;\n@@ -28,13 +31,21 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn canonicalize_goal(\n         &self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n-    ) -> (Vec<ty::GenericArg<'tcx>>, CanonicalGoal<'tcx>) {\n+    ) -> (Vec<ty::GenericArg<'tcx>>, CanonicalInput<'tcx>) {\n         let mut orig_values = Default::default();\n         let canonical_goal = Canonicalizer::canonicalize(\n             self.infcx,\n             CanonicalizeMode::Input,\n             &mut orig_values,\n-            goal,\n+            QueryInput {\n+                goal,\n+                anchor: self.infcx.defining_use_anchor,\n+                predefined_opaques_in_body: self.tcx().mk_predefined_opaques_in_body(\n+                    PredefinedOpaquesData {\n+                        opaque_types: self.infcx.clone_opaque_types_for_query_response(),\n+                    },\n+                ),\n+            },\n         );\n         (orig_values, canonical_goal)\n     }\n@@ -138,7 +149,13 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 region_constraints,\n             )\n         });\n-        let opaque_types = self.infcx.clone_opaque_types_for_query_response();\n+\n+        let mut opaque_types = self.infcx.clone_opaque_types_for_query_response();\n+        // Only return opaque type keys for newly-defined opaques\n+        opaque_types.retain(|(a, _)| {\n+            self.predefined_opaques_in_body.opaque_types.iter().all(|(pa, _)| pa != a)\n+        });\n+\n         Ok(self\n             .tcx()\n             .mk_external_constraints(ExternalConstraintsData { region_constraints, opaque_types }))\n@@ -164,10 +181,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         let nested_goals = self.unify_query_var_values(param_env, &original_values, var_values)?;\n \n-        // FIXME: implement external constraints.\n-        let ExternalConstraintsData { region_constraints, opaque_types: _ } =\n+        let ExternalConstraintsData { region_constraints, opaque_types } =\n             external_constraints.deref();\n         self.register_region_constraints(region_constraints);\n+        self.register_opaque_types(param_env, opaque_types)?;\n \n         Ok((certainty, nested_goals))\n     }\n@@ -287,4 +304,19 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             let _ = member_constraint;\n         }\n     }\n+\n+    fn register_opaque_types(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        opaque_types: &[(ty::OpaqueTypeKey<'tcx>, Ty<'tcx>)],\n+    ) -> Result<(), NoSolution> {\n+        for &(a, b) in opaque_types {\n+            let InferOk { value: (), obligations } =\n+                self.infcx.register_hidden_type_in_new_solver(a, param_env, b)?;\n+            // It's sound to drop these obligations, since the normalizes-to goal\n+            // is responsible for proving these obligations.\n+            let _ = obligations;\n+        }\n+        Ok(())\n+    }\n }"}, {"sha": "4a403196c7e05d89abf8a49c67cf9900eb095484", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -133,12 +133,14 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                 | ty::PredicateKind::ObjectSafe(_)\n                                 | ty::PredicateKind::ClosureKind(_, _, _)\n                                 | ty::PredicateKind::ConstEvaluatable(_)\n-                                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n                                 | ty::PredicateKind::Ambiguous => {\n                                     FulfillmentErrorCode::CodeSelectionError(\n                                         SelectionError::Unimplemented,\n                                     )\n                                 }\n+                                ty::PredicateKind::TypeWellFormedFromEnv(_) => {\n+                                    bug!(\"unexpected goal: {goal:?}\")\n+                                }\n                             },\n                             root_obligation: obligation,\n                         });"}, {"sha": "26ace28f5fd24ba744b10636967183e29389c519", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -24,6 +24,7 @@ mod assembly;\n mod canonicalize;\n mod eval_ctxt;\n mod fulfill;\n+mod opaques;\n mod project_goals;\n mod search_graph;\n mod trait_goals;\n@@ -212,7 +213,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             );\n         }\n \n-        match (lhs.to_projection_term(tcx), rhs.to_projection_term(tcx)) {\n+        match (lhs.to_alias_ty(tcx), rhs.to_alias_ty(tcx)) {\n             (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n \n             // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n@@ -238,34 +239,34 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                     evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes).ok(),\n                 );\n                 // Relate via substs\n-                candidates.extend(\n-                    self.probe(|ecx| {\n-                        let span = tracing::span!(\n-                            tracing::Level::DEBUG,\n-                            \"compute_alias_relate_goal(relate_via_substs)\",\n-                            ?alias_lhs,\n-                            ?alias_rhs,\n-                            ?direction\n-                        );\n-                        let _enter = span.enter();\n-\n-                        match direction {\n-                            ty::AliasRelationDirection::Equate => {\n-                                ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                            }\n-                            ty::AliasRelationDirection::Subtype => {\n-                                ecx.sub(goal.param_env, alias_lhs, alias_rhs)?;\n-                            }\n+                let subst_relate_response = self.probe(|ecx| {\n+                    let span = tracing::span!(\n+                        tracing::Level::DEBUG,\n+                        \"compute_alias_relate_goal(relate_via_substs)\",\n+                        ?alias_lhs,\n+                        ?alias_rhs,\n+                        ?direction\n+                    );\n+                    let _enter = span.enter();\n+\n+                    match direction {\n+                        ty::AliasRelationDirection::Equate => {\n+                            ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                        }\n+                        ty::AliasRelationDirection::Subtype => {\n+                            ecx.sub(goal.param_env, alias_lhs, alias_rhs)?;\n                         }\n+                    }\n \n-                        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                    })\n-                    .ok(),\n-                );\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                });\n+                candidates.extend(subst_relate_response);\n                 debug!(?candidates);\n \n                 if let Some(merged) = self.try_merge_responses(&candidates) {\n                     Ok(merged)\n+                } else if let Ok(subst_relate_response) = subst_relate_response {\n+                    Ok(subst_relate_response)\n                 } else {\n                     self.flounder(&candidates)\n                 }"}, {"sha": "a5de4ddee82bae4f9334c3e29babc11c6eb51113", "filename": "compiler/rustc_trait_selection/src/solve/opaques.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fopaques.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -0,0 +1,67 @@\n+use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::solve::{Certainty, Goal, QueryResult};\n+use rustc_middle::traits::Reveal;\n+use rustc_middle::ty;\n+use rustc_middle::ty::util::NotUniqueParam;\n+\n+use super::{EvalCtxt, SolverMode};\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    pub(super) fn normalize_opaque_type(\n+        &mut self,\n+        goal: Goal<'tcx, ty::ProjectionPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = self.tcx();\n+        let opaque_ty = goal.predicate.projection_ty;\n+        let expected = goal.predicate.term.ty().expect(\"no such thing as an opaque const\");\n+\n+        match (goal.param_env.reveal(), self.solver_mode()) {\n+            (Reveal::UserFacing, SolverMode::Normal) => {\n+                let Some(opaque_ty_def_id) = opaque_ty.def_id.as_local() else {\n+                    return Err(NoSolution);\n+                };\n+                let opaque_ty =\n+                    ty::OpaqueTypeKey { def_id: opaque_ty_def_id, substs: opaque_ty.substs };\n+                // FIXME: at some point we should call queries without defining\n+                // new opaque types but having the existing opaque type definitions.\n+                // This will require moving this below \"Prefer opaques registered already\".\n+                if !self.can_define_opaque_ty(opaque_ty_def_id) {\n+                    return Err(NoSolution);\n+                }\n+                // FIXME: This may have issues when the substs contain aliases...\n+                match self.tcx().uses_unique_placeholders_ignoring_regions(opaque_ty.substs) {\n+                    Err(NotUniqueParam::NotParam(param)) if param.is_non_region_infer() => {\n+                        return self.evaluate_added_goals_and_make_canonical_response(\n+                            Certainty::AMBIGUOUS,\n+                        );\n+                    }\n+                    Err(_) => {\n+                        return Err(NoSolution);\n+                    }\n+                    Ok(()) => {}\n+                }\n+                // Prefer opaques registered already.\n+                let matches = self.unify_existing_opaque_tys(goal.param_env, opaque_ty, expected);\n+                if !matches.is_empty() {\n+                    if let Some(response) = self.try_merge_responses(&matches) {\n+                        return Ok(response);\n+                    } else {\n+                        return self.flounder(&matches);\n+                    }\n+                }\n+                // Otherwise, define a new opaque type\n+                self.register_opaque_ty(opaque_ty, expected, goal.param_env)?;\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }\n+            (Reveal::UserFacing, SolverMode::Coherence) => {\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n+            }\n+            (Reveal::All, _) => {\n+                // FIXME: Add an assertion that opaque type storage is empty.\n+                let actual = tcx.type_of(opaque_ty.def_id).subst(tcx, opaque_ty.substs);\n+                self.eq(goal.param_env, expected, actual)?;\n+                self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+            }\n+        }\n+    }\n+}"}, {"sha": "7d7dfa2c8377637c1fe4b757383fd62dfd86bab5", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -22,19 +22,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        // To only compute normalization once for each projection we only\n-        // normalize if the expected term is an unconstrained inference variable.\n-        //\n-        // E.g. for `<T as Trait>::Assoc == u32` we recursively compute the goal\n-        // `exists<U> <T as Trait>::Assoc == U` and then take the resulting type for\n-        // `U` and equate it with `u32`. This means that we don't need a separate\n-        // projection cache in the solver.\n-        if self.term_is_fully_unconstrained(goal) {\n-            let candidates = self.assemble_and_evaluate_candidates(goal);\n-            self.merge_candidates(candidates)\n-        } else {\n-            self.set_normalizes_to_hack_goal(goal);\n-            self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        match goal.predicate.projection_ty.kind(self.tcx()) {\n+            ty::AliasKind::Projection => {\n+                // To only compute normalization once for each projection we only\n+                // normalize if the expected term is an unconstrained inference variable.\n+                //\n+                // E.g. for `<T as Trait>::Assoc == u32` we recursively compute the goal\n+                // `exists<U> <T as Trait>::Assoc == U` and then take the resulting type for\n+                // `U` and equate it with `u32`. This means that we don't need a separate\n+                // projection cache in the solver.\n+                if self.term_is_fully_unconstrained(goal) {\n+                    let candidates = self.assemble_and_evaluate_candidates(goal);\n+                    self.merge_candidates(candidates)\n+                } else {\n+                    self.set_normalizes_to_hack_goal(goal);\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n+            }\n+            ty::AliasKind::Opaque => self.normalize_opaque_type(goal),\n+            ty::AliasKind::Inherent => bug!(\"IATs not supported here yet\"),\n         }\n     }\n }"}, {"sha": "56f126e91572f5df39d08c822731706d3967af74", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/cache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fcache.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -11,7 +11,7 @@\n use super::StackDepth;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_index::IndexVec;\n-use rustc_middle::traits::solve::{CanonicalGoal, QueryResult};\n+use rustc_middle::traits::solve::{CanonicalInput, QueryResult};\n \n rustc_index::newtype_index! {\n     pub struct EntryIndex {}\n@@ -34,15 +34,15 @@ pub(super) struct ProvisionalEntry<'tcx> {\n \n     // The goal for this entry. Should always be equal to the corresponding goal\n     // in the lookup table.\n-    pub(super) goal: CanonicalGoal<'tcx>,\n+    pub(super) input: CanonicalInput<'tcx>,\n }\n \n pub(super) struct ProvisionalCache<'tcx> {\n     pub(super) entries: IndexVec<EntryIndex, ProvisionalEntry<'tcx>>,\n     // FIXME: This is only used to quickly check whether a given goal\n     // is in the cache. We should experiment with using something like\n     // `SsoHashSet` here because in most cases there are only a few entries.\n-    pub(super) lookup_table: FxHashMap<CanonicalGoal<'tcx>, EntryIndex>,\n+    pub(super) lookup_table: FxHashMap<CanonicalInput<'tcx>, EntryIndex>,\n }\n \n impl<'tcx> ProvisionalCache<'tcx> {"}, {"sha": "19e4b23009a79256c4ef2ee96799124e259ca028", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -8,7 +8,7 @@ use cache::ProvisionalCache;\n use overflow::OverflowData;\n use rustc_index::IndexVec;\n use rustc_middle::dep_graph::DepKind;\n-use rustc_middle::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n+use rustc_middle::traits::solve::{CanonicalInput, Certainty, MaybeCause, QueryResult};\n use rustc_middle::ty::TyCtxt;\n use std::{collections::hash_map::Entry, mem};\n \n@@ -19,7 +19,7 @@ rustc_index::newtype_index! {\n }\n \n struct StackElem<'tcx> {\n-    goal: CanonicalGoal<'tcx>,\n+    input: CanonicalInput<'tcx>,\n     has_been_used: bool,\n }\n \n@@ -77,7 +77,7 @@ impl<'tcx> SearchGraph<'tcx> {\n             }\n \n             // ...or it depends on a goal with a lower depth.\n-            let current_goal = self.stack[stack_depth].goal;\n+            let current_goal = self.stack[stack_depth].input;\n             let entry_index = self.provisional_cache.lookup_table[&current_goal];\n             self.provisional_cache.entries[entry_index].depth != stack_depth\n         } else {\n@@ -92,20 +92,20 @@ impl<'tcx> SearchGraph<'tcx> {\n     fn try_push_stack(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        goal: CanonicalGoal<'tcx>,\n+        input: CanonicalInput<'tcx>,\n     ) -> Result<(), QueryResult<'tcx>> {\n         // Look at the provisional cache to check for cycles.\n         let cache = &mut self.provisional_cache;\n-        match cache.lookup_table.entry(goal) {\n+        match cache.lookup_table.entry(input) {\n             // No entry, simply push this goal on the stack after dealing with overflow.\n             Entry::Vacant(v) => {\n                 if self.overflow_data.has_overflow(self.stack.len()) {\n-                    return Err(self.deal_with_overflow(tcx, goal));\n+                    return Err(self.deal_with_overflow(tcx, input));\n                 }\n \n-                let depth = self.stack.push(StackElem { goal, has_been_used: false });\n-                let response = super::response_no_constraints(tcx, goal, Certainty::Yes);\n-                let entry_index = cache.entries.push(ProvisionalEntry { response, depth, goal });\n+                let depth = self.stack.push(StackElem { input, has_been_used: false });\n+                let response = super::response_no_constraints(tcx, input, Certainty::Yes);\n+                let entry_index = cache.entries.push(ProvisionalEntry { response, depth, input });\n                 v.insert(entry_index);\n                 Ok(())\n             }\n@@ -135,13 +135,13 @@ impl<'tcx> SearchGraph<'tcx> {\n                 // the stack is enough.\n                 if self.stack.raw[stack_depth.index()..]\n                     .iter()\n-                    .all(|g| g.goal.value.predicate.is_coinductive(tcx))\n+                    .all(|g| g.input.value.goal.predicate.is_coinductive(tcx))\n                 {\n                     Err(cache.provisional_result(entry_index))\n                 } else {\n                     Err(super::response_no_constraints(\n                         tcx,\n-                        goal,\n+                        input,\n                         Certainty::Maybe(MaybeCause::Overflow),\n                     ))\n                 }\n@@ -161,18 +161,18 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// updated the provisional cache and we have to recompute the current goal.\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n-    #[instrument(level = \"debug\", skip(self, actual_goal), ret)]\n+    #[instrument(level = \"debug\", skip(self, actual_input), ret)]\n     fn try_finalize_goal(\n         &mut self,\n-        actual_goal: CanonicalGoal<'tcx>,\n+        actual_input: CanonicalInput<'tcx>,\n         response: QueryResult<'tcx>,\n     ) -> bool {\n         let stack_elem = self.stack.pop().unwrap();\n-        let StackElem { goal, has_been_used } = stack_elem;\n-        assert_eq!(goal, actual_goal);\n+        let StackElem { input, has_been_used } = stack_elem;\n+        assert_eq!(input, actual_input);\n \n         let cache = &mut self.provisional_cache;\n-        let provisional_entry_index = *cache.lookup_table.get(&goal).unwrap();\n+        let provisional_entry_index = *cache.lookup_table.get(&input).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         // We eagerly update the response in the cache here. If we have to reevaluate\n         // this goal we use the new response when hitting a cycle, and we definitely\n@@ -194,7 +194,7 @@ impl<'tcx> SearchGraph<'tcx> {\n             cache.entries.truncate(provisional_entry_index.index() + 1);\n \n             // ...and finally push our goal back on the stack and reevaluate it.\n-            self.stack.push(StackElem { goal, has_been_used: false });\n+            self.stack.push(StackElem { input, has_been_used: false });\n             false\n         } else {\n             true\n@@ -204,17 +204,17 @@ impl<'tcx> SearchGraph<'tcx> {\n     pub(super) fn with_new_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n-        canonical_goal: CanonicalGoal<'tcx>,\n+        canonical_input: CanonicalInput<'tcx>,\n         mut loop_body: impl FnMut(&mut Self) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if self.should_use_global_cache() {\n-            if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_goal, tcx) {\n-                debug!(?canonical_goal, ?result, \"cache hit\");\n+            if let Some(result) = tcx.new_solver_evaluation_cache.get(&canonical_input, tcx) {\n+                debug!(?canonical_input, ?result, \"cache hit\");\n                 return result;\n             }\n         }\n \n-        match self.try_push_stack(tcx, canonical_goal) {\n+        match self.try_push_stack(tcx, canonical_input) {\n             Ok(()) => {}\n             // Our goal is already on the stack, eager return.\n             Err(response) => return response,\n@@ -226,19 +226,19 @@ impl<'tcx> SearchGraph<'tcx> {\n         let (result, dep_node) = tcx.dep_graph.with_anon_task(tcx, DepKind::TraitSelect, || {\n             self.repeat_while_none(\n                 |this| {\n-                    let result = this.deal_with_overflow(tcx, canonical_goal);\n+                    let result = this.deal_with_overflow(tcx, canonical_input);\n                     let _ = this.stack.pop().unwrap();\n                     result\n                 },\n                 |this| {\n                     let result = loop_body(this);\n-                    this.try_finalize_goal(canonical_goal, result).then(|| result)\n+                    this.try_finalize_goal(canonical_input, result).then(|| result)\n                 },\n             )\n         });\n \n         let cache = &mut self.provisional_cache;\n-        let provisional_entry_index = *cache.lookup_table.get(&canonical_goal).unwrap();\n+        let provisional_entry_index = *cache.lookup_table.get(&canonical_input).unwrap();\n         let provisional_entry = &mut cache.entries[provisional_entry_index];\n         let depth = provisional_entry.depth;\n \n@@ -254,13 +254,13 @@ impl<'tcx> SearchGraph<'tcx> {\n             // cycle participants without moving them to the global cache.\n             let other_cycle_participants = provisional_entry_index.index() + 1;\n             for (i, entry) in cache.entries.drain_enumerated(other_cycle_participants..) {\n-                let actual_index = cache.lookup_table.remove(&entry.goal);\n+                let actual_index = cache.lookup_table.remove(&entry.input);\n                 debug_assert_eq!(Some(i), actual_index);\n                 debug_assert!(entry.depth == depth);\n             }\n \n             let current_goal = cache.entries.pop().unwrap();\n-            let actual_index = cache.lookup_table.remove(&current_goal.goal);\n+            let actual_index = cache.lookup_table.remove(&current_goal.input);\n             debug_assert_eq!(Some(provisional_entry_index), actual_index);\n             debug_assert!(current_goal.depth == depth);\n \n@@ -274,7 +274,7 @@ impl<'tcx> SearchGraph<'tcx> {\n             let can_cache = !self.overflow_data.did_overflow() || self.stack.is_empty();\n             if self.should_use_global_cache() && can_cache {\n                 tcx.new_solver_evaluation_cache.insert(\n-                    current_goal.goal,\n+                    current_goal.input,\n                     dep_node,\n                     current_goal.response,\n                 );"}, {"sha": "f722f281314e6224162e0af939bddda27e44abcf", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -177,14 +177,18 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             return Err(NoSolution);\n         }\n \n-        if goal.predicate.self_ty().has_non_region_infer() {\n+        // The regions of a type don't affect the size of the type\n+        let tcx = ecx.tcx();\n+        // We should erase regions from both the param-env and type, since both\n+        // may have infer regions. Specifically, after canonicalizing and instantiating,\n+        // early bound regions turn into region vars in both the new and old solver.\n+        let key = tcx.erase_regions(goal.param_env.and(goal.predicate.self_ty()));\n+        // But if there are inference variables, we have to wait until it's resolved.\n+        if key.has_non_region_infer() {\n             return ecx.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n         }\n \n-        let tcx = ecx.tcx();\n-        let self_ty = tcx.erase_regions(goal.predicate.self_ty());\n-\n-        if let Ok(layout) = tcx.layout_of(goal.param_env.and(self_ty))\n+        if let Ok(layout) = tcx.layout_of(key)\n             && layout.layout.is_pointer_like(&tcx.data_layout)\n         {\n             // FIXME: We could make this faster by making a no-constraints response\n@@ -354,7 +358,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     // Can only unsize to an object-safe type\n                     if data\n                         .principal_def_id()\n-                        .map_or(false, |def_id| !tcx.check_is_object_safe(def_id))\n+                        .is_some_and(|def_id| !tcx.check_is_object_safe(def_id))\n                     {\n                         return Err(NoSolution);\n                     }"}, {"sha": "62d2aad5277f6ba75d057303841efb34561fc2ad", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -834,8 +834,10 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 | ty::PredicateKind::Subtype(..)\n                 // FIXME(generic_const_exprs): you can absolutely add this as a where clauses\n                 | ty::PredicateKind::ConstEvaluatable(..)\n-                | ty::PredicateKind::Coerce(..)\n-                | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n+                | ty::PredicateKind::Coerce(..) => {}\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n+                    bug!(\"predicate should only exist in the environment: {bound_predicate:?}\")\n+                }\n                 ty::PredicateKind::Ambiguous => return false,\n             };\n         }"}, {"sha": "e8c5a8fab2a37d97e66e5d4a0376f5bf861368e3", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -17,9 +17,10 @@ use crate::traits::{\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n-use rustc_infer::infer::{DefineOpaqueTypes, DefiningAnchor, InferCtxt, TyCtxtInferExt};\n+use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, TyCtxtInferExt};\n use rustc_infer::traits::util;\n use rustc_middle::traits::specialization_graph::OverlapMode;\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::visit::{TypeVisitable, TypeVisitableExt};\n use rustc_middle::ty::{self, ImplSubject, Ty, TyCtxt, TypeVisitor};\n@@ -706,7 +707,7 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for OrphanChecker<'tcx> {\n             }\n             ty::Dynamic(tt, ..) => {\n                 let principal = tt.principal().map(|p| p.def_id());\n-                if principal.map_or(false, |p| self.def_id_is_local(p)) {\n+                if principal.is_some_and(|p| self.def_id_is_local(p)) {\n                     ControlFlow::Break(OrphanCheckEarlyExit::LocalTy(ty))\n                 } else {\n                     self.found_non_local_ty(ty)"}, {"sha": "2c5ffd664fe1de46269a8afd006d48c94c255a6a", "filename": "compiler/rustc_trait_selection/src/traits/engine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fengine.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -14,11 +14,11 @@ use rustc_infer::infer::canonical::{\n };\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{DefineOpaqueTypes, InferCtxt, InferOk};\n-use rustc_infer::traits::query::Fallible;\n use rustc_infer::traits::{\n     FulfillmentError, Obligation, ObligationCause, PredicateObligation, TraitEngineExt as _,\n };\n use rustc_middle::arena::ArenaAllocatable;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::ToPredicate;\n use rustc_middle::ty::TypeFoldable;\n@@ -235,7 +235,7 @@ impl<'a, 'tcx> ObligationCtxt<'a, 'tcx> {\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, T>>\n+    ) -> Result<CanonicalQueryResponse<'tcx, T>, NoSolution>\n     where\n         T: Debug + TypeFoldable<TyCtxt<'tcx>>,\n         Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable<'tcx>,"}, {"sha": "a10ececbb1ea7e972f3577ea411565bc2ad26800", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -437,7 +437,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     // 1) strictly implied by another error.\n                     // 2) implied by an error with a smaller index.\n                     for error2 in error_set {\n-                        if error2.index.map_or(false, |index2| is_suppressed[index2]) {\n+                        if error2.index.is_some_and(|index2| is_suppressed[index2]) {\n                             // Avoid errors being suppressed by already-suppressed\n                             // errors, to prevent all errors from being suppressed\n                             // at once.\n@@ -885,7 +885,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                             return;\n                         }\n \n-                        if self.suggest_impl_trait(&mut err, span, &obligation, trait_predicate) {\n+                        if self.suggest_impl_trait(&mut err, &obligation, trait_predicate) {\n                             err.emit();\n                             return;\n                         }"}, {"sha": "82bad96ea42db40654fcbd5a44b84e469873a003", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 50, "deletions": 231, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -30,9 +30,9 @@ use rustc_middle::hir::map;\n use rustc_middle::ty::error::TypeError::{self, Sorts};\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind,\n-    GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, InternalSubsts,\n-    IsSuggestable, ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder,\n-    TypeSuperFoldable, TypeVisitableExt, TypeckResults,\n+    GeneratorDiagnosticData, GeneratorInteriorTypeCause, InferTy, InternalSubsts, IsSuggestable,\n+    ToPredicate, Ty, TyCtxt, TypeAndMut, TypeFoldable, TypeFolder, TypeSuperFoldable,\n+    TypeVisitableExt, TypeckResults,\n };\n use rustc_span::def_id::LocalDefId;\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -261,7 +261,6 @@ pub trait TypeErrCtxtExt<'tcx> {\n     fn suggest_impl_trait(\n         &self,\n         err: &mut Diagnostic,\n-        span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n@@ -421,7 +420,7 @@ fn suggest_restriction<'tcx>(\n ) {\n     if hir_generics.where_clause_span.from_expansion()\n         || hir_generics.where_clause_span.desugaring_kind().is_some()\n-        || projection.map_or(false, |projection| tcx.opt_rpitit_info(projection.def_id).is_some())\n+        || projection.is_some_and(|projection| tcx.opt_rpitit_info(projection.def_id).is_some())\n     {\n         return;\n     }\n@@ -1792,215 +1791,66 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n     fn suggest_impl_trait(\n         &self,\n         err: &mut Diagnostic,\n-        span: Span,\n         obligation: &PredicateObligation<'tcx>,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n-        match obligation.cause.code().peel_derives() {\n-            // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n-            ObligationCauseCode::SizedReturnType => {}\n-            _ => return false,\n-        }\n-\n-        let hir = self.tcx.hir();\n-        let fn_hir_id = hir.local_def_id_to_hir_id(obligation.cause.body_id);\n-        let node = hir.find_by_def_id(obligation.cause.body_id);\n-        let Some(hir::Node::Item(hir::Item {\n-            kind: hir::ItemKind::Fn(sig, _, body_id),\n-            ..\n-        })) = node\n-        else {\n+        let ObligationCauseCode::SizedReturnType = obligation.cause.code() else {\n             return false;\n         };\n-        let body = hir.body(*body_id);\n-        let trait_pred = self.resolve_vars_if_possible(trait_pred);\n-        let ty = trait_pred.skip_binder().self_ty();\n-        let is_object_safe = match ty.kind() {\n-            ty::Dynamic(predicates, _, ty::Dyn) => {\n-                // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n-                predicates\n-                    .principal_def_id()\n-                    .map_or(true, |def_id| self.tcx.check_is_object_safe(def_id))\n-            }\n-            // We only want to suggest `impl Trait` to `dyn Trait`s.\n-            // For example, `fn foo() -> str` needs to be filtered out.\n-            _ => return false,\n-        };\n-\n-        let hir::FnRetTy::Return(ret_ty) = sig.decl.output else {\n+        let ty::Dynamic(_, _, ty::Dyn) = trait_pred.self_ty().skip_binder().kind() else {\n             return false;\n         };\n \n-        // Use `TypeVisitor` instead of the output type directly to find the span of `ty` for\n-        // cases like `fn foo() -> (dyn Trait, i32) {}`.\n-        // Recursively look for `TraitObject` types and if there's only one, use that span to\n-        // suggest `impl Trait`.\n-\n-        // Visit to make sure there's a single `return` type to suggest `impl Trait`,\n-        // otherwise suggest using `Box<dyn Trait>` or an enum.\n-        let mut visitor = ReturnsVisitor::default();\n-        visitor.visit_body(&body);\n-\n-        let typeck_results = self.typeck_results.as_ref().unwrap();\n-        let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id).copied() else { return false; };\n-\n-        let ret_types = visitor\n-            .returns\n-            .iter()\n-            .filter_map(|expr| Some((expr.span, typeck_results.node_type_opt(expr.hir_id)?)))\n-            .map(|(expr_span, ty)| (expr_span, self.resolve_vars_if_possible(ty)));\n-        let (last_ty, all_returns_have_same_type, only_never_return) = ret_types.clone().fold(\n-            (None, true, true),\n-            |(last_ty, mut same, only_never_return): (std::option::Option<Ty<'_>>, bool, bool),\n-             (_, ty)| {\n-                let ty = self.resolve_vars_if_possible(ty);\n-                same &=\n-                    !matches!(ty.kind(), ty::Error(_))\n-                        && last_ty.map_or(true, |last_ty| {\n-                            // FIXME: ideally we would use `can_coerce` here instead, but `typeck` comes\n-                            // *after* in the dependency graph.\n-                            match (ty.kind(), last_ty.kind()) {\n-                                (Infer(InferTy::IntVar(_)), Infer(InferTy::IntVar(_)))\n-                                | (Infer(InferTy::FloatVar(_)), Infer(InferTy::FloatVar(_)))\n-                                | (Infer(InferTy::FreshIntTy(_)), Infer(InferTy::FreshIntTy(_)))\n-                                | (\n-                                    Infer(InferTy::FreshFloatTy(_)),\n-                                    Infer(InferTy::FreshFloatTy(_)),\n-                                ) => true,\n-                                _ => ty == last_ty,\n-                            }\n-                        });\n-                (Some(ty), same, only_never_return && matches!(ty.kind(), ty::Never))\n-            },\n-        );\n-        let mut spans_and_needs_box = vec![];\n-\n-        match liberated_sig.output().kind() {\n-            ty::Dynamic(predicates, _, ty::Dyn) => {\n-                let cause = ObligationCause::misc(ret_ty.span, obligation.cause.body_id);\n-                let param_env = ty::ParamEnv::empty();\n-\n-                if !only_never_return {\n-                    for (expr_span, return_ty) in ret_types {\n-                        let self_ty_satisfies_dyn_predicates = |self_ty| {\n-                            predicates.iter().all(|predicate| {\n-                                let pred = predicate.with_self_ty(self.tcx, self_ty);\n-                                let obl = Obligation::new(self.tcx, cause.clone(), param_env, pred);\n-                                self.predicate_may_hold(&obl)\n-                            })\n-                        };\n-\n-                        if let ty::Adt(def, substs) = return_ty.kind()\n-                            && def.is_box()\n-                            && self_ty_satisfies_dyn_predicates(substs.type_at(0))\n-                        {\n-                            spans_and_needs_box.push((expr_span, false));\n-                        } else if self_ty_satisfies_dyn_predicates(return_ty) {\n-                            spans_and_needs_box.push((expr_span, true));\n-                        } else {\n-                            return false;\n-                        }\n-                    }\n-                }\n-            }\n-            _ => return false,\n-        };\n-\n-        let sm = self.tcx.sess.source_map();\n-        if !ret_ty.span.overlaps(span) {\n-            return false;\n-        }\n-        let snippet = if let hir::TyKind::TraitObject(..) = ret_ty.kind {\n-            if let Ok(snippet) = sm.span_to_snippet(ret_ty.span) {\n-                snippet\n-            } else {\n-                return false;\n-            }\n-        } else {\n-            // Substitute the type, so we can print a fixup given `type Alias = dyn Trait`\n-            let name = liberated_sig.output().to_string();\n-            let name =\n-                name.strip_prefix('(').and_then(|name| name.strip_suffix(')')).unwrap_or(&name);\n-            if !name.starts_with(\"dyn \") {\n-                return false;\n-            }\n-            name.to_owned()\n-        };\n-\n         err.code(error_code!(E0746));\n         err.set_primary_message(\"return type cannot have an unboxed trait object\");\n         err.children.clear();\n-        let impl_trait_msg = \"for information on `impl Trait`, see \\\n-            <https://doc.rust-lang.org/book/ch10-02-traits.html\\\n-            #returning-types-that-implement-traits>\";\n-        let trait_obj_msg = \"for information on trait objects, see \\\n-            <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n-            #using-trait-objects-that-allow-for-values-of-different-types>\";\n-\n-        let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n-        let trait_obj = if has_dyn { &snippet[4..] } else { &snippet };\n-        if only_never_return {\n-            // No return paths, probably using `panic!()` or similar.\n-            // Suggest `-> impl Trait`, and if `Trait` is object safe, `-> Box<dyn Trait>`.\n-            suggest_trait_object_return_type_alternatives(\n-                err,\n-                ret_ty.span,\n-                trait_obj,\n-                is_object_safe,\n-            );\n-        } else if let (Some(last_ty), true) = (last_ty, all_returns_have_same_type) {\n-            // Suggest `-> impl Trait`.\n+\n+        let span = obligation.cause.span;\n+        if let Ok(snip) = self.tcx.sess.source_map().span_to_snippet(span)\n+            && snip.starts_with(\"dyn \")\n+        {\n             err.span_suggestion(\n-                ret_ty.span,\n-                format!(\n-                    \"use `impl {1}` as the return type, as all return paths are of type `{}`, \\\n-                     which implements `{1}`\",\n-                    last_ty, trait_obj,\n-                ),\n-                format!(\"impl {}\", trait_obj),\n-                Applicability::MachineApplicable,\n+                span.with_hi(span.lo() + BytePos(4)),\n+                \"return an `impl Trait` instead of a `dyn Trait`, \\\n+                if all returned values are the same type\",\n+                \"impl \",\n+                Applicability::MaybeIncorrect,\n             );\n-            err.note(impl_trait_msg);\n-        } else {\n-            if is_object_safe {\n-                // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n-                err.multipart_suggestion(\n-                    \"return a boxed trait object instead\",\n-                    vec![\n-                        (ret_ty.span.shrink_to_lo(), \"Box<\".to_string()),\n-                        (span.shrink_to_hi(), \">\".to_string()),\n-                    ],\n-                    Applicability::MaybeIncorrect,\n-                );\n-                for (span, needs_box) in spans_and_needs_box {\n-                    if needs_box {\n-                        err.multipart_suggestion(\n-                            \"... and box this value\",\n-                            vec![\n-                                (span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (span.shrink_to_hi(), \")\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n+        }\n+\n+        let body = self.tcx.hir().body(self.tcx.hir().body_owned_by(obligation.cause.body_id));\n+\n+        let mut visitor = ReturnsVisitor::default();\n+        visitor.visit_body(&body);\n+\n+        let mut sugg =\n+            vec![(span.shrink_to_lo(), \"Box<\".to_string()), (span.shrink_to_hi(), \">\".to_string())];\n+        sugg.extend(visitor.returns.into_iter().flat_map(|expr| {\n+            let span = expr.span.find_ancestor_in_same_ctxt(obligation.cause.span).unwrap_or(expr.span);\n+            if !span.can_be_used_for_suggestions() {\n+                vec![]\n+            } else if let hir::ExprKind::Call(path, ..) = expr.kind\n+                && let hir::ExprKind::Path(hir::QPath::TypeRelative(ty, method)) = path.kind\n+                && method.ident.name == sym::new\n+                && let hir::TyKind::Path(hir::QPath::Resolved(.., box_path)) = ty.kind\n+                && box_path.res.opt_def_id().is_some_and(|def_id| Some(def_id) == self.tcx.lang_items().owned_box())\n+            {\n+                // Don't box `Box::new`\n+                vec![]\n             } else {\n-                // This is currently not possible to trigger because E0038 takes precedence, but\n-                // leave it in for completeness in case anything changes in an earlier stage.\n-                err.note(format!(\n-                    \"if trait `{}` were object-safe, you could return a trait object\",\n-                    trait_obj,\n-                ));\n+                vec![\n+                    (span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                    (span.shrink_to_hi(), \")\".to_string()),\n+                ]\n             }\n-            err.note(trait_obj_msg);\n-            err.note(format!(\n-                \"if all the returned values were of the same type you could use `impl {}` as the \\\n-                 return type\",\n-                trait_obj,\n-            ));\n-            err.note(impl_trait_msg);\n-            err.note(\"you can create a new `enum` with a variant for each returned type\");\n-        }\n+        }));\n+\n+        err.multipart_suggestion(\n+            \"box the return type, and wrap all of the returned values in `Box::new`\",\n+            sugg,\n+            Applicability::MaybeIncorrect,\n+        );\n+\n         true\n     }\n \n@@ -3086,7 +2936,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                                     \"note_obligation_cause_code: check for async fn\"\n                                 );\n                                 if is_future\n-                                    && obligated_types.last().map_or(false, |ty| match ty.kind() {\n+                                    && obligated_types.last().is_some_and(|ty| match ty.kind() {\n                                         ty::Generator(last_def_id, ..) => {\n                                             tcx.generator_is_async(*last_def_id)\n                                         }\n@@ -4139,37 +3989,6 @@ impl NextTypeParamName for &[hir::GenericParam<'_>] {\n     }\n }\n \n-fn suggest_trait_object_return_type_alternatives(\n-    err: &mut Diagnostic,\n-    ret_ty: Span,\n-    trait_obj: &str,\n-    is_object_safe: bool,\n-) {\n-    err.span_suggestion(\n-        ret_ty,\n-        format!(\n-            \"use `impl {}` as the return type if all return paths have the same type but you \\\n-                want to expose only the trait in the signature\",\n-            trait_obj,\n-        ),\n-        format!(\"impl {}\", trait_obj),\n-        Applicability::MaybeIncorrect,\n-    );\n-    if is_object_safe {\n-        err.multipart_suggestion(\n-            format!(\n-                \"use a boxed trait object if all return paths implement trait `{}`\",\n-                trait_obj,\n-            ),\n-            vec![\n-                (ret_ty.shrink_to_lo(), \"Box<\".to_string()),\n-                (ret_ty.shrink_to_hi(), \">\".to_string()),\n-            ],\n-            Applicability::MaybeIncorrect,\n-        );\n-    }\n-}\n-\n /// Collect the spans that we see the generic param `param_did`\n struct ReplaceImplTraitVisitor<'a> {\n     ty_spans: &'a mut Vec<Span>,"}, {"sha": "f265230ff772d59004b848010df780dc085471db", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -17,6 +17,7 @@ pub mod query;\n mod select;\n mod specialize;\n mod structural_match;\n+mod structural_normalize;\n mod util;\n mod vtable;\n pub mod wf;\n@@ -62,6 +63,7 @@ pub use self::specialize::{\n pub use self::structural_match::{\n     search_for_adt_const_param_violation, search_for_structural_match_violation,\n };\n+pub use self::structural_normalize::StructurallyNormalizeExt;\n pub use self::util::elaborate;\n pub use self::util::{expand_trait_aliases, TraitAliasExpander};\n pub use self::util::{get_vtable_index_of_object_method, impl_item_is_final, upcast_choices};"}, {"sha": "0e797a1cb60d58189f5753ec3c10baf8867e4d25", "filename": "compiler/rustc_trait_selection/src/traits/outlives_bounds.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Foutlives_bounds.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,8 +1,8 @@\n use crate::infer::InferCtxt;\n use crate::traits::query::type_op::{self, TypeOp, TypeOpOutput};\n-use crate::traits::query::NoSolution;\n use crate::traits::{ObligationCause, ObligationCtxt};\n use rustc_data_structures::fx::FxIndexSet;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n use rustc_middle::ty::{self, ParamEnv, Ty, TypeFolder, TypeVisitableExt};\n use rustc_span::def_id::LocalDefId;\n@@ -69,16 +69,12 @@ impl<'a, 'tcx: 'a> InferCtxtExt<'a, 'tcx> for InferCtxt<'tcx> {\n         }\n \n         let span = self.tcx.def_span(body_id);\n-        let result = param_env\n+        let result: Result<_, ErrorGuaranteed> = param_env\n             .and(type_op::implied_outlives_bounds::ImpliedOutlivesBounds { ty })\n-            .fully_perform(self);\n+            .fully_perform(self, span);\n         let result = match result {\n             Ok(r) => r,\n-            Err(NoSolution) => {\n-                self.tcx.sess.delay_span_bug(\n-                    span,\n-                    \"implied_outlives_bounds failed to solve all obligations\",\n-                );\n+            Err(_) => {\n                 return vec![];\n             }\n         };"}, {"sha": "c61f5454ec52e4f31f09ba865cd7ae50d909e391", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,5 +1,5 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n-use crate::traits::query::Fallible;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::AscribeUserType;\n@@ -17,7 +17,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, ()>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_ascribe_user_type(canonicalized)\n     }\n }"}, {"sha": "6d8d2103f39040a9a68c037b42a57e6a603af4e6", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/custom.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fcustom.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,32 +1,32 @@\n use crate::infer::canonical::query_response;\n-use crate::infer::{InferCtxt, InferOk};\n+use crate::infer::InferCtxt;\n use crate::traits::query::type_op::TypeOpOutput;\n-use crate::traits::query::Fallible;\n use crate::traits::ObligationCtxt;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_infer::infer::region_constraints::RegionConstraintData;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_span::source_map::DUMMY_SP;\n+use rustc_span::Span;\n \n use std::fmt;\n \n-pub struct CustomTypeOp<F, G> {\n+pub struct CustomTypeOp<F> {\n     closure: F,\n-    description: G,\n+    description: &'static str,\n }\n \n-impl<F, G> CustomTypeOp<F, G> {\n-    pub fn new<'tcx, R>(closure: F, description: G) -> Self\n+impl<F> CustomTypeOp<F> {\n+    pub fn new<'tcx, R>(closure: F, description: &'static str) -> Self\n     where\n-        F: FnOnce(&InferCtxt<'tcx>) -> Fallible<InferOk<'tcx, R>>,\n-        G: Fn() -> String,\n+        F: FnOnce(&ObligationCtxt<'_, 'tcx>) -> Result<R, NoSolution>,\n     {\n         CustomTypeOp { closure, description }\n     }\n }\n \n-impl<'tcx, F, R: fmt::Debug, G> super::TypeOp<'tcx> for CustomTypeOp<F, G>\n+impl<'tcx, F, R: fmt::Debug> super::TypeOp<'tcx> for CustomTypeOp<F>\n where\n-    F: for<'a, 'cx> FnOnce(&'a InferCtxt<'tcx>) -> Fallible<InferOk<'tcx, R>>,\n-    G: Fn() -> String,\n+    F: FnOnce(&ObligationCtxt<'_, 'tcx>) -> Result<R, NoSolution>,\n {\n     type Output = R;\n     /// We can't do any custom error reporting for `CustomTypeOp`, so\n@@ -36,30 +36,33 @@ where\n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n     /// (they will be given over to the NLL region solver).\n-    fn fully_perform(self, infcx: &InferCtxt<'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n+    fn fully_perform(\n+        self,\n+        infcx: &InferCtxt<'tcx>,\n+        span: Span,\n+    ) -> Result<TypeOpOutput<'tcx, Self>, ErrorGuaranteed> {\n         if cfg!(debug_assertions) {\n             info!(\"fully_perform({:?})\", self);\n         }\n \n-        Ok(scrape_region_constraints(infcx, || (self.closure)(infcx))?.0)\n+        Ok(scrape_region_constraints(infcx, self.closure, self.description, span)?.0)\n     }\n }\n \n-impl<F, G> fmt::Debug for CustomTypeOp<F, G>\n-where\n-    G: Fn() -> String,\n-{\n+impl<F> fmt::Debug for CustomTypeOp<F> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", (self.description)())\n+        self.description.fmt(f)\n     }\n }\n \n /// Executes `op` and then scrapes out all the \"old style\" region\n /// constraints that result, creating query-region-constraints.\n pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n     infcx: &InferCtxt<'tcx>,\n-    op: impl FnOnce() -> Fallible<InferOk<'tcx, R>>,\n-) -> Fallible<(TypeOpOutput<'tcx, Op>, RegionConstraintData<'tcx>)> {\n+    op: impl FnOnce(&ObligationCtxt<'_, 'tcx>) -> Result<R, NoSolution>,\n+    name: &'static str,\n+    span: Span,\n+) -> Result<(TypeOpOutput<'tcx, Op>, RegionConstraintData<'tcx>), ErrorGuaranteed> {\n     // During NLL, we expect that nobody will register region\n     // obligations **except** as part of a custom type op (and, at the\n     // end of each custom type op, we scrape out the region\n@@ -72,16 +75,21 @@ pub fn scrape_region_constraints<'tcx, Op: super::TypeOp<'tcx, Output = R>, R>(\n         pre_obligations,\n     );\n \n-    let InferOk { value, obligations } = infcx.commit_if_ok(|_| op())?;\n-    let ocx = ObligationCtxt::new(infcx);\n-    ocx.register_obligations(obligations);\n-    let errors = ocx.select_all_or_error();\n-    if !errors.is_empty() {\n-        infcx.tcx.sess.diagnostic().delay_span_bug(\n-            DUMMY_SP,\n-            format!(\"errors selecting obligation during MIR typeck: {:?}\", errors),\n-        );\n-    }\n+    let value = infcx.commit_if_ok(|_| {\n+        let ocx = ObligationCtxt::new_in_snapshot(infcx);\n+        let value = op(&ocx).map_err(|_| {\n+            infcx.tcx.sess.delay_span_bug(span, format!(\"error performing operation: {name}\"))\n+        })?;\n+        let errors = ocx.select_all_or_error();\n+        if errors.is_empty() {\n+            Ok(value)\n+        } else {\n+            Err(infcx.tcx.sess.delay_span_bug(\n+                DUMMY_SP,\n+                format!(\"errors selecting obligation during MIR typeck: {:?}\", errors),\n+            ))\n+        }\n+    })?;\n \n     let region_obligations = infcx.take_registered_region_obligations();\n     let region_constraint_data = infcx.take_and_reset_region_constraints();"}, {"sha": "40f8ecfd4ce101b7cf54bfff0e63cbfb7f90d0bd", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,5 +1,5 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n-use crate::traits::query::Fallible;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::Eq;\n@@ -17,7 +17,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Eq<'tcx> {\n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, ()>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_eq(canonicalized)\n     }\n }"}, {"sha": "26f0d554d350851f4d4e432745686c139de829f7", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fimplied_outlives_bounds.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n-use crate::traits::query::Fallible;\n use rustc_infer::traits::query::OutlivesBound;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable, TypeVisitable, Lift)]\n@@ -28,7 +28,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ImpliedOutlivesBounds<'tcx> {\n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, Self::QueryResponse>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, Self::QueryResponse>, NoSolution> {\n         // FIXME this `unchecked_map` is only necessary because the\n         // query is defined as taking a `ParamEnvAnd<Ty>`; it should\n         // take an `ImpliedOutlivesBounds` instead"}, {"sha": "642326598480426e18a6faea247b19b4eb5a56dd", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/mod.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -2,13 +2,14 @@ use crate::infer::canonical::{\n     Canonical, CanonicalQueryResponse, OriginalQueryValues, QueryRegionConstraints,\n };\n use crate::infer::{InferCtxt, InferOk};\n-use crate::traits::query::Fallible;\n use crate::traits::ObligationCause;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_infer::infer::canonical::Certainty;\n-use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::PredicateObligations;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n+use rustc_span::Span;\n use std::fmt;\n \n pub mod ascribe_user_type;\n@@ -32,7 +33,11 @@ pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n     /// Processes the operation and all resulting obligations,\n     /// returning the final result along with any region constraints\n     /// (they will be given over to the NLL region solver).\n-    fn fully_perform(self, infcx: &InferCtxt<'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>>;\n+    fn fully_perform(\n+        self,\n+        infcx: &InferCtxt<'tcx>,\n+        span: Span,\n+    ) -> Result<TypeOpOutput<'tcx, Self>, ErrorGuaranteed>;\n }\n \n /// The output from performing a type op\n@@ -74,18 +79,21 @@ pub trait QueryTypeOp<'tcx>: fmt::Debug + Copy + TypeFoldable<TyCtxt<'tcx>> + 't\n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, Self::QueryResponse>>;\n+    ) -> Result<CanonicalQueryResponse<'tcx, Self::QueryResponse>, NoSolution>;\n \n     fn fully_perform_into(\n         query_key: ParamEnvAnd<'tcx, Self>,\n         infcx: &InferCtxt<'tcx>,\n         output_query_region_constraints: &mut QueryRegionConstraints<'tcx>,\n-    ) -> Fallible<(\n-        Self::QueryResponse,\n-        Option<Canonical<'tcx, ParamEnvAnd<'tcx, Self>>>,\n-        PredicateObligations<'tcx>,\n-        Certainty,\n-    )> {\n+    ) -> Result<\n+        (\n+            Self::QueryResponse,\n+            Option<Canonical<'tcx, ParamEnvAnd<'tcx, Self>>>,\n+            PredicateObligations<'tcx>,\n+            Certainty,\n+        ),\n+        NoSolution,\n+    > {\n         if let Some(result) = QueryTypeOp::try_fast_path(infcx.tcx, &query_key) {\n             return Ok((result, None, vec![], Certainty::Proven));\n         }\n@@ -120,10 +128,16 @@ where\n     type Output = Q::QueryResponse;\n     type ErrorInfo = Canonical<'tcx, ParamEnvAnd<'tcx, Q>>;\n \n-    fn fully_perform(self, infcx: &InferCtxt<'tcx>) -> Fallible<TypeOpOutput<'tcx, Self>> {\n+    fn fully_perform(\n+        self,\n+        infcx: &InferCtxt<'tcx>,\n+        span: Span,\n+    ) -> Result<TypeOpOutput<'tcx, Self>, ErrorGuaranteed> {\n         let mut region_constraints = QueryRegionConstraints::default();\n         let (output, error_info, mut obligations, _) =\n-            Q::fully_perform_into(self, infcx, &mut region_constraints)?;\n+            Q::fully_perform_into(self, infcx, &mut region_constraints).map_err(|_| {\n+                infcx.tcx.sess.delay_span_bug(span, format!(\"error performing {self:?}\"))\n+            })?;\n \n         // Typically, instantiating NLL query results does not\n         // create obligations. However, in some cases there\n@@ -151,7 +165,10 @@ where\n                 }\n             }\n             if !progress {\n-                return Err(NoSolution);\n+                return Err(infcx.tcx.sess.delay_span_bug(\n+                    span,\n+                    format!(\"ambiguity processing {obligations:?} from {self:?}\"),\n+                ));\n             }\n         }\n "}, {"sha": "776c74fdfae4b9c96ac9b3397f72fb59e31c6a5c", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/normalize.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,5 +1,5 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n-use crate::traits::query::Fallible;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt, TypeVisitableExt};\n use std::fmt;\n@@ -19,7 +19,7 @@ where\n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, Self::QueryResponse>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, Self::QueryResponse>, NoSolution> {\n         T::type_op_method(tcx, canonicalized)\n     }\n }\n@@ -28,14 +28,14 @@ pub trait Normalizable<'tcx>: fmt::Debug + TypeFoldable<TyCtxt<'tcx>> + Lift<'tc\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, Self>>;\n+    ) -> Result<CanonicalQueryResponse<'tcx, Self>, NoSolution>;\n }\n \n impl<'tcx> Normalizable<'tcx> for Ty<'tcx> {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, Self>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, Self>, NoSolution> {\n         tcx.type_op_normalize_ty(canonicalized)\n     }\n }\n@@ -44,7 +44,7 @@ impl<'tcx> Normalizable<'tcx> for ty::Predicate<'tcx> {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, Self>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, Self>, NoSolution> {\n         tcx.type_op_normalize_predicate(canonicalized)\n     }\n }\n@@ -53,7 +53,7 @@ impl<'tcx> Normalizable<'tcx> for ty::PolyFnSig<'tcx> {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, Self>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, Self>, NoSolution> {\n         tcx.type_op_normalize_poly_fn_sig(canonicalized)\n     }\n }\n@@ -62,7 +62,7 @@ impl<'tcx> Normalizable<'tcx> for ty::FnSig<'tcx> {\n     fn type_op_method(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Normalize<Self>>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, Self>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, Self>, NoSolution> {\n         tcx.type_op_normalize_fn_sig(canonicalized)\n     }\n }"}, {"sha": "7ce09bbdb7af366ee3acb78aae5718e29a4df847", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/outlives.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Foutlives.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n use crate::traits::query::dropck_outlives::{trivial_dropck_outlives, DropckOutlivesResult};\n-use crate::traits::query::Fallible;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::{ParamEnvAnd, Ty, TyCtxt};\n \n #[derive(Copy, Clone, Debug, HashStable, TypeFoldable, TypeVisitable, Lift)]\n@@ -27,7 +27,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for DropckOutlives<'tcx> {\n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, Self::QueryResponse>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, Self::QueryResponse>, NoSolution> {\n         // Subtle: note that we are not invoking\n         // `infcx.at(...).dropck_outlives(...)` here, but rather the\n         // underlying `dropck_outlives` query. This same underlying"}, {"sha": "7c02f363960d7aca560b7b0f6e1069a03ac5a9a2", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,5 +1,5 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n-use crate::traits::query::Fallible;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::{self, ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::ProvePredicate;\n@@ -33,7 +33,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, ()>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_prove_predicate(canonicalized)\n     }\n }"}, {"sha": "2f2b931afcff4beb461bb075498c29ec5e20e430", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/subtype.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,5 +1,5 @@\n use crate::infer::canonical::{Canonical, CanonicalQueryResponse};\n-use crate::traits::query::Fallible;\n+use rustc_middle::traits::query::NoSolution;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n \n pub use rustc_middle::traits::query::type_op::Subtype;\n@@ -14,7 +14,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for Subtype<'tcx> {\n     fn perform_query(\n         tcx: TyCtxt<'tcx>,\n         canonicalized: Canonical<'tcx, ParamEnvAnd<'tcx, Self>>,\n-    ) -> Fallible<CanonicalQueryResponse<'tcx, ()>> {\n+    ) -> Result<CanonicalQueryResponse<'tcx, ()>, NoSolution> {\n         tcx.type_op_subtype(canonicalized)\n     }\n }"}, {"sha": "8bc82b9f54926b0cf62b145e536f153f749de909", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -967,16 +967,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     ) {\n         // The regions of a type don't affect the size of the type\n         let tcx = self.tcx();\n-        let self_ty =\n-            tcx.erase_regions(tcx.erase_late_bound_regions(obligation.predicate.self_ty()));\n-\n+        let self_ty = tcx.erase_late_bound_regions(obligation.predicate.self_ty());\n+        // We should erase regions from both the param-env and type, since both\n+        // may have infer regions. Specifically, after canonicalizing and instantiating,\n+        // early bound regions turn into region vars in both the new and old solver.\n+        let key = tcx.erase_regions(obligation.param_env.and(self_ty));\n         // But if there are inference variables, we have to wait until it's resolved.\n-        if self_ty.has_non_region_infer() {\n+        if key.has_non_region_infer() {\n             candidates.ambiguous = true;\n             return;\n         }\n \n-        if let Ok(layout) = tcx.layout_of(obligation.param_env.and(self_ty))\n+        if let Ok(layout) = tcx.layout_of(key)\n             && layout.layout.is_pointer_like(&tcx.data_layout)\n         {\n             candidates.vec.push(BuiltinCandidate { has_nested: false });"}, {"sha": "3baf1c97c9f46539d81d803da9dc94cca2bedc22", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1793,12 +1793,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .infcx\n             .at(&obligation.cause, obligation.param_env)\n             .sup(DefineOpaqueTypes::No, obligation.predicate, infer_projection)\n-            .map_or(false, |InferOk { obligations, value: () }| {\n+            .is_ok_and(|InferOk { obligations, value: () }| {\n                 self.evaluate_predicates_recursively(\n                     TraitObligationStackList::empty(&ProvisionalEvaluationCache::default()),\n                     nested_obligations.into_iter().chain(obligations),\n                 )\n-                .map_or(false, |res| res.may_apply())\n+                .is_ok_and(|res| res.may_apply())\n             });\n \n         if is_match {"}, {"sha": "af8dd0da5792a54e9c34931a204140ec9b784fbb", "filename": "compiler/rustc_trait_selection/src/traits/structural_normalize.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_normalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_normalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_normalize.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -0,0 +1,55 @@\n+use rustc_infer::infer::at::At;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::traits::{FulfillmentError, TraitEngine};\n+use rustc_middle::ty::{self, Ty};\n+\n+use crate::traits::{query::evaluate_obligation::InferCtxtExt, NormalizeExt, Obligation};\n+\n+pub trait StructurallyNormalizeExt<'tcx> {\n+    fn structurally_normalize(\n+        &self,\n+        ty: Ty<'tcx>,\n+        fulfill_cx: &mut dyn TraitEngine<'tcx>,\n+    ) -> Result<Ty<'tcx>, Vec<FulfillmentError<'tcx>>>;\n+}\n+\n+impl<'tcx> StructurallyNormalizeExt<'tcx> for At<'_, 'tcx> {\n+    fn structurally_normalize(\n+        &self,\n+        mut ty: Ty<'tcx>,\n+        fulfill_cx: &mut dyn TraitEngine<'tcx>,\n+    ) -> Result<Ty<'tcx>, Vec<FulfillmentError<'tcx>>> {\n+        assert!(!ty.is_ty_var(), \"should have resolved vars before calling\");\n+\n+        if self.infcx.tcx.trait_solver_next() {\n+            while let ty::Alias(ty::Projection, projection_ty) = *ty.kind() {\n+                let new_infer_ty = self.infcx.next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::NormalizeProjectionType,\n+                    span: self.cause.span,\n+                });\n+                let obligation = Obligation::new(\n+                    self.infcx.tcx,\n+                    self.cause.clone(),\n+                    self.param_env,\n+                    ty::Binder::dummy(ty::ProjectionPredicate {\n+                        projection_ty,\n+                        term: new_infer_ty.into(),\n+                    }),\n+                );\n+                if self.infcx.predicate_may_hold(&obligation) {\n+                    fulfill_cx.register_predicate_obligation(self.infcx, obligation);\n+                    let errors = fulfill_cx.select_where_possible(self.infcx);\n+                    if !errors.is_empty() {\n+                        return Err(errors);\n+                    }\n+                    ty = self.infcx.resolve_vars_if_possible(new_infer_ty);\n+                } else {\n+                    break;\n+                }\n+            }\n+            Ok(ty)\n+        } else {\n+            Ok(self.normalize(ty).into_value_registering_obligations(self.infcx, fulfill_cx))\n+        }\n+    }\n+}"}, {"sha": "e447ab94f6408def5d4ea261a26c29d33513f0d4", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -679,7 +679,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             | ty::PredicateKind::ConstEquate(..)\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n-                bug!(\"unexpected predicate {}\", &self)\n+                bug!(\"unexpected predicate {self}\")\n             }\n         };\n         value.map(|value| chalk_ir::Binders::new(binders, value))"}, {"sha": "ddba03b0b12b3444b7436bd20cd8755fa8c4fc21", "filename": "compiler/rustc_traits/src/codegen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -3,9 +3,9 @@\n // seems likely that they should eventually be merged into more\n // general routines.\n \n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::{FulfillmentErrorCode, TraitEngineExt as _};\n-use rustc_middle::traits::CodegenObligationError;\n+use rustc_middle::traits::{CodegenObligationError, DefiningAnchor};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n use rustc_trait_selection::traits::{"}, {"sha": "f5b2753b7973d51e3cdf2a7e52ff323107a67601", "filename": "compiler/rustc_traits/src/evaluate_obligation.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fevaluate_obligation.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,5 +1,6 @@\n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::query::Providers;\n+use rustc_middle::traits::DefiningAnchor;\n use rustc_middle::ty::{ParamEnvAnd, TyCtxt};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_trait_selection::traits::query::CanonicalPredicateGoal;\n@@ -15,6 +16,7 @@ fn evaluate_obligation<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     canonical_goal: CanonicalPredicateGoal<'tcx>,\n ) -> Result<EvaluationResult, OverflowError> {\n+    assert!(!tcx.trait_solver_next());\n     debug!(\"evaluate_obligation(canonical_goal={:#?})\", canonical_goal);\n     // HACK This bubble is required for this tests to pass:\n     // impl-trait/issue99642.rs"}, {"sha": "49cbf9efa749379643d7ab5757e8be40f665d8b1", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::{self, Ty, TyCtxt, TypeVisitableExt};\n use rustc_span::def_id::CRATE_DEF_ID;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_trait_selection::infer::InferCtxtBuilderExt;\n-use rustc_trait_selection::traits::query::{CanonicalTyGoal, Fallible, NoSolution};\n+use rustc_trait_selection::traits::query::{CanonicalTyGoal, NoSolution};\n use rustc_trait_selection::traits::wf;\n use rustc_trait_selection::traits::ObligationCtxt;\n use smallvec::{smallvec, SmallVec};\n@@ -37,7 +37,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n     ocx: &ObligationCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     ty: Ty<'tcx>,\n-) -> Fallible<Vec<OutlivesBound<'tcx>>> {\n+) -> Result<Vec<OutlivesBound<'tcx>>, NoSolution> {\n     let tcx = ocx.infcx.tcx;\n \n     // Sometimes when we ask what it takes for T: WF, we get back that"}, {"sha": "faf985169deff14e6b8e31a199c27cc9959f68ba", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,8 +1,9 @@\n use rustc_hir as hir;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n-use rustc_infer::infer::{DefiningAnchor, TyCtxtInferExt};\n-use rustc_infer::traits::ObligationCauseCode;\n+use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::query::Providers;\n+use rustc_middle::traits::query::NoSolution;\n+use rustc_middle::traits::{DefiningAnchor, ObligationCauseCode};\n use rustc_middle::ty::{self, FnSig, Lift, PolyFnSig, Ty, TyCtxt, TypeFoldable};\n use rustc_middle::ty::{ParamEnvAnd, Predicate};\n use rustc_middle::ty::{UserSelfTy, UserSubsts, UserType};\n@@ -15,7 +16,6 @@ use rustc_trait_selection::traits::query::type_op::eq::Eq;\n use rustc_trait_selection::traits::query::type_op::normalize::Normalize;\n use rustc_trait_selection::traits::query::type_op::prove_predicate::ProvePredicate;\n use rustc_trait_selection::traits::query::type_op::subtype::Subtype;\n-use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n use rustc_trait_selection::traits::{Normalized, Obligation, ObligationCause, ObligationCtxt};\n use std::fmt;\n \n@@ -160,7 +160,7 @@ fn type_op_eq<'tcx>(\n fn type_op_normalize<'tcx, T>(\n     ocx: &ObligationCtxt<'_, 'tcx>,\n     key: ParamEnvAnd<'tcx, Normalize<T>>,\n-) -> Fallible<T>\n+) -> Result<T, NoSolution>\n where\n     T: fmt::Debug + TypeFoldable<TyCtxt<'tcx>> + Lift<'tcx>,\n {"}, {"sha": "c416aa52a24a4823f1d4f84cad8b7e499624086d", "filename": "compiler/rustc_ty_utils/messages.ftl", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ty_utils%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ty_utils%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fmessages.ftl?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -1,65 +1,65 @@\n-ty_utils_needs_drop_overflow = overflow while checking whether `{$query_ty}` requires drop\n+ty_utils_address_and_deref_not_supported = dereferencing or taking the address is not supported in generic constants\n \n-ty_utils_generic_constant_too_complex = overly complex generic constant\n-    .help = consider moving this anonymous constant into a `const` function\n-    .maybe_supported = this operation may be supported in the future\n+ty_utils_adt_not_supported = struct/enum construction is not supported in generic constants\n \n-ty_utils_borrow_not_supported = borrowing is not supported in generic constants\n+ty_utils_array_not_supported = array construction is not supported in generic constants\n \n-ty_utils_address_and_deref_not_supported = dereferencing or taking the address is not supported in generic constants\n+ty_utils_assign_not_supported = assignment is not supported in generic constants\n \n-ty_utils_array_not_supported = array construction is not supported in generic constants\n+ty_utils_binary_not_supported = unsupported binary operation in generic constants\n \n ty_utils_block_not_supported = blocks are not supported in generic constants\n \n-ty_utils_never_to_any_not_supported = coercing the `never` type is not supported in generic constants\n-\n-ty_utils_tuple_not_supported = tuple construction is not supported in generic constants\n+ty_utils_borrow_not_supported = borrowing is not supported in generic constants\n \n-ty_utils_index_not_supported = indexing is not supported in generic constants\n+ty_utils_box_not_supported = allocations are not allowed in generic constants\n \n-ty_utils_field_not_supported = field access is not supported in generic constants\n+ty_utils_closure_and_return_not_supported = closures and function keywords are not supported in generic constants\n \n ty_utils_const_block_not_supported = const blocks are not supported in generic constants\n \n-ty_utils_adt_not_supported = struct/enum construction is not supported in generic constants\n+ty_utils_control_flow_not_supported = control flow is not supported in generic constants\n \n-ty_utils_pointer_not_supported = pointer casts are not allowed in generic constants\n+ty_utils_field_not_supported = field access is not supported in generic constants\n \n-ty_utils_yield_not_supported = generator control flow is not allowed in generic constants\n+ty_utils_generic_constant_too_complex = overly complex generic constant\n+    .help = consider moving this anonymous constant into a `const` function\n+    .maybe_supported = this operation may be supported in the future\n \n-ty_utils_loop_not_supported = loops and loop control flow are not supported in generic constants\n+ty_utils_impl_trait_duplicate_arg = non-defining opaque type use in defining scope\n+    .label = generic argument `{$arg}` used twice\n+    .note = for this opaque type\n \n-ty_utils_box_not_supported = allocations are not allowed in generic constants\n+ty_utils_impl_trait_not_param = non-defining opaque type use in defining scope\n+    .label = argument `{$arg}` is not a generic parameter\n+    .note = for this opaque type\n \n-ty_utils_binary_not_supported = unsupported binary operation in generic constants\n+ty_utils_index_not_supported = indexing is not supported in generic constants\n+\n+ty_utils_inline_asm_not_supported = assembly is not supported in generic constants\n \n ty_utils_logical_op_not_supported = unsupported operation in generic constants, short-circuiting operations would imply control flow\n \n-ty_utils_assign_not_supported = assignment is not supported in generic constants\n+ty_utils_loop_not_supported = loops and loop control flow are not supported in generic constants\n \n-ty_utils_closure_and_return_not_supported = closures and function keywords are not supported in generic constants\n+ty_utils_multiple_array_fields_simd_type = monomorphising SIMD type `{$ty}` with more than one array field\n \n-ty_utils_control_flow_not_supported = control flow is not supported in generic constants\n+ty_utils_needs_drop_overflow = overflow while checking whether `{$query_ty}` requires drop\n \n-ty_utils_inline_asm_not_supported = assembly is not supported in generic constants\n+ty_utils_never_to_any_not_supported = coercing the `never` type is not supported in generic constants\n \n-ty_utils_operation_not_supported = unsupported operation in generic constants\n+ty_utils_non_primitive_simd_type = monomorphising SIMD type `{$ty}` with a non-primitive-scalar (integer/float/pointer) element type `{$e_ty}`\n \n-ty_utils_unexpected_fnptr_associated_item = `FnPtr` trait with unexpected associated item\n+ty_utils_operation_not_supported = unsupported operation in generic constants\n \n-ty_utils_zero_length_simd_type = monomorphising SIMD type `{$ty}` of zero length\n+ty_utils_oversized_simd_type = monomorphising SIMD type `{$ty}` of length greater than {$max_lanes}\n \n-ty_utils_multiple_array_fields_simd_type = monomorphising SIMD type `{$ty}` with more than one array field\n+ty_utils_pointer_not_supported = pointer casts are not allowed in generic constants\n \n-ty_utils_oversized_simd_type = monomorphising SIMD type `{$ty}` of length greater than {$max_lanes}\n+ty_utils_tuple_not_supported = tuple construction is not supported in generic constants\n \n-ty_utils_non_primitive_simd_type = monomorphising SIMD type `{$ty}` with a non-primitive-scalar (integer/float/pointer) element type `{$e_ty}`\n+ty_utils_unexpected_fnptr_associated_item = `FnPtr` trait with unexpected associated item\n \n-ty_utils_impl_trait_duplicate_arg = non-defining opaque type use in defining scope\n-    .label = generic argument `{$arg}` used twice\n-    .note = for this opaque type\n+ty_utils_yield_not_supported = generator control flow is not allowed in generic constants\n \n-ty_utils_impl_trait_not_param = non-defining opaque type use in defining scope\n-    .label = argument `{$arg}` is not a generic parameter\n-    .note = for this opaque type\n+ty_utils_zero_length_simd_type = monomorphising SIMD type `{$ty}` of zero length"}, {"sha": "15c19104616665d893436ab3b73b9f0c2644d88a", "filename": "compiler/rustc_ty_utils/src/abi.rs", "status": "modified", "additions": 31, "deletions": 4, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fabi.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -238,6 +238,7 @@ fn adjust_for_rust_scalar<'tcx>(\n     layout: TyAndLayout<'tcx>,\n     offset: Size,\n     is_return: bool,\n+    drop_target_pointee: Option<Ty<'tcx>>,\n ) {\n     // Booleans are always a noundef i1 that needs to be zero-extended.\n     if scalar.is_bool() {\n@@ -251,14 +252,24 @@ fn adjust_for_rust_scalar<'tcx>(\n     }\n \n     // Only pointer types handled below.\n-    let Scalar::Initialized { value: Pointer(_), valid_range} = scalar else { return };\n+    let Scalar::Initialized { value: Pointer(_), valid_range } = scalar else { return };\n \n-    if !valid_range.contains(0) {\n+    // Set `nonnull` if the validity range excludes zero, or for the argument to `drop_in_place`,\n+    // which must be nonnull per its documented safety requirements.\n+    if !valid_range.contains(0) || drop_target_pointee.is_some() {\n         attrs.set(ArgAttribute::NonNull);\n     }\n \n     if let Some(pointee) = layout.pointee_info_at(&cx, offset) {\n-        if let Some(kind) = pointee.safe {\n+        let kind = if let Some(kind) = pointee.safe {\n+            Some(kind)\n+        } else if let Some(pointee) = drop_target_pointee {\n+            // The argument to `drop_in_place` is semantically equivalent to a mutable reference.\n+            Some(PointerKind::MutableRef { unpin: pointee.is_unpin(cx.tcx, cx.param_env()) })\n+        } else {\n+            None\n+        };\n+        if let Some(kind) = kind {\n             attrs.pointee_align = Some(pointee.align);\n \n             // `Box` are not necessarily dereferenceable for the entire duration of the function as\n@@ -362,10 +373,18 @@ fn fn_abi_new_uncached<'tcx>(\n     use SpecAbi::*;\n     let rust_abi = matches!(sig.abi, RustIntrinsic | PlatformIntrinsic | Rust | RustCall);\n \n+    let is_drop_in_place =\n+        fn_def_id.is_some() && fn_def_id == cx.tcx.lang_items().drop_in_place_fn();\n+\n     let arg_of = |ty: Ty<'tcx>, arg_idx: Option<usize>| -> Result<_, FnAbiError<'tcx>> {\n         let span = tracing::debug_span!(\"arg_of\");\n         let _entered = span.enter();\n         let is_return = arg_idx.is_none();\n+        let is_drop_target = is_drop_in_place && arg_idx == Some(0);\n+        let drop_target_pointee = is_drop_target.then(|| match ty.kind() {\n+            ty::RawPtr(ty::TypeAndMut { ty, .. }) => *ty,\n+            _ => bug!(\"argument to drop_in_place is not a raw ptr: {:?}\", ty),\n+        });\n \n         let layout = cx.layout_of(ty)?;\n         let layout = if force_thin_self_ptr && arg_idx == Some(0) {\n@@ -379,7 +398,15 @@ fn fn_abi_new_uncached<'tcx>(\n \n         let mut arg = ArgAbi::new(cx, layout, |layout, scalar, offset| {\n             let mut attrs = ArgAttributes::new();\n-            adjust_for_rust_scalar(*cx, &mut attrs, scalar, *layout, offset, is_return);\n+            adjust_for_rust_scalar(\n+                *cx,\n+                &mut attrs,\n+                scalar,\n+                *layout,\n+                offset,\n+                is_return,\n+                drop_target_pointee,\n+            );\n             attrs\n         });\n "}, {"sha": "01d1fdc9b2a5530ac03e1e829fd4d4713f8c6908", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -37,6 +37,9 @@ extern \"Rust\" {\n     #[rustc_allocator_zeroed]\n     #[rustc_nounwind]\n     fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;\n+\n+    #[cfg(not(bootstrap))]\n+    static __rust_no_alloc_shim_is_unstable: u8;\n }\n \n /// The global memory allocator.\n@@ -90,7 +93,14 @@ pub use std::alloc::Global;\n #[must_use = \"losing the pointer will leak memory\"]\n #[inline]\n pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n-    unsafe { __rust_alloc(layout.size(), layout.align()) }\n+    unsafe {\n+        // Make sure we don't accidentally allow omitting the allocator shim in\n+        // stable code until it is actually stabilized.\n+        #[cfg(not(bootstrap))]\n+        core::ptr::read_volatile(&__rust_no_alloc_shim_is_unstable);\n+\n+        __rust_alloc(layout.size(), layout.align())\n+    }\n }\n \n /// Deallocate memory with the global allocator."}, {"sha": "ff9fa48f31136297dd1dbb1d1a9d486cf010abc4", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -441,19 +441,25 @@ mod mut_ptr;\n ///\n /// * `to_drop` must be [valid] for both reads and writes.\n ///\n-/// * `to_drop` must be properly aligned.\n+/// * `to_drop` must be properly aligned, even if `T` has size 0.\n ///\n-/// * The value `to_drop` points to must be valid for dropping, which may mean it must uphold\n-///   additional invariants - this is type-dependent.\n+/// * `to_drop` must be nonnull, even if `T` has size 0.\n+///\n+/// * The value `to_drop` points to must be valid for dropping, which may mean\n+///   it must uphold additional invariants. These invariants depend on the type\n+///   of the value being dropped. For instance, when dropping a Box, the box's\n+///   pointer to the heap must be valid.\n+///\n+/// * While `drop_in_place` is executing, the only way to access parts of\n+///   `to_drop` is through the `&mut self` references supplied to the\n+///   `Drop::drop` methods that `drop_in_place` invokes.\n ///\n /// Additionally, if `T` is not [`Copy`], using the pointed-to value after\n /// calling `drop_in_place` can cause undefined behavior. Note that `*to_drop =\n /// foo` counts as a use because it will cause the value to be dropped\n /// again. [`write()`] can be used to overwrite data without causing it to be\n /// dropped.\n ///\n-/// Note that even if `T` has size `0`, the pointer must be non-null and properly aligned.\n-///\n /// [valid]: self#safety\n ///\n /// # Examples"}, {"sha": "bd1b16e8d73ed64ba33beeae533269aa685cb4c2", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 262, "deletions": 3, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d", "patch": "@@ -42,6 +42,7 @@ mod index;\n mod iter;\n mod raw;\n mod rotate;\n+mod select;\n mod specialize;\n \n #[unstable(feature = \"str_internals\", issue = \"none\")]\n@@ -319,6 +320,264 @@ impl<T> [T] {\n         if let [.., last] = self { Some(last) } else { None }\n     }\n \n+    /// Returns the first `N` elements of the slice, or `None` if it has fewer than `N` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let u = [10, 40, 30];\n+    /// assert_eq!(Some(&[10, 40]), u.first_chunk::<2>());\n+    ///\n+    /// let v: &[i32] = &[10];\n+    /// assert_eq!(None, v.first_chunk::<2>());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(Some(&[]), w.first_chunk::<0>());\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn first_chunk<const N: usize>(&self) -> Option<&[T; N]> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   and do not let the reference outlive the slice.\n+            Some(unsafe { &*(self.as_ptr() as *const [T; N]) })\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the first `N` elements of the slice,\n+    /// or `None` if it has fewer than `N` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(first) = x.first_chunk_mut::<2>() {\n+    ///     first[0] = 5;\n+    ///     first[1] = 4;\n+    /// }\n+    /// assert_eq!(x, &[5, 4, 2]);\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn first_chunk_mut<const N: usize>(&mut self) -> Option<&mut [T; N]> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   do not let the reference outlive the slice,\n+            //   and require exclusive access to the entire slice to mutate the chunk.\n+            Some(unsafe { &mut *(self.as_mut_ptr() as *mut [T; N]) })\n+        }\n+    }\n+\n+    /// Returns the first `N` elements of the slice and the remainder,\n+    /// or `None` if it has fewer than `N` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &[0, 1, 2];\n+    ///\n+    /// if let Some((first, elements)) = x.split_first_chunk::<2>() {\n+    ///     assert_eq!(first, &[0, 1]);\n+    ///     assert_eq!(elements, &[2]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn split_first_chunk<const N: usize>(&self) -> Option<(&[T; N], &[T])> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the split.\n+            let (first, tail) = unsafe { self.split_at_unchecked(N) };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   and do not let the references outlive the slice.\n+            Some((unsafe { &*(first.as_ptr() as *const [T; N]) }, tail))\n+        }\n+    }\n+\n+    /// Returns a mutable reference to the first `N` elements of the slice and the remainder,\n+    /// or `None` if it has fewer than `N` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some((first, elements)) = x.split_first_chunk_mut::<2>() {\n+    ///     first[0] = 3;\n+    ///     first[1] = 4;\n+    ///     elements[0] = 5;\n+    /// }\n+    /// assert_eq!(x, &[3, 4, 5]);\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn split_first_chunk_mut<const N: usize>(\n+        &mut self,\n+    ) -> Option<(&mut [T; N], &mut [T])> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the split.\n+            let (first, tail) = unsafe { self.split_at_mut_unchecked(N) };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   do not let the reference outlive the slice,\n+            //   and enforce exclusive mutability of the chunk by the split.\n+            Some((unsafe { &mut *(first.as_mut_ptr() as *mut [T; N]) }, tail))\n+        }\n+    }\n+\n+    /// Returns the last `N` elements of the slice and the remainder,\n+    /// or `None` if it has fewer than `N` elements.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &[0, 1, 2];\n+    ///\n+    /// if let Some((last, elements)) = x.split_last_chunk::<2>() {\n+    ///     assert_eq!(last, &[1, 2]);\n+    ///     assert_eq!(elements, &[0]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn split_last_chunk<const N: usize>(&self) -> Option<(&[T; N], &[T])> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the split.\n+            let (init, last) = unsafe { self.split_at_unchecked(self.len() - N) };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   and do not let the references outlive the slice.\n+            Some((unsafe { &*(last.as_ptr() as *const [T; N]) }, init))\n+        }\n+    }\n+\n+    /// Returns the last and all the rest of the elements of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some((last, elements)) = x.split_last_chunk_mut::<2>() {\n+    ///     last[0] = 3;\n+    ///     last[1] = 4;\n+    ///     elements[0] = 5;\n+    /// }\n+    /// assert_eq!(x, &[5, 3, 4]);\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn split_last_chunk_mut<const N: usize>(\n+        &mut self,\n+    ) -> Option<(&mut [T; N], &mut [T])> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the split.\n+            let (init, last) = unsafe { self.split_at_mut_unchecked(self.len() - N) };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   do not let the reference outlive the slice,\n+            //   and enforce exclusive mutability of the chunk by the split.\n+            Some((unsafe { &mut *(last.as_mut_ptr() as *mut [T; N]) }, init))\n+        }\n+    }\n+\n+    /// Returns the last element of the slice, or `None` if it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let u = [10, 40, 30];\n+    /// assert_eq!(Some(&[40, 30]), u.last_chunk::<2>());\n+    ///\n+    /// let v: &[i32] = &[10];\n+    /// assert_eq!(None, v.last_chunk::<2>());\n+    ///\n+    /// let w: &[i32] = &[];\n+    /// assert_eq!(Some(&[]), w.last_chunk::<0>());\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn last_chunk<const N: usize>(&self) -> Option<&[T; N]> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the slice.\n+            // FIXME: Without const traits, we need this instead of `get_unchecked`.\n+            let last = unsafe { self.split_at_unchecked(self.len() - N).1 };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   and do not let the references outlive the slice.\n+            Some(unsafe { &*(last.as_ptr() as *const [T; N]) })\n+        }\n+    }\n+\n+    /// Returns a mutable pointer to the last item in the slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_first_last_chunk)]\n+    ///\n+    /// let x = &mut [0, 1, 2];\n+    ///\n+    /// if let Some(last) = x.last_chunk_mut::<2>() {\n+    ///     last[0] = 10;\n+    ///     last[1] = 20;\n+    /// }\n+    /// assert_eq!(x, &[0, 10, 20]);\n+    /// ```\n+    #[unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[rustc_const_unstable(feature = \"slice_first_last_chunk\", issue = \"111774\")]\n+    #[inline]\n+    pub const fn last_chunk_mut<const N: usize>(&mut self) -> Option<&mut [T; N]> {\n+        if self.len() < N {\n+            None\n+        } else {\n+            // SAFETY: We manually verified the bounds of the slice.\n+            // FIXME: Without const traits, we need this instead of `get_unchecked`.\n+            let last = unsafe { self.split_at_mut_unchecked(self.len() - N).1 };\n+\n+            // SAFETY: We explicitly check for the correct number of elements,\n+            //   do not let the reference outlive the slice,\n+            //   and require exclusive access to the entire slice to mutate the chunk.\n+            Some(unsafe { &mut *(last.as_mut_ptr() as *mut [T; N]) })\n+        }\n+    }\n+\n     /// Returns a reference to an element or subslice depending on the type of\n     /// index.\n     ///\n@@ -2776,7 +3035,7 @@ impl<T> [T] {\n     where\n         T: Ord,\n     {\n-        sort::partition_at_index(self, index, T::lt)\n+        select::partition_at_index(self, index, T::lt)\n     }\n \n     /// Reorder the slice with a comparator function such that the element at `index` is at its\n@@ -2831,7 +3090,7 @@ impl<T> [T] {\n     where\n         F: FnMut(&T, &T) -> Ordering,\n     {\n-        sort::partition_at_index(self, index, |a: &T, b: &T| compare(a, b) == Less)\n+        select::partition_at_index(self, index, |a: &T, b: &T| compare(a, b) == Less)\n     }\n \n     /// Reorder the slice with a key extraction function such that the element at `index` is at its\n@@ -2887,7 +3146,7 @@ impl<T> [T] {\n         F: FnMut(&T) -> K,\n         K: Ord,\n     {\n-        sort::partition_at_index(self, index, |a: &T, b: &T| f(a).lt(&f(b)))\n+        select::partition_at_index(self, index, |a: &T, b: &T| f(a).lt(&f(b)))\n     }\n \n     /// Moves all consecutive repeated elements to the end of the slice according to the"}, {"sha": "ffc193578e075cebcbe9fd0e24c0b89237cbed49", "filename": "library/core/src/slice/select.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fcore%2Fsrc%2Fslice%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fcore%2Fsrc%2Fslice%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fselect.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "db76d26257aac8d7d416d1e25613c9e11c1b3351", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 5, "deletions": 137, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "824abc72a223df7812fb59eb0944c6ded4cce8f9", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "8a007d095d5e3a8f42474c0c4530d06f451c04af", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "6ac3b3eaa797b16e2377e6ee53eb41276504676a", "filename": "library/test/src/cli.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Ftest%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/library%2Ftest%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fcli.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "e192cda9a9a71d3340f5464e65307e9f5d0f3c9d", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 124, "deletions": 26, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "4de84b543ed96c0cdf838a8b7b5682d27eac375d", "filename": "src/bootstrap/config/tests.rs", "status": "modified", "additions": 71, "deletions": 6, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fbootstrap%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fbootstrap%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig%2Ftests.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "b49845386da174b0f44a196ca4be142aa7c13a04", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "80e715777984a492fe6d29a6c7dcbad49d2cfa39", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "040a12f5d10a49fa9e19b3aa1c280ebd0a95ca4a", "filename": "src/bootstrap/llvm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fbootstrap%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fbootstrap%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fllvm.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "e799d7c968893432ab50d3f485335a2bb0501ac8", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "420c42bc9d8079a134a5a45a3f6e7f01cf98acb3", "filename": "src/ci/docker/host-x86_64/dist-arm-linux/Dockerfile", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-arm-linux%2FDockerfile?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "78689c429c2e39fd8f41c6c29e53ac9dc231ff73", "filename": "src/ci/docker/host-x86_64/dist-loongarch64-linux/Dockerfile", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-loongarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-loongarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-loongarch64-linux%2FDockerfile?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "576f3631cd53f5bccff71de2a5be2e6c42425d0b", "filename": "src/ci/docker/host-x86_64/dist-loongarch64-linux/loongarch64-unknown-linux-gnu.defconfig", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-loongarch64-linux%2Floongarch64-unknown-linux-gnu.defconfig", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-loongarch64-linux%2Floongarch64-unknown-linux-gnu.defconfig", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-loongarch64-linux%2Floongarch64-unknown-linux-gnu.defconfig?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "398362ca52f22115943bd56bb0c921c1f50eedbe", "filename": "src/ci/docker/scripts/cross-apt-packages.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fcross-apt-packages.sh?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "449cc476f9ab5035d674f33d50d04d119445c430", "filename": "src/ci/docker/scripts/crosstool-ng-git.sh", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-git.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-git.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fcrosstool-ng-git.sh?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "fd619467fc153a3fe3d0e742c166b0f342556999", "filename": "src/ci/github-actions/ci.yml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fgithub-actions%2Fci.yml", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fci%2Fgithub-actions%2Fci.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fgithub-actions%2Fci.yml?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "f2aed2fe8e9f55508c86ba3aa4b6789b18a08a22", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "b5f018fb5930cb733b0a8aaf2eed975d4771e74d", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "553d99b02a53b4133a40d5bd2e19958c67487c00", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "f1e637883fafeb83bdd5906ee7f467e4d35b7337", "filename": "src/doc/rustc-dev-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-dev-guide?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "a82a53248d485d0cfd597f208dba51761c0893d6", "filename": "src/doc/rustc/src/exploit-mitigations.md", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fexploit-mitigations.md?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "ef02c605ead8a217a6991f4e7c137ee73ac6c520", "filename": "src/doc/rustc/src/images/image3.png", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage3.png", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage3.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fimages%2Fimage3.png?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "3b2463aa5b2ddaf47d0780e7c2dcb17e460eba58", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "999e71f80285a52a2b6cefd8883888810d27a733", "filename": "src/doc/rustc/src/platform-support/loongarch-linux.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Floongarch-linux.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Floongarch-linux.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Floongarch-linux.md?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "1fa9f81447607bd725acaaf71b3070810331a526", "filename": "src/doc/rustdoc/src/how-to-write-documentation.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-write-documentation.md?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "9f65f1eeeb7e57e55d7a9b00ac4a8c3adcd14b6a", "filename": "src/etc/completions/x.py.fish", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fetc%2Fcompletions%2Fx.py.fish", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fetc%2Fcompletions%2Fx.py.fish", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcompletions%2Fx.py.fish?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "569c186555cc24e2d173098a4d8856062f302abf", "filename": "src/etc/completions/x.py.ps1", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fetc%2Fcompletions%2Fx.py.ps1", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fetc%2Fcompletions%2Fx.py.ps1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcompletions%2Fx.py.ps1?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "322afdb28835f876f6867755a654ea6b68b84db1", "filename": "src/etc/completions/x.py.sh", "status": "modified", "additions": 75, "deletions": 15, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fetc%2Fcompletions%2Fx.py.sh", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Fetc%2Fcompletions%2Fx.py.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcompletions%2Fx.py.sh?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "e9ccea2cf270f5cd68cfbc06e6ccc52d4d4cd324", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "394954208a48e6fae70690cac77fbd8c0de5d5f2", "filename": "src/librustdoc/clean/types/tests.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes%2Ftests.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "e10a629777526fbd8543f4f4d08f99528253ae5d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "f6631b66f5b65f5e195d061642da622cd865cd75", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "c4758fd9866558a32a289268659c37c2f99f8ee8", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "56af257fd5eb9ef014fcd61b086c4aa7a853a4aa", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "42e27d35a94b1dcc4c15f1c03d6006777128f549", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "76c8e0885a0a2ba864d6bd5328d52883ba62c258", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "846299f02e33c39252f4dc51b1bccf7c1f82c3bd", "filename": "src/librustdoc/html/render/search_index.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fsearch_index.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "c1324c0760e63a662e27e0531d9daf5b9201ad67", "filename": "src/librustdoc/html/static/css/settings.css", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "935bb721f1803f402490f9876a7935afdba22722", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "6ead0cd961a3143a8b382a61c13fae0c15253e6d", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}, {"sha": "b6cd897d317546ef703aa604ca5718369d240e53", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad60608444c9e4c0647b2823f261c7d2359f060d/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=ad60608444c9e4c0647b2823f261c7d2359f060d"}]}