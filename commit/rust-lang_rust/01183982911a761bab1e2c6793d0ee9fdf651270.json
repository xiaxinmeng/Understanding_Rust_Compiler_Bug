{"sha": "01183982911a761bab1e2c6793d0ee9fdf651270", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMTgzOTgyOTExYTc2MWJhYjFlMmM2NzkzZDBlZTlmZGY2NTEyNzA=", "commit": {"author": {"name": "Havvy", "email": "ryan.havvy@gmail.com", "date": "2017-09-27T00:41:21Z"}, "committer": {"name": "Havvy", "email": "ryan.havvy@gmail.com", "date": "2017-09-28T06:01:48Z"}, "message": "Docs for size_of::<#[repr(C)]> items.\n\nMost of this info comes from camlorn's blog post on optimizing\nstruct layout and the Rustonomicon.", "tree": {"sha": "31858352efe8e480409d59ff2f0e492124d4c173", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31858352efe8e480409d59ff2f0e492124d4c173"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/01183982911a761bab1e2c6793d0ee9fdf651270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/01183982911a761bab1e2c6793d0ee9fdf651270", "html_url": "https://github.com/rust-lang/rust/commit/01183982911a761bab1e2c6793d0ee9fdf651270", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/01183982911a761bab1e2c6793d0ee9fdf651270/comments", "author": {"login": "Havvy", "id": 731722, "node_id": "MDQ6VXNlcjczMTcyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/731722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Havvy", "html_url": "https://github.com/Havvy", "followers_url": "https://api.github.com/users/Havvy/followers", "following_url": "https://api.github.com/users/Havvy/following{/other_user}", "gists_url": "https://api.github.com/users/Havvy/gists{/gist_id}", "starred_url": "https://api.github.com/users/Havvy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Havvy/subscriptions", "organizations_url": "https://api.github.com/users/Havvy/orgs", "repos_url": "https://api.github.com/users/Havvy/repos", "events_url": "https://api.github.com/users/Havvy/events{/privacy}", "received_events_url": "https://api.github.com/users/Havvy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Havvy", "id": 731722, "node_id": "MDQ6VXNlcjczMTcyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/731722?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Havvy", "html_url": "https://github.com/Havvy", "followers_url": "https://api.github.com/users/Havvy/followers", "following_url": "https://api.github.com/users/Havvy/following{/other_user}", "gists_url": "https://api.github.com/users/Havvy/gists{/gist_id}", "starred_url": "https://api.github.com/users/Havvy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Havvy/subscriptions", "organizations_url": "https://api.github.com/users/Havvy/orgs", "repos_url": "https://api.github.com/users/Havvy/repos", "events_url": "https://api.github.com/users/Havvy/events{/privacy}", "received_events_url": "https://api.github.com/users/Havvy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c4510adc81bd7623bc2993b42ee7d87320f1f2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4510adc81bd7623bc2993b42ee7d87320f1f2b", "html_url": "https://github.com/rust-lang/rust/commit/1c4510adc81bd7623bc2993b42ee7d87320f1f2b"}], "stats": {"total": 78, "additions": 78, "deletions": 0}, "files": [{"sha": "56685a67ad5e44cfd47d3791845efbe1a9dad7da", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/01183982911a761bab1e2c6793d0ee9fdf651270/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/01183982911a761bab1e2c6793d0ee9fdf651270/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=01183982911a761bab1e2c6793d0ee9fdf651270", "patch": "@@ -209,6 +209,35 @@ pub fn forget<T>(t: T) {\n /// The mutability of a pointer does not change its size. As such, `&T` and `&mut T`\n /// have the same size. Likewise for `*const T` and `*mut T`.\n ///\n+/// # Size of #[repr(C)] items\n+///\n+/// The `C` representation for items has a defined layout. With this layout,\n+/// the size of items is also stable as long as all fields have a stable size.\n+///\n+/// ## Structs\n+///\n+/// For `structs`, the size is determined by the following algorithm.\n+///\n+/// For each field in the struct ordered by declaration order:\n+///\n+/// 1. Add the size of the field.\n+/// 2. Round up the current size to the nearest multiple of the next field's [alignment].\n+///\n+/// Finally, round the size of the struct to the nearest multiple of its [alignment].\n+///\n+/// Unlike `C`, zero sized structs are not rounded up to one byte in size.\n+///\n+/// ## Enums\n+///\n+/// Enums that carry no data other than the descriminant have the same size as C enums\n+/// on the platform they are compiled for.\n+///\n+/// ## Unions\n+///\n+/// The size of a union is the size of its largest field.\n+///\n+/// Unlike `C`, zero sized unions are not rounded up to one byte in size.\n+///\n /// # Examples\n ///\n /// ```\n@@ -231,6 +260,55 @@ pub fn forget<T>(t: T) {\n /// assert_eq!(mem::size_of::<&i32>(), mem::size_of::<Option<&i32>>());\n /// assert_eq!(mem::size_of::<Box<i32>>(), mem::size_of::<Option<Box<i32>>>());\n /// ```\n+///\n+/// Using `#[repr(C)]`.\n+///\n+/// ```\n+/// use std::mem;\n+///\n+/// #[repr(C)]\n+/// struct FieldStruct {\n+///     first: u8,\n+///     second: u16,\n+///     third: u8\n+/// }\n+///\n+/// // The size of the first field is 1, so add 1 to the size. Size is 1.\n+/// // The alignment of the second field is 2, so add 1 to the size for padding. Size is 2.\n+/// // The size of the second field is 2, so add 2 to the size. Size is 4.\n+/// // The alignment of the third field is 1, so add 0 to the size for padding. Size is 4.\n+/// // The size of the third field is 1, so add 1 to the size. Size is 5.\n+/// // Finally, the alignment of the struct is 2, so add 1 to the size for padding. Size is 6.\n+/// assert_eq!(6, mem::size_of::<FieldStruct>());\n+///\n+/// #[repr(C)]\n+/// struct TupleStruct(u8, u16, u8);\n+///\n+/// // Tuple structs follow the same rules.\n+/// assert_eq!(6, mem::size_of::<TupleStruct>());\n+///\n+/// // Note that reordering the fields can lower the size. We can remove both padding bytes\n+/// // by putting `third` before `second`.\n+/// #[repr(C)]\n+/// struct FieldStructOptimized {\n+///     first: u8,\n+///     third: u8,\n+///     second: u16\n+/// }\n+///\n+/// assert_eq!(4, mem::size_of::<FieldStructOptimized>());\n+///\n+/// // Union size is the size of the largest field.\n+/// #[repr(C)]\n+/// union ExampleUnion {\n+///     smaller: u8,\n+///     larger: u16\n+/// }\n+///\n+/// assert_eq!(2, mem::size_of::<ExampleUnion>());\n+/// ```\n+///\n+/// [alignment]: ./fn.align_of.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[cfg_attr(not(stage0), rustc_const_unstable(feature = \"const_size_of\"))]"}]}