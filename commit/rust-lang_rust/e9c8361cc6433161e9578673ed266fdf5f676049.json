{"sha": "e9c8361cc6433161e9578673ed266fdf5f676049", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YzgzNjFjYzY0MzMxNjFlOTU3ODY3M2VkMjY2ZmRmNWY2NzYwNDk=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-14T11:45:26Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-16T19:10:01Z"}, "message": "Add equivalence class splitting for range constructors", "tree": {"sha": "ec86d33864e5a7e86a0a57ca2788e81e11eb70c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec86d33864e5a7e86a0a57ca2788e81e11eb70c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9c8361cc6433161e9578673ed266fdf5f676049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9c8361cc6433161e9578673ed266fdf5f676049", "html_url": "https://github.com/rust-lang/rust/commit/e9c8361cc6433161e9578673ed266fdf5f676049", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9c8361cc6433161e9578673ed266fdf5f676049/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "527cccb7a7a0213880eb97bd01ff1b9f3c834d5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/527cccb7a7a0213880eb97bd01ff1b9f3c834d5b", "html_url": "https://github.com/rust-lang/rust/commit/527cccb7a7a0213880eb97bd01ff1b9f3c834d5b"}], "stats": {"total": 344, "additions": 267, "deletions": 77}, "files": [{"sha": "eef3330c0357ed32b107ff4aaa6e853e1381d5dd", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 266, "deletions": 77, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/e9c8361cc6433161e9578673ed266fdf5f676049/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c8361cc6433161e9578673ed266fdf5f676049/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e9c8361cc6433161e9578673ed266fdf5f676049", "patch": "@@ -59,6 +59,7 @@\n ///        `None`). You can think of it as filtering `P` to just the rows whose *first* pattern\n ///        can cover `c` (and expanding OR-patterns into distinct patterns), and then expanding\n ///        the constructor into all of its components.\n+///        The specialisation of a row vector is computed by `specialize`.\n ///\n ///        It is computed as follows. For each row `p_i` of P, we have four cases:\n ///             1.1. `p_(i,1)= c(r_1, .., r_a)`. Then `S(c, P)` has a corresponding row:\n@@ -74,9 +75,10 @@\n ///     2. `D(P)` is a \"default matrix\". This is used when we know there are missing\n ///        constructor cases, but there might be existing wildcard patterns, so to check the\n ///        usefulness of the matrix, we have to check all its *other* components.\n+///        The default matrix is computed inline in `is_useful`.\n ///\n ///         It is computed as follows. For each row `p_i` of P, we have three cases:\n-///             1.1. `p_(i,1)= c(r_1, .., r_a)`. Then `D(P)` has no corresponding row.\n+///             1.1. `p_(i,1) = c(r_1, .., r_a)`. Then `D(P)` has no corresponding row.\n ///             1.2. `p_(i,1) = _`. Then `D(P)` has a corresponding row:\n ///                     p_(i,2), .., p_(i,n)\n ///             1.3. `p_(i,1) = r_1 | r_2`. Then `D(P)` has corresponding rows inlined from:\n@@ -88,6 +90,7 @@\n /// The algorithm is inductive (on the number of columns: i.e. components of tuple patterns).\n /// That means we're going to check the components from left-to-right, so the algorithm\n /// operates principally on the first component of the matrix and new pattern `p_{m + 1}`.\n+/// This algorithm is realised in the `is_useful` function.\n ///\n /// Base case. (`n = 0`, i.e. an empty tuple pattern)\n ///     - If `P` already contains an empty pattern (i.e. if the number of patterns `m > 0`),\n@@ -101,6 +104,7 @@\n ///           we ignore all the patterns in `P` that involve other constructors. This is where\n ///           `S(c, P)` comes in:\n ///           `U(P, p_{m + 1}) := U(S(c, P), S(c, p_{m + 1}))`\n+///           This special case is handled in `is_useful_specialized`.\n ///         - If `p_{m + 1} == _`, then we have two more cases:\n ///             + All the constructors of the first component of the type exist within\n ///               all the rows (after having expanded OR-patterns). In this case:\n@@ -121,13 +125,48 @@\n /// ------------------------------\n /// The algorithm in the paper doesn't cover some of the special cases that arise in Rust, for\n /// example uninhabited types and variable-length slice patterns. These are drawn attention to\n-/// throughout the code below.\n+/// throughout the code below. I'll make a quick note here about how exhaustive integer matching\n+/// is accounted for, though.\n+///\n+/// Exhaustive integer matching\n+/// ---------------------------\n+/// An integer type can be thought of as a (huge) sum type: 1 | 2 | 3 | ...\n+/// So to support exhaustive integer matching, we can make use of the logic in the paper for\n+/// OR-patterns. However, we obviously can't just treat ranges x..=y as individual sums, because\n+/// they are likely gigantic. So we instead treat ranges as constructors of the integers. This means\n+/// that we have a constructor *of* constructors (the integers themselves). We then need to work\n+/// through all the inductive step rules above, deriving how the ranges would be treated as\n+/// OR-patterns, and making sure that they're treated in the same way even when they're ranges.\n+/// There are really only four special cases here:\n+/// - When we match on a constructor that's actually a range, we have to treat it as if we would\n+///   an OR-pattern.\n+///     + It turns out that we can simply extend the case for single-value patterns in\n+///      `specialize` to either be *equal* to a value constructor, or *contained within* a range\n+///      constructor.\n+///     + When the pattern itself is a range, you just want to tell whether any of the values in\n+///       the pattern range coincide with values in the constructor range, which is precisely\n+///       intersection.\n+///   Since when encountering a range pattern for a value constructor, we also use inclusion, it\n+///   means that whenever the constructor is a value/range and the pattern is also a value/range,\n+///   we can simply use intersection to test usefulness.\n+/// - When we're testing for usefulness of a pattern and the pattern's first component is a\n+///   wildcard.\n+///     + If all the constructors appear in the matrix, we have a slight complication. By default,\n+///       the behaviour (i.e. a disjunction over specialised matrices for each constructor) is\n+///       invalid, because we want a disjunction over every *integer* in each range, not just a\n+///       disjunction over every range. This is a bit more tricky to deal with: essentially we need\n+///       to form equivalence classes of subranges of the constructor range for which the behaviour\n+///       of the matrix `P` and new pattern `p_{m + 1}` are the same. This is described in more\n+///       detail in `split_grouped_constructors`.\n+///     + If some constructors are missing from the matrix, it turns out we don't need to do\n+///       anything special (because we know none of the integers are actually wildcards: i.e. we\n+///       can't span wildcards using ranges).\n \n use self::Constructor::*;\n use self::Usefulness::*;\n use self::WitnessPreference::*;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::Idx;\n \n use super::{FieldPattern, Pattern, PatternKind};\n@@ -147,7 +186,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use arena::TypedArena;\n \n-use std::cmp::{self, Ordering};\n+use std::cmp::{self, Ordering, min, max};\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n@@ -800,8 +839,17 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n-    // The return value of `signed_bias` should be\n-    // XORed with an endpoint to encode/decode it.\n+    fn from_pat(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+                pat: &Pattern<'tcx>)\n+                -> Option<IntRange<'tcx>> {\n+        Self::from_ctor(tcx, &match pat.kind {\n+            box PatternKind::Constant { value } => ConstantValue(value),\n+            box PatternKind::Range { lo, hi, end } => ConstantRange(lo, hi, end),\n+            _ => return None,\n+        })\n+    }\n+\n+    // The return value of `signed_bias` should be XORed with an endpoint to encode/decode it.\n     fn signed_bias(tcx: TyCtxt<'_, 'tcx, 'tcx>, ty: Ty<'tcx>) -> u128 {\n         match ty.sty {\n             ty::TyInt(ity) => {\n@@ -812,6 +860,24 @@ impl<'tcx> IntRange<'tcx> {\n         }\n     }\n \n+    /// Convert a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n+    fn range_to_ctor(\n+        tcx: TyCtxt<'_, 'tcx, 'tcx>,\n+        ty: Ty<'tcx>,\n+        r: RangeInclusive<u128>,\n+    ) -> Constructor<'tcx> {\n+        let bias = IntRange::signed_bias(tcx, ty);\n+        let ty = ty::ParamEnv::empty().and(ty);\n+        let (lo, hi) = r.into_inner();\n+        if lo == hi {\n+            ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty))\n+        } else {\n+            ConstantRange(ty::Const::from_bits(tcx, lo ^ bias, ty),\n+                          ty::Const::from_bits(tcx, hi ^ bias, ty),\n+                          RangeEnd::Included)\n+        }\n+    }\n+\n     /// Given an `IntRange` corresponding to a pattern in a `match` and a collection of\n     /// ranges corresponding to the domain of values of a type (say, an integer), return\n     /// a new collection of ranges corresponding to the original ranges minus the ranges\n@@ -823,42 +889,41 @@ impl<'tcx> IntRange<'tcx> {\n         let ranges = ranges.into_iter().filter_map(|r| {\n             IntRange::from_ctor(tcx, &r).map(|i| i.range)\n         });\n-        // Convert a `RangeInclusive` to a `ConstantValue` or inclusive `ConstantRange`.\n-        let bias = IntRange::signed_bias(tcx, self.ty);\n-        let ty = ty::ParamEnv::empty().and(self.ty);\n-        let range_to_constant = |r: RangeInclusive<u128>| {\n-            let (lo, hi) = r.into_inner();\n-            if lo == hi {\n-                ConstantValue(ty::Const::from_bits(tcx, lo ^ bias, ty))\n-            } else {\n-                ConstantRange(ty::Const::from_bits(tcx, lo ^ bias, ty),\n-                              ty::Const::from_bits(tcx, hi ^ bias, ty),\n-                              RangeEnd::Included)\n-            }\n-        };\n         let mut remaining_ranges = vec![];\n+        let ty = self.ty;\n         let (lo, hi) = self.range.into_inner();\n         for subrange in ranges {\n             let (subrange_lo, subrange_hi) = subrange.into_inner();\n             if lo > subrange_hi || subrange_lo > hi  {\n                 // The pattern doesn't intersect with the subrange at all,\n                 // so the subrange remains untouched.\n-                remaining_ranges.push(range_to_constant(subrange_lo..=subrange_hi));\n+                remaining_ranges.push(Self::range_to_ctor(tcx, ty, subrange_lo..=subrange_hi));\n             } else {\n                 if lo > subrange_lo {\n                     // The pattern intersects an upper section of the\n                     // subrange, so a lower section will remain.\n-                    remaining_ranges.push(range_to_constant(subrange_lo..=(lo - 1)));\n+                    remaining_ranges.push(Self::range_to_ctor(tcx, ty, subrange_lo..=(lo - 1)));\n                 }\n                 if hi < subrange_hi {\n                     // The pattern intersects a lower section of the\n                     // subrange, so an upper section will remain.\n-                    remaining_ranges.push(range_to_constant((hi + 1)..=subrange_hi));\n+                    remaining_ranges.push(Self::range_to_ctor(tcx, ty, (hi + 1)..=subrange_hi));\n                 }\n             }\n         }\n         remaining_ranges\n     }\n+\n+    fn intersection(&self, other: &Self) -> Option<Self> {\n+        let ty = self.ty;\n+        let (lo, hi) = (*self.range.start(), *self.range.end());\n+        let (other_lo, other_hi) = (*other.range.start(), *other.range.end());\n+        if lo <= other_hi && other_lo <= hi {\n+            Some(IntRange { range: max(lo, other_lo)..=min(hi, other_hi), ty })\n+        } else {\n+            None\n+        }\n+    }\n }\n \n /// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n@@ -937,7 +1002,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n \n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n         debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n-        constructors.into_iter().map(|c|\n+        split_grouped_constructors(cx.tcx, constructors, matrix, v, pcx.ty).into_iter().map(|c|\n             is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n         ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n     } else {\n@@ -952,16 +1017,6 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let all_ctors = all_constructors(cx, pcx);\n         debug!(\"all_ctors = {:#?}\", all_ctors);\n \n-        // The only constructor patterns for which it is valid to\n-        // treat the values as constructors are ranges (see\n-        // `all_constructors` for details).\n-        let exhaustive_integer_patterns = cx.tcx.features().exhaustive_integer_patterns;\n-        let consider_value_constructors = exhaustive_integer_patterns\n-            && all_ctors.iter().all(|ctor| match ctor {\n-                ConstantRange(..) => true,\n-                _ => false,\n-            });\n-\n         // `missing_ctors` are those that should have appeared\n         // as patterns in the `match` expression, but did not.\n         let mut missing_ctors = vec![];\n@@ -972,7 +1027,7 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n                     // If a constructor appears in a `match` arm, we can\n                     // eliminate it straight away.\n                     refined_ctors = vec![]\n-                } else if exhaustive_integer_patterns {\n+                } else if cx.tcx.features().exhaustive_integer_patterns {\n                     if let Some(interval) = IntRange::from_ctor(cx.tcx, used_ctor) {\n                         // Refine the required constructors for the type by subtracting\n                         // the range defined by the current constructor pattern.\n@@ -1025,15 +1080,9 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         let is_non_exhaustive = is_privately_empty || is_declared_nonexhaustive;\n \n         if missing_ctors.is_empty() && !is_non_exhaustive {\n-            if consider_value_constructors {\n-                // If we've successfully matched every value\n-                // of the type, then we're done.\n-                NotUseful\n-            } else {\n-                all_ctors.into_iter().map(|c| {\n-                    is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n-                }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n-            }\n+            split_grouped_constructors(cx.tcx, all_ctors, matrix, v, pcx.ty).into_iter().map(|c| {\n+                is_useful_specialized(cx, matrix, v, c.clone(), pcx.ty, witness)\n+            }).find(|result| result.is_useful()).unwrap_or(NotUseful)\n         } else {\n             let matrix = rows.iter().filter_map(|r| {\n                 if r[0].is_wildcard() {\n@@ -1119,14 +1168,16 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n+/// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e. `is_useful` applied\n+/// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n fn is_useful_specialized<'p, 'a:'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     &Matrix(ref m): &Matrix<'p, 'tcx>,\n     v: &[&'p Pattern<'tcx>],\n     ctor: Constructor<'tcx>,\n     lty: Ty<'tcx>,\n-    witness: WitnessPreference) -> Usefulness<'tcx>\n-{\n+    witness: WitnessPreference,\n+) -> Usefulness<'tcx> {\n     debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, lty);\n     let sub_pat_tys = constructor_sub_pattern_tys(cx, &ctor, lty);\n     let wild_patterns_owned: Vec<_> = sub_pat_tys.iter().map(|ty| {\n@@ -1309,13 +1360,160 @@ fn slice_pat_covered_by_constructor<'tcx>(\n     Ok(true)\n }\n \n+/// For exhaustive integer matching, some constructors are grouped within other constructors\n+/// (namely integer typed values are grouped within ranges). However, when specialising these\n+/// constructors, we want to be specialising for the underlying constructors (the integers), not\n+/// the groups (the ranges). Thus we need to split the groups up. Splitting them up na\u00efvely would\n+/// mean creating a separate constructor for every single value in the range, which is clearly\n+/// impractical. However, observe that for some ranges of integers, the specialisation will be\n+/// identical across all values in that range (i.e. there are equivalence classes of ranges of\n+/// constructors based on their `is_useful_specialised` outcome). These classes are grouped by\n+/// the patterns that apply to them (both in the matrix `P` and in the new row `p_{m + 1}`). We\n+/// can split the range whenever the patterns that apply to that range (specifically: the patterns\n+/// that *intersect* with that range) change.\n+/// Our solution, therefore, is to split the range constructor into subranges at every single point\n+/// the group of intersecting patterns changes, which we can compute by converting each pattern to\n+/// a range and recording its endpoints, then creating subranges between each consecutive pair of\n+/// endpoints.\n+/// And voil\u00e0! We're testing precisely those ranges that we need to, without any exhaustive matching\n+/// on actual integers. The nice thing about this is that the number of subranges is linear in the\n+/// number of rows in the matrix (i.e. the number of cases in the `match` statement), so we don't\n+/// need to be worried about matching over gargantuan ranges.\n+fn split_grouped_constructors<'p, 'a: 'p, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ctors: Vec<Constructor<'tcx>>,\n+    &Matrix(ref m): &Matrix<'p, 'tcx>,\n+    p: &[&'p Pattern<'tcx>],\n+    ty: Ty<'tcx>,\n+) -> Vec<Constructor<'tcx>> {\n+    let pat = &p[0];\n+\n+    let mut split_ctors = Vec::with_capacity(ctors.len());\n+\n+    for ctor in ctors.into_iter() {\n+        match ctor {\n+            // For now, only ranges may denote groups of \"subconstructors\", so we only need to\n+            // special-case constant ranges.\n+            ConstantRange(..) => {\n+                // We only care about finding all the subranges within the range of the intersection\n+                // of the new pattern `p_({m + 1},1)` (here `pat`) and the constructor range.\n+                // Anything else is irrelevant, because it is guaranteed to result in `NotUseful`,\n+                // which is the default case anyway, and can be ignored.\n+                let mut ctor_range = IntRange::from_ctor(tcx, &ctor).unwrap();\n+                if let Some(pat_range) = IntRange::from_pat(tcx, pat) {\n+                    if let Some(new_range) = ctor_range.intersection(&pat_range) {\n+                        ctor_range = new_range;\n+                    } else {\n+                        // If the intersection between `pat` and the constructor is empty, the\n+                        // entire range is `NotUseful`.\n+                        continue;\n+                    }\n+                } else {\n+                    match pat.kind {\n+                        box PatternKind::Wild => {\n+                            // A wild pattern matches the entire range of values,\n+                            // so the current values are fine.\n+                        }\n+                        // If the pattern is not a value (i.e. a degenerate range), a range or a\n+                        // wildcard (which stands for the entire range), then it's guaranteed to\n+                        // be `NotUseful`.\n+                        _ => continue,\n+                    }\n+                }\n+                // We're going to collect all the endpoints in the new pattern so we can create\n+                // subranges between them.\n+                let mut points = FxHashSet::default();\n+                let (lo, hi) = (*ctor_range.range.start(), *ctor_range.range.end());\n+                points.insert(lo);\n+                points.insert(hi);\n+                // We're going to iterate through every row pattern, adding endpoints in.\n+                for row in m.iter() {\n+                    if let Some(r) = IntRange::from_pat(tcx, row[0]) {\n+                        // We're only interested in endpoints that lie (at least partially)\n+                        // within the subrange domain.\n+                        if let Some(r) = ctor_range.intersection(&r) {\n+                            let (r_lo, r_hi) = r.range.into_inner();\n+                            // Insert the endpoints.\n+                            points.insert(r_lo);\n+                            points.insert(r_hi);\n+                            // There's a slight subtlety here, which involves the fact we're using\n+                            // inclusive ranges everywhere. When we subdivide the range into\n+                            // subranges, they can't overlap, or the subranges effectively\n+                            // coalesce. We need hard boundaries between subranges. The simplest\n+                            // way to do this is by adding extra \"boundary points\" to prevent this\n+                            // intersection. Technically this means we occasionally check a few more\n+                            // cases for usefulness than we need to (because they're part of another\n+                            // equivalence class), but it's still linear and very simple to verify,\n+                            // which is handy when it comes to matching, which can often be quite\n+                            // fiddly.\n+                            if r_lo > lo {\n+                                points.insert(r_lo - 1);\n+                            }\n+                            if r_hi < hi {\n+                                points.insert(r_hi + 1);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                // The patterns were iterated in an arbitrary order (i.e. in the order the user\n+                // wrote them), so we need to make sure our endpoints are sorted.\n+                let mut points: Vec<_> = points.into_iter().collect();\n+                points.sort();\n+                let mut points = points.into_iter();\n+                let mut start = points.next().unwrap();\n+                // Iterate through pairs of points, adding the subranges to `split_ctors`.\n+                while let Some(end) = points.next() {\n+                    split_ctors.push(IntRange::range_to_ctor(tcx, ty, start..=end));\n+                    start = end;\n+                }\n+            }\n+            // Any other constructor can be used unchanged.\n+            _ => split_ctors.push(ctor),\n+        }\n+    }\n+\n+    split_ctors\n+}\n+\n+/// Check whether there exists any shared value in either `ctor` or `pat` by intersecting them.\n+fn constructor_intersects_pattern<'p, 'a: 'p, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    ctor: &Constructor<'tcx>,\n+    pat: &'p Pattern<'tcx>,\n+) -> Option<Vec<&'p Pattern<'tcx>>> {\n+    let mut integer_matching = false;\n+    if let ConstantValue(value) | ConstantRange(value, _, _) = ctor {\n+        if let ty::TyChar | ty::TyInt(_) | ty::TyUint(_) = value.ty.sty {\n+            integer_matching = true;\n+        }\n+    }\n+    if integer_matching {\n+        match (IntRange::from_ctor(tcx, ctor), IntRange::from_pat(tcx, pat)) {\n+            (Some(ctor), Some(pat)) => ctor.intersection(&pat).map(|_| vec![]),\n+            _ => None,\n+        }\n+    } else {\n+        // Fallback for non-ranges and ranges that involve floating-point numbers, which are not\n+        // conveniently handled by `IntRange`. For these cases, the constructor may not be a range\n+        // so intersection actually devolves into being covered by the pattern.\n+        match constructor_covered_by_range(tcx, ctor, pat) {\n+            Ok(true) => Some(vec![]),\n+            Ok(false) | Err(ErrorReported) => None,\n+        }\n+    }\n+}\n+\n fn constructor_covered_by_range<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     ctor: &Constructor<'tcx>,\n-    from: &'tcx ty::Const<'tcx>, to: &'tcx ty::Const<'tcx>,\n-    end: RangeEnd,\n-    ty: Ty<'tcx>,\n+    pat: &Pattern<'tcx>,\n ) -> Result<bool, ErrorReported> {\n+    let (from, to, end, ty) = match pat.kind {\n+        box PatternKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n+        box PatternKind::Range { lo, hi, end } => (lo, hi, end, lo.ty),\n+        _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n+    };\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n     let cmp_from = |c_from| compare_const_vals(tcx, c_from, from, ty::ParamEnv::empty().and(ty))\n         .map(|res| res != Ordering::Less);\n@@ -1379,9 +1577,8 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n     cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     r: &[&'p Pattern<'tcx>],\n     constructor: &Constructor<'tcx>,\n-    wild_patterns: &[&'p Pattern<'tcx>])\n-    -> Option<Vec<&'p Pattern<'tcx>>>\n-{\n+    wild_patterns: &[&'p Pattern<'tcx>],\n+) -> Option<Vec<&'p Pattern<'tcx>>> {\n     let pat = &r[0];\n \n     let head: Option<Vec<&Pattern>> = match *pat.kind {\n@@ -1432,28 +1629,22 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     }\n                 }\n                 _ => {\n-                    match constructor_covered_by_range(\n-                        cx.tcx,\n-                        constructor, value, value, RangeEnd::Included,\n-                        value.ty,\n-                    ) {\n-                        Ok(true) => Some(vec![]),\n-                        Ok(false) => None,\n-                        Err(ErrorReported) => None,\n-                    }\n+                    // If the constructor is a single value, we add a row to the specialised matrix\n+                    // if the pattern is equal to the constructor. If the constructor is a range of\n+                    // values, we add a row to the specialised matrix if the pattern is contained\n+                    // within the constructor. These two cases (for a single value pattern) can be\n+                    // treated as intersection.\n+                    constructor_intersects_pattern(cx.tcx, constructor, pat)\n                 }\n             }\n         }\n \n-        PatternKind::Range { lo, hi, ref end } => {\n-            match constructor_covered_by_range(\n-                cx.tcx,\n-                constructor, lo, hi, end.clone(), lo.ty,\n-            ) {\n-                Ok(true) => Some(vec![]),\n-                Ok(false) => None,\n-                Err(ErrorReported) => None,\n-            }\n+        PatternKind::Range { .. } => {\n+            // If the constructor is a single value, we add a row to the specialised matrix if the\n+            // pattern contains the constructor. If the constructor is a range of values, we add a\n+            // row to the specialised matrix if there exists any value that lies both within the\n+            // pattern and the constructor. These two cases reduce to intersection.\n+            constructor_intersects_pattern(cx.tcx, constructor, pat)\n         }\n \n         PatternKind::Array { ref prefix, ref slice, ref suffix } |\n@@ -1463,14 +1654,12 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     let pat_len = prefix.len() + suffix.len();\n                     if let Some(slice_count) = wild_patterns.len().checked_sub(pat_len) {\n                         if slice_count == 0 || slice.is_some() {\n-                            Some(\n-                                prefix.iter().chain(\n-                                wild_patterns.iter().map(|p| *p)\n-                                                    .skip(prefix.len())\n-                                                    .take(slice_count)\n-                                                    .chain(\n-                                suffix.iter()\n-                            )).collect())\n+                            Some(prefix.iter().chain(\n+                                    wild_patterns.iter().map(|p| *p)\n+                                                 .skip(prefix.len())\n+                                                 .take(slice_count)\n+                                                 .chain(suffix.iter())\n+                            ).collect())\n                         } else {\n                             None\n                         }"}, {"sha": "d7bb666a80567e4706badc386d4199355e117a01", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9c8361cc6433161e9578673ed266fdf5f676049/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9c8361cc6433161e9578673ed266fdf5f676049/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=e9c8361cc6433161e9578673ed266fdf5f676049", "patch": "@@ -36,6 +36,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(unicode_internals)]\n #![feature(step_trait)]\n #![feature(slice_concat_ext)]\n+#![feature(if_while_or_patterns)]\n \n #![recursion_limit=\"256\"]\n "}]}