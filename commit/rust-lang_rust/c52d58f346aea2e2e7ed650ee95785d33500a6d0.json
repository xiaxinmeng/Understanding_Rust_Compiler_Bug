{"sha": "c52d58f346aea2e2e7ed650ee95785d33500a6d0", "node_id": "C_kwDOAAsO6NoAKGM1MmQ1OGYzNDZhZWEyZTJlN2VkNjUwZWU5NTc4NWQzMzUwMGE2ZDA", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-12-28T21:22:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-12-28T21:22:19Z"}, "message": "Rollup merge of #105570 - Nilstrieb:actual-best-failure, r=compiler-errors\n\nProperly calculate best failure in macro matching\n\nPreviously, we used spans. This was not good. Sometimes, the span of the token that failed to match may come from a position later in the file which has been transcribed into a token stream way earlier in the file. If precisely this token fails to match, we think that it was the best match because its span is so high, even though other arms might have gotten further in the token stream.\n\nWe now try to properly use the location in the token stream.\n\nThis needs a little cleanup as the `best_failure` field is getting out of hand but it should be mostly good to go. I hope I didn't violate too many abstraction boundaries..", "tree": {"sha": "4220254f810af0804181959838ff4eb500f68af0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4220254f810af0804181959838ff4eb500f68af0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c52d58f346aea2e2e7ed650ee95785d33500a6d0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjrLOLCRBK7hj4Ov3rIwAAZ6cIAAeoZpmRIF00eQCBeg32zhNV\nPKC2Go+Njn09+iFTMocqzAlj6/qbNYaeY2/NDq9FZTIEglW9sBqYg/sYmRBi1Gfz\nnnALWYQvUAmJ1fpcv+fFo1+2eOAqhgKr/lMKbv732Tq6PG1Z90pWreyQUwKsvAXF\nV7U14zZp39DKN0iRIJOtg96xh8EKUBuGyond/9dKBURIgCp4LpUl96WvMBN7qbGH\nQ0H+rZ4Oxk/5LdAXpONwwYsFhT1TRIBpl/LCGxS6XUevJy9PKX1b3Gl7zUiZZfnn\nj6H16zD2BQI9B7Ha9kYYdxBvjm/k4AnmhV8p7l9SskBdEuFv2L30tH6mXmtNSKc=\n=AUVe\n-----END PGP SIGNATURE-----\n", "payload": "tree 4220254f810af0804181959838ff4eb500f68af0\nparent 0b7ed65c13064ff1afe334bb781c02d172f54a48\nparent d72a0c437bd2db922b954af7b0278e1f4bf31edf\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1672262539 +0100\ncommitter GitHub <noreply@github.com> 1672262539 +0100\n\nRollup merge of #105570 - Nilstrieb:actual-best-failure, r=compiler-errors\n\nProperly calculate best failure in macro matching\n\nPreviously, we used spans. This was not good. Sometimes, the span of the token that failed to match may come from a position later in the file which has been transcribed into a token stream way earlier in the file. If precisely this token fails to match, we think that it was the best match because its span is so high, even though other arms might have gotten further in the token stream.\n\nWe now try to properly use the location in the token stream.\n\nThis needs a little cleanup as the `best_failure` field is getting out of hand but it should be mostly good to go. I hope I didn't violate too many abstraction boundaries..\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c52d58f346aea2e2e7ed650ee95785d33500a6d0", "html_url": "https://github.com/rust-lang/rust/commit/c52d58f346aea2e2e7ed650ee95785d33500a6d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c52d58f346aea2e2e7ed650ee95785d33500a6d0/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b7ed65c13064ff1afe334bb781c02d172f54a48", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b7ed65c13064ff1afe334bb781c02d172f54a48", "html_url": "https://github.com/rust-lang/rust/commit/0b7ed65c13064ff1afe334bb781c02d172f54a48"}, {"sha": "d72a0c437bd2db922b954af7b0278e1f4bf31edf", "url": "https://api.github.com/repos/rust-lang/rust/commits/d72a0c437bd2db922b954af7b0278e1f4bf31edf", "html_url": "https://github.com/rust-lang/rust/commit/d72a0c437bd2db922b954af7b0278e1f4bf31edf"}], "stats": {"total": 95, "additions": 80, "deletions": 15}, "files": [{"sha": "40aa64d9d40401719d595629467aaa9aa7544f44", "filename": "compiler/rustc_expand/src/mbe/diagnostics.rs", "status": "modified", "additions": 30, "deletions": 10, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c52d58f346aea2e2e7ed650ee95785d33500a6d0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c52d58f346aea2e2e7ed650ee95785d33500a6d0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fdiagnostics.rs?ref=c52d58f346aea2e2e7ed650ee95785d33500a6d0", "patch": "@@ -43,7 +43,7 @@ pub(super) fn failed_to_match_macro<'cx>(\n         return result;\n     }\n \n-    let Some((token, label, remaining_matcher)) = tracker.best_failure else {\n+    let Some(BestFailure { token, msg: label, remaining_matcher, .. }) = tracker.best_failure else {\n         return DummyResult::any(sp);\n     };\n \n@@ -95,11 +95,24 @@ struct CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n     cx: &'a mut ExtCtxt<'cx>,\n     remaining_matcher: Option<&'matcher MatcherLoc>,\n     /// Which arm's failure should we report? (the one furthest along)\n-    best_failure: Option<(Token, &'static str, MatcherLoc)>,\n+    best_failure: Option<BestFailure>,\n     root_span: Span,\n     result: Option<Box<dyn MacResult + 'cx>>,\n }\n \n+struct BestFailure {\n+    token: Token,\n+    position_in_tokenstream: usize,\n+    msg: &'static str,\n+    remaining_matcher: MatcherLoc,\n+}\n+\n+impl BestFailure {\n+    fn is_better_position(&self, position: usize) -> bool {\n+        position > self.position_in_tokenstream\n+    }\n+}\n+\n impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx, 'matcher> {\n     fn before_match_loc(&mut self, parser: &TtParser, matcher: &'matcher MatcherLoc) {\n         if self.remaining_matcher.is_none()\n@@ -119,18 +132,25 @@ impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx,\n                     \"should not collect detailed info for successful macro match\",\n                 );\n             }\n-            Failure(token, msg) => match self.best_failure {\n-                Some((ref best_token, _, _)) if best_token.span.lo() >= token.span.lo() => {}\n-                _ => {\n-                    self.best_failure = Some((\n-                        token.clone(),\n+            Failure(token, approx_position, msg) => {\n+                debug!(?token, ?msg, \"a new failure of an arm\");\n+\n+                if self\n+                    .best_failure\n+                    .as_ref()\n+                    .map_or(true, |failure| failure.is_better_position(*approx_position))\n+                {\n+                    self.best_failure = Some(BestFailure {\n+                        token: token.clone(),\n+                        position_in_tokenstream: *approx_position,\n                         msg,\n-                        self.remaining_matcher\n+                        remaining_matcher: self\n+                            .remaining_matcher\n                             .expect(\"must have collected matcher already\")\n                             .clone(),\n-                    ))\n+                    })\n                 }\n-            },\n+            }\n             Error(err_sp, msg) => {\n                 let span = err_sp.substitute_dummy(self.root_span);\n                 self.cx.struct_span_err(span, msg).emit();"}, {"sha": "df1c1834c1dc0d48b64c14c13e3c3ae950acd97a", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c52d58f346aea2e2e7ed650ee95785d33500a6d0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c52d58f346aea2e2e7ed650ee95785d33500a6d0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=c52d58f346aea2e2e7ed650ee95785d33500a6d0", "patch": "@@ -310,7 +310,8 @@ pub(crate) enum ParseResult<T> {\n     Success(T),\n     /// Arm failed to match. If the second parameter is `token::Eof`, it indicates an unexpected\n     /// end of macro invocation. Otherwise, it indicates that no rules expected the given token.\n-    Failure(Token, &'static str),\n+    /// The usize is the approximate position of the token in the input token stream.\n+    Failure(Token, usize, &'static str),\n     /// Fatal error (malformed macro?). Abort compilation.\n     Error(rustc_span::Span, String),\n     ErrorReported(ErrorGuaranteed),\n@@ -455,6 +456,7 @@ impl TtParser {\n         &mut self,\n         matcher: &'matcher [MatcherLoc],\n         token: &Token,\n+        approx_position: usize,\n         track: &mut T,\n     ) -> Option<NamedParseResult> {\n         // Matcher positions that would be valid if the macro invocation was over now. Only\n@@ -598,6 +600,7 @@ impl TtParser {\n                         token::Eof,\n                         if token.span.is_dummy() { token.span } else { token.span.shrink_to_hi() },\n                     ),\n+                    approx_position,\n                     \"missing tokens in macro arguments\",\n                 ),\n             })\n@@ -627,7 +630,12 @@ impl TtParser {\n \n             // Process `cur_mps` until either we have finished the input or we need to get some\n             // parsing from the black-box parser done.\n-            let res = self.parse_tt_inner(matcher, &parser.token, track);\n+            let res = self.parse_tt_inner(\n+                matcher,\n+                &parser.token,\n+                parser.approx_token_stream_pos(),\n+                track,\n+            );\n             if let Some(res) = res {\n                 return res;\n             }\n@@ -642,6 +650,7 @@ impl TtParser {\n                     // parser: syntax error.\n                     return Failure(\n                         parser.token.clone(),\n+                        parser.approx_token_stream_pos(),\n                         \"no rules expected this token in macro call\",\n                     );\n                 }"}, {"sha": "fbb806fe81b2fb01cbde5c36b0762ed81811488c", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c52d58f346aea2e2e7ed650ee95785d33500a6d0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c52d58f346aea2e2e7ed650ee95785d33500a6d0/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=c52d58f346aea2e2e7ed650ee95785d33500a6d0", "patch": "@@ -326,8 +326,8 @@ pub(super) fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n \n                 return Ok((i, named_matches));\n             }\n-            Failure(_, _) => {\n-                trace!(\"Failed to match arm, trying the next one\");\n+            Failure(_, reached_position, _) => {\n+                trace!(%reached_position, \"Failed to match arm, trying the next one\");\n                 // Try the next arm.\n             }\n             Error(_, _) => {\n@@ -432,7 +432,7 @@ pub fn compile_declarative_macro(\n     let argument_map =\n         match tt_parser.parse_tt(&mut Cow::Owned(parser), &argument_gram, &mut NoopTracker) {\n             Success(m) => m,\n-            Failure(token, msg) => {\n+            Failure(token, _, msg) => {\n                 let s = parse_failure_msg(&token);\n                 let sp = token.span.substitute_dummy(def.span);\n                 let mut err = sess.parse_sess.span_diagnostic.struct_span_err(sp, &s);"}, {"sha": "919e71bd1155c629bc1f3073c4491fba96da8706", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c52d58f346aea2e2e7ed650ee95785d33500a6d0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c52d58f346aea2e2e7ed650ee95785d33500a6d0/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=c52d58f346aea2e2e7ed650ee95785d33500a6d0", "patch": "@@ -1499,6 +1499,10 @@ impl<'a> Parser<'a> {\n     pub fn clear_expected_tokens(&mut self) {\n         self.expected_tokens.clear();\n     }\n+\n+    pub fn approx_token_stream_pos(&self) -> usize {\n+        self.token_cursor.num_next_calls\n+    }\n }\n \n pub(crate) fn make_unclosed_delims_error("}, {"sha": "bbdd465d5ec96b7896b187427f3e60d29099cdac", "filename": "src/test/ui/macros/best-failure.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c52d58f346aea2e2e7ed650ee95785d33500a6d0/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c52d58f346aea2e2e7ed650ee95785d33500a6d0/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.rs?ref=c52d58f346aea2e2e7ed650ee95785d33500a6d0", "patch": "@@ -0,0 +1,11 @@\n+macro_rules! number {\n+    (neg false, $self:ident) => { $self };\n+    ($signed:tt => $ty:ty;) => {\n+        number!(neg $signed, $self);\n+        //~^ ERROR no rules expected the token `$`\n+    };\n+}\n+\n+number! { false => u8; }\n+\n+fn main() {}"}, {"sha": "a52fc5e3da6a576d95df1db8812690b0dafe3b62", "filename": "src/test/ui/macros/best-failure.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c52d58f346aea2e2e7ed650ee95785d33500a6d0/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c52d58f346aea2e2e7ed650ee95785d33500a6d0/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbest-failure.stderr?ref=c52d58f346aea2e2e7ed650ee95785d33500a6d0", "patch": "@@ -0,0 +1,21 @@\n+error: no rules expected the token `$`\n+  --> $DIR/best-failure.rs:4:30\n+   |\n+LL | macro_rules! number {\n+   | ------------------- when calling this macro\n+...\n+LL |         number!(neg $signed, $self);\n+   |                              ^^^^^ no rules expected this token in macro call\n+...\n+LL | number! { false => u8; }\n+   | ------------------------ in this macro invocation\n+   |\n+note: while trying to match meta-variable `$self:ident`\n+  --> $DIR/best-failure.rs:2:17\n+   |\n+LL |     (neg false, $self:ident) => { $self };\n+   |                 ^^^^^^^^^^^\n+   = note: this error originates in the macro `number` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}]}