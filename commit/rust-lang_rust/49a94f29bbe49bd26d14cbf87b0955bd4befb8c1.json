{"sha": "49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YTk0ZjI5YmJlNDliZDI2ZDE0Y2JmODdiMDk1NWJkNGJlZmI4YzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-18T19:24:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-18T19:24:06Z"}, "message": "Auto merge of #24562 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #24466, #24472, #24532, #24542, #24548\n- Failed merges: #24552", "tree": {"sha": "708d53e4b619fb227aefd191af1d7be2f4121d2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/708d53e4b619fb227aefd191af1d7be2f4121d2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "html_url": "https://github.com/rust-lang/rust/commit/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a81ce5f991148b3c701c6b4276cdcafe366cd8f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a81ce5f991148b3c701c6b4276cdcafe366cd8f4", "html_url": "https://github.com/rust-lang/rust/commit/a81ce5f991148b3c701c6b4276cdcafe366cd8f4"}, {"sha": "88601f8d7d0784a2fe502193b9d98edd3e7d88ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/88601f8d7d0784a2fe502193b9d98edd3e7d88ea", "html_url": "https://github.com/rust-lang/rust/commit/88601f8d7d0784a2fe502193b9d98edd3e7d88ea"}], "stats": {"total": 453, "additions": 318, "deletions": 135}, "files": [{"sha": "c5b2fc8b9531ed5ac691b2a56c3eb8561b895a8a", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -18,7 +18,7 @@ CFG_RELEASE_NUM=1.0.0\n # An optional number to put after the label, e.g. '.2' -> '-beta.2'\n # NB Make sure it starts with a dot to conform to semver pre-release\n # versions (section 9)\n-CFG_PRERELEASE_VERSION=.2\n+CFG_PRERELEASE_VERSION=.3\n \n CFG_FILENAME_EXTRA=4e7c5e5c\n "}, {"sha": "f731a78ef1254b27785db30aa7285dd10934e687", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -124,7 +124,7 @@ Yes. Calling C code from Rust is simple and exactly as efficient as calling C co\n \n Yes. The Rust code has to be exposed via an `extern` declaration, which makes it C-ABI compatible. Such a function can be passed to C code as a function pointer or, if given the `#[no_mangle]` attribute to disable symbol mangling, can be called directly from C code.\n \n-## Why aren't function signatures inferred? Why only local slots?\n+## Why aren't function signatures inferred? Why only local variables?\n \n * Mechanically, it simplifies the inference algorithm; inference only requires looking at one function at a time.\n * The same simplification goes double for human readers. A reader does not need an IDE running an inference algorithm across an entire crate to be able to guess at a function's argument types; it's always explicit and nearby."}, {"sha": "3d9a5bafbd71ea2dba50df0c8c52d4fccd053edb", "filename": "src/doc/grammar.md", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -5,8 +5,7 @@\n This document is the primary reference for the Rust programming language grammar. It\n provides only one kind of material:\n \n-  - Chapters that formally define the language grammar and, for each\n-    construct.\n+  - Chapters that formally define the language grammar.\n \n This document does not serve as an introduction to the language. Background\n familiarity with the language is assumed. A separate [guide] is available to\n@@ -427,7 +426,7 @@ meta_seq : meta_item [ ',' meta_seq ] ? ;\n **FIXME:** grammar?\n \n A _declaration statement_ is one that introduces one or more *names* into the\n-enclosing statement block. The declared names may denote new slots or new\n+enclosing statement block. The declared names may denote new variables or new\n items.\n \n #### Item declarations\n@@ -441,7 +440,7 @@ function, enumeration, structure, type, static, trait, implementation or module\n scope to a narrow region containing all of its uses; it is otherwise identical\n in meaning to declaring the item outside the statement block.\n \n-#### Slot declarations\n+#### Variable declarations\n \n ```antlr\n let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n@@ -763,7 +762,7 @@ bound := path | lifetime\n \n ### Memory ownership\n \n-### Memory slots\n+### Variables\n \n ### Boxes\n "}, {"sha": "c159f6164c20554f4b19f973357dfeb7b67d3691", "filename": "src/doc/reference.md", "status": "modified", "additions": 48, "deletions": 90, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -564,7 +564,7 @@ type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n \n A _path_ is a sequence of one or more path components _logically_ separated by\n a namespace qualifier (`::`). If a path consists of only one component, it may\n-refer to either an [item](#items) or a [slot](#memory-slots) in a local control\n+refer to either an [item](#items) or a [variable](#variables) in a local control\n scope. If a path has multiple components, it refers to an item.\n \n Every item has a _canonical path_ within its crate, but the path naming an item\n@@ -735,13 +735,11 @@ Rust syntax is restricted in two ways:\n \n # Crates and source files\n \n-Rust is a *compiled* language. Its semantics obey a *phase distinction*\n-between compile-time and run-time. Those semantic rules that have a *static\n-interpretation* govern the success or failure of compilation. We refer to\n-these rules as \"static semantics\". Semantic rules called \"dynamic semantics\"\n-govern the behavior of programs at run-time. A program that fails to compile\n-due to violation of a compile-time rule has no defined dynamic semantics; the\n-compiler should halt with an error report, and produce no executable artifact.\n+Rust is a *compiled* language. Its semantics obey a *phase distinction* between\n+compile-time and run-time. Those semantic rules that have a *static\n+interpretation* govern the success or failure of compilation. Those semantics\n+that have a *dynamic interpretation* govern the behavior of the program at\n+run-time.\n \n The compilation model centers on artifacts called _crates_. Each compilation\n processes a single crate in source form, and if successful, produces a single\n@@ -1064,9 +1062,9 @@ fn main() {}\n A _function item_ defines a sequence of [statements](#statements) and an\n optional final [expression](#expressions), along with a name and a set of\n parameters. Functions are declared with the keyword `fn`. Functions declare a\n-set of *input* [*slots*](#memory-slots) as parameters, through which the caller\n-passes arguments into the function, and an *output* [*slot*](#memory-slots)\n-through which the function passes results back to the caller.\n+set of *input* [*variables*](#variables) as parameters, through which the caller\n+passes arguments into the function, and the *output* [*type*](#types)\n+of the value the function will return to its caller on completion.\n \n A function may also be copied into a first-class *value*, in which case the\n value has the corresponding [*function type*](#function-types), and can be used\n@@ -1229,7 +1227,7 @@ be undesired.\n #### Diverging functions\n \n A special kind of function can be declared with a `!` character where the\n-output slot type would normally be. For example:\n+output type would normally be. For example:\n \n ```\n fn my_err(s: &str) -> ! {\n@@ -1302,18 +1300,11 @@ contiguous stack segments like C.\n \n A _type alias_ defines a new name for an existing [type](#types). Type\n aliases are declared with the keyword `type`. Every value has a single,\n-specific type; the type-specified aspects of a value include:\n+specific type, but may implement several different traits, or be compatible with\n+several different type constraints.\n \n-* Whether the value is composed of sub-values or is indivisible.\n-* Whether the value represents textual or numerical information.\n-* Whether the value represents integral or floating-point information.\n-* The sequence of memory operations required to access the value.\n-* The [kind](#type-kinds) of the type.\n-\n-For example, the type `(u8, u8)` defines the set of immutable values that are\n-composite pairs, each containing two unsigned 8-bit integers accessed by\n-pattern-matching and laid out in memory with the `x` component preceding the\n-`y` component:\n+For example, the following defines the type `Point` as a synonym for the type\n+`(u8, u8)`, the type of pairs of unsigned 8 bit integers.:\n \n ```\n type Point = (u8, u8);\n@@ -2551,7 +2542,7 @@ statements](#expression-statements).\n ### Declaration statements\n \n A _declaration statement_ is one that introduces one or more *names* into the\n-enclosing statement block. The declared names may denote new slots or new\n+enclosing statement block. The declared names may denote new variables or new\n items.\n \n #### Item declarations\n@@ -2566,18 +2557,18 @@ in meaning to declaring the item outside the statement block.\n > **Note**: there is no implicit capture of the function's dynamic environment when\n > declaring a function-local item.\n \n-#### Slot declarations\n+#### Variable declarations\n \n ```{.ebnf .gram}\n let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n init : [ '=' ] expr ;\n ```\n \n-A _slot declaration_ introduces a new set of slots, given by a pattern. The\n+A _variable declaration_ introduces a new set of variable, given by a pattern. The\n pattern may be followed by a type annotation, and/or an initializer expression.\n When no type annotation is given, the compiler will infer the type, or signal\n an error if insufficient type information is available for definite inference.\n-Any slots introduced by a slot declaration are visible from the point of\n+Any variables introduced by a variable declaration are visible from the point of\n declaration until the end of the enclosing block scope.\n \n ### Expression statements\n@@ -2632,7 +2623,7 @@ of any reference that points to it.\n \n #### Moved and copied types\n \n-When a [local variable](#memory-slots) is used as an\n+When a [local variable](#variables) is used as an\n [rvalue](#lvalues,-rvalues-and-temporaries) the variable will either be moved\n or copied, depending on its type. All values whose type implements `Copy` are\n copied, all others are moved.\n@@ -3042,10 +3033,9 @@ paren_expr_list : '(' expr_list ')' ;\n call_expr : expr paren_expr_list ;\n ```\n \n-A _call expression_ invokes a function, providing zero or more input slots and\n-an optional reference slot to serve as the function's output, bound to the\n-`lval` on the right hand side of the call. If the function eventually returns,\n-then the expression completes.\n+A _call expression_ invokes a function, providing zero or more input variables\n+and an optional location to move the function's output into. If the function\n+eventually returns, then the expression completes.\n \n Some examples of call expressions:\n \n@@ -3456,9 +3446,9 @@ return_expr : \"return\" expr ? ;\n ```\n \n Return expressions are denoted with the keyword `return`. Evaluating a `return`\n-expression moves its argument into the output slot of the current function,\n-destroys the current function activation frame, and transfers control to the\n-caller frame.\n+expression moves its argument into the designated output location for the\n+current function call, destroys the current function activation frame, and\n+transfers control to the caller frame.\n \n An example of a `return` expression:\n \n@@ -3475,7 +3465,7 @@ fn max(a: i32, b: i32) -> i32 {\n \n ## Types\n \n-Every slot, item and value in a Rust program has a type. The _type_ of a\n+Every variable, item and value in a Rust program has a type. The _type_ of a\n *value* defines the interpretation of the memory holding it.\n \n Built-in types and type-constructors are tightly integrated into the language,\n@@ -3493,7 +3483,7 @@ The primitive types are the following:\n * The machine-dependent integer and floating-point types.\n \n [^unittype]: The \"unit\" value `()` is *not* a sentinel \"null pointer\" value for\n-    reference slots; the \"unit\" type is the implicit return type from functions\n+    reference variables; the \"unit\" type is the implicit return type from functions\n     otherwise lacking a return type, and can be used in other contexts (such as\n     message-sending or type-parametric code) as a zero-size type.]\n \n@@ -3831,29 +3821,33 @@ impl Printable for String {\n `self` refers to the value of type `String` that is the receiver for a call to\n the method `make_string`.\n \n-# The `Copy` trait\n+# Special traits\n+\n+Several traits define special evaluation behavior.\n \n-Rust has a special trait, `Copy`, which when implemented changes the semantics\n-of a value. Values whose type implements `Copy` are copied rather than moved\n-upon assignment.\n+## The `Copy` trait\n \n-# The `Sized` trait\n+The `Copy` trait changes the semantics of a type implementing it. Values whose\n+type implements `Copy` are copied rather than moved upon assignment.\n \n-`Sized` is a special trait which indicates that the size of this type is known\n-at compile-time.\n+## The `Sized` trait\n \n-# The `Drop` trait\n+The `Sized` trait indicates that the size of this type is known at compile-time.\n+\n+## The `Drop` trait\n \n The `Drop` trait provides a destructor, to be run whenever a value of this type\n is to be destroyed.\n \n # Memory model\n \n A Rust program's memory consists of a static set of *items* and a *heap*.\n-Immutable portions of the heap may be shared between threads, mutable portions\n-may not.\n+Immutable portions of the heap may be safely shared between threads, mutable\n+portions may not be safely shared, but several mechanisms for effectively-safe\n+sharing of mutable values, built on unsafe code but enforcing a safe locking\n+discipline, exist in the standard library.\n \n-Allocations in the stack consist of *slots*, and allocations in the heap\n+Allocations in the stack consist of *variables*, and allocations in the heap\n consist of *boxes*.\n \n ### Memory allocation and lifetime\n@@ -3872,10 +3866,11 @@ in the heap, heap allocations may outlive the frame they are allocated within.\n When a stack frame is exited, its local allocations are all released, and its\n references to boxes are dropped.\n \n-### Memory slots\n+### Variables\n \n-A _slot_ is a component of a stack frame, either a function parameter, a\n-[temporary](#lvalues,-rvalues-and-temporaries), or a local variable.\n+A _variable_ is a component of a stack frame, either a named function parameter,\n+an anonymous [temporary](#lvalues,-rvalues-and-temporaries), or a named local\n+variable.\n \n A _local variable_ (or *stack-local* allocation) holds a value directly,\n allocated within the stack's memory. The value is a part of the stack frame.\n@@ -3888,7 +3883,7 @@ Box<i32>, y: Box<i32>)` declare one mutable variable `x` and one immutable\n variable `y`).\n \n Methods that take either `self` or `Box<Self>` can optionally place them in a\n-mutable slot by prefixing them with `mut` (similar to regular arguments):\n+mutable variable by prefixing them with `mut` (similar to regular arguments):\n \n ```\n trait Changer {\n@@ -3903,44 +3898,7 @@ state. Subsequent statements within a function may or may not initialize the\n local variables. Local variables can be used only after they have been\n initialized; this is enforced by the compiler.\n \n-# Runtime services, linkage and debugging\n-\n-The Rust _runtime_ is a relatively compact collection of Rust code that\n-provides fundamental services and datatypes to all Rust threads at run-time. It\n-is smaller and simpler than many modern language runtimes. It is tightly\n-integrated into the language's execution model of memory, threads, communication\n-and logging.\n-\n-### Memory allocation\n-\n-The runtime memory-management system is based on a _service-provider\n-interface_, through which the runtime requests blocks of memory from its\n-environment and releases them back to its environment when they are no longer\n-needed. The default implementation of the service-provider interface consists\n-of the C runtime functions `malloc` and `free`.\n-\n-The runtime memory-management system, in turn, supplies Rust threads with\n-facilities for allocating releasing stacks, as well as allocating and freeing\n-heap data.\n-\n-### Built in types\n-\n-The runtime provides C and Rust code to assist with various built-in types,\n-such as arrays, strings, and the low level communication system (ports,\n-channels, threads).\n-\n-Support for other built-in types such as simple types, tuples and enums is\n-open-coded by the Rust compiler.\n-\n-### Thread scheduling and communication\n-\n-The runtime provides code to manage inter-thread communication. This includes\n-the system of thread-lifecycle state transitions depending on the contents of\n-queues, as well as code to copy values between queues and their recipients and\n-to serialize values for transmission over operating-system inter-process\n-communication facilities.\n-\n-### Linkage\n+# Linkage\n \n The Rust compiler supports various methods to link crates together both\n statically and dynamically. This section will explore the various methods to"}, {"sha": "cfcd8c4ee155a209c31beb0115f68cb28c1b8f6e", "filename": "src/doc/trpl/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Ftrpl%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Ftrpl%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flifetimes.md?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -1,3 +1,3 @@\n % Lifetimes\n \n-Coming soon!\n+Coming Soon! Until then, check out the [ownership](ownership.html) chapter."}, {"sha": "b5bd53e1d75a14bc6ad23ddc81756403916a1fa1", "filename": "src/doc/trpl/move-semantics.md", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Ftrpl%2Fmove-semantics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmove-semantics.md?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -1,3 +1,105 @@\n % Move Semantics\n \n-Coming Soon\n+An important aspect of [ownership][ownership] is \u2018move semantics\u2019. Move\n+semantics control how and when ownership is transferred between bindings.\n+\n+[ownership]: ownership.html\n+\n+For example, consider a type like `Vec<T>`, which owns its contents:\n+\n+```rust\n+let v = vec![1, 2, 3];\n+```\n+\n+I can assign this vector to another binding:\n+\n+```rust\n+let v = vec![1, 2, 3];\n+\n+let v2 = v;\n+```\n+\n+But, if we try to use `v` afterwards, we get an error:\n+\n+```rust,ignore\n+let v = vec![1, 2, 3];\n+\n+let v2 = v;\n+\n+println!(\"v[0] is: {}\", v[0]);\n+```\n+\n+It looks like this:\n+\n+```text\n+error: use of moved value: `v`\n+println!(\"v[0] is: {}\", v[0]);\n+                        ^\n+```\n+\n+A similar thing happens if we define a function which takes ownership, and\n+try to use something after we\u2019ve passed it as an argument:\n+\n+```rust,ignore\n+fn take(v: Vec<i32>) {\n+    // what happens here isn\u2019t important.\n+}\n+\n+let v = vec![1, 2, 3];\n+\n+take(v);\n+\n+println!(\"v[0] is: {}\", v[0]);\n+```\n+\n+Same error: \u201cuse of moved value.\u201d When we transfer ownership to something else,\n+we say that we\u2019ve \u2018moved\u2019 the thing we refer to. You don\u2019t need some sort of\n+special annotation here, it\u2019s the default thing that Rust does.\n+\n+# The details\n+\n+The reason that we cannot use a binding after we\u2019ve moved it is subtle, but\n+important. When we write code like this:\n+\n+```rust\n+let v = vec![1, 2, 3];\n+\n+let v2 = v;\n+```\n+\n+The first line creates some data for the vector on the stack, `v`. The vector\u2019s\n+data, however, is stored on the heap, and so it contains a pointer to that\n+data. When we move `v` to `v2`, it creates a copy of that data, for `v2`. Which\n+would mean two pointers to the contents of the vector on the heap. That would\n+be a problem: it would violate Rust\u2019s safety guarantees by introducing a data\n+race. Therefore, Rust forbids using `v` after we\u2019ve done the move.\n+\n+It\u2019s also important to note that optimizations may remove the actual copy of\n+the bytes, depending on circumstances. So it may not be as inefficient as it\n+initially seems.\n+\n+# `Copy` types\n+\n+We\u2019ve established that when ownership is transferred to another binding, you\n+cannot use the original binding. However, there\u2019s a [trait][traits] that changes this\n+behavior, and it\u2019s called `Copy`. We haven\u2019t discussed traits yet, but for now,\n+you can think of them as an annotation to a particular type that adds extra\n+behavior. For example:\n+\n+```rust\n+let v = 1;\n+\n+let v2 = v;\n+\n+println!(\"v is: {}\", v);\n+```\n+\n+In this case, `v` is an `i32`, which implements the `Copy` trait. This means\n+that, just like a move, when we assign `v` to `v2`, a copy of the data is made.\n+But, unlike a move, we can still use `v` afterward. This is because an `i32`\n+has no pointers to data somewhere else, copying it is a full copy.\n+\n+We will discuss how to make your own types `Copy` in the [traits][traits]\n+section.\n+\n+[traits]: traits.html"}, {"sha": "0e13ea612645cf5a101154d671c70e052bd24d81", "filename": "src/doc/trpl/references-and-borrowing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Freferences-and-borrowing.md?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -1,3 +1,3 @@\n % References and Borrowing\n \n-Coming Soon!\n+Coming Soon! Until then, check out the [ownership](ownership.html) chapter."}, {"sha": "306d2cd102fdb8f2456acbf068d3d27b9a041d8f", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 96, "deletions": 19, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -55,15 +55,17 @@ underscore `_` wildcard pattern can be added after all other patterns to match\n \n // FIXME: Remove duplication here?\n E0005: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n-name will be extracted in all cases. If you encounter this error you probably need\n-to use a `match` or `if let` to deal with the possibility of failure.\n+Patterns used to bind names must be irrefutable, that is, they must guarantee\n+that a name will be extracted in all cases. If you encounter this error you\n+probably need to use a `match` or `if let` to deal with the possibility of\n+failure.\n \"##,\n \n E0006: r##\"\n-Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n-name will be extracted in all cases. If you encounter this error you probably need\n-to use a `match` or `if let` to deal with the possibility of failure.\n+Patterns used to bind names must be irrefutable, that is, they must guarantee\n+that a name will be extracted in all cases. If you encounter this error you\n+probably need to use a `match` or `if let` to deal with the possibility of\n+failure.\n \"##,\n \n E0007: r##\"\n@@ -112,6 +114,65 @@ reference when using guards or refactor the entire expression, perhaps by\n putting the condition inside the body of the arm.\n \"##,\n \n+E0009: r##\"\n+In a pattern, all values that don't implement the `Copy` trait have to be bound\n+the same way. The goal here is to avoid binding simultaneously by-move and\n+by-ref.\n+\n+This limitation may be removed in a future version of Rust.\n+\n+Wrong example:\n+\n+```\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {},\n+    None => panic!()\n+}\n+```\n+\n+You have two solutions:\n+1. Bind the pattern's values the same way:\n+\n+```\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((ref y, ref z)) => {},\n+    // or Some((y, z)) => {}\n+    None => panic!()\n+}\n+```\n+\n+2. Implement the `Copy` trait for the X structure (however, please\n+keep in mind that the first solution should be preferred!):\n+\n+```\n+#[derive(Clone, Copy)]\n+struct X { x: (), }\n+\n+let x = Some((X { x: () }, X { x: () }));\n+match x {\n+    Some((y, ref z)) => {},\n+    None => panic!()\n+}\n+```\n+\"##,\n+\n+E0015: r##\"\n+The only function calls allowed in static or constant expressions are enum\n+variant constructors or struct constructors (for unit or tuple structs). This\n+is because Rust currently does not support compile-time function execution.\n+\"##,\n+\n+E0020: r##\"\n+This error indicates that an attempt was made to divide by zero (or take the\n+remainder of a zero divisor) in a static or constant expression.\n+\"##,\n+\n E0152: r##\"\n Lang items are already implemented in the standard library. Unless you are\n writing a free-standing application (e.g. a kernel), you do not need to provide\n@@ -217,6 +278,26 @@ use Method::*;\n enum Method { GET, POST }\n \"##,\n \n+E0267: r##\"\n+This error indicates the use of loop keyword (break or continue) inside a\n+closure but outside of any loop. Break and continue can be used as normal\n+inside closures as long as they are also contained within a loop. To halt the\n+execution of a closure you should instead use a return statement.\n+\"##,\n+\n+E0268: r##\"\n+This error indicates the use of loop keyword (break or continue) outside of a\n+loop. Without a loop to break out of or continue in, no sensible action can be\n+taken.\n+\"##,\n+\n+E0296: r##\"\n+This error indicates that the given recursion limit could not be parsed. Ensure\n+that the value provided is a positive integer between quotes, like so:\n+\n+#![recursion_limit=\"1000\"]\n+\"##,\n+\n E0297: r##\"\n Patterns used to bind names must be irrefutable. That is, they must guarantee\n that a name will be extracted in all cases. Instead of pattern matching the\n@@ -277,21 +358,23 @@ In certain cases it is possible for sub-bindings to violate memory safety.\n Updates to the borrow checker in a future version of Rust may remove this\n restriction, but for now patterns must be rewritten without sub-bindings.\n \n-// Code like this...\n-match Some(5) {\n-    ref op_num @ Some(num) => ...\n+// Before.\n+match Some(\"hi\".to_string()) {\n+    ref op_string_ref @ Some(ref s) => ...\n     None => ...\n }\n \n-// ... should be updated to code like this.\n-match Some(5) {\n-    Some(num) => {\n-        let op_num = &Some(num);\n+// After.\n+match Some(\"hi\".to_string()) {\n+    Some(ref s) => {\n+        let op_string_ref = &Some(&s);\n         ...\n     }\n     None => ...\n }\n \n+The `op_string_ref` binding has type &Option<&String> in both cases.\n+\n See also https://github.com/rust-lang/rust/issues/14587\n \"##,\n \n@@ -308,18 +391,15 @@ a compile-time constant.\n }\n \n register_diagnostics! {\n-    E0009,\n     E0010,\n     E0011,\n     E0012,\n     E0013,\n     E0014,\n-    E0015,\n     E0016,\n     E0017,\n     E0018,\n     E0019,\n-    E0020,\n     E0022,\n     E0079, // enum variant: expected signed integer constant\n     E0080, // enum variant: constant evaluation error\n@@ -338,8 +418,6 @@ register_diagnostics! {\n     E0264, // unknown external lang item\n     E0265, // recursive constant\n     E0266, // expected item\n-    E0267, // thing inside of a closure\n-    E0268, // thing outside of a loop\n     E0269, // not all control paths return a value\n     E0270, // computation may converge in a function marked as diverging\n     E0271, // type mismatch resolving\n@@ -357,7 +435,6 @@ register_diagnostics! {\n     E0283, // cannot resolve type\n     E0284, // cannot resolve type\n     E0285, // overflow evaluation builtin bounds\n-    E0296, // malformed recursion limit attribute\n     E0298, // mismatched types between arms\n     E0299, // mismatched types between arms\n     E0300, // unexpanded macro"}, {"sha": "ffa068a2ae44b80f39001abe1370605964416ec7", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -880,7 +880,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         CEnum(ity, min, max) => {\n             assert_discr_in_range(ity, min, max, discr);\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n-                  val)\n+                  val);\n         }\n         General(ity, ref cases, dtor) => {\n             if dtor_active(dtor) {\n@@ -889,7 +889,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                 Store(bcx, C_u8(bcx.ccx(), DTOR_NEEDED as usize), ptr);\n             }\n             Store(bcx, C_integral(ll_inttype(bcx.ccx(), ity), discr as u64, true),\n-                  GEPi(bcx, val, &[0, 0]))\n+                  GEPi(bcx, val, &[0, 0]));\n         }\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n@@ -901,14 +901,14 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         RawNullablePointer { nndiscr, nnty, ..} => {\n             if discr != nndiscr {\n                 let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n-                Store(bcx, C_null(llptrty), val)\n+                Store(bcx, C_null(llptrty), val);\n             }\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             if discr != nndiscr {\n                 let llptrptr = GEPi(bcx, val, &discrfield[..]);\n                 let llptrty = val_ty(llptrptr).element_type();\n-                Store(bcx, C_null(llptrty), llptrptr)\n+                Store(bcx, C_null(llptrty), llptrptr);\n             }\n         }\n     }"}, {"sha": "59f3ff72602616f0dfe246234a55fd94f501b385", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -765,9 +765,14 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     }\n \n     let ptr = to_arg_ty_ptr(cx, ptr, t);\n+    let align = type_of::align_of(cx.ccx(), t);\n \n     if type_is_immediate(cx.ccx(), t) && type_of::type_of(cx.ccx(), t).is_aggregate() {\n-        return Load(cx, ptr);\n+        let load = Load(cx, ptr);\n+        unsafe {\n+            llvm::LLVMSetAlignment(load, align);\n+        }\n+        return load;\n     }\n \n     unsafe {\n@@ -793,13 +798,24 @@ pub fn load_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         Load(cx, ptr)\n     };\n \n+    unsafe {\n+        llvm::LLVMSetAlignment(val, align);\n+    }\n+\n     from_arg_ty(cx, val, t)\n }\n \n /// Helper for storing values in memory. Does the necessary conversion if the in-memory type\n /// differs from the type used for SSA values.\n pub fn store_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n-    Store(cx, to_arg_ty(cx, v, t), to_arg_ty_ptr(cx, dst, t));\n+    if cx.unreachable.get() {\n+        return;\n+    }\n+\n+    let store = Store(cx, to_arg_ty(cx, v, t), to_arg_ty_ptr(cx, dst, t));\n+    unsafe {\n+        llvm::LLVMSetAlignment(store, type_of::align_of(cx.ccx(), t));\n+    }\n }\n \n pub fn to_arg_ty(bcx: Block, val: ValueRef, ty: Ty) -> ValueRef {"}, {"sha": "32d73e50e6b6bf1b3cef7a46f21c907be169a5fc", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -646,13 +646,13 @@ pub fn LoadNonNull(cx: Block, ptr: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn Store(cx: Block, val: ValueRef, ptr: ValueRef) {\n-    if cx.unreachable.get() { return; }\n+pub fn Store(cx: Block, val: ValueRef, ptr: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return C_nil(cx.ccx()); }\n     B(cx).store(val, ptr)\n }\n \n-pub fn VolatileStore(cx: Block, val: ValueRef, ptr: ValueRef) {\n-    if cx.unreachable.get() { return; }\n+pub fn VolatileStore(cx: Block, val: ValueRef, ptr: ValueRef) -> ValueRef {\n+    if cx.unreachable.get() { return C_nil(cx.ccx()); }\n     B(cx).volatile_store(val, ptr)\n }\n "}, {"sha": "3febd41bdce2eccbdccf71ff79947fa68e48639c", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -509,18 +509,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         value\n     }\n \n-    pub fn store(&self, val: ValueRef, ptr: ValueRef) {\n+    pub fn store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n         debug!(\"Store {} -> {}\",\n                self.ccx.tn().val_to_string(val),\n                self.ccx.tn().val_to_string(ptr));\n         assert!(!self.llbuilder.is_null());\n         self.count_insn(\"store\");\n         unsafe {\n-            llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n+            llvm::LLVMBuildStore(self.llbuilder, val, ptr)\n         }\n     }\n \n-    pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) {\n+    pub fn volatile_store(&self, val: ValueRef, ptr: ValueRef) -> ValueRef {\n         debug!(\"Store {} -> {}\",\n                self.ccx.tn().val_to_string(val),\n                self.ccx.tn().val_to_string(ptr));\n@@ -529,6 +529,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         unsafe {\n             let insn = llvm::LLVMBuildStore(self.llbuilder, val, ptr);\n             llvm::LLVMSetVolatile(insn, llvm::True);\n+            insn\n         }\n     }\n "}, {"sha": "c025be2ee98772eb7241dd565501c90a77bbe757", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -802,7 +802,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     // appropriately sized integer and we have to convert it\n                     let tmp = builder.bitcast(llforeign_arg,\n                                               type_of::arg_type_of(ccx, rust_ty).ptr_to());\n-                    builder.load(tmp)\n+                    let load = builder.load(tmp);\n+                    llvm::LLVMSetAlignment(load, type_of::align_of(ccx, rust_ty));\n+                    load\n                 } else {\n                     builder.load(llforeign_arg)\n                 }"}, {"sha": "1e67212871a1e10e3b765e417f51f936afe29a3d", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -456,13 +456,20 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"volatile_load\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n-            from_arg_ty(bcx, VolatileLoad(bcx, ptr), tp_ty)\n+            let load = VolatileLoad(bcx, ptr);\n+            unsafe {\n+                llvm::LLVMSetAlignment(load, type_of::align_of(ccx, tp_ty));\n+            }\n+            from_arg_ty(bcx, load, tp_ty)\n         },\n         (_, \"volatile_store\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let ptr = to_arg_ty_ptr(bcx, llargs[0], tp_ty);\n             let val = to_arg_ty(bcx, llargs[1], tp_ty);\n-            VolatileStore(bcx, val, ptr);\n+            let store = VolatileStore(bcx, val, ptr);\n+            unsafe {\n+                llvm::LLVMSetAlignment(store, type_of::align_of(ccx, tp_ty));\n+            }\n             C_nil(ccx)\n         },\n "}, {"sha": "6fcf39f0b174bf5ec4b57626740b707fc4fe9029", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a94f29bbe49bd26d14cbf87b0955bd4befb8c1/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=49a94f29bbe49bd26d14cbf87b0955bd4befb8c1", "patch": "@@ -20,6 +20,9 @@ use parse::token;\n use ptr::P;\n use util::small_vector::SmallVector;\n \n+// Maximum width of any line in an extended error description (inclusive).\n+const MAX_DESCRIPTION_WIDTH: usize = 80;\n+\n thread_local! {\n     static REGISTERED_DIAGNOSTICS: RefCell<BTreeMap<Name, Option<Name>>> = {\n         RefCell::new(BTreeMap::new())\n@@ -92,6 +95,24 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n         }\n         _ => unreachable!()\n     };\n+    // Check that the description starts and ends with a newline and doesn't\n+    // overflow the maximum line width.\n+    description.map(|raw_msg| {\n+        let msg = raw_msg.as_str();\n+        if !msg.starts_with(\"\\n\") || !msg.ends_with(\"\\n\") {\n+            ecx.span_err(span, &format!(\n+                \"description for error code {} doesn't start and end with a newline\",\n+                token::get_ident(*code)\n+            ));\n+        }\n+        if msg.lines().any(|line| line.len() > MAX_DESCRIPTION_WIDTH) {\n+            ecx.span_err(span, &format!(\n+                \"description for error code {} contains a line longer than {} characters\",\n+                token::get_ident(*code), MAX_DESCRIPTION_WIDTH\n+            ));\n+        }\n+        raw_msg\n+    });\n     with_registered_diagnostics(|diagnostics| {\n         if diagnostics.insert(code.name, description).is_some() {\n             ecx.span_err(span, &format!("}]}