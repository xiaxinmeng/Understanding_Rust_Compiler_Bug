{"sha": "7156ded5bcf6831a6da22688d08f71985fdc81df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNTZkZWQ1YmNmNjgzMWE2ZGEyMjY4OGQwOGY3MTk4NWZkYzgxZGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-16T12:11:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-16T12:11:18Z"}, "message": "auto merge of #12924 : Florob/rust/bigint, r=alexcrichton\n\nThis is a minor optimization of the bignum module. The improvements mostly come from avoiding allocations and boundary checks. This also switches all of libnum to vec_ng::Vec.", "tree": {"sha": "50de17f552553387019becca487b94c510a8b6b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50de17f552553387019becca487b94c510a8b6b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7156ded5bcf6831a6da22688d08f71985fdc81df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7156ded5bcf6831a6da22688d08f71985fdc81df", "html_url": "https://github.com/rust-lang/rust/commit/7156ded5bcf6831a6da22688d08f71985fdc81df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7156ded5bcf6831a6da22688d08f71985fdc81df/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d73c899383249e14d9ab74745167f502c31295d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d73c899383249e14d9ab74745167f502c31295d3", "html_url": "https://github.com/rust-lang/rust/commit/d73c899383249e14d9ab74745167f502c31295d3"}, {"sha": "ce2ce2410f17be55393f512432ae4760e03069b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce2ce2410f17be55393f512432ae4760e03069b2", "html_url": "https://github.com/rust-lang/rust/commit/ce2ce2410f17be55393f512432ae4760e03069b2"}], "stats": {"total": 362, "additions": 176, "deletions": 186}, "files": [{"sha": "4fcd1a6afb82b331a924784e0d71b6cf2c21603c", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 169, "deletions": 180, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/7156ded5bcf6831a6da22688d08f71985fdc81df/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7156ded5bcf6831a6da22688d08f71985fdc81df/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=7156ded5bcf6831a6da22688d08f71985fdc81df", "patch": "@@ -27,8 +27,9 @@ use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n use rand::Rng;\n use std::str;\n use std::uint;\n-use std::vec;\n use std::{i64, u64};\n+use std::vec_ng;\n+use std::vec_ng::Vec;\n \n /**\n A `BigDigit` is a `BigUint`'s composing element.\n@@ -47,6 +48,7 @@ A `BigDigit` is half the size of machine word size.\n pub type BigDigit = u32;\n \n pub static ZERO_BIG_DIGIT: BigDigit = 0;\n+static ZERO_VEC: [BigDigit, ..1] = [ZERO_BIG_DIGIT];\n \n pub mod BigDigit {\n     use super::BigDigit;\n@@ -86,7 +88,7 @@ A `BigUint`-typed value `BigUint { data: ~[a, b, c] }` represents a number\n */\n #[deriving(Clone)]\n pub struct BigUint {\n-    priv data: ~[BigDigit]\n+    priv data: Vec<BigDigit>\n }\n \n impl Eq for BigUint {\n@@ -140,37 +142,28 @@ impl Num for BigUint {}\n \n impl BitAnd<BigUint, BigUint> for BigUint {\n     fn bitand(&self, other: &BigUint) -> BigUint {\n-        let new_len = cmp::min(self.data.len(), other.data.len());\n-        let anded = vec::from_fn(new_len, |i| {\n-            // i will never be less than the size of either data vector\n-            let ai = self.data[i];\n-            let bi = other.data[i];\n-            ai & bi\n-        });\n-        return BigUint::new(anded);\n+        BigUint::new(self.data.iter().zip(other.data.iter()).map(|(ai, bi)| *ai & *bi).collect())\n     }\n }\n \n impl BitOr<BigUint, BigUint> for BigUint {\n     fn bitor(&self, other: &BigUint) -> BigUint {\n-        let new_len = cmp::max(self.data.len(), other.data.len());\n-        let ored = vec::from_fn(new_len, |i| {\n-            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n-            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n-            ai | bi\n-        });\n+        let zeros = ZERO_VEC.iter().cycle();\n+        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n+        let ored = a.data.iter().zip(b.data.iter().chain(zeros)).map(\n+            |(ai, bi)| *ai | *bi\n+        ).collect();\n         return BigUint::new(ored);\n     }\n }\n \n impl BitXor<BigUint, BigUint> for BigUint {\n     fn bitxor(&self, other: &BigUint) -> BigUint {\n-        let new_len = cmp::max(self.data.len(), other.data.len());\n-        let xored = vec::from_fn(new_len, |i| {\n-            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n-            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n-            ai ^ bi\n-        });\n+        let zeros = ZERO_VEC.iter().cycle();\n+        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n+        let xored = a.data.iter().zip(b.data.iter().chain(zeros)).map(\n+            |(ai, bi)| *ai ^ *bi\n+        ).collect();\n         return BigUint::new(xored);\n     }\n }\n@@ -195,33 +188,30 @@ impl Shr<uint, BigUint> for BigUint {\n \n impl Zero for BigUint {\n     #[inline]\n-    fn zero() -> BigUint { BigUint::new(~[]) }\n+    fn zero() -> BigUint { BigUint::new(Vec::new()) }\n \n     #[inline]\n     fn is_zero(&self) -> bool { self.data.is_empty() }\n }\n \n impl One for BigUint {\n     #[inline]\n-    fn one() -> BigUint { BigUint::new(~[1]) }\n+    fn one() -> BigUint { BigUint::new(vec!(1)) }\n }\n \n impl Unsigned for BigUint {}\n \n impl Add<BigUint, BigUint> for BigUint {\n     fn add(&self, other: &BigUint) -> BigUint {\n-        let new_len = cmp::max(self.data.len(), other.data.len());\n+        let zeros = ZERO_VEC.iter().cycle();\n+        let (a, b) = if self.data.len() > other.data.len() { (self, other) } else { (other, self) };\n \n         let mut carry = 0;\n-        let mut sum = vec::from_fn(new_len, |i| {\n-            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n-            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n-            let (hi, lo) = BigDigit::from_uint(\n-                (ai as uint) + (bi as uint) + (carry as uint)\n-            );\n+        let mut sum: Vec<BigDigit> =  a.data.iter().zip(b.data.iter().chain(zeros)).map(|(ai, bi)| {\n+            let (hi, lo) = BigDigit::from_uint((*ai as uint) + (*bi as uint) + (carry as uint));\n             carry = hi;\n             lo\n-        });\n+        }).collect();\n         if carry != 0 { sum.push(carry); }\n         return BigUint::new(sum);\n     }\n@@ -230,22 +220,21 @@ impl Add<BigUint, BigUint> for BigUint {\n impl Sub<BigUint, BigUint> for BigUint {\n     fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = cmp::max(self.data.len(), other.data.len());\n+        let zeros = ZERO_VEC.iter().cycle();\n+        let (a, b) = (self.data.iter().chain(zeros.clone()), other.data.iter().chain(zeros));\n \n         let mut borrow = 0;\n-        let diff = vec::from_fn(new_len, |i| {\n-            let ai = if i < self.data.len()  { self.data[i]  } else { 0 };\n-            let bi = if i < other.data.len() { other.data[i] } else { 0 };\n+        let diff: Vec<BigDigit> =  a.take(new_len).zip(b).map(|(ai, bi)| {\n             let (hi, lo) = BigDigit::from_uint(\n-                (BigDigit::base) +\n-                (ai as uint) - (bi as uint) - (borrow as uint)\n+                BigDigit::base + (*ai as uint) - (*bi as uint) - (borrow as uint)\n             );\n             /*\n             hi * (base) + lo == 1*(base) + ai - bi - borrow\n             => ai - bi - borrow < 0 <=> hi == 0\n             */\n             borrow = if hi == 0 { 1 } else { 0 };\n             lo\n-        });\n+        }).collect();\n \n         assert_eq!(borrow, 0);     // <=> assert!((self >= other));\n         return BigUint::new(diff);\n@@ -257,8 +246,8 @@ impl Mul<BigUint, BigUint> for BigUint {\n         if self.is_zero() || other.is_zero() { return Zero::zero(); }\n \n         let (s_len, o_len) = (self.data.len(), other.data.len());\n-        if s_len == 1 { return mul_digit(other, self.data[0]);  }\n-        if o_len == 1 { return mul_digit(self,  other.data[0]); }\n+        if s_len == 1 { return mul_digit(other, self.data.as_slice()[0]);  }\n+        if o_len == 1 { return mul_digit(self,  other.data.as_slice()[0]); }\n \n         // Using Karatsuba multiplication\n         // (a1 * base + a0) * (b1 * base + b0)\n@@ -289,13 +278,13 @@ impl Mul<BigUint, BigUint> for BigUint {\n             if n == 1 { return (*a).clone(); }\n \n             let mut carry = 0;\n-            let mut prod = a.data.iter().map(|ai| {\n+            let mut prod: Vec<BigDigit> = a.data.iter().map(|ai| {\n                 let (hi, lo) = BigDigit::from_uint(\n                     (*ai as uint) * (n as uint) + (carry as uint)\n                 );\n                 carry = hi;\n                 lo\n-            }).collect::<~[BigDigit]>();\n+            }).collect();\n             if carry != 0 { prod.push(carry); }\n             return BigUint::new(prod);\n         }\n@@ -451,24 +440,25 @@ impl Integer for BigUint {\n                 return (Zero::zero(), Zero::zero(), (*a).clone());\n             }\n \n-            let an = a.data.slice(a.data.len() - n, a.data.len());\n+            let an = a.data.tailn(a.data.len() - n);\n             let bn = *b.data.last().unwrap();\n-            let mut d = ~[];\n+            let mut d = Vec::with_capacity(an.len());\n             let mut carry = 0;\n             for elt in an.rev_iter() {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n                 assert!(di < BigDigit::base);\n                 carry = (ai % (bn as uint)) as BigDigit;\n-                d = ~[di as BigDigit] + d;\n+                d.push(di as BigDigit)\n             }\n+            d.reverse();\n \n             let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n             if shift == 0 {\n                 return (BigUint::new(d), One::one(), (*b).clone());\n             }\n             let one: BigUint = One::one();\n-            return (BigUint::from_slice(d).shl_unit(shift),\n+            return (BigUint::new(d).shl_unit(shift),\n                     one.shl_unit(shift),\n                     b.shl_unit(shift));\n         }\n@@ -506,10 +496,9 @@ impl Integer for BigUint {\n     #[inline]\n     fn is_even(&self) -> bool {\n         // Considering only the last digit.\n-        if self.data.is_empty() {\n-            true\n-        } else {\n-            self.data[0].is_even()\n+        match self.data.as_slice().head() {\n+            Some(x) => x.is_even(),\n+            None => true\n         }\n     }\n \n@@ -536,20 +525,20 @@ impl ToPrimitive for BigUint {\n     fn to_u64(&self) -> Option<u64> {\n         match self.data.len() {\n             0 => Some(0),\n-            1 => Some(self.data[0] as u64),\n+            1 => Some(self.data.as_slice()[0] as u64),\n             2 => {\n-                Some(BigDigit::to_uint(self.data[1], self.data[0]) as u64)\n+                Some(BigDigit::to_uint(self.data.as_slice()[1], self.data.as_slice()[0]) as u64)\n             }\n             3 => {\n-                let n_lo = BigDigit::to_uint(self.data[1], self.data[0]) as\n+                let n_lo = BigDigit::to_uint(self.data.as_slice()[1], self.data.as_slice()[0]) as\n                     u64;\n-                let n_hi = self.data[2] as u64;\n+                let n_hi = self.data.as_slice()[2] as u64;\n                 Some((n_hi << 32) + n_lo)\n             }\n             4 => {\n-                let n_lo = BigDigit::to_uint(self.data[1], self.data[0])\n+                let n_lo = BigDigit::to_uint(self.data.as_slice()[1], self.data.as_slice()[0])\n                     as u64;\n-                let n_hi = BigDigit::to_uint(self.data[3], self.data[2])\n+                let n_hi = BigDigit::to_uint(self.data.as_slice()[3], self.data.as_slice()[2])\n                     as u64;\n                 Some((n_hi << 32) + n_lo)\n             }\n@@ -562,8 +551,8 @@ impl ToPrimitive for BigUint {\n     fn to_u64(&self) -> Option<u64> {\n         match self.data.len() {\n             0 => Some(0),\n-            1 => Some(self.data[0] as u64),\n-            2 => Some(BigDigit::to_uint(self.data[1], self.data[0]) as u64),\n+            1 => Some(self.data.as_slice()[0] as u64),\n+            2 => Some(BigDigit::to_uint(self.data.as_slice()[1], self.data.as_slice()[0]) as u64),\n             _ => None\n         }\n     }\n@@ -589,10 +578,10 @@ impl FromPrimitive for BigUint {\n \n         let n = match (BigDigit::from_uint(n_hi), BigDigit::from_uint(n_lo)) {\n             ((0,  0),  (0,  0))  => Zero::zero(),\n-            ((0,  0),  (0,  n0)) => BigUint::new(~[n0]),\n-            ((0,  0),  (n1, n0)) => BigUint::new(~[n0, n1]),\n-            ((0,  n2), (n1, n0)) => BigUint::new(~[n0, n1, n2]),\n-            ((n3, n2), (n1, n0)) => BigUint::new(~[n0, n1, n2, n3]),\n+            ((0,  0),  (0,  n0)) => BigUint::new(vec!(n0)),\n+            ((0,  0),  (n1, n0)) => BigUint::new(vec!(n0, n1)),\n+            ((0,  n2), (n1, n0)) => BigUint::new(vec!(n0, n1, n2)),\n+            ((n3, n2), (n1, n0)) => BigUint::new(vec!(n0, n1, n2, n3)),\n         };\n         Some(n)\n     }\n@@ -602,8 +591,8 @@ impl FromPrimitive for BigUint {\n     fn from_u64(n: u64) -> Option<BigUint> {\n         let n = match BigDigit::from_uint(n as uint) {\n             (0,  0)  => Zero::zero(),\n-            (0,  n0) => BigUint::new(~[n0]),\n-            (n1, n0) => BigUint::new(~[n0, n1])\n+            (0,  n0) => BigUint::new(vec!(n0)),\n+            (n1, n0) => BigUint::new(vec!(n0, n1))\n         };\n         Some(n)\n     }\n@@ -662,14 +651,14 @@ impl ToStrRadix for BigUint {\n         assert!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n         if base == BigDigit::base {\n-            return fill_concat(self.data, radix, max_len)\n+            return fill_concat(self.data.as_slice(), radix, max_len)\n         }\n-        return fill_concat(convert_base((*self).clone(), base), radix, max_len);\n+        return fill_concat(convert_base(self, base).as_slice(), radix, max_len);\n \n-        fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n+        fn convert_base(n: &BigUint, base: uint) -> Vec<BigDigit> {\n             let divider    = FromPrimitive::from_uint(base).unwrap();\n-            let mut result = ~[];\n-            let mut m      = n;\n+            let mut result = Vec::new();\n+            let mut m      = n.clone();\n             while m >= divider {\n                 let (d, m0) = m.div_mod_floor(&divider);\n                 result.push(m0.to_uint().unwrap() as BigDigit);\n@@ -706,7 +695,7 @@ impl FromStrRadix for BigUint {\n impl BigUint {\n     /// Creates and initializes a `BigUint`.\n     #[inline]\n-    pub fn new(v: ~[BigDigit]) -> BigUint {\n+    pub fn new(v: Vec<BigDigit>) -> BigUint {\n         // omit trailing zeros\n         let new_len = v.iter().rposition(|n| *n != 0).map_or(0, |p| p + 1);\n \n@@ -719,7 +708,7 @@ impl BigUint {\n     /// Creates and initializes a `BigUint`.\n     #[inline]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n-        return BigUint::new(slice.to_owned());\n+        return BigUint::new(Vec::from_slice(slice));\n     }\n \n     /// Creates and initializes a `BigUint`.\n@@ -764,22 +753,22 @@ impl BigUint {\n     fn shl_unit(&self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return (*self).clone(); }\n \n-        return BigUint::new(vec::from_elem(n_unit, ZERO_BIG_DIGIT)\n-                            + self.data);\n+        return BigUint::new(vec_ng::append(Vec::from_elem(n_unit, ZERO_BIG_DIGIT),\n+                                           self.data.as_slice()));\n     }\n \n     #[inline]\n     fn shl_bits(&self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return (*self).clone(); }\n \n         let mut carry = 0;\n-        let mut shifted = self.data.iter().map(|elem| {\n+        let mut shifted: Vec<BigDigit> = self.data.iter().map(|elem| {\n             let (hi, lo) = BigDigit::from_uint(\n                 (*elem as uint) << n_bits | (carry as uint)\n             );\n             carry = hi;\n             lo\n-        }).collect::<~[BigDigit]>();\n+        }).collect();\n         if carry != 0 { shifted.push(carry); }\n         return BigUint::new(shifted);\n     }\n@@ -798,7 +787,7 @@ impl BigUint {\n         if n_bits == 0 || self.data.is_empty() { return (*self).clone(); }\n \n         let mut borrow = 0;\n-        let mut shifted_rev = vec::with_capacity(self.data.len());\n+        let mut shifted_rev = Vec::with_capacity(self.data.len());\n         for elem in self.data.rev_iter() {\n             shifted_rev.push((*elem >> n_bits) | borrow);\n             borrow = *elem << (BigDigit::bits - n_bits);\n@@ -1351,7 +1340,7 @@ pub trait RandBigInt {\n impl<R: Rng> RandBigInt for R {\n     fn gen_biguint(&mut self, bit_size: uint) -> BigUint {\n         let (digits, rem) = bit_size.div_rem(&BigDigit::bits);\n-        let mut data = vec::with_capacity(digits+1);\n+        let mut data = Vec::with_capacity(digits+1);\n         for _ in range(0, digits) {\n             data.push(self.gen());\n         }\n@@ -1414,7 +1403,7 @@ impl<R: Rng> RandBigInt for R {\n impl BigInt {\n     /// Creates and initializes a BigInt.\n     #[inline]\n-    pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n+    pub fn new(sign: Sign, v: Vec<BigDigit>) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n@@ -1471,14 +1460,13 @@ mod biguint_tests {\n     use std::num::{ToPrimitive, FromPrimitive};\n     use std::num::CheckedDiv;\n     use rand::{task_rng};\n-    use std::str;\n     use std::u64;\n-    use std::vec;\n+    use std::vec_ng::Vec;\n \n     #[test]\n     fn test_from_slice() {\n         fn check(slice: &[BigDigit], data: &[BigDigit]) {\n-            assert!(data == BigUint::from_slice(slice).data);\n+            assert!(data == BigUint::from_slice(slice).data.as_slice());\n         }\n         check([1], [1]);\n         check([0, 0, 0], []);\n@@ -1490,8 +1478,8 @@ mod biguint_tests {\n \n     #[test]\n     fn test_cmp() {\n-        let data: ~[BigUint] = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n-            .map(|v| BigUint::from_slice(*v));\n+        let data: Vec<BigUint> = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n+            .iter().map(|v| BigUint::from_slice(*v)).collect();\n         for (i, ni) in data.iter().enumerate() {\n             for (j0, nj) in data.slice(i, data.len()).iter().enumerate() {\n                 let j = j0 + i;\n@@ -1527,44 +1515,44 @@ mod biguint_tests {\n \n     #[test]\n     fn test_bitand() {\n-        fn check(left: ~[BigDigit],\n-                 right: ~[BigDigit],\n-                 expected: ~[BigDigit]) {\n-            assert_eq!(BigUint::new(left) & BigUint::new(right),\n-                       BigUint::new(expected));\n+        fn check(left: &[BigDigit],\n+                 right: &[BigDigit],\n+                 expected: &[BigDigit]) {\n+            assert_eq!(BigUint::from_slice(left) & BigUint::from_slice(right),\n+                       BigUint::from_slice(expected));\n         }\n-        check(~[], ~[], ~[]);\n-        check(~[268, 482, 17],\n-              ~[964, 54],\n-              ~[260, 34]);\n+        check([], [], []);\n+        check([268, 482, 17],\n+              [964, 54],\n+              [260, 34]);\n     }\n \n     #[test]\n     fn test_bitor() {\n-        fn check(left: ~[BigDigit],\n-                 right: ~[BigDigit],\n-                 expected: ~[BigDigit]) {\n-            assert_eq!(BigUint::new(left) | BigUint::new(right),\n-                       BigUint::new(expected));\n+        fn check(left: &[BigDigit],\n+                 right: &[BigDigit],\n+                 expected: &[BigDigit]) {\n+            assert_eq!(BigUint::from_slice(left) | BigUint::from_slice(right),\n+                       BigUint::from_slice(expected));\n         }\n-        check(~[], ~[], ~[]);\n-        check(~[268, 482, 17],\n-              ~[964, 54],\n-              ~[972, 502, 17]);\n+        check([], [], []);\n+        check([268, 482, 17],\n+              [964, 54],\n+              [972, 502, 17]);\n     }\n \n     #[test]\n     fn test_bitxor() {\n-        fn check(left: ~[BigDigit],\n-                 right: ~[BigDigit],\n-                 expected: ~[BigDigit]) {\n-            assert_eq!(BigUint::new(left) ^ BigUint::new(right),\n-                       BigUint::new(expected));\n+        fn check(left: &[BigDigit],\n+                 right: &[BigDigit],\n+                 expected: &[BigDigit]) {\n+            assert_eq!(BigUint::from_slice(left) ^ BigUint::from_slice(right),\n+                       BigUint::from_slice(expected));\n         }\n-        check(~[], ~[], ~[]);\n-        check(~[268, 482, 17],\n-              ~[964, 54],\n-              ~[712, 468, 17]);\n+        check([], [], []);\n+        check([268, 482, 17],\n+              [964, 54],\n+              [712, 468, 17]);\n     }\n \n     #[test]\n@@ -1657,20 +1645,20 @@ mod biguint_tests {\n         check(One::one(), 1);\n         check(i64::MAX.to_biguint().unwrap(), i64::MAX);\n \n-        check(BigUint::new(~[                   ]), 0);\n-        check(BigUint::new(~[ 1                 ]), (1 << (0*BigDigit::bits)));\n-        check(BigUint::new(~[-1                 ]), (1 << (1*BigDigit::bits)) - 1);\n-        check(BigUint::new(~[ 0,  1             ]), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1             ]), (1 << (2*BigDigit::bits)) - 1);\n-        check(BigUint::new(~[ 0,  0,  1         ]), (1 << (2*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1, -1         ]), (1 << (3*BigDigit::bits)) - 1);\n-        check(BigUint::new(~[ 0,  0,  0,  1     ]), (1 << (3*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1, -1, -1 >> 1]), i64::MAX);\n+        check(BigUint::new(vec!(                   )), 0);\n+        check(BigUint::new(vec!( 1                 )), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1                 )), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(vec!( 0,  1             )), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1, -1             )), (1 << (2*BigDigit::bits)) - 1);\n+        check(BigUint::new(vec!( 0,  0,  1         )), (1 << (2*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1, -1, -1         )), (1 << (3*BigDigit::bits)) - 1);\n+        check(BigUint::new(vec!( 0,  0,  0,  1     )), (1 << (3*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1, -1, -1, -1 >> 1)), i64::MAX);\n \n         assert_eq!(i64::MIN.to_biguint(), None);\n-        assert_eq!(BigUint::new(~[-1, -1, -1, -1    ]).to_i64(), None);\n-        assert_eq!(BigUint::new(~[ 0,  0,  0,  0,  1]).to_i64(), None);\n-        assert_eq!(BigUint::new(~[-1, -1, -1, -1, -1]).to_i64(), None);\n+        assert_eq!(BigUint::new(vec!(-1, -1, -1, -1    )).to_i64(), None);\n+        assert_eq!(BigUint::new(vec!( 0,  0,  0,  0,  1)).to_i64(), None);\n+        assert_eq!(BigUint::new(vec!(-1, -1, -1, -1, -1)).to_i64(), None);\n     }\n \n     #[cfg(target_word_size = \"64\")]\n@@ -1686,16 +1674,16 @@ mod biguint_tests {\n         check(One::one(), 1);\n         check(i64::MAX.to_biguint().unwrap(), i64::MAX);\n \n-        check(BigUint::new(~[           ]), 0);\n-        check(BigUint::new(~[ 1         ]), (1 << (0*BigDigit::bits)));\n-        check(BigUint::new(~[-1         ]), (1 << (1*BigDigit::bits)) - 1);\n-        check(BigUint::new(~[ 0,  1     ]), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1 >> 1]), i64::MAX);\n+        check(BigUint::new(vec!(           )), 0);\n+        check(BigUint::new(vec!( 1         )), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1         )), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(vec!( 0,  1     )), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1, -1 >> 1)), i64::MAX);\n \n         assert_eq!(i64::MIN.to_biguint(), None);\n-        assert_eq!(BigUint::new(~[-1, -1    ]).to_i64(), None);\n-        assert_eq!(BigUint::new(~[ 0,  0,  1]).to_i64(), None);\n-        assert_eq!(BigUint::new(~[-1, -1, -1]).to_i64(), None);\n+        assert_eq!(BigUint::new(vec!(-1, -1    )).to_i64(), None);\n+        assert_eq!(BigUint::new(vec!( 0,  0,  1)).to_i64(), None);\n+        assert_eq!(BigUint::new(vec!(-1, -1, -1)).to_i64(), None);\n     }\n \n     #[cfg(target_word_size = \"32\")]\n@@ -1712,18 +1700,18 @@ mod biguint_tests {\n         check(u64::MIN.to_biguint().unwrap(), u64::MIN);\n         check(u64::MAX.to_biguint().unwrap(), u64::MAX);\n \n-        check(BigUint::new(~[              ]), 0);\n-        check(BigUint::new(~[ 1            ]), (1 << (0*BigDigit::bits)));\n-        check(BigUint::new(~[-1            ]), (1 << (1*BigDigit::bits)) - 1);\n-        check(BigUint::new(~[ 0,  1        ]), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1        ]), (1 << (2*BigDigit::bits)) - 1);\n-        check(BigUint::new(~[ 0,  0,  1    ]), (1 << (2*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1, -1    ]), (1 << (3*BigDigit::bits)) - 1);\n-        check(BigUint::new(~[ 0,  0,  0,  1]), (1 << (3*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1, -1, -1]), u64::MAX);\n+        check(BigUint::new(vec!(              )), 0);\n+        check(BigUint::new(vec!( 1            )), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1            )), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(vec!( 0,  1        )), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1, -1        )), (1 << (2*BigDigit::bits)) - 1);\n+        check(BigUint::new(vec!( 0,  0,  1    )), (1 << (2*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1, -1, -1    )), (1 << (3*BigDigit::bits)) - 1);\n+        check(BigUint::new(vec!( 0,  0,  0,  1)), (1 << (3*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1, -1, -1, -1)), u64::MAX);\n \n-        assert_eq!(BigUint::new(~[ 0,  0,  0,  0,  1]).to_u64(), None);\n-        assert_eq!(BigUint::new(~[-1, -1, -1, -1, -1]).to_u64(), None);\n+        assert_eq!(BigUint::new(vec!( 0,  0,  0,  0,  1)).to_u64(), None);\n+        assert_eq!(BigUint::new(vec!(-1, -1, -1, -1, -1)).to_u64(), None);\n     }\n \n     #[cfg(target_word_size = \"64\")]\n@@ -1740,14 +1728,14 @@ mod biguint_tests {\n         check(u64::MIN.to_biguint().unwrap(), u64::MIN);\n         check(u64::MAX.to_biguint().unwrap(), u64::MAX);\n \n-        check(BigUint::new(~[      ]), 0);\n-        check(BigUint::new(~[ 1    ]), (1 << (0*BigDigit::bits)));\n-        check(BigUint::new(~[-1    ]), (1 << (1*BigDigit::bits)) - 1);\n-        check(BigUint::new(~[ 0,  1]), (1 << (1*BigDigit::bits)));\n-        check(BigUint::new(~[-1, -1]), u64::MAX);\n+        check(BigUint::new(vec!(      )), 0);\n+        check(BigUint::new(vec!( 1    )), (1 << (0*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1    )), (1 << (1*BigDigit::bits)) - 1);\n+        check(BigUint::new(vec!( 0,  1)), (1 << (1*BigDigit::bits)));\n+        check(BigUint::new(vec!(-1, -1)), u64::MAX);\n \n-        assert_eq!(BigUint::new(~[ 0,  0,  1]).to_u64(), None);\n-        assert_eq!(BigUint::new(~[-1, -1, -1]).to_u64(), None);\n+        assert_eq!(BigUint::new(vec!( 0,  0,  1)).to_u64(), None);\n+        assert_eq!(BigUint::new(vec!(-1, -1, -1)).to_u64(), None);\n     }\n \n     #[test]\n@@ -1757,8 +1745,8 @@ mod biguint_tests {\n             assert_eq!(n.to_bigint().unwrap().to_biguint().unwrap(), n);\n         }\n         check(Zero::zero(), Zero::zero());\n-        check(BigUint::new(~[1,2,3]),\n-              BigInt::from_biguint(Plus, BigUint::new(~[1,2,3])));\n+        check(BigUint::new(vec!(1,2,3)),\n+              BigInt::from_biguint(Plus, BigUint::new(vec!(1,2,3))));\n     }\n \n     static sum_triples: &'static [(&'static [BigDigit],\n@@ -2017,11 +2005,11 @@ mod biguint_tests {\n         assert!(((one << 64) + one).is_odd());\n     }\n \n-    fn to_str_pairs() -> ~[ (BigUint, ~[(uint, ~str)]) ] {\n+    fn to_str_pairs() -> Vec<(BigUint, Vec<(uint, ~str)>)> {\n         let bits = BigDigit::bits;\n-        ~[( Zero::zero(), ~[\n+        vec!(( Zero::zero(), vec!(\n             (2, ~\"0\"), (3, ~\"0\")\n-        ]), ( BigUint::from_slice([ 0xff ]), ~[\n+        )), ( BigUint::from_slice([ 0xff ]), vec!(\n             (2,  ~\"11111111\"),\n             (3,  ~\"100110\"),\n             (4,  ~\"3333\"),\n@@ -2037,41 +2025,41 @@ mod biguint_tests {\n             (14, ~\"143\"),\n             (15, ~\"120\"),\n             (16, ~\"ff\")\n-        ]), ( BigUint::from_slice([ 0xfff ]), ~[\n+        )), ( BigUint::from_slice([ 0xfff ]), vec!(\n             (2,  ~\"111111111111\"),\n             (4,  ~\"333333\"),\n             (16, ~\"fff\")\n-        ]), ( BigUint::from_slice([ 1, 2 ]), ~[\n+        )), ( BigUint::from_slice([ 1, 2 ]), vec!(\n             (2,\n              ~\"10\" +\n-             str::from_chars(vec::from_elem(bits - 1, '0')) + \"1\"),\n+             \"0\".repeat(bits - 1) + \"1\"),\n             (4,\n              ~\"2\" +\n-             str::from_chars(vec::from_elem(bits / 2 - 1, '0')) + \"1\"),\n+             \"0\".repeat(bits / 2 - 1) + \"1\"),\n             (10, match bits {\n                 32 => ~\"8589934593\", 16 => ~\"131073\", _ => fail!()\n             }),\n             (16,\n              ~\"2\" +\n-             str::from_chars(vec::from_elem(bits / 4 - 1, '0')) + \"1\")\n-        ]), ( BigUint::from_slice([ 1, 2, 3 ]), ~[\n+             \"0\".repeat(bits / 4 - 1) + \"1\")\n+        )), ( BigUint::from_slice([ 1, 2, 3 ]), vec!(\n             (2,\n              ~\"11\" +\n-             str::from_chars(vec::from_elem(bits - 2, '0')) + \"10\" +\n-             str::from_chars(vec::from_elem(bits - 1, '0')) + \"1\"),\n+             \"0\".repeat(bits - 2) + \"10\" +\n+             \"0\".repeat(bits - 1) + \"1\"),\n             (4,\n              ~\"3\" +\n-             str::from_chars(vec::from_elem(bits / 2 - 1, '0')) + \"2\" +\n-             str::from_chars(vec::from_elem(bits / 2 - 1, '0')) + \"1\"),\n+             \"0\".repeat(bits / 2 - 1) + \"2\" +\n+             \"0\".repeat(bits / 2 - 1) + \"1\"),\n             (10, match bits {\n                 32 => ~\"55340232229718589441\",\n                 16 => ~\"12885032961\",\n                 _ => fail!()\n             }),\n             (16, ~\"3\" +\n-             str::from_chars(vec::from_elem(bits / 4 - 1, '0')) + \"2\" +\n-             str::from_chars(vec::from_elem(bits / 4 - 1, '0')) + \"1\")\n-        ]) ]\n+             \"0\".repeat(bits / 4 - 1) + \"2\" +\n+             \"0\".repeat(bits / 4 - 1) + \"1\")\n+        )) )\n     }\n \n     #[test]\n@@ -2134,7 +2122,7 @@ mod biguint_tests {\n \n     #[test]\n     fn test_bits() {\n-        assert_eq!(BigUint::new(~[0,0,0,0]).bits(), 0);\n+        assert_eq!(BigUint::new(vec!(0,0,0,0)).bits(), 0);\n         let n: BigUint = FromPrimitive::from_uint(0).unwrap();\n         assert_eq!(n.bits(), 0);\n         let n: BigUint = FromPrimitive::from_uint(1).unwrap();\n@@ -2207,6 +2195,7 @@ mod bigint_tests {\n     use std::num::{ToPrimitive, FromPrimitive};\n     use rand::{task_rng};\n     use std::u64;\n+    use std::vec_ng::Vec;\n \n     #[test]\n     fn test_from_biguint() {\n@@ -2224,12 +2213,12 @@ mod bigint_tests {\n     #[test]\n     fn test_cmp() {\n         let vs = [ &[2 as BigDigit], &[1, 1], &[2, 1], &[1, 1, 1] ];\n-        let mut nums = ~[];\n+        let mut nums = Vec::new();\n         for s in vs.rev_iter() {\n             nums.push(BigInt::from_slice(Minus, *s));\n         }\n         nums.push(Zero::zero());\n-        nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n+        nums.extend(&mut vs.iter().map(|s| BigInt::from_slice(Plus, *s)));\n \n         for (i, ni) in nums.iter().enumerate() {\n             for (j0, nj) in nums.slice(i, nums.len()).iter().enumerate() {\n@@ -2282,15 +2271,15 @@ mod bigint_tests {\n             None);\n \n         assert_eq!(\n-            BigInt::from_biguint(Plus,  BigUint::new(~[1, 2, 3, 4, 5])).to_i64(),\n+            BigInt::from_biguint(Plus,  BigUint::new(vec!(1, 2, 3, 4, 5))).to_i64(),\n             None);\n \n         assert_eq!(\n-            BigInt::from_biguint(Minus, BigUint::new(~[1, 0, 0, 1<<(BigDigit::bits-1)])).to_i64(),\n+            BigInt::from_biguint(Minus, BigUint::new(vec!(1,0,0,1<<(BigDigit::bits-1)))).to_i64(),\n             None);\n \n         assert_eq!(\n-            BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3, 4, 5])).to_i64(),\n+            BigInt::from_biguint(Minus, BigUint::new(vec!(1, 2, 3, 4, 5))).to_i64(),\n             None);\n     }\n \n@@ -2308,12 +2297,12 @@ mod bigint_tests {\n         check(u64::MAX.to_bigint().unwrap(), u64::MAX);\n \n         assert_eq!(\n-            BigInt::from_biguint(Plus, BigUint::new(~[1, 2, 3, 4, 5])).to_u64(),\n+            BigInt::from_biguint(Plus, BigUint::new(vec!(1, 2, 3, 4, 5))).to_u64(),\n             None);\n \n         let max_value: BigUint = FromPrimitive::from_u64(u64::MAX).unwrap();\n         assert_eq!(BigInt::from_biguint(Minus, max_value).to_u64(), None);\n-        assert_eq!(BigInt::from_biguint(Minus, BigUint::new(~[1, 2, 3, 4, 5])).to_u64(), None);\n+        assert_eq!(BigInt::from_biguint(Minus, BigUint::new(vec!(1, 2, 3, 4, 5))).to_u64(), None);\n     }\n \n     #[test]\n@@ -2325,11 +2314,11 @@ mod bigint_tests {\n         let zero: BigInt = Zero::zero();\n         let unsigned_zero: BigUint = Zero::zero();\n         let positive = BigInt::from_biguint(\n-            Plus, BigUint::new(~[1,2,3]));\n+            Plus, BigUint::new(vec!(1,2,3)));\n         let negative = -positive;\n \n         check(zero, unsigned_zero);\n-        check(positive, BigUint::new(~[1,2,3]));\n+        check(positive, BigUint::new(vec!(1,2,3)));\n \n         assert_eq!(negative.to_biguint(), None);\n     }\n@@ -2727,10 +2716,10 @@ mod bigint_tests {\n \n     #[test]\n     fn test_neg() {\n-        assert!(-BigInt::new(Plus,  ~[1, 1, 1]) ==\n-            BigInt::new(Minus, ~[1, 1, 1]));\n-        assert!(-BigInt::new(Minus, ~[1, 1, 1]) ==\n-            BigInt::new(Plus,  ~[1, 1, 1]));\n+        assert!(-BigInt::new(Plus,  vec!(1, 1, 1)) ==\n+            BigInt::new(Minus, vec!(1, 1, 1)));\n+        assert!(-BigInt::new(Minus, vec!(1, 1, 1)) ==\n+            BigInt::new(Plus,  vec!(1, 1, 1)));\n         let zero: BigInt = Zero::zero();\n         assert_eq!(-zero, zero);\n     }"}, {"sha": "6d0b6128f8872b7548d155a81eb38954ee143d6c", "filename": "src/libnum/rational.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7156ded5bcf6831a6da22688d08f71985fdc81df/src%2Flibnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7156ded5bcf6831a6da22688d08f71985fdc81df/src%2Flibnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Frational.rs?ref=7156ded5bcf6831a6da22688d08f71985fdc81df", "patch": "@@ -16,6 +16,7 @@ use std::cmp;\n use std::fmt;\n use std::from_str::FromStr;\n use std::num::{Zero,One,ToStrRadix,FromStrRadix,Round};\n+use std::vec_ng::Vec;\n use bigint::{BigInt, BigUint, Sign, Plus, Minus};\n \n /// Represents the ratio between 2 numbers.\n@@ -295,13 +296,13 @@ impl<T: FromStr + Clone + Integer + Ord>\n     FromStr for Ratio<T> {\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n-        let split: ~[&str] = s.splitn('/', 1).collect();\n+        let split: Vec<&str> = s.splitn('/', 1).collect();\n         if split.len() < 2 {\n             return None\n         }\n-        let a_option: Option<T> = FromStr::from_str(split[0]);\n+        let a_option: Option<T> = FromStr::from_str(split.as_slice()[0]);\n         a_option.and_then(|a| {\n-            let b_option: Option<T> = FromStr::from_str(split[1]);\n+            let b_option: Option<T> = FromStr::from_str(split.as_slice()[1]);\n             b_option.and_then(|b| {\n                 Some(Ratio::new(a.clone(), b.clone()))\n             })\n@@ -312,15 +313,15 @@ impl<T: FromStrRadix + Clone + Integer + Ord>\n     FromStrRadix for Ratio<T> {\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n-        let split: ~[&str] = s.splitn('/', 1).collect();\n+        let split: Vec<&str> = s.splitn('/', 1).collect();\n         if split.len() < 2 {\n             None\n         } else {\n-            let a_option: Option<T> = FromStrRadix::from_str_radix(split[0],\n+            let a_option: Option<T> = FromStrRadix::from_str_radix(split.as_slice()[0],\n                                                                    radix);\n             a_option.and_then(|a| {\n                 let b_option: Option<T> =\n-                    FromStrRadix::from_str_radix(split[1], radix);\n+                    FromStrRadix::from_str_radix(split.as_slice()[1], radix);\n                 b_option.and_then(|b| {\n                     Some(Ratio::new(a.clone(), b.clone()))\n                 })"}]}