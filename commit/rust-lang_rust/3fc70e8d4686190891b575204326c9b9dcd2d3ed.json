{"sha": "3fc70e8d4686190891b575204326c9b9dcd2d3ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmYzcwZThkNDY4NjE5MDg5MWI1NzUyMDQzMjZjOWI5ZGNkMmQzZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-03T02:37:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-03T02:37:29Z"}, "message": "Auto merge of #54383 - mikeyhew:custom-receivers-object-safety, r=nikomatsakis\n\nTake 2: Implement object-safety and dynamic dispatch for arbitrary_self_types\n\nThis replaces #50173. Over the months that that PR was open, we made a lot of changes to the way this was going to be implemented, and the long, meandering comment thread and commit history would have been confusing to people reading it in the future. So I decided to package everything up with new, straighforward commits and open a new PR.\n\nHere are the main points. Please read the commit messages for details.\n\n- To simplify codegen, we only support receivers that have the ABI of a pointer. That means they are builtin pointer types, or newtypes thereof.\n- We introduce a new trait: `DispatchFromDyn<T>`, similar to `CoerceUnsized<T>`. `DispatchFromDyn` has extra requirements that `CoerceUnsized` does not: when you implement `DispatchFromDyn` for a struct, there cannot be any extra fields besides the field being coerced and `PhantomData` fields. This ensures that the struct's ABI is the same as a pointer.\n- For a method's receiver (e.g. `self: Rc<Self>`) to be object-safe, it needs to have the following property:\n    - let `DynReceiver` be the receiver when `Self = dyn Trait`\n    - let `ConcreteReceiver` be the receiver when `Self = T`, where `T` is some unknown `Sized` type that implements `Trait`, and is the erased type of the trait object.\n    - `ConcreteReceiver` must implement `DispatchFromDyn<DynReceiver>`\n\nIn the case of `Rc<Self>`, this requires `Rc<T>: DispatchFromDyn<Rc<dyn Trait>>`\n\nThese rules are explained more thoroughly in the doc comment on `receiver_is_dispatchable` in object_safety.rs.\n\nr? @nikomatsakis and @eddyb\n\ncc @arielb1 @cramertj @withoutboats\n\nSpecial thanks to @nikomatsakis for getting me un-stuck when implementing the object-safety checks, and @eddyb for helping with the codegen parts.\n\nEDIT 2018-11-01: updated because CoerceSized has been replaced with DispatchFromDyn", "tree": {"sha": "3780984da4d2269cfcf6a71ddc54abe478fde944", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3780984da4d2269cfcf6a71ddc54abe478fde944"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3fc70e8d4686190891b575204326c9b9dcd2d3ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3fc70e8d4686190891b575204326c9b9dcd2d3ed", "html_url": "https://github.com/rust-lang/rust/commit/3fc70e8d4686190891b575204326c9b9dcd2d3ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3fc70e8d4686190891b575204326c9b9dcd2d3ed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b096314a6381e28834ddb1e662ce90e5b32736b", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b096314a6381e28834ddb1e662ce90e5b32736b", "html_url": "https://github.com/rust-lang/rust/commit/8b096314a6381e28834ddb1e662ce90e5b32736b"}, {"sha": "192e7c4b51ab35f4cfbbacde9eeffa8e12dba873", "url": "https://api.github.com/repos/rust-lang/rust/commits/192e7c4b51ab35f4cfbbacde9eeffa8e12dba873", "html_url": "https://github.com/rust-lang/rust/commit/192e7c4b51ab35f4cfbbacde9eeffa8e12dba873"}], "stats": {"total": 1032, "additions": 904, "deletions": 128}, "files": [{"sha": "74354f605e5370d1824dc58d03d0b4266e4ce23a", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -77,7 +77,7 @@ use core::iter::FusedIterator;\n use core::marker::{Unpin, Unsize};\n use core::mem;\n use core::pin::Pin;\n-use core::ops::{CoerceUnsized, Deref, DerefMut, Generator, GeneratorState};\n+use core::ops::{CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Generator, GeneratorState};\n use core::ptr::{self, NonNull, Unique};\n use core::task::{LocalWaker, Poll};\n \n@@ -696,6 +696,9 @@ impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + Send + 'a> {\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n \n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Box<U>> for Box<T> {}\n+\n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl<T: Clone> Clone for Box<[T]> {\n     fn clone(&self) -> Self {"}, {"sha": "ad6e594c884af9674c7311ffcd0200bac1fd79da", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -86,6 +86,7 @@\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n+#![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n #![feature(dropck_eyepatch)]"}, {"sha": "be452ebb45a3cae2b2ad54c04b2d5c38aa0dd65b", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -255,7 +255,7 @@ use core::marker;\n use core::marker::{Unpin, Unsize, PhantomData};\n use core::mem::{self, align_of_val, forget, size_of_val};\n use core::ops::Deref;\n-use core::ops::CoerceUnsized;\n+use core::ops::{CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n@@ -297,6 +297,9 @@ impl<T: ?Sized> !marker::Sync for Rc<T> {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n \n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T> {}\n+\n impl<T> Rc<T> {\n     /// Constructs a new `Rc<T>`.\n     ///\n@@ -1176,6 +1179,9 @@ impl<T: ?Sized> !marker::Sync for Weak<T> {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n \n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Weak<U>> for Weak<T> {}\n+\n impl<T> Weak<T> {\n     /// Constructs a new `Weak<T>`, without allocating any memory.\n     /// Calling [`upgrade`][Weak::upgrade] on the return value always gives [`None`]."}, {"sha": "d388f76d8e84c1686ff2dd5a5482a5bffdcdce9a", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -25,7 +25,7 @@ use core::cmp::Ordering;\n use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val};\n use core::ops::Deref;\n-use core::ops::CoerceUnsized;\n+use core::ops::{CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::marker::{Unpin, Unsize, PhantomData};\n@@ -214,6 +214,9 @@ unsafe impl<T: ?Sized + Sync + Send> Sync for Arc<T> {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n \n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Arc<U>> for Arc<T> {}\n+\n /// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n /// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n@@ -254,6 +257,8 @@ unsafe impl<T: ?Sized + Sync + Send> Sync for Weak<T> {}\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Weak<U>> for Weak<T> {}\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Weak<U>> for Weak<T> {}\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {"}, {"sha": "436cd1fc0572837e408407e9d0bb7b310eea92b2", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -10,7 +10,7 @@\n \n //! Exposes the NonZero lang item which provides optimization hints.\n \n-use ops::CoerceUnsized;\n+use ops::{CoerceUnsized, DispatchFromDyn};\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n@@ -20,3 +20,5 @@ use ops::CoerceUnsized;\n pub(crate) struct NonZero<T>(pub(crate) T);\n \n impl<T: CoerceUnsized<U>, U> CoerceUnsized<NonZero<U>> for NonZero<T> {}\n+\n+impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<NonZero<U>> for NonZero<T> {}"}, {"sha": "edfa6df11aceb6e958273084271ccf87762d20e9", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -201,3 +201,6 @@ pub use self::generator::{Generator, GeneratorState};\n \n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n pub use self::unsize::CoerceUnsized;\n+\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+pub use self::unsize::DispatchFromDyn;"}, {"sha": "4d9a40a1b9089b078ee08dc453d9d16870ada099", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -43,7 +43,7 @@ use marker::Unsize;\n /// [nomicon-coerce]: ../../nomicon/coercions.html\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n #[lang = \"coerce_unsized\"]\n-pub trait CoerceUnsized<T> {\n+pub trait CoerceUnsized<T: ?Sized> {\n     // Empty.\n }\n \n@@ -77,3 +77,37 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n // *const T -> *const U\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n+\n+\n+/// This is used for object safety, to check that a method's receiver type can be dispatched on.\n+///\n+/// example impl:\n+///\n+/// ```\n+/// # #![feature(dispatch_from_dyn, unsize)]\n+/// # use std::{ops::DispatchFromDyn, marker::Unsize};\n+/// # struct Rc<T: ?Sized>(::std::rc::Rc<T>);\n+/// impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T>\n+/// where\n+///     T: Unsize<U>,\n+/// {}\n+/// ```\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+#[cfg_attr(not(stage0), lang = \"dispatch_from_dyn\")]\n+pub trait DispatchFromDyn<T> {\n+    // Empty.\n+}\n+\n+// &T -> &U\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a U> for &'a T {}\n+// &mut T -> &mut U\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<&'a mut U> for &'a mut T {}\n+// *const T -> *const U\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*const U> for *const T {}\n+// *mut T -> *mut U\n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized+Unsize<U>, U: ?Sized> DispatchFromDyn<*mut U> for *mut T {}\n+"}, {"sha": "68de82d294529e5cefa0d3eae3159a00674849f3", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -91,7 +91,7 @@\n \n use fmt;\n use marker::Sized;\n-use ops::{Deref, DerefMut, CoerceUnsized};\n+use ops::{Deref, DerefMut, CoerceUnsized, DispatchFromDyn};\n \n #[doc(inline)]\n pub use marker::Unpin;\n@@ -324,5 +324,11 @@ where\n     P: CoerceUnsized<U>,\n {}\n \n+#[unstable(feature = \"pin\", issue = \"49150\")]\n+impl<'a, P, U> DispatchFromDyn<Pin<U>> for Pin<P>\n+where\n+    P: DispatchFromDyn<U>,\n+{}\n+\n #[unstable(feature = \"pin\", issue = \"49150\")]\n impl<P> Unpin for Pin<P> {}"}, {"sha": "62ccf6c865cd96735a92bf30969e5be5de08f815", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -75,7 +75,7 @@\n \n use convert::From;\n use intrinsics;\n-use ops::CoerceUnsized;\n+use ops::{CoerceUnsized, DispatchFromDyn};\n use fmt;\n use hash;\n use marker::{PhantomData, Unsize};\n@@ -2795,6 +2795,9 @@ impl<T: ?Sized> Copy for Unique<T> { }\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<Unique<U>> for Unique<T> where T: Unsize<U> { }\n \n+#[unstable(feature = \"ptr_internals\", issue = \"0\")]\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Unique<U>> for Unique<T> where T: Unsize<U> { }\n+\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<T: ?Sized> fmt::Pointer for Unique<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -2951,6 +2954,9 @@ impl<T: ?Sized> Copy for NonNull<T> { }\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized, U: ?Sized> CoerceUnsized<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n \n+#[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NonNull<U>> for NonNull<T> where T: Unsize<U> { }\n+\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<T: ?Sized> fmt::Debug for NonNull<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "cce8081daf28e5b397cd3edb7350e0f1b2309c6b", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -271,6 +271,7 @@ language_item_table! {\n     DropTraitLangItem,           \"drop\",               drop_trait,              Target::Trait;\n \n     CoerceUnsizedTraitLangItem,  \"coerce_unsized\",     coerce_unsized_trait,    Target::Trait;\n+    DispatchFromDynTraitLangItem,\"dispatch_from_dyn\",  dispatch_from_dyn_trait, Target::Trait;\n \n     AddTraitLangItem,            \"add\",                add_trait,               Target::Trait;\n     SubTraitLangItem,            \"sub\",                sub_trait,               Target::Trait;"}, {"sha": "18ee98c515fb27dc643442f890b7b5d207aac060", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -754,7 +754,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     }\n \n                     ty::Predicate::ObjectSafe(trait_def_id) => {\n-                        let violations = self.tcx.object_safety_violations(trait_def_id);\n+                        let violations = self.tcx.global_tcx()\n+                            .object_safety_violations(trait_def_id);\n                         self.tcx.report_object_safety_error(span,\n                                                             trait_def_id,\n                                                             violations)\n@@ -875,7 +876,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             TraitNotObjectSafe(did) => {\n-                let violations = self.tcx.object_safety_violations(did);\n+                let violations = self.tcx.global_tcx().object_safety_violations(did);\n                 self.tcx.report_object_safety_error(span, did, violations)\n             }\n "}, {"sha": "1d76ccdca3161b33a2f6b7cb6b447159f955314d", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 260, "deletions": 21, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -13,19 +13,21 @@\n //! object if all of their methods meet certain criteria. In particular,\n //! they must:\n //!\n-//!   - have a suitable receiver from which we can extract a vtable;\n+//!   - have a suitable receiver from which we can extract a vtable and coerce to a \"thin\" version\n+//!     that doesn't contain the vtable;\n //!   - not reference the erased type `Self` except for in this receiver;\n //!   - not have generic type parameters\n \n use super::elaborate_predicates;\n \n use hir::def_id::DefId;\n use lint;\n-use traits;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::util::ExplicitSelf;\n+use traits::{self, Obligation, ObligationCause};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, Predicate, ToPredicate};\n+use ty::subst::{Subst, Substs};\n use std::borrow::Cow;\n-use syntax::ast;\n+use std::iter::{self};\n+use syntax::ast::{self, Name};\n use syntax_pos::Span;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n@@ -62,8 +64,8 @@ impl ObjectSafetyViolation {\n                 format!(\"method `{}` references the `Self` type in where clauses\", name).into(),\n             ObjectSafetyViolation::Method(name, MethodViolationCode::Generic) =>\n                 format!(\"method `{}` has generic type parameters\", name).into(),\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::NonStandardSelfType) =>\n-                format!(\"method `{}` has a non-standard `self` type\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::UndispatchableReceiver) =>\n+                format!(\"method `{}`'s receiver cannot be dispatched on\", name).into(),\n             ObjectSafetyViolation::AssociatedConst(name) =>\n                 format!(\"the trait cannot contain associated consts like `{}`\", name).into(),\n         }\n@@ -85,11 +87,11 @@ pub enum MethodViolationCode {\n     /// e.g., `fn foo<A>()`\n     Generic,\n \n-    /// arbitrary `self` type, e.g. `self: Rc<Self>`\n-    NonStandardSelfType,\n+    /// the method's receiver (`self` argument) can't be dispatched on\n+    UndispatchableReceiver,\n }\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n     /// Returns the object safety violations that affect\n     /// astconv - currently, Self in supertraits. This is needed\n@@ -113,6 +115,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn object_safety_violations(self, trait_def_id: DefId)\n                                     -> Vec<ObjectSafetyViolation>\n     {\n+        debug!(\"object_safety_violations: {:?}\", trait_def_id);\n+\n         traits::supertrait_def_ids(self, trait_def_id)\n             .flat_map(|def_id| self.object_safety_violations_for_trait(def_id))\n             .collect()\n@@ -277,23 +281,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                          method: &ty::AssociatedItem)\n                                          -> Option<MethodViolationCode>\n     {\n-        // The method's first parameter must be something that derefs (or\n-        // autorefs) to `&self`. For now, we only accept `self`, `&self`\n-        // and `Box<Self>`.\n+        // The method's first parameter must be named `self`\n         if !method.method_has_self_argument {\n             return Some(MethodViolationCode::StaticMethod);\n         }\n \n         let sig = self.fn_sig(method.def_id);\n \n-        let self_ty = self.mk_self_type();\n-        let self_arg_ty = sig.skip_binder().inputs()[0];\n-        if let ExplicitSelf::Other = ExplicitSelf::determine(self_arg_ty, |ty| ty == self_ty) {\n-            return Some(MethodViolationCode::NonStandardSelfType);\n-        }\n-\n-        // The `Self` type is erased, so it should not appear in list of\n-        // arguments or return type apart from the receiver.\n         for input_ty in &sig.skip_binder().inputs()[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n@@ -320,9 +314,254 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             return Some(MethodViolationCode::WhereClauseReferencesSelf(span));\n         }\n \n+        let receiver_ty = self.liberate_late_bound_regions(\n+            method.def_id,\n+            &sig.map_bound(|sig| sig.inputs()[0]),\n+        );\n+\n+        // until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n+        // However, this is already considered object-safe. We allow it as a special case here.\n+        // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n+        // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n+        if receiver_ty != self.mk_self_type() {\n+            if !self.receiver_is_dispatchable(method, receiver_ty) {\n+                return Some(MethodViolationCode::UndispatchableReceiver);\n+            } else {\n+                // sanity check to make sure the receiver actually has the layout of a pointer\n+\n+                use ty::layout::Abi;\n+\n+                let param_env = self.param_env(method.def_id);\n+\n+                let abi_of_ty = |ty: Ty<'tcx>| -> &Abi {\n+                    match self.layout_of(param_env.and(ty)) {\n+                        Ok(layout) => &layout.abi,\n+                        Err(err) => bug!(\n+                            \"Error: {}\\n while computing layout for type {:?}\", err, ty\n+                        )\n+                    }\n+                };\n+\n+                // e.g. Rc<()>\n+                let unit_receiver_ty = self.receiver_for_self_ty(\n+                    receiver_ty, self.mk_unit(), method.def_id\n+                );\n+\n+                match abi_of_ty(unit_receiver_ty) {\n+                    &Abi::Scalar(..) => (),\n+                    abi => bug!(\"Receiver when Self = () should have a Scalar ABI, found {:?}\", abi)\n+                }\n+\n+                let trait_object_ty = self.object_ty_for_trait(\n+                    trait_def_id, self.mk_region(ty::ReStatic)\n+                );\n+\n+                // e.g. Rc<dyn Trait>\n+                let trait_object_receiver = self.receiver_for_self_ty(\n+                    receiver_ty, trait_object_ty, method.def_id\n+                );\n+\n+                match abi_of_ty(trait_object_receiver) {\n+                    &Abi::ScalarPair(..) => (),\n+                    abi => bug!(\n+                        \"Receiver when Self = {} should have a ScalarPair ABI, found {:?}\",\n+                        trait_object_ty, abi\n+                    )\n+                }\n+            }\n+        }\n+\n         None\n     }\n \n+    /// performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n+    /// e.g. for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`\n+    fn receiver_for_self_ty(\n+        self, receiver_ty: Ty<'tcx>, self_ty: Ty<'tcx>, method_def_id: DefId\n+    ) -> Ty<'tcx> {\n+        let substs = Substs::for_item(self, method_def_id, |param, _| {\n+            if param.index == 0 {\n+                self_ty.into()\n+            } else {\n+                self.mk_param_from_def(param)\n+            }\n+        });\n+\n+        receiver_ty.subst(self, substs)\n+    }\n+\n+    /// creates the object type for the current trait. For example,\n+    /// if the current trait is `Deref`, then this will be\n+    /// `dyn Deref<Target=Self::Target> + 'static`\n+    fn object_ty_for_trait(self, trait_def_id: DefId, lifetime: ty::Region<'tcx>) -> Ty<'tcx> {\n+        debug!(\"object_ty_for_trait: trait_def_id={:?}\", trait_def_id);\n+\n+        let trait_ref = ty::TraitRef::identity(self, trait_def_id);\n+\n+        let trait_predicate = ty::ExistentialPredicate::Trait(\n+            ty::ExistentialTraitRef::erase_self_ty(self, trait_ref)\n+        );\n+\n+        let mut associated_types = traits::supertraits(self, ty::Binder::dummy(trait_ref))\n+            .flat_map(|trait_ref| self.associated_items(trait_ref.def_id()))\n+            .filter(|item| item.kind == ty::AssociatedKind::Type)\n+            .collect::<Vec<_>>();\n+\n+        // existential predicates need to be in a specific order\n+        associated_types.sort_by_key(|item| self.def_path_hash(item.def_id));\n+\n+        let projection_predicates = associated_types.into_iter().map(|item| {\n+            ty::ExistentialPredicate::Projection(ty::ExistentialProjection {\n+                ty: self.mk_projection(item.def_id, trait_ref.substs),\n+                item_def_id: item.def_id,\n+                substs: trait_ref.substs,\n+            })\n+        });\n+\n+        let existential_predicates = self.mk_existential_predicates(\n+            iter::once(trait_predicate).chain(projection_predicates)\n+        );\n+\n+        let object_ty = self.mk_dynamic(\n+            ty::Binder::dummy(existential_predicates),\n+            lifetime,\n+        );\n+\n+        debug!(\"object_ty_for_trait: object_ty=`{}`\", object_ty);\n+\n+        object_ty\n+    }\n+\n+    /// checks the method's receiver (the `self` argument) can be dispatched on when `Self` is a\n+    /// trait object. We require that `DispatchableFromDyn` be implemented for the receiver type\n+    /// in the following way:\n+    /// - let `Receiver` be the type of the `self` argument, i.e `Self`, `&Self`, `Rc<Self>`\n+    /// - require the following bound:\n+    ///\n+    ///        Receiver[Self => T]: DispatchFromDyn<Receiver[Self => dyn Trait]>\n+    ///\n+    ///    where `Foo[X => Y]` means \"the same type as `Foo`, but with `X` replaced with `Y`\"\n+    ///   (substitution notation).\n+    ///\n+    /// some examples of receiver types and their required obligation\n+    /// - `&'a mut self` requires `&'a mut Self: DispatchFromDyn<&'a mut dyn Trait>`\n+    /// - `self: Rc<Self>` requires `Rc<Self>: DispatchFromDyn<Rc<dyn Trait>>`\n+    /// - `self: Pin<Box<Self>>` requires `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<dyn Trait>>>`\n+    ///\n+    /// The only case where the receiver is not dispatchable, but is still a valid receiver\n+    /// type (just not object-safe), is when there is more than one level of pointer indirection.\n+    /// e.g. `self: &&Self`, `self: &Rc<Self>`, `self: Box<Box<Self>>`. In these cases, there\n+    /// is no way, or at least no inexpensive way, to coerce the receiver from the version where\n+    /// `Self = dyn Trait` to the version where `Self = T`, where `T` is the unknown erased type\n+    /// contained by the trait object, because the object that needs to be coerced is behind\n+    /// a pointer.\n+    ///\n+    /// In practice, we cannot use `dyn Trait` explicitly in the obligation because it would result\n+    /// in a new check that `Trait` is object safe, creating a cycle. So instead, we fudge a little\n+    /// by introducing a new type parameter `U` such that `Self: Unsize<U>` and `U: Trait + ?Sized`,\n+    /// and use `U` in place of `dyn Trait`. Written as a chalk-style query:\n+    ///\n+    ///     forall (U: Trait + ?Sized) {\n+    ///         if (Self: Unsize<U>) {\n+    ///             Receiver: DispatchFromDyn<Receiver[Self => U]>\n+    ///         }\n+    ///     }\n+    ///\n+    /// for `self: &'a mut Self`, this means `&'a mut Self: DispatchFromDyn<&'a mut U>`\n+    /// for `self: Rc<Self>`, this means `Rc<Self>: DispatchFromDyn<Rc<U>>`\n+    /// for `self: Pin<Box<Self>>, this means `Pin<Box<Self>>: DispatchFromDyn<Pin<Box<U>>>`\n+    //\n+    // FIXME(mikeyhew) when unsized receivers are implemented as part of unsized rvalues, add this\n+    // fallback query: `Receiver: Unsize<Receiver[Self => U]>` to support receivers like\n+    // `self: Wrapper<Self>`.\n+    #[allow(dead_code)]\n+    fn receiver_is_dispatchable(\n+        self,\n+        method: &ty::AssociatedItem,\n+        receiver_ty: Ty<'tcx>,\n+    ) -> bool {\n+        debug!(\"receiver_is_dispatchable: method = {:?}, receiver_ty = {:?}\", method, receiver_ty);\n+\n+        let traits = (self.lang_items().unsize_trait(),\n+                      self.lang_items().dispatch_from_dyn_trait());\n+        let (unsize_did, dispatch_from_dyn_did) = if let (Some(u), Some(cu)) = traits {\n+            (u, cu)\n+        } else {\n+            debug!(\"receiver_is_dispatchable: Missing Unsize or DispatchFromDyn traits\");\n+            return false;\n+        };\n+\n+        // the type `U` in the query\n+        // use a bogus type parameter to mimick a forall(U) query using u32::MAX for now.\n+        // FIXME(mikeyhew) this is a total hack, and we should replace it when real forall queries\n+        // are implemented\n+        let unsized_self_ty: Ty<'tcx> = self.mk_ty_param(\n+            ::std::u32::MAX,\n+            Name::intern(\"RustaceansAreAwesome\").as_interned_str(),\n+        );\n+\n+        // `Receiver[Self => U]`\n+        let unsized_receiver_ty = self.receiver_for_self_ty(\n+            receiver_ty, unsized_self_ty, method.def_id\n+        );\n+\n+        // create a modified param env, with `Self: Unsize<U>` and `U: Trait` added to caller bounds\n+        // `U: ?Sized` is already implied here\n+        let param_env = {\n+            let mut param_env = self.param_env(method.def_id);\n+\n+            // Self: Unsize<U>\n+            let unsize_predicate = ty::TraitRef {\n+                def_id: unsize_did,\n+                substs: self.mk_substs_trait(self.mk_self_type(), &[unsized_self_ty.into()]),\n+            }.to_predicate();\n+\n+            // U: Trait<Arg1, ..., ArgN>\n+            let trait_predicate = {\n+                let substs = Substs::for_item(self, method.container.assert_trait(), |param, _| {\n+                    if param.index == 0 {\n+                        unsized_self_ty.into()\n+                    } else {\n+                        self.mk_param_from_def(param)\n+                    }\n+                });\n+\n+                ty::TraitRef {\n+                    def_id: unsize_did,\n+                    substs,\n+                }.to_predicate()\n+            };\n+\n+            let caller_bounds: Vec<Predicate<'tcx>> = param_env.caller_bounds.iter().cloned()\n+                .chain(iter::once(unsize_predicate))\n+                .chain(iter::once(trait_predicate))\n+                .collect();\n+\n+            param_env.caller_bounds = self.intern_predicates(&caller_bounds);\n+\n+            param_env\n+        };\n+\n+        // Receiver: DispatchFromDyn<Receiver[Self => U]>\n+        let obligation = {\n+            let predicate = ty::TraitRef {\n+                def_id: dispatch_from_dyn_did,\n+                substs: self.mk_substs_trait(receiver_ty, &[unsized_receiver_ty.into()]),\n+            }.to_predicate();\n+\n+            Obligation::new(\n+                ObligationCause::dummy(),\n+                param_env,\n+                predicate,\n+            )\n+        };\n+\n+        self.infer_ctxt().enter(|ref infcx| {\n+            // the receiver is dispatchable iff the obligation holds\n+            infcx.predicate_must_hold(&obligation)\n+        })\n+    }\n+\n     fn contains_illegal_self_type_reference(self,\n                                             trait_def_id: DefId,\n                                             ty: Ty<'tcx>)"}, {"sha": "ce515c4507772172102202516d52fd781f80c29e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -2091,18 +2091,6 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             obligation.self_ty().skip_binder()\n         );\n \n-        // Object-safety candidates are only applicable to object-safe\n-        // traits. Including this check is useful because it helps\n-        // inference in cases of traits like `BorrowFrom`, which are\n-        // not object-safe, and which rely on being able to infer the\n-        // self-type from one of the other inputs. Without this check,\n-        // these cases wind up being considered ambiguous due to a\n-        // (spurious) ambiguity introduced here.\n-        let predicate_trait_ref = obligation.predicate.to_poly_trait_ref();\n-        if !self.tcx().is_object_safe(predicate_trait_ref.def_id()) {\n-            return;\n-        }\n-\n         self.probe(|this, _snapshot| {\n             // the code below doesn't care about regions, and the\n             // self-ty here doesn't escape this probe, so just erase"}, {"sha": "e50534a4e1dc95fc7d19eaf5f3c6d4f0e691046c", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 41, "deletions": 13, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -19,7 +19,7 @@ use type_::Type;\n use type_of::{LayoutLlvmExt, PointerKind};\n use value::Value;\n \n-use rustc_target::abi::{LayoutOf, Size, TyLayout};\n+use rustc_target::abi::{LayoutOf, Size, TyLayout, Abi as LayoutAbi};\n use rustc::ty::{self, Ty};\n use rustc::ty::layout;\n \n@@ -302,21 +302,49 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n         FnType::new_internal(cx, sig, extra_args, |ty, arg_idx| {\n             let mut layout = cx.layout_of(ty);\n             // Don't pass the vtable, it's not an argument of the virtual fn.\n-            // Instead, pass just the (thin pointer) first field of `*dyn Trait`.\n+            // Instead, pass just the data pointer, but give it the type `*const/mut dyn Trait`\n+            // or `&/&mut dyn Trait` because this is special-cased elsewhere in codegen\n             if arg_idx == Some(0) {\n-                // FIXME(eddyb) `layout.field(cx, 0)` is not enough because e.g.\n-                // `Box<dyn Trait>` has a few newtype wrappers around the raw\n-                // pointer, so we'd have to \"dig down\" to find `*dyn Trait`.\n-                let pointee = if layout.is_unsized() {\n-                    layout.ty\n+                let fat_pointer_ty = if layout.is_unsized() {\n+                    // unsized `self` is passed as a pointer to `self`\n+                    // FIXME (mikeyhew) change this to use &own if it is ever added to the language\n+                    cx.tcx.mk_mut_ptr(layout.ty)\n                 } else {\n-                    layout.ty.builtin_deref(true)\n-                        .unwrap_or_else(|| {\n-                            bug!(\"FnType::new_vtable: non-pointer self {:?}\", layout)\n-                        }).ty\n+                    match layout.abi {\n+                        LayoutAbi::ScalarPair(..) => (),\n+                        _ => bug!(\"receiver type has unsupported layout: {:?}\", layout)\n+                    }\n+\n+                    // In the case of Rc<Self>, we need to explicitly pass a *mut RcBox<Self>\n+                    // with a Scalar (not ScalarPair) ABI. This is a hack that is understood\n+                    // elsewhere in the compiler as a method on a `dyn Trait`.\n+                    // To get the type `*mut RcBox<Self>`, we just keep unwrapping newtypes until we\n+                    // get a built-in pointer type\n+                    let mut fat_pointer_layout = layout;\n+                    'descend_newtypes: while !fat_pointer_layout.ty.is_unsafe_ptr()\n+                        && !fat_pointer_layout.ty.is_region_ptr()\n+                    {\n+                        'iter_fields: for i in 0..fat_pointer_layout.fields.count() {\n+                            let field_layout = fat_pointer_layout.field(cx, i);\n+\n+                            if !field_layout.is_zst() {\n+                                fat_pointer_layout = field_layout;\n+                                continue 'descend_newtypes\n+                            }\n+                        }\n+\n+                        bug!(\"receiver has no non-zero-sized fields {:?}\", fat_pointer_layout);\n+                    }\n+\n+                    fat_pointer_layout.ty\n                 };\n-                let fat_ptr_ty = cx.tcx.mk_mut_ptr(pointee);\n-                layout = cx.layout_of(fat_ptr_ty).field(cx, 0);\n+\n+                // we now have a type like `*mut RcBox<dyn Trait>`\n+                // change its layout to that of `*mut ()`, a thin pointer, but keep the same type\n+                // this is understood as a special case elsewhere in the compiler\n+                let unit_pointer_ty = cx.tcx.mk_mut_ptr(cx.tcx.mk_unit());\n+                layout = cx.layout_of(unit_pointer_ty);\n+                layout.ty = fat_pointer_ty;\n             }\n             ArgType::new(layout)\n         })"}, {"sha": "a7f4c48c89bd6c99ef8e7a559e702f14d0033b26", "filename": "src/librustc_codegen_llvm/mir/block.rs", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fblock.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -642,14 +642,46 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     (&args[..], None)\n                 };\n \n-                for (i, arg) in first_args.iter().enumerate() {\n+                'make_args: for (i, arg) in first_args.iter().enumerate() {\n                     let mut op = self.codegen_operand(&bx, arg);\n+\n                     if let (0, Some(ty::InstanceDef::Virtual(_, idx))) = (i, def) {\n-                        if let Pair(data_ptr, meta) = op.val {\n-                            llfn = Some(meth::VirtualIndex::from_index(idx)\n-                                .get_fn(&bx, meta, &fn_ty));\n-                            llargs.push(data_ptr);\n-                            continue;\n+                        if let Pair(..) = op.val {\n+                            // In the case of Rc<Self>, we need to explicitly pass a\n+                            // *mut RcBox<Self> with a Scalar (not ScalarPair) ABI. This is a hack\n+                            // that is understood elsewhere in the compiler as a method on\n+                            // `dyn Trait`.\n+                            // To get a `*mut RcBox<Self>`, we just keep unwrapping newtypes until\n+                            // we get a value of a built-in pointer type\n+                            'descend_newtypes: while !op.layout.ty.is_unsafe_ptr()\n+                                            && !op.layout.ty.is_region_ptr()\n+                            {\n+                                'iter_fields: for i in 0..op.layout.fields.count() {\n+                                    let field = op.extract_field(&bx, i);\n+                                    if !field.layout.is_zst() {\n+                                        // we found the one non-zero-sized field that is allowed\n+                                        // now find *its* non-zero-sized field, or stop if it's a\n+                                        // pointer\n+                                        op = field;\n+                                        continue 'descend_newtypes\n+                                    }\n+                                }\n+\n+                                span_bug!(span, \"receiver has no non-zero-sized fields {:?}\", op);\n+                            }\n+\n+                            // now that we have `*dyn Trait` or `&dyn Trait`, split it up into its\n+                            // data pointer and vtable. Look up the method in the vtable, and pass\n+                            // the data pointer as the first argument\n+                            match op.val {\n+                                Pair(data_ptr, meta) => {\n+                                    llfn = Some(meth::VirtualIndex::from_index(idx)\n+                                        .get_fn(&bx, meta, &fn_ty));\n+                                    llargs.push(data_ptr);\n+                                    continue 'make_args\n+                                }\n+                                other => bug!(\"expected a Pair, got {:?}\", other)\n+                            }\n                         } else if let Ref(data_ptr, Some(meta), _) = op.val {\n                             // by-value dynamic dispatch\n                             llfn = Some(meth::VirtualIndex::from_index(idx)"}, {"sha": "afd8c251b76508c30a8620020e7ae13317061172", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -1013,7 +1013,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         // most importantly, that the supertraits don't contain Self,\n         // to avoid ICE-s.\n         let object_safety_violations =\n-            tcx.astconv_object_safety_violations(principal.def_id());\n+            tcx.global_tcx().astconv_object_safety_violations(principal.def_id());\n         if !object_safety_violations.is_empty() {\n             tcx.report_object_safety_error(\n                 span, principal.def_id(), object_safety_violations)"}, {"sha": "99c6ba457faa0a807c5e689cdc04ab338c63cf57", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 173, "deletions": 4, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -31,8 +31,9 @@ pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n     Checker { tcx, trait_def_id }\n         .check(tcx.lang_items().drop_trait(), visit_implementation_of_drop)\n         .check(tcx.lang_items().copy_trait(), visit_implementation_of_copy)\n-        .check(tcx.lang_items().coerce_unsized_trait(),\n-               visit_implementation_of_coerce_unsized);\n+        .check(tcx.lang_items().coerce_unsized_trait(), visit_implementation_of_coerce_unsized)\n+        .check(tcx.lang_items().dispatch_from_dyn_trait(),\n+            visit_implementation_of_dispatch_from_dyn);\n }\n \n struct Checker<'a, 'tcx: 'a> {\n@@ -162,6 +163,174 @@ fn visit_implementation_of_coerce_unsized<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn visit_implementation_of_dispatch_from_dyn<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    impl_did: DefId,\n+) {\n+    debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\",\n+           impl_did);\n+    if impl_did.is_local() {\n+        let dispatch_from_dyn_trait = tcx.lang_items().dispatch_from_dyn_trait().unwrap();\n+\n+        let impl_node_id = tcx.hir.as_local_node_id(impl_did).unwrap();\n+        let span = tcx.hir.span(impl_node_id);\n+\n+        let source = tcx.type_of(impl_did);\n+        assert!(!source.has_escaping_regions());\n+        let target = {\n+            let trait_ref = tcx.impl_trait_ref(impl_did).unwrap();\n+            assert_eq!(trait_ref.def_id, dispatch_from_dyn_trait);\n+\n+            trait_ref.substs.type_at(1)\n+        };\n+\n+        debug!(\"visit_implementation_of_dispatch_from_dyn: {:?} -> {:?}\",\n+            source,\n+            target);\n+\n+        let param_env = tcx.param_env(impl_did);\n+\n+        let create_err = |msg: &str| {\n+            struct_span_err!(tcx.sess, span, E0378, \"{}\", msg)\n+        };\n+\n+        tcx.infer_ctxt().enter(|infcx| {\n+            let cause = ObligationCause::misc(span, impl_node_id);\n+\n+            use ty::TyKind::*;\n+            match (&source.sty, &target.sty) {\n+                (&Ref(r_a, _, mutbl_a), Ref(r_b, _, mutbl_b))\n+                    if infcx.at(&cause, param_env).eq(r_a, r_b).is_ok()\n+                    && mutbl_a == *mutbl_b => (),\n+                (&RawPtr(tm_a), &RawPtr(tm_b))\n+                    if tm_a.mutbl == tm_b.mutbl => (),\n+                (&Adt(def_a, substs_a), &Adt(def_b, substs_b))\n+                    if def_a.is_struct() && def_b.is_struct() =>\n+                {\n+                    if def_a != def_b {\n+                        let source_path = tcx.item_path_str(def_a.did);\n+                        let target_path = tcx.item_path_str(def_b.did);\n+\n+                        create_err(\n+                            &format!(\n+                                \"the trait `DispatchFromDyn` may only be implemented \\\n+                                for a coercion between structures with the same \\\n+                                definition; expected `{}`, found `{}`\",\n+                                source_path, target_path,\n+                            )\n+                        ).emit();\n+\n+                        return\n+                    }\n+\n+                    if def_a.repr.c() || def_a.repr.packed() {\n+                        create_err(\n+                            \"structs implementing `DispatchFromDyn` may not have \\\n+                             `#[repr(packed)]` or `#[repr(C)]`\"\n+                        ).emit();\n+                    }\n+\n+                    let fields = &def_a.non_enum_variant().fields;\n+\n+                    let coerced_fields = fields.iter().filter_map(|field| {\n+                        if tcx.type_of(field.did).is_phantom_data() {\n+                            // ignore PhantomData fields\n+                            return None\n+                        }\n+\n+                        let ty_a = field.ty(tcx, substs_a);\n+                        let ty_b = field.ty(tcx, substs_b);\n+                        if let Ok(ok) = infcx.at(&cause, param_env).eq(ty_a, ty_b) {\n+                            if ok.obligations.is_empty() {\n+                                create_err(\n+                                    \"the trait `DispatchFromDyn` may only be implemented \\\n+                                     for structs containing the field being coerced, \\\n+                                     `PhantomData` fields, and nothing else\"\n+                                ).note(\n+                                    &format!(\n+                                        \"extra field `{}` of type `{}` is not allowed\",\n+                                        field.ident, ty_a,\n+                                    )\n+                                ).emit();\n+\n+                                return None;\n+                            }\n+                        }\n+\n+                        Some(field)\n+                    }).collect::<Vec<_>>();\n+\n+                    if coerced_fields.is_empty() {\n+                        create_err(\n+                            \"the trait `DispatchFromDyn` may only be implemented \\\n+                            for a coercion between structures with a single field \\\n+                            being coerced, none found\"\n+                        ).emit();\n+                    } else if coerced_fields.len() > 1 {\n+                        create_err(\n+                            \"implementing the `DispatchFromDyn` trait requires multiple coercions\",\n+                        ).note(\n+                            \"the trait `DispatchFromDyn` may only be implemented \\\n+                                for a coercion between structures with a single field \\\n+                                being coerced\"\n+                        ).note(\n+                            &format!(\n+                                \"currently, {} fields need coercions: {}\",\n+                                coerced_fields.len(),\n+                                coerced_fields.iter().map(|field| {\n+                                    format!(\"`{}` (`{}` to `{}`)\",\n+                                        field.ident,\n+                                        field.ty(tcx, substs_a),\n+                                        field.ty(tcx, substs_b),\n+                                    )\n+                                }).collect::<Vec<_>>()\n+                                .join(\", \")\n+                            )\n+                        ).emit();\n+                    } else {\n+                        let mut fulfill_cx = TraitEngine::new(infcx.tcx);\n+\n+                        for field in coerced_fields {\n+\n+                            let predicate = tcx.predicate_for_trait_def(\n+                                param_env,\n+                                cause.clone(),\n+                                dispatch_from_dyn_trait,\n+                                0,\n+                                field.ty(tcx, substs_a),\n+                                &[field.ty(tcx, substs_b).into()]\n+                            );\n+\n+                            fulfill_cx.register_predicate_obligation(&infcx, predicate);\n+                        }\n+\n+                        // Check that all transitive obligations are satisfied.\n+                        if let Err(errors) = fulfill_cx.select_all_or_error(&infcx) {\n+                            infcx.report_fulfillment_errors(&errors, None, false);\n+                        }\n+\n+                        // Finally, resolve all regions.\n+                        let region_scope_tree = region::ScopeTree::default();\n+                        let outlives_env = OutlivesEnvironment::new(param_env);\n+                        infcx.resolve_regions_and_report_errors(\n+                            impl_did,\n+                            &region_scope_tree,\n+                            &outlives_env,\n+                            SuppressRegionErrors::default(),\n+                        );\n+                    }\n+                }\n+                _ => {\n+                    create_err(\n+                        \"the trait `DispatchFromDyn` may only be implemented \\\n+                        for a coercion between structures\"\n+                    ).emit();\n+                }\n+            }\n+        })\n+    }\n+}\n+\n pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                      impl_did: DefId)\n                                      -> CoerceUnsizedInfo {\n@@ -236,7 +405,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                               E0377,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n                                for a coercion between structures with the same \\\n-                               definition; expected {}, found {}\",\n+                               definition; expected `{}`, found `{}`\",\n                               source_path,\n                               target_path);\n                     return err_info;\n@@ -341,7 +510,7 @@ pub fn coerce_unsized_info<'a, 'gcx>(gcx: TyCtxt<'a, 'gcx, 'gcx>,\n                                       diff_fields.len(),\n                                       diff_fields.iter()\n                                           .map(|&(i, a, b)| {\n-                                              format!(\"{} ({} to {})\", fields[i].ident, a, b)\n+                                              format!(\"`{}` (`{}` to `{}`)\", fields[i].ident, a, b)\n                                           })\n                                           .collect::<Vec<_>>()\n                                           .join(\", \")));"}, {"sha": "c81aea2465b7be40b39d5840be6c07bbeb915061", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -3084,6 +3084,66 @@ containing the unsized type is the last and only unsized type field in the\n struct.\n \"##,\n \n+E0378: r##\"\n+The `DispatchFromDyn` trait currently can only be implemented for\n+builtin pointer types and structs that are newtype wrappers around them\n+\u2014 that is, the struct must have only one field (except for`PhantomData`),\n+and that field must itself implement `DispatchFromDyn`.\n+\n+Examples:\n+\n+```\n+#![feature(dispatch_from_dyn, unsize)]\n+use std::{\n+    marker::Unsize,\n+    ops::DispatchFromDyn,\n+};\n+\n+struct Ptr<T: ?Sized>(*const T);\n+\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T>\n+where\n+    T: Unsize<U>,\n+{}\n+```\n+\n+```\n+#![feature(dispatch_from_dyn)]\n+use std::{\n+    ops::DispatchFromDyn,\n+    marker::PhantomData,\n+};\n+\n+struct Wrapper<T> {\n+    ptr: T,\n+    _phantom: PhantomData<()>,\n+}\n+\n+impl<T, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T>\n+where\n+    T: DispatchFromDyn<U>,\n+{}\n+```\n+\n+Example of illegal `DispatchFromDyn` implementation\n+(illegal because of extra field)\n+\n+```compile-fail,E0378\n+#![feature(dispatch_from_dyn)]\n+use std::ops::DispatchFromDyn;\n+\n+struct WrapperExtraField<T> {\n+    ptr: T,\n+    extra_stuff: i32,\n+}\n+\n+impl<T, U> DispatchFromDyn<WrapperExtraField<U>> for WrapperExtraField<T>\n+where\n+    T: DispatchFromDyn<U>,\n+{}\n+```\n+\"##,\n+\n E0390: r##\"\n You tried to implement methods for a primitive type. Erroneous code example:\n "}, {"sha": "e1663563cec0aef60341cf0fce21a021916b57ff", "filename": "src/test/run-pass/arbitrary_self_types_pointers_and_wrappers.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Frun-pass%2Farbitrary_self_types_pointers_and_wrappers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Frun-pass%2Farbitrary_self_types_pointers_and_wrappers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_pointers_and_wrappers.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -0,0 +1,76 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(arbitrary_self_types, unsize, coerce_unsized, dispatch_from_dyn)]\n+#![feature(rustc_attrs)]\n+\n+use std::{\n+    ops::{Deref, CoerceUnsized, DispatchFromDyn},\n+    marker::Unsize,\n+};\n+\n+struct Ptr<T: ?Sized>(Box<T>);\n+\n+impl<T: ?Sized> Deref for Ptr<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &*self.0\n+    }\n+}\n+\n+impl<T: Unsize<U> + ?Sized, U: ?Sized> CoerceUnsized<Ptr<U>> for Ptr<T> {}\n+impl<T: Unsize<U> + ?Sized, U: ?Sized> DispatchFromDyn<Ptr<U>> for Ptr<T> {}\n+\n+struct Wrapper<T: ?Sized>(T);\n+\n+impl<T: ?Sized> Deref for Wrapper<T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &self.0\n+    }\n+}\n+\n+impl<T: CoerceUnsized<U>, U> CoerceUnsized<Wrapper<U>> for Wrapper<T> {}\n+impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<Wrapper<U>> for Wrapper<T> {}\n+\n+\n+trait Trait {\n+    // This method isn't object-safe yet. Unsized by-value `self` is object-safe (but not callable\n+    // without unsized_locals), but wrappers arond `Self` currently are not.\n+    // FIXME (mikeyhew) uncomment this when unsized rvalues object-safety is implemented\n+    // fn wrapper(self: Wrapper<Self>) -> i32;\n+    fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32;\n+    fn wrapper_ptr(self: Wrapper<Ptr<Self>>) -> i32;\n+    fn wrapper_ptr_wrapper(self: Wrapper<Ptr<Wrapper<Self>>>) -> i32;\n+}\n+\n+impl Trait for i32 {\n+    fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32 {\n+        **self\n+    }\n+    fn wrapper_ptr(self: Wrapper<Ptr<Self>>) -> i32 {\n+        **self\n+    }\n+    fn wrapper_ptr_wrapper(self: Wrapper<Ptr<Wrapper<Self>>>) -> i32 {\n+        ***self\n+    }\n+}\n+\n+fn main() {\n+    let pw = Ptr(Box::new(Wrapper(5))) as Ptr<Wrapper<dyn Trait>>;\n+    assert_eq!(pw.ptr_wrapper(), 5);\n+\n+    let wp = Wrapper(Ptr(Box::new(6))) as Wrapper<Ptr<dyn Trait>>;\n+    assert_eq!(wp.wrapper_ptr(), 6);\n+\n+    let wpw = Wrapper(Ptr(Box::new(Wrapper(7)))) as Wrapper<Ptr<Wrapper<dyn Trait>>>;\n+    assert_eq!(wpw.wrapper_ptr_wrapper(), 7);\n+}"}, {"sha": "80a7ce9691126a4aa3892b61a0d8a463548797d5", "filename": "src/test/run-pass/arbitrary_self_types_stdlib_pointers.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Frun-pass%2Farbitrary_self_types_stdlib_pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Frun-pass%2Farbitrary_self_types_stdlib_pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Farbitrary_self_types_stdlib_pointers.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(arbitrary_self_types)]\n+#![feature(pin)]\n+#![feature(rustc_attrs)]\n+\n+use std::{\n+    rc::Rc,\n+    sync::Arc,\n+    pin::Pin,\n+};\n+\n+trait Trait {\n+    fn by_rc(self: Rc<Self>) -> i64;\n+    fn by_arc(self: Arc<Self>) -> i64;\n+    fn by_pin_mut(self: Pin<&mut Self>) -> i64;\n+    fn by_pin_box(self: Pin<Box<Self>>) -> i64;\n+}\n+\n+impl Trait for i64 {\n+    fn by_rc(self: Rc<Self>) -> i64 {\n+        *self\n+    }\n+    fn by_arc(self: Arc<Self>) -> i64 {\n+        *self\n+    }\n+    fn by_pin_mut(self: Pin<&mut Self>) -> i64 {\n+        *self\n+    }\n+    fn by_pin_box(self: Pin<Box<Self>>) -> i64 {\n+        *self\n+    }\n+}\n+\n+fn main() {\n+    let rc = Rc::new(1i64) as Rc<dyn Trait>;\n+    assert_eq!(1, rc.by_rc());\n+\n+    let arc = Arc::new(2i64) as Arc<dyn Trait>;\n+    assert_eq!(2, arc.by_arc());\n+\n+    let mut value = 3i64;\n+    let pin_mut = Pin::new(&mut value) as Pin<&mut dyn Trait>;\n+    assert_eq!(3, pin_mut.by_pin_mut());\n+\n+    let pin_box = Into::<Pin<Box<i64>>>::into(Box::new(4i64)) as Pin<Box<dyn Trait>>;\n+    assert_eq!(4, pin_box.by_pin_box());\n+}"}, {"sha": "4dc481174a45d4ac94a5690a256b5df4bd3f1435", "filename": "src/test/ui/arbitrary-self-types-not-object-safe.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Farbitrary-self-types-not-object-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Farbitrary-self-types-not-object-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farbitrary-self-types-not-object-safe.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -12,38 +12,38 @@\n use std::rc::Rc;\n \n trait Foo {\n-    fn foo(self: Rc<Self>) -> usize;\n+    fn foo(self: &Rc<Self>) -> usize;\n }\n \n trait Bar {\n-    fn foo(self: Rc<Self>) -> usize where Self: Sized;\n-    fn bar(self: Box<Self>) -> usize;\n+    fn foo(self: &Rc<Self>) -> usize where Self: Sized;\n+    fn bar(self: Rc<Self>) -> usize;\n }\n \n impl Foo for usize {\n-    fn foo(self: Rc<Self>) -> usize {\n-        *self\n+    fn foo(self: &Rc<Self>) -> usize {\n+        **self\n     }\n }\n \n impl Bar for usize {\n-    fn foo(self: Rc<Self>) -> usize {\n-        *self\n+    fn foo(self: &Rc<Self>) -> usize {\n+        **self\n     }\n \n-    fn bar(self: Box<Self>) -> usize {\n+    fn bar(self: Rc<Self>) -> usize {\n         *self\n     }\n }\n \n fn make_foo() {\n-    let x = Box::new(5usize) as Box<Foo>;\n+    let x = Rc::new(5usize) as Rc<Foo>;\n     //~^ ERROR E0038\n     //~| ERROR E0038\n }\n \n fn make_bar() {\n-    let x = Box::new(5usize) as Box<Bar>;\n+    let x = Rc::new(5usize) as Rc<Bar>;\n     x.bar();\n }\n "}, {"sha": "77ca118471db5d6d75c506c69902cbce7f35e8f0", "filename": "src/test/ui/arbitrary-self-types-not-object-safe.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Farbitrary-self-types-not-object-safe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Farbitrary-self-types-not-object-safe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farbitrary-self-types-not-object-safe.stderr?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -1,19 +1,19 @@\n error[E0038]: the trait `Foo` cannot be made into an object\n-  --> $DIR/arbitrary-self-types-not-object-safe.rs:40:33\n+  --> $DIR/arbitrary-self-types-not-object-safe.rs:40:32\n    |\n-LL |     let x = Box::new(5usize) as Box<Foo>;\n-   |                                 ^^^^^^^^ the trait `Foo` cannot be made into an object\n+LL |     let x = Rc::new(5usize) as Rc<Foo>;\n+   |                                ^^^^^^^ the trait `Foo` cannot be made into an object\n    |\n-   = note: method `foo` has a non-standard `self` type\n+   = note: method `foo`'s receiver cannot be dispatched on\n \n error[E0038]: the trait `Foo` cannot be made into an object\n   --> $DIR/arbitrary-self-types-not-object-safe.rs:40:13\n    |\n-LL |     let x = Box::new(5usize) as Box<Foo>;\n-   |             ^^^^^^^^^^^^^^^^ the trait `Foo` cannot be made into an object\n+LL |     let x = Rc::new(5usize) as Rc<Foo>;\n+   |             ^^^^^^^^^^^^^^^ the trait `Foo` cannot be made into an object\n    |\n-   = note: method `foo` has a non-standard `self` type\n-   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::boxed::Box<dyn Foo>>` for `std::boxed::Box<usize>`\n+   = note: method `foo`'s receiver cannot be dispatched on\n+   = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::rc::Rc<dyn Foo>>` for `std::rc::Rc<usize>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f3db697790c5e26e246ea59b4be0bdb3fa26414d", "filename": "src/test/ui/error-codes/E0375.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Ferror-codes%2FE0375.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Ferror-codes%2FE0375.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0375.stderr?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -5,7 +5,7 @@ LL | impl<T, U> CoerceUnsized<Foo<U, T>> for Foo<T, U> {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^ requires multiple coercions\n    |\n    = note: `CoerceUnsized` may only be implemented for a coercion between structures with one field being coerced\n-   = note: currently, 2 fields need coercions: b (T to U), c (U to T)\n+   = note: currently, 2 fields need coercions: `b` (`T` to `U`), `c` (`U` to `T`)\n \n error: aborting due to previous error\n "}, {"sha": "1cf5c73ab138febd90b99c51c31bf5ab73cbefd6", "filename": "src/test/ui/invalid_dispatch_from_dyn_impls.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unsize, dispatch_from_dyn)]\n+\n+use std::{\n+    ops::DispatchFromDyn,\n+    marker::{Unsize, PhantomData},\n+};\n+\n+struct WrapperWithExtraField<T>(T, i32);\n+\n+impl<T, U> DispatchFromDyn<WrapperWithExtraField<U>> for WrapperWithExtraField<T>\n+where\n+    T: DispatchFromDyn<U>,\n+{} //~^^^ ERROR [E0378]\n+\n+\n+struct MultiplePointers<T: ?Sized>{\n+    ptr1: *const T,\n+    ptr2: *const T,\n+}\n+\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<MultiplePointers<U>> for MultiplePointers<T>\n+where\n+    T: Unsize<U>,\n+{} //~^^^ ERROR [E0378]\n+\n+\n+struct NothingToCoerce<T: ?Sized> {\n+    data: PhantomData<T>,\n+}\n+\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NothingToCoerce<T>> for NothingToCoerce<U> {}\n+//~^ ERROR [E0378]\n+\n+#[repr(C)]\n+struct HasReprC<T: ?Sized>(Box<T>);\n+\n+impl<T: ?Sized, U: ?Sized> DispatchFromDyn<HasReprC<U>> for HasReprC<T>\n+where\n+    T: Unsize<U>,\n+{} //~^^^ ERROR [E0378]\n+\n+fn main() {}"}, {"sha": "82186b67d97fd6c5357fbfdcd07656da9d1abf44", "filename": "src/test/ui/invalid_dispatch_from_dyn_impls.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid_dispatch_from_dyn_impls.stderr?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -0,0 +1,41 @@\n+error[E0378]: the trait `DispatchFromDyn` may only be implemented for structs containing the field being coerced, `PhantomData` fields, and nothing else\n+  --> $DIR/invalid_dispatch_from_dyn_impls.rs:20:1\n+   |\n+LL | / impl<T, U> DispatchFromDyn<WrapperWithExtraField<U>> for WrapperWithExtraField<T>\n+LL | | where\n+LL | |     T: DispatchFromDyn<U>,\n+LL | | {} //~^^^ ERROR [E0378]\n+   | |__^\n+   |\n+   = note: extra field `1` of type `i32` is not allowed\n+\n+error[E0378]: implementing the `DispatchFromDyn` trait requires multiple coercions\n+  --> $DIR/invalid_dispatch_from_dyn_impls.rs:31:1\n+   |\n+LL | / impl<T: ?Sized, U: ?Sized> DispatchFromDyn<MultiplePointers<U>> for MultiplePointers<T>\n+LL | | where\n+LL | |     T: Unsize<U>,\n+LL | | {} //~^^^ ERROR [E0378]\n+   | |__^\n+   |\n+   = note: the trait `DispatchFromDyn` may only be implemented for a coercion between structures with a single field being coerced\n+   = note: currently, 2 fields need coercions: `ptr1` (`*const T` to `*const U`), `ptr2` (`*const T` to `*const U`)\n+\n+error[E0378]: the trait `DispatchFromDyn` may only be implemented for a coercion between structures with a single field being coerced, none found\n+  --> $DIR/invalid_dispatch_from_dyn_impls.rs:41:1\n+   |\n+LL | impl<T: ?Sized, U: ?Sized> DispatchFromDyn<NothingToCoerce<T>> for NothingToCoerce<U> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0378]: structs implementing `DispatchFromDyn` may not have `#[repr(packed)]` or `#[repr(C)]`\n+  --> $DIR/invalid_dispatch_from_dyn_impls.rs:47:1\n+   |\n+LL | / impl<T: ?Sized, U: ?Sized> DispatchFromDyn<HasReprC<U>> for HasReprC<T>\n+LL | | where\n+LL | |     T: Unsize<U>,\n+LL | | {} //~^^^ ERROR [E0378]\n+   | |__^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0378`."}, {"sha": "7feabef56609a054c9e3334fe9072d450cc8ec2a", "filename": "src/test/ui/issues/issue-26905.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Fissues%2Fissue-26905.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Fissues%2Fissue-26905.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-26905.stderr?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -5,7 +5,7 @@ LL | impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<MyRc<U>> for MyRc<T>{\n    |                                        ^^^^^^^^^^^^^^^^^^^^^^ requires multiple coercions\n    |\n    = note: `CoerceUnsized` may only be implemented for a coercion between structures with one field being coerced\n-   = note: currently, 2 fields need coercions: _ptr (*const T to *const U), _boo (NotPhantomData<T> to NotPhantomData<U>)\n+   = note: currently, 2 fields need coercions: `_ptr` (`*const T` to `*const U`), `_boo` (`NotPhantomData<T>` to `NotPhantomData<U>`)\n \n error: aborting due to previous error\n "}, {"sha": "1db5ec097376cd95f6b1ebb138b97009e26601ea", "filename": "src/test/ui/traits/trait-item-privacy.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -110,9 +110,7 @@ fn check_assoc_const() {\n     // A, B, C are resolved as inherent items, their traits don't need to be in scope\n     C::A; //~ ERROR associated constant `A` is private\n           //~^ ERROR the trait `assoc_const::C` cannot be made into an object\n-          //~| ERROR the trait bound `dyn assoc_const::C: assoc_const::A` is not satisfied\n     C::B; // ERROR the trait `assoc_const::C` cannot be made into an object\n-          //~^ ERROR the trait bound `dyn assoc_const::C: assoc_const::B` is not satisfied\n     C::C; // OK\n }\n "}, {"sha": "4ede83d5d73627e3a68e20777e9ce401abc7c153", "filename": "src/test/ui/traits/trait-item-privacy.stderr", "status": "modified", "additions": 7, "deletions": 31, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-item-privacy.stderr?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -100,30 +100,6 @@ error[E0624]: associated constant `A` is private\n LL |     C::A; //~ ERROR associated constant `A` is private\n    |     ^^^^\n \n-error[E0277]: the trait bound `dyn assoc_const::C: assoc_const::A` is not satisfied\n-  --> $DIR/trait-item-privacy.rs:111:5\n-   |\n-LL |     C::A; //~ ERROR associated constant `A` is private\n-   |     ^^^^ the trait `assoc_const::A` is not implemented for `dyn assoc_const::C`\n-   |\n-note: required by `assoc_const::A::A`\n-  --> $DIR/trait-item-privacy.rs:35:9\n-   |\n-LL |         const A: u8 = 0;\n-   |         ^^^^^^^^^^^^^^^^\n-\n-error[E0277]: the trait bound `dyn assoc_const::C: assoc_const::B` is not satisfied\n-  --> $DIR/trait-item-privacy.rs:114:5\n-   |\n-LL |     C::B; // ERROR the trait `assoc_const::C` cannot be made into an object\n-   |     ^^^^ the trait `assoc_const::B` is not implemented for `dyn assoc_const::C`\n-   |\n-note: required by `assoc_const::B::B`\n-  --> $DIR/trait-item-privacy.rs:39:9\n-   |\n-LL |         const B: u8 = 0;\n-   |         ^^^^^^^^^^^^^^^^\n-\n error[E0038]: the trait `assoc_const::C` cannot be made into an object\n   --> $DIR/trait-item-privacy.rs:111:5\n    |\n@@ -135,36 +111,36 @@ LL |     C::A; //~ ERROR associated constant `A` is private\n    = note: the trait cannot contain associated consts like `A`\n \n error[E0223]: ambiguous associated type\n-  --> $DIR/trait-item-privacy.rs:127:12\n+  --> $DIR/trait-item-privacy.rs:125:12\n    |\n LL |     let _: S::A; //~ ERROR ambiguous associated type\n    |            ^^^^ help: use fully-qualified syntax: `<S as Trait>::A`\n \n error[E0223]: ambiguous associated type\n-  --> $DIR/trait-item-privacy.rs:128:12\n+  --> $DIR/trait-item-privacy.rs:126:12\n    |\n LL |     let _: S::B; //~ ERROR ambiguous associated type\n    |            ^^^^ help: use fully-qualified syntax: `<S as Trait>::B`\n \n error[E0223]: ambiguous associated type\n-  --> $DIR/trait-item-privacy.rs:129:12\n+  --> $DIR/trait-item-privacy.rs:127:12\n    |\n LL |     let _: S::C; //~ ERROR ambiguous associated type\n    |            ^^^^ help: use fully-qualified syntax: `<S as Trait>::C`\n \n error: associated type `A` is private\n-  --> $DIR/trait-item-privacy.rs:131:12\n+  --> $DIR/trait-item-privacy.rs:129:12\n    |\n LL |     let _: T::A; //~ ERROR associated type `A` is private\n    |            ^^^^\n \n error: associated type `A` is private\n-  --> $DIR/trait-item-privacy.rs:140:9\n+  --> $DIR/trait-item-privacy.rs:138:9\n    |\n LL |         A = u8, //~ ERROR associated type `A` is private\n    |         ^^^^^^\n \n-error: aborting due to 17 previous errors\n+error: aborting due to 15 previous errors\n \n-Some errors occurred: E0038, E0223, E0277, E0599, E0624.\n+Some errors occurred: E0038, E0223, E0599, E0624.\n For more information about an error, try `rustc --explain E0038`."}, {"sha": "01d7e89847a89fa454cd5d4bfbfc07174086e2c4", "filename": "src/test/ui/traits/trait-test-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.rs?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -20,5 +20,4 @@ fn main() {\n     (box 10 as Box<bar>).dup();\n     //~^ ERROR E0038\n     //~| ERROR E0038\n-    //~| ERROR E0277\n }"}, {"sha": "db0cd38cb6a682fe256b5370c0fc64900d70badc", "filename": "src/test/ui/traits/trait-test-2.stderr", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3fc70e8d4686190891b575204326c9b9dcd2d3ed/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-test-2.stderr?ref=3fc70e8d4686190891b575204326c9b9dcd2d3ed", "patch": "@@ -10,12 +10,6 @@ error[E0107]: wrong number of type arguments: expected 1, found 2\n LL |     10.blah::<i32, i32>(); //~ ERROR wrong number of type arguments: expected 1, found 2\n    |                    ^^^ unexpected type argument\n \n-error[E0277]: the trait bound `dyn bar: bar` is not satisfied\n-  --> $DIR/trait-test-2.rs:20:26\n-   |\n-LL |     (box 10 as Box<bar>).dup();\n-   |                          ^^^ the trait `bar` is not implemented for `dyn bar`\n-\n error[E0038]: the trait `bar` cannot be made into an object\n   --> $DIR/trait-test-2.rs:20:16\n    |\n@@ -35,7 +29,7 @@ LL |     (box 10 as Box<bar>).dup();\n    = note: method `blah` has generic type parameters\n    = note: required because of the requirements on the impl of `std::ops::CoerceUnsized<std::boxed::Box<dyn bar>>` for `std::boxed::Box<{integer}>`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n \n-Some errors occurred: E0038, E0107, E0277.\n+Some errors occurred: E0038, E0107.\n For more information about an error, try `rustc --explain E0038`."}]}