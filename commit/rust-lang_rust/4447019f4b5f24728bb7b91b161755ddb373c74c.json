{"sha": "4447019f4b5f24728bb7b91b161755ddb373c74c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NDcwMTlmNGI1ZjI0NzI4YmI3YjkxYjE2MTc1NWRkYjM3M2M3NGM=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-01T22:37:59Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-01T22:37:59Z"}, "message": "Merge #693\n\n693: Name resolution refactoring r=matklad a=flodiebold\n\nThis is still very WIP, but it's becoming quite big and I want to make sure this isn't going in a completely bad direction :sweat_smile:. I'm not really happy with how the path resolution looks, and I'm not sure `PerNs<Resolution>` is the best return type -- there are 'this cannot happen in the (types/values) namespace' cases everywhere. I also want to unify the `resolver` and `nameres` namespaces once I'm done switching everything to `Resolver`. Also, `Resolver` only has a lifetime because it needs to have a reference to the `ItemMap` during import resolution :confused: \r\n\r\nThe differences in the completion snapshots are almost completely just ordering (except it completes `Self` as well now), so I changed it to sort the completions before snapshotting.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "c53ff3531cbbad182e821eb92fa9ad201d2bff0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c53ff3531cbbad182e821eb92fa9ad201d2bff0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4447019f4b5f24728bb7b91b161755ddb373c74c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4447019f4b5f24728bb7b91b161755ddb373c74c", "html_url": "https://github.com/rust-lang/rust/commit/4447019f4b5f24728bb7b91b161755ddb373c74c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4447019f4b5f24728bb7b91b161755ddb373c74c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "2b5c226e86892113bcab478cdf4c9adaf1e7b2f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b5c226e86892113bcab478cdf4c9adaf1e7b2f6", "html_url": "https://github.com/rust-lang/rust/commit/2b5c226e86892113bcab478cdf4c9adaf1e7b2f6"}, {"sha": "c5852f422ff45adaa21815c1a15e03b067a56a82", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5852f422ff45adaa21815c1a15e03b067a56a82", "html_url": "https://github.com/rust-lang/rust/commit/c5852f422ff45adaa21815c1a15e03b067a56a82"}], "stats": {"total": 1327, "additions": 906, "deletions": 421}, "files": [{"sha": "92ab0f6922cab410c973d9c7dc50509ddac46ebe", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -5,18 +5,19 @@ use ra_db::{CrateId, FileId};\n use ra_syntax::{ast::self, TreeArc, SyntaxNode};\n \n use crate::{\n-    Name, Path, PerNs, ScopesWithSyntaxMapping, Ty, HirFileId,\n+    Name, ScopesWithSyntaxMapping, Ty, HirFileId,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, lower::ImportId},\n     HirDatabase, PersistentHirDatabase,\n-    expr::BodySyntaxMapping,\n-    ty::{InferenceResult},\n+    expr::{Body, BodySyntaxMapping},\n+    ty::InferenceResult,\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::GenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n     module_tree::ModuleId,\n     ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeId},\n     impl_block::ImplId,\n+    resolve::Resolver,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -174,13 +175,14 @@ impl Module {\n         db.item_map(self.krate)[self.module_id].clone()\n     }\n \n-    pub fn resolve_path(&self, db: &impl PersistentHirDatabase, path: &Path) -> PerNs<ModuleDef> {\n-        db.item_map(self.krate).resolve_path(db, *self, path)\n-    }\n-\n     pub fn problems(&self, db: &impl HirDatabase) -> Vec<(TreeArc<SyntaxNode>, Problem)> {\n         self.problems_impl(db)\n     }\n+\n+    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+        let item_map = db.item_map(self.krate);\n+        Resolver::default().push_module_scope(item_map, *self)\n+    }\n }\n \n impl Docs for Module {\n@@ -282,6 +284,21 @@ impl Struct {\n     pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n         db.type_for_def((*self).into())\n     }\n+\n+    // TODO move to a more general type\n+    /// Builds a resolver for type references inside this struct.\n+    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+        // take the outer scope...\n+        let r = self.module(db).resolver(db);\n+        // ...and add generic params, if present\n+        let p = self.generic_params(db);\n+        let r = if !p.params.is_empty() {\n+            r.push_generic_params_scope(p)\n+        } else {\n+            r\n+        };\n+        r\n+    }\n }\n \n impl Docs for Struct {\n@@ -331,6 +348,21 @@ impl Enum {\n     pub fn ty(&self, db: &impl HirDatabase) -> Ty {\n         db.type_for_def((*self).into())\n     }\n+\n+    // TODO move to a more general type\n+    /// Builds a resolver for type references inside this struct.\n+    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+        // take the outer scope...\n+        let r = self.module(db).resolver(db);\n+        // ...and add generic params, if present\n+        let p = self.generic_params(db);\n+        let r = if !p.params.is_empty() {\n+            r.push_generic_params_scope(p)\n+        } else {\n+            r\n+        };\n+        r\n+    }\n }\n \n impl Docs for Enum {\n@@ -449,6 +481,10 @@ impl Function {\n         db.body_syntax_mapping(*self)\n     }\n \n+    pub fn body(&self, db: &impl HirDatabase) -> Arc<Body> {\n+        db.body_hir(*self)\n+    }\n+\n     pub fn scopes(&self, db: &impl HirDatabase) -> ScopesWithSyntaxMapping {\n         let scopes = db.expr_scopes(*self);\n         let syntax_mapping = db.body_syntax_mapping(*self);\n@@ -469,6 +505,24 @@ impl Function {\n     pub fn generic_params(&self, db: &impl PersistentHirDatabase) -> Arc<GenericParams> {\n         db.generic_params((*self).into())\n     }\n+\n+    // TODO move to a more general type for 'body-having' items\n+    /// Builds a resolver for code inside this item.\n+    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+        // take the outer scope...\n+        let r = self\n+            .impl_block(db)\n+            .map(|ib| ib.resolver(db))\n+            .unwrap_or_else(|| self.module(db).resolver(db));\n+        // ...and add generic params, if present\n+        let p = self.generic_params(db);\n+        let r = if !p.params.is_empty() {\n+            r.push_generic_params_scope(p)\n+        } else {\n+            r\n+        };\n+        r\n+    }\n }\n \n impl Docs for Function {"}, {"sha": "8326c02c783b5a22f155afdf765cbebc39157d7d", "filename": "crates/ra_hir/src/code_model_impl/function.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Ffunction.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -5,14 +5,12 @@ use ra_syntax::ast::{self, NameOwner};\n use crate::{\n     HirDatabase, Name, AsName, Function, FnSignature,\n     type_ref::{TypeRef, Mutability},\n-    expr::Body, PersistentHirDatabase,\n+    PersistentHirDatabase,\n     impl_block::ImplBlock,\n };\n \n impl Function {\n-    pub(crate) fn body(&self, db: &impl HirDatabase) -> Arc<Body> {\n-        db.body_hir(*self)\n-    }\n+    // TODO impl_block should probably also be part of the code model API?\n \n     /// The containing impl block, if this is a method.\n     pub(crate) fn impl_block(&self, db: &impl HirDatabase) -> Option<ImplBlock> {"}, {"sha": "f9f702ae2bd276c493412065d0cb99691d32e08b", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 91, "deletions": 52, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -10,15 +10,15 @@ use ra_syntax::{\n };\n \n use crate::{\n-    Path, Name, Function,\n-    name::AsName, HirDatabase,\n+    Path, Name, HirDatabase, Function, Resolver,\n+    name::AsName,\n     type_ref::{Mutability, TypeRef},\n };\n use crate::ty::primitive::{UintTy, UncertainIntTy, UncertainFloatTy};\n \n pub use self::scope::{ExprScopes, ScopesWithSyntaxMapping, ScopeEntryWithSyntax};\n \n-mod scope;\n+pub(crate) mod scope;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ExprId(RawId);\n@@ -27,6 +27,9 @@ impl_arena_id!(ExprId);\n /// The body of an item (function, const etc.).\n #[derive(Debug, Eq, PartialEq)]\n pub struct Body {\n+    // TODO: this should be more general, consts & statics also have bodies\n+    /// The Function of the item this body belongs to\n+    owner: Function,\n     exprs: Arena<ExprId, Expr>,\n     pats: Arena<PatId, Pat>,\n     /// The patterns for the function's parameters. While the parameter types are\n@@ -62,6 +65,34 @@ impl Body {\n     pub fn body_expr(&self) -> ExprId {\n         self.body_expr\n     }\n+\n+    pub fn owner(&self) -> Function {\n+        self.owner\n+    }\n+\n+    pub fn syntax_mapping(&self, db: &impl HirDatabase) -> Arc<BodySyntaxMapping> {\n+        db.body_syntax_mapping(self.owner)\n+    }\n+}\n+\n+// needs arbitrary_self_types to be a method... or maybe move to the def?\n+pub fn resolver_for_expr(body: Arc<Body>, db: &impl HirDatabase, expr_id: ExprId) -> Resolver {\n+    let scopes = db.expr_scopes(body.owner);\n+    resolver_for_scope(body, db, scopes.scope_for(expr_id))\n+}\n+\n+pub fn resolver_for_scope(\n+    body: Arc<Body>,\n+    db: &impl HirDatabase,\n+    scope_id: Option<scope::ScopeId>,\n+) -> Resolver {\n+    let mut r = body.owner.resolver(db);\n+    let scopes = db.expr_scopes(body.owner);\n+    let scope_chain = scopes.scope_chain_for(scope_id).collect::<Vec<_>>();\n+    for scope in scope_chain.into_iter().rev() {\n+        r = r.push_expr_scope(Arc::clone(&scopes), scope);\n+    }\n+    r\n }\n \n impl Index<ExprId> for Body {\n@@ -448,23 +479,29 @@ pub(crate) fn body_hir(db: &impl HirDatabase, func: Function) -> Arc<Body> {\n }\n \n struct ExprCollector {\n+    owner: Function,\n     exprs: Arena<ExprId, Expr>,\n     pats: Arena<PatId, Pat>,\n     expr_syntax_mapping: FxHashMap<SyntaxNodePtr, ExprId>,\n     expr_syntax_mapping_back: ArenaMap<ExprId, SyntaxNodePtr>,\n     pat_syntax_mapping: FxHashMap<SyntaxNodePtr, PatId>,\n     pat_syntax_mapping_back: ArenaMap<PatId, SyntaxNodePtr>,\n+    params: Vec<PatId>,\n+    body_expr: Option<ExprId>,\n }\n \n impl ExprCollector {\n-    fn new() -> Self {\n+    fn new(owner: Function) -> Self {\n         ExprCollector {\n+            owner,\n             exprs: Arena::default(),\n             pats: Arena::default(),\n             expr_syntax_mapping: FxHashMap::default(),\n             expr_syntax_mapping_back: ArenaMap::default(),\n             pat_syntax_mapping: FxHashMap::default(),\n             pat_syntax_mapping_back: ArenaMap::default(),\n+            params: Vec::new(),\n+            body_expr: None,\n         }\n     }\n \n@@ -902,10 +939,7 @@ impl ExprCollector {\n                 });\n                 fields.extend(iter);\n \n-                Pat::Struct {\n-                    path: path,\n-                    args: fields,\n-                }\n+                Pat::Struct { path, args: fields }\n             }\n \n             // TODO: implement\n@@ -923,12 +957,48 @@ impl ExprCollector {\n         }\n     }\n \n-    fn into_body_syntax_mapping(self, params: Vec<PatId>, body_expr: ExprId) -> BodySyntaxMapping {\n+    fn collect_fn_body(&mut self, node: &ast::FnDef) {\n+        if let Some(param_list) = node.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_param = SyntaxNodePtr::new(\n+                    self_param\n+                        .self_kw()\n+                        .expect(\"self param without self keyword\")\n+                        .syntax(),\n+                );\n+                let param_pat = self.alloc_pat(\n+                    Pat::Bind {\n+                        name: Name::self_param(),\n+                        mode: BindingAnnotation::Unannotated,\n+                        subpat: None,\n+                    },\n+                    self_param,\n+                );\n+                self.params.push(param_pat);\n+            }\n+\n+            for param in param_list.params() {\n+                let pat = if let Some(pat) = param.pat() {\n+                    pat\n+                } else {\n+                    continue;\n+                };\n+                let param_pat = self.collect_pat(pat);\n+                self.params.push(param_pat);\n+            }\n+        };\n+\n+        let body = self.collect_block_opt(node.body());\n+        self.body_expr = Some(body);\n+    }\n+\n+    fn into_body_syntax_mapping(self) -> BodySyntaxMapping {\n         let body = Body {\n+            owner: self.owner,\n             exprs: self.exprs,\n             pats: self.pats,\n-            params,\n-            body_expr,\n+            params: self.params,\n+            body_expr: self.body_expr.expect(\"A body should have been collected\"),\n         };\n         BodySyntaxMapping {\n             body: Arc::new(body),\n@@ -940,49 +1010,18 @@ impl ExprCollector {\n     }\n }\n \n-pub(crate) fn collect_fn_body_syntax(node: &ast::FnDef) -> BodySyntaxMapping {\n-    let mut collector = ExprCollector::new();\n-\n-    let params = if let Some(param_list) = node.param_list() {\n-        let mut params = Vec::new();\n-\n-        if let Some(self_param) = param_list.self_param() {\n-            let self_param = SyntaxNodePtr::new(\n-                self_param\n-                    .self_kw()\n-                    .expect(\"self param without self keyword\")\n-                    .syntax(),\n-            );\n-            let param = collector.alloc_pat(\n-                Pat::Bind {\n-                    name: Name::self_param(),\n-                    mode: BindingAnnotation::Unannotated,\n-                    subpat: None,\n-                },\n-                self_param,\n-            );\n-            params.push(param);\n-        }\n+pub(crate) fn body_syntax_mapping(db: &impl HirDatabase, func: Function) -> Arc<BodySyntaxMapping> {\n+    let mut collector = ExprCollector::new(func);\n \n-        for param in param_list.params() {\n-            let pat = if let Some(pat) = param.pat() {\n-                pat\n-            } else {\n-                continue;\n-            };\n-            params.push(collector.collect_pat(pat));\n-        }\n-        params\n-    } else {\n-        Vec::new()\n-    };\n+    // TODO: consts, etc.\n+    collector.collect_fn_body(&func.source(db).1);\n \n-    let body = collector.collect_block_opt(node.body());\n-    collector.into_body_syntax_mapping(params, body)\n+    Arc::new(collector.into_body_syntax_mapping())\n }\n \n-pub(crate) fn body_syntax_mapping(db: &impl HirDatabase, func: Function) -> Arc<BodySyntaxMapping> {\n-    let (_, fn_def) = func.source(db);\n-    let body_syntax_mapping = collect_fn_body_syntax(&fn_def);\n-    Arc::new(body_syntax_mapping)\n+#[cfg(test)]\n+pub(crate) fn collect_fn_body_syntax(function: Function, node: &ast::FnDef) -> BodySyntaxMapping {\n+    let mut collector = ExprCollector::new(function);\n+    collector.collect_fn_body(node);\n+    collector.into_body_syntax_mapping()\n }"}, {"sha": "9202e367126edc5785e1b31a610b420bc892a941", "filename": "crates/ra_hir/src/expr/scope.rs", "status": "modified", "additions": 24, "deletions": 31, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fscope.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -58,28 +58,19 @@ impl ExprScopes {\n         scopes\n     }\n \n-    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n-        &self.scopes[scope].entries\n+    pub fn body(&self) -> Arc<Body> {\n+        self.body.clone()\n     }\n \n-    pub fn scope_chain_for<'a>(&'a self, expr: ExprId) -> impl Iterator<Item = ScopeId> + 'a {\n-        generate(self.scope_for(expr), move |&scope| {\n-            self.scopes[scope].parent\n-        })\n+    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+        &self.scopes[scope].entries\n     }\n \n-    pub fn resolve_local_name<'a>(\n+    pub fn scope_chain_for<'a>(\n         &'a self,\n-        context_expr: ExprId,\n-        name: Name,\n-    ) -> Option<&'a ScopeEntry> {\n-        let mut shadowed = FxHashSet::default();\n-        let ret = self\n-            .scope_chain_for(context_expr)\n-            .flat_map(|scope| self.entries(scope).iter())\n-            .filter(|entry| shadowed.insert(entry.name()))\n-            .find(|entry| entry.name() == &name);\n-        ret\n+        scope: Option<ScopeId>,\n+    ) -> impl Iterator<Item = ScopeId> + 'a {\n+        generate(scope, move |&scope| self.scopes[scope].parent)\n     }\n \n     fn root_scope(&mut self) -> ScopeId {\n@@ -122,7 +113,7 @@ impl ExprScopes {\n         self.scope_for.insert(node, scope);\n     }\n \n-    fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n+    pub fn scope_for(&self, expr: ExprId) -> Option<ScopeId> {\n         self.scope_for.get(&expr).map(|&scope| scope)\n     }\n }\n@@ -150,18 +141,14 @@ impl ScopeEntryWithSyntax {\n }\n \n impl ScopesWithSyntaxMapping {\n-    pub fn scope_chain<'a>(&'a self, node: &SyntaxNode) -> impl Iterator<Item = ScopeId> + 'a {\n+    fn scope_chain<'a>(&'a self, node: &SyntaxNode) -> impl Iterator<Item = ScopeId> + 'a {\n         generate(self.scope_for(node), move |&scope| {\n             self.scopes.scopes[scope].parent\n         })\n     }\n \n-    pub fn scope_chain_for_offset<'a>(\n-        &'a self,\n-        offset: TextUnit,\n-    ) -> impl Iterator<Item = ScopeId> + 'a {\n-        let scope = self\n-            .scopes\n+    pub fn scope_for_offset<'a>(&'a self, offset: TextUnit) -> Option<ScopeId> {\n+        self.scopes\n             .scope_for\n             .iter()\n             .filter_map(|(id, scope)| Some((self.syntax_mapping.expr_syntax(*id)?, scope)))\n@@ -172,13 +159,12 @@ impl ScopesWithSyntaxMapping {\n                     ptr.range().len(),\n                 )\n             })\n-            .map(|(ptr, scope)| self.adjust(ptr, *scope, offset));\n-\n-        generate(scope, move |&scope| self.scopes.scopes[scope].parent)\n+            .map(|(ptr, scope)| self.adjust(ptr, *scope, offset))\n     }\n \n     // XXX: during completion, cursor might be outside of any particular\n     // expression. Try to figure out the correct scope...\n+    // TODO: move this to source binder?\n     fn adjust(&self, ptr: SyntaxNodePtr, original_scope: ScopeId, offset: TextUnit) -> ScopeId {\n         let r = ptr.range();\n         let child_scopes = self\n@@ -238,7 +224,7 @@ impl ScopesWithSyntaxMapping {\n             .collect()\n     }\n \n-    fn scope_for(&self, node: &SyntaxNode) -> Option<ScopeId> {\n+    pub fn scope_for(&self, node: &SyntaxNode) -> Option<ScopeId> {\n         node.ancestors()\n             .map(SyntaxNodePtr::new)\n             .filter_map(|ptr| self.syntax_mapping.syntax_expr(ptr))\n@@ -336,6 +322,7 @@ pub struct ReferenceDescriptor {\n mod tests {\n     use ra_syntax::{SourceFile, algo::find_node_at_offset};\n     use test_utils::{extract_offset, assert_eq_text};\n+    use ra_arena::ArenaId;\n \n     use crate::expr;\n \n@@ -354,7 +341,10 @@ mod tests {\n         let file = SourceFile::parse(&code);\n         let marker: &ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n         let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n-        let body_hir = expr::collect_fn_body_syntax(fn_def);\n+        let irrelevant_function = Function {\n+            id: crate::ids::FunctionId::from_raw(0.into()),\n+        };\n+        let body_hir = expr::collect_fn_body_syntax(irrelevant_function, fn_def);\n         let scopes = ExprScopes::new(Arc::clone(body_hir.body()));\n         let scopes = ScopesWithSyntaxMapping {\n             scopes: Arc::new(scopes),\n@@ -454,7 +444,10 @@ mod tests {\n         let fn_def: &ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n         let name_ref: &ast::NameRef = find_node_at_offset(file.syntax(), off).unwrap();\n \n-        let body_hir = expr::collect_fn_body_syntax(fn_def);\n+        let irrelevant_function = Function {\n+            id: crate::ids::FunctionId::from_raw(0.into()),\n+        };\n+        let body_hir = expr::collect_fn_body_syntax(irrelevant_function, fn_def);\n         let scopes = ExprScopes::new(Arc::clone(body_hir.body()));\n         let scopes = ScopesWithSyntaxMapping {\n             scopes: Arc::new(scopes),"}, {"sha": "a82205f0b3e0d1d7bd9ca21441d4029cd10b8159", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -12,6 +12,7 @@ use crate::{db::PersistentHirDatabase, Name, AsName, Function, Struct, Enum, Tra\n /// Data about a generic parameter (to a function, struct, impl, ...).\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct GenericParam {\n+    // TODO: give generic params proper IDs\n     pub(crate) idx: u32,\n     pub(crate) name: Name,\n }"}, {"sha": "738c58fbe88a9102add56fe7470309fa0f0b62da", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 49, "deletions": 20, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -7,11 +7,13 @@ use ra_syntax::{\n ast::{self, AstNode}};\n \n use crate::{\n-    Const, Type,\n-    Function, HirFileId,\n-    PersistentHirDatabase,\n+    Const, Type, Function, HirFileId,\n+    HirDatabase, PersistentHirDatabase,\n+    ModuleDef, Trait, Resolution,\n     type_ref::TypeRef,\n     ids::LocationCtx,\n+    resolve::Resolver,\n+    ty::Ty,\n };\n \n use crate::code_model_api::{Module, ModuleSource};\n@@ -69,17 +71,44 @@ impl ImplBlock {\n         &self.module_impl_blocks.impls[self.impl_id]\n     }\n \n-    pub fn target_trait(&self) -> Option<&TypeRef> {\n+    pub fn module(&self) -> Module {\n+        self.module_impl_blocks.module.clone()\n+    }\n+\n+    pub fn target_trait_ref(&self) -> Option<&TypeRef> {\n         self.impl_data().target_trait()\n     }\n \n     pub fn target_type(&self) -> &TypeRef {\n         self.impl_data().target_type()\n     }\n \n+    pub fn target_ty(&self, db: &impl HirDatabase) -> Ty {\n+        Ty::from_hir(db, &self.resolver(db), self.target_type())\n+    }\n+\n+    pub fn target_trait(&self, db: &impl HirDatabase) -> Option<Trait> {\n+        if let Some(TypeRef::Path(path)) = self.target_trait_ref() {\n+            let resolver = self.resolver(db);\n+            if let Some(Resolution::Def(ModuleDef::Trait(tr))) =\n+                resolver.resolve_path(db, path).take_types()\n+            {\n+                return Some(tr);\n+            }\n+        }\n+        None\n+    }\n+\n     pub fn items(&self) -> &[ImplItem] {\n         self.impl_data().items()\n     }\n+\n+    pub fn resolver(&self, db: &impl HirDatabase) -> Resolver {\n+        let r = self.module().resolver(db);\n+        // TODO: add generics\n+        let r = r.push_impl_block_scope(self.clone());\n+        r\n+    }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -162,25 +191,24 @@ impl_arena_id!(ImplId);\n /// we don't need to do the second step again.\n #[derive(Debug, PartialEq, Eq)]\n pub struct ModuleImplBlocks {\n+    module: Module,\n     pub(crate) impls: Arena<ImplId, ImplData>,\n     impls_by_def: FxHashMap<ImplItem, ImplId>,\n }\n \n impl ModuleImplBlocks {\n-    fn new() -> Self {\n-        ModuleImplBlocks {\n-            impls: Arena::default(),\n-            impls_by_def: FxHashMap::default(),\n-        }\n-    }\n-\n     fn collect(\n-        &mut self,\n         db: &impl PersistentHirDatabase,\n         module: Module,\n         source_map: &mut ImplSourceMap,\n-    ) {\n-        let (file_id, module_source) = module.definition_source(db);\n+    ) -> Self {\n+        let mut m = ModuleImplBlocks {\n+            module,\n+            impls: Arena::default(),\n+            impls_by_def: FxHashMap::default(),\n+        };\n+\n+        let (file_id, module_source) = m.module.definition_source(db);\n         let file_id: HirFileId = file_id.into();\n         let node = match &module_source {\n             ModuleSource::SourceFile(node) => node.syntax(),\n@@ -191,14 +219,16 @@ impl ModuleImplBlocks {\n         };\n \n         for impl_block_ast in node.children().filter_map(ast::ImplBlock::cast) {\n-            let impl_block = ImplData::from_ast(db, file_id, module, impl_block_ast);\n-            let id = self.impls.alloc(impl_block);\n-            for &impl_item in &self.impls[id].items {\n-                self.impls_by_def.insert(impl_item, id);\n+            let impl_block = ImplData::from_ast(db, file_id, m.module, impl_block_ast);\n+            let id = m.impls.alloc(impl_block);\n+            for &impl_item in &m.impls[id].items {\n+                m.impls_by_def.insert(impl_item, id);\n             }\n \n             source_map.insert(id, impl_block_ast);\n         }\n+\n+        m\n     }\n }\n \n@@ -208,8 +238,7 @@ pub(crate) fn impls_in_module_with_source_map_query(\n ) -> (Arc<ModuleImplBlocks>, Arc<ImplSourceMap>) {\n     let mut source_map = ImplSourceMap::default();\n \n-    let mut result = ModuleImplBlocks::new();\n-    result.collect(db, module, &mut source_map);\n+    let result = ModuleImplBlocks::collect(db, module, &mut source_map);\n \n     (Arc::new(result), Arc::new(source_map))\n }"}, {"sha": "54da5559857eeba84a4bfdc4e96255fb686be19d", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -36,6 +36,7 @@ mod impl_block;\n mod expr;\n mod generics;\n mod docs;\n+mod resolve;\n \n mod code_model_api;\n mod code_model_impl;\n@@ -54,12 +55,13 @@ pub use self::{\n     name::Name,\n     ids::{HirFileId, MacroCallId, MacroCallLoc, HirInterner},\n     macros::{MacroDef, MacroInput, MacroExpansion},\n-    nameres::{ItemMap, PerNs, Namespace, Resolution},\n+    nameres::{ItemMap, PerNs, Namespace},\n     ty::Ty,\n     impl_block::{ImplBlock, ImplItem},\n     docs::{Docs, Documentation},\n     adt::AdtDef,\n     expr::{ExprScopes, ScopesWithSyntaxMapping},\n+    resolve::{Resolver, Resolution},\n };\n \n pub use self::code_model_api::{"}, {"sha": "7ec6512b64570df2a5058d7f52aaf7bc5a1bfe67", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -24,13 +24,13 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     Module, ModuleDef,\n-    Path, PathKind, Crate,\n-    Name, PersistentHirDatabase,\n+    Path, PathKind, PersistentHirDatabase,\n+    Crate, Name,\n     module_tree::{ModuleId, ModuleTree},\n     nameres::lower::{ImportId, LoweredModule, ImportData},\n };\n \n-/// `ItemMap` is the result of name resolution. It contains, for each\n+/// `ItemMap` is the result of module name resolution. It contains, for each\n /// module, the set of visible items.\n #[derive(Default, Debug, PartialEq, Eq)]\n pub struct ItemMap {\n@@ -46,7 +46,7 @@ impl std::ops::Index<ModuleId> for ItemMap {\n \n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n-    items: FxHashMap<Name, Resolution>,\n+    pub(crate) items: FxHashMap<Name, Resolution>,\n }\n \n impl ModuleScope {\n@@ -80,6 +80,15 @@ pub struct PerNs<T> {\n     pub values: Option<T>,\n }\n \n+impl<T> Default for PerNs<T> {\n+    fn default() -> Self {\n+        PerNs {\n+            types: None,\n+            values: None,\n+        }\n+    }\n+}\n+\n impl<T> PerNs<T> {\n     pub fn none() -> PerNs<T> {\n         PerNs {\n@@ -113,6 +122,10 @@ impl<T> PerNs<T> {\n         self.types.is_none() && self.values.is_none()\n     }\n \n+    pub fn is_both(&self) -> bool {\n+        self.types.is_some() && self.values.is_some()\n+    }\n+\n     pub fn take(self, namespace: Namespace) -> Option<T> {\n         match namespace {\n             Namespace::Types => self.types,\n@@ -139,6 +152,13 @@ impl<T> PerNs<T> {\n         }\n     }\n \n+    pub fn combine(self, other: PerNs<T>) -> PerNs<T> {\n+        PerNs {\n+            types: self.types.or(other.types),\n+            values: self.values.or(other.values),\n+        }\n+    }\n+\n     pub fn and_then<U>(self, f: impl Fn(T) -> Option<U>) -> PerNs<U> {\n         PerNs {\n             types: self.types.and_then(&f),\n@@ -402,10 +422,11 @@ impl ItemMap {\n                     if module.krate != original_module.krate {\n                         let path = Path {\n                             segments: path.segments[i..].iter().cloned().collect(),\n-                            kind: PathKind::Crate,\n+                            kind: PathKind::Self_,\n                         };\n                         log::debug!(\"resolving {:?} in other crate\", path);\n-                        let def = module.resolve_path(db, &path);\n+                        let item_map = db.item_map(module.krate);\n+                        let def = item_map.resolve_path(db, *module, &path);\n                         return (def, ReachedFixedPoint::Yes);\n                     }\n "}, {"sha": "0e0683db7723e037c07c4a5a30574a49aea5e8fc", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -5,11 +5,12 @@ use relative_path::RelativePath;\n use test_utils::{assert_eq_text, covers};\n \n use crate::{\n-    ItemMap, Resolution,\n+    ItemMap,\n     PersistentHirDatabase,\n     mock::MockDatabase,\n     module_tree::ModuleId,\n };\n+use super::Resolution;\n \n fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n     let (db, pos) = MockDatabase::with_position(fixture);"}, {"sha": "6c87d0df724294c6c1fcb6cbf3e77fcb1e101fa8", "filename": "crates/ra_hir/src/resolve.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -0,0 +1,226 @@\n+//! Name resolution.\n+use std::sync::Arc;\n+\n+use rustc_hash::FxHashMap;\n+\n+use crate::{\n+    ModuleDef, Module,\n+    db::HirDatabase,\n+    name::{Name, KnownName},\n+    nameres::{PerNs, ItemMap},\n+    generics::GenericParams,\n+    expr::{scope::{ExprScopes, ScopeId}, PatId, Body},\n+    impl_block::ImplBlock,\n+    path::Path,\n+};\n+\n+#[derive(Debug, Clone, Default)]\n+pub struct Resolver {\n+    scopes: Vec<Scope>,\n+}\n+\n+// TODO how to store these best\n+#[derive(Debug, Clone)]\n+pub(crate) struct ModuleItemMap {\n+    item_map: Arc<ItemMap>,\n+    module: Module,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(crate) struct ExprScope {\n+    expr_scopes: Arc<ExprScopes>,\n+    scope_id: ScopeId,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub(crate) enum Scope {\n+    /// All the items and imported names of a module\n+    ModuleScope(ModuleItemMap),\n+    /// Brings the generic parameters of an item into scope\n+    GenericParams(Arc<GenericParams>),\n+    /// Brings `Self` into scope\n+    ImplBlockScope(ImplBlock),\n+    /// Local bindings\n+    ExprScope(ExprScope),\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum Resolution {\n+    /// An item\n+    Def(ModuleDef),\n+    /// A local binding (only value namespace)\n+    LocalBinding(PatId),\n+    /// A generic parameter\n+    GenericParam(u32),\n+    SelfType(ImplBlock),\n+}\n+\n+impl Resolver {\n+    pub fn resolve_name(&self, name: &Name) -> PerNs<Resolution> {\n+        let mut resolution = PerNs::none();\n+        for scope in self.scopes.iter().rev() {\n+            resolution = resolution.combine(scope.resolve_name(name));\n+            if resolution.is_both() {\n+                return resolution;\n+            }\n+        }\n+        resolution\n+    }\n+\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<Resolution> {\n+        if let Some(name) = path.as_ident() {\n+            self.resolve_name(name)\n+        } else if path.is_self() {\n+            self.resolve_name(&Name::self_param())\n+        } else {\n+            let (item_map, module) = match self.module() {\n+                Some(m) => m,\n+                _ => return PerNs::none(),\n+            };\n+            let module_res = item_map.resolve_path(db, module, path);\n+            module_res.map(|def| Resolution::Def(def))\n+        }\n+    }\n+\n+    pub fn all_names(&self) -> FxHashMap<Name, PerNs<Resolution>> {\n+        let mut names = FxHashMap::default();\n+        for scope in self.scopes.iter().rev() {\n+            scope.collect_names(&mut |name, res| {\n+                let current: &mut PerNs<Resolution> = names.entry(name).or_default();\n+                if current.types.is_none() {\n+                    current.types = res.types;\n+                }\n+                if current.values.is_none() {\n+                    current.values = res.values;\n+                }\n+            });\n+        }\n+        names\n+    }\n+\n+    fn module(&self) -> Option<(&ItemMap, Module)> {\n+        self.scopes.iter().rev().find_map(|scope| match scope {\n+            Scope::ModuleScope(m) => Some((&*m.item_map, m.module.clone())),\n+\n+            _ => None,\n+        })\n+    }\n+\n+    /// The body from which any `LocalBinding` resolutions in this resolver come.\n+    pub fn body(&self) -> Option<Arc<Body>> {\n+        self.scopes.iter().rev().find_map(|scope| match scope {\n+            Scope::ExprScope(expr_scope) => Some(expr_scope.expr_scopes.body()),\n+            _ => None,\n+        })\n+    }\n+}\n+\n+impl Resolver {\n+    pub(crate) fn push_scope(mut self, scope: Scope) -> Resolver {\n+        self.scopes.push(scope);\n+        self\n+    }\n+\n+    pub(crate) fn push_generic_params_scope(self, params: Arc<GenericParams>) -> Resolver {\n+        self.push_scope(Scope::GenericParams(params))\n+    }\n+\n+    pub(crate) fn push_impl_block_scope(self, impl_block: ImplBlock) -> Resolver {\n+        self.push_scope(Scope::ImplBlockScope(impl_block))\n+    }\n+\n+    pub(crate) fn push_module_scope(self, item_map: Arc<ItemMap>, module: Module) -> Resolver {\n+        self.push_scope(Scope::ModuleScope(ModuleItemMap { item_map, module }))\n+    }\n+\n+    pub(crate) fn push_expr_scope(\n+        self,\n+        expr_scopes: Arc<ExprScopes>,\n+        scope_id: ScopeId,\n+    ) -> Resolver {\n+        self.push_scope(Scope::ExprScope(ExprScope {\n+            expr_scopes,\n+            scope_id,\n+        }))\n+    }\n+}\n+\n+impl Scope {\n+    fn resolve_name(&self, name: &Name) -> PerNs<Resolution> {\n+        match self {\n+            Scope::ModuleScope(m) => {\n+                if let Some(KnownName::SelfParam) = name.as_known_name() {\n+                    PerNs::types(Resolution::Def(m.module.into()))\n+                } else {\n+                    match m.item_map[m.module.module_id].get(name) {\n+                        Some(res) => res.def.map(Resolution::Def),\n+                        None => PerNs::none(),\n+                    }\n+                }\n+            }\n+            Scope::GenericParams(gp) => match gp.find_by_name(name) {\n+                Some(gp) => PerNs::types(Resolution::GenericParam(gp.idx)),\n+                None => PerNs::none(),\n+            },\n+            Scope::ImplBlockScope(i) => {\n+                if name.as_known_name() == Some(KnownName::SelfType) {\n+                    PerNs::types(Resolution::SelfType(i.clone()))\n+                } else {\n+                    PerNs::none()\n+                }\n+            }\n+            Scope::ExprScope(e) => {\n+                let entry = e\n+                    .expr_scopes\n+                    .entries(e.scope_id)\n+                    .iter()\n+                    .find(|entry| entry.name() == name);\n+                match entry {\n+                    Some(e) => PerNs::values(Resolution::LocalBinding(e.pat())),\n+                    None => PerNs::none(),\n+                }\n+            }\n+        }\n+    }\n+\n+    fn collect_names(&self, f: &mut FnMut(Name, PerNs<Resolution>)) {\n+        match self {\n+            Scope::ModuleScope(m) => {\n+                // TODO: should we provide `self` here?\n+                // f(\n+                //     Name::self_param(),\n+                //     PerNs::types(Resolution::Def {\n+                //         def: m.module.into(),\n+                //     }),\n+                // );\n+                m.item_map[m.module.module_id]\n+                    .entries()\n+                    .for_each(|(name, res)| {\n+                        f(name.clone(), res.def.map(Resolution::Def));\n+                    })\n+            }\n+            Scope::GenericParams(gp) => {\n+                for param in &gp.params {\n+                    f(\n+                        param.name.clone(),\n+                        PerNs::types(Resolution::GenericParam(param.idx)),\n+                    )\n+                }\n+            }\n+            Scope::ImplBlockScope(i) => {\n+                f(\n+                    Name::self_type(),\n+                    PerNs::types(Resolution::SelfType(i.clone())),\n+                );\n+            }\n+            Scope::ExprScope(e) => {\n+                e.expr_scopes.entries(e.scope_id).iter().for_each(|e| {\n+                    f(\n+                        e.name().clone(),\n+                        PerNs::values(Resolution::LocalBinding(e.pat())),\n+                    );\n+                });\n+            }\n+        }\n+    }\n+}"}, {"sha": "59f7822774c8805574c2f06f17354e5c205e35ed", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -9,13 +9,14 @@ use ra_db::{FileId, FilePosition};\n use ra_syntax::{\n     SmolStr, TextRange, SyntaxNode,\n     ast::{self, AstNode, NameOwner},\n-    algo::find_node_at_offset,\n+    algo::{find_node_at_offset, find_leaf_at_offset},\n };\n \n use crate::{\n     HirDatabase, Function, ModuleDef, Struct, Enum,\n-    AsName, Module, HirFileId, Crate, Trait,\n+    AsName, Module, HirFileId, Crate, Trait, Resolver,\n     ids::{LocationCtx, SourceFileItemId},\n+    expr\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -201,3 +202,67 @@ pub fn macro_symbols(db: &impl HirDatabase, file_id: FileId) -> Vec<(SmolStr, Te\n \n     res\n }\n+\n+pub fn resolver_for_position(db: &impl HirDatabase, position: FilePosition) -> Resolver {\n+    let file_id = position.file_id;\n+    let file = db.parse(file_id);\n+    find_leaf_at_offset(file.syntax(), position.offset)\n+        .find_map(|node| {\n+            node.ancestors().find_map(|node| {\n+                if ast::Expr::cast(node).is_some() || ast::Block::cast(node).is_some() {\n+                    if let Some(func) = function_from_child_node(db, file_id, node) {\n+                        let scopes = func.scopes(db);\n+                        let scope = scopes.scope_for_offset(position.offset);\n+                        Some(expr::resolver_for_scope(func.body(db), db, scope))\n+                    } else {\n+                        // TODO const/static/array length\n+                        None\n+                    }\n+                } else if let Some(module) = ast::Module::cast(node) {\n+                    Some(module_from_declaration(db, file_id, module)?.resolver(db))\n+                } else if let Some(_) = ast::SourceFile::cast(node) {\n+                    Some(module_from_source(db, file_id.into(), None)?.resolver(db))\n+                } else if let Some(s) = ast::StructDef::cast(node) {\n+                    let module = module_from_child_node(db, file_id, s.syntax())?;\n+                    Some(struct_from_module(db, module, s).resolver(db))\n+                } else if let Some(e) = ast::EnumDef::cast(node) {\n+                    let module = module_from_child_node(db, file_id, e.syntax())?;\n+                    Some(enum_from_module(db, module, e).resolver(db))\n+                } else {\n+                    // TODO add missing cases\n+                    None\n+                }\n+            })\n+        })\n+        .unwrap_or_default()\n+}\n+\n+pub fn resolver_for_node(db: &impl HirDatabase, file_id: FileId, node: &SyntaxNode) -> Resolver {\n+    node.ancestors()\n+        .find_map(|node| {\n+            if ast::Expr::cast(node).is_some() || ast::Block::cast(node).is_some() {\n+                if let Some(func) = function_from_child_node(db, file_id, node) {\n+                    let scopes = func.scopes(db);\n+                    let scope = scopes.scope_for(&node);\n+                    Some(expr::resolver_for_scope(func.body(db), db, scope))\n+                } else {\n+                    // TODO const/static/array length\n+                    None\n+                }\n+            } else if let Some(module) = ast::Module::cast(node) {\n+                Some(module_from_declaration(db, file_id, module)?.resolver(db))\n+            } else if let Some(_) = ast::SourceFile::cast(node) {\n+                Some(module_from_source(db, file_id.into(), None)?.resolver(db))\n+            } else if let Some(s) = ast::StructDef::cast(node) {\n+                let module = module_from_child_node(db, file_id, s.syntax())?;\n+                Some(struct_from_module(db, module, s).resolver(db))\n+            } else if let Some(e) = ast::EnumDef::cast(node) {\n+                let module = module_from_child_node(db, file_id, e.syntax())?;\n+                Some(enum_from_module(db, module, e).resolver(db))\n+            } else {\n+                // TODO add missing cases\n+                None\n+            }\n+        })\n+        .unwrap_or_default()\n+}"}, {"sha": "cc5afad7533dca791ce3a2315656355c1e533d86", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 113, "deletions": 157, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -33,15 +33,16 @@ use rustc_hash::FxHashMap;\n use test_utils::tested_by;\n \n use crate::{\n-    Module, Function, Struct, StructField, Enum, EnumVariant, Path, Name, ImplBlock,\n-    FnSignature, ExprScopes, ModuleDef, AdtDef,\n+    Function, Struct, StructField, Enum, EnumVariant, Path, Name,\n+    FnSignature, ModuleDef, AdtDef,\n     HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n-    expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat},\n+    expr::{Body, Expr, BindingAnnotation, Literal, ExprId, Pat, PatId, UnaryOp, BinaryOp, Statement, FieldPat, self},\n     generics::GenericParams,\n     path::GenericArg,\n     adt::VariantDef,\n+    resolve::{Resolver, Resolution},\n };\n \n /// The ID of a type variable.\n@@ -300,47 +301,38 @@ pub struct FnSig {\n }\n \n impl Ty {\n-    pub(crate) fn from_hir(\n-        db: &impl HirDatabase,\n-        // TODO: the next three parameters basically describe the scope for name\n-        // resolution; this should be refactored into something like a general\n-        // resolver architecture\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        generics: &GenericParams,\n-        type_ref: &TypeRef,\n-    ) -> Self {\n+    pub(crate) fn from_hir(db: &impl HirDatabase, resolver: &Resolver, type_ref: &TypeRef) -> Self {\n         match type_ref {\n             TypeRef::Never => Ty::Never,\n             TypeRef::Tuple(inner) => {\n                 let inner_tys = inner\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, impl_block, generics, tr))\n+                    .map(|tr| Ty::from_hir(db, resolver, tr))\n                     .collect::<Vec<_>>();\n                 Ty::Tuple(inner_tys.into())\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(db, module, impl_block, generics, path),\n+            TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n             TypeRef::RawPtr(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n                 Ty::RawPtr(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Array(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n                 Ty::Array(Arc::new(inner_ty))\n             }\n             TypeRef::Slice(inner) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n                 Ty::Slice(Arc::new(inner_ty))\n             }\n             TypeRef::Reference(inner, mutability) => {\n-                let inner_ty = Ty::from_hir(db, module, impl_block, generics, inner);\n+                let inner_ty = Ty::from_hir(db, resolver, inner);\n                 Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n                 let mut inner_tys = params\n                     .iter()\n-                    .map(|tr| Ty::from_hir(db, module, impl_block, generics, tr))\n+                    .map(|tr| Ty::from_hir(db, resolver, tr))\n                     .collect::<Vec<_>>();\n                 let return_ty = inner_tys\n                     .pop()\n@@ -355,77 +347,62 @@ impl Ty {\n         }\n     }\n \n-    pub(crate) fn from_hir_opt(\n-        db: &impl HirDatabase,\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        generics: &GenericParams,\n-        type_ref: Option<&TypeRef>,\n-    ) -> Self {\n-        type_ref.map_or(Ty::Unknown, |t| {\n-            Ty::from_hir(db, module, impl_block, generics, t)\n-        })\n-    }\n-\n-    pub(crate) fn from_hir_path(\n-        db: &impl HirDatabase,\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        generics: &GenericParams,\n-        path: &Path,\n-    ) -> Self {\n+    pub(crate) fn from_hir_path(db: &impl HirDatabase, resolver: &Resolver, path: &Path) -> Self {\n         if let Some(name) = path.as_ident() {\n+            // TODO handle primitive type names in resolver as well?\n             if let Some(int_ty) = primitive::UncertainIntTy::from_name(name) {\n                 return Ty::Int(int_ty);\n             } else if let Some(float_ty) = primitive::UncertainFloatTy::from_name(name) {\n                 return Ty::Float(float_ty);\n-            } else if name.as_known_name() == Some(KnownName::SelfType) {\n-                // TODO pass the impl block's generics?\n-                let generics = &GenericParams::default();\n-                return Ty::from_hir_opt(\n-                    db,\n-                    module,\n-                    None,\n-                    generics,\n-                    impl_block.map(|i| i.target_type()),\n-                );\n             } else if let Some(known) = name.as_known_name() {\n                 match known {\n                     KnownName::Bool => return Ty::Bool,\n                     KnownName::Char => return Ty::Char,\n                     KnownName::Str => return Ty::Str,\n                     _ => {}\n                 }\n-            } else if let Some(generic_param) = generics.find_by_name(&name) {\n+            }\n+        }\n+\n+        // Resolve the path (in type namespace)\n+        let resolution = resolver.resolve_path(db, path).take_types();\n+\n+        let def = match resolution {\n+            Some(Resolution::Def(def)) => def,\n+            Some(Resolution::LocalBinding(..)) => {\n+                // this should never happen\n+                panic!(\"path resolved to local binding in type ns\");\n+            }\n+            Some(Resolution::GenericParam(idx)) => {\n                 return Ty::Param {\n-                    idx: generic_param.idx,\n-                    name: generic_param.name.clone(),\n+                    idx,\n+                    // TODO: maybe return name in resolution?\n+                    name: path\n+                        .as_ident()\n+                        .expect(\"generic param should be single-segment path\")\n+                        .clone(),\n                 };\n             }\n-        }\n+            Some(Resolution::SelfType(impl_block)) => {\n+                return impl_block.target_ty(db);\n+            }\n+            None => return Ty::Unknown,\n+        };\n \n-        // Resolve in module (in type namespace)\n-        let typable: TypableDef = match module\n-            .resolve_path(db, path)\n-            .take_types()\n-            .and_then(|it| it.into())\n-        {\n+        let typable: TypableDef = match def.into() {\n             None => return Ty::Unknown,\n             Some(it) => it,\n         };\n         let ty = db.type_for_def(typable);\n-        let substs = Ty::substs_from_path(db, module, impl_block, generics, path, typable);\n+        let substs = Ty::substs_from_path(db, resolver, path, typable);\n         ty.apply_substs(substs)\n     }\n \n     /// Collect generic arguments from a path into a `Substs`. See also\n     /// `create_substs_for_ast_path` and `def_to_ty` in rustc.\n     fn substs_from_path(\n         db: &impl HirDatabase,\n-        // the scope of the segment...\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        outer_generics: &GenericParams,\n+        resolver: &Resolver,\n         path: &Path,\n         resolved: TypableDef,\n     ) -> Substs {\n@@ -462,7 +439,7 @@ impl Ty {\n             for arg in generic_args.args.iter().take(param_count) {\n                 match arg {\n                     GenericArg::Type(type_ref) => {\n-                        let ty = Ty::from_hir(db, module, impl_block, outer_generics, type_ref);\n+                        let ty = Ty::from_hir(db, resolver, type_ref);\n                         substs.push(ty);\n                     }\n                 }\n@@ -666,24 +643,17 @@ impl fmt::Display for Ty {\n /// function body.\n fn type_for_fn(db: &impl HirDatabase, def: Function) -> Ty {\n     let signature = def.signature(db);\n-    let module = def.module(db);\n-    let impl_block = def.impl_block(db);\n+    let resolver = def.resolver(db);\n     let generics = def.generic_params(db);\n+    let name = def.name(db);\n     let input = signature\n         .params()\n         .iter()\n-        .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), &generics, tr))\n+        .map(|tr| Ty::from_hir(db, &resolver, tr))\n         .collect::<Vec<_>>();\n-    let output = Ty::from_hir(\n-        db,\n-        &module,\n-        impl_block.as_ref(),\n-        &generics,\n-        signature.ret_type(),\n-    );\n+    let output = Ty::from_hir(db, &resolver, signature.ret_type());\n     let sig = Arc::new(FnSig { input, output });\n     let substs = make_substs(&generics);\n-    let name = def.name(db);\n     Ty::FnDef {\n         def,\n         sig,\n@@ -764,13 +734,13 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def: TypableDef) -> Ty {\n \n pub(super) fn type_for_field(db: &impl HirDatabase, field: StructField) -> Ty {\n     let parent_def = field.parent_def(db);\n-    let (generics, module) = match parent_def {\n-        VariantDef::Struct(it) => (it.generic_params(db), it.module(db)),\n-        VariantDef::EnumVariant(it) => (it.parent_enum(db).generic_params(db), it.module(db)),\n+    let resolver = match parent_def {\n+        VariantDef::Struct(it) => it.resolver(db),\n+        VariantDef::EnumVariant(it) => it.parent_enum(db).resolver(db),\n     };\n     let var_data = parent_def.variant_data(db);\n     let type_ref = &var_data.fields().unwrap()[field.id].type_ref;\n-    Ty::from_hir(db, &module, None, &generics, type_ref)\n+    Ty::from_hir(db, &resolver, type_ref)\n }\n \n /// The result of type inference: A mapping from expressions and patterns to types.\n@@ -814,9 +784,7 @@ impl Index<PatId> for InferenceResult {\n struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n     body: Arc<Body>,\n-    scopes: Arc<ExprScopes>,\n-    module: Module,\n-    impl_block: Option<ImplBlock>,\n+    resolver: Resolver,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n     method_resolutions: FxHashMap<ExprId, Function>,\n     field_resolutions: FxHashMap<ExprId, StructField>,\n@@ -905,13 +873,7 @@ fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n-    fn new(\n-        db: &'a D,\n-        body: Arc<Body>,\n-        scopes: Arc<ExprScopes>,\n-        module: Module,\n-        impl_block: Option<ImplBlock>,\n-    ) -> Self {\n+    fn new(db: &'a D, body: Arc<Body>, resolver: Resolver) -> Self {\n         InferenceContext {\n             method_resolutions: FxHashMap::default(),\n             field_resolutions: FxHashMap::default(),\n@@ -921,9 +883,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n             body,\n-            scopes,\n-            module,\n-            impl_block,\n+            resolver,\n         }\n     }\n \n@@ -940,8 +900,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             *ty = resolved;\n         }\n         InferenceResult {\n-            method_resolutions: mem::replace(&mut self.method_resolutions, Default::default()),\n-            field_resolutions: mem::replace(&mut self.field_resolutions, Default::default()),\n+            method_resolutions: self.method_resolutions,\n+            field_resolutions: self.field_resolutions,\n             type_of_expr: expr_types,\n             type_of_pat: pat_types,\n         }\n@@ -964,13 +924,10 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     }\n \n     fn make_ty(&mut self, type_ref: &TypeRef) -> Ty {\n-        // TODO provide generics of function\n-        let generics = GenericParams::default();\n         let ty = Ty::from_hir(\n             self.db,\n-            &self.module,\n-            self.impl_block.as_ref(),\n-            &generics,\n+            // TODO use right resolver for block\n+            &self.resolver,\n             type_ref,\n         );\n         let ty = self.insert_type_vars(ty);\n@@ -1147,65 +1104,62 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_path_expr(&mut self, expr: ExprId, path: &Path) -> Option<Ty> {\n-        if path.is_ident() || path.is_self() {\n-            // resolve locally\n-            let name = path.as_ident().cloned().unwrap_or_else(Name::self_param);\n-            if let Some(scope_entry) = self.scopes.resolve_local_name(expr, name) {\n-                let ty = self.type_of_pat.get(scope_entry.pat())?;\n+    fn infer_path_expr(&mut self, resolver: &Resolver, path: &Path) -> Option<Ty> {\n+        let resolved = resolver.resolve_path(self.db, &path).take_values()?;\n+        match resolved {\n+            Resolution::Def(def) => {\n+                let typable: Option<TypableDef> = def.into();\n+                let typable = typable?;\n+                let substs = Ty::substs_from_path(self.db, &self.resolver, path, typable);\n+                let ty = self.db.type_for_def(typable).apply_substs(substs);\n+                let ty = self.insert_type_vars(ty);\n+                Some(ty)\n+            }\n+            Resolution::LocalBinding(pat) => {\n+                let ty = self.type_of_pat.get(pat)?;\n                 let ty = self.resolve_ty_as_possible(&mut vec![], ty.clone());\n-                return Some(ty);\n-            };\n-        };\n-\n-        // resolve in module\n-        let typable: Option<TypableDef> = self\n-            .module\n-            .resolve_path(self.db, &path)\n-            .take_values()?\n-            .into();\n-        let typable = typable?;\n-        let ty = self.db.type_for_def(typable);\n-        let generics = GenericParams::default();\n-        let substs = Ty::substs_from_path(\n-            self.db,\n-            &self.module,\n-            self.impl_block.as_ref(),\n-            &generics,\n-            path,\n-            typable,\n-        );\n-        let ty = ty.apply_substs(substs);\n-        let ty = self.insert_type_vars(ty);\n-\n-        Some(ty)\n+                Some(ty)\n+            }\n+            Resolution::GenericParam(..) => {\n+                // generic params can't refer to values... yet\n+                None\n+            }\n+            Resolution::SelfType(_) => {\n+                log::error!(\"path expr {:?} resolved to Self type in values ns\", path);\n+                None\n+            }\n+        }\n     }\n \n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantDef>) {\n         let path = match path {\n             Some(path) => path,\n             None => return (Ty::Unknown, None),\n         };\n-        let typable: Option<TypableDef> = self\n-            .module\n-            .resolve_path(self.db, &path)\n-            .take_types()\n-            .and_then(|it| it.into());\n+        let resolver = &self.resolver;\n+        let typable: Option<TypableDef> = match resolver.resolve_path(self.db, &path).take_types() {\n+            Some(Resolution::Def(def)) => def.into(),\n+            Some(Resolution::LocalBinding(..)) => {\n+                // this cannot happen\n+                log::error!(\"path resolved to local binding in type ns\");\n+                return (Ty::Unknown, None);\n+            }\n+            Some(Resolution::GenericParam(..)) => {\n+                // generic params can't be used in struct literals\n+                return (Ty::Unknown, None);\n+            }\n+            Some(Resolution::SelfType(..)) => {\n+                // TODO this is allowed in an impl for a struct, handle this\n+                return (Ty::Unknown, None);\n+            }\n+            None => return (Ty::Unknown, None),\n+        };\n         let def = match typable {\n             None => return (Ty::Unknown, None),\n             Some(it) => it,\n         };\n         // TODO remove the duplication between here and `Ty::from_path`?\n-        // TODO provide generics of function\n-        let generics = GenericParams::default();\n-        let substs = Ty::substs_from_path(\n-            self.db,\n-            &self.module,\n-            self.impl_block.as_ref(),\n-            &generics,\n-            path,\n-            def,\n-        );\n+        let substs = Ty::substs_from_path(self.db, resolver, path, def);\n         match def {\n             TypableDef::Struct(s) => {\n                 let ty = type_for_struct(self.db, s);\n@@ -1303,12 +1257,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 path: ref p,\n                 args: ref fields,\n             } => self.infer_struct_pat(p.as_ref(), fields, expected),\n-            Pat::Path(path) => self\n-                .module\n-                .resolve_path(self.db, &path)\n-                .take_values()\n-                .and_then(|module_def| module_def.into())\n-                .map_or(Ty::Unknown, |resolved| self.db.type_for_def(resolved)),\n+            Pat::Path(path) => {\n+                // TODO use correct resolver for the surrounding expression\n+                let resolver = self.resolver.clone();\n+                self.infer_path_expr(&resolver, &path)\n+                    .unwrap_or(Ty::Unknown)\n+            }\n             Pat::Bind {\n                 mode,\n                 name: _name,\n@@ -1496,7 +1450,11 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 expected.ty\n             }\n-            Expr::Path(p) => self.infer_path_expr(tgt_expr, p).unwrap_or(Ty::Unknown),\n+            Expr::Path(p) => {\n+                // TODO this could be more efficient...\n+                let resolver = expr::resolver_for_expr(self.body.clone(), self.db, tgt_expr);\n+                self.infer_path_expr(&resolver, p).unwrap_or(Ty::Unknown)\n+            }\n             Expr::Continue => Ty::Never,\n             Expr::Break { expr } => {\n                 if let Some(expr) = expr {\n@@ -1730,10 +1688,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n pub fn infer(db: &impl HirDatabase, func: Function) -> Arc<InferenceResult> {\n     db.check_canceled();\n     let body = func.body(db);\n-    let scopes = db.expr_scopes(func);\n-    let module = func.module(db);\n-    let impl_block = func.impl_block(db);\n-    let mut ctx = InferenceContext::new(db, body, scopes, module, impl_block);\n+    let resolver = func.resolver(db);\n+    let mut ctx = InferenceContext::new(db, body, resolver);\n \n     let signature = func.signature(db);\n     ctx.collect_fn_signature(&signature);"}, {"sha": "2282286b0b83f69f3e14baab4719b72615eacffc", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -7,12 +7,10 @@ use std::sync::Arc;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    HirDatabase, module_tree::ModuleId, Module, ModuleDef, Crate, Name, Function, Trait,\n+    HirDatabase, module_tree::ModuleId, Module, Crate, Name, Function, Trait,\n     ids::TraitId,\n     impl_block::{ImplId, ImplBlock, ImplItem},\n-    generics::GenericParams,\n     ty::{AdtDef, Ty},\n-    type_ref::TypeRef,\n };\n \n /// This is used as a key for indexing impls.\n@@ -85,17 +83,10 @@ impl CrateImplBlocks {\n     fn collect_recursive(&mut self, db: &impl HirDatabase, module: &Module) {\n         let module_impl_blocks = db.impls_in_module(module.clone());\n \n-        for (impl_id, impl_data) in module_impl_blocks.impls.iter() {\n+        for (impl_id, _) in module_impl_blocks.impls.iter() {\n             let impl_block = ImplBlock::from_id(Arc::clone(&module_impl_blocks), impl_id);\n-            // TODO provide generics of impl\n-            let generics = GenericParams::default();\n-            let target_ty = Ty::from_hir(\n-                db,\n-                &module,\n-                Some(&impl_block),\n-                &generics,\n-                impl_data.target_type(),\n-            );\n+\n+            let target_ty = impl_block.target_ty(db);\n \n             if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n                 self.impls\n@@ -104,14 +95,11 @@ impl CrateImplBlocks {\n                     .push((module.module_id, impl_id));\n             }\n \n-            if let Some(TypeRef::Path(path)) = impl_data.target_trait() {\n-                let perns = module.resolve_path(db, path);\n-                if let Some(ModuleDef::Trait(tr)) = perns.take_types() {\n-                    self.impls_by_trait\n-                        .entry(tr.id)\n-                        .or_insert_with(Vec::new)\n-                        .push((module.module_id, impl_id));\n-                }\n+            if let Some(tr) = impl_block.target_trait(db) {\n+                self.impls_by_trait\n+                    .entry(tr.id)\n+                    .or_insert_with(Vec::new)\n+                    .push((module.module_id, impl_id));\n             }\n         }\n "}, {"sha": "91c48897cf7b26fd29415a97803249806611f17e", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_function_generics.snap", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_function_generics.snap?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -1,12 +1,12 @@\n ---\n-created: \"2019-01-26T18:16:16.530712344+00:00\"\n+created: \"2019-01-27T14:52:29.934503829+00:00\"\n creator: insta@0.5.2\n expression: \"&result\"\n source: crates/ra_hir/src/ty/tests.rs\n ---\n-[10; 11) 't': [unknown]\n-[21; 26) '{ t }': [unknown]\n-[23; 24) 't': [unknown]\n+[10; 11) 't': T\n+[21; 26) '{ t }': T\n+[23; 24) 't': T\n [38; 98) '{     ...(1); }': ()\n [44; 46) 'id': fn id<u32>(T) -> T\n [44; 52) 'id(1u32)': u32"}, {"sha": "626f31252556acd495bb6f7ae5127437b1a48304", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_generic_chain.snap", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_generic_chain.snap?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -1,5 +1,5 @@\n ---\n-created: \"2019-01-26T17:46:03.866825843+00:00\"\n+created: \"2019-01-27T14:52:29.938713255+00:00\"\n creator: insta@0.5.2\n expression: \"&result\"\n source: crates/ra_hir/src/ty/tests.rs\n@@ -8,9 +8,9 @@ source: crates/ra_hir/src/ty/tests.rs\n [65; 87) '{     ...     }': [unknown]\n [75; 79) 'self': A<[unknown]>\n [75; 81) 'self.x': [unknown]\n-[99; 100) 't': [unknown]\n-[110; 115) '{ t }': [unknown]\n-[112; 113) 't': [unknown]\n+[99; 100) 't': T\n+[110; 115) '{ t }': T\n+[112; 113) 't': T\n [135; 261) '{     ....x() }': i128\n [146; 147) 'x': i32\n [150; 151) '1': i32"}, {"sha": "216d1e41f103a1d01bfc29b1a7ae3ed8cf592b97", "filename": "crates/ra_hir/src/ty/snapshots/tests__infer_type_param.snap", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_type_param.snap", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_type_param.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fsnapshots%2Ftests__infer_type_param.snap?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -1,15 +1,15 @@\n ---\n-created: \"2019-01-27T16:54:18.368427685+00:00\"\n+created: \"2019-01-27T20:38:32.153717698+00:00\"\n creator: insta@0.5.2\n expression: \"&result\"\n source: crates/ra_hir/src/ty/tests.rs\n ---\n-[10; 11) 'x': [unknown]\n-[21; 30) '{     x }': [unknown]\n-[27; 28) 'x': [unknown]\n-[44; 45) 'x': &[unknown]\n-[56; 65) '{     x }': &[unknown]\n-[62; 63) 'x': &[unknown]\n+[10; 11) 'x': T\n+[21; 30) '{     x }': T\n+[27; 28) 'x': T\n+[44; 45) 'x': &T\n+[56; 65) '{     x }': &T\n+[62; 63) 'x': &T\n [77; 157) '{     ...(1); }': ()\n [87; 88) 'y': u32\n [91; 96) '10u32': u32"}, {"sha": "0b9948d4b423818c2baa6ee8223e539893aaf3e0", "filename": "crates/ra_ide_api/src/completion/complete_path.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -1,21 +1,21 @@\n use join_to_string::join;\n \n+use hir::{Docs, Resolution};\n+\n use crate::{\n     completion::{CompletionItem, CompletionItemKind, Completions, CompletionKind, CompletionContext},\n };\n \n-use hir::Docs;\n-\n pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n-    let (path, module) = match (&ctx.path_prefix, &ctx.module) {\n-        (Some(path), Some(module)) => (path.clone(), module),\n+    let path = match &ctx.path_prefix {\n+        Some(path) => path.clone(),\n         _ => return,\n     };\n-    let def_id = match module.resolve_path(ctx.db, &path).take_types() {\n-        Some(it) => it,\n-        None => return,\n+    let def = match ctx.resolver.resolve_path(ctx.db, &path).take_types() {\n+        Some(Resolution::Def(def)) => def,\n+        _ => return,\n     };\n-    match def_id {\n+    match def {\n         hir::ModuleDef::Module(module) => {\n             let module_scope = module.scope(ctx.db);\n             for (name, res) in module_scope.entries() {\n@@ -24,7 +24,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) {\n                     ctx.source_range(),\n                     name.to_string(),\n                 )\n-                .from_resolution(ctx, res)\n+                .from_resolution(ctx, &res.def.map(hir::Resolution::Def))\n                 .add_to(acc);\n             }\n         }\n@@ -65,6 +65,17 @@ mod tests {\n         check_completion(code, expected_completions, CompletionKind::Reference);\n     }\n \n+    #[test]\n+    #[ignore] // should not complete foo, which currently doesn't work\n+    fn dont_complete_current_use() {\n+        check_reference_completion(\n+            \"dont_complete_current_use\",\n+            r\"\n+            use self::foo<|>;\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn completes_mod_with_docs() {\n         check_reference_completion("}, {"sha": "44514ab2b2f73e76f0b45bb7380215b2a94bd888", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 35, "deletions": 55, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -1,63 +1,20 @@\n-use rustc_hash::FxHashSet;\n-use ra_syntax::ast::AstNode;\n-use crate::completion::{CompletionItem, CompletionItemKind, Completions, CompletionKind, CompletionContext};\n+use crate::completion::{CompletionItem, Completions, CompletionKind, CompletionContext};\n \n pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_trivial_path {\n         return;\n     }\n-    let module = match &ctx.module {\n-        Some(it) => it,\n-        None => return,\n-    };\n-    if let Some(function) = &ctx.function {\n-        let scopes = function.scopes(ctx.db);\n-        complete_fn(acc, &scopes, ctx);\n-    }\n-\n-    let module_scope = module.scope(ctx.db);\n-    module_scope\n-        .entries()\n-        .filter(|(_name, res)| {\n-            // For cases like `use self::foo<|>` don't suggest foo itself.\n-            match res.import {\n-                None => true,\n-                Some(import) => {\n-                    let source = module.import_source(ctx.db, import);\n-                    !source.syntax().range().is_subrange(&ctx.leaf.range())\n-                }\n-            }\n-        })\n-        .for_each(|(name, res)| {\n-            CompletionItem::new(\n-                CompletionKind::Reference,\n-                ctx.source_range(),\n-                name.to_string(),\n-            )\n-            .from_resolution(ctx, res)\n-            .add_to(acc)\n-        });\n-}\n+    let names = ctx.resolver.all_names();\n \n-fn complete_fn(\n-    acc: &mut Completions,\n-    scopes: &hir::ScopesWithSyntaxMapping,\n-    ctx: &CompletionContext,\n-) {\n-    let mut shadowed = FxHashSet::default();\n-    scopes\n-        .scope_chain_for_offset(ctx.offset)\n-        .flat_map(|scope| scopes.scopes.entries(scope).iter())\n-        .filter(|entry| shadowed.insert(entry.name()))\n-        .for_each(|entry| {\n-            CompletionItem::new(\n-                CompletionKind::Reference,\n-                ctx.source_range(),\n-                entry.name().to_string(),\n-            )\n-            .kind(CompletionItemKind::Binding)\n-            .add_to(acc)\n-        });\n+    names.into_iter().for_each(|(name, res)| {\n+        CompletionItem::new(\n+            CompletionKind::Reference,\n+            ctx.source_range(),\n+            name.to_string(),\n+        )\n+        .from_resolution(ctx, &res)\n+        .add_to(acc)\n+    });\n }\n \n #[cfg(test)]\n@@ -115,6 +72,30 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn completes_generic_params() {\n+        check_reference_completion(\n+            \"generic_params\",\n+            r\"\n+            fn quux<T>() {\n+                <|>\n+            }\n+            \",\n+        );\n+    }\n+\n+    #[test]\n+    fn completes_generic_params_in_struct() {\n+        check_reference_completion(\n+            \"generic_params_in_struct\",\n+            r\"\n+            struct X<T> {\n+                x: <|>\n+            }\n+            \",\n+        );\n+    }\n+\n     #[test]\n     fn completes_module_items() {\n         check_reference_completion(\n@@ -174,5 +155,4 @@ mod tests {\n     fn completes_self_in_methods() {\n         check_reference_completion(\"self_in_methods\", r\"impl S { fn foo(&self) { <|> } }\")\n     }\n-\n }"}, {"sha": "5d1851da649752328fc23c5c8bff36d07bcde3dd", "filename": "crates/ra_ide_api/src/completion/completion_context.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     algo::{find_leaf_at_offset, find_covering_node, find_node_at_offset},\n     SyntaxKind::*,\n };\n-use hir::source_binder;\n+use hir::{source_binder, Resolver};\n \n use crate::{db, FilePosition};\n \n@@ -16,6 +16,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) db: &'a db::RootDatabase,\n     pub(super) offset: TextUnit,\n     pub(super) leaf: &'a SyntaxNode,\n+    pub(super) resolver: Resolver,\n     pub(super) module: Option<hir::Module>,\n     pub(super) function: Option<hir::Function>,\n     pub(super) function_syntax: Option<&'a ast::FnDef>,\n@@ -42,12 +43,14 @@ impl<'a> CompletionContext<'a> {\n         original_file: &'a SourceFile,\n         position: FilePosition,\n     ) -> Option<CompletionContext<'a>> {\n+        let resolver = source_binder::resolver_for_position(db, position);\n         let module = source_binder::module_from_position(db, position);\n         let leaf = find_leaf_at_offset(original_file.syntax(), position.offset).left_biased()?;\n         let mut ctx = CompletionContext {\n             db,\n             leaf,\n             offset: position.offset,\n+            resolver,\n             module,\n             function: None,\n             function_syntax: None,"}, {"sha": "bada6a33bf25cda892449f948371b08f2dd66626", "filename": "crates/ra_ide_api/src/completion/completion_item.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -1,5 +1,7 @@\n-use hir::{Docs, Documentation};\n-use ra_syntax::TextRange;\n+use hir::{Docs, Documentation, PerNs, Resolution};\n+use ra_syntax::{\n+    TextRange,\n+};\n use ra_text_edit::TextEdit;\n use test_utils::tested_by;\n \n@@ -48,6 +50,7 @@ pub enum CompletionItemKind {\n     Trait,\n     TypeAlias,\n     Method,\n+    TypeParam,\n }\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n@@ -207,23 +210,34 @@ impl Builder {\n     pub(super) fn from_resolution(\n         mut self,\n         ctx: &CompletionContext,\n-        resolution: &hir::Resolution,\n+        resolution: &PerNs<Resolution>,\n     ) -> Builder {\n-        let def = resolution.def.take_types().or(resolution.def.take_values());\n+        use hir::ModuleDef::*;\n+\n+        let def = resolution\n+            .as_ref()\n+            .take_types()\n+            .or(resolution.as_ref().take_values());\n         let def = match def {\n             None => return self,\n             Some(it) => it,\n         };\n         let (kind, docs) = match def {\n-            hir::ModuleDef::Module(it) => (CompletionItemKind::Module, it.docs(ctx.db)),\n-            hir::ModuleDef::Function(func) => return self.from_function(ctx, func),\n-            hir::ModuleDef::Struct(it) => (CompletionItemKind::Struct, it.docs(ctx.db)),\n-            hir::ModuleDef::Enum(it) => (CompletionItemKind::Enum, it.docs(ctx.db)),\n-            hir::ModuleDef::EnumVariant(it) => (CompletionItemKind::EnumVariant, it.docs(ctx.db)),\n-            hir::ModuleDef::Const(it) => (CompletionItemKind::Const, it.docs(ctx.db)),\n-            hir::ModuleDef::Static(it) => (CompletionItemKind::Static, it.docs(ctx.db)),\n-            hir::ModuleDef::Trait(it) => (CompletionItemKind::Trait, it.docs(ctx.db)),\n-            hir::ModuleDef::Type(it) => (CompletionItemKind::TypeAlias, it.docs(ctx.db)),\n+            Resolution::Def(Module(it)) => (CompletionItemKind::Module, it.docs(ctx.db)),\n+            Resolution::Def(Function(func)) => return self.from_function(ctx, *func),\n+            Resolution::Def(Struct(it)) => (CompletionItemKind::Struct, it.docs(ctx.db)),\n+            Resolution::Def(Enum(it)) => (CompletionItemKind::Enum, it.docs(ctx.db)),\n+            Resolution::Def(EnumVariant(it)) => (CompletionItemKind::EnumVariant, it.docs(ctx.db)),\n+            Resolution::Def(Const(it)) => (CompletionItemKind::Const, it.docs(ctx.db)),\n+            Resolution::Def(Static(it)) => (CompletionItemKind::Static, it.docs(ctx.db)),\n+            Resolution::Def(Trait(it)) => (CompletionItemKind::Trait, it.docs(ctx.db)),\n+            Resolution::Def(Type(it)) => (CompletionItemKind::TypeAlias, it.docs(ctx.db)),\n+            Resolution::GenericParam(..) => (CompletionItemKind::TypeParam, None),\n+            Resolution::LocalBinding(..) => (CompletionItemKind::Binding, None),\n+            Resolution::SelfType(..) => (\n+                CompletionItemKind::TypeParam, // (does this need its own kind?)\n+                None,\n+            ),\n         };\n         self.kind = Some(kind);\n         self.documentation = docs;"}, {"sha": "71cb55a5bc846e2359d36cfa34460a1762e5ff5b", "filename": "crates/ra_ide_api/src/completion/snapshots/completion_item__generic_params.snap", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__generic_params.snap", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__generic_params.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__generic_params.snap?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -0,0 +1,40 @@\n+---\n+created: \"2019-02-01T22:20:40.580128393+00:00\"\n+creator: insta@0.5.3\n+expression: kind_completions\n+source: crates/ra_ide_api/src/completion/completion_item.rs\n+---\n+[\n+    CompletionItem {\n+        completion_kind: Reference,\n+        label: \"T\",\n+        kind: Some(\n+            TypeParam\n+        ),\n+        detail: None,\n+        documentation: None,\n+        lookup: None,\n+        insert_text: None,\n+        insert_text_format: PlainText,\n+        source_range: [44; 44),\n+        text_edit: None\n+    },\n+    CompletionItem {\n+        completion_kind: Reference,\n+        label: \"quux\",\n+        kind: Some(\n+            Function\n+        ),\n+        detail: Some(\n+            \"fn quux<T>()\"\n+        ),\n+        documentation: None,\n+        lookup: None,\n+        insert_text: Some(\n+            \"quux()$0\"\n+        ),\n+        insert_text_format: Snippet,\n+        source_range: [44; 44),\n+        text_edit: None\n+    }\n+]"}, {"sha": "a35c0cd13a78ae2d72f68837a5833f374ee968cf", "filename": "crates/ra_ide_api/src/completion/snapshots/completion_item__generic_params_in_struct.snap", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__generic_params_in_struct.snap", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__generic_params_in_struct.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__generic_params_in_struct.snap?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -0,0 +1,36 @@\n+---\n+created: \"2019-02-01T22:23:21.508620224+00:00\"\n+creator: insta@0.5.3\n+expression: kind_completions\n+source: crates/ra_ide_api/src/completion/completion_item.rs\n+---\n+[\n+    CompletionItem {\n+        completion_kind: Reference,\n+        label: \"T\",\n+        kind: Some(\n+            TypeParam\n+        ),\n+        detail: None,\n+        documentation: None,\n+        lookup: None,\n+        insert_text: None,\n+        insert_text_format: PlainText,\n+        source_range: [46; 46),\n+        text_edit: None\n+    },\n+    CompletionItem {\n+        completion_kind: Reference,\n+        label: \"X\",\n+        kind: Some(\n+            Struct\n+        ),\n+        detail: None,\n+        documentation: None,\n+        lookup: None,\n+        insert_text: None,\n+        insert_text_format: PlainText,\n+        source_range: [46; 46),\n+        text_edit: None\n+    }\n+]"}, {"sha": "ba1d4abbd5b2a10ae1f493eb657250a1ebd5fa5c", "filename": "crates/ra_ide_api/src/completion/snapshots/completion_item__self_in_methods.snap", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__self_in_methods.snap", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__self_in_methods.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__self_in_methods.snap?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -1,10 +1,24 @@\n ---\n-created: \"2019-01-23T05:27:32.422259+00:00\"\n-creator: insta@0.4.0\n+created: \"2019-01-27T20:17:10.051725945+00:00\"\n+creator: insta@0.5.2\n expression: kind_completions\n source: crates/ra_ide_api/src/completion/completion_item.rs\n ---\n [\n+    CompletionItem {\n+        completion_kind: Reference,\n+        label: \"Self\",\n+        kind: Some(\n+            TypeParam\n+        ),\n+        detail: None,\n+        documentation: None,\n+        lookup: None,\n+        insert_text: None,\n+        insert_text_format: PlainText,\n+        source_range: [25; 25),\n+        text_edit: None\n+    },\n     CompletionItem {\n         completion_kind: Reference,\n         label: \"self\","}, {"sha": "88efcea2a57368808f4c36ad8b3729495dd1dbd8", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -4,6 +4,7 @@ use ra_syntax::{\n     algo::find_node_at_offset,\n };\n use test_utils::tested_by;\n+use hir::Resolution;\n \n use crate::{FilePosition, NavigationTarget, db::RootDatabase, RangeInfo};\n \n@@ -48,14 +49,7 @@ pub(crate) fn reference_definition(\n     if let Some(function) =\n         hir::source_binder::function_from_child_node(db, file_id, name_ref.syntax())\n     {\n-        let scope = function.scopes(db);\n-        // First try to resolve the symbol locally\n-        if let Some(entry) = scope.resolve_local_name(name_ref) {\n-            let nav = NavigationTarget::from_scope_entry(file_id, &entry);\n-            return Exact(nav);\n-        };\n-\n-        // Next check if it is a method\n+        // Check if it is a method\n         if let Some(method_call) = name_ref\n             .syntax()\n             .parent()\n@@ -86,19 +80,37 @@ pub(crate) fn reference_definition(\n             };\n         }\n     }\n-    // Then try module name resolution\n-    if let Some(module) = hir::source_binder::module_from_child_node(db, file_id, name_ref.syntax())\n+    // Try name resolution\n+    let resolver = hir::source_binder::resolver_for_node(db, file_id, name_ref.syntax());\n+    if let Some(path) = name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::Path::cast)\n+        .and_then(hir::Path::from_ast)\n     {\n-        if let Some(path) = name_ref\n-            .syntax()\n-            .ancestors()\n-            .find_map(ast::Path::cast)\n-            .and_then(hir::Path::from_ast)\n-        {\n-            let resolved = module.resolve_path(db, &path);\n-            if let Some(def_id) = resolved.take_types().or(resolved.take_values()) {\n-                return Exact(NavigationTarget::from_def(db, def_id));\n+        let resolved = resolver.resolve_path(db, &path);\n+        match resolved.clone().take_types().or(resolved.take_values()) {\n+            Some(Resolution::Def(def)) => return Exact(NavigationTarget::from_def(db, def)),\n+            Some(Resolution::LocalBinding(pat)) => {\n+                let body = resolver.body().expect(\"no body for local binding\");\n+                let syntax_mapping = body.syntax_mapping(db);\n+                let ptr = syntax_mapping\n+                    .pat_syntax(pat)\n+                    .expect(\"pattern not found in syntax mapping\");\n+                let name = path\n+                    .as_ident()\n+                    .cloned()\n+                    .expect(\"local binding from a multi-segment path\");\n+                let nav = NavigationTarget::from_scope_entry(file_id, name, ptr);\n+                return Exact(nav);\n+            }\n+            Some(Resolution::GenericParam(..)) => {\n+                // TODO go to the generic param def\n+            }\n+            Some(Resolution::SelfType(_impl_block)) => {\n+                // TODO go to the implemented type\n             }\n+            None => {}\n         }\n     }\n     // If that fails try the index based approach."}, {"sha": "617908aedfef9a763410e2c0c1b759ed2380c87b", "filename": "crates/ra_ide_api/src/navigation_target.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fnavigation_target.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -1,9 +1,9 @@\n use ra_db::FileId;\n use ra_syntax::{\n-    SyntaxNode, AstNode, SmolStr, TextRange, ast,\n+    SyntaxNode, SyntaxNodePtr, AstNode, SmolStr, TextRange, ast,\n     SyntaxKind::{self, NAME},\n };\n-use hir::{ModuleSource, FieldSource};\n+use hir::{ModuleSource, FieldSource, Name};\n \n use crate::{FileSymbol, db::RootDatabase};\n \n@@ -58,12 +58,13 @@ impl NavigationTarget {\n \n     pub(crate) fn from_scope_entry(\n         file_id: FileId,\n-        entry: &hir::ScopeEntryWithSyntax,\n+        name: Name,\n+        ptr: SyntaxNodePtr,\n     ) -> NavigationTarget {\n         NavigationTarget {\n             file_id,\n-            name: entry.name().to_string().into(),\n-            full_range: entry.ptr().range(),\n+            name: name.to_string().into(),\n+            full_range: ptr.range(),\n             focus_range: None,\n             kind: NAME,\n         }"}, {"sha": "17fa073406b286d1e324cc50d6139112f3f0f432", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4447019f4b5f24728bb7b91b161755ddb373c74c/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=4447019f4b5f24728bb7b91b161755ddb373c74c", "patch": "@@ -70,6 +70,7 @@ impl Conv for CompletionItemKind {\n             CompletionItemKind::Const => Constant,\n             CompletionItemKind::Static => Value,\n             CompletionItemKind::Method => Method,\n+            CompletionItemKind::TypeParam => TypeParameter,\n         }\n     }\n }"}]}