{"sha": "de287df86245bdeed485373d1a3b29ec028d33f5", "node_id": "C_kwDOAAsO6NoAKGRlMjg3ZGY4NjI0NWJkZWVkNDg1MzczZDFhM2IyOWVjMDI4ZDMzZjU", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-16T20:59:21Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-04-19T19:53:50Z"}, "message": "rustdoc: Cache preprocessed markdown links", "tree": {"sha": "131e7af87d4df3ba654c510148d69e085dd11869", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/131e7af87d4df3ba654c510148d69e085dd11869"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de287df86245bdeed485373d1a3b29ec028d33f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de287df86245bdeed485373d1a3b29ec028d33f5", "html_url": "https://github.com/rust-lang/rust/commit/de287df86245bdeed485373d1a3b29ec028d33f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de287df86245bdeed485373d1a3b29ec028d33f5/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72ed1014281cbb90e7a1d60f7508a5201cb0ae5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f", "html_url": "https://github.com/rust-lang/rust/commit/72ed1014281cbb90e7a1d60f7508a5201cb0ae5f"}], "stats": {"total": 113, "additions": 68, "deletions": 45}, "files": [{"sha": "1db6064551cae362fc30911ba5528b00e052b1c7", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de287df86245bdeed485373d1a3b29ec028d33f5/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de287df86245bdeed485373d1a3b29ec028d33f5/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=de287df86245bdeed485373d1a3b29ec028d33f5", "patch": "@@ -29,13 +29,13 @@ use crate::clean::inline::build_external_trait;\n use crate::clean::{self, ItemId, TraitWithExtraInfo};\n use crate::config::{Options as RustdocOptions, OutputFormat, RenderOptions};\n use crate::formats::cache::Cache;\n-use crate::html::markdown::MarkdownLink;\n+use crate::passes::collect_intra_doc_links::PreprocessedMarkdownLink;\n use crate::passes::{self, Condition::*};\n \n crate use rustc_session::config::{DebuggingOptions, Input, Options};\n \n crate struct ResolverCaches {\n-    crate markdown_links: Option<FxHashMap<String, Vec<MarkdownLink>>>,\n+    crate markdown_links: Option<FxHashMap<String, Vec<PreprocessedMarkdownLink>>>,\n     crate doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<NodeId>>>,\n     /// Traits in scope for a given module.\n     /// See `collect_intra_doc_links::traits_implemented_by` for more details."}, {"sha": "eafe6f17d44bf6788239e6d7a59f28a3899981eb", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/de287df86245bdeed485373d1a3b29ec028d33f5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de287df86245bdeed485373d1a3b29ec028d33f5/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=de287df86245bdeed485373d1a3b29ec028d33f5", "patch": "@@ -1255,7 +1255,7 @@ crate struct MarkdownLink {\n     pub range: Range<usize>,\n }\n \n-crate fn markdown_links(md: &str) -> Vec<MarkdownLink> {\n+crate fn markdown_links<R>(md: &str, filter_map: impl Fn(MarkdownLink) -> Option<R>) -> Vec<R> {\n     if md.is_empty() {\n         return vec![];\n     }\n@@ -1295,11 +1295,12 @@ crate fn markdown_links(md: &str) -> Vec<MarkdownLink> {\n \n     let mut push = |link: BrokenLink<'_>| {\n         let span = span_for_link(&link.reference, link.span);\n-        links.borrow_mut().push(MarkdownLink {\n+        filter_map(MarkdownLink {\n             kind: LinkType::ShortcutUnknown,\n             link: link.reference.to_string(),\n             range: span,\n-        });\n+        })\n+        .map(|link| links.borrow_mut().push(link));\n         None\n     };\n     let p = Parser::new_with_broken_link_callback(md, main_body_opts(), Some(&mut push))\n@@ -1314,7 +1315,8 @@ crate fn markdown_links(md: &str) -> Vec<MarkdownLink> {\n         if let Event::Start(Tag::Link(kind, dest, _)) = ev.0 {\n             debug!(\"found link: {dest}\");\n             let span = span_for_link(&dest, ev.1);\n-            links.borrow_mut().push(MarkdownLink { kind, link: dest.into_string(), range: span });\n+            filter_map(MarkdownLink { kind, link: dest.into_string(), range: span })\n+                .map(|link| links.borrow_mut().push(link));\n         }\n     }\n "}, {"sha": "c9fc14d5f71a4e1b7f6a3284deca6ce2022930ec", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 51, "deletions": 33, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/de287df86245bdeed485373d1a3b29ec028d33f5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de287df86245bdeed485373d1a3b29ec028d33f5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=de287df86245bdeed485373d1a3b29ec028d33f5", "patch": "@@ -160,7 +160,7 @@ impl TryFrom<ResolveRes> for Res {\n }\n \n /// A link failed to resolve.\n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n enum ResolutionFailure<'a> {\n     /// This resolved, but with the wrong namespace.\n     WrongNamespace {\n@@ -200,7 +200,7 @@ enum ResolutionFailure<'a> {\n     Dummy,\n }\n \n-#[derive(Debug)]\n+#[derive(Clone, Debug)]\n enum MalformedGenerics {\n     /// This link has unbalanced angle brackets.\n     ///\n@@ -253,6 +253,7 @@ impl ResolutionFailure<'_> {\n     }\n }\n \n+#[derive(Clone, Copy)]\n enum AnchorFailure {\n     /// User error: `[std#x#y]` is not valid\n     MultipleAnchors,\n@@ -1064,7 +1065,7 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n                 .take()\n                 .expect(\"`markdown_links` are already borrowed\");\n             if !tmp_links.contains_key(&doc) {\n-                tmp_links.insert(doc.clone(), markdown_links(&doc));\n+                tmp_links.insert(doc.clone(), preprocessed_markdown_links(&doc));\n             }\n             for md_link in &tmp_links[&doc] {\n                 let link = self.resolve_link(&item, &doc, parent_node, md_link);\n@@ -1088,34 +1089,38 @@ impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     }\n }\n \n-enum PreprocessingError<'a> {\n+enum PreprocessingError {\n     Anchor(AnchorFailure),\n     Disambiguator(Range<usize>, String),\n-    Resolution(ResolutionFailure<'a>, String, Option<Disambiguator>),\n+    Resolution(ResolutionFailure<'static>, String, Option<Disambiguator>),\n }\n \n-impl From<AnchorFailure> for PreprocessingError<'_> {\n+impl From<AnchorFailure> for PreprocessingError {\n     fn from(err: AnchorFailure) -> Self {\n         Self::Anchor(err)\n     }\n }\n \n+#[derive(Clone)]\n struct PreprocessingInfo {\n     path_str: String,\n     disambiguator: Option<Disambiguator>,\n     extra_fragment: Option<String>,\n     link_text: String,\n }\n \n+// Not a typedef to avoid leaking several private structures from this module.\n+crate struct PreprocessedMarkdownLink(Result<PreprocessingInfo, PreprocessingError>, MarkdownLink);\n+\n /// Returns:\n /// - `None` if the link should be ignored.\n /// - `Some(Err)` if the link should emit an error\n /// - `Some(Ok)` if the link is valid\n ///\n /// `link_buffer` is needed for lifetime reasons; it will always be overwritten and the contents ignored.\n-fn preprocess_link<'a>(\n-    ori_link: &'a MarkdownLink,\n-) -> Option<Result<PreprocessingInfo, PreprocessingError<'a>>> {\n+fn preprocess_link(\n+    ori_link: &MarkdownLink,\n+) -> Option<Result<PreprocessingInfo, PreprocessingError>> {\n     // [] is mostly likely not supposed to be a link\n     if ori_link.link.is_empty() {\n         return None;\n@@ -1194,6 +1199,12 @@ fn preprocess_link<'a>(\n     }))\n }\n \n+fn preprocessed_markdown_links(s: &str) -> Vec<PreprocessedMarkdownLink> {\n+    markdown_links(s, |link| {\n+        preprocess_link(&link).map(|pp_link| PreprocessedMarkdownLink(pp_link, link))\n+    })\n+}\n+\n impl LinkCollector<'_, '_> {\n     /// This is the entry point for resolving an intra-doc link.\n     ///\n@@ -1203,8 +1214,9 @@ impl LinkCollector<'_, '_> {\n         item: &Item,\n         dox: &str,\n         parent_node: Option<DefId>,\n-        ori_link: &MarkdownLink,\n+        link: &PreprocessedMarkdownLink,\n     ) -> Option<ItemLink> {\n+        let PreprocessedMarkdownLink(pp_link, ori_link) = link;\n         trace!(\"considering link '{}'\", ori_link.link);\n \n         let diag_info = DiagnosticInfo {\n@@ -1214,28 +1226,29 @@ impl LinkCollector<'_, '_> {\n             link_range: ori_link.range.clone(),\n         };\n \n-        let PreprocessingInfo { ref path_str, disambiguator, extra_fragment, link_text } =\n-            match preprocess_link(&ori_link)? {\n-                Ok(x) => x,\n-                Err(err) => {\n-                    match err {\n-                        PreprocessingError::Anchor(err) => anchor_failure(self.cx, diag_info, err),\n-                        PreprocessingError::Disambiguator(range, msg) => {\n-                            disambiguator_error(self.cx, diag_info, range, &msg)\n-                        }\n-                        PreprocessingError::Resolution(err, path_str, disambiguator) => {\n-                            resolution_failure(\n-                                self,\n-                                diag_info,\n-                                &path_str,\n-                                disambiguator,\n-                                smallvec![err],\n-                            );\n-                        }\n+        let PreprocessingInfo { path_str, disambiguator, extra_fragment, link_text } = match pp_link\n+        {\n+            Ok(x) => x,\n+            Err(err) => {\n+                match err {\n+                    PreprocessingError::Anchor(err) => anchor_failure(self.cx, diag_info, *err),\n+                    PreprocessingError::Disambiguator(range, msg) => {\n+                        disambiguator_error(self.cx, diag_info, range.clone(), msg)\n+                    }\n+                    PreprocessingError::Resolution(err, path_str, disambiguator) => {\n+                        resolution_failure(\n+                            self,\n+                            diag_info,\n+                            path_str,\n+                            *disambiguator,\n+                            smallvec![err.clone()],\n+                        );\n                     }\n-                    return None;\n                 }\n-            };\n+                return None;\n+            }\n+        };\n+        let disambiguator = *disambiguator;\n \n         let inner_docs = item.inner_docs(self.cx.tcx);\n \n@@ -1272,7 +1285,7 @@ impl LinkCollector<'_, '_> {\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.to_owned(),\n-                extra_fragment,\n+                extra_fragment: extra_fragment.clone(),\n             },\n             diag_info.clone(), // this struct should really be Copy, but Range is not :(\n             matches!(ori_link.kind, LinkType::Reference | LinkType::Shortcut),\n@@ -1343,7 +1356,7 @@ impl LinkCollector<'_, '_> {\n \n                 Some(ItemLink {\n                     link: ori_link.link.clone(),\n-                    link_text,\n+                    link_text: link_text.clone(),\n                     did: res.def_id(self.cx.tcx),\n                     fragment,\n                 })\n@@ -1365,7 +1378,12 @@ impl LinkCollector<'_, '_> {\n                     &diag_info,\n                 )?;\n                 let id = clean::register_res(self.cx, rustc_hir::def::Res::Def(kind, id));\n-                Some(ItemLink { link: ori_link.link.clone(), link_text, did: id, fragment })\n+                Some(ItemLink {\n+                    link: ori_link.link.clone(),\n+                    link_text: link_text.clone(),\n+                    did: id,\n+                    fragment,\n+                })\n             }\n         }\n     }"}, {"sha": "a285c300b75c31012be2a3fd5ce5d34d56ddc197", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/de287df86245bdeed485373d1a3b29ec028d33f5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de287df86245bdeed485373d1a3b29ec028d33f5/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=de287df86245bdeed485373d1a3b29ec028d33f5", "patch": "@@ -1,7 +1,7 @@\n use crate::clean::Attributes;\n use crate::core::ResolverCaches;\n-use crate::html::markdown::{markdown_links, MarkdownLink};\n-use crate::passes::collect_intra_doc_links::preprocess_link;\n+use crate::passes::collect_intra_doc_links::preprocessed_markdown_links;\n+use crate::passes::collect_intra_doc_links::PreprocessedMarkdownLink;\n \n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_ast::{self as ast, ItemKind};\n@@ -72,7 +72,7 @@ struct EarlyDocLinkResolver<'r, 'ra> {\n     resolver: &'r mut Resolver<'ra>,\n     current_mod: LocalDefId,\n     visited_mods: DefIdSet,\n-    markdown_links: FxHashMap<String, Vec<MarkdownLink>>,\n+    markdown_links: FxHashMap<String, Vec<PreprocessedMarkdownLink>>,\n     doc_link_resolutions: FxHashMap<(Symbol, Namespace, DefId), Option<Res<ast::NodeId>>>,\n     traits_in_scope: DefIdMap<Vec<TraitCandidate>>,\n     all_traits: Vec<DefId>,\n@@ -203,9 +203,12 @@ impl EarlyDocLinkResolver<'_, '_> {\n         let mut need_traits_in_scope = false;\n         for (doc_module, doc) in attrs.collapsed_doc_value_by_module_level() {\n             assert_eq!(doc_module, None);\n-            for link in self.markdown_links.entry(doc).or_insert_with_key(|doc| markdown_links(doc))\n-            {\n-                if let Some(Ok(pinfo)) = preprocess_link(&link) {\n+            let links = self\n+                .markdown_links\n+                .entry(doc)\n+                .or_insert_with_key(|doc| preprocessed_markdown_links(doc));\n+            for PreprocessedMarkdownLink(pp_link, _) in links {\n+                if let Ok(pinfo) = pp_link {\n                     // FIXME: Resolve the path in all namespaces and resolve its prefixes too.\n                     let ns = TypeNS;\n                     self.doc_link_resolutions"}]}