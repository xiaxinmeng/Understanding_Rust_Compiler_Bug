{"sha": "92f08b78a12ff119af853cb2bf58468208ea6a90", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZjA4Yjc4YTEyZmYxMTlhZjg1M2NiMmJmNTg0NjgyMDhlYTZhOTA=", "commit": {"author": {"name": "phosphorus", "email": "steepout@qq.com", "date": "2019-08-19T05:34:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-19T05:34:02Z"}, "message": "Merge pull request #1 from rust-lang/master\n\nPull from newest repo", "tree": {"sha": "b4636f43c056de11dd69130ce47039343a9f52c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4636f43c056de11dd69130ce47039343a9f52c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92f08b78a12ff119af853cb2bf58468208ea6a90", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdWjTKCRBK7hj4Ov3rIwAAdHIIADCmkpSgsBfukbNvmRtazFkO\nU0OuuHJMvm3Lw65SjXdWykiU6AbVcaJQ4EqTQljEgYFc1Htg11QYy07GWfh8ddO6\n+Izw6SJU7J06PRRTw/YqbJlhvecQhyyNhOF6W9xcsEPWS5GiqOJLNfPRUqbxPMJm\nC7kzvySCJK9ZP+z8HavBfwqFmWxPrzPYhBwfecoSqIjpTS/1loQoUSlBm1XoPOam\nwwZ/ks9Elncb7cRFwkLGcnflg2bR7/tuM/bGkrGZWhv40681dU9KvYFMX7fO6sfR\nvzi2UeohkRA2pezEGlc3QLM6SsVqlWNAyGMf3d+m62K6ONdfV2kjx44toX5mQXI=\n=VftE\n-----END PGP SIGNATURE-----\n", "payload": "tree b4636f43c056de11dd69130ce47039343a9f52c5\nparent 963184bbb670c1ffa97fc28a98cd5e8473118859\nparent a807902dd6b4222179776c3f3c33da8dafdd4da1\nauthor phosphorus <steepout@qq.com> 1566192842 -0500\ncommitter GitHub <noreply@github.com> 1566192842 -0500\n\nMerge pull request #1 from rust-lang/master\n\nPull from newest repo"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92f08b78a12ff119af853cb2bf58468208ea6a90", "html_url": "https://github.com/rust-lang/rust/commit/92f08b78a12ff119af853cb2bf58468208ea6a90", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92f08b78a12ff119af853cb2bf58468208ea6a90/comments", "author": {"login": "Phosphorus15", "id": 15113098, "node_id": "MDQ6VXNlcjE1MTEzMDk4", "avatar_url": "https://avatars.githubusercontent.com/u/15113098?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Phosphorus15", "html_url": "https://github.com/Phosphorus15", "followers_url": "https://api.github.com/users/Phosphorus15/followers", "following_url": "https://api.github.com/users/Phosphorus15/following{/other_user}", "gists_url": "https://api.github.com/users/Phosphorus15/gists{/gist_id}", "starred_url": "https://api.github.com/users/Phosphorus15/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Phosphorus15/subscriptions", "organizations_url": "https://api.github.com/users/Phosphorus15/orgs", "repos_url": "https://api.github.com/users/Phosphorus15/repos", "events_url": "https://api.github.com/users/Phosphorus15/events{/privacy}", "received_events_url": "https://api.github.com/users/Phosphorus15/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "963184bbb670c1ffa97fc28a98cd5e8473118859", "url": "https://api.github.com/repos/rust-lang/rust/commits/963184bbb670c1ffa97fc28a98cd5e8473118859", "html_url": "https://github.com/rust-lang/rust/commit/963184bbb670c1ffa97fc28a98cd5e8473118859"}, {"sha": "a807902dd6b4222179776c3f3c33da8dafdd4da1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a807902dd6b4222179776c3f3c33da8dafdd4da1", "html_url": "https://github.com/rust-lang/rust/commit/a807902dd6b4222179776c3f3c33da8dafdd4da1"}], "stats": {"total": 293957, "additions": 171804, "deletions": 122153}, "files": [{"sha": "81a472451d777435d9ac39589de08c80a56bd7a4", "filename": ".gitignore", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,3 +1,7 @@\n+# This file should only ignore things that are generated during a build,\n+# generated by common IDEs, and optional files controlled by the user\n+# that affect the build (such as config.toml).\n+# FIXME: This needs cleanup.\n *~\n .#*\n .DS_Store\n@@ -12,22 +16,19 @@ __pycache__/\n .project\n .settings/\n .valgrindrc\n-.vscode/\n+.vscode\n .favorites.json\n-/*-*-*-*/\n-/*-*-*/\n /Makefile\n-/build\n+/build/\n /config.toml\n /dist/\n /dl/\n-/doc\n+/doc/\n /inst/\n /llvm/\n /mingw-build/\n-/nd/\n+# Created by default with `src/ci/docker/run.sh`:\n /obj/\n-/rt/\n /rustllvm/\n /src/libcore/unicode/DerivedCoreProperties.txt\n /src/libcore/unicode/DerivedNormalizationProps.txt\n@@ -36,10 +37,9 @@ __pycache__/\n /src/libcore/unicode/Scripts.txt\n /src/libcore/unicode/SpecialCasing.txt\n /src/libcore/unicode/UnicodeData.txt\n-/stage[0-9]+/\n-/target\n-target/\n-/test/\n+/src/libcore/unicode/downloaded\n+/target/\n+# Generated by compiletest for incremental:\n /tmp/\n tags\n tags.*\n@@ -49,18 +49,6 @@ TAGS.*\n \\#*\\#\n config.mk\n config.stamp\n-keywords.md\n-lexer.ml\n-mir_dump\n Session.vim\n-src/etc/dl\n-tmp.*.rs\n-version.md\n-version.ml\n-version.texi\n .cargo\n-!src/vendor/**\n-/src/target/\n-\n no_llvm_build\n-"}, {"sha": "f64e21c5af0e4dec0382ff2261b8354f9a27b246", "filename": ".gitmodules", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -31,9 +31,9 @@\n [submodule \"src/llvm-emscripten\"]\n \tpath = src/llvm-emscripten\n \turl = https://github.com/rust-lang/llvm.git\n-[submodule \"src/stdsimd\"]\n-\tpath = src/stdsimd\n-\turl = https://github.com/rust-lang-nursery/stdsimd.git\n+[submodule \"src/stdarch\"]\n+\tpath = src/stdarch\n+\turl = https://github.com/rust-lang/stdarch.git\n [submodule \"src/doc/rustc-guide\"]\n \tpath = src/doc/rustc-guide\n \turl = https://github.com/rust-lang/rustc-guide.git\n@@ -43,7 +43,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/8.0-2019-03-18\n+\tbranch = rustc/9.0-2019-07-12\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "c5ecfb54fca52df808b9a523857b47fb93bb2f64", "filename": ".mailmap", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -5,8 +5,8 @@\n # email addresses.\n #\n \n+Aaron Power <theaaronepower@gmail.com> Erin Power <xampprocky@gmail.com>\n Aaron Todd <github@opprobrio.us>\n-Aaron Power <theaaronepower@gmail.com>\n Abhishek Chanda <abhishek.becs@gmail.com> Abhishek Chanda <abhishek@cloudscaling.com>\n Adolfo Ochagav\u00eda <aochagavia92@gmail.com>\n Adrien T\u00e9tar <adri-from-59@hotmail.fr>\n@@ -29,8 +29,8 @@ Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> Ariel Ben-Yehuda <ariel.byd@gmail.com>\n Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> arielb1 <arielb1@mail.tau.ac.il>\n Austin Seipp <mad.one@gmail.com> <as@hacks.yi.org>\n Aydin Kim <ladinjin@hanmail.net> aydin.kim <aydin.kim@samsung.com>\n-Bastian Kauschke <bastian_kauschke@hotmail.de>\n Barosl Lee <vcs@barosl.com> Barosl LEE <github@barosl.com>\n+Bastian Kauschke <bastian_kauschke@hotmail.de>\n Ben Alpert <ben@benalpert.com> <spicyjalapeno@gmail.com>\n Ben Sago <ogham@users.noreply.github.com> Ben S <ogham@bsago.me>\n Ben Sago <ogham@users.noreply.github.com> Ben S <ogham@users.noreply.github.com>\n@@ -46,22 +46,24 @@ Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@users.noreply.github.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <cnichols@thinkthroughmath.com>\n-Carol (Nichols || Goulding) <carol.nichols@gmail.com> Carol Nichols <carol.nichols@gmail.com>\n Carol Willing <carolcode@willingconsulting.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n Chris Vittal <christopher.vittal@gmail.com> Christopher Vittal <christopher.vittal@gmail.com>\n-Christian Poveda <christianpoveda@protonmail.com> <z1mvader@protonmail.com>\n Christian Poveda <christianpoveda@protonmail.com> <cn.poveda.ruiz@gmail.com>\n+Christian Poveda <christianpoveda@protonmail.com> <z1mvader@protonmail.com>\n+Christian Poveda <christianpoveda@protonmail.com> <cpovedar@fnal.gov>\n Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n Clinton Ryan <clint.ryan3@gmail.com>\n Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>\n Cyryl P\u0142otnicki <cyplo@cyplo.net>\n Damien Schoof <damien.schoof@gmail.com>\n-Daniel Ramos <dan@daramos.com>\n Daniel J Rollins <drollins@financialforce.com>\n+Daniel Ramos <dan@daramos.com>\n David Klein <david.klein@baesystemsdetica.com>\n David Manescu <david.manescu@gmail.com> <dman2626@uni.sydney.edu.au>\n David Ross <daboross@daboross.net>\n@@ -70,18 +72,18 @@ Diggory Hardy <diggory.hardy@gmail.com> Diggory Hardy <github@dhardy.name>\n Dylan Braithwaite <dylanbraithwaite1@gmail.com> <mail@dylanb.me>\n Dzmitry Malyshau <kvarkus@gmail.com>\n E. Dunham <edunham@mozilla.com> edunham <edunham@mozilla.com>\n+Eduard-Mihai Burtescu <edy.burt@gmail.com>\n Eduardo Bautista <me@eduardobautista.com> <=>\n Eduardo Bautista <me@eduardobautista.com> <mail@eduardobautista.com>\n-Eduard-Mihai Burtescu <edy.burt@gmail.com>\n Elliott Slaughter <elliottslaughter@gmail.com> <eslaughter@mozilla.com>\n Elly Fong-Jones <elly@leptoquark.net>\n Eric Holk <eric.holk@gmail.com> <eholk@cs.indiana.edu>\n Eric Holk <eric.holk@gmail.com> <eholk@mozilla.com>\n Eric Holmes <eric@ejholmes.net>\n Eric Reed <ecreed@cs.washington.edu> <ereed@mozilla.com>\n Erick Tryzelaar <erick.tryzelaar@gmail.com> <etryzelaar@iqt.org>\n-Esteban K\u00fcber <esteban@kuber.com.ar> <estebank@users.noreply.github.com>\n Esteban K\u00fcber <esteban@kuber.com.ar> <esteban@commure.com>\n+Esteban K\u00fcber <esteban@kuber.com.ar> <estebank@users.noreply.github.com>\n Esteban K\u00fcber <esteban@kuber.com.ar> <github@kuber.com.ar>\n Evgeny Sologubov\n Falco Hirschenberger <falco.hirschenberger@gmail.com> <hirschen@itwm.fhg.de>\n@@ -102,9 +104,9 @@ Herman J. Radtke III <herman@hermanradtke.com> Herman J. Radtke III <hermanradtk\n Ilyong Cho <ilyoan@gmail.com>\n Ivan Ivaschenko <defuz.net@gmail.com>\n J. J. Weber <jjweber@gmail.com>\n+Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub@jakub.cc>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakubw@jakubw.net>\n-Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>\n James Deng <cnjamesdeng@gmail.com> <cnJamesDeng@gmail.com>\n James Miller <bladeon@gmail.com> <james@aatch.net>\n James Perry <james.austin.perry@gmail.com>\n@@ -119,6 +121,7 @@ Jethro Beekman <github@jbeekman.nl>\n Jihyun Yu <j.yu@navercorp.com> <yjh0502@gmail.com>\n Jihyun Yu <j.yu@navercorp.com> jihyun <jihyun@nablecomm.com>\n Jihyun Yu <j.yu@navercorp.com> Jihyun Yu <jihyun@nclab.kaist.ac.kr>\n+Jo\u00e3o Oliveira <hello@jxs.pt> joaoxsouls <joaoxsouls@gmail.com>\n Johann Hofmann <git@johann-hofmann.com> Johann <git@johann-hofmann.com>\n John Clements <clements@racket-lang.org> <clements@brinckerhoff.org>\n John Hodge <acessdev@gmail.com> John Hodge <tpg@mutabah.net>\n@@ -129,13 +132,15 @@ Jonathan S <gereeter@gmail.com> Jonathan S <gereeter+code@gmail.com>\n Jonathan Turner <probata@hotmail.com>\n Jorge Aparicio <japaric@linux.com> <japaricious@gmail.com>\n Joseph Martin <pythoner6@gmail.com>\n-Jo\u00e3o Oliveira <hello@jxs.pt> joaoxsouls <joaoxsouls@gmail.com>\n+Joseph T. Lyons <JosephTLyons@gmail.com> <josephtlyons@gmail.com>\n+Joseph T. Lyons <JosephTLyons@gmail.com> <JosephTLyons@users.noreply.github.com>\n Junyoung Cho <june0.cho@samsung.com>\n Jyun-Yan You <jyyou.tw@gmail.com> <jyyou@cs.nctu.edu.tw>\n Kang Seonghoon <kang.seonghoon@mearie.org> <public+git@mearie.org>\n Keegan McAllister <mcallister.keegan@gmail.com> <kmcallister@mozilla.com>\n Kevin Butler <haqkrs@gmail.com>\n Kyeongwoon Lee <kyeongwoon.lee@samsung.com>\n+Lauren\u021biu Nicola <lnicola@dend.ro>\n Lee Jeffery <leejeffery@gmail.com> Lee Jeffery <lee@leejeffery.co.uk>\n Lee Wondong <wdlee91@gmail.com>\n Lennart Kudling <github@kudling.de>\n@@ -145,8 +150,6 @@ Lindsey Kuper <lindsey@composition.al> <lkuper@mozilla.com>\n Luke Metz <luke.metz@students.olin.edu>\n Luqman Aden <me@luqman.ca> <laden@csclub.uwaterloo.ca>\n Luqman Aden <me@luqman.ca> <laden@mozilla.com>\n-NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm@gmail.com>\n-NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm+github@gmail.com>\n Marcell Pardavi <marcell.pardavi@gmail.com>\n Margaret Meyerhofer <mmeyerho@andrew.cmu.edu> <mmeyerho@andrew>\n Mark Rousskov <mark.simulacrum@gmail.com>\n@@ -164,15 +167,19 @@ Matthijs Hofstra <thiezz@gmail.com>\n Melody Horn <melody@boringcactus.com> <mathphreak@gmail.com>\n Michael Williams <m.t.williams@live.com>\n Michael Woerister <michaelwoerister@posteo> <michaelwoerister@gmail>\n+Michael Woerister <michaelwoerister@posteo> <michaelwoerister@users.noreply.github.com>\n+Michael Woerister <michaelwoerister@posteo> <michaelwoerister@posteo.net>\n Micka\u00ebl Raybaud-Roig <raybaudroigm@gmail.com> m-r-r <raybaudroigm@gmail.com>\n Ms2ger <ms2ger@gmail.com> <Ms2ger@gmail.com>\n Mukilan Thiagarajan <mukilanthiagarajan@gmail.com>\n+NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm@gmail.com>\n+NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm+github@gmail.com>\n Nathan West <Lucretiel@gmail.com> <lucretiel@gmail.com>\n Nathan Wilson <wilnathan@gmail.com>\n Nathaniel Herman <nherman@post.harvard.edu> Nathaniel Herman <nherman@college.harvard.edu>\n Neil Pankey <npankey@gmail.com> <neil@wire.im>\n-Nicole Mazzuca <npmazzuca@gmail.com>\n Nick Platt <platt.nicholas@gmail.com>\n+Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n Oliver Schneider <oliver.schneider@kit.edu> oli-obk <github6541940@oli-obk.de>\n Oliver Schneider <oliver.schneider@kit.edu> Oliver 'ker' Schneider <rust19446194516@oli-obk.de>\n@@ -230,8 +237,8 @@ Tim JIANG <p90eri@gmail.com>\n Tim Joseph Dumol <tim@timdumol.com>\n Torsten Weber <TorstenWeber12@gmail.com> <torstenweber12@gmail.com>\n Ty Overby <ty@pre-alpha.com>\n-Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss>\n Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss@users.noreply.github.com>\n+Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss>\n Ulrik Sverdrup <bluss@users.noreply.github.com> Ulrik Sverdrup <root@localhost>\n Vadim Petrochenkov <vadim.petrochenkov@gmail.com>\n Vadim Petrochenkov <vadim.petrochenkov@gmail.com> petrochenkov <vadim.petrochenkov@gmail.com>"}, {"sha": "7a8772d7abd63556a991e2dd2f10b8c0ccdbba69", "filename": ".travis.yml", "status": "removed", "additions": 0, "deletions": 379, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=963184bbb670c1ffa97fc28a98cd5e8473118859", "patch": "@@ -1,379 +0,0 @@\n-language: shell\n-sudo: required\n-dist: xenial\n-services:\n-  - docker\n-addons:\n-  apt:\n-    packages:\n-      - gdb\n-\n-git:\n-  depth: 2\n-  submodules: false\n-\n-env:\n-  global:\n-    - CI_JOB_NAME=$TRAVIS_JOB_NAME\n-\n-matrix:\n-  fast_finish: true\n-  include:\n-    # Images used in testing PR and try-build should be run first.\n-    - env: IMAGE=x86_64-gnu-llvm-6.0 RUST_BACKTRACE=1\n-      name: x86_64-gnu-llvm-6.0\n-      if: type = pull_request OR branch = auto\n-\n-    - env: IMAGE=dist-x86_64-linux DEPLOY=1\n-      name: dist-x86_64-linux\n-      if: branch = try OR branch = auto\n-\n-    # \"alternate\" deployments, these are \"nightlies\" but have LLVM assertions\n-    # turned on, they're deployed to a different location primarily for\n-    # additional testing.\n-    - env: IMAGE=dist-x86_64-linux DEPLOY_ALT=1\n-      name: dist-x86_64-linux-alt\n-      if: branch = try OR branch = auto\n-\n-    - env: >\n-        RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--enable-extended --enable-profiler --enable-lldb --set rust.jemalloc\"\n-        SRC=.\n-        DEPLOY_ALT=1\n-        RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        MACOSX_DEPLOYMENT_TARGET=10.7\n-        NO_LLVM_ASSERTIONS=1\n-        NO_DEBUG_ASSERTIONS=1\n-      os: osx\n-      osx_image: xcode9.3-moar\n-      name: dist-x86_64-apple-alt\n-      if: branch = auto\n-\n-    # macOS builders. These are placed near the beginning because they are very\n-    # slow to run.\n-\n-    # OSX builders running tests, these run the full test suite.\n-    # NO_DEBUG_ASSERTIONS=1 to make them go faster, but also do have some\n-    # runners that run `//ignore-debug` tests.\n-    #\n-    # Note that the compiler is compiled to target 10.8 here because the Xcode\n-    # version that we're using, 8.2, cannot compile LLVM for OSX 10.7.\n-    - env: >\n-        RUST_CHECK_TARGET=check\n-        RUST_CONFIGURE_ARGS=\"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n-        SRC=.\n-        RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        MACOSX_DEPLOYMENT_TARGET=10.8\n-        MACOSX_STD_DEPLOYMENT_TARGET=10.7\n-        NO_LLVM_ASSERTIONS=1\n-        NO_DEBUG_ASSERTIONS=1\n-      os: osx\n-      osx_image: xcode9.3-moar\n-      name: x86_64-apple\n-      if: branch = auto\n-\n-    - env: >\n-        RUST_CHECK_TARGET=check\n-        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --set rust.jemalloc\"\n-        SRC=.\n-        RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        MACOSX_DEPLOYMENT_TARGET=10.8\n-        MACOSX_STD_DEPLOYMENT_TARGET=10.7\n-        NO_LLVM_ASSERTIONS=1\n-        NO_DEBUG_ASSERTIONS=1\n-      os: osx\n-      osx_image: xcode9.3-moar\n-      name: i686-apple\n-      if: branch = auto\n-\n-    # OSX builders producing releases. These do not run the full test suite and\n-    # just produce a bunch of artifacts.\n-    #\n-    # Note that these are running in the `xcode7` image instead of the\n-    # `xcode8.2` image as above. That's because we want to build releases for\n-    # OSX 10.7 and `xcode7` is the latest Xcode able to compile LLVM for 10.7.\n-    - env: >\n-        RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-full-tools --enable-profiler --enable-lldb --set rust.jemalloc\"\n-        SRC=.\n-        DEPLOY=1\n-        RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        MACOSX_DEPLOYMENT_TARGET=10.7\n-        NO_LLVM_ASSERTIONS=1\n-        NO_DEBUG_ASSERTIONS=1\n-        DIST_REQUIRE_ALL_TOOLS=1\n-      os: osx\n-      osx_image: xcode9.3-moar\n-      name: dist-i686-apple\n-      if: branch = auto\n-\n-    - env: >\n-        RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --enable-lldb --set rust.jemalloc\"\n-        SRC=.\n-        DEPLOY=1\n-        RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        MACOSX_DEPLOYMENT_TARGET=10.7\n-        NO_LLVM_ASSERTIONS=1\n-        NO_DEBUG_ASSERTIONS=1\n-        DIST_REQUIRE_ALL_TOOLS=1\n-      os: osx\n-      osx_image: xcode9.3-moar\n-      name: dist-x86_64-apple\n-      if: branch = auto\n-\n-    # Linux builders, remaining docker images\n-    - env: IMAGE=arm-android\n-      name: arm-android\n-      if: branch = auto\n-    - env: IMAGE=armhf-gnu\n-      name: armhf-gnu\n-      if: branch = auto\n-    - env: IMAGE=dist-various-1 DEPLOY=1\n-      name: dist-various-1\n-      if: branch = auto\n-    - env: IMAGE=dist-various-2 DEPLOY=1\n-      name: dist-various-2\n-      if: branch = auto\n-    - env: IMAGE=dist-aarch64-linux DEPLOY=1\n-      name: dist-aarch64-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-android DEPLOY=1\n-      name: dist-android\n-      if: branch = auto\n-    - env: IMAGE=dist-arm-linux DEPLOY=1\n-      name: dist-arm-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-armhf-linux DEPLOY=1\n-      name: dist-armhf-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-armv7-linux DEPLOY=1\n-      name: dist-armv7-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-i586-gnu-i586-i686-musl DEPLOY=1\n-      name: dist-i586-gnu-i586-i686-musl\n-      if: branch = auto\n-    - env: IMAGE=dist-i686-freebsd DEPLOY=1\n-      name: dist-i686-freebsd\n-      if: branch = auto\n-    - env: IMAGE=dist-i686-linux DEPLOY=1\n-      name: dist-i686-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-mips-linux DEPLOY=1\n-      name: dist-mips-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-mips64-linux DEPLOY=1\n-      name: dist-mips64-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-mips64el-linux DEPLOY=1\n-      name: dist-mips64el-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-mipsel-linux DEPLOY=1\n-      name: dist-mipsel-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-powerpc-linux DEPLOY=1\n-      name: dist-powerpc-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-powerpc64-linux DEPLOY=1\n-      name: dist-powerpc64-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-powerpc64le-linux DEPLOY=1\n-      name: dist-powerpc64le-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-s390x-linux DEPLOY=1\n-      name: dist-s390x-linux\n-      if: branch = auto\n-    - env: IMAGE=dist-x86_64-freebsd DEPLOY=1\n-      name: dist-x86_64-freebsd\n-      if: branch = auto\n-    - env: IMAGE=dist-x86_64-musl DEPLOY=1\n-      name: dist-x86_64-musl\n-      if: branch = auto\n-    - env: IMAGE=dist-x86_64-netbsd DEPLOY=1\n-      name: dist-x86_64-netbsd\n-      if: branch = auto\n-    - env: IMAGE=asmjs\n-      name: asmjs\n-      if: branch = auto\n-    - env: IMAGE=i686-gnu\n-      name: i686-gnu\n-      if: branch = auto\n-    - env: IMAGE=i686-gnu-nopt\n-      name: i686-gnu-nopt\n-      if: branch = auto\n-    - env: IMAGE=test-various\n-      name: test-various\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu\n-      name: x86_64-gnu\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu-full-bootstrap\n-      name: x86_64-gnu-full-bootstrap\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu-aux\n-      name: x86_64-gnu-aux\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu-tools\n-      name: x86_64-gnu-tools\n-      if: branch = auto OR (type = pull_request AND commit_message =~ /(?i:^update.*\\b(rls|rustfmt|clippy|miri|cargo)\\b)/)\n-    - env: IMAGE=x86_64-gnu-debug\n-      name: x86_64-gnu-debug\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu-nopt\n-      name: x86_64-gnu-nopt\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu-distcheck\n-      name: x86_64-gnu-distcheck\n-      if: branch = auto\n-    - env: IMAGE=mingw-check\n-      name: mingw-check\n-      if: type = pull_request OR branch = auto\n-\n-    - stage: publish toolstate\n-      if: branch = master AND type = push\n-      before_install: []\n-      install: []\n-      sudo: false\n-      script:\n-        MESSAGE_FILE=$(mktemp -t msg.XXXXXX);\n-        . src/ci/docker/x86_64-gnu-tools/repo.sh;\n-        commit_toolstate_change \"$MESSAGE_FILE\" \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"$MESSAGE_FILE\" \"$TOOLSTATE_REPO_ACCESS_TOKEN\";\n-\n-before_install:\n-  # We'll use the AWS cli to download/upload cached docker layers as well as\n-  # push our deployments, so download that here.\n-  - pip install --user awscli; export PATH=$PATH:$HOME/.local/bin:$HOME/Library/Python/2.7/bin/\n-  - mkdir -p $HOME/rustsrc\n-  # FIXME(#46924): these two commands are required to enable IPv6,\n-  # they shouldn't exist, please revert once more official solutions appeared.\n-  # see https://github.com/travis-ci/travis-ci/issues/8891#issuecomment-353403729\n-  - if [ \"$TRAVIS_OS_NAME\" = linux ]; then\n-      echo '{\"ipv6\":true,\"fixed-cidr-v6\":\"fd9a:8454:6789:13f7::/64\"}' | sudo tee /etc/docker/daemon.json;\n-      sudo service docker restart;\n-    fi\n-\n-install:\n-  - case \"$TRAVIS_OS_NAME\" in\n-        linux)\n-          travis_retry curl -fo $HOME/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-unknown-linux-musl &&\n-            chmod +x $HOME/stamp &&\n-            export PATH=$PATH:$HOME\n-          ;;\n-        osx)\n-          if [[ \"$RUST_CHECK_TARGET\" == dist ]]; then\n-            travis_retry brew update &&\n-            travis_retry brew install xz &&\n-            travis_retry brew install swig;\n-          fi &&\n-          travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin &&\n-            chmod +x /usr/local/bin/sccache &&\n-          travis_retry curl -fo /usr/local/bin/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-apple-darwin &&\n-            chmod +x /usr/local/bin/stamp &&\n-          travis_retry curl -f http://releases.llvm.org/7.0.0/clang+llvm-7.0.0-x86_64-apple-darwin.tar.xz | tar xJf - &&\n-            export CC=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang &&\n-            export CXX=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang++ &&\n-            export AR=ar\n-          ;;\n-    esac\n-\n-before_script:\n-  - >\n-      echo \"#### Disk usage before running script:\";\n-      df -h;\n-      du . | sort -nr | head -n100\n-  - >\n-      RUN_SCRIPT=\"src/ci/init_repo.sh . $HOME/rustsrc\";\n-      if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n-          export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/run.sh\";\n-      else\n-          export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/docker/run.sh $IMAGE\";\n-          # Enable core dump on Linux.\n-          sudo sh -c 'echo \"/checkout/obj/cores/core.%p.%E\" > /proc/sys/kernel/core_pattern';\n-      fi\n-  - >\n-      if [ \"$IMAGE\" = mingw-check ]; then\n-        # verify the publish_toolstate script works.\n-        git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git;\n-        cd rust-toolstate;\n-        python2.7 \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"\" \"\";\n-        cd ..;\n-        rm -rf rust-toolstate;\n-      fi\n-\n-# Log time information from this machine and an external machine for insight into possible\n-# clock drift. Timezones don't matter since relative deltas give all the necessary info.\n-script:\n-  - >\n-      date && (curl -fs --head https://google.com | grep ^Date: | sed 's/Date: //g' || true)\n-  - stamp sh -x -c \"$RUN_SCRIPT\"\n-  - >\n-      date && (curl -fs --head https://google.com | grep ^Date: | sed 's/Date: //g' || true)\n-\n-after_success:\n-  - >\n-      echo \"#### Build successful; Disk usage after running script:\";\n-      df -h;\n-      du . | sort -nr | head -n100\n-  - >\n-      if [ \"$DEPLOY$DEPLOY_ALT\" == \"1\" ]; then\n-        mkdir -p deploy/$TRAVIS_COMMIT;\n-        if [ \"$TRAVIS_OS_NAME\" == \"osx\" ]; then\n-            rm -rf build/dist/doc &&\n-            cp -r build/dist/* deploy/$TRAVIS_COMMIT;\n-        else\n-            rm -rf obj/build/dist/doc &&\n-            cp -r obj/build/dist/* deploy/$TRAVIS_COMMIT;\n-        fi;\n-        ls -la deploy/$TRAVIS_COMMIT;\n-        deploy_dir=rustc-builds;\n-        if [ \"$DEPLOY_ALT\" == \"1\" ]; then\n-            deploy_dir=rustc-builds-alt;\n-        fi;\n-        travis_retry aws s3 cp --no-progress --recursive --acl public-read ./deploy s3://rust-lang-ci2/$deploy_dir\n-      fi\n-\n-after_failure:\n-  - >\n-      echo \"#### Build failed; Disk usage after running script:\";\n-      df -h;\n-      du . | sort -nr | head -n100\n-\n-  # Random attempt at debugging currently. Just poking around in here to see if\n-  # anything shows up.\n-\n-  # Dump backtrace for macOS\n-  - ls -lat $HOME/Library/Logs/DiagnosticReports/\n-  - find $HOME/Library/Logs/DiagnosticReports\n-      -type f\n-      -name '*.crash'\n-      -not -name '*.stage2-*.crash'\n-      -not -name 'com.apple.CoreSimulator.CoreSimulatorService-*.crash'\n-      -exec printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" {} \\;\n-      -exec head -750 {} \\;\n-      -exec echo travis_fold\":\"end:crashlog \\; || true\n-\n-  # Dump backtrace for Linux\n-  - ln -s . checkout &&\n-    for CORE in obj/cores/core.*; do\n-      EXE=$(echo $CORE | sed 's|obj/cores/core\\.[0-9]*\\.!checkout!\\(.*\\)|\\1|;y|!|/|');\n-      if [ -f \"$EXE\" ]; then\n-        printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" \"$CORE\";\n-        gdb --batch -q -c \"$CORE\" \"$EXE\"\n-          -iex 'set auto-load off'\n-          -iex 'dir src/'\n-          -iex 'set sysroot .'\n-          -ex bt\n-          -ex q;\n-        echo travis_fold\":\"end:crashlog;\n-      fi;\n-    done || true\n-\n-  # see #50887\n-  - cat ./obj/build/x86_64-unknown-linux-gnu/native/asan/build/lib/asan/clang_rt.asan-dynamic-i386.vers || true\n-\n-  # attempt to debug anything killed by the oom killer on linux, just to see if\n-  # it happened\n-  - dmesg | grep -i kill\n-\n-notifications:\n-  email: false"}, {"sha": "4daaa986a2dc2fbf31080efade8a989be2de2d69", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -179,7 +179,6 @@ Speaking of tests, Rust has a comprehensive test suite. More information about\n it can be found [here][rctd].\n \n ### External Dependencies\n-[external-dependencies]: #external-dependencies\n \n Currently building Rust will also build the following external projects:\n \n@@ -209,7 +208,6 @@ Breakage is not allowed in the beta and stable channels, and must be addressed\n before the PR is merged.\n \n #### Breaking Tools Built With The Compiler\n-[breaking-tools-built-with-the-compiler]: #breaking-tools-built-with-the-compiler\n \n Rust's build system builds a number of tools that make use of the\n internals of the compiler. This includes\n@@ -242,7 +240,7 @@ Here are those same steps in detail:\n    `config.toml.example` in the root directory of the Rust repository.\n    Set `submodules = false` in the `[build]` section. This will prevent `x.py`\n    from resetting to the original branch after you make your changes. If you\n-   need to [update any submodules to their latest versions][updating-submodules],\n+   need to [update any submodules to their latest versions](#updating-submodules),\n    see the section of this file about that for more information.\n 2. (optional) Run `./x.py test src/tools/rustfmt` (substituting the submodule\n    that broke for `rustfmt`). Fix any errors in the submodule (and possibly others).\n@@ -256,7 +254,6 @@ Here are those same steps in detail:\n 8. (optional) Send a PR to rust-lang/rust updating the submodule.\n \n #### Updating submodules\n-[updating-submodules]: #updating-submodules\n \n These instructions are specific to updating `rustfmt`, however they may apply\n to the other submodules as well. Please help by improving these instructions\n@@ -310,7 +307,6 @@ This should change the version listed in `Cargo.lock` to the new version you upd\n the submodule to. Running `./x.py build` should work now.\n \n ## Writing Documentation\n-[writing-documentation]: #writing-documentation\n \n Documentation improvements are very welcome. The source of `doc.rust-lang.org`\n is located in `src/doc` in the tree, and standard API documentation is generated\n@@ -337,7 +333,6 @@ tracker in that repo is also a great way to find things that need doing. There\n are issues for beginners and advanced compiler devs alike!\n \n ## Issue Triage\n-[issue-triage]: #issue-triage\n \n Sometimes, an issue will stay open, even though the bug has been fixed. And\n sometimes, the original bug may go stale because something has changed in the\n@@ -405,7 +400,6 @@ If you're looking for somewhere to start, check out the [E-easy][eeasy] tag.\n [rfcbot]: https://github.com/anp/rfcbot-rs/\n \n ## Out-of-tree Contributions\n-[out-of-tree-contributions]: #out-of-tree-contributions\n \n There are a number of other ways to contribute to Rust that don't deal with\n this repository.\n@@ -425,7 +419,6 @@ valuable!\n [community-library]: https://github.com/rust-lang/rfcs/labels/A-community-library\n \n ## Helpful Links and Information\n-[helpful-info]: #helpful-info\n \n For people new to Rust, and just starting to contribute, or even for\n more seasoned developers, some useful places to look for information"}, {"sha": "c784246ba396ec46a75c54b5b773dc9022c6a603", "filename": "Cargo.lock", "status": "modified", "additions": 1163, "deletions": 842, "changes": 2005, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "724bc36ecc6fb7fd2bb6b9783416528c7554b9ae", "filename": "README.md", "status": "modified", "additions": 37, "deletions": 52, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -6,19 +6,22 @@ standard library, and documentation.\n [Rust]: https://www.rust-lang.org\n \n ## Quick Start\n-[quick-start]: #quick-start\n \n Read [\"Installation\"] from [The Book].\n \n [\"Installation\"]: https://doc.rust-lang.org/book/ch01-01-installation.html\n [The Book]: https://doc.rust-lang.org/book/index.html\n \n ## Installing from Source\n-[building-from-source]: #building-from-source\n \n-_Note: If you wish to contribute to the compiler, you should read\n-[this chapter](https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html)\n-of the rustc-guide instead._\n+_Note: If you wish to contribute to the compiler, you should read [this\n+chapter][rustcguidebuild] of the rustc-guide instead of this section._\n+\n+The Rust build system has a Python script called `x.py` to bootstrap building\n+the compiler. More information about it may be found by running `./x.py --help`\n+or reading the [rustc guide][rustcguidebuild].\n+\n+[rustcguidebuild]: https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html\n \n ### Building on *nix\n 1. Make sure you have installed the dependencies:\n@@ -39,43 +42,36 @@ of the rustc-guide instead._\n \n [source]: https://github.com/rust-lang/rust\n \n-3. Build and install:\n-\n-    ```sh\n-    $ ./x.py build && sudo ./x.py install\n-    ```\n+3. Configure the build settings:\n \n-    If after running `sudo ./x.py install` you see an error message like\n+    The Rust build system uses a file named `config.toml` in the root of the\n+    source tree to determine various configuration settings for the build.\n+    Copy the default `config.toml.example` to `config.toml` to get started.\n \n-    ```\n-    error: failed to load source for a dependency on 'cc'\n+    ```sh\n+    $ cp config.toml.example config.toml\n     ```\n \n-    then run these two commands and then try `sudo ./x.py install` again:\n+    It is recommended that if you plan to use the Rust build system to create\n+    an installation (using `./x.py install`) that you set the `prefix` value\n+    in the `[install]` section to a directory that you have write permissions.\n \n-    ```\n-    $ cargo install cargo-vendor\n-    ```\n+4. Build and install:\n \n+    ```sh\n+    $ ./x.py build && ./x.py install\n     ```\n-    $ cargo vendor\n-    ```\n-\n-    > ***Note:*** Install locations can be adjusted by copying the config file\n-    > from `./config.toml.example` to `./config.toml`, and\n-    > adjusting the `prefix` option under `[install]`. Various other options, such\n-    > as enabling debug information, are also supported, and are documented in\n-    > the config file.\n \n-    When complete, `sudo ./x.py install` will place several programs into\n-    `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n+    When complete, `./x.py install` will place several programs into\n+    `$PREFIX/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n     API-documentation tool. This install does not include [Cargo],\n-    Rust's package manager, which you may also want to build.\n+    Rust's package manager. To build and install Cargo, you may\n+    run `./x.py install cargo` or set the `build.extended` key in\n+    `config.toml` to `true` to build and install all tools.\n \n [Cargo]: https://github.com/rust-lang/cargo\n \n ### Building on Windows\n-[building-on-windows]: #building-on-windows\n \n There are two prominent ABIs in use on Windows: the native (MSVC) ABI used by\n Visual Studio, and the GNU ABI used by the GCC toolchain. Which version of Rust\n@@ -85,7 +81,6 @@ for interop with GNU software built using the MinGW/MSYS2 toolchain use the GNU\n build.\n \n #### MinGW\n-[windows-mingw]: #windows-mingw\n \n [MSYS2][msys2] can be used to easily build Rust on Windows:\n \n@@ -126,17 +121,15 @@ build.\n    ```\n \n #### MSVC\n-[windows-msvc]: #windows-msvc\n \n MSVC builds of Rust additionally require an installation of Visual Studio 2017\n (or later) so `rustc` can use its linker.  The simplest way is to get the\n-[Visual Studio Build Tools] and check the \u201cC++ build tools\u201d workload.\n+[Visual Studio], check the \u201cC++ build tools\u201d and \u201cWindows 10 SDK\u201d workload.\n \n-[Visual Studio Build Tools]: https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2019\n+[Visual Studio]: https://visualstudio.microsoft.com/downloads/\n \n-At last check (cmake 3.14.3 and msvc 16.0.3) using the 2019 tools fails to\n-build the in-tree LLVM build with a CMake error, so use 2017 instead by\n-including the \u201cMSVC v141 \u2013 VS 2017 C++ x64/x86 build tools (v14.16)\u201d component.\n+(If you're installing cmake yourself, be careful that \u201cC++ CMake tools for\n+Windows\u201d doesn't get included under \u201cIndividual components\u201d.)\n \n With these dependencies installed, you can build the compiler in a `cmd.exe`\n shell with:\n@@ -151,12 +144,11 @@ then you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n \n ```batch\n-> CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\n+> CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n > python x.py build\n ```\n \n #### Specifying an ABI\n-[specifying-an-abi]: #specifying-an-abi\n \n Each specific ABI can also be used from either environment (for example, using\n the GNU ABI in PowerShell) by using an explicit build triple. The available\n@@ -170,11 +162,10 @@ Windows build triples are:\n \n The build triple can be specified by either specifying `--build=<triple>` when\n invoking `x.py` commands, or by copying the `config.toml` file (as described\n-in Building From Source), and modifying the `build` option under the `[build]`\n-section.\n+in [Installing From Source](#installing-from-source)), and modifying the\n+`build` option under the `[build]` section.\n \n ### Configure and Make\n-[configure-and-make]: #configure-and-make\n \n While it's not the recommended build system, this project also provides a\n configure script and makefile (the latter of which just invokes `x.py`).\n@@ -189,7 +180,6 @@ When using the configure script, the generated `config.mk` file may override the\n `config.mk` file.\n \n ## Building Documentation\n-[building-documentation]: #building-documentation\n \n If you\u2019d like to build the documentation, it\u2019s almost the same:\n \n@@ -202,7 +192,6 @@ the ABI used. I.e., if the ABI was `x86_64-pc-windows-msvc`, the directory will\n `build\\x86_64-pc-windows-msvc\\doc`.\n \n ## Notes\n-[notes]: #notes\n \n Since the Rust compiler is written in Rust, it must be built by a\n precompiled \"snapshot\" version of itself (made in an earlier stage of\n@@ -211,11 +200,11 @@ fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n Snapshot binaries are currently built and tested on several platforms:\n \n-| Platform / Architecture  | x86 | x86_64 |\n-|--------------------------|-----|--------|\n-| Windows (7, 8, 10, ...)  | \u2713   | \u2713      |\n-| Linux (2.6.18 or later)  | \u2713   | \u2713      |\n-| OSX (10.7 Lion or later) | \u2713   | \u2713      |\n+| Platform / Architecture    | x86 | x86_64 |\n+|----------------------------|-----|--------|\n+| Windows (7, 8, 10, ...)    | \u2713   | \u2713      |\n+| Linux (2.6.18 or later)    | \u2713   | \u2713      |\n+| macOS (10.7 Lion or later) | \u2713   | \u2713      |\n \n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work.\n@@ -225,7 +214,6 @@ There is more advice about hacking on Rust in [CONTRIBUTING.md].\n [CONTRIBUTING.md]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md\n \n ## Getting Help\n-[getting-help]: #getting-help\n \n The Rust community congregates in a few places:\n \n@@ -238,7 +226,6 @@ The Rust community congregates in a few places:\n [users.rust-lang.org]: https://users.rust-lang.org/\n \n ## Contributing\n-[contributing]: #contributing\n \n To contribute to Rust, please see [CONTRIBUTING](CONTRIBUTING.md).\n \n@@ -259,7 +246,6 @@ Also, you may find the [rustdocs for the compiler itself][rustdocs] useful.\n [rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n \n ## License\n-[license]: #license\n \n Rust is primarily distributed under the terms of both the MIT license\n and the Apache License (Version 2.0), with portions covered by various\n@@ -269,7 +255,6 @@ See [LICENSE-APACHE](LICENSE-APACHE), [LICENSE-MIT](LICENSE-MIT), and\n [COPYRIGHT](COPYRIGHT) for details.\n \n ## Trademark\n-[trademark]: #trademark\n \n The Rust programming language is an open source, community project governed\n by a core team. It is also sponsored by the Mozilla Foundation (\u201cMozilla\u201d),"}, {"sha": "f26f6e6c888eda387ced2872b2e6eb3dc9074f75", "filename": "RELEASES.md", "status": "modified", "additions": 228, "deletions": 9, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,3 +1,222 @@\n+Version 1.37.0 (2019-08-15)\n+==========================\n+\n+Language\n+--------\n+- `#[must_use]` will now warn if the type is contained in a [tuple][61100],\n+  [`Box`][62228], or an [array][62235] and unused.\n+- [You can now use the `cfg` and `cfg_attr` attributes on\n+  generic parameters.][61547]\n+- [You can now use enum variants through type alias.][61682] e.g. You can\n+  write the following:\n+  ```rust\n+  type MyOption = Option<u8>;\n+\n+  fn increment_or_zero(x: MyOption) -> u8 {\n+      match x {\n+          MyOption::Some(y) => y + 1,\n+          MyOption::None => 0,\n+      }\n+  }\n+  ```\n+- [You can now use `_` as an identifier for consts.][61347] e.g. You can write\n+  `const _: u32 = 5;`.\n+- [You can now use `#[repr(align(X)]` on enums.][61229]\n+- [The  `?` Kleene macro operator is now available in the\n+  2015 edition.][60932]\n+\n+Compiler\n+--------\n+- [You can now enable Profile-Guided Optimization with the `-C profile-generate`\n+  and `-C profile-use` flags.][61268] For more information on how to use profile\n+  guided optimization, please refer to the [rustc book][rustc-book-pgo].\n+- [The `rust-lldb` wrapper script should now work again.][61827]\n+\n+Libraries\n+---------\n+- [`mem::MaybeUninit<T>` is now ABI-compatible with `T`.][61802]\n+\n+Stabilized APIs\n+---------------\n+- [`BufReader::buffer`]\n+- [`BufWriter::buffer`]\n+- [`Cell::from_mut`]\n+- [`Cell<[T]>::as_slice_of_cells`][`Cell<slice>::as_slice_of_cells`]\n+- [`DoubleEndedIterator::nth_back`]\n+- [`Option::xor`]\n+- [`Wrapping::reverse_bits`]\n+- [`i128::reverse_bits`]\n+- [`i16::reverse_bits`]\n+- [`i32::reverse_bits`]\n+- [`i64::reverse_bits`]\n+- [`i8::reverse_bits`]\n+- [`isize::reverse_bits`]\n+- [`slice::copy_within`]\n+- [`u128::reverse_bits`]\n+- [`u16::reverse_bits`]\n+- [`u32::reverse_bits`]\n+- [`u64::reverse_bits`]\n+- [`u8::reverse_bits`]\n+- [`usize::reverse_bits`]\n+\n+Cargo\n+-----\n+- [`Cargo.lock` files are now included by default when publishing executable crates\n+  with executables.][cargo/7026]\n+- [You can now specify `default-run=\"foo\"` in `[package]` to specify the\n+  default executable to use for `cargo run`.][cargo/7056]\n+\n+Misc\n+----\n+\n+Compatibility Notes\n+-------------------\n+- [Using `...` for inclusive range patterns will now warn by default.][61342]\n+  Please transition your code to using the `..=` syntax for inclusive\n+  ranges instead.\n+- [Using a trait object without the `dyn` will now warn by default.][61203]\n+  Please transition your code to use `dyn Trait` for trait objects instead.\n+\n+[62228]: https://github.com/rust-lang/rust/pull/62228/\n+[62235]: https://github.com/rust-lang/rust/pull/62235/\n+[61802]: https://github.com/rust-lang/rust/pull/61802/\n+[61827]: https://github.com/rust-lang/rust/pull/61827/\n+[61547]: https://github.com/rust-lang/rust/pull/61547/\n+[61682]: https://github.com/rust-lang/rust/pull/61682/\n+[61268]: https://github.com/rust-lang/rust/pull/61268/\n+[61342]: https://github.com/rust-lang/rust/pull/61342/\n+[61347]: https://github.com/rust-lang/rust/pull/61347/\n+[61100]: https://github.com/rust-lang/rust/pull/61100/\n+[61203]: https://github.com/rust-lang/rust/pull/61203/\n+[61229]: https://github.com/rust-lang/rust/pull/61229/\n+[60932]: https://github.com/rust-lang/rust/pull/60932/\n+[cargo/7026]: https://github.com/rust-lang/cargo/pull/7026/\n+[cargo/7056]: https://github.com/rust-lang/cargo/pull/7056/\n+[`BufReader::buffer`]: https://doc.rust-lang.org/std/io/struct.BufReader.html#method.buffer\n+[`BufWriter::buffer`]: https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.buffer\n+[`Cell::from_mut`]: https://doc.rust-lang.org/std/cell/struct.Cell.html#method.from_mut\n+[`Cell<slice>::as_slice_of_cells`]: https://doc.rust-lang.org/std/cell/struct.Cell.html#method.as_slice_of_cells\n+[`DoubleEndedIterator::nth_back`]: https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.nth_back\n+[`Option::xor`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.xor\n+[`RefCell::try_borrow_unguarded`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.try_borrow_unguarded\n+[`Wrapping::reverse_bits`]: https://doc.rust-lang.org/std/num/struct.Wrapping.html#method.reverse_bits\n+[`i128::reverse_bits`]: https://doc.rust-lang.org/std/primitive.i128.html#method.reverse_bits\n+[`i16::reverse_bits`]: https://doc.rust-lang.org/std/primitive.i16.html#method.reverse_bits\n+[`i32::reverse_bits`]: https://doc.rust-lang.org/std/primitive.i32.html#method.reverse_bits\n+[`i64::reverse_bits`]: https://doc.rust-lang.org/std/primitive.i64.html#method.reverse_bits\n+[`i8::reverse_bits`]: https://doc.rust-lang.org/std/primitive.i8.html#method.reverse_bits\n+[`isize::reverse_bits`]: https://doc.rust-lang.org/std/primitive.isize.html#method.reverse_bits\n+[`slice::copy_within`]: https://doc.rust-lang.org/std/primitive.slice.html#method.copy_within\n+[`u128::reverse_bits`]: https://doc.rust-lang.org/std/primitive.u128.html#method.reverse_bits\n+[`u16::reverse_bits`]: https://doc.rust-lang.org/std/primitive.u16.html#method.reverse_bits\n+[`u32::reverse_bits`]: https://doc.rust-lang.org/std/primitive.u32.html#method.reverse_bits\n+[`u64::reverse_bits`]: https://doc.rust-lang.org/std/primitive.u64.html#method.reverse_bits\n+[`u8::reverse_bits`]: https://doc.rust-lang.org/std/primitive.u8.html#method.reverse_bits\n+[`usize::reverse_bits`]: https://doc.rust-lang.org/std/primitive.usize.html#method.reverse_bits\n+[rustc-book-pgo]: https://doc.rust-lang.org/rustc/profile-guided-optimization.html\n+\n+\n+Version 1.36.0 (2019-07-04)\n+==========================\n+\n+Language\n+--------\n+- [Non-Lexical Lifetimes are now enabled on the 2015 edition.][59114]\n+- [The order of traits in trait objects no longer affects the semantics of that\n+  object.][59445] e.g. `dyn Send + fmt::Debug` is now equivalent to\n+  `dyn fmt::Debug + Send`, where this was previously not the case.\n+\n+Libraries\n+---------\n+- [`HashMap`'s implementation has been replaced with `hashbrown::HashMap` implementation.][58623]\n+- [`TryFromSliceError` now implements `From<Infallible>`.][60318]\n+- [`mem::needs_drop` is now available as a const fn.][60364]\n+- [`alloc::Layout::from_size_align_unchecked` is now available as a const fn.][60370]\n+- [`String` now implements `BorrowMut<str>`.][60404]\n+- [`io::Cursor` now implements `Default`.][60234]\n+- [Both `NonNull::{dangling, cast}` are now const fns.][60244]\n+- [The `alloc` crate is now stable.][59675] `alloc` allows you to use a subset\n+  of `std` (e.g. `Vec`, `Box`, `Arc`) in `#![no_std]` environments if the\n+  environment has access to heap memory allocation.\n+- [`String` now implements `From<&String>`.][59825]\n+- [You can now pass multiple arguments to the `dbg!` macro.][59826] `dbg!` will\n+  return a tuple of each argument when there is multiple arguments.\n+- [`Result::{is_err, is_ok}` are now `#[must_use]` and will produce a warning if\n+  not used.][59648]\n+\n+Stabilized APIs\n+---------------\n+- [`VecDeque::rotate_left`]\n+- [`VecDeque::rotate_right`]\n+- [`Iterator::copied`]\n+- [`io::IoSlice`]\n+- [`io::IoSliceMut`]\n+- [`Read::read_vectored`]\n+- [`Write::write_vectored`]\n+- [`str::as_mut_ptr`]\n+- [`mem::MaybeUninit`]\n+- [`pointer::align_offset`]\n+- [`future::Future`]\n+- [`task::Context`]\n+- [`task::RawWaker`]\n+- [`task::RawWakerVTable`]\n+- [`task::Waker`]\n+- [`task::Poll`]\n+\n+Cargo\n+-----\n+- [Cargo will now produce an error if you attempt to use the name of a required dependency as a feature.][cargo/6860]\n+- [You can now pass the `--offline` flag to run cargo without accessing the network.][cargo/6934]\n+\n+You can find further change's in [Cargo's 1.36.0 release notes][cargo-1-36-0].\n+\n+Clippy\n+------\n+There have been numerous additions and fixes to clippy, see [Clippy's 1.36.0 release notes][clippy-1-36-0] for more details.\n+\n+Misc\n+----\n+\n+Compatibility Notes\n+-------------------\n+- With the stabilisation of `mem::MaybeUninit`, `mem::uninitialized` use is no\n+  longer recommended, and will be deprecated in 1.39.0.\n+\n+[60318]: https://github.com/rust-lang/rust/pull/60318/\n+[60364]: https://github.com/rust-lang/rust/pull/60364/\n+[60370]: https://github.com/rust-lang/rust/pull/60370/\n+[60404]: https://github.com/rust-lang/rust/pull/60404/\n+[60234]: https://github.com/rust-lang/rust/pull/60234/\n+[60244]: https://github.com/rust-lang/rust/pull/60244/\n+[58623]: https://github.com/rust-lang/rust/pull/58623/\n+[59648]: https://github.com/rust-lang/rust/pull/59648/\n+[59675]: https://github.com/rust-lang/rust/pull/59675/\n+[59825]: https://github.com/rust-lang/rust/pull/59825/\n+[59826]: https://github.com/rust-lang/rust/pull/59826/\n+[59445]: https://github.com/rust-lang/rust/pull/59445/\n+[59114]: https://github.com/rust-lang/rust/pull/59114/\n+[cargo/6860]: https://github.com/rust-lang/cargo/pull/6860/\n+[cargo/6934]: https://github.com/rust-lang/cargo/pull/6934/\n+[`VecDeque::rotate_left`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_left\n+[`VecDeque::rotate_right`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_right\n+[`Iterator::copied`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.copied\n+[`io::IoSlice`]: https://doc.rust-lang.org/std/io/struct.IoSlice.html\n+[`io::IoSliceMut`]: https://doc.rust-lang.org/std/io/struct.IoSliceMut.html\n+[`Read::read_vectored`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_vectored\n+[`Write::write_vectored`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_vectored\n+[`str::as_mut_ptr`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_mut_ptr\n+[`mem::MaybeUninit`]: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\n+[`pointer::align_offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.align_offset\n+[`future::Future`]: https://doc.rust-lang.org/std/future/trait.Future.html\n+[`task::Context`]: https://doc.rust-lang.org/beta/std/task/struct.Context.html\n+[`task::RawWaker`]: https://doc.rust-lang.org/beta/std/task/struct.RawWaker.html\n+[`task::RawWakerVTable`]: https://doc.rust-lang.org/beta/std/task/struct.RawWakerVTable.html\n+[`task::Waker`]: https://doc.rust-lang.org/beta/std/task/struct.Waker.html\n+[`task::Poll`]: https://doc.rust-lang.org/beta/std/task/enum.Poll.html\n+[clippy-1-36-0]: https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-136\n+[cargo-1-36-0]: https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-136-2019-07-04\n+\n+\n Version 1.35.0 (2019-05-23)\n ==========================\n \n@@ -62,7 +281,7 @@ Cargo\n - [You can now set `cargo:rustc-cdylib-link-arg` at build time to pass custom\n   linker arguments when building a `cdylib`.][cargo/6298] Its usage is highly\n   platform specific.\n-  \n+\n Misc\n ----\n - [The Rust toolchain is now available natively for musl based distros.][58575]\n@@ -157,7 +376,7 @@ Libraries\n   produce a warning if their returning type is unused.\n - [The methods `checked_pow`, `saturating_pow`, `wrapping_pow`, and\n   `overflowing_pow` are now available for all numeric types.][57873] These are\n-  equivalvent to methods such as `wrapping_add` for the `pow` operation.\n+  equivalent to methods such as `wrapping_add` for the `pow` operation.\n \n \n Stabilized APIs\n@@ -208,9 +427,9 @@ Misc\n \n Compatibility Notes\n -------------------\n-- [`Command::before_exec` is now deprecated in favor of the\n-  unsafe method `Command::pre_exec`.][58059]\n-- [Use of `ATOMIC_{BOOL, ISIZE, USIZE}_INIT` is now deprecated.][57425] As you\n+- [`Command::before_exec` is being replaced by the unsafe method\n+  `Command::pre_exec`][58059] and will be deprecated with Rust 1.37.0.\n+- [Use of `ATOMIC_{BOOL, ISIZE, USIZE}_INIT` is now deprecated][57425] as you\n   can now use `const` functions in `static` variables.\n \n [58370]: https://github.com/rust-lang/rust/pull/58370/\n@@ -320,7 +539,7 @@ Compiler\n --------\n - [You can now set a linker flavor for `rustc` with the `-Clinker-flavor`\n   command line argument.][56351]\n-- [The mininum required LLVM version has been bumped to 6.0.][56642]\n+- [The minimum required LLVM version has been bumped to 6.0.][56642]\n - [Added support for the PowerPC64 architecture on FreeBSD.][57615]\n - [The `x86_64-fortanix-unknown-sgx` target support has been upgraded to\n   tier 2 support.][57130] Visit the [platform support][platform-support] page for\n@@ -751,7 +970,7 @@ Compiler\n \n Libraries\n ---------\n-- [You can now convert `num::NonZero*` types to their raw equivalvents using the\n+- [You can now convert `num::NonZero*` types to their raw equivalents using the\n   `From` trait.][54240] E.g. `u8` now implements `From<NonZeroU8>`.\n - [You can now convert a `&Option<T>` into `Option<&T>` and `&mut Option<T>`\n   into `Option<&mut T>` using the `From` trait.][53218]\n@@ -944,7 +1163,7 @@ Security Notes\n   caused by an integer overflow. This has been fixed by deterministically\n   panicking when an overflow happens.\n \n-  Thank you to Scott McMurray for responsibily disclosing this vulnerability to\n+  Thank you to Scott McMurray for responsibly disclosing this vulnerability to\n   us.\n \n \n@@ -1216,7 +1435,7 @@ Security Notes\n   given machine. This release fixes that vulnerability; you can read\n   more about this on the [blog][rustdoc-sec]. The associated CVE is [CVE-2018-1000622].\n \n-  Thank you to Red Hat for responsibily disclosing this vulnerability to us.\n+  Thank you to Red Hat for responsibly disclosing this vulnerability to us.\n \n Compatibility Notes\n -------------------"}, {"sha": "dffd79c56e48a70ac26addf789d553601069eed2", "filename": "appveyor.yml", "status": "removed", "additions": 0, "deletions": 275, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=963184bbb670c1ffa97fc28a98cd5e8473118859", "patch": "@@ -1,275 +0,0 @@\n-environment:\n-  # This is required for at least an AArch64 compiler in one image, and is also\n-  # going to soon be required for compiling LLVM.\n-  APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017 Preview\n-\n-  # By default schannel checks revocation of certificates unlike some other SSL\n-  # backends, but we've historically had problems on CI where a revocation\n-  # server goes down presumably. See #43333 for more info\n-  CARGO_HTTP_CHECK_REVOKE: false\n-\n-  matrix:\n-  # 32/64 bit MSVC tests\n-  - CI_JOB_NAME: x86_64-msvc\n-    MSYS_BITS: 64\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n-    SCRIPT: python x.py test\n-    # FIXME(#59637)\n-    NO_DEBUG_ASSERTIONS: 1\n-    NO_LLVM_ASSERTIONS: 1\n-  - CI_JOB_NAME: i686-msvc-1\n-    MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n-    SCRIPT: make appveyor-subset-1\n-  - CI_JOB_NAME: i686-msvc-2\n-    MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n-    SCRIPT: make appveyor-subset-2\n-\n-  # MSVC aux tests\n-  - CI_JOB_NAME: x86_64-msvc-aux\n-    MSYS_BITS: 64\n-    RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n-  - CI_JOB_NAME: x86_64-msvc-cargo\n-    MSYS_BITS: 64\n-    SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n-\n-  # MSVC tools tests\n-  - CI_JOB_NAME: x86_64-msvc-tools\n-    MSYS_BITS: 64\n-    SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json --enable-test-miri\n-\n-  # 32/64-bit MinGW builds.\n-  #\n-  # We are using MinGW with posix threads since LLVM does not compile with\n-  # the win32 threads version due to missing support for C++'s std::thread.\n-  #\n-  # Instead of relying on the MinGW version installed on appveryor we download\n-  # and install one ourselves so we won't be surprised by changes to appveyor's\n-  # build image.\n-  #\n-  # Finally, note that the downloads below are all in the `rust-lang-ci` S3\n-  # bucket, but they cleraly didn't originate there! The downloads originally\n-  # came from the mingw-w64 SourceForge download site. Unfortunately\n-  # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n-  - CI_JOB_NAME: i686-mingw-1\n-    MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    SCRIPT: make appveyor-subset-1\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n-    MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n-    MINGW_DIR: mingw32\n-    # FIXME(#59637)\n-    NO_DEBUG_ASSERTIONS: 1\n-    NO_LLVM_ASSERTIONS: 1\n-  - CI_JOB_NAME: i686-mingw-2\n-    MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    SCRIPT: make appveyor-subset-2\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n-    MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n-    MINGW_DIR: mingw32\n-  - CI_JOB_NAME: x86_64-mingw\n-    MSYS_BITS: 64\n-    SCRIPT: python x.py test\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n-    MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n-    MINGW_DIR: mingw64\n-    # FIXME(#59637)\n-    NO_DEBUG_ASSERTIONS: 1\n-    NO_LLVM_ASSERTIONS: 1\n-\n-  # 32/64 bit MSVC and GNU deployment\n-  - CI_JOB_NAME: dist-x86_64-msvc\n-    RUST_CONFIGURE_ARGS: >\n-      --build=x86_64-pc-windows-msvc\n-      --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n-      --enable-full-tools\n-      --enable-profiler\n-    SCRIPT: python x.py dist\n-    DIST_REQUIRE_ALL_TOOLS: 1\n-    DEPLOY: 1\n-  - CI_JOB_NAME: dist-i686-msvc\n-    RUST_CONFIGURE_ARGS: >\n-      --build=i686-pc-windows-msvc\n-      --target=i586-pc-windows-msvc\n-      --enable-full-tools\n-      --enable-profiler\n-    SCRIPT: python x.py dist\n-    DIST_REQUIRE_ALL_TOOLS: 1\n-    DEPLOY: 1\n-  - CI_JOB_NAME: dist-i686-mingw\n-    MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools\n-    SCRIPT: python x.py dist\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n-    MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n-    MINGW_DIR: mingw32\n-    DIST_REQUIRE_ALL_TOOLS: 1\n-    DEPLOY: 1\n-  - CI_JOB_NAME: dist-x86_64-mingw\n-    MSYS_BITS: 64\n-    SCRIPT: python x.py dist\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n-    MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n-    MINGW_DIR: mingw64\n-    DIST_REQUIRE_ALL_TOOLS: 1\n-    DEPLOY: 1\n-\n-  # \"alternate\" deployment, see .travis.yml for more info\n-  - CI_JOB_NAME: dist-x86_64-msvc-alt\n-    MSYS_BITS: 64\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n-    SCRIPT: python x.py dist\n-    DEPLOY_ALT: 1\n-\n-matrix:\n-  fast_finish: true\n-\n-clone_depth: 2\n-build: false\n-\n-install:\n-  # Print which AppVeyor agent version we're running on.\n-  - appveyor version\n-  # If we need to download a custom MinGW, do so here and set the path\n-  # appropriately.\n-  #\n-  # Note that this *also* means that we're not using what is typically\n-  # /mingw32/bin/python2.7.exe, which is a \"correct\" python interpreter where\n-  # /usr/bin/python2.7.exe is not. To ensure we use the right interpreter we\n-  # move `C:\\Python27` ahead in PATH and then also make sure the `python2.7.exe`\n-  # file exists in there (which it doesn't by default).\n-  - if defined MINGW_URL appveyor-retry appveyor DownloadFile %MINGW_URL%/%MINGW_ARCHIVE%\n-  - if defined MINGW_URL 7z x -y %MINGW_ARCHIVE% > nul\n-  - if defined MINGW_URL set PATH=%CD%\\%MINGW_DIR%\\bin;C:\\msys64\\usr\\bin;%PATH%\n-\n-  # If we're compiling for MSVC then we, like most other distribution builders,\n-  # switch to clang as the compiler. This'll allow us eventually to enable LTO\n-  # amongst LLVM and rustc. Note that we only do this on MSVC as I don't think\n-  # clang has an output mode compatible with MinGW that we need. If it does we\n-  # should switch to clang for MinGW as well!\n-  #\n-  # Note that the LLVM installer is an NSIS installer\n-  #\n-  # Original downloaded here came from\n-  # http://releases.llvm.org/8.0.0/LLVM-8.0.0-win64.exe\n-  - if NOT defined MINGW_URL appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/LLVM-8.0.0-win64.exe\n-  - if NOT defined MINGW_URL .\\LLVM-8.0.0-win64.exe /S /NCRC /D=C:\\clang-rust\n-  - if NOT defined MINGW_URL set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --set llvm.clang-cl=C:\\clang-rust\\bin\\clang-cl.exe\n-\n-  # Here we do a pretty heinous thing which is to mangle the MinGW installation\n-  # we just had above. Currently, as of this writing, we're using MinGW-w64\n-  # builds of gcc, and that's currently at 6.3.0. We use 6.3.0 as it appears to\n-  # be the first version which contains a fix for #40546, builds randomly\n-  # failing during LLVM due to ar.exe/ranlib.exe failures.\n-  #\n-  # Unfortunately, though, 6.3.0 *also* is the first version of MinGW-w64 builds\n-  # to contain a regression in gdb (#40184). As a result if we were to use the\n-  # gdb provided (7.11.1) then we would fail all debuginfo tests.\n-  #\n-  # In order to fix spurious failures (pretty high priority) we use 6.3.0. To\n-  # avoid disabling gdb tests we download an *old* version of gdb, specifically\n-  # that found inside the 6.2.0 distribution. We then overwrite the 6.3.0 gdb\n-  # with the 6.2.0 gdb to get tests passing.\n-  #\n-  # Note that we don't literally overwrite the gdb.exe binary because it appears\n-  # to just use gdborig.exe, so that's the binary we deal with instead.\n-  - if defined MINGW_URL appveyor-retry appveyor DownloadFile %MINGW_URL%/2017-04-20-%MSYS_BITS%bit-gdborig.exe\n-  - if defined MINGW_URL mv 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_DIR%\\bin\\gdborig.exe\n-\n-  # Otherwise pull in the MinGW installed on appveyor\n-  - if NOT defined MINGW_URL set PATH=C:\\msys64\\mingw%MSYS_BITS%\\bin;C:\\msys64\\usr\\bin;%PATH%\n-\n-  # Prefer the \"native\" Python as LLVM has trouble building with MSYS sometimes\n-  - copy C:\\Python27\\python.exe C:\\Python27\\python2.7.exe\n-  - set PATH=C:\\Python27;%PATH%\n-\n-  # Download and install sccache\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\n-  - mv 2018-04-26-sccache-x86_64-pc-windows-msvc sccache.exe\n-  - set PATH=%PATH%;%CD%\n-\n-  # Download and install ninja\n-  #\n-  # Note that this is originally from the github releases patch of Ninja\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-15-ninja-win.zip\n-  - 7z x 2017-03-15-ninja-win.zip\n-  - set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja\n-  # - set PATH=%PATH%;%CD% -- this already happens above for sccache\n-\n-  # Install InnoSetup to get `iscc` used to produce installers\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-08-22-is.exe\n-  - 2017-08-22-is.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n-  - set PATH=\"C:\\Program Files (x86)\\Inno Setup 5\";%PATH%\n-\n-  # Help debug some handle issues on AppVeyor\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-15-Handle.zip\n-  - mkdir handle\n-  - 7z x -ohandle 2017-05-15-Handle.zip\n-  - set PATH=%PATH%;%CD%\\handle\n-  - handle.exe -accepteula -help\n-\n-test_script:\n-  - if not exist C:\\cache\\rustsrc\\NUL mkdir C:\\cache\\rustsrc\n-  - sh src/ci/init_repo.sh . /c/cache/rustsrc\n-  - set SRC=.\n-  - set NO_CCACHE=1\n-  - sh src/ci/run.sh\n-\n-on_failure:\n-  # Dump crash log\n-  - set PATH=%PATH%;\"C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\X64\"\n-  - if exist %LOCALAPPDATA%\\CrashDumps for %%f in (%LOCALAPPDATA%\\CrashDumps\\*) do cdb -c \"k;q\" -G -z \"%%f\"\n-\n-branches:\n-  only:\n-    - auto\n-\n-before_deploy:\n-  - ps: |\n-        New-Item -Path deploy -ItemType directory\n-        Remove-Item -Recurse -Force build\\dist\\doc\n-        Get-ChildItem -Path build\\dist | Move-Item -Destination deploy\n-        Get-ChildItem -Path deploy | Foreach-Object {\n-          Push-AppveyorArtifact $_.FullName -FileName ${env:APPVEYOR_REPO_COMMIT}/$_\n-        }\n-\n-deploy:\n-  - provider: S3\n-    access_key_id: $(AWS_ACCESS_KEY_ID)\n-    secret_access_key: $(AWS_SECRET_ACCESS_KEY)\n-    bucket: rust-lang-ci2\n-    set_public: true\n-    region: us-west-1\n-    artifact: /.*/\n-    folder: rustc-builds\n-    on:\n-      branch: auto\n-      DEPLOY: 1\n-    max_error_retry: 5\n-\n-  # This provider is the same as the one above except that it has a slightly\n-  # different upload directory and a slightly different trigger\n-  - provider: S3\n-    access_key_id: $(AWS_ACCESS_KEY_ID)\n-    secret_access_key: $(AWS_SECRET_ACCESS_KEY)\n-    bucket: rust-lang-ci2\n-    set_public: true\n-    region: us-west-1\n-    artifact: /.*/\n-    folder: rustc-builds-alt\n-    on:\n-      branch: auto\n-      DEPLOY_ALT: 1\n-    max_error_retry: 5\n-\n-# init:\n-#   - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))\n-# on_finish:\n-#   - ps: $blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))"}, {"sha": "a3ec4f2044cbd720fe469e89d744d0294a6f42cd", "filename": "config.toml.example", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -57,14 +57,13 @@\n # support. You'll need to write a target specification at least, and most\n # likely, teach rustc about the C ABI of the target. Get in touch with the\n # Rust team and file an issue if you need assistance in porting!\n-#targets = \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;MSP430;Sparc;NVPTX;Hexagon\"\n+#targets = \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86\"\n \n # LLVM experimental targets to build support for. These targets are specified in\n # the same format as above, but since these targets are experimental, they are\n # not built by default and the experimental Rust compilation targets that depend\n-# on them will not work unless the user opts in to building them. By default the\n-# `WebAssembly` and `RISCV` targets are enabled when compiling LLVM from scratch.\n-#experimental-targets = \"WebAssembly;RISCV\"\n+# on them will not work unless the user opts in to building them.\n+#experimental-targets = \"\"\n \n # Cap the number of parallel linker invocations when compiling LLVM.\n # This can be useful when building LLVM with debug info, which significantly\n@@ -142,10 +141,10 @@\n # library and facade crates.\n #compiler-docs = false\n \n-# Indicate whether submodules are managed and updated automatically.\n+# Indicate whether git submodules are managed and updated automatically.\n #submodules = true\n \n-# Update submodules only when the checked out commit in the submodules differs\n+# Update git submodules only when the checked out commit in the submodules differs\n # from what is committed in the main rustc repo.\n #fast-submodules = true\n \n@@ -301,20 +300,27 @@\n # library.\n #debug-assertions = false\n \n-# Whether or not debuginfo is emitted\n-#debuginfo = false\n+# Debuginfo level for most of Rust code, corresponds to the `-C debuginfo=N` option of `rustc`.\n+# `0` - no debug info\n+# `1` - line tables only\n+# `2` - full debug info with variable and type information\n+# Can be overriden for specific subsets of Rust code (rustc, std or tools).\n+# Debuginfo for tests run with compiletest is not controlled by this option\n+# and needs to be enabled separately with `debuginfo-level-tests`.\n+#debuginfo-level = if debug { 2 } else { 0 }\n \n-# Whether or not line number debug information is emitted\n-#debuginfo-lines = false\n+# Debuginfo level for the compiler.\n+#debuginfo-level-rustc = debuginfo-level\n \n-# Whether or not to only build debuginfo for the standard library if enabled.\n-# If enabled, this will not compile the compiler with debuginfo, just the\n-# standard library.\n-#debuginfo-only-std = false\n+# Debuginfo level for the standard library.\n+#debuginfo-level-std = debuginfo-level\n \n-# Enable debuginfo for the extended tools: cargo, rls, rustfmt\n-# Adding debuginfo makes them several times larger.\n-#debuginfo-tools = false\n+# Debuginfo level for the tools.\n+#debuginfo-level-tools = debuginfo-level\n+\n+# Debuginfo level for the test suites run with compiletest.\n+# FIXME(#61117): Some tests fail when this option is enabled.\n+#debuginfo-level-tests = 0\n \n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n@@ -345,10 +351,8 @@\n # harness are debuggable just from logfiles.\n #verbose-tests = false\n \n-# Flag indicating whether tests are compiled with optimizations (the -O flag) or\n-# with debuginfo (the -g flag)\n+# Flag indicating whether tests are compiled with optimizations (the -O flag).\n #optimize-tests = true\n-#debuginfo-tests = true\n \n # Flag indicating whether codegen tests will be run or not. If you get an error\n # saying that the FileCheck executable is missing, you may want to disable this.\n@@ -364,10 +368,6 @@\n # When creating source tarballs whether or not to create a source tarball.\n #dist-src = false\n \n-# Whether to also run the Miri tests suite when running tests.\n-# As a side-effect also generates MIR for all libraries.\n-#test-miri = false\n-\n # After building or testing extended tools (e.g. clippy and rustfmt), append the\n # result (broken, compiling, testing) into this JSON file.\n #save-toolstates = \"/path/to/toolstates.json\""}, {"sha": "f1b36f5858037b7f12fadf37c070c68ff886af21", "filename": "src/.gitignore", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2F.gitignore?ref=963184bbb670c1ffa97fc28a98cd5e8473118859", "patch": "@@ -1,46 +0,0 @@\n-*.a\n-*.aux\n-*.bc\n-*.boot\n-*.bz2\n-*.cmi\n-*.cmo\n-*.cmx\n-*.cp\n-*.cps\n-*.d\n-*.dSYM\n-*.def\n-*.diff\n-*.dll\n-*.dylib\n-*.elc\n-*.epub\n-*.exe\n-*.fn\n-*.html\n-*.kdev4\n-*.ky\n-*.ll\n-*.llvm\n-*.log\n-*.o\n-*.orig\n-*.out\n-*.patch\n-*.pdb\n-*.pdf\n-*.pg\n-*.pot\n-*.pyc\n-*.rej\n-*.rlib\n-*.rustc\n-*.so\n-*.swo\n-*.swp\n-*.tmp\n-*.toc\n-*.tp\n-*.vr\n-*.x86"}, {"sha": "32ca4a105741b9f09754a40d2da21f5095fb056f", "filename": "src/README.md", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -5,10 +5,7 @@ This directory contains the source code of the rust project, including:\n \n For more information on how various parts of the compiler work, see the [rustc guide].\n \n-There is also useful content in the following READMEs, which are gradually being moved over to the guide:\n-- https://github.com/rust-lang/rust/tree/master/src/librustc/ty/query\n-- https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n-- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked\n-- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve\n+There is also useful content in this README:\n+https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve.\n \n [rustc guide]: https://rust-lang.github.io/rustc-guide/about-this-guide.html"}, {"sha": "3e877fc4e317c9e0affbea0b3f58b685d0b4bf06", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -55,11 +55,11 @@ The script accepts commands, flags, and arguments to determine what to do:\n   # run all unit tests\n   ./x.py test\n \n-  # execute the run-pass test suite\n-  ./x.py test src/test/run-pass\n+  # execute the UI test suite\n+  ./x.py test src/test/ui\n \n-  # execute only some tests in the run-pass test suite\n-  ./x.py test src/test/run-pass --test-args substring-of-test-name\n+  # execute only some tests in the UI test suite\n+  ./x.py test src/test/ui --test-args substring-of-test-name\n \n   # execute tests in the standard library in stage0\n   ./x.py test --stage 0 src/libstd\n@@ -215,7 +215,7 @@ build/\n \n     # Output for all compiletest-based test suites\n     test/\n-      run-pass/\n+      ui/\n       compile-fail/\n       debuginfo/\n       ..."}, {"sha": "bd1a87c5744d39d8c1a552a0925ff18a53b627d8", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -5,7 +5,8 @@\n //! parent directory, and otherwise documentation can be found throughout the `build`\n //! directory in each respective module.\n \n-#![deny(warnings)]\n+// NO-RUSTC-WRAPPER\n+#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n \n use std::env;\n "}, {"sha": "ce92ce026967117016ab27620dafaad86770e207", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 71, "deletions": 62, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -15,7 +15,8 @@\n //! switching compilers for the bootstrap and for build scripts will probably\n //! never get replaced.\n \n-#![deny(warnings)]\n+// NO-RUSTC-WRAPPER\n+#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n \n use std::env;\n use std::ffi::OsString;\n@@ -36,26 +37,14 @@ fn main() {\n             let mut new = None;\n             if let Some(current_as_str) = args[i].to_str() {\n                 if (&*args[i - 1] == \"-C\" && current_as_str.starts_with(\"metadata\")) ||\n-                   current_as_str.starts_with(\"-Cmetadata\") {\n+                    current_as_str.starts_with(\"-Cmetadata\") {\n                     new = Some(format!(\"{}-{}\", current_as_str, s));\n                 }\n             }\n             if let Some(new) = new { args[i] = new.into(); }\n         }\n     }\n \n-    // Drop `--error-format json` because despite our desire for json messages\n-    // from Cargo we don't want any from rustc itself.\n-    if let Some(n) = args.iter().position(|n| n == \"--error-format\") {\n-        args.remove(n);\n-        args.remove(n);\n-    }\n-\n-    if let Some(s) = env::var_os(\"RUSTC_ERROR_FORMAT\") {\n-        args.push(\"--error-format\".into());\n-        args.push(s);\n-    }\n-\n     // Detect whether or not we're a build script depending on whether --target\n     // is passed (a bit janky...)\n     let target = args.windows(2)\n@@ -89,11 +78,38 @@ fn main() {\n \n     let mut cmd = Command::new(rustc);\n     cmd.args(&args)\n-        .arg(\"--cfg\")\n-        .arg(format!(\"stage{}\", stage))\n         .env(bootstrap::util::dylib_path_var(),\n              env::join_paths(&dylib_path).unwrap());\n-    let mut maybe_crate = None;\n+\n+    // Get the name of the crate we're compiling, if any.\n+    let crate_name = args.windows(2)\n+        .find(|args| args[0] == \"--crate-name\")\n+        .and_then(|args| args[1].to_str());\n+\n+    if let Some(crate_name) = crate_name {\n+        if let Some(target) = env::var_os(\"RUSTC_TIME\") {\n+            if target == \"all\" ||\n+                target.into_string().unwrap().split(\",\").any(|c| c.trim() == crate_name)\n+            {\n+                cmd.arg(\"-Ztime\");\n+            }\n+        }\n+    }\n+\n+    // Non-zero stages must all be treated uniformly to avoid problems when attempting to uplift\n+    // compiler libraries and such from stage 1 to 2.\n+    //\n+    // FIXME: the fact that core here is excluded is due to core_arch from our stdarch submodule\n+    // being broken on the beta compiler with bootstrap passed, so this is a temporary workaround\n+    // (we've just snapped, so there are no cfg(bootstrap) related annotations in core).\n+    if stage == \"0\" {\n+        if crate_name != Some(\"core\") {\n+            cmd.arg(\"--cfg\").arg(\"bootstrap\");\n+        } else {\n+            // NOTE(eddyb) see FIXME above, except now we need annotations again in core.\n+            cmd.arg(\"--cfg\").arg(\"boostrap_stdarch_ignore_this\");\n+        }\n+    }\n \n     // Print backtrace in case of ICE\n     if env::var(\"RUSTC_BACKTRACE_ON_ICE\").is_ok() && env::var(\"RUST_BACKTRACE\").is_err() {\n@@ -102,10 +118,30 @@ fn main() {\n \n     cmd.env(\"RUSTC_BREAK_ON_ICE\", \"1\");\n \n+    if let Ok(debuginfo_level) = env::var(\"RUSTC_DEBUGINFO_LEVEL\") {\n+        cmd.arg(format!(\"-Cdebuginfo={}\", debuginfo_level));\n+    }\n+\n+    if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() &&\n+       env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none() {\n+        // When extending this list, search for `NO-RUSTC-WRAPPER` and add the new lints\n+        // there as well, some code doesn't go through this `rustc` wrapper.\n+        cmd.arg(\"-Dwarnings\");\n+        cmd.arg(\"-Drust_2018_idioms\");\n+        cmd.arg(\"-Dunused_lifetimes\");\n+        if use_internal_lints(crate_name) {\n+            cmd.arg(\"-Zunstable-options\");\n+            cmd.arg(\"-Drustc::internal\");\n+        }\n+    }\n+\n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n-        // actually downloaded, so we just always pass the `--sysroot` option.\n-        cmd.arg(\"--sysroot\").arg(&sysroot);\n+        // actually downloaded, so we just always pass the `--sysroot` option,\n+        // unless one is already set.\n+        if !args.iter().any(|arg| arg == \"--sysroot\") {\n+            cmd.arg(\"--sysroot\").arg(&sysroot);\n+        }\n \n         cmd.arg(\"-Zexternal-macro-backtrace\");\n \n@@ -144,12 +180,6 @@ fn main() {\n             cmd.arg(format!(\"-Clinker={}\", target_linker));\n         }\n \n-        let crate_name = args.windows(2)\n-            .find(|a| &*a[0] == \"--crate-name\")\n-            .unwrap();\n-        let crate_name = &*crate_name[1];\n-        maybe_crate = Some(crate_name);\n-\n         // If we're compiling specifically the `panic_abort` crate then we pass\n         // the `-C panic=abort` option. Note that we do not do this for any\n         // other crate intentionally as this is the only crate for now that we\n@@ -162,26 +192,21 @@ fn main() {\n         // `compiler_builtins` are unconditionally compiled with panic=abort to\n         // workaround undefined references to `rust_eh_unwind_resume` generated\n         // otherwise, see issue https://github.com/rust-lang/rust/issues/43095.\n-        if crate_name == \"panic_abort\" ||\n-           crate_name == \"compiler_builtins\" && stage != \"0\" {\n+        if crate_name == Some(\"panic_abort\") ||\n+           crate_name == Some(\"compiler_builtins\") && stage != \"0\" {\n             cmd.arg(\"-C\").arg(\"panic=abort\");\n         }\n \n         // Set various options from config.toml to configure how we're building\n         // code.\n-        if env::var(\"RUSTC_DEBUGINFO\") == Ok(\"true\".to_string()) {\n-            cmd.arg(\"-g\");\n-        } else if env::var(\"RUSTC_DEBUGINFO_LINES\") == Ok(\"true\".to_string()) {\n-            cmd.arg(\"-Cdebuginfo=1\");\n-        }\n         let debug_assertions = match env::var(\"RUSTC_DEBUG_ASSERTIONS\") {\n             Ok(s) => if s == \"true\" { \"y\" } else { \"n\" },\n             Err(..) => \"n\",\n         };\n \n         // The compiler builtins are pretty sensitive to symbols referenced in\n         // libcore and such, so we never compile them with debug assertions.\n-        if crate_name == \"compiler_builtins\" {\n+        if crate_name == Some(\"compiler_builtins\") {\n             cmd.arg(\"-C\").arg(\"debug-assertions=no\");\n         } else {\n             cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));\n@@ -256,24 +281,6 @@ fn main() {\n                 cmd.arg(\"-C\").arg(\"target-feature=-crt-static\");\n             }\n         }\n-\n-        // When running miri tests, we need to generate MIR for all libraries\n-        if env::var(\"TEST_MIRI\").ok().map_or(false, |val| val == \"true\") {\n-            // The flags here should be kept in sync with `add_miri_default_args`\n-            // in miri's `src/lib.rs`.\n-            cmd.arg(\"-Zalways-encode-mir\");\n-            cmd.arg(\"--cfg=miri\");\n-            // These options are preferred by miri, to be able to perform better validation,\n-            // but the bootstrap compiler might not understand them.\n-            if stage != \"0\" {\n-                cmd.arg(\"-Zmir-emit-retag\");\n-                cmd.arg(\"-Zmir-opt-level=0\");\n-            }\n-        }\n-\n-        if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n-            cmd.arg(\"--remap-path-prefix\").arg(&map);\n-        }\n     } else {\n         // Override linker if necessary.\n         if let Ok(host_linker) = env::var(\"RUSTC_HOST_LINKER\") {\n@@ -290,8 +297,9 @@ fn main() {\n         }\n     }\n \n-    // This is required for internal lints.\n-    cmd.arg(\"-Zunstable-options\");\n+    if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n+        cmd.arg(\"--remap-path-prefix\").arg(&map);\n+    }\n \n     // Force all crates compiled by this compiler to (a) be unstable and (b)\n     // allow the `rustc_private` feature to link to other unstable crates\n@@ -305,13 +313,6 @@ fn main() {\n         cmd.arg(\"--cfg\").arg(\"parallel_compiler\");\n     }\n \n-    if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() && env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none()\n-    {\n-        cmd.arg(\"-Dwarnings\");\n-        cmd.arg(\"-Dbare_trait_objects\");\n-        cmd.arg(\"-Drust_2018_idioms\");\n-    }\n-\n     if verbose > 1 {\n         eprintln!(\n             \"rustc command: {:?}={:?} {:?}\",\n@@ -334,7 +335,7 @@ fn main() {\n     }\n \n     if env::var_os(\"RUSTC_PRINT_STEP_TIMINGS\").is_some() {\n-        if let Some(krate) = maybe_crate {\n+        if let Some(crate_name) = crate_name {\n             let start = Instant::now();\n             let status = cmd\n                 .status()\n@@ -343,7 +344,7 @@ fn main() {\n \n             let is_test = args.iter().any(|a| a == \"--test\");\n             eprintln!(\"[RUSTC-TIMING] {} test:{} {}.{:03}\",\n-                      krate.to_string_lossy(),\n+                      crate_name,\n                       is_test,\n                       dur.as_secs(),\n                       dur.subsec_nanos() / 1_000_000);\n@@ -362,6 +363,14 @@ fn main() {\n     std::process::exit(code);\n }\n \n+// Rustc crates for which internal lints are in effect.\n+fn use_internal_lints(crate_name: Option<&str>) -> bool {\n+    crate_name.map_or(false, |crate_name| {\n+        crate_name.starts_with(\"rustc\") || crate_name.starts_with(\"syntax\") ||\n+        [\"arena\", \"fmt_macros\"].contains(&crate_name)\n+    })\n+}\n+\n #[cfg(unix)]\n fn exec_cmd(cmd: &mut Command) -> io::Result<i32> {\n     use std::os::unix::process::CommandExt;"}, {"sha": "ff38ee8788f5652c2c551ff3db1a120a89a27c2c", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -2,7 +2,8 @@\n //!\n //! See comments in `src/bootstrap/rustc.rs` for more information.\n \n-#![deny(warnings)]\n+// NO-RUSTC-WRAPPER\n+#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n \n use std::env;\n use std::process::Command;"}, {"sha": "86901792d79740f1467f53baeb4862f598aad9e3", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 43, "deletions": 24, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -735,6 +735,47 @@ def set_dev_environment(self):\n         \"\"\"Set download URL for development environment\"\"\"\n         self._download_url = 'https://dev-static.rust-lang.org'\n \n+    def check_vendored_status(self):\n+        \"\"\"Check that vendoring is configured properly\"\"\"\n+        vendor_dir = os.path.join(self.rust_root, 'vendor')\n+        if 'SUDO_USER' in os.environ and not self.use_vendored_sources:\n+            if os.environ.get('USER') != os.environ['SUDO_USER']:\n+                self.use_vendored_sources = True\n+                print('info: looks like you are running this command under `sudo`')\n+                print('      and so in order to preserve your $HOME this will now')\n+                print('      use vendored sources by default.')\n+                if not os.path.exists(vendor_dir):\n+                    print('error: vendoring required, but vendor directory does not exist.')\n+                    print('       Run `cargo vendor` without sudo to initialize the '\n+                        'vendor directory.')\n+                    raise Exception(\"{} not found\".format(vendor_dir))\n+\n+        if self.use_vendored_sources:\n+            if not os.path.exists('.cargo'):\n+                os.makedirs('.cargo')\n+            with output('.cargo/config') as cargo_config:\n+                cargo_config.write(\n+                    \"[source.crates-io]\\n\"\n+                    \"replace-with = 'vendored-sources'\\n\"\n+                    \"registry = 'https://example.com'\\n\"\n+                    \"\\n\"\n+                    \"[source.vendored-sources]\\n\"\n+                    \"directory = '{}/vendor'\\n\"\n+                .format(self.rust_root))\n+        else:\n+            if os.path.exists('.cargo'):\n+                shutil.rmtree('.cargo')\n+\n+    def ensure_vendored(self):\n+        \"\"\"Ensure that the vendored sources are available if needed\"\"\"\n+        vendor_dir = os.path.join(self.rust_root, 'vendor')\n+        # Note that this does not handle updating the vendored dependencies if\n+        # the rust git repository is updated. Normal development usually does\n+        # not use vendoring, so hopefully this isn't too much of a problem.\n+        if self.use_vendored_sources and not os.path.exists(vendor_dir):\n+            run([self.cargo(), \"vendor\"],\n+                verbose=self.verbose, cwd=self.rust_root)\n+\n \n def bootstrap(help_triggered):\n     \"\"\"Configure, fetch, build and run the initial bootstrap\"\"\"\n@@ -776,30 +817,7 @@ def bootstrap(help_triggered):\n \n     build.use_locked_deps = '\\nlocked-deps = true' in build.config_toml\n \n-    if 'SUDO_USER' in os.environ and not build.use_vendored_sources:\n-        if os.environ.get('USER') != os.environ['SUDO_USER']:\n-            build.use_vendored_sources = True\n-            print('info: looks like you are running this command under `sudo`')\n-            print('      and so in order to preserve your $HOME this will now')\n-            print('      use vendored sources by default. Note that if this')\n-            print('      does not work you should run a normal build first')\n-            print('      before running a command like `sudo ./x.py install`')\n-\n-    if build.use_vendored_sources:\n-        if not os.path.exists('.cargo'):\n-            os.makedirs('.cargo')\n-        with output('.cargo/config') as cargo_config:\n-            cargo_config.write(\"\"\"\n-                [source.crates-io]\n-                replace-with = 'vendored-sources'\n-                registry = 'https://example.com'\n-\n-                [source.vendored-sources]\n-                directory = '{}/vendor'\n-            \"\"\".format(build.rust_root))\n-    else:\n-        if os.path.exists('.cargo'):\n-            shutil.rmtree('.cargo')\n+    build.check_vendored_status()\n \n     data = stage0_data(build.rust_root)\n     build.date = data['date']\n@@ -815,6 +833,7 @@ def bootstrap(help_triggered):\n     build.build = args.build or build.build_triple()\n     build.download_stage0()\n     sys.stdout.flush()\n+    build.ensure_vendored()\n     build.build_bootstrap()\n     sys.stdout.flush()\n "}, {"sha": "f0054c36c0c886da0ea0f22d27c03c57cd56cccd", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 74, "deletions": 760, "changes": 834, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -59,7 +59,7 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n \n     const DEFAULT: bool = false;\n \n-    /// Run this rule for all hosts without cross compiling.\n+    /// If true, then this rule should be skipped if --target was specified, but --host was not\n     const ONLY_HOSTS: bool = false;\n \n     /// Primary function to execute this rule. Can call `builder.ensure()`\n@@ -145,7 +145,7 @@ impl StepDescription {\n             only_hosts: S::ONLY_HOSTS,\n             should_run: S::should_run,\n             make_run: S::make_run,\n-            name: unsafe { ::std::intrinsics::type_name::<S>() },\n+            name: std::any::type_name::<S>(),\n         }\n     }\n \n@@ -163,7 +163,7 @@ impl StepDescription {\n \n         // Determine the targets participating in this rule.\n         let targets = if self.only_hosts {\n-            if !builder.config.run_host_only {\n+            if builder.config.skip_only_host_steps {\n                 return; // don't run anything\n             } else {\n                 &builder.hosts\n@@ -318,6 +318,8 @@ impl<'a> ShouldRun<'a> {\n pub enum Kind {\n     Build,\n     Check,\n+    Clippy,\n+    Fix,\n     Test,\n     Bench,\n     Dist,\n@@ -359,7 +361,7 @@ impl<'a> Builder<'a> {\n                 tool::Miri,\n                 native::Lld\n             ),\n-            Kind::Check => describe!(\n+            Kind::Check | Kind::Clippy | Kind::Fix => describe!(\n                 check::Std,\n                 check::Test,\n                 check::Rustc,\n@@ -369,7 +371,6 @@ impl<'a> Builder<'a> {\n             Kind::Test => describe!(\n                 test::Tidy,\n                 test::Ui,\n-                test::RunPass,\n                 test::CompileFail,\n                 test::RunFail,\n                 test::RunPassValgrind,\n@@ -380,10 +381,8 @@ impl<'a> Builder<'a> {\n                 test::Incremental,\n                 test::Debuginfo,\n                 test::UiFullDeps,\n-                test::RunPassFullDeps,\n                 test::Rustdoc,\n                 test::Pretty,\n-                test::RunPassPretty,\n                 test::RunFailPretty,\n                 test::RunPassValgrindPretty,\n                 test::Crate,\n@@ -403,6 +402,7 @@ impl<'a> Builder<'a> {\n                 test::TheBook,\n                 test::UnstableBook,\n                 test::RustcBook,\n+                test::RustcGuide,\n                 test::EmbeddedBook,\n                 test::EditionGuide,\n                 test::Rustfmt,\n@@ -520,6 +520,8 @@ impl<'a> Builder<'a> {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n+            Subcommand::Clippy { ref paths } => (Kind::Clippy, &paths[..]),\n+            Subcommand::Fix { ref paths } => (Kind::Fix, &paths[..]),\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n@@ -541,15 +543,6 @@ impl<'a> Builder<'a> {\n             parent: Cell::new(None),\n         };\n \n-        if kind == Kind::Dist {\n-            assert!(\n-                !builder.config.test_miri,\n-                \"Do not distribute with miri enabled.\\n\\\n-                The distributed libraries would include all MIR (increasing binary size).\n-                The distributed MIR would include validation statements.\"\n-            );\n-        }\n-\n         builder\n     }\n \n@@ -577,6 +570,30 @@ impl<'a> Builder<'a> {\n         })\n     }\n \n+    /// Similar to `compiler`, except handles the full-bootstrap option to\n+    /// silently use the stage1 compiler instead of a stage2 compiler if one is\n+    /// requested.\n+    ///\n+    /// Note that this does *not* have the side effect of creating\n+    /// `compiler(stage, host)`, unlike `compiler` above which does have such\n+    /// a side effect. The returned compiler here can only be used to compile\n+    /// new artifacts, it can't be used to rely on the presence of a particular\n+    /// sysroot.\n+    ///\n+    /// See `force_use_stage1` for documentation on what each argument is.\n+    pub fn compiler_for(\n+        &self,\n+        stage: u32,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) -> Compiler {\n+        if self.build.force_use_stage1(Compiler { stage, host }, target) {\n+            self.compiler(1, self.config.build)\n+        } else {\n+            self.compiler(stage, host)\n+        }\n+    }\n+\n     pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n         self.ensure(compile::Sysroot { compiler })\n     }\n@@ -737,80 +754,20 @@ impl<'a> Builder<'a> {\n         let mut cargo = Command::new(&self.initial_cargo);\n         let out_dir = self.stage_out(compiler, mode);\n \n-        // command specific path, we call clear_if_dirty with this\n-        let mut my_out = match cmd {\n-            \"build\" => self.cargo_out(compiler, mode, target),\n-\n-            // This is the intended out directory for crate documentation.\n-            \"doc\" | \"rustdoc\" =>  self.crate_doc_out(target),\n-\n-            _ => self.stage_out(compiler, mode),\n-        };\n-\n-        // This is for the original compiler, but if we're forced to use stage 1, then\n-        // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n-        // we copy the libs forward.\n-        let cmp = if self.force_use_stage1(compiler, target) {\n-            self.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n-\n-        let libstd_stamp = match cmd {\n-            \"check\" => check::libstd_stamp(self, cmp, target),\n-            _ => compile::libstd_stamp(self, cmp, target),\n-        };\n-\n-        let libtest_stamp = match cmd {\n-            \"check\" => check::libtest_stamp(self, cmp, target),\n-            _ => compile::libstd_stamp(self, cmp, target),\n-        };\n-\n-        let librustc_stamp = match cmd {\n-            \"check\" => check::librustc_stamp(self, cmp, target),\n-            _ => compile::librustc_stamp(self, cmp, target),\n-        };\n+        // Codegen backends are not yet tracked by -Zbinary-dep-depinfo,\n+        // so we need to explicitly clear out if they've been updated.\n+        for backend in self.codegen_backends(compiler) {\n+            self.clear_if_dirty(&out_dir, &backend);\n+        }\n \n         if cmd == \"doc\" || cmd == \"rustdoc\" {\n-            if mode == Mode::Rustc || mode == Mode::ToolRustc || mode == Mode::Codegen {\n+            let my_out = match mode {\n                 // This is the intended out directory for compiler documentation.\n-                my_out = self.compiler_doc_out(target);\n-            }\n+                Mode::Rustc | Mode::ToolRustc | Mode::Codegen => self.compiler_doc_out(target),\n+                _ => self.crate_doc_out(target),\n+            };\n             let rustdoc = self.rustdoc(compiler);\n             self.clear_if_dirty(&my_out, &rustdoc);\n-        } else if cmd != \"test\" {\n-            match mode {\n-                Mode::Std => {\n-                    self.clear_if_dirty(&my_out, &self.rustc(compiler));\n-                    for backend in self.codegen_backends(compiler) {\n-                        self.clear_if_dirty(&my_out, &backend);\n-                    }\n-                },\n-                Mode::Test => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                },\n-                Mode::Rustc => {\n-                    self.clear_if_dirty(&my_out, &self.rustc(compiler));\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                },\n-                Mode::Codegen => {\n-                    self.clear_if_dirty(&my_out, &librustc_stamp);\n-                },\n-                Mode::ToolBootstrap => { },\n-                Mode::ToolStd => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                },\n-                Mode::ToolTest => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                },\n-                Mode::ToolRustc => {\n-                    self.clear_if_dirty(&my_out, &libstd_stamp);\n-                    self.clear_if_dirty(&my_out, &libtest_stamp);\n-                    self.clear_if_dirty(&my_out, &librustc_stamp);\n-                },\n-            }\n         }\n \n         cargo\n@@ -831,9 +788,9 @@ impl<'a> Builder<'a> {\n             assert_eq!(target, compiler.host);\n         }\n \n-        // Set a flag for `check` so that certain build scripts can do less work\n-        // (e.g., not building/requiring LLVM).\n-        if cmd == \"check\" {\n+        // Set a flag for `check`/`clippy`/`fix`, so that certain build\n+        // scripts can do less work (e.g. not building/requiring LLVM).\n+        if cmd == \"check\" || cmd == \"clippy\" || cmd == \"fix\" {\n             cargo.env(\"RUST_CHECK\", \"1\");\n         }\n \n@@ -848,6 +805,19 @@ impl<'a> Builder<'a> {\n             },\n         }\n \n+        // This tells Cargo (and in turn, rustc) to output more complete\n+        // dependency information.  Most importantly for rustbuild, this\n+        // includes sysroot artifacts, like libstd, which means that we don't\n+        // need to track those in rustbuild (an error prone process!). This\n+        // feature is currently unstable as there may be some bugs and such, but\n+        // it represents a big improvement in rustbuild's reliability on\n+        // rebuilds, so we're using it here.\n+        //\n+        // For some additional context, see #63470 (the PR originally adding\n+        // this), as well as #63012 which is the tracking issue for this\n+        // feature on the rustc side.\n+        cargo.arg(\"-Zbinary-dep-depinfo\");\n+\n         cargo.arg(\"-j\").arg(self.jobs().to_string());\n         // Remove make-related flags to ensure Cargo can correctly set things up\n         cargo.env_remove(\"MAKEFLAGS\");\n@@ -898,6 +868,11 @@ impl<'a> Builder<'a> {\n             extra_args.push_str(&s);\n         }\n \n+        if cmd == \"clippy\" {\n+            extra_args.push_str(\"-Zforce-unstable-if-unmarked -Zunstable-options \\\n+                --json-rendered=termcolor\");\n+        }\n+\n         if !extra_args.is_empty() {\n             cargo.env(\n                 \"RUSTFLAGS\",\n@@ -954,7 +929,6 @@ impl<'a> Builder<'a> {\n                     PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n                 },\n             )\n-            .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n             .env(\"RUSTC_ERROR_METADATA_DST\", self.extended_error_dir());\n \n         if let Some(host_linker) = self.linker(compiler.host) {\n@@ -963,29 +937,19 @@ impl<'a> Builder<'a> {\n         if let Some(target_linker) = self.linker(target) {\n             cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n         }\n-        if let Some(ref error_format) = self.config.rustc_error_format {\n-            cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n-        }\n-        if cmd != \"build\" && cmd != \"check\" && cmd != \"rustc\" && want_rustdoc {\n+        if !([\"build\", \"check\", \"clippy\", \"fix\", \"rustc\"].contains(&cmd)) && want_rustdoc {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n-        if mode.is_tool() {\n-            // Tools like cargo and rls don't get debuginfo by default right now, but this can be\n-            // enabled in the config.  Adding debuginfo makes them several times larger.\n-            if self.config.rust_debuginfo_tools {\n-                cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string());\n-                cargo.env(\n-                    \"RUSTC_DEBUGINFO_LINES\",\n-                    self.config.rust_debuginfo_lines.to_string(),\n-                );\n-            }\n-        } else {\n-            cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string());\n-            cargo.env(\n-                \"RUSTC_DEBUGINFO_LINES\",\n-                self.config.rust_debuginfo_lines.to_string(),\n-            );\n+        let debuginfo_level = match mode {\n+            Mode::Rustc | Mode::Codegen => self.config.rust_debuginfo_level_rustc,\n+            Mode::Std | Mode::Test => self.config.rust_debuginfo_level_std,\n+            Mode::ToolBootstrap | Mode::ToolStd |\n+            Mode::ToolTest | Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n+        };\n+        cargo.env(\"RUSTC_DEBUGINFO_LEVEL\", debuginfo_level.to_string());\n+\n+        if !mode.is_tool() {\n             cargo.env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n \n             // Currently the compiler depends on crates from crates.io, and\n@@ -1305,654 +1269,4 @@ impl<'a> Builder<'a> {\n }\n \n #[cfg(test)]\n-mod __test {\n-    use super::*;\n-    use crate::config::Config;\n-    use std::thread;\n-\n-    use pretty_assertions::assert_eq;\n-\n-    fn configure(host: &[&str], target: &[&str]) -> Config {\n-        let mut config = Config::default_opts();\n-        // don't save toolstates\n-        config.save_toolstates = None;\n-        config.run_host_only = true;\n-        config.dry_run = true;\n-        // try to avoid spurious failures in dist where we create/delete each others file\n-        let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n-            &thread::current()\n-                .name()\n-                .unwrap_or(\"unknown\")\n-                .replace(\":\", \"-\"),\n-        );\n-        t!(fs::create_dir_all(&dir));\n-        config.out = dir;\n-        config.build = INTERNER.intern_str(\"A\");\n-        config.hosts = vec![config.build]\n-            .clone()\n-            .into_iter()\n-            .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n-            .collect::<Vec<_>>();\n-        config.targets = config\n-            .hosts\n-            .clone()\n-            .into_iter()\n-            .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n-            .collect::<Vec<_>>();\n-        config\n-    }\n-\n-    fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n-        v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n-    }\n-\n-    #[test]\n-    fn dist_baseline() {\n-        let build = Build::new(configure(&[], &[]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[dist::Docs { stage: 2, host: a },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_targets() {\n-        let build = Build::new(configure(&[], &[\"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-                dist::Docs { stage: 2, host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[\n-                dist::Mingw { host: a },\n-                dist::Mingw { host: b },\n-                dist::Mingw { host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_target_flag() {\n-        let mut config = configure(&[\"B\"], &[\"C\"]);\n-        config.run_host_only = false; // as-if --target=C was passed\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-                dist::Docs { stage: 2, host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[\n-                dist::Mingw { host: a },\n-                dist::Mingw { host: b },\n-                dist::Mingw { host: c },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n-    }\n-\n-    #[test]\n-    fn dist_with_same_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n-            &[\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n-            &[\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 0 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 1 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 2 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 2 },\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn build_default() {\n-        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert!(!builder.cache.all::<compile::Std>().is_empty());\n-        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn build_with_target_flag() {\n-        let mut config = configure(&[\"B\"], &[\"C\"]);\n-        config.run_host_only = false;\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert!(!builder.cache.all::<compile::Std>().is_empty());\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n-            &[\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 0 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 1 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 1 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 2 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 2 },\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_with_no_doc_stage0() {\n-        let mut config = configure(&[], &[]);\n-        config.stage = Some(0);\n-        config.cmd = Subcommand::Test {\n-            paths: vec![\"src/libstd\".into()],\n-            test_args: vec![],\n-            rustc_args: vec![],\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n-            bless: false,\n-            compare_mode: None,\n-            rustfix_coverage: false,\n-        };\n-\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-\n-        let host = INTERNER.intern_str(\"A\");\n-\n-        builder.run_step_descriptions(\n-            &[StepDescription::from::<test::Crate>()],\n-            &[\"src/libstd\".into()],\n-        );\n-\n-        // Ensure we don't build any compiler artifacts.\n-        assert!(!builder.cache.contains::<compile::Rustc>());\n-        assert_eq!(\n-            first(builder.cache.all::<test::Crate>()),\n-            &[test::Crate {\n-                compiler: Compiler { host, stage: 0 },\n-                target: host,\n-                mode: Mode::Std,\n-                test_kind: test::TestKind::Test,\n-                krate: INTERNER.intern_str(\"std\"),\n-            },]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_exclude() {\n-        let mut config = configure(&[], &[]);\n-        config.exclude = vec![\n-            \"src/test/run-pass\".into(),\n-            \"src/tools/tidy\".into(),\n-        ];\n-        config.cmd = Subcommand::Test {\n-            paths: Vec::new(),\n-            test_args: Vec::new(),\n-            rustc_args: Vec::new(),\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n-            bless: false,\n-            compare_mode: None,\n-            rustfix_coverage: false,\n-        };\n-\n-        let build = Build::new(config);\n-        let builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-\n-        // Ensure we have really excluded run-pass & tidy\n-        assert!(!builder.cache.contains::<test::RunPass>());\n-        assert!(!builder.cache.contains::<test::Tidy>());\n-\n-        // Ensure other tests are not affected.\n-        assert!(builder.cache.contains::<test::RunPassFullDeps>());\n-        assert!(builder.cache.contains::<test::RustdocUi>());\n-    }\n-}\n+mod tests;"}, {"sha": "d1542b1fca6b7b6278a967e62685a4a65f10bdc8", "filename": "src/bootstrap/builder/tests.rs", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,655 @@\n+use super::*;\n+use crate::config::Config;\n+use std::thread;\n+\n+use pretty_assertions::assert_eq;\n+\n+fn configure(host: &[&str], target: &[&str]) -> Config {\n+    let mut config = Config::default_opts();\n+    // don't save toolstates\n+    config.save_toolstates = None;\n+    config.skip_only_host_steps = false;\n+    config.dry_run = true;\n+    // try to avoid spurious failures in dist where we create/delete each others file\n+    let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n+        &thread::current()\n+            .name()\n+            .unwrap_or(\"unknown\")\n+            .replace(\":\", \"-\"),\n+    );\n+    t!(fs::create_dir_all(&dir));\n+    config.out = dir;\n+    config.build = INTERNER.intern_str(\"A\");\n+    config.hosts = vec![config.build]\n+        .clone()\n+        .into_iter()\n+        .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n+        .collect::<Vec<_>>();\n+    config.targets = config\n+        .hosts\n+        .clone()\n+        .into_iter()\n+        .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n+        .collect::<Vec<_>>();\n+    config\n+}\n+\n+fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n+    v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n+}\n+\n+#[test]\n+fn dist_baseline() {\n+    let build = Build::new(configure(&[], &[]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[dist::Docs { host: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[dist::Rustc {\n+            compiler: Compiler { host: a, stage: 2 }\n+        },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[dist::Std {\n+            compiler: Compiler { host: a, stage: 1 },\n+            target: a,\n+        },]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_targets() {\n+    let build = Build::new(configure(&[], &[\"B\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[dist::Rustc {\n+            compiler: Compiler { host: a, stage: 2 }\n+        },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_only_cross_host() {\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let mut build = Build::new(configure(&[\"B\"], &[]));\n+    build.config.docs = false;\n+    build.config.extended = true;\n+    build.hosts = vec![b];\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn dist_with_targets_and_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+            dist::Docs { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true; // as-if --target=C was passed\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+            dist::Docs { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n+}\n+\n+#[test]\n+fn dist_with_same_targets_and_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Std>()),\n+        &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Assemble>()),\n+        &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn build_default() {\n+    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+        ]\n+    );\n+\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn build_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true;\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Assemble>()),\n+        &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn test_with_no_doc_stage0() {\n+    let mut config = configure(&[], &[]);\n+    config.stage = Some(0);\n+    config.cmd = Subcommand::Test {\n+        paths: vec![\"src/libstd\".into()],\n+        test_args: vec![],\n+        rustc_args: vec![],\n+        fail_fast: true,\n+        doc_tests: DocTests::No,\n+        bless: false,\n+        compare_mode: None,\n+        rustfix_coverage: false,\n+        pass: None,\n+    };\n+\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+\n+    let host = INTERNER.intern_str(\"A\");\n+\n+    builder.run_step_descriptions(\n+        &[StepDescription::from::<test::Crate>()],\n+        &[\"src/libstd\".into()],\n+    );\n+\n+    // Ensure we don't build any compiler artifacts.\n+    assert!(!builder.cache.contains::<compile::Rustc>());\n+    assert_eq!(\n+        first(builder.cache.all::<test::Crate>()),\n+        &[test::Crate {\n+            compiler: Compiler { host, stage: 0 },\n+            target: host,\n+            mode: Mode::Std,\n+            test_kind: test::TestKind::Test,\n+            krate: INTERNER.intern_str(\"std\"),\n+        },]\n+    );\n+}\n+\n+#[test]\n+fn test_exclude() {\n+    let mut config = configure(&[], &[]);\n+    config.exclude = vec![\n+        \"src/tools/tidy\".into(),\n+    ];\n+    config.cmd = Subcommand::Test {\n+        paths: Vec::new(),\n+        test_args: Vec::new(),\n+        rustc_args: Vec::new(),\n+        fail_fast: true,\n+        doc_tests: DocTests::No,\n+        bless: false,\n+        compare_mode: None,\n+        rustfix_coverage: false,\n+        pass: None,\n+    };\n+\n+    let build = Build::new(config);\n+    let builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+\n+    // Ensure we have really excluded tidy\n+    assert!(!builder.cache.contains::<test::Tidy>());\n+\n+    // Ensure other tests are not affected.\n+    assert!(builder.cache.contains::<test::RustdocUi>());\n+}"}, {"sha": "53071df855297e30f17598f8dd03d159f412a151", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -266,8 +266,10 @@ impl Cache {\n                         .expect(\"invalid type mapped\");\n         stepcache.get(step).cloned()\n     }\n+}\n \n-    #[cfg(test)]\n+#[cfg(test)]\n+impl Cache {\n     pub fn all<S: Ord + Copy + Step>(&mut self) -> Vec<(S, S::Output)> {\n         let cache = self.0.get_mut();\n         let type_id = TypeId::of::<S>();\n@@ -279,7 +281,6 @@ impl Cache {\n         v\n     }\n \n-    #[cfg(test)]\n     pub fn contains<S: Step>(&self) -> bool {\n         self.0.borrow().contains_key(&TypeId::of::<S>())\n     }"}, {"sha": "a4cb81d3d1b1b02716417c3c26752f7284b3a2f5", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -45,6 +45,8 @@ fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n         Some(PathBuf::from(\"ar\"))\n     } else if target.contains(\"openbsd\") {\n         Some(PathBuf::from(\"ar\"))\n+    } else if target.contains(\"vxworks\") {\n+        Some(PathBuf::from(\"wr-ar\"))\n     } else {\n         let parent = cc.parent().unwrap();\n         let file = cc.file_name().unwrap().to_str().unwrap();\n@@ -95,29 +97,39 @@ pub fn find(build: &mut Build) {\n         };\n \n         build.cc.insert(target, compiler);\n-        build.verbose(&format!(\"CC_{} = {:?}\", &target, build.cc(target)));\n-        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target, build.cflags(target, GitRepo::Rustc)));\n-        if let Some(ar) = ar {\n-            build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n-            build.ar.insert(target, ar);\n-        }\n-    }\n+        let cflags = build.cflags(target, GitRepo::Rustc);\n \n-    // For all host triples we need to find a C++ compiler as well\n-    let hosts = build.hosts.iter().cloned().chain(iter::once(build.build)).collect::<HashSet<_>>();\n-    for host in hosts.into_iter() {\n+        // If we use llvm-libunwind, we will need a C++ compiler as well for all targets\n+        // We'll need one anyways if the target triple is also a host triple\n         let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(2).warnings(false).debug(false).cpp(true)\n-           .target(&host).host(&build.build);\n-        let config = build.config.target_config.get(&host);\n-        if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n+            .target(&target).host(&build.build);\n+\n+        let cxx_configured = if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n+            true\n+        } else if build.hosts.contains(&target) || build.build == target {\n+            set_compiler(&mut cfg, Language::CPlusPlus, target, config, build);\n+            true\n         } else {\n-            set_compiler(&mut cfg, Language::CPlusPlus, host, config, build);\n+            false\n+        };\n+\n+        if cxx_configured {\n+            let compiler = cfg.get_compiler();\n+            build.cxx.insert(target, compiler);\n+        }\n+\n+        build.verbose(&format!(\"CC_{} = {:?}\", &target, build.cc(target)));\n+        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target, cflags));\n+        if let Ok(cxx) = build.cxx(target) {\n+            build.verbose(&format!(\"CXX_{} = {:?}\", &target, cxx));\n+            build.verbose(&format!(\"CXXFLAGS_{} = {:?}\", &target, cflags));\n+        }\n+        if let Some(ar) = ar {\n+            build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n+            build.ar.insert(target, ar);\n         }\n-        let compiler = cfg.get_compiler();\n-        build.verbose(&format!(\"CXX_{} = {:?}\", host, compiler.path()));\n-        build.cxx.insert(host, compiler);\n     }\n }\n "}, {"sha": "caa4843da4d369a1230c5be822be02329a889475", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -13,7 +13,7 @@ use build_helper::output;\n use crate::Build;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.36.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.39.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,"}, {"sha": "6e6fea6b831a7507f3835fa21c3032d6f9459b71", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,8 +1,8 @@\n-//! Implementation of compiling the compiler and standard library, in \"check\" mode.\n+//! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n use crate::compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env,\n                      add_to_sysroot};\n-use crate::builder::{RunConfig, Builder, ShouldRun, Step};\n+use crate::builder::{RunConfig, Builder, Kind, ShouldRun, Step};\n use crate::tool::{prepare_tool_cargo, SourceType};\n use crate::{Compiler, Mode};\n use crate::cache::{INTERNER, Interned};\n@@ -13,6 +13,22 @@ pub struct Std {\n     pub target: Interned<String>,\n }\n \n+fn args(kind: Kind) -> Vec<String> {\n+    match kind {\n+        Kind::Clippy => vec![\"--\".to_owned(), \"--cap-lints\".to_owned(), \"warn\".to_owned()],\n+        _ => Vec::new()\n+    }\n+}\n+\n+fn cargo_subcommand(kind: Kind) -> &'static str {\n+    match kind {\n+        Kind::Check => \"check\",\n+        Kind::Clippy => \"clippy\",\n+        Kind::Fix => \"fix\",\n+        _ => unreachable!()\n+    }\n+}\n+\n impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n@@ -31,13 +47,13 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = builder.compiler(0, builder.config.build);\n \n-        let mut cargo = builder.cargo(compiler, Mode::Std, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Std, target, cargo_subcommand(builder.kind));\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n         builder.info(&format!(\"Checking std artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  args(builder.kind),\n                   &libstd_stamp(builder, compiler, target),\n                   true);\n \n@@ -78,13 +94,14 @@ impl Step for Rustc {\n \n         builder.ensure(Test { target });\n \n-        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, target,\n+            cargo_subcommand(builder.kind));\n         rustc_cargo(builder, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n         builder.info(&format!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  args(builder.kind),\n                   &librustc_stamp(builder, compiler, target),\n                   true);\n \n@@ -127,15 +144,16 @@ impl Step for CodegenBackend {\n \n         builder.ensure(Rustc { target });\n \n-        let mut cargo = builder.cargo(compiler, Mode::Codegen, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Codegen, target,\n+            cargo_subcommand(builder.kind));\n         cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/librustc_codegen_llvm/Cargo.toml\"));\n         rustc_cargo_env(builder, &mut cargo);\n \n         // We won't build LLVM if it's not available, as it shouldn't affect `check`.\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n         run_cargo(builder,\n                   &mut cargo,\n+                  args(builder.kind),\n                   &codegen_backend_stamp(builder, compiler, target, backend),\n                   true);\n     }\n@@ -166,13 +184,13 @@ impl Step for Test {\n \n         builder.ensure(Std { target });\n \n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Test, target, cargo_subcommand(builder.kind));\n         test_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         builder.info(&format!(\"Checking test artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  args(builder.kind),\n                   &libtest_stamp(builder, compiler, target),\n                   true);\n \n@@ -212,22 +230,21 @@ impl Step for Rustdoc {\n                                            compiler,\n                                            Mode::ToolRustc,\n                                            target,\n-                                           \"check\",\n+                                           cargo_subcommand(builder.kind),\n                                            \"src/tools/rustdoc\",\n                                            SourceType::InTree,\n                                            &[]);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustdoc\", compiler.stage));\n         println!(\"Checking rustdoc artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(builder,\n                   &mut cargo,\n+                  args(builder.kind),\n                   &rustdoc_stamp(builder, compiler, target),\n                   true);\n \n         let libdir = builder.sysroot_libdir(compiler, target);\n         let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n         add_to_sysroot(&builder, &libdir, &hostdir, &rustdoc_stamp(builder, compiler, target));\n-        builder.cargo(compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }\n "}, {"sha": "96987d081594f019bfe6350da04d338014777f25", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 73, "deletions": 65, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -15,7 +15,7 @@ use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio, exit};\n use std::str;\n \n-use build_helper::{output, mtime, t, up_to_date};\n+use build_helper::{output, t, up_to_date};\n use filetime::FileTime;\n use serde::Deserialize;\n use serde_json;\n@@ -70,20 +70,20 @@ impl Step for Std {\n \n         builder.ensure(StartupObjects { compiler, target });\n \n-        if builder.force_use_stage1(compiler, target) {\n-            let from = builder.compiler(1, builder.config.build);\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Std {\n-                compiler: from,\n+                compiler: compiler_to_use,\n                 target,\n             });\n-            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", from.host, target));\n+            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", compiler_to_use.host, target));\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n             copy_third_party_objects(builder, &compiler, target);\n \n             builder.ensure(StdLink {\n-                compiler: from,\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -95,11 +95,11 @@ impl Step for Std {\n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n         builder.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  vec![],\n                   &libstd_stamp(builder, compiler, target),\n                   false);\n \n@@ -161,7 +161,33 @@ pub fn std_cargo(builder: &Builder<'_>,\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n \n+    // Determine if we're going to compile in optimized C intrinsics to\n+    // the `compiler-builtins` crate. These intrinsics live in LLVM's\n+    // `compiler-rt` repository, but our `src/llvm-project` submodule isn't\n+    // always checked out, so we need to conditionally look for this. (e.g. if\n+    // an external LLVM is used we skip the LLVM submodule checkout).\n+    //\n+    // Note that this shouldn't affect the correctness of `compiler-builtins`,\n+    // but only its speed. Some intrinsics in C haven't been translated to Rust\n+    // yet but that's pretty rare. Other intrinsics have optimized\n+    // implementations in C which have only had slower versions ported to Rust,\n+    // so we favor the C version where we can, but it's not critical.\n+    //\n+    // If `compiler-rt` is available ensure that the `c` feature of the\n+    // `compiler-builtins` crate is enabled and it's configured to learn where\n+    // `compiler-rt` is located.\n+    let compiler_builtins_root = builder.src.join(\"src/llvm-project/compiler-rt\");\n+    let compiler_builtins_c_feature = if compiler_builtins_root.exists() {\n+        cargo.env(\"RUST_COMPILER_RT_ROOT\", &compiler_builtins_root);\n+        \" compiler-builtins-c\".to_string()\n+    } else {\n+        String::new()\n+    };\n+\n     if builder.no_std(target) == Some(true) {\n+        let mut features = \"compiler-builtins-mem\".to_string();\n+        features.push_str(&compiler_builtins_c_feature);\n+\n         // for no-std targets we only compile a few no_std crates\n         cargo\n             .args(&[\"-p\", \"alloc\"])\n@@ -170,7 +196,8 @@ pub fn std_cargo(builder: &Builder<'_>,\n             .arg(\"--features\")\n             .arg(\"compiler-builtins-mem compiler-builtins-c\");\n     } else {\n-        let features = builder.std_features();\n+        let mut features = builder.std_features();\n+        features.push_str(&compiler_builtins_c_feature);\n \n         if compiler.stage != 0 && builder.config.sanitizers {\n             // This variable is used by the sanitizer runtime crates, e.g.\n@@ -247,8 +274,6 @@ impl Step for StdLink {\n             // for reason why the sanitizers are not built in stage0.\n             copy_apple_sanitizer_dylibs(builder, &builder.native_dir(target), \"osx\", &libdir);\n         }\n-\n-        builder.cargo(target_compiler, Mode::ToolStd, target, \"clean\");\n     }\n }\n \n@@ -298,7 +323,7 @@ impl Step for StartupObjects {\n     fn run(self, builder: &Builder<'_>) {\n         let for_compiler = self.compiler;\n         let target = self.target;\n-        if !target.contains(\"pc-windows-gnu\") {\n+        if !target.contains(\"windows-gnu\") {\n             return\n         }\n \n@@ -313,7 +338,7 @@ impl Step for StartupObjects {\n             if !up_to_date(src_file, dst_file) {\n                 let mut cmd = Command::new(&builder.initial_rustc);\n                 builder.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n-                            .arg(\"--cfg\").arg(\"stage0\")\n+                            .arg(\"--cfg\").arg(\"bootstrap\")\n                             .arg(\"--target\").arg(target)\n                             .arg(\"--emit=obj\")\n                             .arg(\"-o\").arg(dst_file)\n@@ -375,15 +400,16 @@ impl Step for Test {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Test {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n             });\n             builder.info(\n                 &format!(\"Uplifting stage1 test ({} -> {})\", builder.config.build, target));\n             builder.ensure(TestLink {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -393,11 +419,11 @@ impl Step for Test {\n         let mut cargo = builder.cargo(compiler, Mode::Test, target, \"build\");\n         test_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         builder.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  vec![],\n                   &libtest_stamp(builder, compiler, target),\n                   false);\n \n@@ -452,8 +478,6 @@ impl Step for TestLink {\n             &builder.sysroot_libdir(target_compiler, compiler.host),\n             &libtest_stamp(builder, compiler, target)\n         );\n-\n-        builder.cargo(target_compiler, Mode::ToolTest, target, \"clean\");\n     }\n }\n \n@@ -500,15 +524,16 @@ impl Step for Rustc {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Rustc {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n             });\n             builder.info(&format!(\"Uplifting stage1 rustc ({} -> {})\",\n                 builder.config.build, target));\n             builder.ensure(RustcLink {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -524,11 +549,11 @@ impl Step for Rustc {\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"build\");\n         rustc_cargo(builder, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n         builder.info(&format!(\"Building stage{} compiler artifacts ({} -> {})\",\n                  compiler.stage, &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  vec![],\n                   &librustc_stamp(builder, compiler, target),\n                   false);\n \n@@ -559,13 +584,6 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Command) {\n     let libdir_relative = builder.config.libdir_relative().unwrap_or(Path::new(\"lib\"));\n     cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n \n-    // If we're not building a compiler with debugging information then remove\n-    // these two env vars which would be set otherwise.\n-    if builder.config.rust_debuginfo_only_std {\n-        cargo.env_remove(\"RUSTC_DEBUGINFO\");\n-        cargo.env_remove(\"RUSTC_DEBUGINFO_LINES\");\n-    }\n-\n     if let Some(ref ver_date) = builder.rust_info.commit_date() {\n         cargo.env(\"CFG_VER_DATE\", ver_date);\n     }\n@@ -617,7 +635,6 @@ impl Step for RustcLink {\n             &builder.sysroot_libdir(target_compiler, compiler.host),\n             &librustc_stamp(builder, compiler, target)\n         );\n-        builder.cargo(target_compiler, Mode::ToolRustc, target, \"clean\");\n     }\n }\n \n@@ -664,9 +681,10 @@ impl Step for CodegenBackend {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(CodegenBackend {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n                 backend,\n             });\n@@ -684,9 +702,9 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = out_dir.join(\".tmp.stamp\");\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n         let files = run_cargo(builder,\n                               cargo.arg(\"--features\").arg(features),\n+                              vec![],\n                               &tmp_stamp,\n                               false);\n         if builder.config.dry_run {\n@@ -748,6 +766,10 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n                     cargo.env(\"CFG_LLVM_ROOT\", s);\n                 }\n             }\n+            // Some LLVM linker flags (-L and -l) may be needed to link librustc_llvm.\n+            if let Some(ref s) = builder.config.llvm_ldflags {\n+                cargo.env(\"LLVM_LINKER_FLAGS\", s);\n+            }\n             // Building with a static libstdc++ is only supported on linux right now,\n             // not for MSVC or macOS\n             if builder.config.llvm_static_stdcpp &&\n@@ -768,6 +790,9 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n             if builder.config.llvm_use_libcxx {\n                 cargo.env(\"LLVM_USE_LIBCXX\", \"1\");\n             }\n+            if builder.config.llvm_optimize && !builder.config.llvm_release_debuginfo {\n+                cargo.env(\"LLVM_NDEBUG\", \"1\");\n+            }\n         }\n         _ => panic!(\"unknown backend: {}\", backend),\n     }\n@@ -1057,6 +1082,7 @@ pub fn add_to_sysroot(\n \n pub fn run_cargo(builder: &Builder<'_>,\n                  cargo: &mut Command,\n+                 tail_args: Vec<String>,\n                  stamp: &Path,\n                  is_check: bool)\n     -> Vec<PathBuf>\n@@ -1079,7 +1105,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n     // files we need to probe for later.\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n-    let ok = stream_cargo(builder, cargo, &mut |msg| {\n+    let ok = stream_cargo(builder, cargo, tail_args, &mut |msg| {\n         let (filenames, crate_types) = match msg {\n             CargoMessage::CompilerArtifact {\n                 filenames,\n@@ -1094,6 +1120,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n             // Skip files like executables\n             if !filename.ends_with(\".rlib\") &&\n                !filename.ends_with(\".lib\") &&\n+               !filename.ends_with(\".a\") &&\n                !is_dylib(&filename) &&\n                !(is_check && filename.ends_with(\".rmeta\")) {\n                 continue;\n@@ -1173,57 +1200,38 @@ pub fn run_cargo(builder: &Builder<'_>,\n         deps.push((path_to_add.into(), false));\n     }\n \n-    // Now we want to update the contents of the stamp file, if necessary. First\n-    // we read off the previous contents along with its mtime. If our new\n-    // contents (the list of files to copy) is different or if any dep's mtime\n-    // is newer then we rewrite the stamp file.\n     deps.sort();\n-    let stamp_contents = fs::read(stamp);\n-    let stamp_mtime = mtime(&stamp);\n     let mut new_contents = Vec::new();\n-    let mut max = None;\n-    let mut max_path = None;\n     for (dep, proc_macro) in deps.iter() {\n-        let mtime = mtime(dep);\n-        if Some(mtime) > max {\n-            max = Some(mtime);\n-            max_path = Some(dep.clone());\n-        }\n         new_contents.extend(if *proc_macro { b\"h\" } else { b\"t\" });\n         new_contents.extend(dep.to_str().unwrap().as_bytes());\n         new_contents.extend(b\"\\0\");\n     }\n-    let max = max.unwrap();\n-    let max_path = max_path.unwrap();\n-    let contents_equal = stamp_contents\n-        .map(|contents| contents == new_contents)\n-        .unwrap_or_default();\n-    if contents_equal && max <= stamp_mtime {\n-        builder.verbose(&format!(\"not updating {:?}; contents equal and {:?} <= {:?}\",\n-                stamp, max, stamp_mtime));\n-        return deps.into_iter().map(|(d, _)| d).collect()\n-    }\n-    if max > stamp_mtime {\n-        builder.verbose(&format!(\"updating {:?} as {:?} changed\", stamp, max_path));\n-    } else {\n-        builder.verbose(&format!(\"updating {:?} as deps changed\", stamp));\n-    }\n     t!(fs::write(&stamp, &new_contents));\n     deps.into_iter().map(|(d, _)| d).collect()\n }\n \n pub fn stream_cargo(\n     builder: &Builder<'_>,\n     cargo: &mut Command,\n+    tail_args: Vec<String>,\n     cb: &mut dyn FnMut(CargoMessage<'_>),\n ) -> bool {\n     if builder.config.dry_run {\n         return true;\n     }\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n-    cargo.arg(\"--message-format\").arg(\"json\")\n-         .stdout(Stdio::piped());\n+    let mut message_format = String::from(\"json-render-diagnostics\");\n+    if let Some(s) = &builder.config.rustc_error_format  {\n+        message_format.push_str(\",json-diagnostic-\");\n+        message_format.push_str(s);\n+    }\n+    cargo.arg(\"--message-format\").arg(message_format).stdout(Stdio::piped());\n+\n+    for arg in tail_args {\n+        cargo.arg(arg);\n+    }\n \n     builder.verbose(&format!(\"running: {:?}\", cargo));\n     let mut child = match cargo.spawn() {\n@@ -1271,5 +1279,5 @@ pub enum CargoMessage<'a> {\n     },\n     BuildScriptExecuted {\n         package_id: Cow<'a, str>,\n-    }\n+    },\n }"}, {"sha": "a5bfafdfdb4dcf5b45e91b75dd25827b9fdab22f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -11,7 +11,6 @@ use std::process;\n use std::cmp;\n \n use build_helper::t;\n-use num_cpus;\n use toml;\n use serde::Deserialize;\n use crate::cache::{INTERNER, Interned};\n@@ -52,7 +51,7 @@ pub struct Config {\n     pub test_compare_mode: bool,\n     pub llvm_libunwind: bool,\n \n-    pub run_host_only: bool,\n+    pub skip_only_host_steps: bool,\n \n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n@@ -76,7 +75,7 @@ pub struct Config {\n     pub llvm_link_shared: bool,\n     pub llvm_clang_cl: Option<String>,\n     pub llvm_targets: Option<String>,\n-    pub llvm_experimental_targets: String,\n+    pub llvm_experimental_targets: Option<String>,\n     pub llvm_link_jobs: Option<u32>,\n     pub llvm_version_suffix: Option<String>,\n     pub llvm_use_linker: Option<String>,\n@@ -96,15 +95,14 @@ pub struct Config {\n     pub rust_codegen_units: Option<u32>,\n     pub rust_codegen_units_std: Option<u32>,\n     pub rust_debug_assertions: bool,\n-    pub rust_debuginfo: bool,\n-    pub rust_debuginfo_lines: bool,\n-    pub rust_debuginfo_only_std: bool,\n-    pub rust_debuginfo_tools: bool,\n+    pub rust_debuginfo_level_rustc: u32,\n+    pub rust_debuginfo_level_std: u32,\n+    pub rust_debuginfo_level_tools: u32,\n+    pub rust_debuginfo_level_tests: u32,\n     pub rust_rpath: bool,\n     pub rustc_parallel: bool,\n     pub rustc_default_linker: Option<String>,\n     pub rust_optimize_tests: bool,\n-    pub rust_debuginfo_tests: bool,\n     pub rust_dist_src: bool,\n     pub rust_codegen_backends: Vec<Interned<String>>,\n     pub rust_codegen_backends_dir: String,\n@@ -130,7 +128,6 @@ pub struct Config {\n     pub low_priority: bool,\n     pub channel: String,\n     pub verbose_tests: bool,\n-    pub test_miri: bool,\n     pub save_toolstates: Option<PathBuf>,\n     pub print_step_timings: bool,\n     pub missing_tools: bool,\n@@ -300,24 +297,23 @@ struct Rust {\n     codegen_units: Option<u32>,\n     codegen_units_std: Option<u32>,\n     debug_assertions: Option<bool>,\n-    debuginfo: Option<bool>,\n-    debuginfo_lines: Option<bool>,\n-    debuginfo_only_std: Option<bool>,\n-    debuginfo_tools: Option<bool>,\n+    debuginfo_level: Option<u32>,\n+    debuginfo_level_rustc: Option<u32>,\n+    debuginfo_level_std: Option<u32>,\n+    debuginfo_level_tools: Option<u32>,\n+    debuginfo_level_tests: Option<u32>,\n     parallel_compiler: Option<bool>,\n     backtrace: Option<bool>,\n     default_linker: Option<String>,\n     channel: Option<String>,\n     musl_root: Option<String>,\n     rpath: Option<bool>,\n     optimize_tests: Option<bool>,\n-    debuginfo_tests: Option<bool>,\n     codegen_tests: Option<bool>,\n     ignore_git: Option<bool>,\n     debug: Option<bool>,\n     dist_src: Option<bool>,\n     verbose_tests: Option<bool>,\n-    test_miri: Option<bool>,\n     incremental: Option<bool>,\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n@@ -377,7 +373,6 @@ impl Config {\n         config.codegen_tests = true;\n         config.ignore_git = false;\n         config.rust_dist_src = true;\n-        config.test_miri = false;\n         config.rust_codegen_backends = vec![INTERNER.intern_str(\"llvm\")];\n         config.rust_codegen_backends_dir = \"codegen-backends\".to_owned();\n         config.deny_warnings = true;\n@@ -402,12 +397,12 @@ impl Config {\n         config.rustc_error_format = flags.rustc_error_format;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n-        config.jobs = flags.jobs;\n+        config.jobs = flags.jobs.map(threads_from_config);\n         config.cmd = flags.cmd;\n         config.incremental = flags.incremental;\n         config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n-        if let Some(value) = flags.warnings {\n+        if let Some(value) = flags.deny_warnings {\n             config.deny_warnings = value;\n         }\n \n@@ -418,7 +413,9 @@ impl Config {\n         }\n \n         // If --target was specified but --host wasn't specified, don't run any host-only tests.\n-        config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n+        let has_hosts = !flags.host.is_empty();\n+        let has_targets = !flags.target.is_empty();\n+        config.skip_only_host_steps = !has_hosts && has_targets;\n \n         let toml = file.map(|file| {\n             let contents = t!(fs::read_to_string(&file));\n@@ -495,12 +492,13 @@ impl Config {\n         // Store off these values as options because if they're not provided\n         // we'll infer default values for them later\n         let mut llvm_assertions = None;\n-        let mut debuginfo_lines = None;\n-        let mut debuginfo_only_std = None;\n-        let mut debuginfo_tools = None;\n         let mut debug = None;\n-        let mut debuginfo = None;\n         let mut debug_assertions = None;\n+        let mut debuginfo_level = None;\n+        let mut debuginfo_level_rustc = None;\n+        let mut debuginfo_level_std = None;\n+        let mut debuginfo_level_tools = None;\n+        let mut debuginfo_level_tests = None;\n         let mut optimize = None;\n         let mut ignore_git = None;\n \n@@ -523,8 +521,7 @@ impl Config {\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n             set(&mut config.llvm_link_shared, llvm.link_shared);\n             config.llvm_targets = llvm.targets.clone();\n-            config.llvm_experimental_targets = llvm.experimental_targets.clone()\n-                .unwrap_or_else(|| \"WebAssembly;RISCV\".to_string());\n+            config.llvm_experimental_targets = llvm.experimental_targets.clone();\n             config.llvm_link_jobs = llvm.link_jobs;\n             config.llvm_version_suffix = llvm.version_suffix.clone();\n             config.llvm_clang_cl = llvm.clang_cl.clone();\n@@ -540,14 +537,14 @@ impl Config {\n         if let Some(ref rust) = toml.rust {\n             debug = rust.debug;\n             debug_assertions = rust.debug_assertions;\n-            debuginfo = rust.debuginfo;\n-            debuginfo_lines = rust.debuginfo_lines;\n-            debuginfo_only_std = rust.debuginfo_only_std;\n-            debuginfo_tools = rust.debuginfo_tools;\n+            debuginfo_level = rust.debuginfo_level;\n+            debuginfo_level_rustc = rust.debuginfo_level_rustc;\n+            debuginfo_level_std = rust.debuginfo_level_std;\n+            debuginfo_level_tools = rust.debuginfo_level_tools;\n+            debuginfo_level_tests = rust.debuginfo_level_tests;\n             optimize = rust.optimize;\n             ignore_git = rust.ignore_git;\n             set(&mut config.rust_optimize_tests, rust.optimize_tests);\n-            set(&mut config.rust_debuginfo_tests, rust.debuginfo_tests);\n             set(&mut config.codegen_tests, rust.codegen_tests);\n             set(&mut config.rust_rpath, rust.rpath);\n             set(&mut config.jemalloc, rust.jemalloc);\n@@ -557,7 +554,6 @@ impl Config {\n             set(&mut config.channel, rust.channel.clone());\n             set(&mut config.rust_dist_src, rust.dist_src);\n             set(&mut config.verbose_tests, rust.verbose_tests);\n-            set(&mut config.test_miri, rust.test_miri);\n             // in the case \"false\" is set explicitly, do not overwrite the command line args\n             if let Some(true) = rust.incremental {\n                 config.incremental = true;\n@@ -570,7 +566,7 @@ impl Config {\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n             config.save_toolstates = rust.save_toolstates.clone().map(PathBuf::from);\n-            set(&mut config.deny_warnings, rust.deny_warnings.or(flags.warnings));\n+            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n             set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n             set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n             set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n@@ -583,13 +579,8 @@ impl Config {\n \n             set(&mut config.rust_codegen_backends_dir, rust.codegen_backends_dir.clone());\n \n-            match rust.codegen_units {\n-                Some(0) => config.rust_codegen_units = Some(num_cpus::get() as u32),\n-                Some(n) => config.rust_codegen_units = Some(n),\n-                None => {}\n-            }\n-\n-            config.rust_codegen_units_std = rust.codegen_units_std;\n+            config.rust_codegen_units = rust.codegen_units.map(threads_from_config);\n+            config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n         }\n \n         if let Some(ref t) = toml.target {\n@@ -639,18 +630,19 @@ impl Config {\n         let default = true;\n         config.rust_optimize = optimize.unwrap_or(default);\n \n-        let default = match &config.channel[..] {\n-            \"stable\" | \"beta\" | \"nightly\" => true,\n-            _ => false,\n-        };\n-        config.rust_debuginfo_lines = debuginfo_lines.unwrap_or(default);\n-        config.rust_debuginfo_only_std = debuginfo_only_std.unwrap_or(default);\n-        config.rust_debuginfo_tools = debuginfo_tools.unwrap_or(false);\n-\n         let default = debug == Some(true);\n-        config.rust_debuginfo = debuginfo.unwrap_or(default);\n         config.rust_debug_assertions = debug_assertions.unwrap_or(default);\n \n+        let with_defaults = |debuginfo_level_specific: Option<u32>| {\n+            debuginfo_level_specific\n+                .or(debuginfo_level)\n+                .unwrap_or(if debug == Some(true) { 2 } else { 0 })\n+        };\n+        config.rust_debuginfo_level_rustc = with_defaults(debuginfo_level_rustc);\n+        config.rust_debuginfo_level_std = with_defaults(debuginfo_level_std);\n+        config.rust_debuginfo_level_tools = with_defaults(debuginfo_level_tools);\n+        config.rust_debuginfo_level_tests = debuginfo_level_tests.unwrap_or(0);\n+\n         let default = config.channel == \"dev\";\n         config.ignore_git = ignore_git.unwrap_or(default);\n \n@@ -687,3 +679,10 @@ fn set<T>(field: &mut T, val: Option<T>) {\n         *field = v;\n     }\n }\n+\n+fn threads_from_config(v: u32) -> u32 {\n+    match v {\n+        0 => num_cpus::get() as u32,\n+        n => n,\n+    }\n+}"}, {"sha": "346f0cb2039c08ccbd8d17826cc7af7c24f84a75", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -36,8 +36,6 @@ def v(*args):\n o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n o(\"optimize-tests\", \"rust.optimize-tests\", \"build tests with optimizations\")\n o(\"parallel-compiler\", \"rust.parallel-compiler\", \"build a multi-threaded rustc\")\n-o(\"test-miri\", \"rust.test-miri\", \"run miri's test suite\")\n-o(\"debuginfo-tests\", \"rust.debuginfo-tests\", \"build tests with debugger metadata\")\n o(\"verbose-tests\", \"rust.verbose-tests\", \"enable verbose output when running tests\")\n o(\"ccache\", \"llvm.ccache\", \"invoke gcc/clang via ccache to reuse object files between builds\")\n o(\"sccache\", None, \"invoke gcc/clang via sccache to reuse object files between builds\")\n@@ -77,10 +75,11 @@ def v(*args):\n o(\"llvm-assertions\", \"llvm.assertions\", \"build LLVM with assertions\")\n o(\"debug-assertions\", \"rust.debug-assertions\", \"build with debugging assertions\")\n o(\"llvm-release-debuginfo\", \"llvm.release-debuginfo\", \"build LLVM with debugger metadata\")\n-o(\"debuginfo\", \"rust.debuginfo\", \"build with debugger metadata\")\n-o(\"debuginfo-lines\", \"rust.debuginfo-lines\", \"build with line number debugger metadata\")\n-o(\"debuginfo-only-std\", \"rust.debuginfo-only-std\", \"build only libstd with debugging information\")\n-o(\"debuginfo-tools\", \"rust.debuginfo-tools\", \"build extended tools with debugging information\")\n+v(\"debuginfo-level\", \"rust.debuginfo-level\", \"debuginfo level for Rust code\")\n+v(\"debuginfo-level-rustc\", \"rust.debuginfo-level-rustc\", \"debuginfo level for the compiler\")\n+v(\"debuginfo-level-std\", \"rust.debuginfo-level-std\", \"debuginfo level for the standard library\")\n+v(\"debuginfo-level-tools\", \"rust.debuginfo-level-tools\", \"debuginfo level for the tools\")\n+v(\"debuginfo-level-tests\", \"rust.debuginfo-level-tests\", \"debuginfo level for the test suites run with compiletest\")\n v(\"save-toolstates\", \"rust.save-toolstates\", \"save build and test status of external tools into this file\")\n \n v(\"prefix\", \"install.prefix\", \"set installation prefix\")\n@@ -125,7 +124,9 @@ def v(*args):\n   \"arm-unknown-linux-musleabihf install directory\")\n v(\"musl-root-armv5te\", \"target.armv5te-unknown-linux-musleabi.musl-root\",\n   \"armv5te-unknown-linux-musleabi install directory\")\n-v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n+v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabi.musl-root\",\n+  \"armv7-unknown-linux-musleabi install directory\")\n+v(\"musl-root-armv7hf\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n   \"armv7-unknown-linux-musleabihf install directory\")\n v(\"musl-root-aarch64\", \"target.aarch64-unknown-linux-musl.musl-root\",\n   \"aarch64-unknown-linux-musl install directory\")"}, {"sha": "bd012a887c26ee70fbfb53577c765850397cf217", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 90, "deletions": 94, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -68,7 +68,6 @@ fn missing_tool(tool_name: &str, skip: bool) {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n-    pub stage: u32,\n     pub host: Interned<String>,\n }\n \n@@ -82,7 +81,6 @@ impl Step for Docs {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Docs {\n-            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n@@ -130,7 +128,6 @@ impl Step for Docs {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustcDocs {\n-    pub stage: u32,\n     pub host: Interned<String>,\n }\n \n@@ -144,7 +141,6 @@ impl Step for RustcDocs {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RustcDocs {\n-            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n@@ -647,7 +643,11 @@ impl Step for Std {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n@@ -737,7 +737,14 @@ impl Step for Analysis {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Analysis {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+            // Find the actual compiler (handling the full bootstrap option) which\n+            // produced the save-analysis data because that data isn't copied\n+            // through the sysroot uplifting.\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n@@ -757,14 +764,6 @@ impl Step for Analysis {\n \n         builder.ensure(Std { compiler, target });\n \n-        // Package save-analysis from stage1 if not doing a full bootstrap, as the\n-        // stage2 artifacts is simply copied from stage1 in that case.\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n-\n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n \n         let src = builder.stage_out(compiler, Mode::Std)\n@@ -805,6 +804,7 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n \n         const LLVM_PROJECTS: &[&str] = &[\n             \"llvm-project/clang\", \"llvm-project\\\\clang\",\n+            \"llvm-project/libunwind\", \"llvm-project\\\\libunwind\",\n             \"llvm-project/lld\", \"llvm-project\\\\lld\",\n             \"llvm-project/lldb\", \"llvm-project\\\\lldb\",\n             \"llvm-project/llvm\", \"llvm-project\\\\llvm\",\n@@ -903,7 +903,7 @@ impl Step for Src {\n             \"src/libtest\",\n             \"src/libterm\",\n             \"src/libprofiler_builtins\",\n-            \"src/stdsimd\",\n+            \"src/stdarch\",\n             \"src/libproc_macro\",\n             \"src/tools/rustc-std-workspace-core\",\n             \"src/tools/rustc-std-workspace-alloc\",\n@@ -935,8 +935,6 @@ impl Step for Src {\n     }\n }\n \n-const CARGO_VENDOR_VERSION: &str = \"0.1.22\";\n-\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct PlainSourceTarball;\n \n@@ -998,26 +996,6 @@ impl Step for PlainSourceTarball {\n \n         // If we're building from git sources, we need to vendor a complete distribution.\n         if builder.rust_info.is_git() {\n-            // Get cargo-vendor installed, if it isn't already.\n-            let mut has_cargo_vendor = false;\n-            let mut cmd = Command::new(&builder.initial_cargo);\n-            for line in output(cmd.arg(\"install\").arg(\"--list\")).lines() {\n-                has_cargo_vendor |= line.starts_with(\"cargo-vendor \");\n-            }\n-            if !has_cargo_vendor {\n-                let mut cmd = builder.cargo(\n-                    builder.compiler(0, builder.config.build),\n-                    Mode::ToolBootstrap,\n-                    builder.config.build,\n-                    \"install\"\n-                );\n-                cmd.arg(\"--force\")\n-                   .arg(\"--debug\")\n-                   .arg(\"--vers\").arg(CARGO_VENDOR_VERSION)\n-                   .arg(\"cargo-vendor\");\n-                builder.run(&mut cmd);\n-            }\n-\n             // Vendor all Cargo dependencies\n             let mut cmd = Command::new(&builder.initial_cargo);\n             cmd.arg(\"vendor\")\n@@ -1066,7 +1044,7 @@ pub fn sanitize_sh(path: &Path) -> String {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1080,16 +1058,20 @@ impl Step for Cargo {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargo {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.info(&format!(\"Dist cargo stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist cargo stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n         let release_num = builder.release_num(\"cargo\");\n@@ -1104,10 +1086,7 @@ impl Step for Cargo {\n         // Prepare the image directory\n         builder.create_dir(&image.join(\"share/zsh/site-functions\"));\n         builder.create_dir(&image.join(\"etc/bash_completion.d\"));\n-        let cargo = builder.ensure(tool::Cargo {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target\n-        });\n+        let cargo = builder.ensure(tool::Cargo { compiler, target });\n         builder.install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n@@ -1152,7 +1131,7 @@ impl Step for Cargo {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1166,17 +1145,21 @@ impl Step for Rls {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rls {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist RLS stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist RLS stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/rls\");\n         let release_num = builder.release_num(\"rls\");\n         let name = pkgname(builder, \"rls\");\n@@ -1191,8 +1174,9 @@ impl Step for Rls {\n         // We expect RLS to build, because we've exited this step above if tool\n         // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"RLS\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&rls, &image.join(\"bin\"), 0o755);\n@@ -1231,7 +1215,7 @@ impl Step for Rls {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Clippy {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1245,17 +1229,21 @@ impl Step for Clippy {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Clippy {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist clippy stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/clippy\");\n         let release_num = builder.release_num(\"clippy\");\n         let name = pkgname(builder, \"clippy\");\n@@ -1270,11 +1258,12 @@ impl Step for Clippy {\n         // We expect clippy to build, because we've exited this step above if tool\n         // state for clippy isn't testing.\n         let clippy = builder.ensure(tool::Clippy {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"clippy\", builder.build.config.missing_tools); None })?;\n         let cargoclippy = builder.ensure(tool::CargoClippy {\n-            compiler: builder.compiler(stage, builder.config.build),\n+            compiler,\n             target, extra_features: Vec::new()\n         }).or_else(|| { missing_tool(\"cargo clippy\", builder.build.config.missing_tools); None })?;\n \n@@ -1315,7 +1304,7 @@ impl Step for Clippy {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Miri {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1329,17 +1318,21 @@ impl Step for Miri {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Miri {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist miri stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist miri stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/miri\");\n         let release_num = builder.release_num(\"miri\");\n         let name = pkgname(builder, \"miri\");\n@@ -1354,12 +1347,14 @@ impl Step for Miri {\n         // We expect miri to build, because we've exited this step above if tool\n         // state for miri isn't testing.\n         let miri = builder.ensure(tool::Miri {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"miri\", builder.build.config.missing_tools); None })?;\n         let cargomiri = builder.ensure(tool::CargoMiri {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new()\n         }).or_else(|| { missing_tool(\"cargo miri\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&miri, &image.join(\"bin\"), 0o755);\n@@ -1399,7 +1394,7 @@ impl Step for Miri {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1413,16 +1408,20 @@ impl Step for Rustfmt {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustfmt {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/rustfmt\");\n         let release_num = builder.release_num(\"rustfmt\");\n         let name = pkgname(builder, \"rustfmt\");\n@@ -1435,12 +1434,14 @@ impl Step for Rustfmt {\n \n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"Rustfmt\", builder.build.config.missing_tools); None })?;\n         let cargofmt = builder.ensure(tool::Cargofmt {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"Cargofmt\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&rustfmt, &image.join(\"bin\"), 0o755);\n@@ -1505,30 +1506,28 @@ impl Step for Extended {\n \n     /// Creates a combined installer for the specified target in the provided stage.\n     fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n         let target = self.target;\n+        let stage = self.stage;\n+        let compiler = builder.compiler_for(self.stage, self.host, self.target);\n \n-        builder.info(&format!(\"Dist extended stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist extended stage{} ({})\", compiler.stage, target));\n \n         let rustc_installer = builder.ensure(Rustc {\n             compiler: builder.compiler(stage, target),\n         });\n-        let cargo_installer = builder.ensure(Cargo { stage, target });\n-        let rustfmt_installer = builder.ensure(Rustfmt { stage, target });\n-        let rls_installer = builder.ensure(Rls { stage, target });\n-        let llvm_tools_installer = builder.ensure(LlvmTools { stage, target });\n-        let clippy_installer = builder.ensure(Clippy { stage, target });\n-        let miri_installer = builder.ensure(Miri { stage, target });\n+        let cargo_installer = builder.ensure(Cargo { compiler, target });\n+        let rustfmt_installer = builder.ensure(Rustfmt { compiler, target });\n+        let rls_installer = builder.ensure(Rls { compiler, target });\n+        let llvm_tools_installer = builder.ensure(LlvmTools { target });\n+        let clippy_installer = builder.ensure(Clippy { compiler, target });\n+        let miri_installer = builder.ensure(Miri { compiler, target });\n         let lldb_installer = builder.ensure(Lldb { target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n-        let analysis_installer = builder.ensure(Analysis {\n-            compiler: builder.compiler(stage, self.host),\n-            target\n-        });\n+        let analysis_installer = builder.ensure(Analysis { compiler, target });\n \n-        let docs_installer = builder.ensure(Docs { stage, host: target, });\n+        let docs_installer = builder.ensure(Docs { host: target, });\n         let std_installer = builder.ensure(Std {\n-            compiler: builder.compiler(stage, self.host),\n+            compiler: builder.compiler(stage, target),\n             target,\n         });\n \n@@ -2076,7 +2075,6 @@ pub fn maybe_install_llvm_dylib(builder: &Builder<'_>,\n \n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n-    pub stage: u32,\n     pub target: Interned<String>,\n }\n \n@@ -2090,26 +2088,24 @@ impl Step for LlvmTools {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(LlvmTools {\n-            stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n         /* run only if llvm-config isn't used */\n         if let Some(config) = builder.config.target_config.get(&target) {\n             if let Some(ref _s) = config.llvm_config {\n-                builder.info(&format!(\"Skipping LlvmTools stage{} ({}): external LLVM\",\n-                    stage, target));\n+                builder.info(&format!(\"Skipping LlvmTools ({}): external LLVM\",\n+                    target));\n                 return None;\n             }\n         }\n \n-        builder.info(&format!(\"Dist LlvmTools stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist LlvmTools ({})\", target));\n         let src = builder.src.join(\"src/llvm-project/llvm\");\n         let name = pkgname(builder, \"llvm-tools\");\n "}, {"sha": "36229720e42cd5f993c4338c03f97e958126b04d", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 27, "deletions": 99, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -23,7 +23,7 @@ use crate::cache::{INTERNER, Interned};\n use crate::config::Config;\n \n macro_rules! book {\n-    ($($name:ident, $path:expr, $book_name:expr, $book_ver:expr;)+) => {\n+    ($($name:ident, $path:expr, $book_name:expr;)+) => {\n         $(\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n@@ -46,10 +46,10 @@ macro_rules! book {\n             }\n \n             fn run(self, builder: &Builder<'_>) {\n-                builder.ensure(Rustbook {\n+                builder.ensure(RustbookSrc {\n                     target: self.target,\n                     name: INTERNER.intern_str($book_name),\n-                    version: $book_ver,\n+                    src: doc_src(builder),\n                 })\n             }\n         }\n@@ -60,50 +60,17 @@ macro_rules! book {\n // NOTE: When adding a book here, make sure to ALSO build the book by\n // adding a build step in `src/bootstrap/builder.rs`!\n book!(\n-    EditionGuide, \"src/doc/edition-guide\", \"edition-guide\", RustbookVersion::MdBook2;\n-    EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\", RustbookVersion::MdBook2;\n-    Nomicon, \"src/doc/nomicon\", \"nomicon\", RustbookVersion::MdBook1;\n-    Reference, \"src/doc/reference\", \"reference\", RustbookVersion::MdBook1;\n-    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", RustbookVersion::MdBook1;\n-    RustcBook, \"src/doc/rustc\", \"rustc\", RustbookVersion::MdBook1;\n-    RustdocBook, \"src/doc/rustdoc\", \"rustdoc\", RustbookVersion::MdBook1;\n+    EditionGuide, \"src/doc/edition-guide\", \"edition-guide\";\n+    EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\";\n+    Nomicon, \"src/doc/nomicon\", \"nomicon\";\n+    Reference, \"src/doc/reference\", \"reference\";\n+    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\";\n+    RustcBook, \"src/doc/rustc\", \"rustc\";\n+    RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n );\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-enum RustbookVersion {\n-    MdBook1,\n-    MdBook2,\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-struct Rustbook {\n-    target: Interned<String>,\n-    name: Interned<String>,\n-    version: RustbookVersion,\n-}\n-\n-impl Step for Rustbook {\n-    type Output = ();\n-\n-    // rustbook is never directly called, and only serves as a shim for the nomicon and the\n-    // reference.\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.never()\n-    }\n-\n-    /// Invoke `rustbook` for `target` for the doc book `name`.\n-    ///\n-    /// This will not actually generate any documentation if the documentation has\n-    /// already been generated.\n-    fn run(self, builder: &Builder<'_>) {\n-        let src = builder.src.join(\"src/doc\");\n-        builder.ensure(RustbookSrc {\n-            target: self.target,\n-            name: self.name,\n-            src: INTERNER.intern_path(src),\n-            version: self.version,\n-        });\n-    }\n+fn doc_src(builder: &Builder<'_>) -> Interned<PathBuf> {\n+    INTERNER.intern_path(builder.src.join(\"src/doc\"))\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n@@ -134,7 +101,6 @@ impl Step for UnstableBook {\n             target: self.target,\n             name: INTERNER.intern_str(\"unstable-book\"),\n             src: builder.md_doc_out(self.target),\n-            version: RustbookVersion::MdBook1,\n         })\n     }\n }\n@@ -188,7 +154,6 @@ struct RustbookSrc {\n     target: Interned<String>,\n     name: Interned<String>,\n     src: Interned<PathBuf>,\n-    version: RustbookVersion,\n }\n \n impl Step for RustbookSrc {\n@@ -220,18 +185,11 @@ impl Step for RustbookSrc {\n         builder.info(&format!(\"Rustbook ({}) - {}\", target, name));\n         let _ = fs::remove_dir_all(&out);\n \n-        let vers = match self.version {\n-            RustbookVersion::MdBook1 => \"1\",\n-            RustbookVersion::MdBook2 => \"2\",\n-        };\n-\n         builder.run(rustbook_cmd\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n-                       .arg(out)\n-                       .arg(\"-m\")\n-                       .arg(vers));\n+                       .arg(out));\n     }\n }\n \n@@ -274,33 +232,33 @@ impl Step for TheBook {\n         let name = self.name;\n \n         // build book\n-        builder.ensure(Rustbook {\n+        builder.ensure(RustbookSrc {\n             target,\n             name: INTERNER.intern_string(name.to_string()),\n-            version: RustbookVersion::MdBook2,\n+            src: doc_src(builder),\n         });\n \n         // building older edition redirects\n \n         let source_name = format!(\"{}/first-edition\", name);\n-        builder.ensure(Rustbook {\n+        builder.ensure(RustbookSrc {\n             target,\n             name: INTERNER.intern_string(source_name),\n-            version: RustbookVersion::MdBook2,\n+            src: doc_src(builder),\n         });\n \n         let source_name = format!(\"{}/second-edition\", name);\n-        builder.ensure(Rustbook {\n+        builder.ensure(RustbookSrc {\n             target,\n             name: INTERNER.intern_string(source_name),\n-            version: RustbookVersion::MdBook2,\n+            src: doc_src(builder),\n         });\n \n         let source_name = format!(\"{}/2018-edition\", name);\n-        builder.ensure(Rustbook {\n+        builder.ensure(RustbookSrc {\n             target,\n             name: INTERNER.intern_string(source_name),\n-            version: RustbookVersion::MdBook2,\n+            src: doc_src(builder),\n         });\n \n         // build the version info page and CSS\n@@ -475,12 +433,7 @@ impl Step for Std {\n         builder.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         builder.ensure(compile::Std { compiler, target });\n         let out_dir = builder.stage_out(compiler, Mode::Std)\n@@ -563,12 +516,7 @@ impl Step for Test {\n         builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         // Build libstd docs so that we generate relative links\n         builder.ensure(Std { stage, target });\n@@ -632,12 +580,7 @@ impl Step for WhitelistedRustc {\n         builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         // Build libstd docs so that we generate relative links\n         builder.ensure(Std { stage, target });\n@@ -706,12 +649,7 @@ impl Step for Rustc {\n         t!(fs::create_dir_all(&out));\n \n         // Get the correct compiler for this stage.\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n@@ -728,7 +666,7 @@ impl Step for Rustc {\n \n         // Build cargo command.\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items --passes strip-hidden\");\n         compile::rustc_cargo(builder, &mut cargo);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`.\n@@ -807,12 +745,7 @@ impl Step for Rustdoc {\n         t!(fs::create_dir_all(&out));\n \n         // Get the correct compiler for this stage.\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n@@ -923,11 +856,6 @@ impl Step for UnstableBookGen {\n     fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n \n-        builder.ensure(compile::Std {\n-            compiler: builder.compiler(builder.top_stage, builder.config.build),\n-            target,\n-        });\n-\n         builder.info(&format!(\"Generating unstable book md files ({})\", target));\n         let out = builder.md_doc_out(target).join(\"unstable-book\");\n         builder.create_dir(&out);"}, {"sha": "828865f10ffba37ce53dcfb1003527316565cb82", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 73, "deletions": 4, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -33,8 +33,11 @@ pub struct Flags {\n     pub rustc_error_format: Option<String>,\n     pub dry_run: bool,\n \n-    // true => deny\n-    pub warnings: Option<bool>,\n+    // This overrides the deny-warnings configuation option,\n+    // which passes -Dwarnings to the compiler invocations.\n+    //\n+    // true => deny, false => allow\n+    pub deny_warnings: Option<bool>,\n }\n \n pub enum Subcommand {\n@@ -44,6 +47,12 @@ pub enum Subcommand {\n     Check {\n         paths: Vec<PathBuf>,\n     },\n+    Clippy {\n+        paths: Vec<PathBuf>,\n+    },\n+    Fix {\n+        paths: Vec<PathBuf>,\n+    },\n     Doc {\n         paths: Vec<PathBuf>,\n     },\n@@ -52,6 +61,7 @@ pub enum Subcommand {\n         /// Whether to automatically update stderr/stdout files\n         bless: bool,\n         compare_mode: Option<String>,\n+        pass: Option<String>,\n         test_args: Vec<String>,\n         rustc_args: Vec<String>,\n         fail_fast: bool,\n@@ -90,6 +100,8 @@ Usage: x.py <subcommand> [options] [<paths>...]\n Subcommands:\n     build       Compile either the compiler or libraries\n     check       Compile either the compiler or libraries, using cargo check\n+    clippy      Run clippy\n+    fix         Run cargo fix\n     test        Build and run some test suites\n     bench       Build and run some benchmarks\n     doc         Build documentation\n@@ -146,6 +158,8 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n         let subcommand = args.iter().find(|&s| {\n             (s == \"build\")\n                 || (s == \"check\")\n+                || (s == \"clippy\")\n+                || (s == \"fix\")\n                 || (s == \"test\")\n                 || (s == \"bench\")\n                 || (s == \"doc\")\n@@ -189,6 +203,12 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n                     \"mode describing what file the actual ui output will be compared to\",\n                     \"COMPARE MODE\",\n                 );\n+                opts.optopt(\n+                    \"\",\n+                    \"pass\",\n+                    \"force {check,build,run}-pass tests to this mode.\",\n+                    \"check | build | run\"\n+                );\n                 opts.optflag(\n                     \"\",\n                     \"rustfix-coverage\",\n@@ -281,14 +301,36 @@ Arguments:\n     the compiler.\",\n                 );\n             }\n+            \"clippy\" => {\n+                subcommand_help.push_str(\n+                    \"\\n\n+Arguments:\n+    This subcommand accepts a number of paths to directories to the crates\n+    and/or artifacts to run clippy against. For example:\n+\n+        ./x.py clippy src/libcore\n+        ./x.py clippy src/libcore src/libproc_macro\",\n+                );\n+            }\n+            \"fix\" => {\n+                subcommand_help.push_str(\n+                    \"\\n\n+Arguments:\n+    This subcommand accepts a number of paths to directories to the crates\n+    and/or artifacts to run `cargo fix` against. For example:\n+\n+        ./x.py fix src/libcore\n+        ./x.py fix src/libcore src/libproc_macro\",\n+                );\n+            }\n             \"test\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to tests that\n     should be compiled and run. For example:\n \n-        ./x.py test src/test/run-pass\n+        ./x.py test src/test/ui\n         ./x.py test src/libstd --test-args hash_map\n         ./x.py test src/libstd --stage 0 --no-doc\n         ./x.py test src/test/ui --bless\n@@ -363,10 +405,13 @@ Arguments:\n         let cmd = match subcommand.as_str() {\n             \"build\" => Subcommand::Build { paths },\n             \"check\" => Subcommand::Check { paths },\n+            \"clippy\" => Subcommand::Clippy { paths },\n+            \"fix\" => Subcommand::Fix { paths },\n             \"test\" => Subcommand::Test {\n                 paths,\n                 bless: matches.opt_present(\"bless\"),\n                 compare_mode: matches.opt_str(\"compare-mode\"),\n+                pass: matches.opt_str(\"pass\"),\n                 test_args: matches.opt_strs(\"test-args\"),\n                 rustc_args: matches.opt_strs(\"rustc-args\"),\n                 fail_fast: !matches.opt_present(\"no-fail-fast\"),\n@@ -426,7 +471,7 @@ Arguments:\n                 .into_iter()\n                 .map(|p| p.into())\n                 .collect::<Vec<_>>(),\n-            warnings: matches.opt_str(\"warnings\").map(|v| v == \"deny\"),\n+            deny_warnings: parse_deny_warnings(&matches),\n         }\n     }\n }\n@@ -490,6 +535,15 @@ impl Subcommand {\n             _ => None,\n         }\n     }\n+\n+    pub fn pass(&self) -> Option<&str> {\n+        match *self {\n+            Subcommand::Test {\n+                ref pass, ..\n+            } => pass.as_ref().map(|s| &s[..]),\n+            _ => None,\n+        }\n+    }\n }\n \n fn split(s: &[String]) -> Vec<String> {\n@@ -498,3 +552,18 @@ fn split(s: &[String]) -> Vec<String> {\n         .map(|s| s.to_string())\n         .collect()\n }\n+\n+fn parse_deny_warnings(matches: &getopts::Matches) -> Option<bool> {\n+    match matches.opt_str(\"warnings\").as_ref().map(|v| v.as_str()) {\n+        Some(\"deny\") => Some(true),\n+        Some(\"allow\") => Some(false),\n+        Some(value) => {\n+            eprintln!(\n+                r#\"invalid value for --warnings: {:?}, expected \"allow\" or \"deny\"\"#,\n+                value,\n+                );\n+            process::exit(1);\n+        },\n+        None => None,\n+    }\n+}"}, {"sha": "557586709c61275af7c8658af672075aa67f8a03", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 45, "deletions": 35, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -5,12 +5,13 @@\n \n use std::env;\n use std::fs;\n-use std::path::{Path, PathBuf, Component};\n+use std::path::{Component, Path, PathBuf};\n use std::process::Command;\n \n use build_helper::t;\n \n use crate::dist::{self, pkgname, sanitize_sh, tmpdir};\n+use crate::Compiler;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n@@ -58,7 +59,7 @@ fn install_sh(\n     package: &str,\n     name: &str,\n     stage: u32,\n-    host: Option<Interned<String>>\n+    host: Option<Interned<String>>,\n ) {\n     builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n@@ -144,9 +145,8 @@ macro_rules! install {\n         $(\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n-            pub stage: u32,\n+            pub compiler: Compiler,\n             pub target: Interned<String>,\n-            pub host: Interned<String>,\n         }\n \n         impl $name {\n@@ -175,9 +175,8 @@ macro_rules! install {\n \n             fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n-                    stage: run.builder.top_stage,\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n-                    host: run.builder.config.build,\n                 });\n             }\n \n@@ -190,67 +189,81 @@ macro_rules! install {\n \n install!((self, builder, _config),\n     Docs, \"src/doc\", _config.docs, only_hosts: false, {\n-        builder.ensure(dist::Docs { stage: self.stage, host: self.target });\n-        install_docs(builder, self.stage, self.target);\n+        builder.ensure(dist::Docs { host: self.target });\n+        install_docs(builder, self.compiler.stage, self.target);\n     };\n     Std, \"src/libstd\", true, only_hosts: true, {\n         for target in &builder.targets {\n             builder.ensure(dist::Std {\n-                compiler: builder.compiler(self.stage, self.host),\n+                compiler: self.compiler,\n                 target: *target\n             });\n-            install_std(builder, self.stage, *target);\n+            install_std(builder, self.compiler.stage, *target);\n         }\n     };\n     Cargo, \"cargo\", Self::should_build(_config), only_hosts: true, {\n-        builder.ensure(dist::Cargo { stage: self.stage, target: self.target });\n-        install_cargo(builder, self.stage, self.target);\n+        builder.ensure(dist::Cargo { compiler: self.compiler, target: self.target });\n+        install_cargo(builder, self.compiler.stage, self.target);\n     };\n     Rls, \"rls\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rls { stage: self.stage, target: self.target }).is_some() ||\n+        if builder.ensure(dist::Rls { compiler: self.compiler, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n-            install_rls(builder, self.stage, self.target);\n+            install_rls(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install RLS stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install RLS stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Clippy { stage: self.stage, target: self.target }).is_some() ||\n-            Self::should_install(builder) {\n-            install_clippy(builder, self.stage, self.target);\n+        if builder.ensure(dist::Clippy {\n+            compiler: self.compiler,\n+            target: self.target,\n+        }).is_some() || Self::should_install(builder) {\n+            install_clippy(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install clippy stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install clippy stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Miri, \"miri\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Miri { stage: self.stage, target: self.target }).is_some() ||\n+        if builder.ensure(dist::Miri { compiler: self.compiler, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n-            install_miri(builder, self.stage, self.target);\n+            install_miri(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install miri stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install miri stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() ||\n-            Self::should_install(builder) {\n-            install_rustfmt(builder, self.stage, self.target);\n+        if builder.ensure(dist::Rustfmt {\n+            compiler: self.compiler,\n+            target: self.target\n+        }).is_some() || Self::should_install(builder) {\n+            install_rustfmt(builder, self.compiler.stage, self.target);\n         } else {\n             builder.info(\n-                &format!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target));\n+                &format!(\"skipping Install Rustfmt stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {\n         builder.ensure(dist::Analysis {\n-            compiler: builder.compiler(self.stage, self.host),\n+            // Find the actual compiler (handling the full bootstrap option) which\n+            // produced the save-analysis data because that data isn't copied\n+            // through the sysroot uplifting.\n+            compiler: builder.compiler_for(builder.top_stage, builder.config.build, self.target),\n             target: self.target\n         });\n-        install_analysis(builder, self.stage, self.target);\n+        install_analysis(builder, self.compiler.stage, self.target);\n     };\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n-            compiler: builder.compiler(self.stage, self.target),\n+            compiler: self.compiler,\n         });\n-        install_rustc(builder, self.stage, self.target);\n+        install_rustc(builder, self.compiler.stage, self.target);\n     };\n );\n \n@@ -266,15 +279,12 @@ impl Step for Src {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let config = &run.builder.config;\n-        let cond = config.extended &&\n-            config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n+        let cond = config.extended && config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n         run.path(\"src\").default_condition(cond)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Src {\n-            stage: run.builder.top_stage,\n-        });\n+        run.builder.ensure(Src { stage: run.builder.top_stage });\n     }\n \n     fn run(self, builder: &Builder<'_>) {"}, {"sha": "6867d62a480bd2ba57a5a08767f784ad1266c423", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -32,6 +32,7 @@\n use std::env;\n use std::io;\n use std::mem;\n+use std::ptr;\n use crate::Build;\n \n type HANDLE = *mut u8;\n@@ -118,8 +119,8 @@ pub unsafe fn setup(build: &mut Build) {\n     SetErrorMode(mode & !SEM_NOGPFAULTERRORBOX);\n \n     // Create a new job object for us to use\n-    let job = CreateJobObjectW(0 as *mut _, 0 as *const _);\n-    assert!(job != 0 as *mut _, \"{}\", io::Error::last_os_error());\n+    let job = CreateJobObjectW(ptr::null_mut(), ptr::null());\n+    assert!(!job.is_null(), \"{}\", io::Error::last_os_error());\n \n     // Indicate that when all handles to the job object are gone that all\n     // process in the object should be killed. Note that this includes our\n@@ -166,8 +167,8 @@ pub unsafe fn setup(build: &mut Build) {\n     };\n \n     let parent = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid.parse().unwrap());\n-    assert!(parent != 0 as *mut _, \"{}\", io::Error::last_os_error());\n-    let mut parent_handle = 0 as *mut _;\n+    assert!(!parent.is_null(), \"{}\", io::Error::last_os_error());\n+    let mut parent_handle = ptr::null_mut();\n     let r = DuplicateHandle(GetCurrentProcess(), job,\n                             parent, &mut parent_handle,\n                             0, FALSE, DUPLICATE_SAME_ACCESS);"}, {"sha": "b72aa78f3de191c330134764a625d3d251915177", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 18, "deletions": 38, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -103,8 +103,9 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-#![deny(rust_2018_idioms)]\n-#![deny(warnings)]\n+// NO-RUSTC-WRAPPER\n+#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n+\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n \n@@ -124,11 +125,11 @@ use std::os::unix::fs::symlink as symlink_file;\n use std::os::windows::fs::symlink_file;\n \n use build_helper::{\n-    mtime, output, run_silent, run_suppressed, t, try_run_silent, try_run_suppressed,\n+    mtime, output, run, run_suppressed, t, try_run, try_run_suppressed,\n };\n use filetime::FileTime;\n \n-use crate::util::{exe, libdir, OutputFolder, CiEnv};\n+use crate::util::{exe, libdir, CiEnv};\n \n mod cc_detect;\n mod channel;\n@@ -197,11 +198,11 @@ pub struct Compiler {\n \n #[derive(PartialEq, Eq, Copy, Clone, Debug)]\n pub enum DocTests {\n-    // Default, run normal tests and doc tests.\n+    /// Run normal tests and doc tests (default).\n     Yes,\n-    // Do not run any doc tests.\n+    /// Do not run any doc tests.\n     No,\n-    // Only run doc tests.\n+    /// Only run doc tests.\n     Only,\n }\n \n@@ -221,10 +222,10 @@ pub enum GitRepo {\n /// methods specifically on this structure itself (to make it easier to\n /// organize).\n pub struct Build {\n-    // User-specified configuration via config.toml\n+    /// User-specified configuration from `config.toml`.\n     config: Config,\n \n-    // Derived properties from the above two configurations\n+    // Properties derived from the above configuration\n     src: PathBuf,\n     out: PathBuf,\n     rust_info: channel::GitInfo,\n@@ -240,12 +241,12 @@ pub struct Build {\n     doc_tests: DocTests,\n     verbosity: usize,\n \n-    // Targets for which to build.\n+    // Targets for which to build\n     build: Interned<String>,\n     hosts: Vec<Interned<String>>,\n     targets: Vec<Interned<String>>,\n \n-    // Stage 0 (downloaded) compiler and cargo or their local rust equivalents.\n+    // Stage 0 (downloaded) compiler and cargo or their local rust equivalents\n     initial_rustc: PathBuf,\n     initial_cargo: PathBuf,\n \n@@ -255,7 +256,7 @@ pub struct Build {\n     cxx: HashMap<Interned<String>, cc::Tool>,\n     ar: HashMap<Interned<String>, PathBuf>,\n     ranlib: HashMap<Interned<String>, PathBuf>,\n-    // Misc\n+    // Miscellaneous\n     crates: HashMap<Interned<String>, Crate>,\n     is_sudo: bool,\n     ci_env: CiEnv,\n@@ -270,14 +271,9 @@ pub struct Build {\n #[derive(Debug)]\n struct Crate {\n     name: Interned<String>,\n-    version: String,\n     deps: HashSet<Interned<String>>,\n     id: String,\n     path: PathBuf,\n-    doc_step: String,\n-    build_step: String,\n-    test_step: String,\n-    bench_step: String,\n }\n \n impl Crate {\n@@ -544,9 +540,7 @@ impl Build {\n             Mode::Rustc => \"-rustc\",\n             Mode::Codegen => \"-codegen\",\n             Mode::ToolBootstrap => \"-bootstrap-tools\",\n-            Mode::ToolStd => \"-tools\",\n-            Mode::ToolTest => \"-tools\",\n-            Mode::ToolRustc => \"-tools\",\n+            Mode::ToolStd | Mode::ToolTest | Mode::ToolRustc => \"-tools\",\n         };\n         self.out.join(&*compiler.host)\n                 .join(format!(\"stage{}{}\", compiler.stage, suffix))\n@@ -686,7 +680,7 @@ impl Build {\n     fn run(&self, cmd: &mut Command) {\n         if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n-        run_silent(cmd)\n+        run(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n@@ -702,7 +696,7 @@ impl Build {\n     fn try_run(&self, cmd: &mut Command) -> bool {\n         if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n-        try_run_silent(cmd)\n+        try_run(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n@@ -1097,19 +1091,6 @@ impl Build {\n         }\n     }\n \n-    /// Fold the output of the commands after this method into a group. The fold\n-    /// ends when the returned object is dropped. Folding can only be used in\n-    /// the Travis CI environment.\n-    pub fn fold_output<D, F>(&self, name: F) -> Option<OutputFolder>\n-        where D: Into<String>, F: FnOnce() -> D\n-    {\n-        if !self.config.dry_run && self.ci_env == CiEnv::Travis {\n-            Some(OutputFolder::new(name().into()))\n-        } else {\n-            None\n-        }\n-    }\n-\n     /// Updates the actual toolstate of a tool.\n     ///\n     /// The toolstates are saved to the file specified by the key\n@@ -1214,8 +1195,7 @@ impl Build {\n     /// when this function is called.\n     pub fn cp_r(&self, src: &Path, dst: &Path) {\n         if self.config.dry_run { return; }\n-        for f in t!(fs::read_dir(src)) {\n-            let f = t!(f);\n+        for f in self.read_dir(src) {\n             let path = f.path();\n             let name = path.file_name().unwrap();\n             let dst = dst.join(name);\n@@ -1331,7 +1311,7 @@ fn chmod(path: &Path, perms: u32) {\n fn chmod(_path: &Path, _perms: u32) {}\n \n \n-impl<'a> Compiler {\n+impl Compiler {\n     pub fn with_stage(mut self, stage: u32) -> Compiler {\n         self.stage = stage;\n         self"}, {"sha": "b622b3682a7779c24fc25b8ca022cbfe7c26f3bb", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -20,7 +20,6 @@ struct Output {\n struct Package {\n     id: String,\n     name: String,\n-    version: String,\n     source: Option<String>,\n     manifest_path: String,\n }\n@@ -84,12 +83,7 @@ fn build_krate(features: &str, build: &mut Build, resolves: &mut Vec<ResolveNode\n             let mut path = PathBuf::from(package.manifest_path);\n             path.pop();\n             build.crates.insert(name, Crate {\n-                build_step: format!(\"build-crate-{}\", name),\n-                doc_step: format!(\"doc-crate-{}\", name),\n-                test_step: format!(\"test-crate-{}\", name),\n-                bench_step: format!(\"bench-crate-{}\", name),\n                 name,\n-                version: package.version,\n                 id: package.id,\n                 deps: HashSet::new(),\n                 path,"}, {"sha": "e0a1f46078d32295977e3b6f7832de077d2d21c9", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -48,10 +48,8 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/test/run-pass/pretty \\\n \t\tsrc/test/run-fail/pretty \\\n \t\tsrc/test/run-pass-valgrind/pretty \\\n-\t\tsrc/test/run-pass-fulldeps/pretty \\\n \t\t$(AUX_ARGS) \\\n \t\t$(BOOTSTRAP_ARGS)\n check-bootstrap:\n@@ -75,15 +73,22 @@ check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu:\n \n TESTS_IN_2 := \\\n \tsrc/test/ui \\\n-\tsrc/test/run-pass \\\n \tsrc/test/compile-fail \\\n-\tsrc/test/run-pass-fulldeps \\\n \tsrc/tools/linkchecker\n \n-appveyor-subset-1:\n+ci-subset-1:\n \t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2:%=--exclude %)\n-appveyor-subset-2:\n+ci-subset-2:\n \t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2)\n \n+TESTS_IN_MINGW_2 := \\\n+\tsrc/test/ui \\\n+\tsrc/test/compile-fail\n+\n+ci-mingw-subset-1:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_MINGW_2:%=--exclude %)\n+ci-mingw-subset-2:\n+\t$(Q)$(BOOTSTRAP) test $(TESTS_IN_MINGW_2)\n+\n \n .PHONY: dist"}, {"sha": "f02def3e1b05dcf0c32a94c7237af828903d0a65", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -104,7 +104,6 @@ impl Step for Llvm {\n             }\n         }\n \n-        let _folder = builder.fold_output(|| \"llvm\");\n         let descriptor = if emscripten { \"Emscripten \" } else { \"\" };\n         builder.info(&format!(\"Building {}LLVM for {}\", descriptor, target));\n         let _time = util::timeit(&builder);\n@@ -126,14 +125,18 @@ impl Step for Llvm {\n         } else {\n             match builder.config.llvm_targets {\n                 Some(ref s) => s,\n-                None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;MSP430;Sparc;NVPTX;Hexagon\",\n+                None => \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n+                         Sparc;SystemZ;WebAssembly;X86\",\n             }\n         };\n \n         let llvm_exp_targets = if self.emscripten {\n             \"\"\n         } else {\n-            &builder.config.llvm_experimental_targets[..]\n+            match builder.config.llvm_experimental_targets {\n+                Some(ref s) => s,\n+                None => \"\",\n+            }\n         };\n \n         let assertions = if builder.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n@@ -151,6 +154,7 @@ impl Step for Llvm {\n            .define(\"WITH_POLLY\", \"OFF\")\n            .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n            .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n+           .define(\"LLVM_ENABLE_Z3_SOLVER\", \"OFF\")\n            .define(\"LLVM_PARALLEL_COMPILE_JOBS\", builder.jobs().to_string())\n            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n@@ -203,8 +207,16 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n         }\n \n+        let mut enabled_llvm_projects = Vec::new();\n+\n+        if util::forcing_clang_based_tests() {\n+            enabled_llvm_projects.push(\"clang\");\n+            enabled_llvm_projects.push(\"compiler-rt\");\n+        }\n+\n         if want_lldb {\n-            cfg.define(\"LLVM_ENABLE_PROJECTS\", \"clang;lldb\");\n+            enabled_llvm_projects.push(\"clang\");\n+            enabled_llvm_projects.push(\"lldb\");\n             // For the time being, disable code signing.\n             cfg.define(\"LLDB_CODESIGN_IDENTITY\", \"\");\n             cfg.define(\"LLDB_NO_DEBUGSERVER\", \"ON\");\n@@ -214,6 +226,12 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n         }\n \n+        if enabled_llvm_projects.len() > 0 {\n+            enabled_llvm_projects.sort();\n+            enabled_llvm_projects.dedup();\n+            cfg.define(\"LLVM_ENABLE_PROJECTS\", enabled_llvm_projects.join(\";\"));\n+        }\n+\n         if let Some(num_linkers) = builder.config.llvm_link_jobs {\n             if num_linkers > 0 {\n                 cfg.define(\"LLVM_PARALLEL_LINK_JOBS\", num_linkers.to_string());\n@@ -402,7 +420,7 @@ fn configure_cmake(builder: &Builder<'_>,\n \n     cfg.build_arg(\"-j\").build_arg(builder.jobs().to_string());\n     let mut cflags = builder.cflags(target, GitRepo::Llvm).join(\" \");\n-    if let Some(ref s) = builder.config.llvm_cxxflags {\n+    if let Some(ref s) = builder.config.llvm_cflags {\n         cflags.push_str(&format!(\" {}\", s));\n     }\n     cfg.define(\"CMAKE_C_FLAGS\", cflags);\n@@ -479,7 +497,6 @@ impl Step for Lld {\n             return out_dir\n         }\n \n-        let _folder = builder.fold_output(|| \"lld\");\n         builder.info(&format!(\"Building LLD for {}\", target));\n         let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n@@ -534,7 +551,7 @@ impl Step for TestHelpers {\n     }\n \n     /// Compiles the `rust_test_helpers.c` library which we used in various\n-    /// `run-pass` test suites for ABI testing.\n+    /// `run-pass` tests for ABI testing.\n     fn run(self, builder: &Builder<'_>) {\n         if builder.config.dry_run {\n             return;\n@@ -546,7 +563,6 @@ impl Step for TestHelpers {\n             return\n         }\n \n-        let _folder = builder.fold_output(|| \"build_test_helpers\");\n         builder.info(\"Building test helpers\");\n         t!(fs::create_dir_all(&dst));\n         let mut cfg = cc::Build::new();"}, {"sha": "bffe748f37cc16270661c756ffa9b0099bb61be7", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -78,8 +78,11 @@ pub fn check(build: &mut Build) {\n \n     // We need cmake, but only if we're actually building LLVM or sanitizers.\n     let building_llvm = build.hosts.iter()\n-        .filter_map(|host| build.config.target_config.get(host))\n-        .any(|config| config.llvm_config.is_none());\n+        .map(|host| build.config.target_config\n+            .get(host)\n+            .map(|config| config.llvm_config.is_none())\n+            .unwrap_or(true))\n+        .any(|build_llvm_ourselves| build_llvm_ourselves);\n     if building_llvm || build.config.sanitizers {\n         cmd_finder.must_have(\"cmake\");\n     }\n@@ -106,6 +109,14 @@ pub fn check(build: &mut Build) {\n                 build.config.ninja = true;\n             }\n         }\n+\n+        if build.config.lldb_enabled {\n+            cmd_finder.must_have(\"swig\");\n+            let out = output(Command::new(\"swig\").arg(\"-version\"));\n+            if !out.contains(\"SWIG Version 3\") && !out.contains(\"SWIG Version 4\") {\n+                panic!(\"Ensure that Swig 3.x.x or 4.x.x is installed.\");\n+            }\n+        }\n     }\n \n     build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))\n@@ -191,10 +202,6 @@ pub fn check(build: &mut Build) {\n                         panic!(\"couldn't find libc.a in musl dir: {}\",\n                                root.join(\"lib\").display());\n                     }\n-                    if fs::metadata(root.join(\"lib/libunwind.a\")).is_err() {\n-                        panic!(\"couldn't find libunwind.a in musl dir: {}\",\n-                               root.join(\"lib\").display());\n-                    }\n                 }\n                 None => {\n                     panic!(\"when targeting MUSL either the rust.musl-root \\"}, {"sha": "c2c134bfd1d7da7d1a7225e448a62810e9873d74", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 129, "deletions": 89, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -229,6 +229,9 @@ impl Step for Cargo {\n         cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n         // Disable a test that has issues with mingw.\n         cargo.env(\"CARGO_TEST_DISABLE_GIT_CLI\", \"1\");\n+        // Forcibly disable tests using nightly features since any changes to\n+        // those features won't be able to land.\n+        cargo.env(\"CARGO_TEST_DISABLE_NIGHTLY\", \"1\");\n \n         try_run(\n             builder,\n@@ -360,11 +363,9 @@ pub struct Miri {\n impl Step for Miri {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let test_miri = run.builder.config.test_miri;\n-        run.path(\"src/tools/miri\").default_condition(test_miri)\n+        run.path(\"src/tools/miri\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -386,26 +387,92 @@ impl Step for Miri {\n             extra_features: Vec::new(),\n         });\n         if let Some(miri) = miri {\n-            let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 Mode::ToolRustc,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/miri\",\n-                                                 SourceType::Submodule,\n-                                                 &[]);\n+            // # Run `cargo miri setup`.\n+            // As a side-effect, this will install xargo.\n+            let mut cargo = tool::prepare_tool_cargo(\n+                builder,\n+                compiler,\n+                Mode::ToolRustc,\n+                host,\n+                \"run\",\n+                \"src/tools/miri\",\n+                SourceType::Submodule,\n+                &[],\n+            );\n+            cargo\n+                .arg(\"--bin\")\n+                .arg(\"cargo-miri\")\n+                .arg(\"--\")\n+                .arg(\"miri\")\n+                .arg(\"setup\");\n+\n+            // Tell `cargo miri` not to worry about the sysroot mismatch (we built with\n+            // stage1 but run with stage2).\n+            cargo.env(\"MIRI_SKIP_SYSROOT_CHECK\", \"1\");\n+            // Tell `cargo miri setup` where to find the sources.\n+            cargo.env(\"XARGO_RUST_SRC\", builder.src.join(\"src\"));\n+            // Debug things.\n+            cargo.env(\"RUST_BACKTRACE\", \"1\");\n+            // Configure `cargo install` path, and let cargo-miri know that that's where\n+            // xargo ends up.\n+            cargo.env(\"CARGO_INSTALL_ROOT\", &builder.out); // cargo adds a `bin/`\n+            cargo.env(\"XARGO\", builder.out.join(\"bin\").join(\"xargo\"));\n+\n+            if !try_run(builder, &mut cargo) {\n+                return;\n+            }\n+\n+            // # Determine where Miri put its sysroot.\n+            // To this end, we run `cargo miri setup --env` and capture the output.\n+            // (We do this separately from the above so that when the setup actually\n+            // happens we get some output.)\n+            // We re-use the `cargo` from above.\n+            cargo.arg(\"--env\");\n+\n+            // FIXME: Is there a way in which we can re-use the usual `run` helpers?\n+            let miri_sysroot = if builder.config.dry_run {\n+                String::new()\n+            } else {\n+                builder.verbose(&format!(\"running: {:?}\", cargo));\n+                let out = cargo.output()\n+                    .expect(\"We already ran `cargo miri setup` before and that worked\");\n+                assert!(out.status.success(), \"`cargo miri setup` returned with non-0 exit code\");\n+                // Output is \"MIRI_SYSROOT=<str>\\n\".\n+                let stdout = String::from_utf8(out.stdout)\n+                    .expect(\"`cargo miri setup` stdout is not valid UTF-8\");\n+                let stdout = stdout.trim();\n+                builder.verbose(&format!(\"`cargo miri setup --env` returned: {:?}\", stdout));\n+                let sysroot = stdout.splitn(2, '=')\n+                    .nth(1).expect(\"`cargo miri setup` stdout did not contain '='\");\n+                sysroot.to_owned()\n+            };\n+\n+            // # Run `cargo test`.\n+            let mut cargo = tool::prepare_tool_cargo(\n+                builder,\n+                compiler,\n+                Mode::ToolRustc,\n+                host,\n+                \"test\",\n+                \"src/tools/miri\",\n+                SourceType::Submodule,\n+                &[],\n+            );\n \n             // miri tests need to know about the stage sysroot\n-            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"MIRI_SYSROOT\", miri_sysroot);\n             cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n             cargo.env(\"MIRI_PATH\", miri);\n \n             builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-            if try_run(builder, &mut cargo) {\n-                builder.save_toolstate(\"miri\", ToolState::TestPass);\n+            if !try_run(builder, &mut cargo) {\n+                return;\n             }\n+\n+            // # Done!\n+            builder.save_toolstate(\"miri\", ToolState::TestPass);\n         } else {\n             eprintln!(\"failed to test miri: could not build\");\n         }\n@@ -683,7 +750,7 @@ impl Step for RustdocUi {\n             target: self.target,\n             mode: \"ui\",\n             suite: \"rustdoc-ui\",\n-            path: None,\n+            path: Some(\"src/test/rustdoc-ui\"),\n             compare_mode: None,\n         })\n     }\n@@ -709,11 +776,10 @@ impl Step for Tidy {\n         if !builder.config.vendor {\n             cmd.arg(\"--no-vendor\");\n         }\n-        if !builder.config.verbose_tests {\n-            cmd.arg(\"--quiet\");\n+        if builder.is_verbose() {\n+            cmd.arg(\"--verbose\");\n         }\n \n-        let _folder = builder.fold_output(|| \"tidy\");\n         builder.info(\"tidy check\");\n         try_run(builder, &mut cmd);\n     }\n@@ -821,13 +887,6 @@ default_test_with_compare_mode!(Ui {\n     compare_mode: \"nll\"\n });\n \n-default_test_with_compare_mode!(RunPass {\n-    path: \"src/test/run-pass\",\n-    mode: \"run-pass\",\n-    suite: \"run-pass\",\n-    compare_mode: \"nll\"\n-});\n-\n default_test!(CompileFail {\n     path: \"src/test/compile-fail\",\n     mode: \"compile-fail\",\n@@ -882,12 +941,6 @@ host_test!(UiFullDeps {\n     suite: \"ui-fulldeps\"\n });\n \n-host_test!(RunPassFullDeps {\n-    path: \"src/test/run-pass-fulldeps\",\n-    mode: \"run-pass\",\n-    suite: \"run-pass-fulldeps\"\n-});\n-\n host_test!(Rustdoc {\n     path: \"src/test/rustdoc\",\n     mode: \"rustdoc\",\n@@ -899,13 +952,6 @@ host_test!(Pretty {\n     mode: \"pretty\",\n     suite: \"pretty\"\n });\n-test!(RunPassPretty {\n-    path: \"src/test/run-pass/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-pass\",\n-    default: false,\n-    host: true\n-});\n test!(RunFailPretty {\n     path: \"src/test/run-fail/pretty\",\n     mode: \"pretty\",\n@@ -976,14 +1022,10 @@ impl Step for Compiletest {\n         }\n \n         if suite == \"debuginfo\" {\n-            // Skip debuginfo tests on MSVC\n-            if builder.config.build.contains(\"msvc\") {\n-                return;\n-            }\n-\n+            let msvc = builder.config.build.contains(\"msvc\");\n             if mode == \"debuginfo\" {\n                 return builder.ensure(Compiletest {\n-                    mode: \"debuginfo-both\",\n+                    mode: if msvc { \"debuginfo-cdb\" } else { \"debuginfo-gdb+lldb\" },\n                     ..self\n                 });\n             }\n@@ -1069,6 +1111,11 @@ impl Step for Compiletest {\n             }\n         });\n \n+        if let Some(ref pass) = builder.config.cmd.pass() {\n+            cmd.arg(\"--pass\");\n+            cmd.arg(pass);\n+        }\n+\n         if let Some(ref nodejs) = builder.config.nodejs {\n             cmd.arg(\"--nodejs\").arg(nodejs);\n         }\n@@ -1082,10 +1129,8 @@ impl Step for Compiletest {\n             if builder.config.rust_optimize_tests {\n                 flags.push(\"-O\".to_string());\n             }\n-            if builder.config.rust_debuginfo_tests {\n-                flags.push(\"-g\".to_string());\n-            }\n         }\n+        flags.push(format!(\"-Cdebuginfo={}\", builder.config.rust_debuginfo_level_tests));\n         flags.push(\"-Zunstable-options\".to_string());\n         flags.push(builder.config.cmd.rustc_args().join(\" \"));\n \n@@ -1149,24 +1194,9 @@ impl Step for Compiletest {\n             }\n         }\n \n-        if let Some(var) = env::var_os(\"RUSTBUILD_FORCE_CLANG_BASED_TESTS\") {\n-            match &var.to_string_lossy().to_lowercase()[..] {\n-                \"1\" | \"yes\" | \"on\" => {\n-                    assert!(builder.config.lldb_enabled,\n-                        \"RUSTBUILD_FORCE_CLANG_BASED_TESTS needs Clang/LLDB to \\\n-                         be built.\");\n-                    let clang_exe = builder.llvm_out(target).join(\"bin\").join(\"clang\");\n-                    cmd.arg(\"--run-clang-based-tests-with\").arg(clang_exe);\n-                }\n-                \"0\" | \"no\" | \"off\" => {\n-                    // Nothing to do.\n-                }\n-                other => {\n-                    // Let's make sure typos don't get unnoticed\n-                    panic!(\"Unrecognized option '{}' set in \\\n-                            RUSTBUILD_FORCE_CLANG_BASED_TESTS\", other);\n-                }\n-            }\n+        if util::forcing_clang_based_tests() {\n+            let clang_exe = builder.llvm_out(target).join(\"bin\").join(\"clang\");\n+            cmd.arg(\"--run-clang-based-tests-with\").arg(clang_exe);\n         }\n \n         // Get paths from cmd args\n@@ -1326,7 +1356,6 @@ impl Step for Compiletest {\n \n         builder.ci_env.force_coloring_in_ci(&mut cmd);\n \n-        let _folder = builder.fold_output(|| format!(\"test_{}\", suite));\n         builder.info(&format!(\n             \"Check compiletest suite={} mode={} ({} -> {})\",\n             suite, mode, &compiler.host, target\n@@ -1336,7 +1365,6 @@ impl Step for Compiletest {\n \n         if let Some(compare_mode) = compare_mode {\n             cmd.arg(\"--compare-mode\").arg(compare_mode);\n-            let _folder = builder.fold_output(|| format!(\"test_{}_{}\", suite, compare_mode));\n             builder.info(&format!(\n                 \"Check compiletest suite={} mode={} compare_mode={} ({} -> {})\",\n                 suite, mode, compare_mode, &compiler.host, target\n@@ -1380,7 +1408,6 @@ impl Step for DocTest {\n         // tests for all files that end in `*.md`\n         let mut stack = vec![builder.src.join(self.path)];\n         let _time = util::timeit(&builder);\n-        let _folder = builder.fold_output(|| format!(\"test_{}\", self.name));\n \n         let mut files = Vec::new();\n         while let Some(p) = stack.pop() {\n@@ -1511,10 +1538,9 @@ impl Step for ErrorIndex {\n             .env(\"CFG_BUILD\", &builder.config.build)\n             .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n \n-        let _folder = builder.fold_output(|| \"test_error_index\");\n         builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n         let _time = util::timeit(&builder);\n-        builder.run(&mut tool);\n+        builder.run_quiet(&mut tool);\n         markdown_test(builder, compiler, &output);\n     }\n }\n@@ -1546,6 +1572,34 @@ fn markdown_test(builder: &Builder<'_>, compiler: Compiler, markdown: &Path) ->\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct RustcGuide;\n+\n+impl Step for RustcGuide {\n+    type Output = ();\n+    const DEFAULT: bool = false;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/doc/rustc-guide\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(RustcGuide);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        let src = builder.src.join(\"src/doc/rustc-guide\");\n+        let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n+        let toolstate = if try_run(builder, rustbook_cmd.arg(\"linkcheck\").arg(&src)) {\n+            ToolState::TestPass\n+        } else {\n+            ToolState::TestFail\n+        };\n+        builder.save_toolstate(\"rustc-guide\", toolstate);\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateLibrustc {\n     compiler: Compiler,\n@@ -1711,15 +1765,11 @@ impl Step for Crate {\n         builder.ensure(compile::Test { compiler, target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n-        // If we're not doing a full bootstrap but we're testing a stage2 version of\n-        // libstd, then what we're actually testing is the libstd produced in\n-        // stage1. Reflect that here by updating the compiler that we're working\n-        // with automatically.\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n+        // If we're not doing a full bootstrap but we're testing a stage2\n+        // version of libstd, then what we're actually testing is the libstd\n+        // produced in stage1. Reflect that here by updating the compiler that\n+        // we're working with automatically.\n+        let compiler = builder.compiler_for(compiler.stage, compiler.host, target);\n \n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n         match mode {\n@@ -1814,14 +1864,6 @@ impl Step for Crate {\n             );\n         }\n \n-        let _folder = builder.fold_output(|| {\n-            format!(\n-                \"{}_stage{}-{}\",\n-                test_kind.subcommand(),\n-                compiler.stage,\n-                krate\n-            )\n-        });\n         builder.info(&format!(\n             \"{} {} stage{} ({} -> {})\",\n             test_kind, krate, compiler.stage, &compiler.host, target\n@@ -1889,8 +1931,6 @@ impl Step for CrateRustdoc {\n             cargo.arg(\"--quiet\");\n         }\n \n-        let _folder = builder\n-            .fold_output(|| format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage));\n         builder.info(&format!(\n             \"{} rustdoc stage{} ({} -> {})\",\n             test_kind, compiler.stage, &compiler.host, target"}, {"sha": "df7eb7c455d0267922fc6bf07fac90c85c02a1f0", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 96, "deletions": 66, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -9,7 +9,7 @@ use build_helper::t;\n use crate::Mode;\n use crate::Compiler;\n use crate::builder::{Step, RunConfig, ShouldRun, Builder};\n-use crate::util::{exe, add_lib_path};\n+use crate::util::{exe, add_lib_path, CiEnv};\n use crate::compile;\n use crate::channel::GitInfo;\n use crate::channel;\n@@ -74,16 +74,16 @@ impl Step for ToolBuild {\n             &self.extra_features,\n         );\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n         builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n         let mut duplicates = Vec::new();\n-        let is_expected = compile::stream_cargo(builder, &mut cargo, &mut |msg| {\n+        let is_expected = compile::stream_cargo(builder, &mut cargo, vec![], &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n             match tool {\n                 | \"rls\"\n                 | \"cargo\"\n                 | \"clippy-driver\"\n                 | \"miri\"\n+                | \"rustfmt\"\n                 => {}\n \n                 _ => return,\n@@ -108,36 +108,63 @@ impl Step for ToolBuild {\n                     continue\n                 }\n \n-                // Don't worry about libs that turn out to be host dependencies\n-                // or build scripts, we only care about target dependencies that\n-                // are in `deps`.\n-                if let Some(maybe_target) = val.1\n-                    .parent()                   // chop off file name\n-                    .and_then(|p| p.parent())   // chop off `deps`\n-                    .and_then(|p| p.parent())   // chop off `release`\n-                    .and_then(|p| p.file_name())\n-                    .and_then(|p| p.to_str())\n-                {\n-                    if maybe_target != &*target {\n-                        continue\n+                // Don't worry about compiles that turn out to be host\n+                // dependencies or build scripts. To skip these we look for\n+                // anything that goes in `.../release/deps` but *doesn't* go in\n+                // `$target/release/deps`. This ensure that outputs in\n+                // `$target/release` are still considered candidates for\n+                // deduplication.\n+                if let Some(parent) = val.1.parent() {\n+                    if parent.ends_with(\"release/deps\") {\n+                        let maybe_target = parent\n+                            .parent()\n+                            .and_then(|p| p.parent())\n+                            .and_then(|p| p.file_name())\n+                            .and_then(|p| p.to_str())\n+                            .unwrap();\n+                        if maybe_target != &*target {\n+                            continue;\n+                        }\n                     }\n                 }\n \n+                // Record that we've built an artifact for `id`, and if one was\n+                // already listed then we need to see if we reused the same\n+                // artifact or produced a duplicate.\n                 let mut artifacts = builder.tool_artifacts.borrow_mut();\n                 let prev_artifacts = artifacts\n                     .entry(target)\n                     .or_default();\n-                if let Some(prev) = prev_artifacts.get(&*id) {\n-                    if prev.1 != val.1 {\n-                        duplicates.push((\n-                            id.to_string(),\n-                            val,\n-                            prev.clone(),\n-                        ));\n+                let prev = match prev_artifacts.get(&*id) {\n+                    Some(prev) => prev,\n+                    None => {\n+                        prev_artifacts.insert(id.to_string(), val);\n+                        continue;\n                     }\n-                    return\n+                };\n+                if prev.1 == val.1 {\n+                    return; // same path, same artifact\n                 }\n-                prev_artifacts.insert(id.to_string(), val);\n+\n+                // If the paths are different and one of them *isn't* inside of\n+                // `release/deps`, then it means it's probably in\n+                // `$target/release`, or it's some final artifact like\n+                // `libcargo.rlib`. In these situations Cargo probably just\n+                // copied it up from `$target/release/deps/libcargo-xxxx.rlib`,\n+                // so if the features are equal we can just skip it.\n+                let prev_no_hash = prev.1.parent().unwrap().ends_with(\"release/deps\");\n+                let val_no_hash = val.1.parent().unwrap().ends_with(\"release/deps\");\n+                if prev.2 == val.2 || !prev_no_hash || !val_no_hash {\n+                    return;\n+                }\n+\n+                // ... and otherwise this looks like we duplicated some sort of\n+                // compilation, so record it to generate an error later.\n+                duplicates.push((\n+                    id.to_string(),\n+                    val,\n+                    prev.clone(),\n+                ));\n             }\n         });\n \n@@ -252,11 +279,26 @@ pub fn prepare_tool_cargo(\n     cargo\n }\n \n+fn rustbook_features() -> Vec<String> {\n+    let mut features = Vec::new();\n+\n+    // Due to CI budged and risk of spurious failures we want to limit jobs running this check.\n+    // At same time local builds should run it regardless of the platform.\n+    // `CiEnv::None` means it's local build and `CHECK_LINKS` is defined in x86_64-gnu-tools to\n+    // explicitly enable it on single job\n+    if CiEnv::current() == CiEnv::None || env::var(\"CHECK_LINKS\").is_ok() {\n+        features.push(\"linkcheck\".to_string());\n+    }\n+\n+    features\n+}\n+\n macro_rules! bootstrap_tool {\n     ($(\n         $name:ident, $path:expr, $tool_name:expr\n         $(,llvm_tools = $llvm:expr)*\n         $(,is_external_tool = $external:expr)*\n+        $(,features = $features:expr)*\n         ;\n     )+) => {\n         #[derive(Copy, PartialEq, Eq, Clone)]\n@@ -267,10 +309,6 @@ macro_rules! bootstrap_tool {\n         }\n \n         impl Tool {\n-            pub fn get_mode(&self) -> Mode {\n-                Mode::ToolBootstrap\n-            }\n-\n             /// Whether this tool requires LLVM to run\n             pub fn uses_llvm_tools(&self) -> bool {\n                 match self {\n@@ -327,7 +365,12 @@ macro_rules! bootstrap_tool {\n                     } else {\n                         SourceType::InTree\n                     },\n-                    extra_features: Vec::new(),\n+                    extra_features: {\n+                        // FIXME(#60643): avoid this lint by using `_`\n+                        let mut _tmp = Vec::new();\n+                        $(_tmp.extend($features);)*\n+                        _tmp\n+                    },\n                 }).expect(\"expected to build -- essential tool\")\n             }\n         }\n@@ -336,7 +379,7 @@ macro_rules! bootstrap_tool {\n }\n \n bootstrap_tool!(\n-    Rustbook, \"src/tools/rustbook\", \"rustbook\";\n+    Rustbook, \"src/tools/rustbook\", \"rustbook\", features = rustbook_features();\n     UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\";\n     Tidy, \"src/tools/tidy\", \"tidy\";\n     Linkchecker, \"src/tools/linkchecker\", \"linkchecker\";\n@@ -485,11 +528,6 @@ impl Step for Rustdoc {\n             &[],\n         );\n \n-        // Most tools don't get debuginfo, but rustdoc should.\n-        cargo.env(\"RUSTC_DEBUGINFO\", builder.config.rust_debuginfo.to_string())\n-             .env(\"RUSTC_DEBUGINFO_LINES\", builder.config.rust_debuginfo_lines.to_string());\n-\n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n         builder.info(&format!(\"Building rustdoc for stage{} ({})\",\n             target_compiler.stage, target_compiler.host));\n         builder.run(&mut cargo);\n@@ -539,9 +577,9 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        // Cargo depends on procedural macros, which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Cargo depends on procedural macros, so make sure the host\n+        // libstd/libproc_macro is available.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n@@ -613,26 +651,26 @@ macro_rules! tool_extended {\n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n     CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {\n-        // Clippy depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Clippy depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n     };\n     Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n-        // Clippy depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Clippy depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n     };\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n     CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {\n-        // Miri depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Miri depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n@@ -646,9 +684,9 @@ tool_extended!((self, builder),\n         if clippy.is_some() {\n             self.extra_features.push(\"clippy\".to_owned());\n         }\n-        // RLS depends on procedural macros, which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // RLS depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n@@ -662,23 +700,14 @@ impl<'a> Builder<'a> {\n     pub fn tool_cmd(&self, tool: Tool) -> Command {\n         let mut cmd = Command::new(self.tool_exe(tool));\n         let compiler = self.compiler(0, self.config.build);\n-        self.prepare_tool_cmd(compiler, tool, &mut cmd);\n-        cmd\n-    }\n-\n-    /// Prepares the `cmd` provided to be able to run the `compiler` provided.\n-    ///\n-    /// Notably this munges the dynamic library lookup path to point to the\n-    /// right location to run `compiler`.\n-    fn prepare_tool_cmd(&self, compiler: Compiler, tool: Tool, cmd: &mut Command) {\n         let host = &compiler.host;\n+        // Prepares the `cmd` provided to be able to run the `compiler` provided.\n+        //\n+        // Notably this munges the dynamic library lookup path to point to the\n+        // right location to run `compiler`.\n         let mut lib_paths: Vec<PathBuf> = vec![\n-            if compiler.stage == 0 {\n-                self.build.rustc_snapshot_libdir()\n-            } else {\n-                PathBuf::from(&self.sysroot_libdir(compiler, compiler.host))\n-            },\n-            self.cargo_out(compiler, tool.get_mode(), *host).join(\"deps\"),\n+            self.build.rustc_snapshot_libdir(),\n+            self.cargo_out(compiler, Mode::ToolBootstrap, *host).join(\"deps\"),\n         ];\n \n         // On MSVC a tool may invoke a C compiler (e.g., compiletest in run-make\n@@ -699,6 +728,7 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        add_lib_path(lib_paths, cmd);\n+        add_lib_path(lib_paths, &mut cmd);\n+        cmd\n     }\n }"}, {"sha": "98ae7b692bb3c7524bc01bde8bbfea1b799f8fcf", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 23, "deletions": 73, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -6,10 +6,10 @@\n use std::env;\n use std::str;\n use std::fs;\n-use std::io::{self, Write};\n+use std::io;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n-use std::time::{SystemTime, Instant};\n+use std::time::Instant;\n \n use build_helper::t;\n \n@@ -209,7 +209,7 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n             let h = CreateFileW(path.as_ptr(),\n                                 GENERIC_WRITE,\n                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n-                                0 as *mut _,\n+                                ptr::null_mut(),\n                                 OPEN_EXISTING,\n                                 FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,\n                                 ptr::null_mut());\n@@ -254,87 +254,21 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n     }\n }\n \n-/// An RAII structure that indicates all output until this instance is dropped\n-/// is part of the same group.\n-///\n-/// On Travis CI, these output will be folded by default, together with the\n-/// elapsed time in this block. This reduces noise from unnecessary logs,\n-/// allowing developers to quickly identify the error.\n-///\n-/// Travis CI supports folding by printing `travis_fold:start:<name>` and\n-/// `travis_fold:end:<name>` around the block. Time elapsed is recognized\n-/// similarly with `travis_time:[start|end]:<name>`. These are undocumented, but\n-/// can easily be deduced from source code of the [Travis build commands].\n-///\n-/// [Travis build commands]:\n-/// https://github.com/travis-ci/travis-build/blob/f603c0089/lib/travis/build/templates/header.sh\n-pub struct OutputFolder {\n-    name: String,\n-    start_time: SystemTime, // we need SystemTime to get the UNIX timestamp.\n-}\n-\n-impl OutputFolder {\n-    /// Creates a new output folder with the given group name.\n-    pub fn new(name: String) -> OutputFolder {\n-        // \"\\r\" moves the cursor to the beginning of the line, and \"\\x1b[0K\" is\n-        // the ANSI escape code to clear from the cursor to end of line.\n-        // Travis seems to have trouble when _not_ using \"\\r\\x1b[0K\", that will\n-        // randomly put lines to the top of the webpage.\n-        print!(\"travis_fold:start:{0}\\r\\x1b[0Ktravis_time:start:{0}\\r\\x1b[0K\", name);\n-        OutputFolder {\n-            name,\n-            start_time: SystemTime::now(),\n-        }\n-    }\n-}\n-\n-impl Drop for OutputFolder {\n-    fn drop(&mut self) {\n-        use std::time::*;\n-        use std::u64;\n-\n-        fn to_nanos(duration: Result<Duration, SystemTimeError>) -> u64 {\n-            match duration {\n-                Ok(d) => d.as_secs() * 1_000_000_000 + d.subsec_nanos() as u64,\n-                Err(_) => u64::MAX,\n-            }\n-        }\n-\n-        let end_time = SystemTime::now();\n-        let duration = end_time.duration_since(self.start_time);\n-        let start = self.start_time.duration_since(UNIX_EPOCH);\n-        let finish = end_time.duration_since(UNIX_EPOCH);\n-        println!(\n-            \"travis_fold:end:{0}\\r\\x1b[0K\\n\\\n-                travis_time:end:{0}:start={1},finish={2},duration={3}\\r\\x1b[0K\",\n-            self.name,\n-            to_nanos(start),\n-            to_nanos(finish),\n-            to_nanos(duration)\n-        );\n-        io::stdout().flush().unwrap();\n-    }\n-}\n-\n /// The CI environment rustbuild is running in. This mainly affects how the logs\n /// are printed.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum CiEnv {\n     /// Not a CI environment.\n     None,\n-    /// The Travis CI environment, for Linux (including Docker) and macOS builds.\n-    Travis,\n-    /// The AppVeyor environment, for Windows builds.\n-    AppVeyor,\n+    /// The Azure Pipelines environment, for Linux (including Docker), Windows, and macOS builds.\n+    AzurePipelines,\n }\n \n impl CiEnv {\n     /// Obtains the current CI environment.\n     pub fn current() -> CiEnv {\n-        if env::var(\"TRAVIS\").ok().map_or(false, |e| &*e == \"true\") {\n-            CiEnv::Travis\n-        } else if env::var(\"APPVEYOR\").ok().map_or(false, |e| &*e == \"True\") {\n-            CiEnv::AppVeyor\n+        if env::var(\"TF_BUILD\").ok().map_or(false, |e| &*e == \"True\") {\n+            CiEnv::AzurePipelines\n         } else {\n             CiEnv::None\n         }\n@@ -352,3 +286,19 @@ impl CiEnv {\n         }\n     }\n }\n+\n+pub fn forcing_clang_based_tests() -> bool {\n+    if let Some(var) = env::var_os(\"RUSTBUILD_FORCE_CLANG_BASED_TESTS\") {\n+        match &var.to_string_lossy().to_lowercase()[..] {\n+            \"1\" | \"yes\" | \"on\" => true,\n+            \"0\" | \"no\" | \"off\" => false,\n+            other => {\n+                // Let's make sure typos don't go unnoticed\n+                panic!(\"Unrecognized option '{}' set in \\\n+                        RUSTBUILD_FORCE_CLANG_BASED_TESTS\", other)\n+            }\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "a1aa18922b5c5b9ccac1712c0033ce7e13e959d6", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,4 +1,5 @@\n-#![deny(rust_2018_idioms)]\n+// NO-RUSTC-WRAPPER\n+#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n \n use std::fs::File;\n use std::path::{Path, PathBuf};\n@@ -44,18 +45,19 @@ pub fn restore_library_path() {\n     }\n }\n \n-pub fn run(cmd: &mut Command) {\n+/// Run the command, printing what we are running.\n+pub fn run_verbose(cmd: &mut Command) {\n     println!(\"running: {:?}\", cmd);\n-    run_silent(cmd);\n+    run(cmd);\n }\n \n-pub fn run_silent(cmd: &mut Command) {\n-    if !try_run_silent(cmd) {\n+pub fn run(cmd: &mut Command) {\n+    if !try_run(cmd) {\n         std::process::exit(1);\n     }\n }\n \n-pub fn try_run_silent(cmd: &mut Command) -> bool {\n+pub fn try_run(cmd: &mut Command) -> bool {\n     let status = match cmd.status() {\n         Ok(status) => status,\n         Err(e) => fail(&format!(\n@@ -288,9 +290,9 @@ pub fn sanitizer_lib_boilerplate(sanitizer_name: &str)\n     } else {\n         format!(\"static={}\", link_name)\n     };\n-    // The source for `compiler-rt` comes from the `compiler-builtins` crate, so\n-    // load our env var set by cargo to find the source code.\n-    let dir = env::var_os(\"DEP_COMPILER_RT_COMPILER_RT\").unwrap();\n+    // This env var is provided by rustbuild to tell us where `compiler-rt`\n+    // lives.\n+    let dir = env::var_os(\"RUST_COMPILER_RT_ROOT\").unwrap();\n     let lib = native_lib_boilerplate(\n         dir.as_ref(),\n         sanitizer_name,"}, {"sha": "77c9cda58b8e6d8312ed9a9c7c8fdb4f9d92d344", "filename": "src/ci/azure-pipelines/auto.yml", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,350 @@\n+#\n+# Azure Pipelines \"auto\" branch build for Rust on Linux, macOS, and Windows.\n+#\n+\n+pr: none\n+trigger:\n+  - auto\n+\n+variables:\n+- group: real-prod-credentials\n+\n+jobs:\n+- job: Linux\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: ubuntu-16.04\n+  steps:\n+  - template: steps/run.yml\n+  strategy:\n+    matrix:\n+      x86_64-gnu-llvm-6.0:\n+        IMAGE: x86_64-gnu-llvm-6.0\n+        RUST_BACKTRACE: 1\n+\n+      dist-x86_64-linux:\n+        IMAGE: dist-x86_64-linux\n+        DEPLOY: 1\n+\n+      # \"alternate\" deployments, these are \"nightlies\" but have LLVM assertions\n+      # turned on, they're deployed to a different location primarily for\n+      # additional testing.\n+      dist-x86_64-linux-alt:\n+        IMAGE: dist-x86_64-linux\n+        DEPLOY_ALT: 1\n+\n+      # Linux builders, remaining docker images\n+      arm-android:\n+        IMAGE: arm-android\n+\n+      armhf-gnu:\n+        IMAGE: armhf-gnu\n+\n+      dist-various-1:\n+        IMAGE: dist-various-1\n+        DEPLOY: 1\n+\n+      dist-various-2:\n+        IMAGE: dist-various-2\n+        DEPLOY: 1\n+\n+      dist-aarch64-linux:\n+        IMAGE: dist-aarch64-linux\n+        DEPLOY: 1\n+\n+      dist-android:\n+        IMAGE: dist-android\n+        DEPLOY: 1\n+\n+      dist-arm-linux:\n+        IMAGE: dist-arm-linux\n+        DEPLOY: 1\n+\n+      dist-armhf-linux:\n+        IMAGE: dist-armhf-linux\n+        DEPLOY: 1\n+\n+      dist-armv7-linux:\n+        IMAGE: dist-armv7-linux\n+        DEPLOY: 1\n+\n+      dist-i586-gnu-i586-i686-musl:\n+        IMAGE: dist-i586-gnu-i586-i686-musl\n+        DEPLOY: 1\n+\n+      dist-i686-freebsd:\n+        IMAGE: dist-i686-freebsd\n+        DEPLOY: 1\n+\n+      dist-i686-linux:\n+        IMAGE: dist-i686-linux\n+        DEPLOY: 1\n+\n+      dist-mips-linux:\n+        IMAGE: dist-mips-linux\n+        DEPLOY: 1\n+\n+      dist-mips64-linux:\n+        IMAGE: dist-mips64-linux\n+        DEPLOY: 1\n+\n+      dist-mips64el-linux:\n+        IMAGE: dist-mips64el-linux\n+        DEPLOY: 1\n+\n+      dist-mipsel-linux:\n+        IMAGE: dist-mipsel-linux\n+        DEPLOY: 1\n+\n+      dist-powerpc-linux:\n+        IMAGE: dist-powerpc-linux\n+        DEPLOY: 1\n+\n+      dist-powerpc64-linux:\n+        IMAGE: dist-powerpc64-linux\n+        DEPLOY: 1\n+\n+      dist-powerpc64le-linux:\n+        IMAGE: dist-powerpc64le-linux\n+        DEPLOY: 1\n+\n+      dist-s390x-linux:\n+        IMAGE: dist-s390x-linux\n+        DEPLOY: 1\n+\n+      dist-x86_64-freebsd:\n+        IMAGE: dist-x86_64-freebsd\n+        DEPLOY: 1\n+\n+      dist-x86_64-musl:\n+        IMAGE: dist-x86_64-musl\n+        DEPLOY: 1\n+\n+      dist-x86_64-netbsd:\n+        IMAGE: dist-x86_64-netbsd\n+        DEPLOY: 1\n+\n+      asmjs:\n+        IMAGE: asmjs\n+      i686-gnu:\n+        IMAGE: i686-gnu\n+      i686-gnu-nopt:\n+        IMAGE: i686-gnu-nopt\n+      test-various:\n+        IMAGE: test-various\n+      x86_64-gnu:\n+        IMAGE: x86_64-gnu\n+      x86_64-gnu-full-bootstrap:\n+        IMAGE: x86_64-gnu-full-bootstrap\n+      x86_64-gnu-aux:\n+        IMAGE: x86_64-gnu-aux\n+      x86_64-gnu-tools:\n+        IMAGE: x86_64-gnu-tools\n+      x86_64-gnu-debug:\n+        IMAGE: x86_64-gnu-debug\n+      x86_64-gnu-nopt:\n+        IMAGE: x86_64-gnu-nopt\n+      x86_64-gnu-distcheck:\n+        IMAGE: x86_64-gnu-distcheck\n+      mingw-check:\n+        IMAGE: mingw-check\n+\n+- job: macOS\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: macos-10.13\n+  steps:\n+  - template: steps/run.yml\n+  strategy:\n+    matrix:\n+      # OSX builders running tests, these run the full test suite.\n+      # NO_DEBUG_ASSERTIONS=1 to make them go faster, but also do have some\n+      # runners that run `//ignore-debug` tests.\n+      #\n+      # Note that the compiler is compiled to target 10.8 here because the Xcode\n+      # version that we're using, 8.2, cannot compile LLVM for OSX 10.7.\n+      x86_64-apple:\n+        SCRIPT: ./x.py test\n+        RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n+        RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+        MACOSX_DEPLOYMENT_TARGET: 10.8\n+        MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+        NO_LLVM_ASSERTIONS: 1\n+        NO_DEBUG_ASSERTIONS: 1\n+\n+      dist-x86_64-apple:\n+        SCRIPT: ./x.py dist\n+        RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+        DEPLOY: 1\n+        RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+        MACOSX_DEPLOYMENT_TARGET: 10.7\n+        NO_LLVM_ASSERTIONS: 1\n+        NO_DEBUG_ASSERTIONS: 1\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+\n+      dist-x86_64-apple-alt:\n+        SCRIPT: ./x.py dist\n+        RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+        DEPLOY_ALT: 1\n+        RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+        MACOSX_DEPLOYMENT_TARGET: 10.7\n+        NO_LLVM_ASSERTIONS: 1\n+        NO_DEBUG_ASSERTIONS: 1\n+\n+      i686-apple:\n+        SCRIPT: ./x.py test\n+        RUST_CONFIGURE_ARGS: --build=i686-apple-darwin --set rust.jemalloc\n+        RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+        MACOSX_DEPLOYMENT_TARGET: 10.8\n+        MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+        NO_LLVM_ASSERTIONS: 1\n+        NO_DEBUG_ASSERTIONS: 1\n+\n+      dist-i686-apple:\n+        SCRIPT: ./x.py dist\n+        RUST_CONFIGURE_ARGS: --build=i686-apple-darwin --enable-full-tools --enable-profiler --set rust.jemalloc\n+        DEPLOY: 1\n+        RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+        MACOSX_DEPLOYMENT_TARGET: 10.7\n+        NO_LLVM_ASSERTIONS: 1\n+        NO_DEBUG_ASSERTIONS: 1\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+\n+\n+\n+- job: Windows\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: 'vs2017-win2016'\n+  steps:\n+  - template: steps/run.yml\n+  strategy:\n+    matrix:\n+      # 32/64 bit MSVC tests\n+      x86_64-msvc-1:\n+        MSYS_BITS: 64\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n+        SCRIPT: make ci-subset-1\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n+      x86_64-msvc-2:\n+        MSYS_BITS: 64\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n+        SCRIPT: make ci-subset-2\n+      i686-msvc-1:\n+        MSYS_BITS: 32\n+        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+        SCRIPT: make ci-subset-1\n+      i686-msvc-2:\n+        MSYS_BITS: 32\n+        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+        SCRIPT: make ci-subset-2\n+      # MSVC aux tests\n+      x86_64-msvc-aux:\n+        MSYS_BITS: 64\n+        RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+      x86_64-msvc-cargo:\n+        MSYS_BITS: 64\n+        SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+        VCVARS_BAT: vcvars64.bat\n+      # MSVC tools tests\n+      x86_64-msvc-tools:\n+        MSYS_BITS: 64\n+        SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json\n+\n+      # 32/64-bit MinGW builds.\n+      #\n+      # We are using MinGW with posix threads since LLVM does not compile with\n+      # the win32 threads version due to missing support for C++'s std::thread.\n+      #\n+      # Instead of relying on the MinGW version installed on appveryor we download\n+      # and install one ourselves so we won't be surprised by changes to appveyor's\n+      # build image.\n+      #\n+      # Finally, note that the downloads below are all in the `rust-lang-ci` S3\n+      # bucket, but they cleraly didn't originate there! The downloads originally\n+      # came from the mingw-w64 SourceForge download site. Unfortunately\n+      # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n+      i686-mingw-1:\n+        MSYS_BITS: 32\n+        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+        SCRIPT: make ci-mingw-subset-1\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n+        MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n+        MINGW_DIR: mingw32\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n+      i686-mingw-2:\n+        MSYS_BITS: 32\n+        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+        SCRIPT: make ci-mingw-subset-2\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n+        MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n+        MINGW_DIR: mingw32\n+      x86_64-mingw-1:\n+        MSYS_BITS: 64\n+        SCRIPT: make ci-mingw-subset-1\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n+        MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n+        MINGW_DIR: mingw64\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n+      x86_64-mingw-2:\n+        MSYS_BITS: 64\n+        SCRIPT: make ci-mingw-subset-2\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n+        MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n+        MINGW_DIR: mingw64\n+\n+      # 32/64 bit MSVC and GNU deployment\n+      dist-x86_64-msvc:\n+        RUST_CONFIGURE_ARGS: >\n+          --build=x86_64-pc-windows-msvc\n+          --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n+          --enable-full-tools\n+          --enable-profiler\n+        SCRIPT: python x.py dist\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+        DEPLOY: 1\n+      dist-i686-msvc:\n+        RUST_CONFIGURE_ARGS: >\n+          --build=i686-pc-windows-msvc\n+          --target=i586-pc-windows-msvc\n+          --enable-full-tools\n+          --enable-profiler\n+        SCRIPT: python x.py dist\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+        DEPLOY: 1\n+      dist-i686-mingw:\n+        MSYS_BITS: 32\n+        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\n+        SCRIPT: python x.py dist\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n+        MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n+        MINGW_DIR: mingw32\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+        DEPLOY: 1\n+      dist-x86_64-mingw:\n+        MSYS_BITS: 64\n+        SCRIPT: python x.py dist\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\n+        MINGW_URL: https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n+        MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n+        MINGW_DIR: mingw64\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+        DEPLOY: 1\n+\n+      # \"alternate\" deployment, see .travis.yml for more info\n+      dist-x86_64-msvc-alt:\n+        MSYS_BITS: 64\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n+        SCRIPT: python x.py dist\n+        DEPLOY_ALT: 1"}, {"sha": "9742c7196585113050aa91f235bfea1ee8263f47", "filename": "src/ci/azure-pipelines/master.yml", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fmaster.yml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,25 @@\n+#\n+# Azure Pipelines job to publish toolstate. Only triggers on pushes to master.\n+#\n+\n+pr: none\n+trigger:\n+  - master\n+\n+variables:\n+- group: real-prod-credentials\n+\n+pool:\n+  vmImage: ubuntu-16.04\n+\n+steps:\n+- checkout: self\n+  fetchDepth: 2\n+\n+- script: |\n+    export MESSAGE_FILE=$(mktemp -t msg.XXXXXX)\n+    . src/ci/docker/x86_64-gnu-tools/repo.sh\n+    commit_toolstate_change \"$MESSAGE_FILE\" \"$BUILD_SOURCESDIRECTORY/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"$MESSAGE_FILE\" \"$TOOLSTATE_REPO_ACCESS_TOKEN\"\n+  displayName: Publish toolstate\n+  env:\n+    TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)"}, {"sha": "62e23efe1ef168f951c8ac3d901ef451a7d92d43", "filename": "src/ci/azure-pipelines/pr.yml", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fpr.yml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fpr.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fpr.yml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,35 @@\n+#\n+# Azure Pipelines pull request build for Rust\n+#\n+\n+trigger: none\n+pr:\n+- master\n+\n+variables:\n+- group: public-credentials\n+\n+jobs:\n+- job: Linux\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: ubuntu-16.04\n+  steps:\n+    - template: steps/run.yml\n+  strategy:\n+    matrix:\n+      x86_64-gnu-llvm-6.0:\n+        IMAGE: x86_64-gnu-llvm-6.0\n+      mingw-check:\n+        IMAGE: mingw-check\n+\n+- job: LinuxTools\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: ubuntu-16.04\n+  steps:\n+    - template: steps/run.yml\n+      parameters:\n+        only_on_updated_submodules: 'yes'\n+  variables:\n+    IMAGE: x86_64-gnu-tools"}, {"sha": "14daf81b430755cda020c104ec9da8a8cc138f2c", "filename": "src/ci/azure-pipelines/steps/install-clang.yml", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,46 @@\n+steps:\n+\n+- bash: |\n+    set -e\n+    curl -f http://releases.llvm.org/7.0.0/clang+llvm-7.0.0-x86_64-apple-darwin.tar.xz | tar xJf -\n+\n+    export CC=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang\n+    echo \"##vso[task.setvariable variable=CC]$CC\"\n+\n+    export CXX=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang++\n+    echo \"##vso[task.setvariable variable=CXX]$CXX\"\n+\n+    # Configure `AR` specifically so rustbuild doesn't try to infer it as\n+    # `clang-ar` by accident.\n+    echo \"##vso[task.setvariable variable=AR]ar\"\n+  displayName: Install clang (OSX)\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n+\n+# If we're compiling for MSVC then we, like most other distribution builders,\n+# switch to clang as the compiler. This'll allow us eventually to enable LTO\n+# amongst LLVM and rustc. Note that we only do this on MSVC as I don't think\n+# clang has an output mode compatible with MinGW that we need. If it does we\n+# should switch to clang for MinGW as well!\n+#\n+# Note that the LLVM installer is an NSIS installer\n+#\n+# Original downloaded here came from\n+# http://releases.llvm.org/7.0.0/LLVM-7.0.0-win64.exe\n+# That installer was run through `wine` on Linux and then the resulting\n+# installation directory (found in `$HOME/.wine/drive_c/Program Files/LLVM`) was\n+# packaged up into a tarball. We've had issues otherwise that the installer will\n+# randomly hang, provide not a lot of useful information, pollute global state,\n+# etc. In general the tarball is just more confined and easier to deal with when\n+# working with various CI environments.\n+- bash: |\n+    set -e\n+    mkdir -p citools\n+    cd citools\n+    curl -f https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/LLVM-7.0.0-win64.tar.gz | tar xzf -\n+    echo \"##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]$RUST_CONFIGURE_ARGS --set llvm.clang-cl=`pwd`/clang-rust/bin/clang-cl.exe\"\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n+  displayName: Install clang (Windows)\n+\n+# Note that we don't install clang on Linux since its compiler story is just so\n+# different. Each container has its own toolchain configured appropriately\n+# already."}, {"sha": "d4679c1c6733e50807df5f8c61dec675a15e031c", "filename": "src/ci/azure-pipelines/steps/install-sccache.yml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,21 @@\n+steps:\n+\n+- bash: |\n+    set -e\n+    curl -fo /usr/local/bin/sccache https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-02-sccache-x86_64-apple-darwin\n+    chmod +x /usr/local/bin/sccache\n+  displayName: Install sccache (OSX)\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n+\n+- script: |\n+    md sccache\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf sccache\\sccache.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-26-sccache-x86_64-pc-windows-msvc\"\n+    echo ##vso[task.prependpath]%CD%\\sccache\n+  displayName: Install sccache (Windows)\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+# Note that we don't install sccache on Linux since it's installed elsewhere\n+# through all the containers.\n+#\n+# FIXME: we should probably install sccache outside the containers and then\n+# mount it inside the containers so we can centralize all installation here."}, {"sha": "9aaeb4b79d63410ff36f91d64185ca4f6c6e5c75", "filename": "src/ci/azure-pipelines/steps/install-windows-build-deps.yml", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,119 @@\n+steps:\n+# We use the WIX toolset to create combined installers for Windows, and these\n+# binaries are downloaded from\n+# https://github.com/wixtoolset/wix3 originally\n+- bash: |\n+    set -e\n+    curl -O https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/wix311-binaries.zip\n+    echo \"##vso[task.setvariable variable=WIX]`pwd`/wix\"\n+    mkdir -p wix/bin\n+    cd wix/bin\n+    7z x ../../wix311-binaries.zip\n+  displayName: Install wix\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+# We use InnoSetup and its `iscc` program to also create combined installers.\n+# Honestly at this point WIX above and `iscc` are just holdovers from\n+# oh-so-long-ago and are required for creating installers on Windows. I think\n+# one is MSI installers and one is EXE, but they're not used so frequently at\n+# this point anyway so perhaps it's a wash!\n+- script: |\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf is-install.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-08-22-is.exe\"\n+    is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n+    echo ##vso[task.prependpath]C:\\Program Files (x86)\\Inno Setup 5\n+  displayName: Install InnoSetup\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+# We've had issues with the default drive in use running out of space during a\n+# build, and it looks like the `C:` drive has more space than the default `D:`\n+# drive. We should probably confirm this with the azure pipelines team at some\n+# point, but this seems to fix our \"disk space full\" problems.\n+- script: |\n+    mkdir c:\\MORE_SPACE\n+    mklink /J build c:\\MORE_SPACE\n+  displayName: \"Ensure build happens on C:/ instead of D:/\"\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+- bash: git config --replace-all --global core.autocrlf false\n+  displayName: \"Disable git automatic line ending conversion (on C:/)\"\n+\n+# Download and install MSYS2, needed primarily for the test suite (run-make) but\n+# also used by the MinGW toolchain for assembling things.\n+#\n+# FIXME: we should probe the default azure image and see if we can use the MSYS2\n+# toolchain there. (if there's even one there). For now though this gets the job\n+# done.\n+- script: |\n+    set MSYS_PATH=%CD%\\citools\\msys64\n+    choco install msys2 --params=\"/InstallDir:%MSYS_PATH% /NoPath\" -y\n+    set PATH=%MSYS_PATH%\\usr\\bin;%PATH%\n+    pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar\n+    IF \"%MINGW_URL%\"==\"\" (\n+      IF \"%MSYS_BITS%\"==\"32\" pacman -S --noconfirm --needed mingw-w64-i686-toolchain mingw-w64-i686-cmake mingw-w64-i686-gcc mingw-w64-i686-python2\n+      IF \"%MSYS_BITS%\"==\"64\" pacman -S --noconfirm --needed mingw-w64-x86_64-toolchain mingw-w64-x86_64-cmake mingw-w64-x86_64-gcc mingw-w64-x86_64-python2\n+    )\n+    where rev\n+    rev --help\n+    where make\n+\n+    echo ##vso[task.setvariable variable=MSYS_PATH]%MSYS_PATH%\n+    echo ##vso[task.prependpath]%MSYS_PATH%\\usr\\bin\n+  displayName: Install msys2\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+# If we need to download a custom MinGW, do so here and set the path\n+# appropriately.\n+#\n+# Here we also do a pretty heinous thing which is to mangle the MinGW\n+# installation we just downloaded. Currently, as of this writing, we're using\n+# MinGW-w64 builds of gcc, and that's currently at 6.3.0. We use 6.3.0 as it\n+# appears to be the first version which contains a fix for #40546, builds\n+# randomly failing during LLVM due to ar.exe/ranlib.exe failures.\n+#\n+# Unfortunately, though, 6.3.0 *also* is the first version of MinGW-w64 builds\n+# to contain a regression in gdb (#40184). As a result if we were to use the\n+# gdb provided (7.11.1) then we would fail all debuginfo tests.\n+#\n+# In order to fix spurious failures (pretty high priority) we use 6.3.0. To\n+# avoid disabling gdb tests we download an *old* version of gdb, specifically\n+# that found inside the 6.2.0 distribution. We then overwrite the 6.3.0 gdb\n+# with the 6.2.0 gdb to get tests passing.\n+#\n+# Note that we don't literally overwrite the gdb.exe binary because it appears\n+# to just use gdborig.exe, so that's the binary we deal with instead.\n+- script: |\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf %MINGW_ARCHIVE% %MINGW_URL%/%MINGW_ARCHIVE%\"\n+    7z x -y %MINGW_ARCHIVE% > nul\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_URL%/2017-04-20-%MSYS_BITS%bit-gdborig.exe\"\n+    mv 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_DIR%\\bin\\gdborig.exe\n+    echo ##vso[task.prependpath]%CD%\\%MINGW_DIR%\\bin\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), ne(variables['MINGW_URL'],''))\n+  displayName: Download custom MinGW\n+\n+# Otherwise pull in the MinGW installed on appveyor\n+- script: |\n+    echo ##vso[task.prependpath]%MSYS_PATH%\\mingw%MSYS_BITS%\\bin\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n+  displayName: Add MinGW to path\n+\n+# Make sure we use the native python interpreter instead of some msys equivalent\n+# one way or another. The msys interpreters seem to have weird path conversions\n+# baked in which break LLVM's build system one way or another, so let's use the\n+# native version which keeps everything as native as possible.\n+- script: |\n+    copy C:\\Python27amd64\\python.exe C:\\Python27amd64\\python2.7.exe\n+    echo ##vso[task.prependpath]C:\\Python27amd64\n+  displayName: Prefer the \"native\" Python as LLVM has trouble building with MSYS sometimes\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+# Note that this is originally from the github releases patch of Ninja\n+- script: |\n+    md ninja\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-03-15-ninja-win.zip https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-03-15-ninja-win.zip\"\n+    7z x -oninja 2017-03-15-ninja-win.zip\n+    del 2017-03-15-ninja-win.zip\n+    set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja\n+    echo ##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]%RUST_CONFIGURE_ARGS%\n+    echo ##vso[task.prependpath]%CD%\\ninja\n+  displayName: Download and install ninja\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))"}, {"sha": "ac6b344a45e66a8b32433980992bb7b6de6943fa", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,207 @@\n+# FIXME(linux): need to configure core dumps, enable them, and then dump\n+# backtraces on failure from all core dumps:\n+#\n+# - bash: sudo apt install gdb\n+# - bash: sudo sh -c 'echo \"/checkout/obj/cores/core.%p.%E\" > /proc/sys/kernel/core_pattern'\n+#\n+# Check travis config for `gdb --batch` command to print all crash logs\n+\n+parameters:\n+  # When this parameter is set to anything other than an empty string the tests\n+  # will only be executed when the commit updates submodules\n+  only_on_updated_submodules: ''\n+\n+steps:\n+\n+# Disable automatic line ending conversion, which is enabled by default on\n+# Azure's Windows image. Having the conversion enabled caused regressions both\n+# in our test suite (it broke miri tests) and in the ecosystem, since we\n+# started shipping install scripts with CRLF endings instead of the old LF.\n+#\n+# Note that we do this a couple times during the build as the PATH and current\n+# user/directory change, e.g. when mingw is enabled.\n+- bash: git config --global core.autocrlf false\n+  displayName: \"Disable git automatic line ending conversion\"\n+\n+- checkout: self\n+  fetchDepth: 2\n+\n+# Set the SKIP_JOB environment variable if this job is supposed to only run\n+# when submodules are updated and they were not. The following time consuming\n+# tasks will be skipped when the environment variable is present.\n+- ${{ if parameters.only_on_updated_submodules }}:\n+  - bash: |\n+      set -e\n+      # Submodules pseudo-files inside git have the 160000 permissions, so when\n+      # those files are present in the diff a submodule was updated.\n+      if git diff HEAD^ | grep \"^index .* 160000\" >/dev/null 2>&1; then\n+          echo \"Executing the job since submodules are updated\"\n+      else\n+          echo \"Not executing this job since no submodules were updated\"\n+          echo \"##vso[task.setvariable variable=SKIP_JOB;]1\"\n+      fi\n+    displayName: Decide whether to run this job\n+\n+# Spawn a background process to collect CPU usage statistics which we'll upload\n+# at the end of the build. See the comments in the script here for more\n+# information.\n+- bash: python src/ci/cpu-usage-over-time.py &> cpu-usage.csv &\n+  displayName: \"Collect CPU-usage statistics in the background\"\n+\n+- bash: printenv | sort\n+  displayName: Show environment variables\n+\n+- bash: |\n+    set -e\n+    df -h\n+    du . | sort -nr | head -n100\n+  displayName: Show disk usage\n+  # FIXME: this hasn't been tested, but maybe it works on Windows? Should test!\n+  condition: and(succeeded(), ne(variables['Agent.OS'], 'Windows_NT'))\n+\n+- template: install-sccache.yml\n+- template: install-clang.yml\n+\n+# Switch to XCode 9.3 on OSX since it seems to be the last version that supports\n+# i686-apple-darwin. We'll eventually want to upgrade this and it will probably\n+# force us to drop i686-apple-darwin, but let's keep the wheels turning for now.\n+- bash: |\n+    set -e\n+    sudo xcode-select --switch /Applications/Xcode_9.3.app\n+  displayName: Switch to Xcode 9.3 (OSX)\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n+\n+- template: install-windows-build-deps.yml\n+\n+# Looks like docker containers have IPv6 disabled by default, so let's turn it\n+# on since libstd tests require it\n+- bash: |\n+    set -e\n+    sudo mkdir -p /etc/docker\n+    echo '{\"ipv6\":true,\"fixed-cidr-v6\":\"fd9a:8454:6789:13f7::/64\"}' | sudo tee /etc/docker/daemon.json\n+    sudo service docker restart\n+  displayName: Enable IPv6\n+  condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['Agent.OS'], 'Linux'))\n+\n+# Disable automatic line ending conversion (again). On Windows, when we're\n+# installing dependencies, something switches the git configuration directory or\n+# re-enables autocrlf. We've not tracked down the exact cause -- and there may\n+# be multiple -- but this should ensure submodules are checked out with the\n+# appropriate line endings.\n+- bash: git config --replace-all --global core.autocrlf false\n+  displayName: \"Disable git automatic line ending conversion\"\n+\n+# Check out all our submodules, but more quickly than using git by using one of\n+# our custom scripts\n+- bash: |\n+    set -e\n+    mkdir -p $HOME/rustsrc\n+    $BUILD_SOURCESDIRECTORY/src/ci/init_repo.sh . $HOME/rustsrc\n+  condition: and(succeeded(), not(variables.SKIP_JOB), ne(variables['Agent.OS'], 'Windows_NT'))\n+  displayName: Check out submodules (Unix)\n+- script: |\n+    if not exist C:\\cache\\rustsrc\\NUL mkdir C:\\cache\\rustsrc\n+    sh src/ci/init_repo.sh . /c/cache/rustsrc\n+  condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['Agent.OS'], 'Windows_NT'))\n+  displayName: Check out submodules (Windows)\n+\n+# See also the disable for autocrlf above, this just checks that it worked\n+#\n+# We check both in rust-lang/rust and in a submodule to make sure both are\n+# accurate. Submodules are checked out significantly later than the main\n+# repository in this script, so settings can (and do!) change between then.\n+#\n+# Linux (and maybe macOS) builders don't currently have dos2unix so just only\n+# run this step on Windows.\n+- bash: |\n+    set -x\n+    # print out the git configuration so we can better investigate failures in\n+    # the following\n+    git config --list --show-origin\n+    dos2unix -ih Cargo.lock src/tools/rust-installer/install-template.sh\n+    endings=$(dos2unix -ic Cargo.lock src/tools/rust-installer/install-template.sh)\n+    # if endings has non-zero length, error out\n+    if [ -n \"$endings\" ]; then exit 1 ; fi\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+  displayName: Verify line endings are LF\n+\n+# Ensure the `aws` CLI is installed so we can deploy later on, cache docker\n+# images, etc.\n+- bash: src/ci/install-awscli.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+  displayName: Install awscli\n+\n+# Configure our CI_JOB_NAME variable which log analyzers can use for the main\n+# step to see what's going on.\n+- bash: |\n+    builder=$(echo $AGENT_JOBNAME | cut -d ' ' -f 2)\n+    echo \"##vso[task.setvariable variable=CI_JOB_NAME]$builder\"\n+  displayName: Configure Job Name\n+\n+# As a quick smoke check on the otherwise very fast mingw-check linux builder\n+# check our own internal scripts.\n+- bash: |\n+    set -e\n+    git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n+    cd rust-toolstate\n+    python2.7 \"$BUILD_SOURCESDIRECTORY/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"\" \"\"\n+    cd ..\n+    rm -rf rust-toolstate\n+  condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['IMAGE'], 'mingw-check'))\n+  displayName: Verify the publish_toolstate script works\n+\n+- bash: |\n+    set -e\n+    # Remove any preexisting rustup installation since it can interfere\n+    # with the cargotest step and its auto-detection of things like Clippy in\n+    # the environment\n+    rustup self uninstall -y || true\n+    if [ \"$IMAGE\" = \"\" ]; then\n+      src/ci/run.sh\n+    else\n+      src/ci/docker/run.sh $IMAGE\n+    fi\n+  #timeoutInMinutes: 180\n+  timeoutInMinutes: 600\n+  env:\n+    CI: true\n+    SRC: .\n+    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+    TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+  displayName: Run build\n+\n+# If we're a deploy builder, use the `aws` command to publish everything to our\n+# bucket.\n+- bash: |\n+    set -e\n+    source src/ci/shared.sh\n+    if [ \"$AGENT_OS\" = \"Linux\" ]; then\n+        rm -rf obj/build/dist/doc\n+        upload_dir=obj/build/dist\n+    else\n+        rm -rf build/dist/doc\n+        upload_dir=build/dist\n+    fi\n+    ls -la $upload_dir\n+    deploy_dir=rustc-builds\n+    if [ \"$DEPLOY_ALT\" == \"1\" ]; then\n+        deploy_dir=rustc-builds-alt\n+    fi\n+    retry aws s3 cp --no-progress --recursive --acl public-read ./$upload_dir s3://$DEPLOY_BUCKET/$deploy_dir/$BUILD_SOURCEVERSION\n+  env:\n+    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+  condition: and(succeeded(), not(variables.SKIP_JOB), or(eq(variables.DEPLOY, '1'), eq(variables.DEPLOY_ALT, '1')))\n+  displayName: Upload artifacts\n+\n+# Upload CPU usage statistics that we've been gathering this whole time. Always\n+# execute this step in case we want to inspect failed builds, but don't let\n+# errors here ever fail the build since this is just informational.\n+- bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$CI_JOB_NAME.csv\n+  env:\n+    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+  condition: variables['AWS_SECRET_ACCESS_KEY']\n+  continueOnError: true\n+  displayName: Upload CPU usage statistics"}, {"sha": "0df6c6c951f246eaf70d018f6546ae7c54e4b273", "filename": "src/ci/azure-pipelines/try.yml", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Ftry.yml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fazure-pipelines%2Ftry.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Ftry.yml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,78 @@\n+pr: none\n+trigger:\n+- try\n+\n+variables:\n+- group: real-prod-credentials\n+\n+jobs:\n+- job: Linux\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: ubuntu-16.04\n+  steps:\n+  - template: steps/run.yml\n+  strategy:\n+    matrix:\n+      dist-x86_64-linux:\n+        IMAGE: dist-x86_64-linux\n+        DEPLOY: 1\n+\n+      dist-x86_64-linux-alt:\n+        IMAGE: dist-x86_64-linux\n+        DEPLOY_ALT: 1\n+\n+# The macOS and Windows builds here are currently disabled due to them not being\n+# overly necessary on `try` builds. We also don't actually have anything that\n+# consumes the artifacts currently. Perhaps one day we can reenable, but for now\n+# it helps free up capacity on Azure.\n+# - job: macOS\n+#   timeoutInMinutes: 600\n+#   pool:\n+#     vmImage: macos-10.13\n+#   steps:\n+#   - template: steps/run.yml\n+#   strategy:\n+#     matrix:\n+#       dist-x86_64-apple:\n+#         SCRIPT: ./x.py dist\n+#         RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+#         DEPLOY: 1\n+#         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+#         MACOSX_DEPLOYMENT_TARGET: 10.7\n+#         NO_LLVM_ASSERTIONS: 1\n+#         NO_DEBUG_ASSERTIONS: 1\n+#         DIST_REQUIRE_ALL_TOOLS: 1\n+#\n+#       dist-x86_64-apple-alt:\n+#         SCRIPT: ./x.py dist\n+#         RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+#         DEPLOY_ALT: 1\n+#         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+#         MACOSX_DEPLOYMENT_TARGET: 10.7\n+#         NO_LLVM_ASSERTIONS: 1\n+#         NO_DEBUG_ASSERTIONS: 1\n+#\n+# - job: Windows\n+#   timeoutInMinutes: 600\n+#   pool:\n+#     vmImage: 'vs2017-win2016'\n+#   steps:\n+#   - template: steps/run.yml\n+#   strategy:\n+#     matrix:\n+#       dist-x86_64-msvc:\n+#         RUST_CONFIGURE_ARGS: >\n+#           --build=x86_64-pc-windows-msvc\n+#           --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n+#           --enable-full-tools\n+#           --enable-profiler\n+#         SCRIPT: python x.py dist\n+#         DIST_REQUIRE_ALL_TOOLS: 1\n+#         DEPLOY: 1\n+#\n+#       dist-x86_64-msvc-alt:\n+#         MSYS_BITS: 64\n+#         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n+#         SCRIPT: python x.py dist\n+#         DEPLOY_ALT: 1"}, {"sha": "daf21670b33391d49cbe9f26d6c7fd7b347f6943", "filename": "src/ci/cpu-usage-over-time.py", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fcpu-usage-over-time.py", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fcpu-usage-over-time.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fcpu-usage-over-time.py?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,160 @@\n+#!/usr/bin/env python\n+# ignore-tidy-linelength\n+\n+# This is a small script that we use on CI to collect CPU usage statistics of\n+# our builders. By seeing graphs of CPU usage over time we hope to correlate\n+# that with possible improvements to Rust's own build system, ideally diagnosing\n+# that either builders are always fully using their CPU resources or they're\n+# idle for long stretches of time.\n+#\n+# This script is relatively simple, but it's platform specific. Each platform\n+# (OSX/Windows/Linux) has a different way of calculating the current state of\n+# CPU at a point in time. We then compare two captured states to determine the\n+# percentage of time spent in one state versus another. The state capturing is\n+# all platform-specific but the loop at the bottom is the cross platform part\n+# that executes everywhere.\n+#\n+# # Viewing statistics\n+#\n+# All builders will upload their CPU statistics as CSV files to our S3 buckets.\n+# These URLS look like:\n+#\n+#   https://$bucket.s3.amazonaws.com/rustc-builds/$commit/cpu-$builder.csv\n+#\n+# for example\n+#\n+#   https://rust-lang-ci2.s3.amazonaws.com/rustc-builds/68baada19cd5340f05f0db15a3e16d6671609bcc/cpu-x86_64-apple.csv\n+#\n+# Each CSV file has two columns. The first is the timestamp of the measurement\n+# and the second column is the % of idle cpu time in that time slice. Ideally\n+# the second column is always zero.\n+#\n+# Once you've downloaded a file there's various ways to plot it and visualize\n+# it. For command line usage you use the `src/etc/cpu-usage-over-time-plot.sh`\n+# script in this repository.\n+\n+import datetime\n+import sys\n+import time\n+\n+if sys.platform == 'linux2':\n+    class State:\n+        def __init__(self):\n+            with open('/proc/stat', 'r') as file:\n+                data = file.readline().split()\n+            if data[0] != 'cpu':\n+                raise Exception('did not start with \"cpu\"')\n+            self.user = int(data[1])\n+            self.nice = int(data[2])\n+            self.system = int(data[3])\n+            self.idle = int(data[4])\n+            self.iowait = int(data[5])\n+            self.irq = int(data[6])\n+            self.softirq = int(data[7])\n+            self.steal = int(data[8])\n+            self.guest = int(data[9])\n+            self.guest_nice = int(data[10])\n+\n+        def idle_since(self, prev):\n+            user = self.user - prev.user\n+            nice = self.nice - prev.nice\n+            system = self.system - prev.system\n+            idle = self.idle - prev.idle\n+            iowait = self.iowait - prev.iowait\n+            irq = self.irq - prev.irq\n+            softirq = self.softirq - prev.softirq\n+            steal = self.steal - prev.steal\n+            guest = self.guest - prev.guest\n+            guest_nice = self.guest_nice - prev.guest_nice\n+            total = user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice\n+            return float(idle) / float(total) * 100\n+\n+elif sys.platform == 'win32':\n+    from ctypes.wintypes import DWORD\n+    from ctypes import Structure, windll, WinError, GetLastError, byref\n+\n+    class FILETIME(Structure):\n+        _fields_ = [\n+            (\"dwLowDateTime\", DWORD),\n+            (\"dwHighDateTime\", DWORD),\n+        ]\n+\n+    class State:\n+        def __init__(self):\n+            idle, kernel, user = FILETIME(), FILETIME(), FILETIME()\n+\n+            success = windll.kernel32.GetSystemTimes(\n+                byref(idle),\n+                byref(kernel),\n+                byref(user),\n+            )\n+\n+            assert success, WinError(GetLastError())[1]\n+\n+            self.idle = (idle.dwHighDateTime << 32) | idle.dwLowDateTime\n+            self.kernel = (kernel.dwHighDateTime << 32) | kernel.dwLowDateTime\n+            self.user = (user.dwHighDateTime << 32) | user.dwLowDateTime\n+\n+        def idle_since(self, prev):\n+            idle = self.idle - prev.idle\n+            user = self.user - prev.user\n+            kernel = self.kernel - prev.kernel\n+            return float(idle) / float(user + kernel) * 100\n+\n+elif sys.platform == 'darwin':\n+    from ctypes import *\n+    libc = cdll.LoadLibrary('/usr/lib/libc.dylib')\n+\n+    PROESSOR_CPU_LOAD_INFO = c_int(2)\n+    CPU_STATE_USER = 0\n+    CPU_STATE_SYSTEM = 1\n+    CPU_STATE_IDLE = 2\n+    CPU_STATE_NICE = 3\n+    c_int_p = POINTER(c_int)\n+\n+    class State:\n+        def __init__(self):\n+            num_cpus_u = c_uint(0)\n+            cpu_info = c_int_p()\n+            cpu_info_cnt = c_int(0)\n+            err = libc.host_processor_info(\n+                libc.mach_host_self(),\n+                PROESSOR_CPU_LOAD_INFO,\n+                byref(num_cpus_u),\n+                byref(cpu_info),\n+                byref(cpu_info_cnt),\n+            )\n+            assert err == 0\n+            self.user = 0\n+            self.system = 0\n+            self.idle = 0\n+            self.nice = 0\n+            cur = 0\n+            while cur < cpu_info_cnt.value:\n+                self.user += cpu_info[cur + CPU_STATE_USER]\n+                self.system += cpu_info[cur + CPU_STATE_SYSTEM]\n+                self.idle += cpu_info[cur + CPU_STATE_IDLE]\n+                self.nice += cpu_info[cur + CPU_STATE_NICE]\n+                cur += num_cpus_u.value\n+\n+        def idle_since(self, prev):\n+            user = self.user - prev.user\n+            system = self.system - prev.system\n+            idle = self.idle - prev.idle\n+            nice = self.nice - prev.nice\n+            return float(idle) / float(user + system + idle + nice) * 100.0\n+\n+else:\n+    print('unknown platform', sys.platform)\n+    sys.exit(1)\n+\n+cur_state = State();\n+print(\"Time,Idle\")\n+while True:\n+    time.sleep(1);\n+    next_state = State();\n+    now = datetime.datetime.utcnow().isoformat()\n+    idle = next_state.idle_since(cur_state)\n+    print(\"%s,%s\" % (now, idle))\n+    sys.stdout.flush()\n+    cur_state = next_state"}, {"sha": "367e43849923fca154a6867d158431a214d2f8c7", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -20,7 +20,7 @@ Images will output artifacts in an `obj` dir at the root of a repository.\n \n - Each directory, excluding `scripts` and `disabled`, corresponds to a docker image\n - `scripts` contains files shared by docker images\n-- `disabled` contains images that are not built on travis\n+- `disabled` contains images that are not built on CI\n \n ## Docker Toolbox on Windows\n "}, {"sha": "9493b33698708b08449d55d4b30ee3b54151c355", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -72,7 +72,7 @@ RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n \n # TODO: What is this?!\n # Source of the file: https://github.com/vfdev-5/qemu-rpi2-vexpress/raw/master/vexpress-v2p-ca15-tc1.dtb\n-RUN curl -O https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/vexpress-v2p-ca15-tc1.dtb\n+RUN curl -O https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/vexpress-v2p-ca15-tc1.dtb\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "3abaab6b34ef0dece78106d7955dc7f24c084a5d", "filename": "src/ci/docker/asmjs/Dockerfile", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -32,8 +32,16 @@ ENV TARGETS=asmjs-unknown-emscripten\n ENV RUST_CONFIGURE_ARGS --enable-emscripten --disable-optimize-tests\n \n ENV SCRIPT python2.7 ../x.py test --target $TARGETS \\\n-  src/test/run-pass \\\n+  src/test/ui \\\n   src/test/run-fail \\\n   src/libstd \\\n   src/liballoc \\\n   src/libcore\n+\n+# Debug assertions in rustc are largely covered by other builders, and LLVM\n+# assertions cause this builder to slow down by quite a large amount and don't\n+# buy us a huge amount over other builders (not sure if we've ever seen an\n+# asmjs-specific backend assertion trip), so disable assertions for these\n+# tests.\n+ENV NO_LLVM_ASSERTIONS=1\n+ENV NO_DEBUG_ASSERTIONS=1"}, {"sha": "8c052db1b0dde9283d4b856c615ca09db410db23", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -36,7 +36,3 @@ ENV HOSTS=powerpc-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n-\n-# FIXME(#36150) this will fail the bootstrap. Probably means something bad is\n-#               happening!\n-ENV NO_LLVM_ASSERTIONS 1"}, {"sha": "ae2ea8ef95a6a18fe0661595f8e3f8cd893fffd0", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -64,7 +64,7 @@ RUN env \\\n     env \\\n     CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv7-a\" \\\n     CXX=arm-linux-gnueabihf-g++ CXXFLAGS=\"-march=armv7-a\" \\\n-    bash musl.sh armv7 && \\\n+    bash musl.sh armv7hf && \\\n     env \\\n     CC=aarch64-linux-gnu-gcc \\\n     CXX=aarch64-linux-gnu-g++ \\\n@@ -104,14 +104,17 @@ ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n-ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+# FIXME: temporarily disable the redox builder,\n+# see: https://github.com/rust-lang/rust/issues/63160\n+# ENV TARGETS=$TARGETS,x86_64-unknown-redox\n ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n ENV TARGETS=$TARGETS,thumbv7em-none-eabihf\n ENV TARGETS=$TARGETS,thumbv8m.base-none-eabi\n ENV TARGETS=$TARGETS,thumbv8m.main-none-eabi\n ENV TARGETS=$TARGETS,thumbv8m.main-none-eabihf\n+ENV TARGETS=$TARGETS,riscv32i-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv32imc-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv32imac-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv64imac-unknown-none-elf\n@@ -126,7 +129,6 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n     CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \\\n     CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n-    CC_armebv7r_none_eabi=arm-none-eabi-gcc \\\n     CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n     AR_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar \\\n     CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++\n@@ -135,7 +137,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-armv5te=/musl-armv5te \\\n       --musl-root-arm=/musl-arm \\\n       --musl-root-armhf=/musl-armhf \\\n-      --musl-root-armv7=/musl-armv7 \\\n+      --musl-root-armv7hf=/musl-armv7hf \\\n       --musl-root-aarch64=/musl-aarch64 \\\n       --musl-root-mips=/musl-mips \\\n       --musl-root-mipsel=/musl-mipsel \\"}, {"sha": "29cfb5d96083ef6eabbe39e400d2a939bc60590c", "filename": "src/ci/docker/dist-various-1/install-mips-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mips-linux-musl\n # originally from\n # https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/\n # OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\n-URL=\"https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\"\n+URL=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n FILE=\"OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mips-linux-musl --strip-components=2\n "}, {"sha": "9ae41218ee4fbf2f429510d50fb7f8b475aa4c07", "filename": "src/ci/docker/dist-various-1/install-mipsel-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mipsel-linux-musl\n # Note that this originally came from:\n # https://downloads.openwrt.org/snapshots/trunk/malta/generic/\n # OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\n-URL=\"https://s3-us-west-1.amazonaws.com/rust-lang-ci2/libc\"\n+URL=\"https://rust-lang-ci2.s3.amazonaws.com/libc\"\n FILE=\"OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mipsel-linux-musl --strip-components=2\n "}, {"sha": "2ae6c58941e4c62e781600772640c701582f7e3d", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -8,7 +8,8 @@ RUN sed -i 's/^# deb-src/deb-src/' /etc/apt/sources.list\n \n RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no-install-recommends \\\n   build-essential \\\n-  gcc-multilib \\\n+# gcc-multilib can not be installed together with gcc-arm-linux-gnueabi\n+  gcc-7-multilib \\\n   libedit-dev \\\n   libgmp-dev \\\n   libisl-dev \\\n@@ -21,10 +22,19 @@ RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no\n   unzip \\\n   # Needed for apt-key to work:\n   dirmngr \\\n-  gpg-agent\n+  gpg-agent \\\n+  g++-7-arm-linux-gnueabi\n \n RUN apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys 74DA7924C5513486\n-RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2-testing main'\n+RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2 main'\n+\n+WORKDIR /build\n+COPY scripts/musl.sh /build\n+RUN env \\\n+    CC=arm-linux-gnueabi-gcc-7 CFLAGS=\"-march=armv7-a\" \\\n+    CXX=arm-linux-gnueabi-g++-7 CXXFLAGS=\"-march=armv7-a\" \\\n+    bash musl.sh armv7 && \\\n+    rm -rf /build/*\n \n WORKDIR /tmp\n COPY dist-various-2/shared.sh /tmp/\n@@ -58,7 +68,11 @@ ENV \\\n     CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n     AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n     CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n-    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++\n+    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++ \\\n+    CC_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-gcc-7 \\\n+    CXX_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-g++-7 \\\n+    CC=gcc-7 \\\n+    CXX=g++-7\n \n ENV CARGO_TARGET_X86_64_FUCHSIA_AR /usr/local/bin/llvm-ar\n ENV CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS \\\n@@ -73,17 +87,27 @@ ENV CARGO_TARGET_AARCH64_FUCHSIA_RUSTFLAGS \\\n \n ENV TARGETS=x86_64-fuchsia\n ENV TARGETS=$TARGETS,aarch64-fuchsia\n-ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n ENV TARGETS=$TARGETS,wasm32-unknown-unknown\n ENV TARGETS=$TARGETS,wasm32-wasi\n+ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n ENV TARGETS=$TARGETS,x86_64-sun-solaris\n ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n ENV TARGETS=$TARGETS,x86_64-unknown-cloudabi\n ENV TARGETS=$TARGETS,x86_64-fortanix-unknown-sgx\n ENV TARGETS=$TARGETS,nvptx64-nvidia-cuda\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-gnueabi\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabi\n \n ENV X86_FORTANIX_SGX_LIBS=\"/x86_64-fortanix-unknown-sgx/lib/\"\n \n+# As per https://bugs.launchpad.net/ubuntu/+source/gcc-defaults/+bug/1300211\n+# we need asm in the search path for gcc-7 (for gnux32) but not in the search path of the\n+# cross compilers.\n+# Luckily one of the folders is /usr/local/include so symlink /usr/include/asm-generic there\n+RUN ln -s /usr/include/asm-generic /usr/local/include/asm\n+\n ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --disable-docs \\\n-  --set target.wasm32-wasi.wasi-root=/wasm32-wasi\n+  --set target.wasm32-wasi.wasi-root=/wasm32-wasi \\\n+  --musl-root-armv7=/musl-armv7\n+\n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "f04ee78157167104e53c37390677ae6dfa0af131", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -5,7 +5,7 @@\n set -ex\n \n # Originally from https://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n-curl https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/clang%2Bllvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n+curl https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/clang%2Bllvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n   tar xJf -\n export PATH=`pwd`/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n "}, {"sha": "be8a6c93945e96f7d8c7323b4a917df15e3c8910", "filename": "src/ci/docker/dist-x86_64-linux/build-openssl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -4,7 +4,7 @@ set -ex\n source shared.sh\n \n VERSION=1.0.2k\n-URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/openssl-$VERSION.tar.gz\n+URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/openssl-$VERSION.tar.gz\n \n curl $URL | tar xzf -\n "}, {"sha": "797f674b954f2e54c272cb6b4b2a9bb3f512cc25", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -25,7 +25,7 @@ cd netbsd\n \n mkdir -p /x-tools/x86_64-unknown-netbsd/sysroot\n \n-URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\n \n # Originally from ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-$BSD/source/sets/*.tgz\n curl $URL/2018-03-01-netbsd-src.tgz | tar xzf -"}, {"sha": "2041ba50bc9a041f9ac6e7d9332203df54e454d4", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -18,4 +18,4 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n-ENV RUST_CHECK_TARGET check\n+ENV SCRIPT python2.7 ../x.py test"}, {"sha": "415d6b63eb8dc1152de7a0c191c0ce0cc4da250a", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 55, "deletions": 22, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -17,9 +17,6 @@ dist=$objdir/build/dist\n \n source \"$ci_dir/shared.sh\"\n \n-travis_fold start build_docker\n-travis_time_start\n-\n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n     if [ \"$CI\" != \"\" ]; then\n       hash_key=/tmp/.docker-hash-key.txt\n@@ -40,9 +37,12 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       docker --version >> $hash_key\n       cksum=$(sha512sum $hash_key | \\\n         awk '{print $1}')\n+\n       s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n-      url=\"https://s3-us-west-1.amazonaws.com/$SCCACHE_BUCKET/docker/$cksum\"\n-      echo \"Attempting to download $s3url\"\n+      url=\"https://$SCCACHE_BUCKET.s3.amazonaws.com/docker/$cksum\"\n+      upload=\"aws s3 cp - $s3url\"\n+\n+      echo \"Attempting to download $url\"\n       rm -f /tmp/rustci_docker_cache\n       set +e\n       retry curl -y 30 -Y 10 --connect-timeout 30 -f -L -C - -o /tmp/rustci_docker_cache \"$url\"\n@@ -65,17 +65,17 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       -f \"$dockerfile\" \\\n       \"$context\"\n \n-    if [ \"$s3url\" != \"\" ]; then\n+    if [ \"$upload\" != \"\" ]; then\n       digest=$(docker inspect rust-ci --format '{{.Id}}')\n       echo \"Built container $digest\"\n       if ! grep -q \"$digest\" <(echo \"$loaded_images\"); then\n-        echo \"Uploading finished image to $s3url\"\n+        echo \"Uploading finished image to $url\"\n         set +e\n         docker history -q rust-ci | \\\n           grep -v missing | \\\n           xargs docker save | \\\n           gzip | \\\n-          aws s3 cp - $s3url\n+          $upload\n         set -e\n       else\n         echo \"Looks like docker image is the same as before, not uploading\"\n@@ -87,11 +87,10 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       echo \"$digest\" >>\"$info\"\n     fi\n elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n-    if [ -n \"$TRAVIS_OS_NAME\" ]; then\n-        echo Cannot run disabled images on travis!\n+    if isCI; then\n+        echo Cannot run disabled images on CI!\n         exit 1\n     fi\n-    # retry messes with the pipe from tar to docker. Not needed on non-travis\n     # Transform changes the context of disabled Dockerfiles to match the enabled ones\n     tar --transform 's#^./disabled/#./#' -C $docker_dir -c . | docker \\\n       build \\\n@@ -104,9 +103,6 @@ else\n     exit 1\n fi\n \n-travis_fold end build_docker\n-travis_time_finish\n-\n mkdir -p $HOME/.cargo\n mkdir -p $objdir/tmp\n mkdir -p $objdir/cores\n@@ -129,24 +125,61 @@ fi\n # goes ahead and sets it for all builders.\n args=\"$args --privileged\"\n \n-exec docker \\\n+# Things get a little weird if this script is already running in a docker\n+# container. If we're already in a docker container then we assume it's set up\n+# to do docker-in-docker where we have access to a working `docker` command.\n+#\n+# If this is the case (we check via the presence of `/.dockerenv`)\n+# then we can't actually use the `--volume` argument. Typically we use\n+# `--volume` to efficiently share the build and source directory between this\n+# script and the container we're about to spawn. If we're inside docker already\n+# though the `--volume` argument maps the *host's* folder to the container we're\n+# about to spawn, when in fact we want the folder in this container itself. To\n+# work around this we use a recipe cribbed from\n+# https://circleci.com/docs/2.0/building-docker-images/#mounting-folders to\n+# create a temporary container with a volume. We then copy the entire source\n+# directory into this container, and then use that copy in the container we're\n+# about to spawn. Finally after the build finishes we re-extract the object\n+# directory.\n+#\n+# Note that none of this is necessary if we're *not* in a docker-in-docker\n+# scenario. If this script is run on a bare metal host then we share a bunch of\n+# data directories to share as much data as possible. Note that we also use\n+# `LOCAL_USER_ID` (recognized in `src/ci/run.sh`) to ensure that files are all\n+# read/written as the same user as the bare-metal user.\n+if [ -f /.dockerenv ]; then\n+  docker create -v /checkout --name checkout alpine:3.4 /bin/true\n+  docker cp . checkout:/checkout\n+  args=\"$args --volumes-from checkout\"\n+else\n+  args=\"$args --volume $root_dir:/checkout:ro\"\n+  args=\"$args --volume $objdir:/checkout/obj\"\n+  args=\"$args --volume $HOME/.cargo:/cargo\"\n+  args=\"$args --volume $HOME/rustsrc:$HOME/rustsrc\"\n+  args=\"$args --env LOCAL_USER_ID=`id -u`\"\n+fi\n+\n+docker \\\n   run \\\n-  --volume \"$root_dir:/checkout:ro\" \\\n-  --volume \"$objdir:/checkout/obj\" \\\n   --workdir /checkout/obj \\\n   --env SRC=/checkout \\\n   $args \\\n   --env CARGO_HOME=/cargo \\\n   --env DEPLOY \\\n   --env DEPLOY_ALT \\\n-  --env LOCAL_USER_ID=`id -u` \\\n-  --env TRAVIS \\\n-  --env TRAVIS_BRANCH \\\n+  --env CI \\\n+  --env TF_BUILD \\\n+  --env BUILD_SOURCEBRANCHNAME \\\n   --env TOOLSTATE_REPO_ACCESS_TOKEN \\\n+  --env TOOLSTATE_REPO \\\n+  --env TOOLSTATE_PUBLISH \\\n   --env CI_JOB_NAME=\"${CI_JOB_NAME-$IMAGE}\" \\\n-  --volume \"$HOME/.cargo:/cargo\" \\\n-  --volume \"$HOME/rustsrc:$HOME/rustsrc\" \\\n   --init \\\n   --rm \\\n   rust-ci \\\n   /checkout/src/ci/run.sh\n+\n+if [ -f /.dockerenv ]; then\n+  rm -rf $objdir\n+  docker cp checkout:/checkout/obj $objdir\n+fi"}, {"sha": "c9e2961f6eb156ca8de88dd6ee51aff71bc8ff8f", "filename": "src/ci/docker/scripts/android-sdk-manager.py", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -23,8 +23,9 @@\n HOST_OS = \"linux\"\n \n # Mirroring options\n-MIRROR_BUCKET = \"rust-lang-ci2\"\n-MIRROR_BASE_DIR = \"rust-ci-mirror/android/\"\n+MIRROR_BUCKET = \"rust-lang-ci-mirrors\"\n+MIRROR_BUCKET_REGION = \"us-west-1\"\n+MIRROR_BASE_DIR = \"rustc/android/\"\n \n import argparse\n import hashlib\n@@ -144,7 +145,8 @@ def cli_install(args):\n     lockfile = Lockfile(args.lockfile)\n     for package in lockfile.packages.values():\n         # Download the file from the mirror into a temp file\n-        url = \"https://\" + MIRROR_BUCKET + \".s3.amazonaws.com/\" + MIRROR_BASE_DIR\n+        url = \"https://\" + MIRROR_BUCKET + \".s3-\" + MIRROR_BUCKET_REGION + \\\n+              \".amazonaws.com/\" + MIRROR_BASE_DIR\n         downloaded = package.download(url)\n         # Extract the file in a temporary directory\n         extract_dir = tempfile.mkdtemp()"}, {"sha": "47196e8939626a69bc82255bac116f0a68981459", "filename": "src/ci/docker/scripts/emscripten.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -18,7 +18,7 @@ exit 1\n }\n \n cd /\n-curl -fL https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz | \\\n+curl -fL https://mozilla-games.s3.amazonaws.com/emscripten/releases/emsdk-portable.tar.gz | \\\n     tar -xz\n \n cd /emsdk-portable"}, {"sha": "70155e770a960281eb90668a7485b8a249889938", "filename": "src/ci/docker/scripts/freebsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -59,7 +59,7 @@ done\n \n # Originally downloaded from:\n # https://download.freebsd.org/ftp/releases/${freebsd_arch}/${freebsd_version}-RELEASE/base.txz\n-URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n+URL=https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n curl \"$URL\" | tar xJf - -C \"$sysroot\" --wildcards \"${files_to_extract[@]}\"\n \n # Fix up absolute symlinks from the system image.  This can be removed"}, {"sha": "74ba2f0eadb25602f8718520f1fa08e0ed0e981f", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -3,7 +3,7 @@\n #\n # Versions of the toolchain components are configurable in `musl-cross-make/Makefile` and\n # musl unlike GLIBC is forward compatible so upgrading it shouldn't break old distributions.\n-# Right now we have: Binutils 2.27, GCC 6.3.0, musl 1.1.18\n+# Right now we have: Binutils 2.27, GCC 6.4.0, musl 1.1.22.\n set -ex\n \n hide_output() {\n@@ -33,7 +33,7 @@ shift\n # Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-git clone https://github.com/richfelker/musl-cross-make -b v0.9.7\n+git clone https://github.com/richfelker/musl-cross-make -b v0.9.8\n cd musl-cross-make\n \n hide_output make -j$(nproc) TARGET=$TARGET\n@@ -54,29 +54,3 @@ if [ \"$REPLACE_CC\" = \"1\" ]; then\n         ln -s $TARGET-g++ /usr/local/bin/$exec\n     done\n fi\n-\n-export CC=$TARGET-gcc\n-export CXX=$TARGET-g++\n-\n-LLVM=70\n-\n-# may have been downloaded in a previous run\n-if [ ! -d libunwind-release_$LLVM ]; then\n-  curl -L https://github.com/llvm-mirror/llvm/archive/release_$LLVM.tar.gz | tar xzf -\n-  curl -L https://github.com/llvm-mirror/libunwind/archive/release_$LLVM.tar.gz | tar xzf -\n-fi\n-\n-# fixme(mati865): Replace it with https://github.com/rust-lang/rust/pull/59089\n-mkdir libunwind-build\n-cd libunwind-build\n-cmake ../libunwind-release_$LLVM \\\n-          -DLLVM_PATH=/build/llvm-release_$LLVM \\\n-          -DLIBUNWIND_ENABLE_SHARED=0 \\\n-          -DCMAKE_C_COMPILER=$CC \\\n-          -DCMAKE_CXX_COMPILER=$CXX \\\n-          -DCMAKE_C_FLAGS=\"$CFLAGS\" \\\n-          -DCMAKE_CXX_FLAGS=\"$CXXFLAGS\"\n-\n-hide_output make -j$(nproc)\n-cp lib/libunwind.a $OUTPUT/$TARGET/lib\n-cd - && rm -rf libunwind-build"}, {"sha": "d847c407aba679135ca14c7b56cf50b0ca3ed0b3", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -20,9 +20,11 @@ exit 1\n TAG=$1\n shift\n \n+# Ancient binutils versions don't understand debug symbols produced by more recent tools.\n+# Apparently applying `-fPIC` everywhere allows them to link successfully.\n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-MUSL=musl-1.1.20\n+MUSL=musl-1.1.22\n \n # may have been downloaded in a previous run\n if [ ! -d $MUSL ]; then\n@@ -38,27 +40,3 @@ else\n fi\n hide_output make install\n hide_output make clean\n-\n-cd ..\n-\n-LLVM=70\n-\n-# may have been downloaded in a previous run\n-if [ ! -d libunwind-release_$LLVM ]; then\n-  curl -L https://github.com/llvm-mirror/llvm/archive/release_$LLVM.tar.gz | tar xzf -\n-  curl -L https://github.com/llvm-mirror/libunwind/archive/release_$LLVM.tar.gz | tar xzf -\n-fi\n-\n-mkdir libunwind-build\n-cd libunwind-build\n-cmake ../libunwind-release_$LLVM \\\n-          -DLLVM_PATH=/build/llvm-release_$LLVM \\\n-          -DLIBUNWIND_ENABLE_SHARED=0 \\\n-          -DCMAKE_C_COMPILER=$CC \\\n-          -DCMAKE_CXX_COMPILER=$CXX \\\n-          -DCMAKE_C_FLAGS=\"$CFLAGS\" \\\n-          -DCMAKE_CXX_FLAGS=\"$CXXFLAGS\"\n-\n-hide_output make -j$(nproc)\n-cp lib/libunwind.a /musl-$TAG/lib\n-cd ../ && rm -rf libunwind-build"}, {"sha": "efeb0ed0d72d0f9461f17a4f701039e2f4dee1d7", "filename": "src/ci/docker/scripts/sccache.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,6 +1,6 @@\n set -ex\n \n curl -fo /usr/local/bin/sccache \\\n-  https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-unknown-linux-musl\n+  https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2018-04-02-sccache-x86_64-unknown-linux-musl\n \n chmod +x /usr/local/bin/sccache"}, {"sha": "6a2600d875642f55588d6c6d3e216beacb4c550c", "filename": "src/ci/docker/test-various/Dockerfile", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -11,14 +11,12 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n   xz-utils \\\n   wget \\\n   patch\n \n-# FIXME: build the `ptx-linker` instead.\n-RUN curl -sL https://github.com/denzp/rust-ptx-linker/releases/download/v0.9.0-alpha.2/rust-ptx-linker.linux64.tar.gz | \\\n-  tar -xzvC /usr/bin\n-\n RUN curl -sL https://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.xz | \\\n   tar -xJ\n \n@@ -45,7 +43,6 @@ ENV WASM_TARGETS=wasm32-unknown-unknown\n ENV WASM_SCRIPT python2.7 /checkout/x.py test --target $WASM_TARGETS \\\n   src/test/run-make \\\n   src/test/ui \\\n-  src/test/run-pass \\\n   src/test/compile-fail \\\n   src/test/mir-opt \\\n   src/test/codegen-units \\"}, {"sha": "b2748d9c2ab79696791838f8d063e08f2619fc51", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -17,6 +17,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n   xz-utils \\\n   lld \\\n   clang\n@@ -31,7 +33,6 @@ ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-debug \\\n       --enable-lld \\\n-      --enable-lldb \\\n       --enable-optimize \\\n       --set llvm.use-linker=lld \\\n       --set target.x86_64-unknown-linux-gnu.linker=clang \\"}, {"sha": "364f45aba2c00442b82b75b3f887f75cde9f1cb5", "filename": "src/ci/docker/x86_64-gnu-distcheck/Dockerfile", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -21,3 +21,10 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --set rust.ignore-git=false\n ENV SCRIPT python2.7 ../x.py test distcheck\n ENV DIST_SRC 1\n+\n+# The purpose of this builder is to test that we can `./x.py test` successfully\n+# from a tarball, not to test LLVM/rustc's own set of assertions. These cause a\n+# significant hit to CI compile time (over a half hour as observed in #61185),\n+# so disable assertions for this builder.\n+ENV NO_LLVM_ASSERTIONS=1\n+ENV NO_DEBUG_ASSERTIONS=1"}, {"sha": "207f972c3cdae40c5187894068ff7343fe0cb086", "filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -11,6 +11,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n   xz-utils\n \n COPY scripts/sccache.sh /scripts/\n@@ -20,3 +22,9 @@ ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-full-bootstrap\n ENV SCRIPT python2.7 ../x.py build\n+\n+# In general this just slows down the build and we're just a smoke test that\n+# a full bootstrap works in general, so there's not much need to take this\n+# penalty in build times.\n+ENV NO_LLVM_ASSERTIONS 1\n+ENV NO_DEBUG_ASSERTIONS 1"}, {"sha": "6dbbb2203470ba0b5da1c94db33585b239a64743", "filename": "src/ci/docker/x86_64-gnu-llvm-6.0/Dockerfile", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-6.0%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-6.0%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-6.0%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -13,6 +13,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   llvm-6.0-tools \\\n   libedit-dev \\\n+  libssl-dev \\\n+  pkg-config \\\n   zlib1g-dev \\\n   xz-utils\n \n@@ -24,4 +26,10 @@ ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --llvm-root=/usr/lib/llvm-6.0 \\\n       --enable-llvm-link-shared\n-ENV RUST_CHECK_TARGET check\n+ENV SCRIPT python2.7 ../x.py test src/tools/tidy && python2.7 ../x.py test\n+\n+# The purpose of this container isn't to test with debug assertions and\n+# this is run on all PRs, so let's get speedier builds by disabling these extra\n+# checks.\n+ENV NO_DEBUG_ASSERTIONS=1\n+ENV NO_LLVM_ASSERTIONS=1"}, {"sha": "6a5c7f5d9e6103c34e51b33903c282bef4f444eb", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -11,6 +11,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n   xz-utils\n \n COPY scripts/sccache.sh /scripts/\n@@ -19,4 +21,4 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu \\\n   --disable-optimize-tests \\\n   --set rust.test-compare-mode\n-ENV RUST_CHECK_TARGET check\n+ENV SCRIPT python2.7 ../x.py test"}, {"sha": "8035195c6ed0ae5cdee52296fa294ed6fde3c2d5", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -21,8 +21,10 @@ COPY x86_64-gnu-tools/checkregression.py /tmp/\n COPY x86_64-gnu-tools/checktools.sh /tmp/\n COPY x86_64-gnu-tools/repo.sh /tmp/\n \n+# Run rustbook with `linkcheck` feature enabled\n+ENV CHECK_LINKS 1\n+\n ENV RUST_CONFIGURE_ARGS \\\n   --build=x86_64-unknown-linux-gnu \\\n-  --enable-test-miri \\\n   --save-toolstates=/tmp/toolstates.json\n ENV SCRIPT /tmp/checktools.sh ../x.py /tmp/toolstates.json linux"}, {"sha": "4fbb8c4d2034900dda85f48c5d4afa55b2834c4f", "filename": "src/ci/docker/x86_64-gnu-tools/checkregression.py", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,9 +1,18 @@\n #!/usr/bin/env python\n # -*- coding: utf-8 -*-\n \n+## This script has two purposes: detect any tool that *regressed*, which is used\n+## during the week before the beta branches to reject PRs; and detect any tool\n+## that *changed* to see if we need to update the toolstate repo.\n+\n import sys\n import json\n \n+# Regressions for these tools during the beta cutoff week do not cause failure.\n+# See `status_check` in `checktools.sh` for tools that have to pass on the\n+# beta/stable branches.\n+REGRESSION_OK = [\"rustc-guide\", \"miri\", \"embedded-book\"]\n+\n if __name__ == '__main__':\n     os_name = sys.argv[1]\n     toolstate_file = sys.argv[2]\n@@ -21,12 +30,7 @@\n         state = cur[os_name]\n         new_state = toolstate.get(tool, '')\n         if verb == 'regressed':\n-            if tool == 'rls':\n-                # Temporary override until\n-                # https://github.com/rust-lang/rust/issues/60848 is fixed.\n-                updated = False\n-            else:\n-                updated = new_state < state\n+            updated = new_state < state\n         elif verb == 'changed':\n             updated = new_state != state\n         else:\n@@ -37,7 +41,8 @@\n                 'The state of \"{}\" has {} from \"{}\" to \"{}\"'\n                 .format(tool, verb, state, new_state)\n             )\n-            regressed = True\n+            if not (verb == 'regressed' and tool in REGRESSION_OK):\n+                regressed = True\n \n     if regressed:\n         sys.exit(1)"}, {"sha": "4243effdf9b4b22074af2022a0e49feb53d62580", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -25,6 +25,7 @@ python2.7 \"$X_PY\" test --no-fail-fast \\\n     src/doc/rust-by-example \\\n     src/doc/embedded-book \\\n     src/doc/edition-guide \\\n+    src/doc/rustc-guide \\\n     src/tools/clippy \\\n     src/tools/rls \\\n     src/tools/rustfmt \\\n@@ -35,12 +36,17 @@ set -e\n cat \"$TOOLSTATE_FILE\"\n echo\n \n+# This function checks if a particular tool is *not* in status \"test-pass\".\n+check_tool_failed() {\n+    grep -vq '\"'\"$1\"'\":\"test-pass\"' \"$TOOLSTATE_FILE\"\n+}\n+\n # This function checks that if a tool's submodule changed, the tool's state must improve\n-verify_status() {\n+verify_submodule_changed() {\n     echo \"Verifying status of $1...\"\n     if echo \"$CHANGED_FILES\" | grep -q \"^M[[:blank:]]$2$\"; then\n         echo \"This PR updated '$2', verifying if status is 'test-pass'...\"\n-        if grep -vq '\"'\"$1\"'\":\"test-pass\"' \"$TOOLSTATE_FILE\"; then\n+        if check_tool_failed \"$1\"; then\n             echo\n             echo \"\u26a0\ufe0f We detected that this PR updated '$1', but its tests failed.\"\n             echo\n@@ -55,34 +61,43 @@ verify_status() {\n     fi\n }\n \n-# deduplicates the submodule check and the assertion that on beta some tools MUST be passing\n+# deduplicates the submodule check and the assertion that on beta some tools MUST be passing.\n+# $1 should be \"submodule_changed\" to only check tools that got changed by this PR,\n+# or \"beta_required\" to check all tools that have $2 set to \"beta\".\n check_dispatch() {\n     if [ \"$1\" = submodule_changed ]; then\n         # ignore $2 (branch id)\n-        verify_status $3 $4\n+        verify_submodule_changed $3 $4\n     elif [ \"$2\" = beta ]; then\n         echo \"Requiring test passing for $3...\"\n-        if grep -q '\"'\"$3\"'\":\"\\(test\\|build\\)-fail\"' \"$TOOLSTATE_FILE\"; then\n+        if check_tool_failed \"$3\"; then\n             exit 4\n         fi\n     fi\n }\n \n-# list all tools here\n+# List all tools here.\n+# This function gets called with \"submodule_changed\" for each PR that changed a submodule,\n+# and with \"beta_required\" for each PR that lands on beta/stable.\n+# The purpose of this function is to *reject* PRs if a tool is not \"test-pass\" and\n+# (a) the tool's submodule has been updated, or (b) we landed on beta/stable and the\n+# tool has to \"test-pass\" on that branch.\n status_check() {\n     check_dispatch $1 beta book src/doc/book\n     check_dispatch $1 beta nomicon src/doc/nomicon\n     check_dispatch $1 beta reference src/doc/reference\n     check_dispatch $1 beta rust-by-example src/doc/rust-by-example\n-    # Temporarily disabled until\n-    # https://github.com/rust-lang/rust/issues/60459 is fixed.\n-    # check_dispatch $1 beta edition-guide src/doc/edition-guide\n+    check_dispatch $1 beta edition-guide src/doc/edition-guide\n     check_dispatch $1 beta rls src/tools/rls\n     check_dispatch $1 beta rustfmt src/tools/rustfmt\n     check_dispatch $1 beta clippy-driver src/tools/clippy\n-    # these tools are not required for beta to successfully branch\n+    # These tools are not required on the beta/stable branches, but they *do* cause\n+    # PRs to fail if a submodule update does not fix them.\n+    # They will still cause failure during the beta cutoff week, unless `checkregression.py`\n+    # exempts them from that.\n     check_dispatch $1 nightly miri src/tools/miri\n     check_dispatch $1 nightly embedded-book src/doc/embedded-book\n+    check_dispatch $1 nightly rustc-guide src/doc/rustc-guide\n }\n \n # If this PR is intended to update one of these tools, do not let the build pass\n@@ -91,12 +106,14 @@ status_check() {\n status_check \"submodule_changed\"\n \n CHECK_NOT=\"$(readlink -f \"$(dirname $0)/checkregression.py\")\"\n+# This callback is called by `commit_toolstate_change`, see `repo.sh`.\n change_toolstate() {\n     # only update the history\n     if python2.7 \"$CHECK_NOT\" \"$OS\" \"$TOOLSTATE_FILE\" \"_data/latest.json\" changed; then\n         echo 'Toolstate is not changed. Not updating.'\n     else\n         if [ $SIX_WEEK_CYCLE -ge 35 ]; then\n+            # Reject any regressions during the week before beta cutoff.\n             python2.7 \"$CHECK_NOT\" \"$OS\" \"$TOOLSTATE_FILE\" \"_data/latest.json\" regressed\n         fi\n         sed -i \"1 a\\\\\n@@ -106,7 +123,7 @@ $COMMIT\\t$(cat \"$TOOLSTATE_FILE\")\n }\n \n if [ \"$RUST_RELEASE_CHANNEL\" = nightly ]; then\n-    if [ -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_set}\" ]; then\n+    if [ -n \"${TOOLSTATE_PUBLISH+is_set}\" ]; then\n         . \"$(dirname $0)/repo.sh\"\n         MESSAGE_FILE=$(mktemp -t msg.XXXXXX)\n         echo \"($OS CI update)\" > \"$MESSAGE_FILE\""}, {"sha": "82700a00fb6af61e398dcceb7e3700cba8568af3", "filename": "src/ci/docker/x86_64-gnu-tools/repo.sh", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -5,8 +5,8 @@\n #\n # The function relies on a GitHub bot user, which should have a Personal access\n # token defined in the environment variable $TOOLSTATE_REPO_ACCESS_TOKEN. If for\n-# some reason you need to change the token, please update `.travis.yml` and\n-# `appveyor.yml`:\n+# some reason you need to change the token, please update the Azure Pipelines\n+# variable group.\n #\n #   1. Generate a new Personal access token:\n #\n@@ -18,28 +18,9 @@\n #           Save it somewhere secure, as the token would be gone once you leave\n #           the page.\n #\n-#   2. Encrypt the token for Travis CI\n+#   2. Update the variable group in Azure Pipelines\n #\n-#       * Install the `travis` tool locally (`gem install travis`).\n-#       * Encrypt the token:\n-#           ```\n-#           travis -r rust-lang/rust encrypt \\\n-#                   TOOLSTATE_REPO_ACCESS_TOKEN=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n-#           ```\n-#       * Copy output to replace the existing one in `.travis.yml`.\n-#       * Details of this step can be found in\n-#           <https://docs.travis-ci.com/user/encryption-keys/>\n-#\n-#   3. Encrypt the token for AppVeyor\n-#\n-#       * Login to AppVeyor using your main account, and login as the rust-lang\n-#           organization.\n-#       * Open the [\"Encrypt data\" tool](https://ci.appveyor.com/tools/encrypt)\n-#       * Paste the 40-digit token into the \"Value to encrypt\" box, then click\n-#           \"Encrypt\"\n-#       * Copy the output to replace the existing one in `appveyor.yml`.\n-#       * Details of this step can be found in\n-#           <https://www.appveyor.com/docs/how-to/git-push/>\n+#       * Ping a member of the infrastructure team to do this.\n #\n #   4. Replace the email address below if the bot account identity is changed\n #\n@@ -55,13 +36,20 @@ commit_toolstate_change() {\n     git config --global credential.helper store\n     printf 'https://%s:x-oauth-basic@github.com\\n' \"$TOOLSTATE_REPO_ACCESS_TOKEN\" \\\n         > \"$HOME/.git-credentials\"\n-    git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n+    git clone --depth=1 $TOOLSTATE_REPO\n \n     cd rust-toolstate\n     FAILURE=1\n     MESSAGE_FILE=\"$1\"\n     shift\n     for RETRY_COUNT in 1 2 3 4 5; do\n+        # Call the callback.\n+        # - If we are in the `auto` branch (pre-landing), this is called from `checktools.sh` and\n+        #   the callback is `change_toolstate` in that file. The purpose of this is to publish the\n+        #   test results (the new commit-to-toolstate mapping) in the toolstate repo.\n+        # - If we are in the `master` branch (post-landing), this is called by the CI pipeline\n+        #   and the callback is `src/tools/publish_toolstate.py`. The purpose is to publish\n+        #   the new \"current\" toolstate in the toolstate repo.\n         \"$@\"\n         # `git commit` failing means nothing to commit.\n         FAILURE=0"}, {"sha": "4ec4364721393691ced50f59359f95aa82e2bb20", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -11,6 +11,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n   xz-utils\n \n COPY scripts/sccache.sh /scripts/"}, {"sha": "c7c3b0a5fbf5b0733064b0a46695e8f9a80c80ff", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,15 +1,16 @@\n #!/usr/bin/env bash\n \n+# FIXME(61301): we need to debug spurious failures with this on Windows on\n+# Azure, so let's print more information in the logs.\n+set -x\n+\n set -o errexit\n set -o pipefail\n set -o nounset\n \n ci_dir=$(cd $(dirname $0) && pwd)\n . \"$ci_dir/shared.sh\"\n \n-travis_fold start init_repo\n-travis_time_start\n-\n REPO_DIR=\"$1\"\n CACHE_DIR=\"$2\"\n \n@@ -69,5 +70,3 @@ retry sh -c \"git submodule deinit -f $use_git && \\\n     git submodule sync && \\\n     git submodule update -j 16 --init --recursive $use_git\"\n wait\n-travis_fold end init_repo\n-travis_time_finish"}, {"sha": "69c8d2e3099ab9bdf70e8dc8894495fe011b6d68", "filename": "src/ci/install-awscli.sh", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Finstall-awscli.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Finstall-awscli.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finstall-awscli.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,35 @@\n+#!/bin/bash\n+# This script downloads and installs awscli from the packages mirrored in our\n+# own S3 bucket. This follows the recommendations at:\n+#\n+#    https://packaging.python.org/guides/index-mirrors-and-caches/#caching-with-pip\n+#\n+# To create a new mirrored copy you can run the command:\n+#\n+#    pip wheel awscli\n+#\n+# Before compressing please make sure all the wheels end with `-none-any.whl`.\n+# If that's not the case you'll need to remove the non-cross-platform ones and\n+# replace them with the .tar.gz downloaded from https://pypi.org. Also make\n+# sure it's possible to call this script with both Python 2 and Python 3.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+MIRROR=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2019-07-27-awscli.tar\"\n+DEPS_DIR=\"/tmp/awscli-deps\"\n+\n+pip=\"pip\"\n+pipflags=\"\"\n+if [[ \"${AGENT_OS}\" == \"Linux\" ]]; then\n+    pip=\"pip3\"\n+    pipflags=\"--user\"\n+\n+    sudo apt-get install -y python3-setuptools\n+    echo \"##vso[task.prependpath]$HOME/.local/bin\"\n+fi\n+\n+mkdir -p \"${DEPS_DIR}\"\n+curl \"${MIRROR}\" | tar xf - -C \"${DEPS_DIR}\"\n+\"${pip}\" install ${pipflags} --no-index \"--find-links=${DEPS_DIR}\" awscli\n+rm -rf \"${DEPS_DIR}\""}, {"sha": "457ba9717120710623411d44e7d8afdca1831882", "filename": "src/ci/run.sh", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -23,7 +23,9 @@ fi\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n-if [ \"$TRAVIS\" != \"true\" ] || [ \"$TRAVIS_BRANCH\" == \"auto\" ]; then\n+branch_name=$(getCIBranch)\n+\n+if [ ! isCI ] || [ \"$branch_name\" = \"auto\" ] || [ \"$branch_name\" = \"try\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n fi\n \n@@ -44,10 +46,11 @@ fi\n # FIXME: need a scheme for changing this `nightly` value to `beta` and `stable`\n #        either automatically or manually.\n export RUST_RELEASE_CHANNEL=nightly\n-if [ \"$DEPLOY$DEPLOY_ALT\" != \"\" ]; then\n+if [ \"$DEPLOY$DEPLOY_ALT\" = \"1\" ]; then\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --release-channel=$RUST_RELEASE_CHANNEL\"\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-static-stdcpp\"\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set rust.remap-debuginfo\"\n+  RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --debuginfo-level-std=1\"\n \n   if [ \"$NO_LLVM_ASSERTIONS\" = \"1\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\"\n@@ -75,6 +78,21 @@ if [ \"$RUST_RELEASE_CHANNEL\" = \"nightly\" ] || [ \"$DIST_REQUIRE_ALL_TOOLS\" = \"\" ]\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-missing-tools\"\n fi\n \n+# Print the date from the local machine and the date from an external source to\n+# check for clock drifts. An HTTP URL is used instead of HTTPS since on Azure\n+# Pipelines it happened that the certificates were marked as expired.\n+datecheck() {\n+  echo \"== clock drift check ==\"\n+  echo -n \"  local time: \"\n+  date\n+  echo -n \"  network time: \"\n+  curl -fs --head http://detectportal.firefox.com/success.txt | grep ^Date: \\\n+      | sed 's/Date: //g' || true\n+  echo \"== end clock drift check ==\"\n+}\n+datecheck\n+trap datecheck EXIT\n+\n # We've had problems in the past of shell scripts leaking fds into the sccache\n # server (#48192) which causes Cargo to erroneously think that a build script\n # hasn't finished yet. Try to solve that problem by starting a very long-lived\n@@ -88,28 +106,15 @@ if [ \"$RUN_CHECK_WITH_PARALLEL_QUERIES\" != \"\" ]; then\n   rm -rf build\n fi\n \n-travis_fold start configure\n-travis_time_start\n $SRC/configure $RUST_CONFIGURE_ARGS\n-travis_fold end configure\n-travis_time_finish\n \n-travis_fold start make-prepare\n-travis_time_start\n retry make prepare\n-travis_fold end make-prepare\n-travis_time_finish\n \n-travis_fold start check-bootstrap\n-travis_time_start\n make check-bootstrap\n-travis_fold end check-bootstrap\n-travis_time_finish\n \n # Display the CPU and memory information. This helps us know why the CI timing\n # is fluctuating.\n-travis_fold start log-system-info\n-if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+if isOSX; then\n     system_profiler SPHardwareDataType || true\n     sysctl hw || true\n     ncpus=$(sysctl -n hw.ncpu)\n@@ -118,23 +123,18 @@ else\n     cat /proc/meminfo || true\n     ncpus=$(grep processor /proc/cpuinfo | wc -l)\n fi\n-travis_fold end log-system-info\n \n if [ ! -z \"$SCRIPT\" ]; then\n   sh -x -c \"$SCRIPT\"\n else\n   do_make() {\n-    travis_fold start \"make-$1\"\n-    travis_time_start\n     echo \"make -j $ncpus $1\"\n     make -j $ncpus $1\n     local retval=$?\n-    travis_fold end \"make-$1\"\n-    travis_time_finish\n     return $retval\n   }\n \n-  do_make tidy\n-  do_make all\n   do_make \"$RUST_CHECK_TARGET\"\n fi\n+\n+sccache --show-stats || true"}, {"sha": "b093a07ec5c5aac8f116a21ee571b14c3fa8208a", "filename": "src/ci/shared.sh", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fci%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fshared.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -24,36 +24,14 @@ function retry {\n   done\n }\n \n-if ! declare -F travis_fold; then\n-  if [ \"${TRAVIS-false}\" = 'true' ]; then\n-    # This is a trimmed down copy of\n-    # https://github.com/travis-ci/travis-build/blob/master/lib/travis/build/templates/header.sh\n-    travis_fold() {\n-      echo -en \"travis_fold:$1:$2\\r\\033[0K\"\n-    }\n-    travis_time_start() {\n-      travis_timer_id=$(printf %08x $(( RANDOM * RANDOM )))\n-      travis_start_time=$(travis_nanoseconds)\n-      echo -en \"travis_time:start:$travis_timer_id\\r\\033[0K\"\n-    }\n-    travis_time_finish() {\n-      travis_end_time=$(travis_nanoseconds)\n-      local duration=$(($travis_end_time-$travis_start_time))\n-      local msg=\"travis_time:end:$travis_timer_id\"\n-      echo -en \"\\n$msg:start=$travis_start_time,finish=$travis_end_time,duration=$duration\\r\\033[0K\"\n-    }\n-    if [ $(uname) = 'Darwin' ]; then\n-      travis_nanoseconds() {\n-        date -u '+%s000000000'\n-      }\n-    else\n-      travis_nanoseconds() {\n-        date -u '+%s%N'\n-      }\n-    fi\n-  else\n-    travis_fold() { return 0; }\n-    travis_time_start() { return 0; }\n-    travis_time_finish() { return 0; }\n-  fi\n-fi\n+function isCI {\n+  [ \"$CI\" = \"true\" ] || [ \"$TF_BUILD\" = \"True\" ]\n+}\n+\n+function isOSX {\n+  [ \"$AGENT_OS\" = \"Darwin\" ]\n+}\n+\n+function getCIBranch {\n+  echo \"$BUILD_SOURCEBRANCHNAME\"\n+}"}, {"sha": "7ddc46460f09a5cd9bd2a620565bdc20b3315ea9", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1 +1 @@\n-Subproject commit 29fe982990e43b9367be0ff47abc82fb2123fd03\n+Subproject commit 7ddc46460f09a5cd9bd2a620565bdc20b3315ea9"}, {"sha": "e58bc4ca104e890ac56af846877c874c432a64b5", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1 +1 @@\n-Subproject commit 581c6cccfaf995394ea9dcac362dc8e731c18558\n+Subproject commit e58bc4ca104e890ac56af846877c874c432a64b5"}, {"sha": "c5da1e11915d3f28266168baaf55822f7e3fe999", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1 +1 @@\n-Subproject commit 9858872bd1b7dbba5ec27dc30d34eba00acd7ef9\n+Subproject commit c5da1e11915d3f28266168baaf55822f7e3fe999"}, {"sha": "8a7d05615e5bc0a7fb961b4919c44f5221ee54da", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1 +1 @@\n-Subproject commit c656171b749b7307f21371dd0d3278efee5573b8\n+Subproject commit 8a7d05615e5bc0a7fb961b4919c44f5221ee54da"}, {"sha": "b4b3536839042a6743fc76f0d9ad2a812020aeaa", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1 +1 @@\n-Subproject commit 862b669c395822bb0938781d74f860e5762ad4fb\n+Subproject commit b4b3536839042a6743fc76f0d9ad2a812020aeaa"}, {"sha": "f2c15ba5ee89ae9469a2cf60494977749901d764", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1 +1 @@\n-Subproject commit 811c697b232c611ed754d279ed20643a0c4096f6\n+Subproject commit f2c15ba5ee89ae9469a2cf60494977749901d764"}, {"sha": "6f4ba673ff9d4613e98415bc095347a6a0031e9c", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1 +1 @@\n-Subproject commit 3cb727b62b953d59b4360d39aa68b6dc8f157655\n+Subproject commit 6f4ba673ff9d4613e98415bc095347a6a0031e9c"}, {"sha": "3cda8d927973ca64c7210d37ecd750093f838ca7", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -13,5 +13,6 @@\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)\n     - [Custom Targets](targets/custom.md)\n+- [Profile-guided Optimization](profile-guided-optimization.md)\n - [Linker-plugin based LTO](linker-plugin-lto.md)\n - [Contributing to `rustc`](contributing.md)"}, {"sha": "5c41acc6581c5ae04564187de3a84b6ad072b26a", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -214,3 +214,20 @@ This option lets you control what happens when the code panics.\n ## incremental\n \n This flag allows you to enable incremental compilation.\n+\n+## profile-generate\n+\n+This flag allows for creating instrumented binaries that will collect\n+profiling data for use with profile-guided optimization (PGO). The flag takes\n+an optional argument which is the path to a directory into which the\n+instrumented binary will emit the collected data. See the chapter on\n+[profile-guided optimization] for more information.\n+\n+## profile-use\n+\n+This flag specifies the profiling data file to be used for profile-guided\n+optimization (PGO). The flag takes a mandatory argument which is the path\n+to a valid `.profdata` file. See the chapter on\n+[profile-guided optimization] for more information.\n+\n+[profile-guided optimization]: ../profile-guided-optimization.md"}, {"sha": "d774e465118b3d520be86a402fc64466b214a5c1", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -161,11 +161,11 @@ of print values are:\n \n ## `-g`: include debug information\n \n-A synonym for `-C debuginfo=2`, for more see [here](codegen-options/index.html#debuginfo).\n+A synonym for `-C debuginfo=2`, for more see [here](codegen-options/index.md#debuginfo).\n \n ## `-O`: optimize your code\n \n-A synonym for `-C opt-level=2`, for more see [here](codegen-options/index.html#opt-level).\n+A synonym for `-C opt-level=2`, for more see [here](codegen-options/index.md#opt-level).\n \n ## `-o`: filename of the output\n \n@@ -188,23 +188,23 @@ and instead produce a test harness.\n \n ## `--target`: select a target triple to build\n \n-This controls which [target](targets/index.html) to produce.\n+This controls which [target](targets/index.md) to produce.\n \n ## `-W`: set lint warnings\n \n-This flag will set which lints should be set to the [warn level](lints/levels.html#warn).\n+This flag will set which lints should be set to the [warn level](lints/levels.md#warn).\n \n ## `-A`: set lint allowed\n \n-This flag will set which lints should be set to the [allow level](lints/levels.html#allow).\n+This flag will set which lints should be set to the [allow level](lints/levels.md#allow).\n \n ## `-D`: set lint denied\n \n-This flag will set which lints should be set to the [deny level](lints/levels.html#deny).\n+This flag will set which lints should be set to the [deny level](lints/levels.md#deny).\n \n ## `-F`: set lint forbidden\n \n-This flag will set which lints should be set to the [forbid level](lints/levels.html#forbid).\n+This flag will set which lints should be set to the [forbid level](lints/levels.md#forbid).\n \n ## `-Z`: set unstable options\n \n@@ -215,11 +215,11 @@ run: `rustc -Z help`.\n \n ## `--cap-lints`: set the most restrictive lint level\n \n-This flag lets you 'cap' lints, for more, [see here](lints/levels.html#capping-lints).\n+This flag lets you 'cap' lints, for more, [see here](lints/levels.md#capping-lints).\n \n ## `-C`/`--codegen`: code generation options\n \n-This flag will allow you to set [codegen options](codegen-options/index.html).\n+This flag will allow you to set [codegen options](codegen-options/index.md).\n \n ## `-V`/`--version`: print a version\n \n@@ -271,3 +271,36 @@ current directory out of pathnames emitted into the object files. The\n replacement is purely textual, with no consideration of the current system's\n pathname syntax. For example `--remap-path-prefix foo=bar` will match\n `foo/lib.rs` but not `./foo/lib.rs`.\n+\n+## `--json`: configure json messages printed by the compiler\n+\n+When the `--error-format=json` option is passed to rustc then all of the\n+compiler's diagnostic output will be emitted in the form of JSON blobs. The\n+`--json` argument can be used in conjunction with `--error-format=json` to\n+configure what the JSON blobs contain as well as which ones are emitted.\n+\n+With `--error-format=json` the compiler will always emit any compiler errors as\n+a JSON blob, but the following options are also available to the `--json` flag\n+to customize the output:\n+\n+- `diagnostic-short` - json blobs for diagnostic messages should use the \"short\"\n+  rendering instead of the normal \"human\" default. This means that the output of\n+  `--error-format=short` will be embedded into the JSON diagnostics instead of\n+  the default `--error-format=human`.\n+\n+- `diagnostic-rendered-ansi` - by default JSON blobs in their `rendered` field\n+  will contain a plain text rendering of the diagnostic. This option instead\n+  indicates that the diagnostic should have embedded ANSI color codes intended\n+  to be used to colorize the message in the manner rustc typically already does\n+  for terminal outputs. Note that this is usefully combined with crates like\n+  `fwdansi` to translate these ANSI codes on Windows to console commands or\n+  `strip-ansi-escapes` if you'd like to optionally remove the ansi colors\n+  afterwards.\n+\n+- `artifacts` - this instructs rustc to emit a JSON blob for each artifact that\n+  is emitted. An artifact corresponds to a request from the `--emit` CLI\n+  argument, and as soon as the artifact is available on the filesystem a\n+  notification will be emitted.\n+\n+Note that it is invalid to combine the `--json` argument with the `--color`\n+argument, and it is required to combine `--json` with `--error-format=json`."}, {"sha": "2ae726c4ba61d6af6744f03c82ff644e3933f92a", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -100,9 +100,10 @@ LLVM. However, the approximation is usually reliable.\n \n The following table shows known good combinations of toolchain versions.\n \n-|           | Clang 7   | Clang 8   |\n+|           |  Clang 7  |  Clang 8  |\n |-----------|-----------|-----------|\n | Rust 1.34 |     \u2717     |     \u2713     |\n-| Rust 1.35 |     \u2717     |    \u2713(?)   |\n+| Rust 1.35 |     \u2717     |     \u2713     |\n+| Rust 1.36 |     \u2717     |     \u2713     |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "9010d436eb5cfa6eac08b2915252459e8d26d78b", "filename": "src/doc/rustc/src/lints/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -19,7 +19,7 @@ warning: unused variable: `x`\n 2 |     let x = 5;\n   |         ^\n   |\n-  = note: #[warn(unused_variables)] on by default\n+  = note: `#[warn(unused_variables)]` on by default\n   = note: to avoid this warning, consider using `_x` instead\n ```\n "}, {"sha": "834a4a79727ab9a84346c9e88c1c7f0799042280", "filename": "src/doc/rustc/src/lints/levels.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -53,7 +53,7 @@ warning: unused variable: `x`\n 2 |     let x = 5;\n   |         ^\n   |\n-  = note: #[warn(unused_variables)] on by default\n+  = note: `#[warn(unused_variables)]` on by default\n   = note: to avoid this warning, consider using `_x` instead\n ```\n \n@@ -76,7 +76,7 @@ error: bitshift exceeds the type's number of bits\n 2 |     100u8 << 10;\n   |     ^^^^^^^^^^^\n   |\n-  = note: #[deny(exceeding_bitshifts)] on by default\n+  = note: `#[deny(exceeding_bitshifts)]` on by default\n ```\n \n What's the difference between an error from a lint and a regular old error?\n@@ -236,7 +236,7 @@ warning: bitshift exceeds the type's number of bits\n 2 |     100u8 << 10;\n   |     ^^^^^^^^^^^\n   |\n-  = note: #[warn(exceeding_bitshifts)] on by default\n+  = note: `#[warn(exceeding_bitshifts)]` on by default\n \n warning: this expression will panic at run-time\n  --> lib.rs:2:5"}, {"sha": "a6e4e166d7bc685971ab5b5a9e4010358a155dcf", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -165,7 +165,7 @@ pub struct Foo;\n When set to 'deny', this will produce:\n \n ```text\n-error: type does not implement `fmt::Debug`; consider adding #[derive(Debug)] or a manual implementation\n+error: type does not implement `fmt::Debug`; consider adding `#[derive(Debug)]` or a manual implementation\n  --> src/main.rs:3:1\n   |\n 3 | pub struct Foo;"}, {"sha": "6574267f185113f13da7fa7b93b0f05898255694", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -40,7 +40,7 @@ error: defaults for type parameters are only allowed in `struct`, `enum`, `type`\n 4 | fn foo<T=i32>(t: T) {}\n   |        ^\n   |\n-  = note: #[deny(invalid_type_param_default)] on by default\n+  = note: `#[deny(invalid_type_param_default)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #36887 <https://github.com/rust-lang/rust/issues/36887>\n ```\n@@ -74,7 +74,7 @@ error: private struct constructors are not usable through re-exports in outer mo\n 5 |         ::S;\n   |         ^^^\n   |\n-  = note: #[deny(legacy_constructor_visibility)] on by default\n+  = note: `#[deny(legacy_constructor_visibility)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #39207 <https://github.com/rust-lang/rust/issues/39207>\n ```\n@@ -84,9 +84,9 @@ error: private struct constructors are not usable through re-exports in outer mo\n \n The legacy_directory_ownership warning is issued when\n \n-* There is a non-inline module with a #[path] attribute (e.g. #[path = \"foo.rs\"] mod bar;),\n+* There is a non-inline module with a `#[path]` attribute (e.g. `#[path = \"foo.rs\"] mod bar;`),\n * The module's file (\"foo.rs\" in the above example) is not named \"mod.rs\", and\n-* The module's file contains a non-inline child module without a #[path] attribute.\n+* The module's file contains a non-inline child module without a `#[path]` attribute.\n \n The warning can be fixed by renaming the parent module to \"mod.rs\" and moving\n it into its own directory if appropriate.\n@@ -139,7 +139,7 @@ const FOO: i32 = 5;\n This will produce:\n \n ```text\n-error: const items should never be #[no_mangle]\n+error: const items should never be `#[no_mangle]`\n  --> src/main.rs:3:1\n   |\n 3 | const FOO: i32 = 5;\n@@ -187,7 +187,7 @@ error: parenthesized parameters may only be used with a trait\n 2 |   let x = 5 as usize();\n   |                     ^^\n   |\n-  = note: #[deny(parenthesized_params_in_types_and_modules)] on by default\n+  = note: `#[deny(parenthesized_params_in_types_and_modules)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #42238 <https://github.com/rust-lang/rust/issues/42238>\n ```"}, {"sha": "e486240fda896f164267093ecb8023483a0ea457", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -90,7 +90,7 @@ warning: floating-point literals cannot be used in patterns\n 4 |         5.0 => {},\n   |         ^^^\n   |\n-  = note: #[warn(illegal_floating_point_literal_pattern)] on by default\n+  = note: `#[warn(illegal_floating_point_literal_pattern)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n ```\n@@ -109,7 +109,7 @@ extern \"C\" {\n This will produce:\n \n ```text\n-warning: found struct without foreign-function-safe representation annotation in foreign module, consider adding a #[repr(C)] attribute to the type\n+warning: found struct without foreign-function-safe representation annotation in foreign module, consider adding a `#[repr(C)]` attribute to the type\n  --> src/main.rs:2:20\n   |\n 2 |     static STATIC: String;\n@@ -146,7 +146,7 @@ warning: cannot specify lifetime arguments explicitly if late bound lifetime par\n 8 |     S.late::<'static>(&0, &0);\n   |              ^^^^^^^\n   |\n-  = note: #[warn(late_bound_lifetime_arguments)] on by default\n+  = note: `#[warn(late_bound_lifetime_arguments)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n ```\n@@ -327,7 +327,7 @@ warning: patterns aren't allowed in methods without bodies\n 2 |     fn foo(mut arg: u8);\n   |            ^^^^^^^\n   |\n-  = note: #[warn(patterns_in_fns_without_body)] on by default\n+  = note: `#[warn(patterns_in_fns_without_body)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #35203 <https://github.com/rust-lang/rust/issues/35203>\n ```\n@@ -406,7 +406,7 @@ fn foo() {}\n This will produce:\n \n ```text\n-warning: function is marked #[no_mangle], but not exported\n+warning: function is marked `#[no_mangle]`, but not exported\n  --> src/main.rs:2:1\n   |\n 2 | fn foo() {}\n@@ -433,7 +433,7 @@ static X: i32 = 4;\n This will produce:\n \n ```text\n-warning: static is marked #[no_mangle], but not exported\n+warning: static is marked `#[no_mangle]`, but not exported\n  --> src/main.rs:2:1\n   |\n 2 | static X: i32 = 4;\n@@ -496,7 +496,7 @@ warning: borrow of packed field requires unsafe function or block (error E0133)\n 11 |     let y = &x.data.0;\n    |             ^^^^^^^^^\n    |\n-   = note: #[warn(safe_packed_borrows)] on by default\n+   = note: `#[warn(safe_packed_borrows)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n ```\n@@ -529,18 +529,21 @@ This lint detects bounds in type aliases. These are not currently enforced.\n Some example code that triggers this lint:\n \n ```rust\n+#[allow(dead_code)]\n type SendVec<T: Send> = Vec<T>;\n ```\n \n This will produce:\n \n ```text\n-warning: type alias is never used: `SendVec`\n- --> src/main.rs:1:1\n+warning: bounds on generic parameters are not enforced in type aliases\n+ --> src/lib.rs:2:17\n   |\n-1 | type SendVec<T: Send> = Vec<T>;\n-  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+2 | type SendVec<T: Send> = Vec<T>;\n+  |                 ^^^^\n   |\n+  = note: `#[warn(type_alias_bounds)]` on by default\n+  = help: the bound will not be checked when the type alias is used, and should be removed\n ```\n \n ## tyvar-behind-raw-pointer\n@@ -564,7 +567,7 @@ warning: type annotations needed\n 4 |     if data.is_null() {}\n   |             ^^^^^^^\n   |\n-  = note: #[warn(tyvar_behind_raw_pointer)] on by default\n+  = note: `#[warn(tyvar_behind_raw_pointer)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n   = note: for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n ```\n@@ -725,19 +728,17 @@ This lint detects attributes that were not used by the compiler. Some\n example code that triggers this lint:\n \n ```rust\n-#![feature(custom_attribute)]\n-\n-#![mutable_doc]\n+#![macro_export]\n ```\n \n This will produce:\n \n ```text\n warning: unused attribute\n- --> src/main.rs:4:1\n+ --> src/main.rs:1:1\n   |\n-4 | #![mutable_doc]\n-  | ^^^^^^^^^^^^^^^\n+1 | #![macro_export]\n+  | ^^^^^^^^^^^^^^^^\n   |\n ```\n \n@@ -786,7 +787,7 @@ warning: doc comment not used by rustdoc\n \n ## unused-features\n \n-This lint detects unused or unknown features found in crate-level #[feature] directives.\n+This lint detects unused or unknown features found in crate-level `#[feature]` directives.\n To fix this, simply remove the feature flag.\n \n ## unused-imports\n@@ -838,7 +839,7 @@ warning: unused macro definition\n \n ## unused-must-use\n \n-This lint detects unused result of a type flagged as #[must_use]. Some\n+This lint detects unused result of a type flagged as `#[must_use]`. Some\n example code that triggers this lint:\n \n ```rust"}, {"sha": "38be07a6440dab772e199f81687e2f4c3304812b", "filename": "src/doc/rustc/src/profile-guided-optimization.md", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,136 @@\n+# Profile Guided Optimization\n+\n+`rustc` supports doing profile-guided optimization (PGO).\n+This chapter describes what PGO is, what it is good for, and how it can be used.\n+\n+## What Is Profiled-Guided Optimization?\n+\n+The basic concept of PGO is to collect data about the typical execution of\n+a program (e.g. which branches it is likely to take) and then use this data\n+to inform optimizations such as inlining, machine-code layout,\n+register allocation, etc.\n+\n+There are different ways of collecting data about a program's execution.\n+One is to run the program inside a profiler (such as `perf`) and another\n+is to create an instrumented binary, that is, a binary that has data\n+collection built into it, and run that.\n+The latter usually provides more accurate data and it is also what is\n+supported by `rustc`.\n+\n+## Usage\n+\n+Generating a PGO-optimized program involves following a workflow with four steps:\n+\n+1. Compile the program with instrumentation enabled\n+   (e.g. `rustc -Cprofile-generate=/tmp/pgo-data main.rs`)\n+2. Run the instrumented program (e.g. `./main`) which generates a\n+   `default_<id>.profraw` file\n+3. Convert the `.profraw` file into a `.profdata` file using\n+   LLVM's `llvm-profdata` tool\n+4. Compile the program again, this time making use of the profiling data\n+   (for example `rustc -Cprofile-use=merged.profdata main.rs`)\n+\n+An instrumented program will create one or more `.profraw` files, one for each\n+instrumented binary. E.g. an instrumented executable that loads two instrumented\n+dynamic libraries at runtime will generate three `.profraw` files. Running an\n+instrumented binary multiple times, on the other hand, will re-use the\n+respective `.profraw` files, updating them in place.\n+\n+These `.profraw` files have to be post-processed before they can be fed back\n+into the compiler. This is done by the `llvm-profdata` tool. This tool\n+is most easily installed via\n+\n+```bash\n+rustup component add llvm-tools-preview\n+```\n+\n+Note that installing the `llvm-tools-preview` component won't add\n+`llvm-profdata` to the `PATH`. Rather, the tool can be found in:\n+\n+```bash\n+~/.rustup/toolchains/<toolchain>/lib/rustlib/<target-triple>/bin/\n+```\n+\n+Alternatively, an `llvm-profdata` coming with a recent LLVM or Clang\n+version usually works too.\n+\n+The `llvm-profdata` tool merges multiple `.profraw` files into a single\n+`.profdata` file that can then be fed back into the compiler via\n+`-Cprofile-use`:\n+\n+```bash\n+# STEP 1: Compile the binary with instrumentation\n+rustc -Cprofile-generate=/tmp/pgo-data -O ./main.rs\n+\n+# STEP 2: Run the binary a few times, maybe with common sets of args.\n+#         Each run will create or update `.profraw` files in /tmp/pgo-data\n+./main mydata1.csv\n+./main mydata2.csv\n+./main mydata3.csv\n+\n+# STEP 3: Merge and post-process all the `.profraw` files in /tmp/pgo-data\n+llvm-profdata merge -o ./merged.profdata /tmp/pgo-data\n+\n+# STEP 4: Use the merged `.profdata` file during optimization. All `rustc`\n+#         flags have to be the same.\n+rustc -Cprofile-use=./merged.profdata -O ./main.rs\n+```\n+\n+### A Complete Cargo Workflow\n+\n+Using this feature with Cargo works very similar to using it with `rustc`\n+directly. Again, we generate an instrumented binary, run it to produce data,\n+merge the data, and feed it back into the compiler. Some things of note:\n+\n+- We use the `RUSTFLAGS` environment variable in order to pass the PGO compiler\n+  flags to the compilation of all crates in the program.\n+\n+- We pass the `--target` flag to Cargo, which prevents the `RUSTFLAGS`\n+  arguments to be passed to Cargo build scripts. We don't want the build\n+  scripts to generate a bunch of `.profraw` files.\n+\n+- We pass `--release` to Cargo because that's where PGO makes the most sense.\n+  In theory, PGO can also be done on debug builds but there is little reason\n+  to do so.\n+\n+- It is recommended to use *absolute paths* for the argument of\n+  `-Cprofile-generate` and `-Cprofile-use`. Cargo can invoke `rustc` with\n+  varying working directories, meaning that `rustc` will not be able to find\n+  the supplied `.profdata` file. With absolute paths this is not an issue.\n+\n+- It is good practice to make sure that there is no left-over profiling data\n+  from previous compilation sessions. Just deleting the directory is a simple\n+  way of doing so (see `STEP 0` below).\n+\n+This is what the entire workflow looks like:\n+\n+```bash\n+# STEP 0: Make sure there is no left-over profiling data from previous runs\n+rm -rf /tmp/pgo-data\n+\n+# STEP 1: Build the instrumented binaries\n+RUSTFLAGS=\"-Cprofile-generate=/tmp/pgo-data\" \\\n+    cargo build --release --target=x86_64-unknown-linux-gnu\n+\n+# STEP 2: Run the instrumented binaries with some typical data\n+./target/x86_64-unknown-linux-gnu/release/myprogram mydata1.csv\n+./target/x86_64-unknown-linux-gnu/release/myprogram mydata2.csv\n+./target/x86_64-unknown-linux-gnu/release/myprogram mydata3.csv\n+\n+# STEP 3: Merge the `.profraw` files into a `.profdata` file\n+llvm-profdata merge -o /tmp/pgo-data/merged.profdata /tmp/pgo-data\n+\n+# STEP 4: Use the `.profdata` file for guiding optimizations\n+RUSTFLAGS=\"-Cprofile-use=/tmp/pgo-data/merged.profdata\" \\\n+    cargo build --release --target=x86_64-unknown-linux-gnu\n+```\n+\n+## Further Reading\n+\n+`rustc`'s PGO support relies entirely on LLVM's implementation of the feature\n+and is equivalent to what Clang offers via the `-fprofile-generate` /\n+`-fprofile-use` flags. The [Profile Guided Optimization][clang-pgo] section\n+in Clang's documentation is therefore an interesting read for anyone who wants\n+to use PGO with Rust.\n+\n+[clang-pgo]: https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization"}, {"sha": "b21defaedc31312147423bd3c051d9a34b472973", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -178,7 +178,7 @@ $ rustdoc src/lib.rs --passes strip-priv-imports\n An argument of \"list\" will print a list of possible \"rustdoc passes\", and other\n arguments will be the name of which passes to run in addition to the defaults.\n \n-For more details on passes, see [the chapter on them](passes.html).\n+For more details on passes, see [the chapter on them](passes.md).\n \n See also `--no-defaults`.\n \n@@ -194,7 +194,7 @@ By default, `rustdoc` will run several passes over your code. This\n removes those defaults, allowing you to use `--passes` to specify\n exactly which passes you want.\n \n-For more details on passes, see [the chapter on them](passes.html).\n+For more details on passes, see [the chapter on them](passes.md).\n \n See also `--passes`.\n \n@@ -207,7 +207,7 @@ $ rustdoc src/lib.rs --test\n ```\n \n This flag will run your code examples as tests. For more, see [the chapter\n-on documentation tests](documentation-tests.html).\n+on documentation tests](documentation-tests.md).\n \n See also `--test-args`.\n \n@@ -220,7 +220,7 @@ $ rustdoc src/lib.rs --test --test-args ignored\n ```\n \n This flag will pass options to the test runner when running documentation tests.\n-For more, see [the chapter on documentation tests](documentation-tests.html).\n+For more, see [the chapter on documentation tests](documentation-tests.md).\n \n See also `--test`.\n "}, {"sha": "12d4ea205b31e64308106741522b85a910300d99", "filename": "src/doc/rustdoc/src/passes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -5,8 +5,8 @@ Rustdoc has a concept called \"passes\". These are transformations that\n \n In addition to the passes below, check out the docs for these flags:\n \n-* [`--passes`](command-line-arguments.html#a--passes-add-more-rustdoc-passes)\n-* [`--no-defaults`](command-line-arguments.html#a--no-defaults-dont-run-default-passes)\n+* [`--passes`](command-line-arguments.md#--passes-add-more-rustdoc-passes)\n+* [`--no-defaults`](command-line-arguments.md#--no-defaults-dont-run-default-passes)\n \n ## Default passes\n "}, {"sha": "80ac405eb2f2a72d9d6bbcac0e1b15ce35e027c7", "filename": "src/doc/rustdoc/src/the-doc-attribute.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -202,7 +202,7 @@ mod bar {\n Now we'll have a `Re-exports` line, and `Bar` will not link to anywhere.\n \n One special case: In Rust 2018 and later, if you `pub use` one of your dependencies, `rustdoc` will\n-not eagerly inline it as a module unless you add `#[doc(inline)}`.\n+not eagerly inline it as a module unless you add `#[doc(inline)]`.\n \n ## `#[doc(hidden)]`\n "}, {"sha": "6e32468b64dee0f4c4503f90e3424fd53dfdb61e", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -183,9 +183,8 @@ Book][unstable-masked] and [its tracking issue][issue-masked].\n \n As designed in [RFC 1990], Rustdoc can read an external file to use as a type's documentation. This\n is useful if certain documentation is so long that it would break the flow of reading the source.\n-Instead of writing it all inline, writing `#[doc(include = \"sometype.md\")]` (where `sometype.md` is\n-a file adjacent to the `lib.rs` for the crate) will ask Rustdoc to instead read that file and use it\n-as if it were written inline.\n+Instead of writing it all inline, writing `#[doc(include = \"sometype.md\")]` will ask Rustdoc to\n+instead read that file and use it as if it were written inline.\n \n [RFC 1990]: https://github.com/rust-lang/rfcs/pull/1990\n \n@@ -212,6 +211,36 @@ pub struct BigX;\n Then, when looking for it through the `rustdoc` search, if you enter \"x\" or\n \"big\", search will show the `BigX` struct first.\n \n+### Include items only when collecting doctests\n+\n+Rustdoc's [documentation tests] can do some things that regular unit tests can't, so it can\n+sometimes be useful to extend your doctests with samples that wouldn't otherwise need to be in\n+documentation. To this end, Rustdoc allows you to have certain items only appear when it's\n+collecting doctests, so you can utilize doctest functionality without forcing the test to appear in\n+docs, or to find an arbitrary private item to include it on.\n+\n+If you add `#![feature(cfg_doctest)]` to your crate, Rustdoc will set `cfg(doctest)` when collecting\n+doctests. Note that they will still link against only the public items of your crate; if you need to\n+test private items, unit tests are still the way to go.\n+\n+In this example, we're adding doctests that we know won't compile, to verify that our struct can\n+only take in valid data:\n+\n+```rust\n+#![feature(cfg_doctest)]\n+\n+/// We have a struct here. Remember it doesn't accept negative numbers!\n+pub struct MyStruct(usize);\n+\n+/// ```compile_fail\n+/// let x = my_crate::MyStruct(-5);\n+/// ```\n+#[cfg(doctest)]\n+pub struct MyStructOnlyTakesUsize;\n+```\n+\n+[documentation tests]: documentation-tests.html\n+\n ## Unstable command-line arguments\n \n These features are enabled by passing a command-line flag to Rustdoc, but the flags in question are"}, {"sha": "e0bb782270e22821f416ac44a45d91236e985ffd", "filename": "src/doc/unstable-book/src/language-features/arbitrary-enum-discriminant.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Farbitrary-enum-discriminant.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Farbitrary-enum-discriminant.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Farbitrary-enum-discriminant.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,37 @@\n+# `arbitrary_enum_discriminant`\n+\n+The tracking issue for this feature is: [#60553]\n+\n+[#60553]: https://github.com/rust-lang/rust/issues/60553\n+\n+------------------------\n+\n+The `arbitrary_enum_discriminant` feature permits tuple-like and\n+struct-like enum variants with `#[repr(<int-type>)]` to have explicit discriminants.\n+\n+## Examples\n+\n+```rust\n+#![feature(arbitrary_enum_discriminant)]\n+\n+#[allow(dead_code)]\n+#[repr(u8)]\n+enum Enum {\n+    Unit = 3,\n+    Tuple(u16) = 2,\n+    Struct {\n+        a: u8,\n+        b: u16,\n+    } = 1,\n+}\n+\n+impl Enum {\n+    fn tag(&self) -> u8 {\n+        unsafe { *(self as *const Self as *const u8) }\n+    }\n+}\n+\n+assert_eq!(3, Enum::Unit.tag());\n+assert_eq!(2, Enum::Tuple(5).tag());\n+assert_eq!(1, Enum::Struct{a: 7, b: 11}.tag());\n+```"}, {"sha": "bf0819ec920b7f0462ad912fa87ad80124e1c34c", "filename": "src/doc/unstable-book/src/language-features/box-patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-patterns.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -4,7 +4,7 @@ The tracking issue for this feature is: [#29641]\n \n [#29641]: https://github.com/rust-lang/rust/issues/29641\n \n-See also [`box_syntax`](language-features/box-syntax.html)\n+See also [`box_syntax`](box-syntax.md)\n \n ------------------------\n "}, {"sha": "9569974d22ca28124cd888e78c56a9a81d15aedf", "filename": "src/doc/unstable-book/src/language-features/box-syntax.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -4,7 +4,7 @@ The tracking issue for this feature is: [#49733]\n \n [#49733]: https://github.com/rust-lang/rust/issues/49733\n \n-See also [`box_patterns`](language-features/box-patterns.html)\n+See also [`box_patterns`](box-patterns.md)\n \n ------------------------\n "}, {"sha": "09d1b19b4c3c382868c7500a2557a48c241f4cba", "filename": "src/doc/unstable-book/src/language-features/const-in-array-repeat-expressions.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,11 @@\n+# `const_in_array_repeat_expressions`\n+\n+The tracking issue for this feature is: [#49147]\n+\n+[#44109]: https://github.com/rust-lang/rust/issues/49147\n+\n+------------------------\n+\n+Relaxes the rules for repeat expressions, `[x; N]` such that `x` may also be `const` (strictly\n+speaking rvalue promotable), in addition to `typeof(x): Copy`. The result of `[x; N]` where `x` is\n+`const` is itself also `const`."}, {"sha": "97cf58e57e6056e7e9399056806f0cd03762e8eb", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -146,7 +146,7 @@ closure-like semantics. Namely:\n   generators also depend on variables live across suspension points. This means\n   that although the ambient environment may be `Send` or `Sync`, the generator\n   itself may not be due to internal variables live across `yield` points being\n-  not-`Send` or not-`Sync`. Note that generators, like closures, do\n+  not-`Send` or not-`Sync`. Note that generators do\n   not implement traits like `Copy` or `Clone` automatically.\n \n * Whenever a generator is dropped it will drop all captured environment"}, {"sha": "3ee024c6b588361e8f10a3f593aebf1f60b6333d", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -192,7 +192,7 @@ such as \"```undefined reference to `__rust_probestack'```\". Using this crate\n also requires enabling the library feature `compiler_builtins_lib`. You can read\n more about this [here][compiler-builtins-lib].\n \n-[compiler-builtins-lib]: library-features/compiler-builtins-lib.html\n+[compiler-builtins-lib]: ../library-features/compiler-builtins-lib.md\n \n ## More about the language items\n "}, {"sha": "0d11c31aca6e956ab91f3fff9e5e82f9f1b89f23", "filename": "src/doc/unstable-book/src/language-features/member-constraints.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,29 @@\n+# `member_constraints`\n+\n+The tracking issue for this feature is: [#61977]\n+\n+[#61977]: https://github.com/rust-lang/rust/issues/61977\n+\n+------------------------\n+\n+The `member_constraints` feature gate lets you use `impl Trait` syntax with\n+multiple unrelated lifetime parameters.\n+\n+A simple example is:\n+\n+```rust\n+#![feature(member_constraints)]\n+\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T {}\n+\n+fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Trait<'a, 'b> {\n+  (x, y)\n+}\n+\n+fn main() { }\n+```\n+\n+Without the `member_constraints` feature gate, the above example is an\n+error because both `'a` and `'b` appear in the impl Trait bounds, but\n+neither outlives the other."}, {"sha": "22dae0c89a6ff5a460ef4c04679f2b29c24ca0c6", "filename": "src/doc/unstable-book/src/language-features/non-ascii-idents.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -45,4 +45,4 @@ that does _not_ occur in the set of [strict keywords].\n \n [`XID_start`]:  http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=\n [`XID_continue`]: http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=\n-[strict keywords]: ../reference/keywords.html#strict-keywords\n+[strict keywords]: ../../reference/keywords.md#strict-keywords"}, {"sha": "8db241e4b4ebf7f0e67713dc0240b112745a83c0", "filename": "src/doc/unstable-book/src/language-features/on-unimplemented.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -98,7 +98,8 @@ application of these fields based on a variety of attributes when using\n    `crate_local`) or matching against a particular method. Currently used\n    for `try`.\n  - `from_desugaring`: usable both as boolean (whether the flag is present)\n-   or matching against a particular desugaring.\n+   or matching against a particular desugaring. The desugaring is identified\n+   with its variant name in the `DesugaringKind` enum.\n \n For example, the `Iterator` trait can be annotated in the following way:\n "}, {"sha": "8ebacb44d37cc2151f4883020e499d23f9bab0ef", "filename": "src/doc/unstable-book/src/language-features/or-patterns.md", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2For-patterns.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,36 @@\n+# `or_patterns`\n+\n+The tracking issue for this feature is: [#54883]\n+\n+[#54883]: https://github.com/rust-lang/rust/issues/54883\n+\n+------------------------\n+\n+The `or_pattern` language feature allows `|` to be arbitrarily nested within\n+a pattern, for example, `Some(A(0) | B(1 | 2))` becomes a valid pattern.\n+\n+## Examples\n+\n+```rust,ignore\n+#![feature(or_patterns)]\n+\n+pub enum Foo {\n+    Bar,\n+    Baz,\n+    Quux,\n+}\n+\n+pub fn example(maybe_foo: Option<Foo>) {\n+    match maybe_foo {\n+        Some(Foo::Bar | Foo::Baz) => {\n+            println!(\"The value contained `Bar` or `Baz`\");\n+        }\n+        Some(_) => {\n+            println!(\"The value did not contain `Bar` or `Baz`\");\n+        }\n+        None => {\n+            println!(\"The value was `None`\");\n+        }\n+    }\n+}\n+```"}, {"sha": "4b83c204ba10579d2152672578834232bd4d1984", "filename": "src/doc/unstable-book/src/language-features/param-attrs.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fparam-attrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fparam-attrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fparam-attrs.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,27 @@\n+# `param_attrs`\n+\n+The tracking issue for this feature is: [#60406]\n+\n+[#60406]: https://github.com/rust-lang/rust/issues/60406\n+\n+Allow attributes in formal function parameter position so external tools and compiler internals can\n+take advantage of the additional information that the parameters provide.\n+\n+Enables finer conditional compilation with `#[cfg(..)]` and linting control of variables. Moreover,\n+opens the path to richer DSLs created by users.\n+\n+------------------------\n+\n+Example:\n+\n+```rust\n+#![feature(param_attrs)]\n+\n+fn len(\n+  #[cfg(windows)] slice: &[u16],\n+  #[cfg(not(windows))] slice: &[u8],\n+) -> usize\n+{\n+  slice.len()\n+}\n+```"}, {"sha": "bf5dd81d735af768be0994f50fa6fb6193be9569", "filename": "src/doc/unstable-book/src/language-features/plugin-registrar.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin-registrar.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin-registrar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin-registrar.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -8,6 +8,6 @@ This feature is part of \"compiler plugins.\" It will often be used with the\n [`plugin`] and `rustc_private` features as well. For more details, see\n their docs.\n \n-[`plugin`]: language-features/plugin.html\n+[`plugin`]: plugin.md\n \n ------------------------"}, {"sha": "8be4d16998276f91e4cc63e065304780fd3ef071", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -8,7 +8,7 @@ The tracking issue for this feature is: [#29597]\n This feature is part of \"compiler plugins.\" It will often be used with the\n [`plugin_registrar`] and `rustc_private` features.\n \n-[`plugin_registrar`]: language-features/plugin-registrar.html\n+[`plugin_registrar`]: plugin-registrar.md\n \n ------------------------\n \n@@ -39,12 +39,12 @@ of a library.\n \n Plugins can extend Rust's syntax in various ways. One kind of syntax extension\n is the procedural macro. These are invoked the same way as [ordinary\n-macros](../book/macros.html), but the expansion is performed by arbitrary Rust\n+macros](../../book/macros.md), but the expansion is performed by arbitrary Rust\n code that manipulates syntax trees at\n compile time.\n \n Let's write a plugin\n-[`roman_numerals.rs`](https://github.com/rust-lang/rust/blob/master/src/test/run-pass-fulldeps/auxiliary/roman_numerals.rs)\n+[`roman_numerals.rs`](https://github.com/rust-lang/rust/blob/master/src/test/ui-fulldeps/auxiliary/roman_numerals.rs)\n that implements Roman numeral integer literals.\n \n ```rust,ignore\n@@ -56,15 +56,14 @@ extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::parse::token;\n+use syntax::parse::token::{self, Token};\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n-use syntax::ext::build::AstBuilder;  // A trait for expr_usize.\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n-        -> Box<MacResult + 'static> {\n+        -> Box<dyn MacResult + 'static> {\n \n     static NUMERALS: &'static [(&'static str, usize)] = &[\n         (\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400),\n@@ -80,7 +79,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n     }\n \n     let text = match args[0] {\n-        TokenTree::Token(_, token::Ident(s)) => s.to_string(),\n+        TokenTree::Token(Token { kind: token::Ident(s, _), .. }) => s.to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");\n             return DummyResult::any(sp);\n@@ -130,9 +129,9 @@ The advantages over a simple `fn(&str) -> u32` are:\n   a way to define new literal syntax for any data type.\n \n In addition to procedural macros, you can define new\n-[`derive`](../reference/attributes/derive.html)-like attributes and other kinds\n+[`derive`](../../reference/attributes/derive.md)-like attributes and other kinds\n of extensions.  See `Registry::register_syntax_extension` and the\n-`SyntaxExtension` enum.  For a more involved macro example, see\n+`SyntaxExtension` struct.  For a more involved macro example, see\n [`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n \n \n@@ -164,17 +163,10 @@ can continue and find further errors.\n To print syntax fragments for debugging, you can use `span_note` together with\n `syntax::print::pprust::*_to_string`.\n \n-The example above produced an integer literal using `AstBuilder::expr_usize`.\n-As an alternative to the `AstBuilder` trait, `libsyntax` provides a set of\n-quasiquote macros. They are undocumented and very rough around the edges.\n-However, the implementation may be a good starting point for an improved\n-quasiquote as an ordinary plugin library.\n-\n-\n # Lint plugins\n \n Plugins can extend [Rust's lint\n-infrastructure](../reference/attributes/diagnostics.html#lint-check-attributes) with\n+infrastructure](../../reference/attributes/diagnostics.md#lint-check-attributes) with\n additional checks for code style, safety, etc. Now let's write a plugin\n [`lint_plugin_test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/ui-fulldeps/auxiliary/lint_plugin_test.rs)\n that warns about any item named `lintme`.\n@@ -253,7 +245,7 @@ mostly use the same infrastructure as lint plugins, and provide examples of how\n to access type information.\n \n Lints defined by plugins are controlled by the usual [attributes and compiler\n-flags](../reference/attributes/diagnostics.html#lint-check-attributes), e.g.\n+flags](../../reference/attributes/diagnostics.md#lint-check-attributes), e.g.\n `#[allow(test_lint)]` or `-A test-lint`. These identifiers are derived from the\n first argument to `declare_lint!`, with appropriate case and punctuation\n conversion."}, {"sha": "415c6ebe8b4bcfe7e45026f4e0dda575da807bcb", "filename": "src/doc/unstable-book/src/language-features/repr-align-enum.md", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md?ref=963184bbb670c1ffa97fc28a98cd5e8473118859", "patch": "@@ -1,42 +0,0 @@\n-# `repr_align_enum`\n-\n-The tracking issue for this feature is: [#57996]\n-\n-[#57996]: https://github.com/rust-lang/rust/issues/57996\n-\n-------------------------\n-\n-The `repr_align_enum` feature allows using the `#[repr(align(x))]` attribute\n-on enums, similarly to structs.\n-\n-# Examples\n-\n-```rust\n-#![feature(repr_align_enum)]\n-\n-#[repr(align(8))]\n-enum Aligned {\n-    Foo,\n-    Bar { value: u32 },\n-}\n-\n-fn main() {\n-    assert_eq!(std::mem::align_of::<Aligned>(), 8);\n-}\n-```\n-\n-This is equivalent to using an aligned wrapper struct everywhere:\n-\n-```rust\n-#[repr(align(8))]\n-struct Aligned(Unaligned);\n-\n-enum Unaligned {\n-    Foo,\n-    Bar { value: u32 },\n-}\n-\n-fn main() {\n-    assert_eq!(std::mem::align_of::<Aligned>(), 8);\n-}\n-```"}, {"sha": "cdb74495884a8e6e8d027992e147814ed44946ee", "filename": "src/doc/unstable-book/src/language-features/slice-patterns.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,8 +1,8 @@\n # `slice_patterns`\n \n-The tracking issue for this feature is: [#23121]\n+The tracking issue for this feature is: [#62254]\n \n-[#23121]: https://github.com/rust-lang/rust/issues/23121\n+[#62254]: https://github.com/rust-lang/rust/issues/62254\n \n ------------------------\n \n@@ -17,7 +17,7 @@ matched against that pattern. For example:\n fn is_symmetric(list: &[u32]) -> bool {\n     match list {\n         &[] | &[_] => true,\n-        &[x, ref inside.., y] if x == y => is_symmetric(inside),\n+        &[x, ref inside @ .., y] if x == y => is_symmetric(inside),\n         &[..] => false,\n     }\n }"}, {"sha": "862411ab392031ee9315d4fc07edf5a61b04c6e9", "filename": "src/doc/unstable-book/src/language-features/transparent-enums.md", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-enums.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-enums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-enums.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,93 @@\n+# `transparent_enums`\n+\n+The tracking issue for this feature is [#60405]\n+\n+[60405]: https://github.com/rust-lang/rust/issues/60405\n+\n+----\n+\n+The `transparent_enums` feature allows you mark `enum`s as\n+`#[repr(transparent)]`. An `enum` may be `#[repr(transparent)]` if it has\n+exactly one variant, and that variant matches the same conditions which `struct`\n+requires for transparency. Some concrete illustrations follow.\n+\n+```rust\n+#![feature(transparent_enums)]\n+\n+// This enum has the same representation as `f32`.\n+#[repr(transparent)]\n+enum SingleFieldEnum {\n+    Variant(f32)\n+}\n+\n+// This enum has the same representation as `usize`.\n+#[repr(transparent)]\n+enum MultiFieldEnum {\n+    Variant { field: usize, nothing: () },\n+}\n+```\n+\n+For consistency with transparent `struct`s, `enum`s must have exactly one\n+non-zero-sized field. If all fields are zero-sized, the `enum` must not be\n+`#[repr(transparent)]`:\n+\n+```rust\n+#![feature(transparent_enums)]\n+\n+// This (non-transparent) enum is already valid in stable Rust:\n+pub enum GoodEnum {\n+    Nothing,\n+}\n+\n+// Error: transparent enum needs exactly one non-zero-sized field, but has 0\n+// #[repr(transparent)]\n+// pub enum BadEnum {\n+//     Nothing(()),\n+// }\n+\n+// Error: transparent enum needs exactly one non-zero-sized field, but has 0\n+// #[repr(transparent)]\n+// pub enum BadEmptyEnum {\n+//     Nothing,\n+// }\n+```\n+\n+The one exception is if the `enum` is generic over `T` and has a field of type\n+`T`, it may be `#[repr(transparent)]` even if `T` is a zero-sized type:\n+\n+```rust\n+#![feature(transparent_enums)]\n+\n+// This enum has the same representation as `T`.\n+#[repr(transparent)]\n+pub enum GenericEnum<T> {\n+    Variant(T, ()),\n+}\n+\n+// This is okay even though `()` is a zero-sized type.\n+pub const THIS_IS_OKAY: GenericEnum<()> = GenericEnum::Variant((), ());\n+```\n+\n+Transparent `enum`s require exactly one variant:\n+\n+```rust\n+// Error: transparent enum needs exactly one variant, but has 0\n+// #[repr(transparent)]\n+// pub enum TooFewVariants {\n+// }\n+\n+// Error: transparent enum needs exactly one variant, but has 2\n+// #[repr(transparent)]\n+// pub enum TooManyVariants {\n+//     First(usize),\n+//     Second,\n+// }\n+```\n+\n+Like transarent `struct`s, a transparent `enum` of type `E` has the same layout,\n+size, and ABI as its single non-ZST field. If it is generic over a type `T`, and\n+all its fields are ZSTs except for exactly one field of type `T`, then it has\n+the same layout and ABI as `T` (even if `T` is a ZST when monomorphized).\n+\n+Like transparent `struct`s, transparent `enum`s are FFI-safe if and only if\n+their underlying representation type is also FFI-safe."}, {"sha": "b731c9ea6d0123c23d536828891a28403e3a564c", "filename": "src/doc/unstable-book/src/language-features/transparent-unions.md", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-unions.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-unions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-unions.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,83 @@\n+# `transparent_unions`\n+\n+The tracking issue for this feature is [#60405]\n+\n+[60405]: https://github.com/rust-lang/rust/issues/60405\n+\n+----\n+\n+The `transparent_unions` feature allows you mark `union`s as\n+`#[repr(transparent)]`. A `union` may be `#[repr(transparent)]` in exactly the\n+same conditions in which a `struct` may be `#[repr(transparent)]` (generally,\n+this means the `union` must have exactly one non-zero-sized field). Some\n+concrete illustrations follow.\n+\n+```rust\n+#![feature(transparent_unions)]\n+\n+// This union has the same representation as `f32`.\n+#[repr(transparent)]\n+union SingleFieldUnion {\n+    field: f32,\n+}\n+\n+// This union has the same representation as `usize`.\n+#[repr(transparent)]\n+union MultiFieldUnion {\n+    field: usize,\n+    nothing: (),\n+}\n+```\n+\n+For consistency with transparent `struct`s, `union`s must have exactly one\n+non-zero-sized field. If all fields are zero-sized, the `union` must not be\n+`#[repr(transparent)]`:\n+\n+```rust\n+#![feature(transparent_unions)]\n+\n+// This (non-transparent) union is already valid in stable Rust:\n+pub union GoodUnion {\n+    pub nothing: (),\n+}\n+\n+// Error: transparent union needs exactly one non-zero-sized field, but has 0\n+// #[repr(transparent)]\n+// pub union BadUnion {\n+//     pub nothing: (),\n+// }\n+```\n+\n+The one exception is if the `union` is generic over `T` and has a field of type\n+`T`, it may be `#[repr(transparent)]` even if `T` is a zero-sized type:\n+\n+```rust\n+#![feature(transparent_unions)]\n+\n+// This union has the same representation as `T`.\n+#[repr(transparent)]\n+pub union GenericUnion<T: Copy> { // Unions with non-`Copy` fields are unstable.\n+    pub field: T,\n+    pub nothing: (),\n+}\n+\n+// This is okay even though `()` is a zero-sized type.\n+pub const THIS_IS_OKAY: GenericUnion<()> = GenericUnion { field: () };\n+```\n+\n+Like transarent `struct`s, a transparent `union` of type `U` has the same\n+layout, size, and ABI as its single non-ZST field. If it is generic over a type\n+`T`, and all its fields are ZSTs except for exactly one field of type `T`, then\n+it has the same layout and ABI as `T` (even if `T` is a ZST when monomorphized).\n+\n+Like transparent `struct`s, transparent `union`s are FFI-safe if and only if\n+their underlying representation type is also FFI-safe.\n+\n+A `union` may not be eligible for the same nonnull-style optimizations that a\n+`struct` or `enum` (with the same fields) are eligible for. Adding\n+`#[repr(transparent)]` to  `union` does not change this. To give a more concrete\n+example, it is unspecified whether `size_of::<T>()` is equal to\n+`size_of::<Option<T>>()`, where `T` is a `union` (regardless of whether or not\n+it is transparent). The Rust compiler is free to perform this optimization if\n+possible, but is not required to, and different compiler versions may differ in\n+their application of these optimizations."}, {"sha": "bcdeafc4b113717c431d8f833ae20a6a5c54e441", "filename": "src/doc/unstable-book/src/language-features/type-alias-enum-variants.md", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md?ref=963184bbb670c1ffa97fc28a98cd5e8473118859", "patch": "@@ -1,36 +0,0 @@\n-# `type_alias_enum_variants`\n-\n-The tracking issue for this feature is: [#49683]\n-\n-[#49683]: https://github.com/rust-lang/rust/issues/49683\n-\n-------------------------\n-\n-The `type_alias_enum_variants` feature enables the use of variants on type\n-aliases that refer to enums, as both a constructor and a pattern. That is,\n-it allows for the syntax `EnumAlias::Variant`, which behaves exactly the same\n-as `Enum::Variant` (assuming that `EnumAlias` is an alias for some enum type\n-`Enum`).\n-\n-Note that since `Self` exists as a type alias, this feature also enables the\n-use of the syntax `Self::Variant` within an impl block for an enum type.\n-\n-```rust\n-#![feature(type_alias_enum_variants)]\n-\n-enum Foo {\n-    Bar(i32),\n-    Baz { i: i32 },\n-}\n-\n-type Alias = Foo;\n-\n-fn main() {\n-    let t = Alias::Bar(0);\n-    let t = Alias::Baz { i: 0 };\n-    match t {\n-        Alias::Bar(_i) => {}\n-        Alias::Baz { i: _i } => {}\n-    }\n-}\n-```"}, {"sha": "71003fba00ba237e9fed3601258d7aa18c502165", "filename": "src/doc/unstable-book/src/language-features/unboxed-closures.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -2,7 +2,7 @@\n \n The tracking issue for this feature is [#29625]\n \n-See Also: [`fn_traits`](library-features/fn-traits.html)\n+See Also: [`fn_traits`](../library-features/fn-traits.md)\n \n [#29625]: https://github.com/rust-lang/rust/issues/29625\n "}, {"sha": "343084b7db5016f9fef3ea74be335ea3d4ded529", "filename": "src/doc/unstable-book/src/language-features/unsized-locals.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -117,9 +117,7 @@ fn main () {\n }\n ```\n \n-One of the objectives of this feature is to allow `Box<dyn FnOnce>`, instead of `Box<dyn FnBox>` in the future. See [#28796] for details.\n-\n-[#28796]: https://github.com/rust-lang/rust/issues/28796\n+One of the objectives of this feature is to allow `Box<dyn FnOnce>`.\n \n ## Variable length arrays\n "}, {"sha": "2a1b6397781f95fc9a98fbb620c6e5b2dd29aae8", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -190,4 +190,4 @@ constraints, etc.\n [llvm-docs]: http://llvm.org/docs/LangRef.html#inline-assembler-expressions\n \n If you need more power and don't mind losing some of the niceties of\n-`asm!`, check out [global_asm](language-features/global-asm.html).\n+`asm!`, check out [global_asm](global-asm.md).", "previous_filename": "src/doc/unstable-book/src/language-features/asm.md"}, {"sha": "304b8dffe98679c9f6fea3e7d2558757c1797563", "filename": "src/doc/unstable-book/src/library-features/borrow-state.md", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fborrow-state.md?ref=963184bbb670c1ffa97fc28a98cd5e8473118859", "patch": "@@ -1,7 +0,0 @@\n-# `borrow_state`\n-\n-The tracking issue for this feature is: [#27733]\n-\n-[#27733]: https://github.com/rust-lang/rust/issues/27733\n-\n-------------------------"}, {"sha": "ecfd34a22e5ccbd39794a260879eb88317088e09", "filename": "src/doc/unstable-book/src/library-features/concat-idents.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "previous_filename": "src/doc/unstable-book/src/language-features/concat-idents.md"}, {"sha": "ae839bf2ac32b7d96c419045d2a436554ae6445a", "filename": "src/doc/unstable-book/src/library-features/debug-map-key-value.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,9 @@\n+# `debug_map_key_value`\n+\n+The tracking issue for this feature is: [#62482]\n+\n+[#62482]: https://github.com/rust-lang/rust/issues/62482\n+\n+------------------------\n+\n+Add the methods `key` and `value` to `DebugMap` so that an entry can be formatted across multiple calls without additional buffering."}, {"sha": "29a8aecee6c2fd26e5420a2c06640823e01b99fa", "filename": "src/doc/unstable-book/src/library-features/fn-traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -2,7 +2,7 @@\n \n The tracking issue for this feature is [#29625]\n \n-See Also: [`unboxed_closures`](language-features/unboxed-closures.html)\n+See Also: [`unboxed_closures`](../language-features/unboxed-closures.md)\n \n [#29625]: https://github.com/rust-lang/rust/issues/29625\n "}, {"sha": "cb3386b7152112a5953d457b12c36c181f061618", "filename": "src/doc/unstable-book/src/library-features/fnbox.md", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffnbox.md?ref=963184bbb670c1ffa97fc28a98cd5e8473118859", "patch": "@@ -1,32 +0,0 @@\n-# `fnbox`\n-\n-The tracking issue for this feature is [#28796]\n-\n-[#28796]: https://github.com/rust-lang/rust/issues/28796\n-\n-------------------------\n-\n-This had been a temporary alternative to the following impls:\n-\n-```rust,ignore\n-impl<A, F> FnOnce for Box<F> where F: FnOnce<A> + ?Sized {}\n-impl<A, F> FnMut for Box<F> where F: FnMut<A> + ?Sized {}\n-impl<A, F> Fn for Box<F> where F: Fn<A> + ?Sized {}\n-```\n-\n-The impls are parallel to these (relatively old) impls:\n-\n-```rust,ignore\n-impl<A, F> FnOnce for &mut F where F: FnMut<A> + ?Sized {}\n-impl<A, F> FnMut for &mut F where F: FnMut<A> + ?Sized {}\n-impl<A, F> Fn for &mut F where F: Fn<A> + ?Sized {}\n-impl<A, F> FnOnce for &F where F: Fn<A> + ?Sized {}\n-impl<A, F> FnMut for &F where F: Fn<A> + ?Sized {}\n-impl<A, F> Fn for &F where F: Fn<A> + ?Sized {}\n-```\n-\n-Before the introduction of [`unsized_locals`][unsized_locals], we had been unable to provide the former impls. That means, unlike `&dyn Fn()` or `&mut dyn FnMut()` we could not use `Box<dyn FnOnce()>` at that time.\n-\n-[unsized_locals]: language-features/unsized-locals.html\n-\n-`FnBox()` is an alternative approach to `Box<dyn FnBox()>` is delegated to `FnBox::call_box` which doesn't need unsized locals. As we now have `Box<dyn FnOnce()>` working, the `fnbox` feature is going to be removed."}, {"sha": "bc55fe80fa64c599f954ebdedd613ebba60465e1", "filename": "src/doc/unstable-book/src/library-features/global-asm.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -75,4 +75,4 @@ usages and placed the larger, single usage in the crate root.\n If you don't need quite as much power and flexibility as\n `global_asm!` provides, and you don't mind restricting your inline\n assembly to `fn` bodies only, you might try the\n-[asm](language-features/asm.html) feature instead.\n+[asm](asm.md) feature instead.", "previous_filename": "src/doc/unstable-book/src/language-features/global-asm.md"}, {"sha": "e556adaa13ea738db2fdb9b30069fa8ac06583ea", "filename": "src/doc/unstable-book/src/library-features/n16.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fn16.md", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fn16.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fn16.md?ref=963184bbb670c1ffa97fc28a98cd5e8473118859", "patch": "@@ -1,5 +0,0 @@\n-# `n16`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "41aa286e69bfb320a0467ce4659e506093257807", "filename": "src/doc/unstable-book/src/library-features/trace-macros.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrace-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrace-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrace-macros.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "previous_filename": "src/doc/unstable-book/src/language-features/trace-macros.md"}, {"sha": "554c52c3c9c2761c7f6768a51923c7b36fdbf2c5", "filename": "src/doc/unstable-book/src/the-unstable-book.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Fthe-unstable-book.md", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fdoc%2Funstable-book%2Fsrc%2Fthe-unstable-book.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fthe-unstable-book.md?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -14,7 +14,7 @@ fn main() {\n \n The `box_syntax` feature [has a chapter][box] describing how to use it.\n \n-[box]: language-features/box-syntax.html\n+[box]: language-features/box-syntax.md\n \n Because this documentation relates to unstable features, we make no guarantees\n that what is contained here is accurate or up to date. It's developed on a"}, {"sha": "0905789079a3e51c072cfcc0c7c621a0cdde7c02", "filename": "src/etc/cpu-usage-over-time-plot.sh", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fetc%2Fcpu-usage-over-time-plot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fetc%2Fcpu-usage-over-time-plot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcpu-usage-over-time-plot.sh?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,49 @@\n+#!/bin/bash\n+\n+# A small script to help visualizing CPU usage over time data collected on CI\n+# using `gnuplot`.\n+#\n+# This script is expected to be called with two arguments. The first is the full\n+# commit SHA of the build you're interested in, and the second is the name of\n+# the builder. For example:\n+#\n+#  ./src/etc/cpu-usage-over-time-plot.sh e699ea096fcc2fc9ce8e8bcf884e11496a31cc9f i686-mingw-1\n+#\n+# That will generate `$builder.png` in the current directory which you can open\n+# up to see a hopefully pretty graph.\n+#\n+# Improvements to this script are greatly appreciated!\n+\n+set -ex\n+\n+bucket=rust-lang-ci2\n+commit=$1\n+builder=$2\n+\n+curl -O https://$bucket.s3.amazonaws.com/rustc-builds/$commit/cpu-$builder.csv\n+\n+gnuplot <<-EOF\n+reset\n+set timefmt '%Y-%m-%dT%H:%M:%S'\n+set xdata time\n+set ylabel \"CPU Usage %\"\n+set xlabel \"Time\"\n+set datafile sep ','\n+set term png size 3000,1000\n+set output \"$builder.png\"\n+set grid\n+\n+f(x) = mean_y\n+fit f(x) 'cpu-$builder.csv' using 1:(100-\\$2) via mean_y\n+\n+set label 1 gprintf(\"Average = %g%%\", mean_y) center font \",18\"\n+set label 1 at graph 0.50, 0.25\n+set xtics rotate by 45 offset -2,-2.4 300\n+set ytics 10\n+set boxwidth 0.5\n+\n+plot \\\\\n+   mean_y with lines linetype 1 linecolor rgb \"#ff0000\" title \"average\", \\\\\n+   \"cpu-$builder.csv\" using 1:(100-\\$2) with points pointtype 7 pointsize 0.4 title \"$builder\", \\\\\n+   \"\" using 1:(100-\\$2) smooth bezier linewidth 3 title \"bezier\"\n+EOF"}, {"sha": "fe38c49d2707dcdf9061e2d8fff362c06e62fb3d", "filename": "src/etc/gdb_load_rust_pretty_printers.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_load_rust_pretty_printers.py?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,2 +1,3 @@\n+import gdb\n import gdb_rust_pretty_printing\n gdb_rust_pretty_printing.register_printers(gdb.current_objfile())"}, {"sha": "7b9b40e6b4a0afb288f8b8875ef0352d129843fb", "filename": "src/etc/rust-lldb", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fetc%2Frust-lldb", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fetc%2Frust-lldb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-lldb?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -3,25 +3,30 @@\n # Exit if anything fails\n set -e\n \n-# Find out where to look for the pretty printer Python module\n-RUSTC_SYSROOT=`rustc --print sysroot`\n-\n # Find the host triple so we can find lldb in rustlib.\n-host=`rustc -vV | sed -n -e 's/^host: //p'`\n+host=$(rustc -vV | sed -n -e 's/^host: //p')\n+\n+# Find out where to look for the pretty printer Python module\n+RUSTC_SYSROOT=$(rustc --print sysroot)\n+RUST_LLDB=\"$RUSTC_SYSROOT/lib/rustlib/$host/bin/lldb\"\n \n lldb=lldb\n-if [ -f \"$RUSTC_SYSROOT/lib/rustlib/$host/bin/lldb\" ]; then\n-    lldb=\"$RUSTC_SYSROOT/lib/rustlib/$host/bin/lldb\"\n+if [ -f \"$RUST_LLDB\" ]; then\n+    lldb=\"$RUST_LLDB\"\n else\n-    LLDB_VERSION=`\"$lldb\" --version 2>/dev/null | head -1 | cut -d. -f1`\n+    if ! command -v \"$lldb\" > /dev/null; then\n+        echo \"$lldb not found! Please install it.\" >&2\n+        exit 1\n+    else\n+        LLDB_VERSION=$(\"$lldb\" --version | cut -d ' ' -f3)\n \n-    if [ \"$LLDB_VERSION\" = \"lldb-350\" ]\n-    then\n-        echo \"***\"\n-\techo \\\n-\"WARNING: This version of LLDB has known issues with Rust and cannot \\\n-display the contents of local variables!\"\n-        echo \"***\"\n+        if [ \"$LLDB_VERSION\" = \"3.5.0\" ]; then\n+            cat << EOF >&2\n+***\n+WARNING: This version of LLDB has known issues with Rust and cannot display the contents of local variables!\n+***\n+EOF\n+        fi\n     fi\n fi\n \n@@ -31,7 +36,7 @@ category_definition=\"type summary add --no-value --python-function lldb_rust_for\n category_enable=\"type category enable Rust\"\n \n # Call LLDB with the commands added to the argument list\n-exec \"$lldb\" --one-line-before-file=\"$script_import\" \\\n-    --one-line-before-file=\"$category_definition\" \\\n-    --one-line-before-file=\"$category_enable\" \\\n+exec \"$lldb\" --one-line-before-file \"$script_import\" \\\n+    --one-line-before-file \"$category_definition\" \\\n+    --one-line-before-file \"$category_enable\" \\\n     \"$@\""}, {"sha": "d1119f7b7c0a7f6a83cccaa0aa7c8d0897d5abde", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -15,8 +15,8 @@ core = { path = \"../libcore\" }\n compiler_builtins = { version = \"0.1.10\", features = ['rustc-dep-of-std'] }\n \n [dev-dependencies]\n-rand = \"0.6\"\n-rand_xorshift = \"0.1\"\n+rand = \"0.7\"\n+rand_xorshift = \"0.2\"\n \n [[test]]\n name = \"collectionstests\""}, {"sha": "dc7fd1adc295895016dd2c71f34df41355ca02ea", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 22, "deletions": 34, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -10,12 +10,15 @@ use core::usize;\n #[doc(inline)]\n pub use core::alloc::*;\n \n+#[cfg(test)]\n+mod tests;\n+\n extern \"Rust\" {\n     // These are the magic symbols to call the global allocator.  rustc generates\n     // them from the `#[global_allocator]` attribute if there is one, or uses the\n     // default implementations in libstd (`__rdl_alloc` etc in `src/libstd/alloc.rs`)\n     // otherwise.\n-    #[allocator]\n+    #[rustc_allocator]\n     #[rustc_allocator_nounwind]\n     fn __rust_alloc(size: usize, align: usize) -> *mut u8;\n     #[rustc_allocator_nounwind]\n@@ -37,6 +40,8 @@ extern \"Rust\" {\n ///\n /// Note: while this type is unstable, the functionality it provides can be\n /// accessed through the [free functions in `alloc`](index.html#functions).\n+///\n+/// [`Alloc`]: trait.Alloc.html\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n@@ -54,6 +59,10 @@ pub struct Global;\n ///\n /// See [`GlobalAlloc::alloc`].\n ///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::alloc`]: trait.GlobalAlloc.html#tymethod.alloc\n+///\n /// # Examples\n ///\n /// ```\n@@ -87,6 +96,10 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n /// # Safety\n ///\n /// See [`GlobalAlloc::dealloc`].\n+///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::dealloc`]: trait.GlobalAlloc.html#tymethod.dealloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n@@ -105,6 +118,10 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n /// # Safety\n ///\n /// See [`GlobalAlloc::realloc`].\n+///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::realloc`]: trait.GlobalAlloc.html#method.realloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n@@ -124,6 +141,10 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n ///\n /// See [`GlobalAlloc::alloc_zeroed`].\n ///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::alloc_zeroed`]: trait.GlobalAlloc.html#method.alloc_zeroed\n+///\n /// # Examples\n ///\n /// ```\n@@ -226,36 +247,3 @@ pub fn handle_alloc_error(layout: Layout) -> ! {\n     }\n     unsafe { oom_impl(layout) }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use test::Bencher;\n-    use crate::boxed::Box;\n-    use crate::alloc::{Global, Alloc, Layout, handle_alloc_error};\n-\n-    #[test]\n-    fn allocate_zeroed() {\n-        unsafe {\n-            let layout = Layout::from_size_align(1024, 1).unwrap();\n-            let ptr = Global.alloc_zeroed(layout.clone())\n-                .unwrap_or_else(|_| handle_alloc_error(layout));\n-\n-            let mut i = ptr.cast::<u8>().as_ptr();\n-            let end = i.add(layout.size());\n-            while i < end {\n-                assert_eq!(*i, 0);\n-                i = i.offset(1);\n-            }\n-            Global.dealloc(ptr, layout);\n-        }\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn alloc_owned_small(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = box 10;\n-        })\n-    }\n-}"}, {"sha": "c69f4e49ee1e3994e6621496129e54fceea84e52", "filename": "src/liballoc/alloc/tests.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,30 @@\n+use super::*;\n+\n+extern crate test;\n+use test::Bencher;\n+use crate::boxed::Box;\n+\n+#[test]\n+fn allocate_zeroed() {\n+    unsafe {\n+        let layout = Layout::from_size_align(1024, 1).unwrap();\n+        let ptr = Global.alloc_zeroed(layout.clone())\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n+\n+        let mut i = ptr.cast::<u8>().as_ptr();\n+        let end = i.add(layout.size());\n+        while i < end {\n+            assert_eq!(*i, 0);\n+            i = i.offset(1);\n+        }\n+        Global.dealloc(ptr, layout);\n+    }\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn alloc_owned_small(b: &mut Bencher) {\n+    b.iter(|| {\n+        let _: Box<_> = box 10;\n+    })\n+}"}, {"sha": "ef91d801dc72cb6e30c3915486f151bd9113cfe2", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -186,12 +186,12 @@ const SEED: [u8; 16] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n \n fn gen_random(len: usize) -> Vec<u64> {\n     let mut rng = XorShiftRng::from_seed(SEED);\n-    rng.sample_iter(&Standard).take(len).collect()\n+    (&mut rng).sample_iter(&Standard).take(len).collect()\n }\n \n fn gen_random_bytes(len: usize) -> Vec<u8> {\n     let mut rng = XorShiftRng::from_seed(SEED);\n-    rng.sample_iter(&Standard).take(len).collect()\n+    (&mut rng).sample_iter(&Standard).take(len).collect()\n }\n \n fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n@@ -221,14 +221,14 @@ fn gen_strings(len: usize) -> Vec<String> {\n     let mut v = vec![];\n     for _ in 0..len {\n         let n = rng.gen::<usize>() % 20 + 1;\n-        v.push(rng.sample_iter(&Alphanumeric).take(n).collect());\n+        v.push((&mut rng).sample_iter(&Alphanumeric).take(n).collect());\n     }\n     v\n }\n \n fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n     let mut rng = XorShiftRng::from_seed(SEED);\n-    rng.sample_iter(&Standard).map(|x| [x; 16]).take(len).collect()\n+    (&mut rng).sample_iter(&Standard).map(|x| [x; 16]).take(len).collect()\n }\n \n macro_rules! sort {"}, {"sha": "a9c5bce4c25fc212a1b821b3b56bec87c736373a", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -329,8 +329,8 @@ impl<'a, B: ?Sized> PartialOrd for Cow<'a, B>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: ?Sized> fmt::Debug for Cow<'_, B>\n-    where B: fmt::Debug + ToOwned,\n-          <B as ToOwned>::Owned: fmt::Debug\n+where\n+    B: fmt::Debug + ToOwned<Owned: fmt::Debug>,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n@@ -342,8 +342,8 @@ impl<B: ?Sized> fmt::Debug for Cow<'_, B>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B: ?Sized> fmt::Display for Cow<'_, B>\n-    where B: fmt::Display + ToOwned,\n-          <B as ToOwned>::Owned: fmt::Display\n+where\n+    B: fmt::Display + ToOwned<Owned: fmt::Display>,\n {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n@@ -355,8 +355,8 @@ impl<B: ?Sized> fmt::Display for Cow<'_, B>\n \n #[stable(feature = \"default\", since = \"1.11.0\")]\n impl<B: ?Sized> Default for Cow<'_, B>\n-    where B: ToOwned,\n-          <B as ToOwned>::Owned: Default\n+where\n+    B: ToOwned<Owned: Default>,\n {\n     /// Creates an owned Cow<'a, B> with the default value for the contained owned value.\n     fn default() -> Self {"}, {"sha": "c61e3183409f267fcf83a9565ece1b58efdd096f", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 260, "deletions": 97, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,19 +1,9 @@\n //! A pointer type for heap allocation.\n //!\n-//! `Box<T>`, casually referred to as a 'box', provides the simplest form of\n+//! [`Box<T>`], casually referred to as a 'box', provides the simplest form of\n //! heap allocation in Rust. Boxes provide ownership for this allocation, and\n //! drop their contents when they go out of scope.\n //!\n-//! For non-zero-sized values, a [`Box`] will use the [`Global`] allocator for\n-//! its allocation. It is valid to convert both ways between a [`Box`] and a\n-//! raw pointer allocated with the [`Global`] allocator, given that the\n-//! [`Layout`] used with the allocator is correct for the type. More precisely,\n-//! a `value: *mut T` that has been allocated with the [`Global`] allocator\n-//! with `Layout::for_value(&*value)` may be converted into a box using\n-//! `Box::<T>::from_raw(value)`. Conversely, the memory backing a `value: *mut\n-//! T` obtained from `Box::<T>::into_raw` may be deallocated using the\n-//! [`Global`] allocator with `Layout::for_value(&*value)`.\n-//!\n //! # Examples\n //!\n //! Move a value from the stack to the heap by creating a [`Box`]:\n@@ -58,20 +48,38 @@\n //!\n //! It wouldn't work. This is because the size of a `List` depends on how many\n //! elements are in the list, and so we don't know how much memory to allocate\n-//! for a `Cons`. By introducing a `Box`, which has a defined size, we know how\n+//! for a `Cons`. By introducing a [`Box<T>`], which has a defined size, we know how\n //! big `Cons` needs to be.\n //!\n+//! # Memory layout\n+//!\n+//! For non-zero-sized values, a [`Box`] will use the [`Global`] allocator for\n+//! its allocation. It is valid to convert both ways between a [`Box`] and a\n+//! raw pointer allocated with the [`Global`] allocator, given that the\n+//! [`Layout`] used with the allocator is correct for the type. More precisely,\n+//! a `value: *mut T` that has been allocated with the [`Global`] allocator\n+//! with `Layout::for_value(&*value)` may be converted into a box using\n+//! [`Box::<T>::from_raw(value)`]. Conversely, the memory backing a `value: *mut\n+//! T` obtained from [`Box::<T>::into_raw`] may be deallocated using the\n+//! [`Global`] allocator with [`Layout::for_value(&*value)`].\n+//!\n+//!\n //! [dereferencing]: ../../std/ops/trait.Deref.html\n //! [`Box`]: struct.Box.html\n+//! [`Box<T>`]: struct.Box.html\n+//! [`Box::<T>::from_raw(value)`]: struct.Box.html#method.from_raw\n+//! [`Box::<T>::into_raw`]: struct.Box.html#method.into_raw\n //! [`Global`]: ../alloc/struct.Global.html\n //! [`Layout`]: ../alloc/struct.Layout.html\n+//! [`Layout::for_value(&*value)`]: ../alloc/struct.Layout.html#method.for_value\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::any::Any;\n+use core::array::LengthAtMost32;\n use core::borrow;\n use core::cmp::Ordering;\n-use core::convert::From;\n+use core::convert::{From, TryFrom};\n use core::fmt;\n use core::future::Future;\n use core::hash::{Hash, Hasher};\n@@ -83,8 +91,10 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n+use core::slice;\n use core::task::{Context, Poll};\n \n+use crate::alloc::{self, Global, Alloc};\n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -113,6 +123,34 @@ impl<T> Box<T> {\n         box x\n     }\n \n+    /// Constructs a new box with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n+        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = unsafe {\n+            Global.alloc(layout)\n+                .unwrap_or_else(|_| alloc::handle_alloc_error(layout))\n+        };\n+        Box(ptr.cast().into())\n+    }\n+\n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -122,29 +160,148 @@ impl<T> Box<T> {\n     }\n }\n \n+impl<T> Box<[T]> {\n+    /// Constructs a new boxed slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Box<[mem::MaybeUninit<T>]> {\n+        let layout = alloc::Layout::array::<mem::MaybeUninit<T>>(len).unwrap();\n+        let ptr = unsafe { alloc::alloc(layout) };\n+        let unique = Unique::new(ptr).unwrap_or_else(|| alloc::handle_alloc_error(layout));\n+        let slice = unsafe { slice::from_raw_parts_mut(unique.cast().as_ptr(), len) };\n+        Box(Unique::from(slice))\n+    }\n+}\n+\n+impl<T> Box<mem::MaybeUninit<T>> {\n+    /// Converts to `Box<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five: Box<u32> = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<T> {\n+        Box(Box::into_unique(self).cast())\n+    }\n+}\n+\n+impl<T> Box<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Box<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the values\n+    /// really are in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut values = Box::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     values[0].as_mut_ptr().write(1);\n+    ///     values[1].as_mut_ptr().write(2);\n+    ///     values[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Box<[T]> {\n+        Box(Unique::new_unchecked(Box::into_raw(self) as _))\n+    }\n+}\n+\n impl<T: ?Sized> Box<T> {\n     /// Constructs a box from a raw pointer.\n     ///\n     /// After calling this function, the raw pointer is owned by the\n     /// resulting `Box`. Specifically, the `Box` destructor will call\n-    /// the destructor of `T` and free the allocated memory. Since the\n-    /// way `Box` allocates and releases memory is unspecified, the\n-    /// only valid pointer to pass to this function is the one taken\n-    /// from another `Box` via the [`Box::into_raw`] function.\n+    /// the destructor of `T` and free the allocated memory. For this\n+    /// to be safe, the memory must have been allocated in accordance\n+    /// with the [memory layout] used by `Box` .\n+    ///\n+    /// # Safety\n     ///\n     /// This function is unsafe because improper use may lead to\n     /// memory problems. For example, a double-free may occur if the\n     /// function is called twice on the same raw pointer.\n     ///\n-    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n-    ///\n     /// # Examples\n-    ///\n+    /// Recreate a `Box` which was previously converted to a raw pointer\n+    /// using [`Box::into_raw`]:\n     /// ```\n     /// let x = Box::new(5);\n     /// let ptr = Box::into_raw(x);\n     /// let x = unsafe { Box::from_raw(ptr) };\n     /// ```\n+    /// Manually create a `Box` from scratch by using the global allocator:\n+    /// ```\n+    /// use std::alloc::{alloc, Layout};\n+    ///\n+    /// unsafe {\n+    ///     let ptr = alloc(Layout::new::<i32>()) as *mut i32;\n+    ///     *ptr = 5;\n+    ///     let x = Box::from_raw(ptr);\n+    /// }\n+    /// ```\n+    ///\n+    /// [memory layout]: index.html#memory-layout\n+    /// [`Layout`]: ../alloc/struct.Layout.html\n+    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n@@ -157,22 +314,40 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n-    /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the raw pointer back into a\n-    /// `Box` with the [`Box::from_raw`] function.\n+    /// caller should properly destroy `T` and release the memory, taking\n+    /// into account the [memory layout] used by `Box`. The easiest way to\n+    /// do this is to convert the raw pointer back into a `Box` with the\n+    /// [`Box::from_raw`] function, allowing the `Box` destructor to perform\n+    /// the cleanup.\n     ///\n     /// Note: this is an associated function, which means that you have\n     /// to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n-    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n-    ///\n     /// # Examples\n-    ///\n+    /// Converting the raw pointer back into a `Box` with [`Box::from_raw`]\n+    /// for automatic cleanup:\n     /// ```\n-    /// let x = Box::new(5);\n+    /// let x = Box::new(String::from(\"Hello\"));\n     /// let ptr = Box::into_raw(x);\n+    /// let x = unsafe { Box::from_raw(ptr) };\n     /// ```\n+    /// Manual cleanup by explicitly running the destructor and deallocating\n+    /// the memory:\n+    /// ```\n+    /// use std::alloc::{dealloc, Layout};\n+    /// use std::ptr;\n+    ///\n+    /// let x = Box::new(String::from(\"Hello\"));\n+    /// let p = Box::into_raw(x);\n+    /// unsafe {\n+    ///     ptr::drop_in_place(p);\n+    ///     dealloc(p as *mut u8, Layout::new::<String>());\n+    /// }\n+    /// ```\n+    ///\n+    /// [memory layout]: index.html#memory-layout\n+    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n@@ -184,7 +359,7 @@ impl<T: ?Sized> Box<T> {\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n     /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the `NonNull<T>` pointer\n+    /// easiest way to do so is to convert the `NonNull<T>` pointer\n     /// into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n     /// function.\n     ///\n@@ -203,6 +378,10 @@ impl<T: ?Sized> Box<T> {\n     /// fn main() {\n     ///     let x = Box::new(5);\n     ///     let ptr = Box::into_raw_non_null(x);\n+    ///\n+    ///     // Clean up the memory by converting the NonNull pointer back\n+    ///     // into a Box and letting the Box be dropped.\n+    ///     let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n     /// }\n     /// ```\n     #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n@@ -214,15 +393,16 @@ impl<T: ?Sized> Box<T> {\n     #[unstable(feature = \"ptr_internals\", issue = \"0\", reason = \"use into_raw_non_null instead\")]\n     #[inline]\n     #[doc(hidden)]\n-    pub fn into_unique(mut b: Box<T>) -> Unique<T> {\n+    pub fn into_unique(b: Box<T>) -> Unique<T> {\n+        let mut unique = b.0;\n+        mem::forget(b);\n         // Box is kind-of a library type, but recognized as a \"unique pointer\" by\n         // Stacked Borrows.  This function here corresponds to \"reborrowing to\n         // a raw pointer\", but there is no actual reborrow here -- so\n         // without some care, the pointer we are returning here still carries\n-        // the `Uniq` tag.  We round-trip through a mutable reference to avoid that.\n-        let unique = unsafe { b.0.as_mut() as *mut T };\n-        mem::forget(b);\n-        unsafe { Unique::new_unchecked(unique) }\n+        // the tag of `b`, with `Unique` permission.\n+        // We round-trip through a mutable reference to avoid that.\n+        unsafe { Unique::new_unchecked(unique.as_mut() as *mut T) }\n     }\n \n     /// Consumes and leaks the `Box`, returning a mutable reference,\n@@ -280,7 +460,7 @@ impl<T: ?Sized> Box<T> {\n     /// This conversion does not allocate on the heap and happens in place.\n     ///\n     /// This is also available via [`From`].\n-    #[unstable(feature = \"box_into_pin\", issue = \"0\")]\n+    #[unstable(feature = \"box_into_pin\", issue = \"62370\")]\n     pub fn into_pin(boxed: Box<T>) -> Pin<Box<T>> {\n         // It's not possible to move or replace the insides of a `Pin<Box<T>>`\n         // when `T: !Unpin`,  so it's safe to pin it directly without any\n@@ -327,23 +507,35 @@ impl<T: Clone> Clone for Box<T> {\n     /// ```\n     /// let x = Box::new(5);\n     /// let y = x.clone();\n+    ///\n+    /// // The value is the same\n+    /// assert_eq!(x, y);\n+    ///\n+    /// // But they are unique objects\n+    /// assert_ne!(&*x as *const i32, &*y as *const i32);\n     /// ```\n     #[rustfmt::skip]\n     #[inline]\n     fn clone(&self) -> Box<T> {\n         box { (**self).clone() }\n     }\n+\n     /// Copies `source`'s contents into `self` without creating a new allocation.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let x = Box::new(5);\n     /// let mut y = Box::new(10);\n+    /// let yp: *const i32 = &*y;\n     ///\n     /// y.clone_from(&x);\n     ///\n-    /// assert_eq!(*y, 5);\n+    /// // The value is the same\n+    /// assert_eq!(x, y);\n+    ///\n+    /// // And no allocation occurred\n+    /// assert_eq!(yp, &*y);\n     /// ```\n     #[inline]\n     fn clone_from(&mut self, source: &Box<T>) {\n@@ -355,11 +547,10 @@ impl<T: Clone> Clone for Box<T> {\n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl Clone for Box<str> {\n     fn clone(&self) -> Self {\n-        let len = self.len();\n-        let buf = RawVec::with_capacity(len);\n+        // this makes a copy of the data\n+        let buf: Box<[u8]> = self.as_bytes().into();\n         unsafe {\n-            ptr::copy_nonoverlapping(self.as_ptr(), buf.ptr(), len);\n-            from_boxed_utf8_unchecked(buf.into_box())\n+            from_boxed_utf8_unchecked(buf)\n         }\n     }\n }\n@@ -506,9 +697,12 @@ impl<T: Copy> From<&[T]> for Box<[T]> {\n     /// println!(\"{:?}\", boxed_slice);\n     /// ```\n     fn from(slice: &[T]) -> Box<[T]> {\n-        let mut boxed = unsafe { RawVec::with_capacity(slice.len()).into_box() };\n-        boxed.copy_from_slice(slice);\n-        boxed\n+        let len = slice.len();\n+        let buf = RawVec::with_capacity(len);\n+        unsafe {\n+            ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);\n+            buf.into_box()\n+        }\n     }\n }\n \n@@ -554,6 +748,22 @@ impl From<Box<str>> for Box<[u8]> {\n     }\n }\n \n+#[unstable(feature = \"boxed_slice_try_from\", issue = \"0\")]\n+impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = Box<[T]>;\n+\n+    fn try_from(boxed_slice: Box<[T]>) -> Result<Self, Self::Error> {\n+        if boxed_slice.len() == N {\n+            Ok(unsafe { Box::from_raw(Box::into_raw(boxed_slice) as *mut [T; N]) })\n+        } else {\n+            Err(boxed_slice)\n+        }\n+    }\n+}\n+\n impl Box<dyn Any> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -674,6 +884,14 @@ impl<I: Iterator + ?Sized> Iterator for Box<I> {\n         (**self).nth(n)\n     }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator + Sized> Iterator for Box<I> {\n+    fn last(self) -> Option<I::Item> where I: Sized {\n+        (*self).last()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n     fn next_back(&mut self) -> Option<I::Item> {\n@@ -719,61 +937,6 @@ impl<A, F: Fn<A> + ?Sized> Fn<A> for Box<F> {\n     }\n }\n \n-/// `FnBox` is a version of the `FnOnce` intended for use with boxed\n-/// closure objects. The idea is that where one would normally store a\n-/// `Box<dyn FnOnce()>` in a data structure, you should use\n-/// `Box<dyn FnBox()>`. The two traits behave essentially the same, except\n-/// that a `FnBox` closure can only be called if it is boxed. (Note\n-/// that `FnBox` may be deprecated in the future if `Box<dyn FnOnce()>`\n-/// closures become directly usable.)\n-///\n-/// # Examples\n-///\n-/// Here is a snippet of code which creates a hashmap full of boxed\n-/// once closures and then removes them one by one, calling each\n-/// closure as it is removed. Note that the type of the closures\n-/// stored in the map is `Box<dyn FnBox() -> i32>` and not `Box<dyn FnOnce()\n-/// -> i32>`.\n-///\n-/// ```\n-/// #![feature(fnbox)]\n-///\n-/// use std::boxed::FnBox;\n-/// use std::collections::HashMap;\n-///\n-/// fn make_map() -> HashMap<i32, Box<dyn FnBox() -> i32>> {\n-///     let mut map: HashMap<i32, Box<dyn FnBox() -> i32>> = HashMap::new();\n-///     map.insert(1, Box::new(|| 22));\n-///     map.insert(2, Box::new(|| 44));\n-///     map\n-/// }\n-///\n-/// fn main() {\n-///     let mut map = make_map();\n-///     for i in &[1, 2] {\n-///         let f = map.remove(&i).unwrap();\n-///         assert_eq!(f(), i * 22);\n-///     }\n-/// }\n-/// ```\n-#[rustc_paren_sugar]\n-#[unstable(feature = \"fnbox\",\n-           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-pub trait FnBox<A>: FnOnce<A> {\n-    /// Performs the call operation.\n-    fn call_box(self: Box<Self>, args: A) -> Self::Output;\n-}\n-\n-#[unstable(feature = \"fnbox\",\n-           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-impl<A, F> FnBox<A> for F\n-    where F: FnOnce<A>\n-{\n-    fn call_box(self: Box<F>, args: A) -> F::Output {\n-        self.call_once(args)\n-    }\n-}\n-\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Box<U>> for Box<T> {}\n "}, {"sha": "654eabd0703263d7464480e102a636ac4183cc89", "filename": "src/liballoc/boxed_test.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=963184bbb670c1ffa97fc28a98cd5e8473118859", "patch": "@@ -1,140 +0,0 @@\n-//! Test for `boxed` mod.\n-\n-use core::any::Any;\n-use core::ops::Deref;\n-use core::result::Result::{Err, Ok};\n-use core::clone::Clone;\n-use core::f64;\n-use core::i64;\n-\n-use std::boxed::Box;\n-\n-#[test]\n-fn test_owned_clone() {\n-    let a = Box::new(5);\n-    let b: Box<i32> = a.clone();\n-    assert!(a == b);\n-}\n-\n-#[derive(PartialEq, Eq)]\n-struct Test;\n-\n-#[test]\n-fn any_move() {\n-    let a = Box::new(8) as Box<dyn Any>;\n-    let b = Box::new(Test) as Box<dyn Any>;\n-\n-    match a.downcast::<i32>() {\n-        Ok(a) => {\n-            assert!(a == Box::new(8));\n-        }\n-        Err(..) => panic!(),\n-    }\n-    match b.downcast::<Test>() {\n-        Ok(a) => {\n-            assert!(a == Box::new(Test));\n-        }\n-        Err(..) => panic!(),\n-    }\n-\n-    let a = Box::new(8) as Box<dyn Any>;\n-    let b = Box::new(Test) as Box<dyn Any>;\n-\n-    assert!(a.downcast::<Box<Test>>().is_err());\n-    assert!(b.downcast::<Box<i32>>().is_err());\n-}\n-\n-#[test]\n-fn test_show() {\n-    let a = Box::new(8) as Box<dyn Any>;\n-    let b = Box::new(Test) as Box<dyn Any>;\n-    let a_str = format!(\"{:?}\", a);\n-    let b_str = format!(\"{:?}\", b);\n-    assert_eq!(a_str, \"Any\");\n-    assert_eq!(b_str, \"Any\");\n-\n-    static EIGHT: usize = 8;\n-    static TEST: Test = Test;\n-    let a = &EIGHT as &dyn Any;\n-    let b = &TEST as &dyn Any;\n-    let s = format!(\"{:?}\", a);\n-    assert_eq!(s, \"Any\");\n-    let s = format!(\"{:?}\", b);\n-    assert_eq!(s, \"Any\");\n-}\n-\n-#[test]\n-fn deref() {\n-    fn homura<T: Deref<Target = i32>>(_: T) {}\n-    homura(Box::new(765));\n-}\n-\n-#[test]\n-fn raw_sized() {\n-    let x = Box::new(17);\n-    let p = Box::into_raw(x);\n-    unsafe {\n-        assert_eq!(17, *p);\n-        *p = 19;\n-        let y = Box::from_raw(p);\n-        assert_eq!(19, *y);\n-    }\n-}\n-\n-#[test]\n-fn raw_trait() {\n-    trait Foo {\n-        fn get(&self) -> u32;\n-        fn set(&mut self, value: u32);\n-    }\n-\n-    struct Bar(u32);\n-\n-    impl Foo for Bar {\n-        fn get(&self) -> u32 {\n-            self.0\n-        }\n-\n-        fn set(&mut self, value: u32) {\n-            self.0 = value;\n-        }\n-    }\n-\n-    let x: Box<dyn Foo> = Box::new(Bar(17));\n-    let p = Box::into_raw(x);\n-    unsafe {\n-        assert_eq!(17, (*p).get());\n-        (*p).set(19);\n-        let y: Box<dyn Foo> = Box::from_raw(p);\n-        assert_eq!(19, y.get());\n-    }\n-}\n-\n-#[test]\n-fn f64_slice() {\n-    let slice: &[f64] = &[-1.0, 0.0, 1.0, f64::INFINITY];\n-    let boxed: Box<[f64]> = Box::from(slice);\n-    assert_eq!(&*boxed, slice)\n-}\n-\n-#[test]\n-fn i64_slice() {\n-    let slice: &[i64] = &[i64::MIN, -2, -1, 0, 1, 2, i64::MAX];\n-    let boxed: Box<[i64]> = Box::from(slice);\n-    assert_eq!(&*boxed, slice)\n-}\n-\n-#[test]\n-fn str_slice() {\n-    let s = \"Hello, world!\";\n-    let boxed: Box<str> = Box::from(s);\n-    assert_eq!(&*boxed, s)\n-}\n-\n-#[test]\n-fn boxed_slice_from_iter() {\n-    let iter = 0..100;\n-    let boxed: Box<[u32]> = iter.collect();\n-    assert_eq!(boxed.len(), 100);\n-    assert_eq!(boxed[7], 7);\n-}"}, {"sha": "3d04f30e7bde54bf2c8e832bcd4cedb40688fbb8", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -231,6 +231,20 @@ use super::SpecExtend;\n /// assert_eq!(heap.pop(), Some(Reverse(5)));\n /// assert_eq!(heap.pop(), None);\n /// ```\n+///\n+/// # Time complexity\n+///\n+/// | [push] | [pop]    | [peek]/[peek\\_mut] |\n+/// |--------|----------|--------------------|\n+/// | O(1)~  | O(log n) | O(1)               |\n+///\n+/// The value for `push` is an expected cost; the method documentation gives a\n+/// more detailed analysis.\n+///\n+/// [push]: #method.push\n+/// [pop]: #method.pop\n+/// [peek]: #method.peek\n+/// [peek\\_mut]: #method.peek_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n@@ -384,6 +398,10 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// assert_eq!(heap.peek(), Some(&2));\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// Cost is O(1) in the worst case.\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n         if self.is_empty() {\n@@ -411,6 +429,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.pop(), Some(1));\n     /// assert_eq!(heap.pop(), None);\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// The worst case cost of `pop` on a heap containing *n* elements is O(log\n+    /// n).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n@@ -438,6 +461,22 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.len(), 3);\n     /// assert_eq!(heap.peek(), Some(&5));\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// The expected cost of `push`, averaged over every possible ordering of\n+    /// the elements being pushed, and over a sufficiently large number of\n+    /// pushes, is O(1). This is the most meaningful cost metric when pushing\n+    /// elements that are *not* already in any sorted pattern.\n+    ///\n+    /// The time complexity degrades if elements are pushed in predominantly\n+    /// ascending order. In the worst case, elements are pushed in ascending\n+    /// sorted order and the amortized cost per push is O(log n) against a heap\n+    /// containing *n* elements.\n+    ///\n+    /// The worst case cost of a *single* call to `push` is O(n). The worst case\n+    /// occurs when capacity is exhausted and needs a resize. The resize cost\n+    /// has been amortized in the previous figures.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n@@ -650,6 +689,10 @@ impl<T> BinaryHeap<T> {\n     /// assert_eq!(heap.peek(), Some(&5));\n     ///\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// Cost is O(1) in the worst case.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n@@ -994,8 +1037,8 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     }\n \n     #[inline]\n-    fn last(mut self) -> Option<&'a T> {\n-        self.next_back()\n+    fn last(self) -> Option<&'a T> {\n+        self.iter.last()\n     }\n }\n \n@@ -1052,11 +1095,6 @@ impl<T> Iterator for IntoIter<T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<T> {\n-        self.next_back()\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1103,11 +1141,6 @@ impl<T> Iterator for Drain<'_, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<T> {\n-        self.next_back()\n-    }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n@@ -1130,6 +1163,9 @@ impl<T> FusedIterator for Drain<'_, T> {}\n \n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {\n+    /// Converts a `Vec<T>` into a `BinaryHeap<T>`.\n+    ///\n+    /// This conversion happens in-place, and has `O(n)` time complexity.\n     fn from(vec: Vec<T>) -> BinaryHeap<T> {\n         let mut heap = BinaryHeap { data: vec };\n         heap.rebuild();"}, {"sha": "1683b8105567f7f10c135f1dd1dca1abea12e13c", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -75,10 +75,10 @@ use Entry::*;\n ///\n /// // look up the values associated with some keys.\n /// let to_find = [\"Up!\", \"Office Space\"];\n-/// for book in &to_find {\n-///     match movie_reviews.get(book) {\n-///        Some(review) => println!(\"{}: {}\", book, review),\n-///        None => println!(\"{} is unreviewed.\", book)\n+/// for movie in &to_find {\n+///     match movie_reviews.get(movie) {\n+///        Some(review) => println!(\"{}: {}\", movie, review),\n+///        None => println!(\"{} is unreviewed.\", movie)\n ///     }\n /// }\n ///\n@@ -200,7 +200,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             }\n         }\n \n-        if self.len() == 0 {\n+        if self.is_empty() {\n             // Ideally we'd call `BTreeMap::new` here, but that has the `K:\n             // Ord` constraint, which this method lacks.\n             BTreeMap {\n@@ -759,19 +759,19 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n         // Do we have to append anything at all?\n-        if other.len() == 0 {\n+        if other.is_empty() {\n             return;\n         }\n \n         // We can just swap `self` and `other` if `self` is empty.\n-        if self.len() == 0 {\n+        if self.is_empty() {\n             mem::swap(self, other);\n             return;\n         }\n \n         // First, we merge `self` and `other` into a sorted sequence in linear time.\n-        let self_iter = mem::replace(self, BTreeMap::new()).into_iter();\n-        let other_iter = mem::replace(other, BTreeMap::new()).into_iter();\n+        let self_iter = mem::take(self).into_iter();\n+        let other_iter = mem::take(other).into_iter();\n         let iter = MergeIter {\n             left: self_iter.peekable(),\n             right: other_iter.peekable(),\n@@ -1194,7 +1194,6 @@ impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n         (self.length, Some(self.length))\n     }\n \n-    #[inline]\n     fn last(mut self) -> Option<(&'a K, &'a V)> {\n         self.next_back()\n     }\n@@ -1259,7 +1258,6 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n         (self.length, Some(self.length))\n     }\n \n-    #[inline]\n     fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n         self.next_back()\n     }\n@@ -1369,11 +1367,6 @@ impl<K, V> Iterator for IntoIter<K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.length, Some(self.length))\n     }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<(K, V)> {\n-        self.next_back()\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1437,7 +1430,6 @@ impl<'a, K, V> Iterator for Keys<'a, K, V> {\n         self.inner.size_hint()\n     }\n \n-    #[inline]\n     fn last(mut self) -> Option<&'a K> {\n         self.next_back()\n     }\n@@ -1479,7 +1471,6 @@ impl<'a, K, V> Iterator for Values<'a, K, V> {\n         self.inner.size_hint()\n     }\n \n-    #[inline]\n     fn last(mut self) -> Option<&'a V> {\n         self.next_back()\n     }\n@@ -1521,7 +1512,6 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n         }\n     }\n \n-    #[inline]\n     fn last(mut self) -> Option<(&'a K, &'a V)> {\n         self.next_back()\n     }\n@@ -1539,7 +1529,6 @@ impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n         self.inner.size_hint()\n     }\n \n-    #[inline]\n     fn last(mut self) -> Option<&'a mut V> {\n         self.next_back()\n     }\n@@ -1662,7 +1651,6 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n         }\n     }\n \n-    #[inline]\n     fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n         self.next_back()\n     }\n@@ -2044,7 +2032,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(keys, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n+    pub fn keys(&self) -> Keys<'_, K, V> {\n         Keys { inner: self.iter() }\n     }\n \n@@ -2065,7 +2053,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(values, [\"hello\", \"goodbye\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n+    pub fn values(&self) -> Values<'_, K, V> {\n         Values { inner: self.iter() }\n     }\n \n@@ -2569,8 +2557,8 @@ enum UnderflowResult<'a, K, V> {\n     Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n }\n \n-fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>)\n-                                   -> UnderflowResult<'a, K, V> {\n+fn handle_underfull_node<K, V>(node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>)\n+                               -> UnderflowResult<'_, K, V> {\n     let parent = if let Ok(parent) = node.ascend() {\n         parent\n     } else {"}, {"sha": "0b5a271dbea956ef032d21c2aed12802b957faf0", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -106,8 +106,8 @@ impl<K, V> LeafNode<K, V> {\n         LeafNode {\n             // As a general policy, we leave fields uninitialized if they can be, as this should\n             // be both slightly faster and easier to track in Valgrind.\n-            keys: uninitialized_array![_; CAPACITY],\n-            vals: uninitialized_array![_; CAPACITY],\n+            keys: [MaybeUninit::UNINIT; CAPACITY],\n+            vals: [MaybeUninit::UNINIT; CAPACITY],\n             parent: ptr::null(),\n             parent_idx: MaybeUninit::uninit(),\n             len: 0\n@@ -159,7 +159,7 @@ impl<K, V> InternalNode<K, V> {\n     unsafe fn new() -> Self {\n         InternalNode {\n             data: LeafNode::new(),\n-            edges: uninitialized_array![_; 2*B],\n+            edges: [MaybeUninit::UNINIT; 2*B]\n         }\n     }\n }\n@@ -394,7 +394,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     /// Temporarily takes out another, immutable reference to the same node.\n-    fn reborrow<'a>(&'a self) -> NodeRef<marker::Immut<'a>, K, V, Type> {\n+    fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n         NodeRef {\n             height: self.height,\n             node: self.node,"}, {"sha": "d3af910a82c27939dab4b03e1190ccad6b842a86", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1019,8 +1019,6 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n-\n-    #[inline]\n     fn last(mut self) -> Option<&'a T> {\n         self.next_back()\n     }\n@@ -1049,11 +1047,6 @@ impl<T> Iterator for IntoIter<T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<T> {\n-        self.next_back()\n-    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> DoubleEndedIterator for IntoIter<T> {\n@@ -1084,7 +1077,6 @@ impl<'a, T> Iterator for Range<'a, T> {\n         self.iter.next().map(|(k, _)| k)\n     }\n \n-    #[inline]\n     fn last(mut self) -> Option<&'a T> {\n         self.next_back()\n     }"}, {"sha": "a14a3fe9994abb59c517411f62ec9400ad22a6ef", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 18, "deletions": 275, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -23,6 +23,9 @@ use core::ptr::NonNull;\n use crate::boxed::Box;\n use super::SpecExtend;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A doubly-linked list with owned nodes.\n ///\n /// The `LinkedList` allows pushing and popping elements at either end\n@@ -237,15 +240,15 @@ impl<T> LinkedList<T> {\n \n         // Not creating new mutable (unique!) references overlapping `element`.\n         match node.prev {\n-            Some(prev) => (*prev.as_ptr()).next = node.next.clone(),\n+            Some(prev) => (*prev.as_ptr()).next = node.next,\n             // this node is the head node\n-            None => self.head = node.next.clone(),\n+            None => self.head = node.next,\n         };\n \n         match node.next {\n-            Some(next) => (*next.as_ptr()).prev = node.prev.clone(),\n+            Some(next) => (*next.as_ptr()).prev = node.prev,\n             // this node is the tail node\n-            None => self.tail = node.prev.clone(),\n+            None => self.tail = node.prev,\n         };\n \n         self.len -= 1;\n@@ -708,7 +711,7 @@ impl<T> LinkedList<T> {\n         let len = self.len();\n         assert!(at <= len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n-            return mem::replace(self, Self::new());\n+            return mem::take(self);\n         } else if at == len {\n             return Self::new();\n         }\n@@ -832,6 +835,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -881,6 +889,11 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a mut T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1234,273 +1247,3 @@ unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::thread;\n-    use std::vec::Vec;\n-\n-    use rand::{thread_rng, RngCore};\n-\n-    use super::{LinkedList, Node};\n-\n-    #[cfg(test)]\n-    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n-        v.iter().cloned().collect()\n-    }\n-\n-    pub fn check_links<T>(list: &LinkedList<T>) {\n-        unsafe {\n-            let mut len = 0;\n-            let mut last_ptr: Option<&Node<T>> = None;\n-            let mut node_ptr: &Node<T>;\n-            match list.head {\n-                None => {\n-                    // tail node should also be None.\n-                    assert!(list.tail.is_none());\n-                    assert_eq!(0, list.len);\n-                    return;\n-                }\n-                Some(node) => node_ptr = &*node.as_ptr(),\n-            }\n-            loop {\n-                match (last_ptr, node_ptr.prev) {\n-                    (None, None) => {}\n-                    (None, _) => panic!(\"prev link for head\"),\n-                    (Some(p), Some(pptr)) => {\n-                        assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n-                    }\n-                    _ => panic!(\"prev link is none, not good\"),\n-                }\n-                match node_ptr.next {\n-                    Some(next) => {\n-                        last_ptr = Some(node_ptr);\n-                        node_ptr = &*next.as_ptr();\n-                        len += 1;\n-                    }\n-                    None => {\n-                        len += 1;\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            // verify that the tail node points to the last node.\n-            let tail = list.tail.as_ref().expect(\"some tail node\").as_ref();\n-            assert_eq!(tail as *const Node<T>, node_ptr as *const Node<T>);\n-            // check that len matches interior links.\n-            assert_eq!(len, list.len);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        // Empty to empty\n-        {\n-            let mut m = LinkedList::<i32>::new();\n-            let mut n = LinkedList::new();\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 0);\n-            assert_eq!(n.len(), 0);\n-        }\n-        // Non-empty to empty\n-        {\n-            let mut m = LinkedList::new();\n-            let mut n = LinkedList::new();\n-            n.push_back(2);\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            assert_eq!(n.len(), 0);\n-            check_links(&m);\n-        }\n-        // Empty to non-empty\n-        {\n-            let mut m = LinkedList::new();\n-            let mut n = LinkedList::new();\n-            m.push_back(2);\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            check_links(&m);\n-        }\n-\n-        // Non-empty to non-empty\n-        let v = vec![1, 2, 3, 4, 5];\n-        let u = vec![9, 8, 1, 2, 3, 4, 5];\n-        let mut m = list_from(&v);\n-        let mut n = list_from(&u);\n-        m.append(&mut n);\n-        check_links(&m);\n-        let mut sum = v;\n-        sum.extend_from_slice(&u);\n-        assert_eq!(sum.len(), m.len());\n-        for elt in sum {\n-            assert_eq!(m.pop_front(), Some(elt))\n-        }\n-        assert_eq!(n.len(), 0);\n-        // let's make sure it's working properly, since we\n-        // did some direct changes to private members\n-        n.push_back(3);\n-        assert_eq!(n.len(), 1);\n-        assert_eq!(n.pop_front(), Some(3));\n-        check_links(&n);\n-    }\n-\n-    #[test]\n-    fn test_insert_prev() {\n-        let mut m = list_from(&[0, 2, 4, 6, 8]);\n-        let len = m.len();\n-        {\n-            let mut it = m.iter_mut();\n-            it.insert_next(-2);\n-            loop {\n-                match it.next() {\n-                    None => break,\n-                    Some(elt) => {\n-                        it.insert_next(*elt + 1);\n-                        match it.peek_next() {\n-                            Some(x) => assert_eq!(*x, *elt + 2),\n-                            None => assert_eq!(8, *elt),\n-                        }\n-                    }\n-                }\n-            }\n-            it.insert_next(0);\n-            it.insert_next(1);\n-        }\n-        check_links(&m);\n-        assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(),\n-                   [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg(not(miri))] // Miri does not support threads\n-    fn test_send() {\n-        let n = list_from(&[1, 2, 3]);\n-        thread::spawn(move || {\n-                check_links(&n);\n-                let a: &[_] = &[&1, &2, &3];\n-                assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n-            })\n-            .join()\n-            .ok()\n-            .unwrap();\n-    }\n-\n-    #[test]\n-    fn test_fuzz() {\n-        for _ in 0..25 {\n-            fuzz_test(3);\n-            fuzz_test(16);\n-            #[cfg(not(miri))] // Miri is too slow\n-            fuzz_test(189);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_26021() {\n-        // There was a bug in split_off that failed to null out the RHS's head's prev ptr.\n-        // This caused the RHS's dtor to walk up into the LHS at drop and delete all of\n-        // its nodes.\n-        //\n-        // https://github.com/rust-lang/rust/issues/26021\n-        let mut v1 = LinkedList::new();\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        let _ = v1.split_off(3); // Dropping this now should not cause laundry consumption\n-        assert_eq!(v1.len(), 3);\n-\n-        assert_eq!(v1.iter().len(), 3);\n-        assert_eq!(v1.iter().collect::<Vec<_>>().len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        let mut v1 = LinkedList::new();\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-\n-        // test all splits\n-        for ix in 0..1 + v1.len() {\n-            let mut a = v1.clone();\n-            let b = a.split_off(ix);\n-            check_links(&a);\n-            check_links(&b);\n-            a.extend(b);\n-            assert_eq!(v1, a);\n-        }\n-    }\n-\n-    #[cfg(test)]\n-    fn fuzz_test(sz: i32) {\n-        let mut m: LinkedList<_> = LinkedList::new();\n-        let mut v = vec![];\n-        for i in 0..sz {\n-            check_links(&m);\n-            let r: u8 = thread_rng().next_u32() as u8;\n-            match r % 6 {\n-                0 => {\n-                    m.pop_back();\n-                    v.pop();\n-                }\n-                1 => {\n-                    if !v.is_empty() {\n-                        m.pop_front();\n-                        v.remove(0);\n-                    }\n-                }\n-                2 | 4 => {\n-                    m.push_front(-i);\n-                    v.insert(0, -i);\n-                }\n-                3 | 5 | _ => {\n-                    m.push_back(i);\n-                    v.push(i);\n-                }\n-            }\n-        }\n-\n-        check_links(&m);\n-\n-        let mut i = 0;\n-        for (a, &b) in m.into_iter().zip(&v) {\n-            i += 1;\n-            assert_eq!(a, b);\n-        }\n-        assert_eq!(i, v.len());\n-    }\n-\n-    #[test]\n-    fn drain_filter_test() {\n-        let mut m: LinkedList<u32> = LinkedList::new();\n-        m.extend(&[1, 2, 3, 4, 5, 6]);\n-        let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n-\n-        check_links(&m);\n-\n-        assert_eq!(deleted, &[1, 2, 3]);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n-    }\n-\n-    #[test]\n-    fn drain_to_empty_test() {\n-        let mut m: LinkedList<u32> = LinkedList::new();\n-        m.extend(&[1, 2, 3, 4, 5, 6]);\n-        let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n-\n-        check_links(&m);\n-\n-        assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n-    }\n-}"}, {"sha": "9a6c57d286970d997a9ca4612f30b0cab3bd6383", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,264 @@\n+use super::*;\n+\n+use std::thread;\n+use std::vec::Vec;\n+\n+use rand::{thread_rng, RngCore};\n+\n+fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n+    v.iter().cloned().collect()\n+}\n+\n+pub fn check_links<T>(list: &LinkedList<T>) {\n+    unsafe {\n+        let mut len = 0;\n+        let mut last_ptr: Option<&Node<T>> = None;\n+        let mut node_ptr: &Node<T>;\n+        match list.head {\n+            None => {\n+                // tail node should also be None.\n+                assert!(list.tail.is_none());\n+                assert_eq!(0, list.len);\n+                return;\n+            }\n+            Some(node) => node_ptr = &*node.as_ptr(),\n+        }\n+        loop {\n+            match (last_ptr, node_ptr.prev) {\n+                (None, None) => {}\n+                (None, _) => panic!(\"prev link for head\"),\n+                (Some(p), Some(pptr)) => {\n+                    assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n+                }\n+                _ => panic!(\"prev link is none, not good\"),\n+            }\n+            match node_ptr.next {\n+                Some(next) => {\n+                    last_ptr = Some(node_ptr);\n+                    node_ptr = &*next.as_ptr();\n+                    len += 1;\n+                }\n+                None => {\n+                    len += 1;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // verify that the tail node points to the last node.\n+        let tail = list.tail.as_ref().expect(\"some tail node\").as_ref();\n+        assert_eq!(tail as *const Node<T>, node_ptr as *const Node<T>);\n+        // check that len matches interior links.\n+        assert_eq!(len, list.len);\n+    }\n+}\n+\n+#[test]\n+fn test_append() {\n+    // Empty to empty\n+    {\n+        let mut m = LinkedList::<i32>::new();\n+        let mut n = LinkedList::new();\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(n.len(), 0);\n+    }\n+    // Non-empty to empty\n+    {\n+        let mut m = LinkedList::new();\n+        let mut n = LinkedList::new();\n+        n.push_back(2);\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        assert_eq!(n.len(), 0);\n+        check_links(&m);\n+    }\n+    // Empty to non-empty\n+    {\n+        let mut m = LinkedList::new();\n+        let mut n = LinkedList::new();\n+        m.push_back(2);\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        check_links(&m);\n+    }\n+\n+    // Non-empty to non-empty\n+    let v = vec![1, 2, 3, 4, 5];\n+    let u = vec![9, 8, 1, 2, 3, 4, 5];\n+    let mut m = list_from(&v);\n+    let mut n = list_from(&u);\n+    m.append(&mut n);\n+    check_links(&m);\n+    let mut sum = v;\n+    sum.extend_from_slice(&u);\n+    assert_eq!(sum.len(), m.len());\n+    for elt in sum {\n+        assert_eq!(m.pop_front(), Some(elt))\n+    }\n+    assert_eq!(n.len(), 0);\n+    // let's make sure it's working properly, since we\n+    // did some direct changes to private members\n+    n.push_back(3);\n+    assert_eq!(n.len(), 1);\n+    assert_eq!(n.pop_front(), Some(3));\n+    check_links(&n);\n+}\n+\n+#[test]\n+fn test_insert_prev() {\n+    let mut m = list_from(&[0, 2, 4, 6, 8]);\n+    let len = m.len();\n+    {\n+        let mut it = m.iter_mut();\n+        it.insert_next(-2);\n+        loop {\n+            match it.next() {\n+                None => break,\n+                Some(elt) => {\n+                    it.insert_next(*elt + 1);\n+                    match it.peek_next() {\n+                        Some(x) => assert_eq!(*x, *elt + 2),\n+                        None => assert_eq!(8, *elt),\n+                    }\n+                }\n+            }\n+        }\n+        it.insert_next(0);\n+        it.insert_next(1);\n+    }\n+    check_links(&m);\n+    assert_eq!(m.len(), 3 + len * 2);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(),\n+                [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support threads\n+fn test_send() {\n+    let n = list_from(&[1, 2, 3]);\n+    thread::spawn(move || {\n+            check_links(&n);\n+            let a: &[_] = &[&1, &2, &3];\n+            assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n+        })\n+        .join()\n+        .ok()\n+        .unwrap();\n+}\n+\n+#[test]\n+fn test_fuzz() {\n+    for _ in 0..25 {\n+        fuzz_test(3);\n+        fuzz_test(16);\n+        #[cfg(not(miri))] // Miri is too slow\n+        fuzz_test(189);\n+    }\n+}\n+\n+#[test]\n+fn test_26021() {\n+    // There was a bug in split_off that failed to null out the RHS's head's prev ptr.\n+    // This caused the RHS's dtor to walk up into the LHS at drop and delete all of\n+    // its nodes.\n+    //\n+    // https://github.com/rust-lang/rust/issues/26021\n+    let mut v1 = LinkedList::new();\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    let _ = v1.split_off(3); // Dropping this now should not cause laundry consumption\n+    assert_eq!(v1.len(), 3);\n+\n+    assert_eq!(v1.iter().len(), 3);\n+    assert_eq!(v1.iter().collect::<Vec<_>>().len(), 3);\n+}\n+\n+#[test]\n+fn test_split_off() {\n+    let mut v1 = LinkedList::new();\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+\n+    // test all splits\n+    for ix in 0..1 + v1.len() {\n+        let mut a = v1.clone();\n+        let b = a.split_off(ix);\n+        check_links(&a);\n+        check_links(&b);\n+        a.extend(b);\n+        assert_eq!(v1, a);\n+    }\n+}\n+\n+fn fuzz_test(sz: i32) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    let mut v = vec![];\n+    for i in 0..sz {\n+        check_links(&m);\n+        let r: u8 = thread_rng().next_u32() as u8;\n+        match r % 6 {\n+            0 => {\n+                m.pop_back();\n+                v.pop();\n+            }\n+            1 => {\n+                if !v.is_empty() {\n+                    m.pop_front();\n+                    v.remove(0);\n+                }\n+            }\n+            2 | 4 => {\n+                m.push_front(-i);\n+                v.insert(0, -i);\n+            }\n+            3 | 5 | _ => {\n+                m.push_back(i);\n+                v.push(i);\n+            }\n+        }\n+    }\n+\n+    check_links(&m);\n+\n+    let mut i = 0;\n+    for (a, &b) in m.into_iter().zip(&v) {\n+        i += 1;\n+        assert_eq!(a, b);\n+    }\n+    assert_eq!(i, v.len());\n+}\n+\n+#[test]\n+fn drain_filter_test() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n+\n+    check_links(&m);\n+\n+    assert_eq!(deleted, &[1, 2, 3]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n+}\n+\n+#[test]\n+fn drain_to_empty_test() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n+\n+    check_links(&m);\n+\n+    assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+}"}, {"sha": "f1f22fe48c58ab0c4343a82dbd7ecfd26708c9c3", "filename": "src/liballoc/collections/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -41,32 +41,35 @@ pub use linked_list::LinkedList;\n #[doc(no_inline)]\n pub use vec_deque::VecDeque;\n \n-use crate::alloc::{AllocErr, LayoutErr};\n+use crate::alloc::{Layout, LayoutErr};\n \n-/// Augments `AllocErr` with a CapacityOverflow variant.\n+/// The error type for `try_reserve` methods.\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-pub enum CollectionAllocErr {\n+pub enum TryReserveError {\n     /// Error due to the computed capacity exceeding the collection's maximum\n     /// (usually `isize::MAX` bytes).\n     CapacityOverflow,\n-    /// Error due to the allocator (see the `AllocErr` type's docs).\n-    AllocErr,\n-}\n \n-#[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-impl From<AllocErr> for CollectionAllocErr {\n-    #[inline]\n-    fn from(AllocErr: AllocErr) -> Self {\n-        CollectionAllocErr::AllocErr\n-    }\n+    /// The memory allocator returned an error\n+    AllocError {\n+        /// The layout of allocation request that failed\n+        layout: Layout,\n+\n+        #[doc(hidden)]\n+        #[unstable(feature = \"container_error_extra\", issue = \"0\", reason = \"\\\n+            Enable exposing the allocator\u2019s custom error value \\\n+            if an associated type is added in the future: \\\n+            https://github.com/rust-lang/wg-allocators/issues/23\")]\n+        non_exhaustive: (),\n+    },\n }\n \n #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-impl From<LayoutErr> for CollectionAllocErr {\n+impl From<LayoutErr> for TryReserveError {\n     #[inline]\n     fn from(_: LayoutErr) -> Self {\n-        CollectionAllocErr::CapacityOverflow\n+        TryReserveError::CapacityOverflow\n     }\n }\n "}, {"sha": "7315963cc8b1dd6db5128d0a7c3ab8d6c04f2a8a", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 132, "deletions": 484, "changes": 616, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! A double-ended queue implemented with a growable ring buffer.\n //!\n //! This queue has `O(1)` amortized inserts and removals from both ends of the\n@@ -9,6 +7,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n use core::iter::{repeat_with, FromIterator, FusedIterator};\n@@ -19,10 +18,13 @@ use core::ptr::{self, NonNull};\n use core::slice;\n use core::hash::{Hash, Hasher};\n \n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n #[cfg(target_pointer_width = \"16\")]\n@@ -98,7 +100,7 @@ impl<T> VecDeque<T> {\n             // For zero sized types, we are always at maximum capacity\n             MAXIMUM_ZST_CAPACITY\n         } else {\n-            self.buf.cap()\n+            self.buf.capacity()\n         }\n     }\n \n@@ -314,10 +316,10 @@ impl<T> VecDeque<T> {\n     }\n \n     /// Frobs the head and tail sections around to handle the fact that we\n-    /// just reallocated. Unsafe because it trusts old_cap.\n+    /// just reallocated. Unsafe because it trusts old_capacity.\n     #[inline]\n-    unsafe fn handle_cap_increase(&mut self, old_cap: usize) {\n-        let new_cap = self.cap();\n+    unsafe fn handle_capacity_increase(&mut self, old_capacity: usize) {\n+        let new_capacity = self.cap();\n \n         // Move the shortest contiguous section of the ring buffer\n         //    T             H\n@@ -336,15 +338,15 @@ impl<T> VecDeque<T> {\n         if self.tail <= self.head {\n             // A\n             // Nop\n-        } else if self.head < old_cap - self.tail {\n+        } else if self.head < old_capacity - self.tail {\n             // B\n-            self.copy_nonoverlapping(old_cap, 0, self.head);\n-            self.head += old_cap;\n+            self.copy_nonoverlapping(old_capacity, 0, self.head);\n+            self.head += old_capacity;\n             debug_assert!(self.head > self.tail);\n         } else {\n             // C\n-            let new_tail = new_cap - (old_cap - self.tail);\n-            self.copy_nonoverlapping(new_tail, self.tail, old_cap - self.tail);\n+            let new_tail = new_capacity - (old_capacity - self.tail);\n+            self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n             self.tail = new_tail;\n             debug_assert!(self.head < self.tail);\n         }\n@@ -551,7 +553,7 @@ impl<T> VecDeque<T> {\n         if new_cap > old_cap {\n             self.buf.reserve_exact(used_cap, new_cap - used_cap);\n             unsafe {\n-                self.handle_cap_increase(old_cap);\n+                self.handle_capacity_increase(old_cap);\n             }\n         }\n     }\n@@ -574,10 +576,10 @@ impl<T> VecDeque<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     /// use std::collections::VecDeque;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n     ///     let mut output = VecDeque::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -593,7 +595,7 @@ impl<T> VecDeque<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.try_reserve(additional)\n     }\n \n@@ -612,10 +614,10 @@ impl<T> VecDeque<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     /// use std::collections::VecDeque;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<VecDeque<u32>, TryReserveError> {\n     ///     let mut output = VecDeque::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -631,17 +633,17 @@ impl<T> VecDeque<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         let old_cap = self.cap();\n         let used_cap = self.len() + 1;\n         let new_cap = used_cap.checked_add(additional)\n             .and_then(|needed_cap| needed_cap.checked_next_power_of_two())\n-            .ok_or(CollectionAllocErr::CapacityOverflow)?;\n+            .ok_or(TryReserveError::CapacityOverflow)?;\n \n         if new_cap > old_cap {\n             self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;\n             unsafe {\n-                self.handle_cap_increase(old_cap);\n+                self.handle_capacity_increase(old_cap);\n             }\n         }\n         Ok(())\n@@ -1197,6 +1199,31 @@ impl<T> VecDeque<T> {\n         }\n     }\n \n+    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n+    /// it is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    /// assert_eq!(buf.pop_back(), None);\n+    /// buf.push_back(1);\n+    /// buf.push_back(3);\n+    /// assert_eq!(buf.pop_back(), Some(3));\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn pop_back(&mut self) -> Option<T> {\n+        if self.is_empty() {\n+            None\n+        } else {\n+            self.head = self.wrap_sub(self.head, 1);\n+            let head = self.head;\n+            unsafe { Some(self.buffer_read(head)) }\n+        }\n+    }\n+\n     /// Prepends an element to the `VecDeque`.\n     ///\n     /// # Examples\n@@ -1241,38 +1268,13 @@ impl<T> VecDeque<T> {\n         unsafe { self.buffer_write(head, value) }\n     }\n \n-    /// Removes the last element from the `VecDeque` and returns it, or `None` if\n-    /// it is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::VecDeque;\n-    ///\n-    /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.pop_back(), None);\n-    /// buf.push_back(1);\n-    /// buf.push_back(3);\n-    /// assert_eq!(buf.pop_back(), Some(3));\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn pop_back(&mut self) -> Option<T> {\n-        if self.is_empty() {\n-            None\n-        } else {\n-            self.head = self.wrap_sub(self.head, 1);\n-            let head = self.head;\n-            unsafe { Some(self.buffer_read(head)) }\n-        }\n-    }\n-\n     #[inline]\n     fn is_contiguous(&self) -> bool {\n         self.tail <= self.head\n     }\n \n-    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n-    /// last element.\n+    /// Removes an element from anywhere in the `VecDeque` and returns it,\n+    /// replacing it with the first element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -1286,28 +1288,28 @@ impl<T> VecDeque<T> {\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.swap_remove_back(0), None);\n+    /// assert_eq!(buf.swap_remove_front(0), None);\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n     /// assert_eq!(buf, [1, 2, 3]);\n     ///\n-    /// assert_eq!(buf.swap_remove_back(0), Some(1));\n-    /// assert_eq!(buf, [3, 2]);\n+    /// assert_eq!(buf.swap_remove_front(2), Some(3));\n+    /// assert_eq!(buf, [2, 1]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n-    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n+    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n-        if length > 0 && index < length - 1 {\n-            self.swap(index, length - 1);\n+        if length > 0 && index < length && index != 0 {\n+            self.swap(index, 0);\n         } else if index >= length {\n             return None;\n         }\n-        self.pop_back()\n+        self.pop_front()\n     }\n \n-    /// Removes an element from anywhere in the `VecDeque` and returns it,\n-    /// replacing it with the first element.\n+    /// Removes an element from anywhere in the `VecDeque` and returns it, replacing it with the\n+    /// last element.\n     ///\n     /// This does not preserve ordering, but is O(1).\n     ///\n@@ -1321,24 +1323,24 @@ impl<T> VecDeque<T> {\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf = VecDeque::new();\n-    /// assert_eq!(buf.swap_remove_front(0), None);\n+    /// assert_eq!(buf.swap_remove_back(0), None);\n     /// buf.push_back(1);\n     /// buf.push_back(2);\n     /// buf.push_back(3);\n     /// assert_eq!(buf, [1, 2, 3]);\n     ///\n-    /// assert_eq!(buf.swap_remove_front(2), Some(3));\n-    /// assert_eq!(buf, [2, 1]);\n+    /// assert_eq!(buf.swap_remove_back(0), Some(1));\n+    /// assert_eq!(buf, [3, 2]);\n     /// ```\n     #[stable(feature = \"deque_extras_15\", since = \"1.5.0\")]\n-    pub fn swap_remove_front(&mut self, index: usize) -> Option<T> {\n+    pub fn swap_remove_back(&mut self, index: usize) -> Option<T> {\n         let length = self.len();\n-        if length > 0 && index < length && index != 0 {\n-            self.swap(index, 0);\n+        if length > 0 && index < length - 1 {\n+            self.swap(index, length - 1);\n         } else if index >= length {\n             return None;\n         }\n-        self.pop_front()\n+        self.pop_back()\n     }\n \n     /// Inserts an element at `index` within the `VecDeque`, shifting all elements with indices\n@@ -1887,7 +1889,7 @@ impl<T> VecDeque<T> {\n             let old_cap = self.cap();\n             self.buf.double();\n             unsafe {\n-                self.handle_cap_increase(old_cap);\n+                self.handle_capacity_increase(old_cap);\n             }\n             debug_assert!(!self.is_full());\n         }\n@@ -1948,8 +1950,6 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(vecdeque_rotate)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<_> = (0..10).collect();\n@@ -1963,7 +1963,7 @@ impl<T> VecDeque<T> {\n     /// }\n     /// assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n     /// ```\n-    #[unstable(feature = \"vecdeque_rotate\", issue = \"56686\")]\n+    #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n     pub fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n         let k = self.len() - mid;\n@@ -1993,8 +1993,6 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(vecdeque_rotate)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<_> = (0..10).collect();\n@@ -2008,7 +2006,7 @@ impl<T> VecDeque<T> {\n     /// }\n     /// assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n     /// ```\n-    #[unstable(feature = \"vecdeque_rotate\", issue = \"56686\")]\n+    #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n     pub fn rotate_right(&mut self, k: usize) {\n         assert!(k <= self.len());\n         let mid = self.len() - k;\n@@ -2210,6 +2208,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         self.tail = self.head - iter.len();\n         final_res\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2323,6 +2326,11 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         accum = front.iter_mut().fold(accum, &mut f);\n         back.iter_mut().fold(accum, &mut f)\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a mut T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2565,13 +2573,14 @@ impl<A: PartialEq> PartialEq for VecDeque<A> {\n impl<A: Eq> Eq for VecDeque<A> {}\n \n macro_rules! __impl_slice_eq1 {\n-    ($Lhs: ty, $Rhs: ty) => {\n-        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n-    };\n-    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n+    ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n         #[stable(feature = \"vec_deque_partial_eq_slice\", since = \"1.17.0\")]\n-        impl<A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n-            fn eq(&self, other: &$Rhs) -> bool {\n+        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n+        where\n+            A: PartialEq<B>,\n+            $($constraints)*\n+        {\n+            fn eq(&self, other: &$rhs) -> bool {\n                 if self.len() != other.len() {\n                     return false;\n                 }\n@@ -2583,26 +2592,12 @@ macro_rules! __impl_slice_eq1 {\n     }\n }\n \n-__impl_slice_eq1! { VecDeque<A>, Vec<B> }\n-__impl_slice_eq1! { VecDeque<A>, &[B] }\n-__impl_slice_eq1! { VecDeque<A>, &mut [B] }\n-\n-macro_rules! array_impls {\n-    ($($N: expr)+) => {\n-        $(\n-            __impl_slice_eq1! { VecDeque<A>, [B; $N] }\n-            __impl_slice_eq1! { VecDeque<A>, &[B; $N] }\n-            __impl_slice_eq1! { VecDeque<A>, &mut [B; $N] }\n-        )+\n-    }\n-}\n-\n-array_impls! {\n-     0  1  2  3  4  5  6  7  8  9\n-    10 11 12 13 14 15 16 17 18 19\n-    20 21 22 23 24 25 26 27 28 29\n-    30 31 32\n-}\n+__impl_slice_eq1! { [] VecDeque<A>, Vec<B>, }\n+__impl_slice_eq1! { [] VecDeque<A>, &[B], }\n+__impl_slice_eq1! { [] VecDeque<A>, &mut [B], }\n+__impl_slice_eq1! { [const N: usize] VecDeque<A>, [B; N], [B; N]: LengthAtMost32 }\n+__impl_slice_eq1! { [const N: usize] VecDeque<A>, &[B; N], [B; N]: LengthAtMost32 }\n+__impl_slice_eq1! { [const N: usize] VecDeque<A>, &mut [B; N], [B; N]: LengthAtMost32 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for VecDeque<A> {\n@@ -2713,6 +2708,14 @@ impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n \n #[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\n impl<T> From<Vec<T>> for VecDeque<T> {\n+    /// Turn a [`Vec<T>`] into a [`VecDeque<T>`].\n+    ///\n+    /// [`Vec<T>`]: crate::vec::Vec\n+    /// [`VecDeque<T>`]: crate::collections::VecDeque\n+    ///\n+    /// This avoids reallocating where possible, but the conditions for that are\n+    /// strict, and subject to change, and so shouldn't be relied upon unless the\n+    /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n     fn from(mut other: Vec<T>) -> Self {\n         unsafe {\n             let other_buf = other.as_mut_ptr();\n@@ -2722,9 +2725,9 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n \n             // We need to extend the buf if it's not a power of two, too small\n             // or doesn't have at least one free space\n-            if !buf.cap().is_power_of_two() || (buf.cap() < (MINIMUM_CAPACITY + 1)) ||\n-               (buf.cap() == len) {\n-                let cap = cmp::max(buf.cap() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+            if !buf.capacity().is_power_of_two() || (buf.capacity() < (MINIMUM_CAPACITY + 1)) ||\n+               (buf.capacity() == len) {\n+                let cap = cmp::max(buf.capacity() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n                 buf.reserve_exact(len, cap - len);\n             }\n \n@@ -2739,6 +2742,35 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n \n #[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\n impl<T> From<VecDeque<T>> for Vec<T> {\n+    /// Turn a [`VecDeque<T>`] into a [`Vec<T>`].\n+    ///\n+    /// [`Vec<T>`]: crate::vec::Vec\n+    /// [`VecDeque<T>`]: crate::collections::VecDeque\n+    ///\n+    /// This never needs to re-allocate, but does need to do O(n) data movement if\n+    /// the circular buffer doesn't happen to be at the beginning of the allocation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// // This one is O(1).\n+    /// let deque: VecDeque<_> = (1..5).collect();\n+    /// let ptr = deque.as_slices().0.as_ptr();\n+    /// let vec = Vec::from(deque);\n+    /// assert_eq!(vec, [1, 2, 3, 4]);\n+    /// assert_eq!(vec.as_ptr(), ptr);\n+    ///\n+    /// // This one needs data rearranging.\n+    /// let mut deque: VecDeque<_> = (1..5).collect();\n+    /// deque.push_front(9);\n+    /// deque.push_front(8);\n+    /// let ptr = deque.as_slices().1.as_ptr();\n+    /// let vec = Vec::from(deque);\n+    /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n+    /// assert_eq!(vec.as_ptr(), ptr);\n+    /// ```\n     fn from(other: VecDeque<T>) -> Self {\n         unsafe {\n             let buf = other.buf.ptr();\n@@ -2807,387 +2839,3 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use ::test;\n-\n-    use super::VecDeque;\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_push_back_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::with_capacity(101);\n-        b.iter(|| {\n-            for i in 0..100 {\n-                deq.push_back(i);\n-            }\n-            deq.head = 0;\n-            deq.tail = 0;\n-        })\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_push_front_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::with_capacity(101);\n-        b.iter(|| {\n-            for i in 0..100 {\n-                deq.push_front(i);\n-            }\n-            deq.head = 0;\n-            deq.tail = 0;\n-        })\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::<i32>::with_capacity(101);\n-\n-        b.iter(|| {\n-            deq.head = 100;\n-            deq.tail = 0;\n-            while !deq.is_empty() {\n-                test::black_box(deq.pop_back());\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    #[cfg(not(miri))] // Miri does not support benchmarks\n-    fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::<i32>::with_capacity(101);\n-\n-        b.iter(|| {\n-            deq.head = 100;\n-            deq.tail = 0;\n-            while !deq.is_empty() {\n-                test::black_box(deq.pop_front());\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn test_swap_front_back_remove() {\n-        fn test(back: bool) {\n-            // This test checks that every single combination of tail position and length is tested.\n-            // Capacity 15 should be large enough to cover every case.\n-            let mut tester = VecDeque::with_capacity(15);\n-            let usable_cap = tester.capacity();\n-            let final_len = usable_cap / 2;\n-\n-            for len in 0..final_len {\n-                let expected: VecDeque<_> = if back {\n-                    (0..len).collect()\n-                } else {\n-                    (0..len).rev().collect()\n-                };\n-                for tail_pos in 0..usable_cap {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    if back {\n-                        for i in 0..len * 2 {\n-                            tester.push_front(i);\n-                        }\n-                        for i in 0..len {\n-                            assert_eq!(tester.swap_remove_back(i), Some(len * 2 - 1 - i));\n-                        }\n-                    } else {\n-                        for i in 0..len * 2 {\n-                            tester.push_back(i);\n-                        }\n-                        for i in 0..len {\n-                            let idx = tester.len() - 1 - i;\n-                            assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n-                        }\n-                    }\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-        test(true);\n-        test(false);\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        // This test checks that every single combination of tail position, length, and\n-        // insertion position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-\n-        // len is the length *after* insertion\n-        for len in 1..cap {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..cap {\n-                for to_insert in 0..len {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        if i != to_insert {\n-                            tester.push_back(i);\n-                        }\n-                    }\n-                    tester.insert(to_insert, to_insert);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        // This test checks that every single combination of tail position, length, and\n-        // removal position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-        // len is the length *after* removal\n-        for len in 0..cap - 1 {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..cap {\n-                for to_remove in 0..=len {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        if i == to_remove {\n-                            tester.push_back(1234);\n-                        }\n-                        tester.push_back(i);\n-                    }\n-                    if to_remove == len {\n-                        tester.push_back(1234);\n-                    }\n-                    tester.remove(to_remove);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_drain() {\n-        let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n-\n-        let cap = tester.capacity();\n-        for len in 0..=cap {\n-            for tail in 0..=cap {\n-                for drain_start in 0..=len {\n-                    for drain_end in drain_start..=len {\n-                        tester.tail = tail;\n-                        tester.head = tail;\n-                        for i in 0..len {\n-                            tester.push_back(i);\n-                        }\n-\n-                        // Check that we drain the correct values\n-                        let drained: VecDeque<_> = tester.drain(drain_start..drain_end).collect();\n-                        let drained_expected: VecDeque<_> = (drain_start..drain_end).collect();\n-                        assert_eq!(drained, drained_expected);\n-\n-                        // We shouldn't have changed the capacity or made the\n-                        // head or tail out of bounds\n-                        assert_eq!(tester.capacity(), cap);\n-                        assert!(tester.tail < tester.cap());\n-                        assert!(tester.head < tester.cap());\n-\n-                        // We should see the correct values in the VecDeque\n-                        let expected: VecDeque<_> = (0..drain_start)\n-                            .chain(drain_end..len)\n-                            .collect();\n-                        assert_eq!(expected, tester);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_shrink_to_fit() {\n-        // This test checks that every single combination of head and tail position,\n-        // is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-        tester.reserve(63);\n-        let max_cap = tester.capacity();\n-\n-        for len in 0..=cap {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..=max_cap {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n-                tester.reserve(63);\n-                for i in 0..len {\n-                    tester.push_back(i);\n-                }\n-                tester.shrink_to_fit();\n-                assert!(tester.capacity() <= cap);\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n-                assert_eq!(tester, expected);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        // This test checks that every single combination of tail position, length, and\n-        // split position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-        // len is the length *before* splitting\n-        for len in 0..cap {\n-            // index to split at\n-            for at in 0..=len {\n-                // 0, 1, 2, .., at - 1 (may be empty)\n-                let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n-                // at, at + 1, .., len - 1 (may be empty)\n-                let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n-\n-                for tail_pos in 0..cap {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        tester.push_back(i);\n-                    }\n-                    let result = tester.split_off(at);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert!(result.tail < result.cap());\n-                    assert!(result.head < result.cap());\n-                    assert_eq!(tester, expected_self);\n-                    assert_eq!(result, expected_other);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        use crate::vec::Vec;\n-        for cap in 0..35 {\n-            for len in 0..=cap {\n-                let mut vec = Vec::with_capacity(cap);\n-                vec.extend(0..len);\n-\n-                let vd = VecDeque::from(vec.clone());\n-                assert!(vd.cap().is_power_of_two());\n-                assert_eq!(vd.len(), vec.len());\n-                assert!(vd.into_iter().eq(vec));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_vec_from_vecdeque() {\n-        use crate::vec::Vec;\n-\n-        fn create_vec_and_test_convert(cap: usize, offset: usize, len: usize) {\n-            let mut vd = VecDeque::with_capacity(cap);\n-            for _ in 0..offset {\n-                vd.push_back(0);\n-                vd.pop_front();\n-            }\n-            vd.extend(0..len);\n-\n-            let vec: Vec<_> = Vec::from(vd.clone());\n-            assert_eq!(vec.len(), vd.len());\n-            assert!(vec.into_iter().eq(vd));\n-        }\n-\n-        #[cfg(not(miri))] // Miri is too slow\n-        let max_pwr = 7;\n-        #[cfg(miri)]\n-        let max_pwr = 5;\n-\n-        for cap_pwr in 0..max_pwr {\n-            // Make capacity as a (2^x)-1, so that the ring size is 2^x\n-            let cap = (2i32.pow(cap_pwr) - 1) as usize;\n-\n-            // In these cases there is enough free space to solve it with copies\n-            for len in 0..((cap + 1) / 2) {\n-                // Test contiguous cases\n-                for offset in 0..(cap - len) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap - len)..(cap - (len / 2)) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap - (len / 2))..cap {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-            }\n-\n-            // Now there's not (necessarily) space to straighten the ring with simple copies,\n-            // the ring will use swapping when:\n-            // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n-            //  right block size  >   free space    &&      left block size       >    free space\n-            for len in ((cap + 1) / 2)..cap {\n-                // Test contiguous cases\n-                for offset in 0..(cap - len) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap - len)..(cap - (len / 2)) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap - (len / 2))..cap {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn issue_53529() {\n-        use crate::boxed::Box;\n-\n-        let mut dst = VecDeque::new();\n-        dst.push_front(Box::new(1));\n-        dst.push_front(Box::new(2));\n-        assert_eq!(*dst.pop_back().unwrap(), 1);\n-\n-        let mut src = VecDeque::new();\n-        src.push_front(Box::new(2));\n-        dst.append(&mut src);\n-        for a in dst {\n-            assert_eq!(*a, 2);\n-        }\n-    }\n-\n-}"}, {"sha": "d25352399796e684ec503bc05ed8b1597ed48806", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,379 @@\n+use super::*;\n+\n+use ::test;\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_push_back_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::with_capacity(101);\n+    b.iter(|| {\n+        for i in 0..100 {\n+            deq.push_back(i);\n+        }\n+        deq.head = 0;\n+        deq.tail = 0;\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_push_front_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::with_capacity(101);\n+    b.iter(|| {\n+        for i in 0..100 {\n+            deq.push_front(i);\n+        }\n+        deq.head = 0;\n+        deq.tail = 0;\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_pop_back_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::<i32>::with_capacity(101);\n+\n+    b.iter(|| {\n+        deq.head = 100;\n+        deq.tail = 0;\n+        while !deq.is_empty() {\n+            test::black_box(deq.pop_back());\n+        }\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_pop_front_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::<i32>::with_capacity(101);\n+\n+    b.iter(|| {\n+        deq.head = 100;\n+        deq.tail = 0;\n+        while !deq.is_empty() {\n+            test::black_box(deq.pop_front());\n+        }\n+    })\n+}\n+\n+#[test]\n+fn test_swap_front_back_remove() {\n+    fn test(back: bool) {\n+        // This test checks that every single combination of tail position and length is tested.\n+        // Capacity 15 should be large enough to cover every case.\n+        let mut tester = VecDeque::with_capacity(15);\n+        let usable_cap = tester.capacity();\n+        let final_len = usable_cap / 2;\n+\n+        for len in 0..final_len {\n+            let expected: VecDeque<_> = if back {\n+                (0..len).collect()\n+            } else {\n+                (0..len).rev().collect()\n+            };\n+            for tail_pos in 0..usable_cap {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                if back {\n+                    for i in 0..len * 2 {\n+                        tester.push_front(i);\n+                    }\n+                    for i in 0..len {\n+                        assert_eq!(tester.swap_remove_back(i), Some(len * 2 - 1 - i));\n+                    }\n+                } else {\n+                    for i in 0..len * 2 {\n+                        tester.push_back(i);\n+                    }\n+                    for i in 0..len {\n+                        let idx = tester.len() - 1 - i;\n+                        assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n+                    }\n+                }\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+    test(true);\n+    test(false);\n+}\n+\n+#[test]\n+fn test_insert() {\n+    // This test checks that every single combination of tail position, length, and\n+    // insertion position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+\n+    // len is the length *after* insertion\n+    for len in 1..cap {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..cap {\n+            for to_insert in 0..len {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    if i != to_insert {\n+                        tester.push_back(i);\n+                    }\n+                }\n+                tester.insert(to_insert, to_insert);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_remove() {\n+    // This test checks that every single combination of tail position, length, and\n+    // removal position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+    // len is the length *after* removal\n+    for len in 0..cap - 1 {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..cap {\n+            for to_remove in 0..=len {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    if i == to_remove {\n+                        tester.push_back(1234);\n+                    }\n+                    tester.push_back(i);\n+                }\n+                if to_remove == len {\n+                    tester.push_back(1234);\n+                }\n+                tester.remove(to_remove);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_drain() {\n+    let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n+\n+    let cap = tester.capacity();\n+    for len in 0..=cap {\n+        for tail in 0..=cap {\n+            for drain_start in 0..=len {\n+                for drain_end in drain_start..=len {\n+                    tester.tail = tail;\n+                    tester.head = tail;\n+                    for i in 0..len {\n+                        tester.push_back(i);\n+                    }\n+\n+                    // Check that we drain the correct values\n+                    let drained: VecDeque<_> = tester.drain(drain_start..drain_end).collect();\n+                    let drained_expected: VecDeque<_> = (drain_start..drain_end).collect();\n+                    assert_eq!(drained, drained_expected);\n+\n+                    // We shouldn't have changed the capacity or made the\n+                    // head or tail out of bounds\n+                    assert_eq!(tester.capacity(), cap);\n+                    assert!(tester.tail < tester.cap());\n+                    assert!(tester.head < tester.cap());\n+\n+                    // We should see the correct values in the VecDeque\n+                    let expected: VecDeque<_> = (0..drain_start)\n+                        .chain(drain_end..len)\n+                        .collect();\n+                    assert_eq!(expected, tester);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_shrink_to_fit() {\n+    // This test checks that every single combination of head and tail position,\n+    // is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+    tester.reserve(63);\n+    let max_cap = tester.capacity();\n+\n+    for len in 0..=cap {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..=max_cap {\n+            tester.tail = tail_pos;\n+            tester.head = tail_pos;\n+            tester.reserve(63);\n+            for i in 0..len {\n+                tester.push_back(i);\n+            }\n+            tester.shrink_to_fit();\n+            assert!(tester.capacity() <= cap);\n+            assert!(tester.tail < tester.cap());\n+            assert!(tester.head < tester.cap());\n+            assert_eq!(tester, expected);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_split_off() {\n+    // This test checks that every single combination of tail position, length, and\n+    // split position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+    // len is the length *before* splitting\n+    for len in 0..cap {\n+        // index to split at\n+        for at in 0..=len {\n+            // 0, 1, 2, .., at - 1 (may be empty)\n+            let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n+            // at, at + 1, .., len - 1 (may be empty)\n+            let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n+\n+            for tail_pos in 0..cap {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    tester.push_back(i);\n+                }\n+                let result = tester.split_off(at);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert!(result.tail < result.cap());\n+                assert!(result.head < result.cap());\n+                assert_eq!(tester, expected_self);\n+                assert_eq!(result, expected_other);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    use crate::vec::Vec;\n+    for cap in 0..35 {\n+        for len in 0..=cap {\n+            let mut vec = Vec::with_capacity(cap);\n+            vec.extend(0..len);\n+\n+            let vd = VecDeque::from(vec.clone());\n+            assert!(vd.cap().is_power_of_two());\n+            assert_eq!(vd.len(), vec.len());\n+            assert!(vd.into_iter().eq(vec));\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_vec_from_vecdeque() {\n+    use crate::vec::Vec;\n+\n+    fn create_vec_and_test_convert(capacity: usize, offset: usize, len: usize) {\n+        let mut vd = VecDeque::with_capacity(capacity);\n+        for _ in 0..offset {\n+            vd.push_back(0);\n+            vd.pop_front();\n+        }\n+        vd.extend(0..len);\n+\n+        let vec: Vec<_> = Vec::from(vd.clone());\n+        assert_eq!(vec.len(), vd.len());\n+        assert!(vec.into_iter().eq(vd));\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    let max_pwr = 7;\n+    #[cfg(miri)]\n+    let max_pwr = 5;\n+\n+    for cap_pwr in 0..max_pwr {\n+        // Make capacity as a (2^x)-1, so that the ring size is 2^x\n+        let cap = (2i32.pow(cap_pwr) - 1) as usize;\n+\n+        // In these cases there is enough free space to solve it with copies\n+        for len in 0..((cap + 1) / 2) {\n+            // Test contiguous cases\n+            for offset in 0..(cap - len) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at end of buffer is bigger than block at start\n+            for offset in (cap - len)..(cap - (len / 2)) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at start of buffer is bigger than block at end\n+            for offset in (cap - (len / 2))..cap {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+        }\n+\n+        // Now there's not (necessarily) space to straighten the ring with simple copies,\n+        // the ring will use swapping when:\n+        // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n+        //  right block size  >   free space    &&      left block size       >    free space\n+        for len in ((cap + 1) / 2)..cap {\n+            // Test contiguous cases\n+            for offset in 0..(cap - len) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at end of buffer is bigger than block at start\n+            for offset in (cap - len)..(cap - (len / 2)) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at start of buffer is bigger than block at end\n+            for offset in (cap - (len / 2))..cap {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn issue_53529() {\n+    use crate::boxed::Box;\n+\n+    let mut dst = VecDeque::new();\n+    dst.push_front(Box::new(1));\n+    dst.push_front(Box::new(2));\n+    assert_eq!(*dst.pop_back().unwrap(), 1);\n+\n+    let mut src = VecDeque::new();\n+    src.push_front(Box::new(2));\n+    dst.append(&mut src);\n+    for a in dst {\n+        assert_eq!(*a, 2);\n+    }\n+}"}, {"sha": "4a48945adc37a4bf313a00fe38cd06fce4296d0f", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -10,30 +10,30 @@\n //!\n //! ## Boxed values\n //!\n-//! The [`Box`](boxed/index.html) type is a smart pointer type. There can\n-//! only be one owner of a `Box`, and the owner can decide to mutate the\n-//! contents, which live on the heap.\n+//! The [`Box`] type is a smart pointer type. There can only be one owner of a\n+//! [`Box`], and the owner can decide to mutate the contents, which live on the\n+//! heap.\n //!\n //! This type can be sent among threads efficiently as the size of a `Box` value\n //! is the same as that of a pointer. Tree-like data structures are often built\n //! with boxes because each node often has only one owner, the parent.\n //!\n //! ## Reference counted pointers\n //!\n-//! The [`Rc`](rc/index.html) type is a non-threadsafe reference-counted pointer\n-//! type intended for sharing memory within a thread. An `Rc` pointer wraps a\n-//! type, `T`, and only allows access to `&T`, a shared reference.\n+//! The [`Rc`] type is a non-threadsafe reference-counted pointer type intended\n+//! for sharing memory within a thread. An [`Rc`] pointer wraps a type, `T`, and\n+//! only allows access to `&T`, a shared reference.\n //!\n-//! This type is useful when inherited mutability (such as using `Box`) is too\n-//! constraining for an application, and is often paired with the `Cell` or\n-//! `RefCell` types in order to allow mutation.\n+//! This type is useful when inherited mutability (such as using [`Box`]) is too\n+//! constraining for an application, and is often paired with the [`Cell`] or\n+//! [`RefCell`] types in order to allow mutation.\n //!\n //! ## Atomically reference counted pointers\n //!\n-//! The [`Arc`](sync/index.html) type is the threadsafe equivalent of the `Rc`\n-//! type. It provides all the same functionality of `Rc`, except it requires\n-//! that the contained type `T` is shareable. Additionally, `Arc<T>` is itself\n-//! sendable while `Rc<T>` is not.\n+//! The [`Arc`] type is the threadsafe equivalent of the [`Rc`] type. It\n+//! provides all the same functionality of [`Rc`], except it requires that the\n+//! contained type `T` is shareable. Additionally, [`Arc<T>`][`Arc`] is itself\n+//! sendable while [`Rc<T>`][`Rc`] is not.\n //!\n //! This type allows for shared access to the contained data, and is often\n //! paired with synchronization primitives such as mutexes to allow mutation of\n@@ -49,6 +49,12 @@\n //!\n //! The [`alloc`](alloc/index.html) module defines the low-level interface to the\n //! default global allocator. It is not compatible with the libc allocator API.\n+//!\n+//! [`Arc`]: sync/index.html\n+//! [`Box`]: boxed/index.html\n+//! [`Cell`]: ../core/cell/index.html\n+//! [`Rc`]: rc/index.html\n+//! [`RefCell`]: ../core/cell/index.html\n \n #![allow(unused_attributes)]\n #![stable(feature = \"alloc\", since = \"1.36.0\")]\n@@ -62,9 +68,8 @@\n #![warn(missing_docs)]\n #![warn(missing_debug_implementations)]\n #![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n-\n-#![deny(rust_2018_idioms)]\n #![allow(explicit_outlives_requirements)]\n+#![allow(incomplete_features)]\n \n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n@@ -77,14 +82,18 @@\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n+#![feature(const_generic_impls_guard)]\n+#![feature(const_generics)]\n+#![feature(const_in_array_repeat_expressions)]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n-#![feature(custom_attribute)]\n+#![feature(container_error_extra)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n #![feature(fundamental)]\n+#![feature(internal_uninit_const)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(nll)]\n@@ -94,6 +103,7 @@\n #![feature(ptr_offset_from)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n+#![feature(slice_from_raw_parts)]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n@@ -109,10 +119,11 @@\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_extra, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n-#![feature(iter_nth_back)]\n+#![feature(mem_take)]\n+#![feature(associated_type_bounds)]\n \n // Allow testing this library\n \n@@ -142,7 +153,7 @@ mod boxed {\n     pub use std::boxed::Box;\n }\n #[cfg(test)]\n-mod boxed_test;\n+mod tests;\n pub mod collections;\n #[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n pub mod sync;"}, {"sha": "0b5e186d4c77b17c5ae683437df783fea53bd320", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -42,7 +42,7 @@ macro_rules! vec {\n     ($($x:expr),*) => (\n         <[_]>::into_vec(box [$($x),*])\n     );\n-    ($($x:expr,)*) => (vec![$($x),*])\n+    ($($x:expr,)*) => ($crate::vec![$($x),*])\n }\n \n // HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is\n@@ -98,5 +98,5 @@ macro_rules! vec {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! format {\n-    ($($arg:tt)*) => ($crate::fmt::format(format_args!($($arg)*)))\n+    ($($arg:tt)*) => ($crate::fmt::format(::core::format_args!($($arg)*)))\n }"}, {"sha": "3cb285bf0492f5ccf32252c89547bbe6f6232866", "filename": "src/liballoc/prelude/v1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fv1.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -6,6 +6,5 @@\n \n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::borrow::ToOwned;\n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::boxed::Box;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::slice::SliceConcatExt;\n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::string::{String, ToString};\n #[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::vec::Vec;"}, {"sha": "bc8a38f6b3aad530a9a0eb95d826f1696cd9d8e5", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 81, "deletions": 152, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -7,10 +7,13 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use crate::alloc::{Alloc, Layout, Global, handle_alloc_error};\n-use crate::collections::CollectionAllocErr::{self, *};\n+use crate::alloc::{Alloc, Layout, Global, AllocErr, handle_alloc_error};\n+use crate::collections::TryReserveError::{self, *};\n use crate::boxed::Box;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n@@ -34,7 +37,7 @@ use crate::boxed::Box;\n /// that might occur with zero-sized types.\n ///\n /// However this means that you need to be careful when round-tripping this type\n-/// with a `Box<[T]>`: `cap()` won't yield the len. However `with_capacity`,\n+/// with a `Box<[T]>`: `capacity()` won't yield the len. However `with_capacity`,\n /// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n@@ -65,25 +68,25 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Like `with_capacity` but parameterized over the choice of\n     /// allocator for the returned RawVec.\n     #[inline]\n-    pub fn with_capacity_in(cap: usize, a: A) -> Self {\n-        RawVec::allocate_in(cap, false, a)\n+    pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n+        RawVec::allocate_in(capacity, false, a)\n     }\n \n     /// Like `with_capacity_zeroed` but parameterized over the choice\n     /// of allocator for the returned RawVec.\n     #[inline]\n-    pub fn with_capacity_zeroed_in(cap: usize, a: A) -> Self {\n-        RawVec::allocate_in(cap, true, a)\n+    pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n+        RawVec::allocate_in(capacity, true, a)\n     }\n \n-    fn allocate_in(cap: usize, zeroed: bool, mut a: A) -> Self {\n+    fn allocate_in(capacity: usize, zeroed: bool, mut a: A) -> Self {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n-            let alloc_size = cap.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n+            let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n             alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n \n-            // handles ZSTs and `cap = 0` alike\n+            // handles ZSTs and `capacity = 0` alike\n             let ptr = if alloc_size == 0 {\n                 NonNull::<T>::dangling()\n             } else {\n@@ -102,7 +105,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             RawVec {\n                 ptr: ptr.into(),\n-                cap,\n+                cap: capacity,\n                 a,\n             }\n         }\n@@ -120,8 +123,8 @@ impl<T> RawVec<T, Global> {\n     }\n \n     /// Creates a RawVec (on the system heap) with exactly the\n-    /// capacity and alignment requirements for a `[T; cap]`. This is\n-    /// equivalent to calling RawVec::new when `cap` is 0 or T is\n+    /// capacity and alignment requirements for a `[T; capacity]`. This is\n+    /// equivalent to calling RawVec::new when `capacity` is 0 or T is\n     /// zero-sized. Note that if `T` is zero-sized this means you will\n     /// *not* get a RawVec with the requested capacity!\n     ///\n@@ -135,14 +138,14 @@ impl<T> RawVec<T, Global> {\n     ///\n     /// Aborts on OOM\n     #[inline]\n-    pub fn with_capacity(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, false, Global)\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        RawVec::allocate_in(capacity, false, Global)\n     }\n \n     /// Like `with_capacity` but guarantees the buffer is zeroed.\n     #[inline]\n-    pub fn with_capacity_zeroed(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, true, Global)\n+    pub fn with_capacity_zeroed(capacity: usize) -> Self {\n+        RawVec::allocate_in(capacity, true, Global)\n     }\n }\n \n@@ -154,10 +157,10 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// The ptr must be allocated (via the given allocator `a`), and with the given capacity. The\n     /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n     /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n-    pub unsafe fn from_raw_parts_in(ptr: *mut T, cap: usize, a: A) -> Self {\n+    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n-            cap,\n+            cap: capacity,\n             a,\n         }\n     }\n@@ -171,10 +174,10 @@ impl<T> RawVec<T, Global> {\n     /// The ptr must be allocated (on the system heap), and with the given capacity. The\n     /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n     /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n-    pub unsafe fn from_raw_parts(ptr: *mut T, cap: usize) -> Self {\n+    pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n-            cap,\n+            cap: capacity,\n             a: Global,\n         }\n     }\n@@ -191,7 +194,7 @@ impl<T> RawVec<T, Global> {\n \n impl<T, A: Alloc> RawVec<T, A> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// Unique::empty() if `cap = 0` or T is zero-sized. In the former case, you must\n+    /// Unique::empty() if `capacity = 0` or T is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n         self.ptr.as_ptr()\n@@ -201,7 +204,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// This will always be `usize::MAX` if `T` is zero-sized.\n     #[inline(always)]\n-    pub fn cap(&self) -> usize {\n+    pub fn capacity(&self) -> usize {\n         if mem::size_of::<T>() == 0 {\n             !0\n         } else {\n@@ -240,7 +243,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// This function is ideal for when pushing elements one-at-a-time because\n     /// you don't need to incur the costs of the more general computations\n     /// reserve needs to do to guard against overflow. You do however need to\n-    /// manually check if your `len == cap`.\n+    /// manually check if your `len == capacity`.\n     ///\n     /// # Panics\n     ///\n@@ -267,7 +270,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// impl<T> MyVec<T> {\n     ///     pub fn push(&mut self, elem: T) {\n-    ///         if self.len == self.buf.cap() { self.buf.double(); }\n+    ///         if self.len == self.buf.capacity() { self.buf.double(); }\n     ///         // double would have aborted or panicked if the len exceeded\n     ///         // `isize::MAX` so this is safe to do unchecked now.\n     ///         unsafe {\n@@ -381,20 +384,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n \n     /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n-           -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n+           -> Result<(), TryReserveError> {\n \n-        self.reserve_internal(used_cap, needed_extra_cap, Fallible, Exact)\n+        self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Exact)\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n     /// will reallocate the minimum possible amount of memory necessary.\n     /// Generally this will be exactly the amount of memory necessary,\n     /// but in principle the allocator is free to give back more than\n     /// we asked for.\n     ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n@@ -407,41 +410,42 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM\n-    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        match self.reserve_internal(used_cap, needed_extra_cap, Infallible, Exact) {\n+    pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n+        match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => unreachable!(),\n+            Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n \n-    /// Calculates the buffer's new size given that it'll hold `used_cap +\n-    /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n+    /// Calculates the buffer's new size given that it'll hold `used_capacity +\n+    /// needed_extra_capacity` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize)\n-        -> Result<usize, CollectionAllocErr> {\n+    fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n+        -> Result<usize, TryReserveError> {\n \n         // Nothing we can really do about these checks :(\n-        let required_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n+        let required_cap = used_capacity.checked_add(needed_extra_capacity)\n+            .ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth.\n         Ok(cmp::max(double_cap, required_cap))\n     }\n \n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n-        -> Result<(), CollectionAllocErr> {\n-        self.reserve_internal(used_cap, needed_extra_cap, Fallible, Amortized)\n+    pub fn try_reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n+        -> Result<(), TryReserveError> {\n+        self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Amortized)\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n     /// space to get amortized `O(1)` behavior. Will limit this behavior\n     /// if it would needlessly cause itself to panic.\n     ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n@@ -487,20 +491,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        match self.reserve_internal(used_cap, needed_extra_cap, Infallible, Amortized) {\n+    pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n+        match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Amortized) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => unreachable!(),\n+            Err(AllocError { .. }) => unreachable!(),\n             Ok(()) => { /* yay */ }\n         }\n     }\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n     /// space to get amortized `O(1)` behavior. Will limit this behaviour\n     /// if it would needlessly cause itself to panic.\n     ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n@@ -511,7 +515,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n-    pub fn reserve_in_place(&mut self, used_cap: usize, needed_extra_cap: usize) -> bool {\n+    pub fn reserve_in_place(&mut self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n@@ -520,20 +524,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Don't actually need any more capacity. If the current `cap` is 0, we can't\n             // reallocate in place.\n-            // Wrapping in case they give a bad `used_cap`\n+            // Wrapping in case they give a bad `used_capacity`\n             let old_layout = match self.current_layout() {\n                 Some(layout) => layout,\n                 None => return false,\n             };\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+            if self.capacity().wrapping_sub(used_capacity) >= needed_extra_capacity {\n                 return false;\n             }\n \n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)\n+            let new_cap = self.amortized_new_size(used_capacity, needed_extra_capacity)\n                 .unwrap_or_else(|_| capacity_overflow());\n \n-            // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n-            // (regardless of whether `self.cap - used_cap` wrapped).\n+            // Here, `cap < used_capacity + needed_extra_capacity <= new_cap`\n+            // (regardless of whether `self.cap - used_capacity` wrapped).\n             // Therefore we can safely call grow_in_place.\n \n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n@@ -632,29 +636,27 @@ use ReserveStrategy::*;\n impl<T, A: Alloc> RawVec<T, A> {\n     fn reserve_internal(\n         &mut self,\n-        used_cap: usize,\n-        needed_extra_cap: usize,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n         fallibility: Fallibility,\n         strategy: ReserveStrategy,\n-    ) -> Result<(), CollectionAllocErr> {\n+    ) -> Result<(), TryReserveError> {\n         unsafe {\n-            use crate::alloc::AllocErr;\n-\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n             // If we make it past the first branch then we are guaranteed to\n             // panic.\n \n             // Don't actually need any more capacity.\n-            // Wrapping in case they gave a bad `used_cap`.\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+            // Wrapping in case they gave a bad `used_capacity`.\n+            if self.capacity().wrapping_sub(used_capacity) >= needed_extra_capacity {\n                 return Ok(());\n             }\n \n             // Nothing we can really do about these checks :(\n             let new_cap = match strategy {\n-                Exact => used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?,\n-                Amortized => self.amortized_new_size(used_cap, needed_extra_cap)?,\n+                Exact => used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?,\n+                Amortized => self.amortized_new_size(used_capacity, needed_extra_capacity)?,\n             };\n             let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n \n@@ -668,12 +670,16 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 None => self.a.alloc(new_layout),\n             };\n \n-            match (&res, fallibility) {\n+            let ptr = match (res, fallibility) {\n                 (Err(AllocErr), Infallible) => handle_alloc_error(new_layout),\n-                _ => {}\n-            }\n+                (Err(AllocErr), Fallible) => return Err(TryReserveError::AllocError {\n+                    layout: new_layout,\n+                    non_exhaustive: (),\n+                }),\n+                (Ok(ptr), _) => ptr,\n+            };\n \n-            self.ptr = res?.cast().into();\n+            self.ptr = ptr.cast().into();\n             self.cap = new_cap;\n \n             Ok(())\n@@ -685,14 +691,16 @@ impl<T, A: Alloc> RawVec<T, A> {\n impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n-    /// While it is not *strictly* Undefined Behavior to call\n-    /// this procedure while some of the RawVec is uninitialized,\n-    /// it certainly makes it trivial to trigger it.\n-    ///\n     /// Note that this will correctly reconstitute any `cap` changes\n     /// that may have been performed. (see description of type for details)\n+    ///\n+    /// # Undefined Behavior\n+    ///\n+    /// All elements of `RawVec<T, Global>` must be initialized. Notice that\n+    /// the rules around uninitialized boxed values are not finalized yet,\n+    /// but until they are, it is advisable to avoid them.\n     pub unsafe fn into_box(self) -> Box<[T]> {\n-        // NOTE: not calling `cap()` here, actually using the real `cap` field!\n+        // NOTE: not calling `capacity()` here, actually using the real `cap` field!\n         let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n         let output: Box<[T]> = Box::from_raw(slice);\n         mem::forget(self);\n@@ -731,7 +739,7 @@ unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n // all 4GB in user-space. e.g., PAE or x32\n \n #[inline]\n-fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n+fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n     if mem::size_of::<usize>() < 8 && alloc_size > core::isize::MAX as usize {\n         Err(CapacityOverflow)\n     } else {\n@@ -745,82 +753,3 @@ fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n fn capacity_overflow() -> ! {\n     panic!(\"capacity overflow\")\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn allocator_param() {\n-        use crate::alloc::AllocErr;\n-\n-        // Writing a test of integration between third-party\n-        // allocators and RawVec is a little tricky because the RawVec\n-        // API does not expose fallible allocation methods, so we\n-        // cannot check what happens when allocator is exhausted\n-        // (beyond detecting a panic).\n-        //\n-        // Instead, this just checks that the RawVec methods do at\n-        // least go through the Allocator API when it reserves\n-        // storage.\n-\n-        // A dumb allocator that consumes a fixed amount of fuel\n-        // before allocation attempts start failing.\n-        struct BoundedAlloc { fuel: usize }\n-        unsafe impl Alloc for BoundedAlloc {\n-            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-                let size = layout.size();\n-                if size > self.fuel {\n-                    return Err(AllocErr);\n-                }\n-                match Global.alloc(layout) {\n-                    ok @ Ok(_) => { self.fuel -= size; ok }\n-                    err @ Err(_) => err,\n-                }\n-            }\n-            unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-                Global.dealloc(ptr, layout)\n-            }\n-        }\n-\n-        let a = BoundedAlloc { fuel: 500 };\n-        let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n-        assert_eq!(v.a.fuel, 450);\n-        v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n-        assert_eq!(v.a.fuel, 250);\n-    }\n-\n-    #[test]\n-    fn reserve_does_not_overallocate() {\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            // First `reserve` allocates like `reserve_exact`\n-            v.reserve(0, 9);\n-            assert_eq!(9, v.cap());\n-        }\n-\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            v.reserve(0, 7);\n-            assert_eq!(7, v.cap());\n-            // 97 if more than double of 7, so `reserve` should work\n-            // like `reserve_exact`.\n-            v.reserve(7, 90);\n-            assert_eq!(97, v.cap());\n-        }\n-\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            v.reserve(0, 12);\n-            assert_eq!(12, v.cap());\n-            v.reserve(12, 3);\n-            // 3 is less than half of 12, so `reserve` must grow\n-            // exponentially. At the time of writing this test grow\n-            // factor is 2, so new capacity is 24, however, grow factor\n-            // of 1.5 is OK too. Hence `>= 18` in assert.\n-            assert!(v.cap() >= 12 + 12 / 2);\n-        }\n-    }\n-\n-\n-}"}, {"sha": "c389898d1ef0450c3bdf3f168b45fbb40e71e089", "filename": "src/liballoc/raw_vec/tests.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,73 @@\n+use super::*;\n+\n+#[test]\n+fn allocator_param() {\n+    use crate::alloc::AllocErr;\n+\n+    // Writing a test of integration between third-party\n+    // allocators and RawVec is a little tricky because the RawVec\n+    // API does not expose fallible allocation methods, so we\n+    // cannot check what happens when allocator is exhausted\n+    // (beyond detecting a panic).\n+    //\n+    // Instead, this just checks that the RawVec methods do at\n+    // least go through the Allocator API when it reserves\n+    // storage.\n+\n+    // A dumb allocator that consumes a fixed amount of fuel\n+    // before allocation attempts start failing.\n+    struct BoundedAlloc { fuel: usize }\n+    unsafe impl Alloc for BoundedAlloc {\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+            let size = layout.size();\n+            if size > self.fuel {\n+                return Err(AllocErr);\n+            }\n+            match Global.alloc(layout) {\n+                ok @ Ok(_) => { self.fuel -= size; ok }\n+                err @ Err(_) => err,\n+            }\n+        }\n+        unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+            Global.dealloc(ptr, layout)\n+        }\n+    }\n+\n+    let a = BoundedAlloc { fuel: 500 };\n+    let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n+    assert_eq!(v.a.fuel, 450);\n+    v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n+    assert_eq!(v.a.fuel, 250);\n+}\n+\n+#[test]\n+fn reserve_does_not_overallocate() {\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        // First `reserve` allocates like `reserve_exact`\n+        v.reserve(0, 9);\n+        assert_eq!(9, v.capacity());\n+    }\n+\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        v.reserve(0, 7);\n+        assert_eq!(7, v.capacity());\n+        // 97 if more than double of 7, so `reserve` should work\n+        // like `reserve_exact`.\n+        v.reserve(7, 90);\n+        assert_eq!(97, v.capacity());\n+    }\n+\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        v.reserve(0, 12);\n+        assert_eq!(12, v.capacity());\n+        v.reserve(12, 3);\n+        // 3 is less than half of 12, so `reserve` must grow\n+        // exponentially. At the time of writing this test grow\n+        // factor is 2, so new capacity is 24, however, grow factor\n+        // of 1.5 is OK too. Hence `>= 18` in assert.\n+        assert!(v.capacity() >= 12 + 12 / 2);\n+    }\n+}"}, {"sha": "2b222caf13f3d48c3333aa35ff78a01e1ced57b1", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 602, "deletions": 527, "changes": 1129, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -232,25 +232,30 @@ use crate::boxed::Box;\n use std::boxed::Box;\n \n use core::any::Any;\n+use core::array::LengthAtMost32;\n use core::borrow;\n use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n+use core::iter;\n use core::marker::{self, Unpin, Unsize, PhantomData};\n-use core::mem::{self, align_of_val, forget, size_of_val};\n+use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::from_raw_parts_mut;\n-use core::convert::From;\n+use core::slice::{self, from_raw_parts_mut};\n+use core::convert::{From, TryFrom};\n use core::usize;\n \n use crate::alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use crate::string::String;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n     weak: Cell<usize>,\n@@ -286,6 +291,19 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T> {}\n \n+impl<T: ?Sized> Rc<T> {\n+    fn from_inner(ptr: NonNull<RcBox<T>>) -> Self {\n+        Self {\n+            ptr,\n+            phantom: PhantomData,\n+        }\n+    }\n+\n+    unsafe fn from_ptr(ptr: *mut RcBox<T>) -> Self {\n+        Self::from_inner(NonNull::new_unchecked(ptr))\n+    }\n+}\n+\n impl<T> Rc<T> {\n     /// Constructs a new `Rc<T>`.\n     ///\n@@ -298,17 +316,45 @@ impl<T> Rc<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Rc<T> {\n-        Rc {\n-            // there is an implicit weak pointer owned by all the strong\n-            // pointers, which ensures that the weak destructor never frees\n-            // the allocation while the strong destructor is running, even\n-            // if the weak pointer is stored inside the strong one.\n-            ptr: Box::into_raw_non_null(box RcBox {\n-                strong: Cell::new(1),\n-                weak: Cell::new(1),\n-                value,\n-            }),\n-            phantom: PhantomData,\n+        // There is an implicit weak pointer owned by all the strong\n+        // pointers, which ensures that the weak destructor never frees\n+        // the allocation while the strong destructor is running, even\n+        // if the weak pointer is stored inside the strong one.\n+        Self::from_inner(Box::into_raw_non_null(box RcBox {\n+            strong: Cell::new(1),\n+            weak: Cell::new(1),\n+            value,\n+        }))\n+    }\n+\n+    /// Constructs a new `Rc` with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |mem| mem as *mut RcBox<mem::MaybeUninit<T>>,\n+            ))\n         }\n     }\n \n@@ -362,6 +408,118 @@ impl<T> Rc<T> {\n     }\n }\n \n+impl<T> Rc<[T]> {\n+    /// Constructs a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Rc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Rc::from_ptr(Rc::allocate_for_slice(len))\n+        }\n+    }\n+}\n+\n+impl<T> Rc<mem::MaybeUninit<T>> {\n+    /// Converts to `Rc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<T> {\n+        Rc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+    }\n+}\n+\n+impl<T> Rc<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Rc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut values = Rc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Rc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Rc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Rc<[T]> {\n+        Rc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+    }\n+}\n+\n impl<T: ?Sized> Rc<T> {\n     /// Consumes the `Rc`, returning the wrapped pointer.\n     ///\n@@ -375,9 +533,9 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let x = Rc::new(10);\n+    /// let x = Rc::new(\"hello\".to_owned());\n     /// let x_ptr = Rc::into_raw(x);\n-    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n@@ -401,13 +559,13 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let x = Rc::new(10);\n+    /// let x = Rc::new(\"hello\".to_owned());\n     /// let x_ptr = Rc::into_raw(x);\n     ///\n     /// unsafe {\n     ///     // Convert back to an `Rc` to prevent leak.\n     ///     let x = Rc::from_raw(x_ptr);\n-    ///     assert_eq!(*x, 10);\n+    ///     assert_eq!(&*x, \"hello\");\n     ///\n     ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory unsafe.\n     /// }\n@@ -416,20 +574,13 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the RcBox.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<RcBox<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original RcBox.\n         let fake_ptr = ptr as *mut RcBox<T>;\n         let rc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n \n-        Rc {\n-            ptr: NonNull::new_unchecked(rc_ptr),\n-            phantom: PhantomData,\n-        }\n+        Self::from_ptr(rc_ptr)\n     }\n \n     /// Consumes the `Rc`, returning the wrapped pointer as `NonNull<T>`.\n@@ -441,10 +592,10 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// use std::rc::Rc;\n     ///\n-    /// let x = Rc::new(10);\n+    /// let x = Rc::new(\"hello\".to_owned());\n     /// let ptr = Rc::into_raw_non_null(x);\n-    /// let deref = unsafe { *ptr.as_ref() };\n-    /// assert_eq!(deref, 10);\n+    /// let deref = unsafe { ptr.as_ref() };\n+    /// assert_eq!(deref, \"hello\");\n     /// ```\n     #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n     #[inline]\n@@ -552,13 +703,46 @@ impl<T: ?Sized> Rc<T> {\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n             unsafe {\n-                Some(&mut this.ptr.as_mut().value)\n+                Some(Rc::get_mut_unchecked(this))\n             }\n         } else {\n             None\n         }\n     }\n \n+    /// Returns a mutable reference to the inner value,\n+    /// without any check.\n+    ///\n+    /// See also [`get_mut`], which is safe and does appropriate checks.\n+    ///\n+    /// [`get_mut`]: struct.Rc.html#method.get_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any other `Rc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// for the duration of the returned borrow.\n+    /// This is trivially the case if no such pointers exist,\n+    /// for example immediately after `Rc::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut x = Rc::new(String::new());\n+    /// unsafe {\n+    ///     Rc::get_mut_unchecked(&mut x).push_str(\"foo\")\n+    /// }\n+    /// assert_eq!(*x, \"foo\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n+    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n+        &mut this.ptr.as_mut().value\n+    }\n+\n     #[inline]\n     #[stable(feature = \"ptr_eq\", since = \"1.17.0\")]\n     /// Returns `true` if the two `Rc`s point to the same value (not\n@@ -584,15 +768,18 @@ impl<T: ?Sized> Rc<T> {\n impl<T: Clone> Rc<T> {\n     /// Makes a mutable reference into the given `Rc`.\n     ///\n-    /// If there are other `Rc` or [`Weak`][weak] pointers to the same value,\n-    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n-    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    /// If there are other `Rc` pointers to the same value, then `make_mut` will\n+    /// [`clone`] the inner value to ensure unique ownership.  This is also\n+    /// referred to as clone-on-write.\n     ///\n-    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n+    /// If there are no other `Rc` pointers to this value, then [`Weak`]\n+    /// pointers to this value will be dissassociated.\n     ///\n-    /// [weak]: struct.Weak.html\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-    /// [get_mut]: struct.Rc.html#method.get_mut\n+    /// See also [`get_mut`], which will fail rather than cloning.\n+    ///\n+    /// [`Weak`]: struct.Weak.html\n+    /// [`clone`]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [`get_mut`]: struct.Rc.html#method.get_mut\n     ///\n     /// # Examples\n     ///\n@@ -611,6 +798,23 @@ impl<T: Clone> Rc<T> {\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n+    ///\n+    /// [`Weak`] pointers will be dissassociated:\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut data = Rc::new(75);\n+    /// let weak = Rc::downgrade(&data);\n+    ///\n+    /// assert!(75 == *data);\n+    /// assert!(75 == *weak.upgrade().unwrap());\n+    ///\n+    /// *Rc::make_mut(&mut data) += 1;\n+    ///\n+    /// assert!(76 == *data);\n+    /// assert!(weak.upgrade().is_none());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn make_mut(this: &mut Self) -> &mut T {\n@@ -667,29 +871,37 @@ impl Rc<dyn Any> {\n         if (*self).is::<T>() {\n             let ptr = self.ptr.cast::<RcBox<T>>();\n             forget(self);\n-            Ok(Rc { ptr, phantom: PhantomData })\n+            Ok(Rc::from_inner(ptr))\n         } else {\n             Err(self)\n         }\n     }\n }\n \n impl<T: ?Sized> Rc<T> {\n-    // Allocates an `RcBox<T>` with sufficient space for an unsized value\n-    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n-        // Calculate layout using the given value.\n+    /// Allocates an `RcBox<T>` with sufficient space for\n+    /// a possibly-unsized value where the value has the layout provided.\n+    ///\n+    /// The function `mem_to_rcbox` is called with the data pointer\n+    /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n+    unsafe fn allocate_for_layout(\n+        value_layout: Layout,\n+        mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>\n+    ) -> *mut RcBox<T> {\n+        // Calculate layout using the given value layout.\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n         // reference (see #54908).\n         let layout = Layout::new::<RcBox<()>>()\n-            .extend(Layout::for_value(&*ptr)).unwrap().0\n+            .extend(value_layout).unwrap().0\n             .pad_to_align().unwrap();\n \n+        // Allocate for the layout.\n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n-        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut RcBox<T>;\n+        let inner = mem_to_rcbox(mem.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));\n@@ -698,6 +910,15 @@ impl<T: ?Sized> Rc<T> {\n         inner\n     }\n \n+    /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n+        // Allocate for the `RcBox<T>` using the given value.\n+        Self::allocate_for_layout(\n+            Layout::for_value(&*ptr),\n+            |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n+        )\n+    }\n+\n     fn from_box(v: Box<T>) -> Rc<T> {\n         unsafe {\n             let box_unique = Box::into_unique(v);\n@@ -715,44 +936,49 @@ impl<T: ?Sized> Rc<T> {\n             // Free the allocation without dropping its contents\n             box_free(box_unique);\n \n-            Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+            Self::from_ptr(ptr)\n         }\n     }\n }\n \n-// Sets the data pointer of a `?Sized` raw pointer.\n-//\n-// For a slice/trait object, this sets the `data` field and leaves the rest\n-// unchanged. For a sized raw pointer, this simply sets the pointer.\n+impl<T> Rc<[T]> {\n+    /// Allocates an `RcBox<[T]>` with the given length.\n+    unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n+        Self::allocate_for_layout(\n+            Layout::array::<T>(len).unwrap(),\n+            |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n+        )\n+    }\n+}\n+\n+/// Sets the data pointer of a `?Sized` raw pointer.\n+///\n+/// For a slice/trait object, this sets the `data` field and leaves the rest\n+/// unchanged. For a sized raw pointer, this simply sets the pointer.\n unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n     ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n     ptr\n }\n \n impl<T> Rc<[T]> {\n-    // Copy elements from slice into newly allocated Rc<[T]>\n-    //\n-    // Unsafe because the caller must either take ownership or bind `T: Copy`\n+    /// Copy elements from slice into newly allocated Rc<[T]>\n+    ///\n+    /// Unsafe because the caller must either take ownership or bind `T: Copy`\n     unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n-        let v_ptr = v as *const [T];\n-        let ptr = Self::allocate_for_ptr(v_ptr);\n+        let ptr = Self::allocate_for_slice(v.len());\n \n         ptr::copy_nonoverlapping(\n             v.as_ptr(),\n             &mut (*ptr).value as *mut [T] as *mut T,\n             v.len());\n \n-        Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+        Self::from_ptr(ptr)\n     }\n-}\n-\n-trait RcFromSlice<T> {\n-    fn from_slice(slice: &[T]) -> Self;\n-}\n \n-impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n-    #[inline]\n-    default fn from_slice(v: &[T]) -> Self {\n+    /// Constructs an `Rc<[T]>` from an iterator known to be of a certain size.\n+    ///\n+    /// Behavior is undefined should the size be wrong.\n+    unsafe fn from_iter_exact(iter: impl iter::Iterator<Item = T>, len: usize) -> Rc<[T]> {\n         // Panic guard while cloning T elements.\n         // In the event of a panic, elements that have been written\n         // into the new RcBox will be dropped, then the memory freed.\n@@ -769,37 +995,48 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem, self.layout.clone());\n+                    Global.dealloc(self.mem, self.layout);\n                 }\n             }\n         }\n \n-        unsafe {\n-            let v_ptr = v as *const [T];\n-            let ptr = Self::allocate_for_ptr(v_ptr);\n+        let ptr = Self::allocate_for_slice(len);\n \n-            let mem = ptr as *mut _ as *mut u8;\n-            let layout = Layout::for_value(&*ptr);\n+        let mem = ptr as *mut _ as *mut u8;\n+        let layout = Layout::for_value(&*ptr);\n \n-            // Pointer to first element\n-            let elems = &mut (*ptr).value as *mut [T] as *mut T;\n+        // Pointer to first element\n+        let elems = &mut (*ptr).value as *mut [T] as *mut T;\n \n-            let mut guard = Guard{\n-                mem: NonNull::new_unchecked(mem),\n-                elems: elems,\n-                layout: layout,\n-                n_elems: 0,\n-            };\n+        let mut guard = Guard {\n+            mem: NonNull::new_unchecked(mem),\n+            elems,\n+            layout,\n+            n_elems: 0,\n+        };\n \n-            for (i, item) in v.iter().enumerate() {\n-                ptr::write(elems.add(i), item.clone());\n-                guard.n_elems += 1;\n-            }\n+        for (i, item) in iter.enumerate() {\n+            ptr::write(elems.add(i), item);\n+            guard.n_elems += 1;\n+        }\n \n-            // All clear. Forget the guard so it doesn't free the new RcBox.\n-            forget(guard);\n+        // All clear. Forget the guard so it doesn't free the new RcBox.\n+        forget(guard);\n+\n+        Self::from_ptr(ptr)\n+    }\n+}\n \n-            Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+/// Specialization trait used for `From<&[T]>`.\n+trait RcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        unsafe {\n+            Self::from_iter_exact(v.iter().cloned(), v.len())\n         }\n     }\n }\n@@ -891,7 +1128,7 @@ impl<T: ?Sized> Clone for Rc<T> {\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n         self.inc_strong();\n-        Rc { ptr: self.ptr, phantom: PhantomData }\n+        Self::from_inner(self.ptr)\n     }\n }\n \n@@ -1197,6 +1434,114 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n     }\n }\n \n+#[unstable(feature = \"boxed_slice_try_from\", issue = \"0\")]\n+impl<T, const N: usize> TryFrom<Rc<[T]>> for Rc<[T; N]>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = Rc<[T]>;\n+\n+    fn try_from(boxed_slice: Rc<[T]>) -> Result<Self, Self::Error> {\n+        if boxed_slice.len() == N {\n+            Ok(unsafe { Rc::from_raw(Rc::into_raw(boxed_slice) as *mut [T; N]) })\n+        } else {\n+            Err(boxed_slice)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_iter\", since = \"1.37.0\")]\n+impl<T> iter::FromIterator<T> for Rc<[T]> {\n+    /// Takes each element in the `Iterator` and collects it into an `Rc<[T]>`.\n+    ///\n+    /// # Performance characteristics\n+    ///\n+    /// ## The general case\n+    ///\n+    /// In the general case, collecting into `Rc<[T]>` is done by first\n+    /// collecting into a `Vec<T>`. That is, when writing the following:\n+    ///\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// let evens: Rc<[u8]> = (0..10).filter(|&x| x % 2 == 0).collect();\n+    /// # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n+    /// ```\n+    ///\n+    /// this behaves as if we wrote:\n+    ///\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// let evens: Rc<[u8]> = (0..10).filter(|&x| x % 2 == 0)\n+    ///     .collect::<Vec<_>>() // The first set of allocations happens here.\n+    ///     .into(); // A second allocation for `Rc<[T]>` happens here.\n+    /// # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n+    /// ```\n+    ///\n+    /// This will allocate as many times as needed for constructing the `Vec<T>`\n+    /// and then it will allocate once for turning the `Vec<T>` into the `Rc<[T]>`.\n+    ///\n+    /// ## Iterators of known length\n+    ///\n+    /// When your `Iterator` implements `TrustedLen` and is of an exact size,\n+    /// a single allocation will be made for the `Rc<[T]>`. For example:\n+    ///\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// let evens: Rc<[u8]> = (0..10).collect(); // Just a single allocation happens here.\n+    /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n+    /// ```\n+    fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n+        RcFromIter::from_iter(iter.into_iter())\n+    }\n+}\n+\n+/// Specialization trait used for collecting into `Rc<[T]>`.\n+trait RcFromIter<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I: Iterator<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n+    default fn from_iter(iter: I) -> Self {\n+        iter.collect::<Vec<T>>().into()\n+    }\n+}\n+\n+impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]>  {\n+    default fn from_iter(iter: I) -> Self {\n+        // This is the case for a `TrustedLen` iterator.\n+        let (low, high) = iter.size_hint();\n+        if let Some(high) = high {\n+            debug_assert_eq!(\n+                low, high,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n+\n+            unsafe {\n+                // SAFETY: We need to ensure that the iterator has an exact length and we have.\n+                Rc::from_iter_exact(iter, low)\n+            }\n+        } else {\n+            // Fall back to normal implementation.\n+            iter.collect::<Vec<T>>().into()\n+        }\n+    }\n+}\n+\n+impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n+    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n+        // Delegate to `impl<T: Clone> From<&[T]> for Rc<[T]>`.\n+        //\n+        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n+        // which is even more performant.\n+        //\n+        // In the fall-back case we have `T: Clone`. This is still better\n+        // than the `TrustedLen` implementation as slices have a known length\n+        // and so we get to avoid calling `size_hint` and avoid the branching.\n+        iter.as_slice().into()\n+    }\n+}\n+\n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n /// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n@@ -1262,6 +1607,143 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut RcBox<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Rc::new(\"hello\".to_owned());\n+    /// let weak = Rc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(&self) -> *const T {\n+        match self.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const RcBox<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(\"hello\".to_owned());\n+    /// let weak = Rc::downgrade(&strong);\n+    /// let raw = weak.into_raw();\n+    ///\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    /// assert_eq!(\"hello\", unsafe { &*raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Rc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(self) -> *const T {\n+        let result = self.as_raw();\n+        mem::forget(self);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Rc`] and the weak count of that [`Rc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(\"hello\".to_owned());\n+    ///\n+    /// let raw_1 = Rc::downgrade(&strong).into_raw();\n+    /// let raw_2 = Rc::downgrade(&strong).into_raw();\n+    ///\n+    /// assert_eq!(2, Rc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(\"hello\", &*unsafe { Weak::from_raw(raw_1) }.upgrade().unwrap());\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Rc`]: struct.Rc.html\n+    /// [`Weak`]: struct.Weak.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Rc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut RcBox<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n@@ -1303,7 +1785,7 @@ impl<T: ?Sized> Weak<T> {\n             None\n         } else {\n             inner.inc_strong();\n-            Some(Rc { ptr: self.ptr, phantom: PhantomData })\n+            Some(Rc::from_inner(self.ptr))\n         }\n     }\n \n@@ -1362,18 +1844,18 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// ```\n     /// #![feature(weak_ptr_eq)]\n-    /// use std::rc::{Rc, Weak};\n+    /// use std::rc::Rc;\n     ///\n     /// let first_rc = Rc::new(5);\n     /// let first = Rc::downgrade(&first_rc);\n     /// let second = Rc::downgrade(&first_rc);\n     ///\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Rc::new(5);\n     /// let third = Rc::downgrade(&third_rc);\n     ///\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n     /// Comparing `Weak::new`.\n@@ -1384,16 +1866,16 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// let first = Weak::new();\n     /// let second = Weak::new();\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Rc::new(());\n     /// let third = Rc::downgrade(&third_rc);\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n     #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n-    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        this.ptr.as_ptr() == other.ptr.as_ptr()\n+    pub fn ptr_eq(&self, other: &Self) -> bool {\n+        self.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -1507,14 +1989,16 @@ trait RcBoxPtr<T: ?Sized> {\n \n     #[inline]\n     fn inc_strong(&self) {\n+        let strong = self.strong();\n+\n         // We want to abort on overflow instead of dropping the value.\n         // The reference count will never be zero when this is called;\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n-        if self.strong() == 0 || self.strong() == usize::max_value() {\n+        if strong == 0 || strong == usize::max_value() {\n             unsafe { abort(); }\n         }\n-        self.inner().strong.set(self.strong() + 1);\n+        self.inner().strong.set(strong + 1);\n     }\n \n     #[inline]\n@@ -1529,14 +2013,16 @@ trait RcBoxPtr<T: ?Sized> {\n \n     #[inline]\n     fn inc_weak(&self) {\n+        let weak = self.weak();\n+\n         // We want to abort on overflow instead of dropping the value.\n         // The reference count will never be zero when this is called;\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n-        if self.weak() == 0 || self.weak() == usize::max_value() {\n+        if weak == 0 || weak == usize::max_value() {\n             unsafe { abort(); }\n         }\n-        self.inner().weak.set(self.weak() + 1);\n+        self.inner().weak.set(weak + 1);\n     }\n \n     #[inline]\n@@ -1561,436 +2047,6 @@ impl<T: ?Sized> RcBoxPtr<T> for RcBox<T> {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use super::{Rc, Weak};\n-    use std::boxed::Box;\n-    use std::cell::RefCell;\n-    use std::option::Option::{self, None, Some};\n-    use std::result::Result::{Err, Ok};\n-    use std::mem::drop;\n-    use std::clone::Clone;\n-    use std::convert::From;\n-\n-    #[test]\n-    fn test_clone() {\n-        let x = Rc::new(RefCell::new(5));\n-        let y = x.clone();\n-        *x.borrow_mut() = 20;\n-        assert_eq!(*y.borrow(), 20);\n-    }\n-\n-    #[test]\n-    fn test_simple() {\n-        let x = Rc::new(5);\n-        assert_eq!(*x, 5);\n-    }\n-\n-    #[test]\n-    fn test_simple_clone() {\n-        let x = Rc::new(5);\n-        let y = x.clone();\n-        assert_eq!(*x, 5);\n-        assert_eq!(*y, 5);\n-    }\n-\n-    #[test]\n-    fn test_destructor() {\n-        let x: Rc<Box<_>> = Rc::new(box 5);\n-        assert_eq!(**x, 5);\n-    }\n-\n-    #[test]\n-    fn test_live() {\n-        let x = Rc::new(5);\n-        let y = Rc::downgrade(&x);\n-        assert!(y.upgrade().is_some());\n-    }\n-\n-    #[test]\n-    fn test_dead() {\n-        let x = Rc::new(5);\n-        let y = Rc::downgrade(&x);\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn weak_self_cyclic() {\n-        struct Cycle {\n-            x: RefCell<Option<Weak<Cycle>>>,\n-        }\n-\n-        let a = Rc::new(Cycle { x: RefCell::new(None) });\n-        let b = Rc::downgrade(&a.clone());\n-        *a.x.borrow_mut() = Some(b);\n-\n-        // hopefully we don't double-free (or leak)...\n-    }\n-\n-    #[test]\n-    fn is_unique() {\n-        let x = Rc::new(3);\n-        assert!(Rc::is_unique(&x));\n-        let y = x.clone();\n-        assert!(!Rc::is_unique(&x));\n-        drop(y);\n-        assert!(Rc::is_unique(&x));\n-        let w = Rc::downgrade(&x);\n-        assert!(!Rc::is_unique(&x));\n-        drop(w);\n-        assert!(Rc::is_unique(&x));\n-    }\n-\n-    #[test]\n-    fn test_strong_count() {\n-        let a = Rc::new(0);\n-        assert!(Rc::strong_count(&a) == 1);\n-        let w = Rc::downgrade(&a);\n-        assert!(Rc::strong_count(&a) == 1);\n-        let b = w.upgrade().expect(\"upgrade of live rc failed\");\n-        assert!(Rc::strong_count(&b) == 2);\n-        assert!(Rc::strong_count(&a) == 2);\n-        drop(w);\n-        drop(a);\n-        assert!(Rc::strong_count(&b) == 1);\n-        let c = b.clone();\n-        assert!(Rc::strong_count(&b) == 2);\n-        assert!(Rc::strong_count(&c) == 2);\n-    }\n-\n-    #[test]\n-    fn test_weak_count() {\n-        let a = Rc::new(0);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 0);\n-        let w = Rc::downgrade(&a);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 1);\n-        drop(w);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 0);\n-        let c = a.clone();\n-        assert!(Rc::strong_count(&a) == 2);\n-        assert!(Rc::weak_count(&a) == 0);\n-        drop(c);\n-    }\n-\n-    #[test]\n-    fn weak_counts() {\n-        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n-        assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n-\n-        let a = Rc::new(0);\n-        let w = Rc::downgrade(&a);\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(1));\n-        let w2 = w.clone();\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(2));\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(2));\n-        drop(w);\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        let a2 = a.clone();\n-        assert_eq!(Weak::strong_count(&w2), 2);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(a2);\n-        drop(a);\n-        assert_eq!(Weak::strong_count(&w2), 0);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(w2);\n-    }\n-\n-    #[test]\n-    fn try_unwrap() {\n-        let x = Rc::new(3);\n-        assert_eq!(Rc::try_unwrap(x), Ok(3));\n-        let x = Rc::new(4);\n-        let _y = x.clone();\n-        assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n-        let x = Rc::new(5);\n-        let _w = Rc::downgrade(&x);\n-        assert_eq!(Rc::try_unwrap(x), Ok(5));\n-    }\n-\n-    #[test]\n-    fn into_from_raw() {\n-        let x = Rc::new(box \"hello\");\n-        let y = x.clone();\n-\n-        let x_ptr = Rc::into_raw(x);\n-        drop(y);\n-        unsafe {\n-            assert_eq!(**x_ptr, \"hello\");\n-\n-            let x = Rc::from_raw(x_ptr);\n-            assert_eq!(**x, \"hello\");\n-\n-            assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_from_raw_unsized() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let rc: Rc<str> = Rc::from(\"foo\");\n-\n-        let ptr = Rc::into_raw(rc.clone());\n-        let rc2 = unsafe { Rc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }, \"foo\");\n-        assert_eq!(rc, rc2);\n-\n-        let rc: Rc<dyn Display> = Rc::new(123);\n-\n-        let ptr = Rc::into_raw(rc.clone());\n-        let rc2 = unsafe { Rc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n-        assert_eq!(rc2.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn get_mut() {\n-        let mut x = Rc::new(3);\n-        *Rc::get_mut(&mut x).unwrap() = 4;\n-        assert_eq!(*x, 4);\n-        let y = x.clone();\n-        assert!(Rc::get_mut(&mut x).is_none());\n-        drop(y);\n-        assert!(Rc::get_mut(&mut x).is_some());\n-        let _w = Rc::downgrade(&x);\n-        assert!(Rc::get_mut(&mut x).is_none());\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_make_unique() {\n-        let mut cow0 = Rc::new(75);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *Rc::make_mut(&mut cow0));\n-        assert!(75 == *Rc::make_mut(&mut cow1));\n-        assert!(75 == *Rc::make_mut(&mut cow2));\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-        *Rc::make_mut(&mut cow1) += 2;\n-        *Rc::make_mut(&mut cow2) += 3;\n-\n-        assert!(76 == *cow0);\n-        assert!(77 == *cow1);\n-        assert!(78 == *cow2);\n-\n-        // none should point to the same backing memory\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 != *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_unique2() {\n-        let mut cow0 = Rc::new(75);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        // cow1 and cow2 should share the same contents\n-        // cow0 should have a unique reference\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 == *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_weak() {\n-        let mut cow0 = Rc::new(75);\n-        let cow1_weak = Rc::downgrade(&cow0);\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1_weak.upgrade().unwrap());\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(cow1_weak.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let foo = Rc::new(75);\n-        assert_eq!(format!(\"{:?}\", foo), \"75\");\n-    }\n-\n-    #[test]\n-    fn test_unsized() {\n-        let foo: Rc<[i32]> = Rc::new([1, 2, 3]);\n-        assert_eq!(foo, foo.clone());\n-    }\n-\n-    #[test]\n-    fn test_from_owned() {\n-        let foo = 123;\n-        let foo_rc = Rc::from(foo);\n-        assert!(123 == *foo_rc);\n-    }\n-\n-    #[test]\n-    fn test_new_weak() {\n-        let foo: Weak<usize> = Weak::new();\n-        assert!(foo.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_ptr_eq() {\n-        let five = Rc::new(5);\n-        let same_five = five.clone();\n-        let other_five = Rc::new(5);\n-\n-        assert!(Rc::ptr_eq(&five, &same_five));\n-        assert!(!Rc::ptr_eq(&five, &other_five));\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-        let r: Rc<str> = Rc::from(\"foo\");\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_copy_from_slice() {\n-        let s: &[u32] = &[1, 2, 3];\n-        let r: Rc<[u32]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_clone_from_slice() {\n-        #[derive(Clone, Debug, Eq, PartialEq)]\n-        struct X(u32);\n-\n-        let s: &[X] = &[X(1), X(2), X(3)];\n-        let r: Rc<[X]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], s);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clone_from_slice_panic() {\n-        use std::string::{String, ToString};\n-\n-        struct Fail(u32, String);\n-\n-        impl Clone for Fail {\n-            fn clone(&self) -> Fail {\n-                if self.0 == 2 {\n-                    panic!();\n-                }\n-                Fail(self.0, self.1.clone())\n-            }\n-        }\n-\n-        let s: &[Fail] = &[\n-            Fail(0, \"foo\".to_string()),\n-            Fail(1, \"bar\".to_string()),\n-            Fail(2, \"baz\".to_string()),\n-        ];\n-\n-        // Should panic, but not cause memory corruption\n-        let _r: Rc<[Fail]> = Rc::from(s);\n-    }\n-\n-    #[test]\n-    fn test_from_box() {\n-        let b: Box<u32> = box 123;\n-        let r: Rc<u32> = Rc::from(b);\n-\n-        assert_eq!(*r, 123);\n-    }\n-\n-    #[test]\n-    fn test_from_box_str() {\n-        use std::string::String;\n-\n-        let s = String::from(\"foo\").into_boxed_str();\n-        let r: Rc<str> = Rc::from(s);\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_slice() {\n-        let s = vec![1, 2, 3].into_boxed_slice();\n-        let r: Rc<[u32]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let b: Box<dyn Display> = box 123;\n-        let r: Rc<dyn Display> = Rc::from(b);\n-\n-        assert_eq!(r.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait_zero_sized() {\n-        use std::fmt::Debug;\n-\n-        let b: Box<dyn Debug> = box ();\n-        let r: Rc<dyn Debug> = Rc::from(b);\n-\n-        assert_eq!(format!(\"{:?}\", r), \"()\");\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        let v = vec![1, 2, 3];\n-        let r: Rc<[u32]> = Rc::from(v);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_downcast() {\n-        use std::any::Any;\n-\n-        let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n-        let r2: Rc<dyn Any> = Rc::new(\"abc\");\n-\n-        assert!(r1.clone().downcast::<u32>().is_err());\n-\n-        let r1i32 = r1.downcast::<i32>();\n-        assert!(r1i32.is_ok());\n-        assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n-\n-        assert!(r2.clone().downcast::<i32>().is_err());\n-\n-        let r2str = r2.downcast::<&'static str>();\n-        assert!(r2str.is_ok());\n-        assert_eq!(r2str.unwrap(), Rc::new(\"abc\"));\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> borrow::Borrow<T> for Rc<T> {\n     fn borrow(&self) -> &T {\n@@ -2007,3 +2063,22 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> { }\n+\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the `RcBox`.\n+    // Because it is ?Sized, it will always be the last field in memory.\n+    data_offset_align(align_of_val(&*ptr))\n+}\n+\n+/// Computes the offset of the data field within `RcBox`.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    data_offset_align(align_of::<T>())\n+}\n+\n+#[inline]\n+fn data_offset_align(align: usize) -> isize {\n+    let layout = Layout::new::<RcBox<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}, {"sha": "6fd3f909357141120289b6e50bd65051636feefd", "filename": "src/liballoc/rc/tests.rs", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,439 @@\n+use super::*;\n+\n+use std::boxed::Box;\n+use std::cell::RefCell;\n+use std::option::Option::{self, None, Some};\n+use std::result::Result::{Err, Ok};\n+use std::mem::drop;\n+use std::clone::Clone;\n+use std::convert::{From, TryInto};\n+\n+#[test]\n+fn test_clone() {\n+    let x = Rc::new(RefCell::new(5));\n+    let y = x.clone();\n+    *x.borrow_mut() = 20;\n+    assert_eq!(*y.borrow(), 20);\n+}\n+\n+#[test]\n+fn test_simple() {\n+    let x = Rc::new(5);\n+    assert_eq!(*x, 5);\n+}\n+\n+#[test]\n+fn test_simple_clone() {\n+    let x = Rc::new(5);\n+    let y = x.clone();\n+    assert_eq!(*x, 5);\n+    assert_eq!(*y, 5);\n+}\n+\n+#[test]\n+fn test_destructor() {\n+    let x: Rc<Box<_>> = Rc::new(box 5);\n+    assert_eq!(**x, 5);\n+}\n+\n+#[test]\n+fn test_live() {\n+    let x = Rc::new(5);\n+    let y = Rc::downgrade(&x);\n+    assert!(y.upgrade().is_some());\n+}\n+\n+#[test]\n+fn test_dead() {\n+    let x = Rc::new(5);\n+    let y = Rc::downgrade(&x);\n+    drop(x);\n+    assert!(y.upgrade().is_none());\n+}\n+\n+#[test]\n+fn weak_self_cyclic() {\n+    struct Cycle {\n+        x: RefCell<Option<Weak<Cycle>>>,\n+    }\n+\n+    let a = Rc::new(Cycle { x: RefCell::new(None) });\n+    let b = Rc::downgrade(&a.clone());\n+    *a.x.borrow_mut() = Some(b);\n+\n+    // hopefully we don't double-free (or leak)...\n+}\n+\n+#[test]\n+fn is_unique() {\n+    let x = Rc::new(3);\n+    assert!(Rc::is_unique(&x));\n+    let y = x.clone();\n+    assert!(!Rc::is_unique(&x));\n+    drop(y);\n+    assert!(Rc::is_unique(&x));\n+    let w = Rc::downgrade(&x);\n+    assert!(!Rc::is_unique(&x));\n+    drop(w);\n+    assert!(Rc::is_unique(&x));\n+}\n+\n+#[test]\n+fn test_strong_count() {\n+    let a = Rc::new(0);\n+    assert!(Rc::strong_count(&a) == 1);\n+    let w = Rc::downgrade(&a);\n+    assert!(Rc::strong_count(&a) == 1);\n+    let b = w.upgrade().expect(\"upgrade of live rc failed\");\n+    assert!(Rc::strong_count(&b) == 2);\n+    assert!(Rc::strong_count(&a) == 2);\n+    drop(w);\n+    drop(a);\n+    assert!(Rc::strong_count(&b) == 1);\n+    let c = b.clone();\n+    assert!(Rc::strong_count(&b) == 2);\n+    assert!(Rc::strong_count(&c) == 2);\n+}\n+\n+#[test]\n+fn test_weak_count() {\n+    let a = Rc::new(0);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 0);\n+    let w = Rc::downgrade(&a);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 1);\n+    drop(w);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 0);\n+    let c = a.clone();\n+    assert!(Rc::strong_count(&a) == 2);\n+    assert!(Rc::weak_count(&a) == 0);\n+    drop(c);\n+}\n+\n+#[test]\n+fn weak_counts() {\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n+\n+    let a = Rc::new(0);\n+    let w = Rc::downgrade(&a);\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(1));\n+    let w2 = w.clone();\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    drop(w);\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    let a2 = a.clone();\n+    assert_eq!(Weak::strong_count(&w2), 2);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(a2);\n+    drop(a);\n+    assert_eq!(Weak::strong_count(&w2), 0);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(w2);\n+}\n+\n+#[test]\n+fn try_unwrap() {\n+    let x = Rc::new(3);\n+    assert_eq!(Rc::try_unwrap(x), Ok(3));\n+    let x = Rc::new(4);\n+    let _y = x.clone();\n+    assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    let x = Rc::new(5);\n+    let _w = Rc::downgrade(&x);\n+    assert_eq!(Rc::try_unwrap(x), Ok(5));\n+}\n+\n+#[test]\n+fn into_from_raw() {\n+    let x = Rc::new(box \"hello\");\n+    let y = x.clone();\n+\n+    let x_ptr = Rc::into_raw(x);\n+    drop(y);\n+    unsafe {\n+        assert_eq!(**x_ptr, \"hello\");\n+\n+        let x = Rc::from_raw(x_ptr);\n+        assert_eq!(**x, \"hello\");\n+\n+        assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+    }\n+}\n+\n+#[test]\n+fn test_into_from_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let rc: Rc<str> = Rc::from(\"foo\");\n+\n+    let ptr = Rc::into_raw(rc.clone());\n+    let rc2 = unsafe { Rc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert_eq!(rc, rc2);\n+\n+    let rc: Rc<dyn Display> = Rc::new(123);\n+\n+    let ptr = Rc::into_raw(rc.clone());\n+    let rc2 = unsafe { Rc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert_eq!(rc2.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn get_mut() {\n+    let mut x = Rc::new(3);\n+    *Rc::get_mut(&mut x).unwrap() = 4;\n+    assert_eq!(*x, 4);\n+    let y = x.clone();\n+    assert!(Rc::get_mut(&mut x).is_none());\n+    drop(y);\n+    assert!(Rc::get_mut(&mut x).is_some());\n+    let _w = Rc::downgrade(&x);\n+    assert!(Rc::get_mut(&mut x).is_none());\n+}\n+\n+#[test]\n+fn test_cowrc_clone_make_unique() {\n+    let mut cow0 = Rc::new(75);\n+    let mut cow1 = cow0.clone();\n+    let mut cow2 = cow1.clone();\n+\n+    assert!(75 == *Rc::make_mut(&mut cow0));\n+    assert!(75 == *Rc::make_mut(&mut cow1));\n+    assert!(75 == *Rc::make_mut(&mut cow2));\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+    *Rc::make_mut(&mut cow1) += 2;\n+    *Rc::make_mut(&mut cow2) += 3;\n+\n+    assert!(76 == *cow0);\n+    assert!(77 == *cow1);\n+    assert!(78 == *cow2);\n+\n+    // none should point to the same backing memory\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 != *cow2);\n+}\n+\n+#[test]\n+fn test_cowrc_clone_unique2() {\n+    let mut cow0 = Rc::new(75);\n+    let cow1 = cow0.clone();\n+    let cow2 = cow1.clone();\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    // cow1 and cow2 should share the same contents\n+    // cow0 should have a unique reference\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 == *cow2);\n+}\n+\n+#[test]\n+fn test_cowrc_clone_weak() {\n+    let mut cow0 = Rc::new(75);\n+    let cow1_weak = Rc::downgrade(&cow0);\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1_weak.upgrade().unwrap());\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(cow1_weak.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_show() {\n+    let foo = Rc::new(75);\n+    assert_eq!(format!(\"{:?}\", foo), \"75\");\n+}\n+\n+#[test]\n+fn test_unsized() {\n+    let foo: Rc<[i32]> = Rc::new([1, 2, 3]);\n+    assert_eq!(foo, foo.clone());\n+}\n+\n+#[test]\n+fn test_from_owned() {\n+    let foo = 123;\n+    let foo_rc = Rc::from(foo);\n+    assert!(123 == *foo_rc);\n+}\n+\n+#[test]\n+fn test_new_weak() {\n+    let foo: Weak<usize> = Weak::new();\n+    assert!(foo.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_ptr_eq() {\n+    let five = Rc::new(5);\n+    let same_five = five.clone();\n+    let other_five = Rc::new(5);\n+\n+    assert!(Rc::ptr_eq(&five, &same_five));\n+    assert!(!Rc::ptr_eq(&five, &other_five));\n+}\n+\n+#[test]\n+fn test_from_str() {\n+    let r: Rc<str> = Rc::from(\"foo\");\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_copy_from_slice() {\n+    let s: &[u32] = &[1, 2, 3];\n+    let r: Rc<[u32]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_clone_from_slice() {\n+    #[derive(Clone, Debug, Eq, PartialEq)]\n+    struct X(u32);\n+\n+    let s: &[X] = &[X(1), X(2), X(3)];\n+    let r: Rc<[X]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], s);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clone_from_slice_panic() {\n+    use std::string::{String, ToString};\n+\n+    struct Fail(u32, String);\n+\n+    impl Clone for Fail {\n+        fn clone(&self) -> Fail {\n+            if self.0 == 2 {\n+                panic!();\n+            }\n+            Fail(self.0, self.1.clone())\n+        }\n+    }\n+\n+    let s: &[Fail] = &[\n+        Fail(0, \"foo\".to_string()),\n+        Fail(1, \"bar\".to_string()),\n+        Fail(2, \"baz\".to_string()),\n+    ];\n+\n+    // Should panic, but not cause memory corruption\n+    let _r: Rc<[Fail]> = Rc::from(s);\n+}\n+\n+#[test]\n+fn test_from_box() {\n+    let b: Box<u32> = box 123;\n+    let r: Rc<u32> = Rc::from(b);\n+\n+    assert_eq!(*r, 123);\n+}\n+\n+#[test]\n+fn test_from_box_str() {\n+    use std::string::String;\n+\n+    let s = String::from(\"foo\").into_boxed_str();\n+    let r: Rc<str> = Rc::from(s);\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_from_box_slice() {\n+    let s = vec![1, 2, 3].into_boxed_slice();\n+    let r: Rc<[u32]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_from_box_trait() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let b: Box<dyn Display> = box 123;\n+    let r: Rc<dyn Display> = Rc::from(b);\n+\n+    assert_eq!(r.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn test_from_box_trait_zero_sized() {\n+    use std::fmt::Debug;\n+\n+    let b: Box<dyn Debug> = box ();\n+    let r: Rc<dyn Debug> = Rc::from(b);\n+\n+    assert_eq!(format!(\"{:?}\", r), \"()\");\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    let v = vec![1, 2, 3];\n+    let r: Rc<[u32]> = Rc::from(v);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_downcast() {\n+    use std::any::Any;\n+\n+    let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n+    let r2: Rc<dyn Any> = Rc::new(\"abc\");\n+\n+    assert!(r1.clone().downcast::<u32>().is_err());\n+\n+    let r1i32 = r1.downcast::<i32>();\n+    assert!(r1i32.is_ok());\n+    assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n+\n+    assert!(r2.clone().downcast::<i32>().is_err());\n+\n+    let r2str = r2.downcast::<&'static str>();\n+    assert!(r2str.is_ok());\n+    assert_eq!(r2str.unwrap(), Rc::new(\"abc\"));\n+}\n+\n+#[test]\n+fn test_array_from_slice() {\n+    let v = vec![1, 2, 3];\n+    let r: Rc<[u32]> = Rc::from(v);\n+\n+    let a: Result<Rc<[u32; 3]>, _> = r.clone().try_into();\n+    assert!(a.is_ok());\n+\n+    let a: Result<Rc<[u32; 2]>, _> = r.clone().try_into();\n+    assert!(a.is_err());\n+}"}, {"sha": "881d499c0745baf427f3e61e98281d263473b06f", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 137, "deletions": 69, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -123,12 +123,12 @@ pub use core::slice::{RChunks, RChunksMut, RChunksExact, RChunksExactMut};\n ////////////////////////////////////////////////////////////////////////////////\n \n // HACK(japaric) needed for the implementation of `vec!` macro during testing\n-// NB see the hack module in this file for more details\n+// N.B., see the `hack` module in this file for more details.\n #[cfg(test)]\n pub use hack::into_vec;\n \n // HACK(japaric) needed for the implementation of `Vec::clone` during testing\n-// NB see the hack module in this file for more details\n+// N.B., see the `hack` module in this file for more details.\n #[cfg(test)]\n pub use hack::to_vec;\n \n@@ -137,17 +137,16 @@ pub use hack::to_vec;\n // `core::slice::SliceExt` - we need to supply these functions for the\n // `test_permutations` test\n mod hack {\n-    use core::mem;\n-\n     use crate::boxed::Box;\n     use crate::vec::Vec;\n     #[cfg(test)]\n     use crate::string::ToString;\n \n-    pub fn into_vec<T>(mut b: Box<[T]>) -> Vec<T> {\n+    pub fn into_vec<T>(b: Box<[T]>) -> Vec<T> {\n         unsafe {\n-            let xs = Vec::from_raw_parts(b.as_mut_ptr(), b.len(), b.len());\n-            mem::forget(b);\n+            let len = b.len();\n+            let b = Box::into_raw(b);\n+            let xs = Vec::from_raw_parts(b as *mut T, len, len);\n             xs\n         }\n     }\n@@ -376,7 +375,7 @@ impl<T> [T] {\n     pub fn to_vec(&self) -> Vec<T>\n         where T: Clone\n     {\n-        // NB see hack module in this file\n+        // N.B., see the `hack` module in this file for more details.\n         hack::to_vec(self)\n     }\n \n@@ -397,7 +396,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn into_vec(self: Box<Self>) -> Vec<T> {\n-        // NB see hack module in this file\n+        // N.B., see the `hack` module in this file for more details.\n         hack::into_vec(self)\n     }\n \n@@ -485,6 +484,57 @@ impl<T> [T] {\n         }\n         buf\n     }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n+    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n+        where Self: Concat<Item>\n+    {\n+        Concat::concat(self)\n+    }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n+    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n+    /// assert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n+    pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n+        where Self: Join<Separator>\n+    {\n+        Join::join(self, sep)\n+    }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![allow(deprecated)]\n+    /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n+    /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n+    pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n+        where Self: Join<Separator>\n+    {\n+        Join::join(self, sep)\n+    }\n+\n }\n \n #[lang = \"slice_u8_alloc\"]\n@@ -528,85 +578,84 @@ impl [u8] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-/// An extension trait for concatenating slices\n+\n+/// Helper trait for [`[T]::concat`](../../std/primitive.slice.html#method.concat).\n ///\n-/// While this trait is unstable, the methods are stable. `SliceConcatExt` is\n-/// included in the [standard library prelude], so you can use [`join()`] and\n-/// [`concat()`] as if they existed on `[T]` itself.\n+/// Note: the `Item` type parameter is not used in this trait,\n+/// but it allows impls to be more generic.\n+/// Without it, we get this error:\n ///\n-/// [standard library prelude]: ../../std/prelude/index.html\n-/// [`join()`]: #tymethod.join\n-/// [`concat()`]: #tymethod.concat\n-pub trait SliceConcatExt<T: ?Sized> {\n-    #[unstable(feature = \"slice_concat_ext\",\n-               reason = \"trait should not have to exist\",\n-               issue = \"27747\")]\n+/// ```error\n+/// error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predica\n+///    --> src/liballoc/slice.rs:608:6\n+///     |\n+/// 608 | impl<T: Clone, V: Borrow<[T]>> Concat for [V] {\n+///     |      ^ unconstrained type parameter\n+/// ```\n+///\n+/// This is because there could exist `V` types with multiple `Borrow<[_]>` impls,\n+/// such that multiple `T` types would apply:\n+///\n+/// ```\n+/// # #[allow(dead_code)]\n+/// pub struct Foo(Vec<u32>, Vec<String>);\n+///\n+/// impl std::borrow::Borrow<[u32]> for Foo {\n+///     fn borrow(&self) -> &[u32] { &self.0 }\n+/// }\n+///\n+/// impl std::borrow::Borrow<[String]> for Foo {\n+///     fn borrow(&self) -> &[String] { &self.1 }\n+/// }\n+/// ```\n+#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+pub trait Concat<Item: ?Sized> {\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n     /// The resulting type after concatenation\n     type Output;\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n-    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn concat(&self) -> Self::Output;\n+    /// Implementation of [`[T]::concat`](../../std/primitive.slice.html#method.concat)\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    fn concat(slice: &Self) -> Self::Output;\n+}\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n-    /// given separator between each.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n-    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n-    fn join(&self, sep: &T) -> Self::Output;\n+/// Helper trait for [`[T]::join`](../../std/primitive.slice.html#method.join)\n+#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+pub trait Join<Separator> {\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    /// The resulting type after concatenation\n+    type Output;\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n-    /// given separator between each.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n-    /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n-    fn connect(&self, sep: &T) -> Self::Output;\n+    /// Implementation of [`[T]::join`](../../std/primitive.slice.html#method.join)\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    fn join(slice: &Self, sep: Separator) -> Self::Output;\n }\n \n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Concat<T> for [V] {\n     type Output = Vec<T>;\n \n-    fn concat(&self) -> Vec<T> {\n-        let size = self.iter().map(|slice| slice.borrow().len()).sum();\n+    fn concat(slice: &Self) -> Vec<T> {\n+        let size = slice.iter().map(|slice| slice.borrow().len()).sum();\n         let mut result = Vec::with_capacity(size);\n-        for v in self {\n+        for v in slice {\n             result.extend_from_slice(v.borrow())\n         }\n         result\n     }\n+}\n+\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Join<&T> for [V] {\n+    type Output = Vec<T>;\n \n-    fn join(&self, sep: &T) -> Vec<T> {\n-        let mut iter = self.iter();\n+    fn join(slice: &Self, sep: &T) -> Vec<T> {\n+        let mut iter = slice.iter();\n         let first = match iter.next() {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = self.iter().map(|slice| slice.borrow().len()).sum::<usize>() + self.len() - 1;\n+        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() + slice.len() - 1;\n         let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n \n@@ -616,9 +665,28 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n         }\n         result\n     }\n+}\n+\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n+    type Output = Vec<T>;\n+\n+    fn join(slice: &Self, sep: &[T]) -> Vec<T> {\n+        let mut iter = slice.iter();\n+        let first = match iter.next() {\n+            Some(first) => first,\n+            None => return vec![],\n+        };\n+        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() +\n+            sep.len() * (slice.len() - 1);\n+        let mut result = Vec::with_capacity(size);\n+        result.extend_from_slice(first.borrow());\n \n-    fn connect(&self, sep: &T) -> Vec<T> {\n-        self.join(sep)\n+        for v in iter {\n+            result.extend_from_slice(sep);\n+            result.extend_from_slice(v.borrow())\n+        }\n+        result\n     }\n }\n "}, {"sha": "9a1342c30d502b57130c632b4c3011faf1420f40", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -37,7 +37,7 @@ use core::unicode::conversions;\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n-use crate::slice::{SliceConcatExt, SliceIndex};\n+use crate::slice::{Concat, Join, SliceIndex};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -71,25 +71,26 @@ pub use core::str::SplitAsciiWhitespace;\n #[stable(feature = \"str_escape\", since = \"1.34.0\")]\n pub use core::str::{EscapeDebug, EscapeDefault, EscapeUnicode};\n \n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n+/// Note: `str` in `Concat<str>` is not meaningful here.\n+/// This type parameter of the trait only exists to enable another impl.\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<S: Borrow<str>> Concat<str> for [S] {\n     type Output = String;\n \n-    fn concat(&self) -> String {\n-        self.join(\"\")\n+    fn concat(slice: &Self) -> String {\n+        Join::join(slice, \"\")\n     }\n+}\n+\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<S: Borrow<str>> Join<&str> for [S] {\n+    type Output = String;\n \n-    fn join(&self, sep: &str) -> String {\n+    fn join(slice: &Self, sep: &str) -> String {\n         unsafe {\n-            String::from_utf8_unchecked( join_generic_copy(self, sep.as_bytes()) )\n+            String::from_utf8_unchecked( join_generic_copy(slice, sep.as_bytes()) )\n         }\n     }\n-\n-    fn connect(&self, sep: &str) -> String {\n-        self.join(sep)\n-    }\n }\n \n macro_rules! spezialize_for_lengths {\n@@ -130,7 +131,7 @@ macro_rules! copy_slice_and_advance {\n \n // Optimized join implementation that works for both Vec<T> (T: Copy) and String's inner vec\n // Currently (2018-05-13) there is a bug with type inference and specialization (see issue #36262)\n-// For this reason SliceConcatExt<T> is not specialized for T: Copy and SliceConcatExt<str> is the\n+// For this reason SliceConcat<T> is not specialized for T: Copy and SliceConcat<str> is the\n // only user of this function. It is left in place for the time when that is fixed.\n //\n // the bounds for String-join are S: Borrow<str> and for Vec-join Borrow<[T]>\n@@ -207,7 +208,7 @@ impl ToOwned for str {\n     }\n \n     fn clone_into(&self, target: &mut String) {\n-        let mut b = mem::replace(target, String::new()).into_bytes();\n+        let mut b = mem::take(target).into_bytes();\n         self.as_bytes().clone_into(&mut b);\n         *target = unsafe { String::from_utf8_unchecked(b) }\n     }\n@@ -431,6 +432,13 @@ impl str {\n     ///\n     /// assert_eq!(new_year, new_year.to_uppercase());\n     /// ```\n+    ///\n+    /// One character can become multiple:\n+    /// ```\n+    /// let s = \"tsch\u00fc\u00df\";\n+    ///\n+    /// assert_eq!(\"TSCH\u00dcSS\", s.to_uppercase());\n+    /// ```\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());"}, {"sha": "b65f191836e9dcc9548bac74f9894520f5df463a", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -56,7 +56,7 @@ use core::ptr;\n use core::str::{pattern::Pattern, lossy};\n \n use crate::borrow::{Cow, ToOwned};\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::boxed::Box;\n use crate::str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n use crate::vec::Vec;\n@@ -552,7 +552,7 @@ impl String {\n     /// assert_eq!(\"Hello \ufffdWorld\", output);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n+    pub fn from_utf8_lossy(v: &[u8]) -> Cow<'_, str> {\n         let mut iter = lossy::Utf8Lossy::from_bytes(v).chunks();\n \n         let (first_valid, first_broken) = if let Some(chunk) = iter.next() {\n@@ -937,9 +937,9 @@ impl String {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    /// fn process_data(data: &str) -> Result<String, TryReserveError> {\n     ///     let mut output = String::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -953,7 +953,7 @@ impl String {\n     /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.vec.try_reserve(additional)\n     }\n \n@@ -975,9 +975,9 @@ impl String {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &str) -> Result<String, CollectionAllocErr> {\n+    /// fn process_data(data: &str) -> Result<String, TryReserveError> {\n     ///     let mut output = String::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -991,7 +991,7 @@ impl String {\n     /// # process_data(\"rust\").expect(\"why is the test harness OOMing on 4 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.vec.try_reserve_exact(additional)\n     }\n \n@@ -1838,6 +1838,7 @@ impl PartialEq for String {\n macro_rules! impl_eq {\n     ($lhs:ty, $rhs: ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(unused_lifetimes)]\n         impl<'a, 'b> PartialEq<$rhs> for $lhs {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n@@ -1846,6 +1847,7 @@ macro_rules! impl_eq {\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(unused_lifetimes)]\n         impl<'a, 'b> PartialEq<$lhs> for $rhs {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n@@ -2385,6 +2387,7 @@ impl Iterator for Drain<'_> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n     #[inline]\n     fn last(mut self) -> Option<char> {\n         self.next_back()"}, {"sha": "341172136e25833f87837dd8aa5066b14d5b61de", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 544, "deletions": 547, "changes": 1091, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -7,28 +7,33 @@\n //! [arc]: struct.Arc.html\n \n use core::any::Any;\n+use core::array::LengthAtMost32;\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n use core::cmp::{self, Ordering};\n+use core::iter;\n use core::intrinsics::abort;\n-use core::mem::{self, align_of_val, size_of_val};\n+use core::mem::{self, align_of, align_of_val, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::marker::{Unpin, Unsize, PhantomData};\n use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n-use core::convert::From;\n-use core::slice::from_raw_parts_mut;\n+use core::convert::{From, TryFrom};\n+use core::slice::{self, from_raw_parts_mut};\n \n use crate::alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use crate::boxed::Box;\n use crate::rc::is_dangling;\n use crate::string::String;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A soft limit on the amount of references that may be made to an `Arc`.\n ///\n /// Going above this limit will abort your program (although not\n@@ -206,6 +211,19 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Arc<U>> for Arc<T> {}\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Arc<U>> for Arc<T> {}\n \n+impl<T: ?Sized> Arc<T> {\n+    fn from_inner(ptr: NonNull<ArcInner<T>>) -> Self {\n+        Self {\n+            ptr,\n+            phantom: PhantomData,\n+        }\n+    }\n+\n+    unsafe fn from_ptr(ptr: *mut ArcInner<T>) -> Self {\n+        Self::from_inner(NonNull::new_unchecked(ptr))\n+    }\n+}\n+\n /// `Weak` is a version of [`Arc`] that holds a non-owning reference to the\n /// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Arc`]`<T>>`.\n@@ -290,7 +308,38 @@ impl<T> Arc<T> {\n             weak: atomic::AtomicUsize::new(1),\n             data,\n         };\n-        Arc { ptr: Box::into_raw_non_null(x), phantom: PhantomData }\n+        Self::from_inner(Box::into_raw_non_null(x))\n+    }\n+\n+    /// Constructs a new `Arc` with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_layout(\n+                Layout::new::<T>(),\n+                |mem| mem as *mut ArcInner<mem::MaybeUninit<T>>,\n+            ))\n+        }\n     }\n \n     /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n@@ -343,6 +392,118 @@ impl<T> Arc<T> {\n     }\n }\n \n+impl<T> Arc<[T]> {\n+    /// Constructs a new reference-counted slice with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    pub fn new_uninit_slice(len: usize) -> Arc<[mem::MaybeUninit<T>]> {\n+        unsafe {\n+            Arc::from_ptr(Arc::allocate_for_slice(len))\n+        }\n+    }\n+}\n+\n+impl<T> Arc<mem::MaybeUninit<T>> {\n+    /// Converts to `Arc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     five.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<T> {\n+        Arc::from_inner(mem::ManuallyDrop::new(self).ptr.cast())\n+    }\n+}\n+\n+impl<T> Arc<[mem::MaybeUninit<T>]> {\n+    /// Converts to `Arc<[T]>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// [`MaybeUninit::assume_init`]: ../../std/mem/union.MaybeUninit.html#method.assume_init\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut values = Arc::<[u32]>::new_uninit_slice(3);\n+    ///\n+    /// let values = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut values)[0].as_mut_ptr().write(1);\n+    ///     Arc::get_mut_unchecked(&mut values)[1].as_mut_ptr().write(2);\n+    ///     Arc::get_mut_unchecked(&mut values)[2].as_mut_ptr().write(3);\n+    ///\n+    ///     values.assume_init()\n+    /// };\n+    ///\n+    /// assert_eq!(*values, [1, 2, 3])\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n+    #[inline]\n+    pub unsafe fn assume_init(self) -> Arc<[T]> {\n+        Arc::from_ptr(mem::ManuallyDrop::new(self).ptr.as_ptr() as _)\n+    }\n+}\n+\n impl<T: ?Sized> Arc<T> {\n     /// Consumes the `Arc`, returning the wrapped pointer.\n     ///\n@@ -356,9 +517,9 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let x = Arc::new(10);\n+    /// let x = Arc::new(\"hello\".to_owned());\n     /// let x_ptr = Arc::into_raw(x);\n-    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n@@ -382,13 +543,13 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     /// use std::sync::Arc;\n     ///\n-    /// let x = Arc::new(10);\n+    /// let x = Arc::new(\"hello\".to_owned());\n     /// let x_ptr = Arc::into_raw(x);\n     ///\n     /// unsafe {\n     ///     // Convert back to an `Arc` to prevent leak.\n     ///     let x = Arc::from_raw(x_ptr);\n-    ///     assert_eq!(*x, 10);\n+    ///     assert_eq!(&*x, \"hello\");\n     ///\n     ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n     /// }\n@@ -397,20 +558,13 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the ArcInner.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<ArcInner<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original ArcInner.\n         let fake_ptr = ptr as *mut ArcInner<T>;\n         let arc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n \n-        Arc {\n-            ptr: NonNull::new_unchecked(arc_ptr),\n-            phantom: PhantomData,\n-        }\n+        Self::from_ptr(arc_ptr)\n     }\n \n     /// Consumes the `Arc`, returning the wrapped pointer as `NonNull<T>`.\n@@ -422,10 +576,10 @@ impl<T: ?Sized> Arc<T> {\n     ///\n     /// use std::sync::Arc;\n     ///\n-    /// let x = Arc::new(10);\n+    /// let x = Arc::new(\"hello\".to_owned());\n     /// let ptr = Arc::into_raw_non_null(x);\n-    /// let deref = unsafe { *ptr.as_ref() };\n-    /// assert_eq!(deref, 10);\n+    /// let deref = unsafe { ptr.as_ref() };\n+    /// assert_eq!(deref, \"hello\");\n     /// ```\n     #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n     #[inline]\n@@ -581,21 +735,28 @@ impl<T: ?Sized> Arc<T> {\n }\n \n impl<T: ?Sized> Arc<T> {\n-    // Allocates an `ArcInner<T>` with sufficient space for an unsized value\n-    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n-        // Calculate layout using the given value.\n+    /// Allocates an `ArcInner<T>` with sufficient space for\n+    /// a possibly-unsized value where the value has the layout provided.\n+    ///\n+    /// The function `mem_to_arcinner` is called with the data pointer\n+    /// and must return back a (potentially fat)-pointer for the `ArcInner<T>`.\n+    unsafe fn allocate_for_layout(\n+        value_layout: Layout,\n+        mem_to_arcinner: impl FnOnce(*mut u8) -> *mut ArcInner<T>\n+    ) -> *mut ArcInner<T> {\n+        // Calculate layout using the given value layout.\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const ArcInner<T>)`, but this created a misaligned\n         // reference (see #54908).\n         let layout = Layout::new::<ArcInner<()>>()\n-            .extend(Layout::for_value(&*ptr)).unwrap().0\n+            .extend(value_layout).unwrap().0\n             .pad_to_align().unwrap();\n \n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the ArcInner\n-        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut ArcInner<T>;\n+        let inner = mem_to_arcinner(mem.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n@@ -604,6 +765,15 @@ impl<T: ?Sized> Arc<T> {\n         inner\n     }\n \n+    /// Allocates an `ArcInner<T>` with sufficient space for an unsized value.\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n+        // Allocate for the `ArcInner<T>` using the given value.\n+        Self::allocate_for_layout(\n+            Layout::for_value(&*ptr),\n+            |mem| set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>,\n+        )\n+    }\n+\n     fn from_box(v: Box<T>) -> Arc<T> {\n         unsafe {\n             let box_unique = Box::into_unique(v);\n@@ -621,45 +791,49 @@ impl<T: ?Sized> Arc<T> {\n             // Free the allocation without dropping its contents\n             box_free(box_unique);\n \n-            Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+            Self::from_ptr(ptr)\n         }\n     }\n }\n \n-// Sets the data pointer of a `?Sized` raw pointer.\n-//\n-// For a slice/trait object, this sets the `data` field and leaves the rest\n-// unchanged. For a sized raw pointer, this simply sets the pointer.\n+impl<T> Arc<[T]> {\n+    /// Allocates an `ArcInner<[T]>` with the given length.\n+    unsafe fn allocate_for_slice(len: usize) -> *mut ArcInner<[T]> {\n+        Self::allocate_for_layout(\n+            Layout::array::<T>(len).unwrap(),\n+            |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut ArcInner<[T]>,\n+        )\n+    }\n+}\n+\n+/// Sets the data pointer of a `?Sized` raw pointer.\n+///\n+/// For a slice/trait object, this sets the `data` field and leaves the rest\n+/// unchanged. For a sized raw pointer, this simply sets the pointer.\n unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n     ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n     ptr\n }\n \n impl<T> Arc<[T]> {\n-    // Copy elements from slice into newly allocated Arc<[T]>\n-    //\n-    // Unsafe because the caller must either take ownership or bind `T: Copy`\n+    /// Copy elements from slice into newly allocated Arc<[T]>\n+    ///\n+    /// Unsafe because the caller must either take ownership or bind `T: Copy`.\n     unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n-        let v_ptr = v as *const [T];\n-        let ptr = Self::allocate_for_ptr(v_ptr);\n+        let ptr = Self::allocate_for_slice(v.len());\n \n         ptr::copy_nonoverlapping(\n             v.as_ptr(),\n             &mut (*ptr).data as *mut [T] as *mut T,\n             v.len());\n \n-        Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+        Self::from_ptr(ptr)\n     }\n-}\n-\n-// Specialization trait used for From<&[T]>\n-trait ArcFromSlice<T> {\n-    fn from_slice(slice: &[T]) -> Self;\n-}\n \n-impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n-    #[inline]\n-    default fn from_slice(v: &[T]) -> Self {\n+    /// Constructs an `Arc<[T]>` from an iterator known to be of a certain size.\n+    ///\n+    /// Behavior is undefined should the size be wrong.\n+    unsafe fn from_iter_exact(iter: impl iter::Iterator<Item = T>, len: usize) -> Arc<[T]> {\n         // Panic guard while cloning T elements.\n         // In the event of a panic, elements that have been written\n         // into the new ArcInner will be dropped, then the memory freed.\n@@ -676,37 +850,48 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem.cast(), self.layout.clone());\n+                    Global.dealloc(self.mem.cast(), self.layout);\n                 }\n             }\n         }\n \n-        unsafe {\n-            let v_ptr = v as *const [T];\n-            let ptr = Self::allocate_for_ptr(v_ptr);\n+        let ptr = Self::allocate_for_slice(len);\n \n-            let mem = ptr as *mut _ as *mut u8;\n-            let layout = Layout::for_value(&*ptr);\n+        let mem = ptr as *mut _ as *mut u8;\n+        let layout = Layout::for_value(&*ptr);\n \n-            // Pointer to first element\n-            let elems = &mut (*ptr).data as *mut [T] as *mut T;\n+        // Pointer to first element\n+        let elems = &mut (*ptr).data as *mut [T] as *mut T;\n \n-            let mut guard = Guard{\n-                mem: NonNull::new_unchecked(mem),\n-                elems: elems,\n-                layout: layout,\n-                n_elems: 0,\n-            };\n+        let mut guard = Guard {\n+            mem: NonNull::new_unchecked(mem),\n+            elems,\n+            layout,\n+            n_elems: 0,\n+        };\n \n-            for (i, item) in v.iter().enumerate() {\n-                ptr::write(elems.add(i), item.clone());\n-                guard.n_elems += 1;\n-            }\n+        for (i, item) in iter.enumerate() {\n+            ptr::write(elems.add(i), item);\n+            guard.n_elems += 1;\n+        }\n \n-            // All clear. Forget the guard so it doesn't free the new ArcInner.\n-            mem::forget(guard);\n+        // All clear. Forget the guard so it doesn't free the new ArcInner.\n+        mem::forget(guard);\n \n-            Arc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+        Self::from_ptr(ptr)\n+    }\n+}\n+\n+/// Specialization trait used for `From<&[T]>`.\n+trait ArcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        unsafe {\n+            Self::from_iter_exact(v.iter().cloned(), v.len())\n         }\n     }\n }\n@@ -764,7 +949,7 @@ impl<T: ?Sized> Clone for Arc<T> {\n             }\n         }\n \n-        Arc { ptr: self.ptr, phantom: PhantomData }\n+        Self::from_inner(self.ptr)\n     }\n }\n \n@@ -903,13 +1088,46 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                Some(&mut this.ptr.as_mut().data)\n+                Some(Arc::get_mut_unchecked(this))\n             }\n         } else {\n             None\n         }\n     }\n \n+    /// Returns a mutable reference to the inner value,\n+    /// without any check.\n+    ///\n+    /// See also [`get_mut`], which is safe and does appropriate checks.\n+    ///\n+    /// [`get_mut`]: struct.Arc.html#method.get_mut\n+    ///\n+    /// # Safety\n+    ///\n+    /// Any other `Arc` or [`Weak`] pointers to the same value must not be dereferenced\n+    /// for the duration of the returned borrow.\n+    /// This is trivially the case if no such pointers exist,\n+    /// for example immediately after `Arc::new`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut x = Arc::new(String::new());\n+    /// unsafe {\n+    ///     Arc::get_mut_unchecked(&mut x).push_str(\"foo\")\n+    /// }\n+    /// assert_eq!(*x, \"foo\");\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"get_mut_unchecked\", issue = \"63292\")]\n+    pub unsafe fn get_mut_unchecked(this: &mut Self) -> &mut T {\n+        &mut this.ptr.as_mut().data\n+    }\n+\n     /// Determine whether this is the unique reference (including weak refs) to\n     /// the underlying data.\n     ///\n@@ -1043,7 +1261,7 @@ impl Arc<dyn Any + Send + Sync> {\n         if (*self).is::<T>() {\n             let ptr = self.ptr.cast::<ArcInner<T>>();\n             mem::forget(self);\n-            Ok(Arc { ptr, phantom: PhantomData })\n+            Ok(Arc::from_inner(ptr))\n         } else {\n             Err(self)\n         }\n@@ -1071,6 +1289,144 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut ArcInner<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::Arc;\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Arc::new(\"hello\".to_owned());\n+    /// let weak = Arc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(&self) -> *const T {\n+        match self.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const ArcInner<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let strong = Arc::new(\"hello\".to_owned());\n+    /// let weak = Arc::downgrade(&strong);\n+    /// let raw = weak.into_raw();\n+    ///\n+    /// assert_eq!(1, Arc::weak_count(&strong));\n+    /// assert_eq!(\"hello\", unsafe { &*raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Arc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(self) -> *const T {\n+        let result = self.as_raw();\n+        mem::forget(self);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into\n+    /// `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Arc`] and the weak count of that [`Arc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let strong = Arc::new(\"hello\".to_owned());\n+    ///\n+    /// let raw_1 = Arc::downgrade(&strong).into_raw();\n+    /// let raw_2 = Arc::downgrade(&strong).into_raw();\n+    ///\n+    /// assert_eq!(2, Arc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(\"hello\", &*unsafe { Weak::from_raw(raw_1) }.upgrade().unwrap());\n+    /// assert_eq!(1, Arc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Weak`]: struct.Weak.html\n+    /// [`Arc`]: struct.Arc.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Arc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut ArcInner<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n impl<T: ?Sized> Weak<T> {\n@@ -1126,11 +1482,7 @@ impl<T: ?Sized> Weak<T> {\n \n             // Relaxed is valid for the same reason it is on Arc's Clone impl\n             match inner.strong.compare_exchange_weak(n, n + 1, Relaxed, Relaxed) {\n-                Ok(_) => return Some(Arc {\n-                    // null checked above\n-                    ptr: self.ptr,\n-                    phantom: PhantomData,\n-                }),\n+                Ok(_) => return Some(Arc::from_inner(self.ptr)), // null checked above\n                 Err(old) => n = old,\n             }\n         }\n@@ -1215,18 +1567,18 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// ```\n     /// #![feature(weak_ptr_eq)]\n-    /// use std::sync::{Arc, Weak};\n+    /// use std::sync::Arc;\n     ///\n     /// let first_rc = Arc::new(5);\n     /// let first = Arc::downgrade(&first_rc);\n     /// let second = Arc::downgrade(&first_rc);\n     ///\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Arc::new(5);\n     /// let third = Arc::downgrade(&third_rc);\n     ///\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n     /// Comparing `Weak::new`.\n@@ -1237,16 +1589,16 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// let first = Weak::new();\n     /// let second = Weak::new();\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Arc::new(());\n     /// let third = Arc::downgrade(&third_rc);\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n     #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n-    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        this.ptr.as_ptr() == other.ptr.as_ptr()\n+    pub fn ptr_eq(&self, other: &Self) -> bool {\n+        self.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -1651,486 +2003,111 @@ impl<T> From<Vec<T>> for Arc<[T]> {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use std::boxed::Box;\n-    use std::clone::Clone;\n-    use std::sync::mpsc::channel;\n-    use std::mem::drop;\n-    use std::ops::Drop;\n-    use std::option::Option::{self, None, Some};\n-    use std::sync::atomic::{self, Ordering::{Acquire, SeqCst}};\n-    use std::thread;\n-    use std::sync::Mutex;\n-    use std::convert::From;\n-\n-    use super::{Arc, Weak};\n-    use crate::vec::Vec;\n-\n-    struct Canary(*mut atomic::AtomicUsize);\n-\n-    impl Drop for Canary {\n-        fn drop(&mut self) {\n-            unsafe {\n-                match *self {\n-                    Canary(c) => {\n-                        (*c).fetch_add(1, SeqCst);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg(not(miri))] // Miri does not support threads\n-    fn manually_share_arc() {\n-        let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        let arc_v = Arc::new(v);\n-\n-        let (tx, rx) = channel();\n-\n-        let _t = thread::spawn(move || {\n-            let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n-            assert_eq!((*arc_v)[3], 4);\n-        });\n-\n-        tx.send(arc_v.clone()).unwrap();\n-\n-        assert_eq!((*arc_v)[2], 3);\n-        assert_eq!((*arc_v)[4], 5);\n-    }\n-\n-    #[test]\n-    fn test_arc_get_mut() {\n-        let mut x = Arc::new(3);\n-        *Arc::get_mut(&mut x).unwrap() = 4;\n-        assert_eq!(*x, 4);\n-        let y = x.clone();\n-        assert!(Arc::get_mut(&mut x).is_none());\n-        drop(y);\n-        assert!(Arc::get_mut(&mut x).is_some());\n-        let _w = Arc::downgrade(&x);\n-        assert!(Arc::get_mut(&mut x).is_none());\n-    }\n-\n-    #[test]\n-    fn weak_counts() {\n-        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n-        assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n-\n-        let a = Arc::new(0);\n-        let w = Arc::downgrade(&a);\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(1));\n-        let w2 = w.clone();\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(2));\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(2));\n-        drop(w);\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        let a2 = a.clone();\n-        assert_eq!(Weak::strong_count(&w2), 2);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(a2);\n-        drop(a);\n-        assert_eq!(Weak::strong_count(&w2), 0);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(w2);\n-    }\n-\n-    #[test]\n-    fn try_unwrap() {\n-        let x = Arc::new(3);\n-        assert_eq!(Arc::try_unwrap(x), Ok(3));\n-        let x = Arc::new(4);\n-        let _y = x.clone();\n-        assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n-        let x = Arc::new(5);\n-        let _w = Arc::downgrade(&x);\n-        assert_eq!(Arc::try_unwrap(x), Ok(5));\n-    }\n-\n-    #[test]\n-    fn into_from_raw() {\n-        let x = Arc::new(box \"hello\");\n-        let y = x.clone();\n-\n-        let x_ptr = Arc::into_raw(x);\n-        drop(y);\n-        unsafe {\n-            assert_eq!(**x_ptr, \"hello\");\n-\n-            let x = Arc::from_raw(x_ptr);\n-            assert_eq!(**x, \"hello\");\n-\n-            assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_from_raw_unsized() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let arc: Arc<str> = Arc::from(\"foo\");\n-\n-        let ptr = Arc::into_raw(arc.clone());\n-        let arc2 = unsafe { Arc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }, \"foo\");\n-        assert_eq!(arc, arc2);\n-\n-        let arc: Arc<dyn Display> = Arc::new(123);\n-\n-        let ptr = Arc::into_raw(arc.clone());\n-        let arc2 = unsafe { Arc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n-        assert_eq!(arc2.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_make_mut() {\n-        let mut cow0 = Arc::new(75);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *Arc::make_mut(&mut cow0));\n-        assert!(75 == *Arc::make_mut(&mut cow1));\n-        assert!(75 == *Arc::make_mut(&mut cow2));\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-        *Arc::make_mut(&mut cow1) += 2;\n-        *Arc::make_mut(&mut cow2) += 3;\n-\n-        assert!(76 == *cow0);\n-        assert!(77 == *cow1);\n-        assert!(78 == *cow2);\n-\n-        // none should point to the same backing memory\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 != *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_unique2() {\n-        let mut cow0 = Arc::new(75);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n-        assert!(76 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        // cow1 and cow2 should share the same contents\n-        // cow0 should have a unique reference\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 == *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowarc_clone_weak() {\n-        let mut cow0 = Arc::new(75);\n-        let cow1_weak = Arc::downgrade(&cow0);\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1_weak.upgrade().unwrap());\n-\n-        *Arc::make_mut(&mut cow0) += 1;\n+#[unstable(feature = \"boxed_slice_try_from\", issue = \"0\")]\n+impl<T, const N: usize> TryFrom<Arc<[T]>> for Arc<[T; N]>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = Arc<[T]>;\n \n-        assert!(76 == *cow0);\n-        assert!(cow1_weak.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_live() {\n-        let x = Arc::new(5);\n-        let y = Arc::downgrade(&x);\n-        assert!(y.upgrade().is_some());\n-    }\n-\n-    #[test]\n-    fn test_dead() {\n-        let x = Arc::new(5);\n-        let y = Arc::downgrade(&x);\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn weak_self_cyclic() {\n-        struct Cycle {\n-            x: Mutex<Option<Weak<Cycle>>>,\n-        }\n-\n-        let a = Arc::new(Cycle { x: Mutex::new(None) });\n-        let b = Arc::downgrade(&a.clone());\n-        *a.x.lock().unwrap() = Some(b);\n-\n-        // hopefully we don't double-free (or leak)...\n-    }\n-\n-    #[test]\n-    fn drop_arc() {\n-        let mut canary = atomic::AtomicUsize::new(0);\n-        let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n-        drop(x);\n-        assert!(canary.load(Acquire) == 1);\n-    }\n-\n-    #[test]\n-    fn drop_arc_weak() {\n-        let mut canary = atomic::AtomicUsize::new(0);\n-        let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n-        let arc_weak = Arc::downgrade(&arc);\n-        assert!(canary.load(Acquire) == 0);\n-        drop(arc);\n-        assert!(canary.load(Acquire) == 1);\n-        drop(arc_weak);\n-    }\n-\n-    #[test]\n-    fn test_strong_count() {\n-        let a = Arc::new(0);\n-        assert!(Arc::strong_count(&a) == 1);\n-        let w = Arc::downgrade(&a);\n-        assert!(Arc::strong_count(&a) == 1);\n-        let b = w.upgrade().expect(\"\");\n-        assert!(Arc::strong_count(&b) == 2);\n-        assert!(Arc::strong_count(&a) == 2);\n-        drop(w);\n-        drop(a);\n-        assert!(Arc::strong_count(&b) == 1);\n-        let c = b.clone();\n-        assert!(Arc::strong_count(&b) == 2);\n-        assert!(Arc::strong_count(&c) == 2);\n-    }\n-\n-    #[test]\n-    fn test_weak_count() {\n-        let a = Arc::new(0);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let w = Arc::downgrade(&a);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 1);\n-        let x = w.clone();\n-        assert!(Arc::weak_count(&a) == 2);\n-        drop(w);\n-        drop(x);\n-        assert!(Arc::strong_count(&a) == 1);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let c = a.clone();\n-        assert!(Arc::strong_count(&a) == 2);\n-        assert!(Arc::weak_count(&a) == 0);\n-        let d = Arc::downgrade(&c);\n-        assert!(Arc::weak_count(&c) == 1);\n-        assert!(Arc::strong_count(&c) == 2);\n-\n-        drop(a);\n-        drop(c);\n-        drop(d);\n-    }\n-\n-    #[test]\n-    fn show_arc() {\n-        let a = Arc::new(5);\n-        assert_eq!(format!(\"{:?}\", a), \"5\");\n-    }\n-\n-    // Make sure deriving works with Arc<T>\n-    #[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n-    struct Foo {\n-        inner: Arc<i32>,\n-    }\n-\n-    #[test]\n-    fn test_unsized() {\n-        let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n-        assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n-        let y = Arc::downgrade(&x.clone());\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_from_owned() {\n-        let foo = 123;\n-        let foo_arc = Arc::from(foo);\n-        assert!(123 == *foo_arc);\n-    }\n-\n-    #[test]\n-    fn test_new_weak() {\n-        let foo: Weak<usize> = Weak::new();\n-        assert!(foo.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_ptr_eq() {\n-        let five = Arc::new(5);\n-        let same_five = five.clone();\n-        let other_five = Arc::new(5);\n-\n-        assert!(Arc::ptr_eq(&five, &same_five));\n-        assert!(!Arc::ptr_eq(&five, &other_five));\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    #[cfg(not(miri))] // Miri does not support threads\n-    fn test_weak_count_locked() {\n-        let mut a = Arc::new(atomic::AtomicBool::new(false));\n-        let a2 = a.clone();\n-        let t = thread::spawn(move || {\n-            for _i in 0..1000000 {\n-                Arc::get_mut(&mut a);\n-            }\n-            a.store(true, SeqCst);\n-        });\n-\n-        while !a2.load(SeqCst) {\n-            let n = Arc::weak_count(&a2);\n-            assert!(n < 2, \"bad weak count: {}\", n);\n+    fn try_from(boxed_slice: Arc<[T]>) -> Result<Self, Self::Error> {\n+        if boxed_slice.len() == N {\n+            Ok(unsafe { Arc::from_raw(Arc::into_raw(boxed_slice) as *mut [T; N]) })\n+        } else {\n+            Err(boxed_slice)\n         }\n-        t.join().unwrap();\n     }\n+}\n \n-    #[test]\n-    fn test_from_str() {\n-        let r: Arc<str> = Arc::from(\"foo\");\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_copy_from_slice() {\n-        let s: &[u32] = &[1, 2, 3];\n-        let r: Arc<[u32]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n+#[stable(feature = \"shared_from_iter\", since = \"1.37.0\")]\n+impl<T> iter::FromIterator<T> for Arc<[T]> {\n+    /// Takes each element in the `Iterator` and collects it into an `Arc<[T]>`.\n+    ///\n+    /// # Performance characteristics\n+    ///\n+    /// ## The general case\n+    ///\n+    /// In the general case, collecting into `Arc<[T]>` is done by first\n+    /// collecting into a `Vec<T>`. That is, when writing the following:\n+    ///\n+    /// ```rust\n+    /// # use std::sync::Arc;\n+    /// let evens: Arc<[u8]> = (0..10).filter(|&x| x % 2 == 0).collect();\n+    /// # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n+    /// ```\n+    ///\n+    /// this behaves as if we wrote:\n+    ///\n+    /// ```rust\n+    /// # use std::sync::Arc;\n+    /// let evens: Arc<[u8]> = (0..10).filter(|&x| x % 2 == 0)\n+    ///     .collect::<Vec<_>>() // The first set of allocations happens here.\n+    ///     .into(); // A second allocation for `Arc<[T]>` happens here.\n+    /// # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n+    /// ```\n+    ///\n+    /// This will allocate as many times as needed for constructing the `Vec<T>`\n+    /// and then it will allocate once for turning the `Vec<T>` into the `Arc<[T]>`.\n+    ///\n+    /// ## Iterators of known length\n+    ///\n+    /// When your `Iterator` implements `TrustedLen` and is of an exact size,\n+    /// a single allocation will be made for the `Arc<[T]>`. For example:\n+    ///\n+    /// ```rust\n+    /// # use std::sync::Arc;\n+    /// let evens: Arc<[u8]> = (0..10).collect(); // Just a single allocation happens here.\n+    /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n+    /// ```\n+    fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n+        ArcFromIter::from_iter(iter.into_iter())\n     }\n+}\n \n-    #[test]\n-    fn test_clone_from_slice() {\n-        #[derive(Clone, Debug, Eq, PartialEq)]\n-        struct X(u32);\n-\n-        let s: &[X] = &[X(1), X(2), X(3)];\n-        let r: Arc<[X]> = Arc::from(s);\n+/// Specialization trait used for collecting into `Arc<[T]>`.\n+trait ArcFromIter<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n \n-        assert_eq!(&r[..], s);\n+impl<T, I: Iterator<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n+    default fn from_iter(iter: I) -> Self {\n+        iter.collect::<Vec<T>>().into()\n     }\n+}\n \n-    #[test]\n-    #[should_panic]\n-    fn test_clone_from_slice_panic() {\n-        use std::string::{String, ToString};\n-\n-        struct Fail(u32, String);\n+impl<T, I: iter::TrustedLen<Item = T>> ArcFromIter<T, I> for Arc<[T]> {\n+    default fn from_iter(iter: I) -> Self {\n+        // This is the case for a `TrustedLen` iterator.\n+        let (low, high) = iter.size_hint();\n+        if let Some(high) = high {\n+            debug_assert_eq!(\n+                low, high,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n \n-        impl Clone for Fail {\n-            fn clone(&self) -> Fail {\n-                if self.0 == 2 {\n-                    panic!();\n-                }\n-                Fail(self.0, self.1.clone())\n+            unsafe {\n+                // SAFETY: We need to ensure that the iterator has an exact length and we have.\n+                Arc::from_iter_exact(iter, low)\n             }\n+        } else {\n+            // Fall back to normal implementation.\n+            iter.collect::<Vec<T>>().into()\n         }\n-\n-        let s: &[Fail] = &[\n-            Fail(0, \"foo\".to_string()),\n-            Fail(1, \"bar\".to_string()),\n-            Fail(2, \"baz\".to_string()),\n-        ];\n-\n-        // Should panic, but not cause memory corruption\n-        let _r: Arc<[Fail]> = Arc::from(s);\n-    }\n-\n-    #[test]\n-    fn test_from_box() {\n-        let b: Box<u32> = box 123;\n-        let r: Arc<u32> = Arc::from(b);\n-\n-        assert_eq!(*r, 123);\n-    }\n-\n-    #[test]\n-    fn test_from_box_str() {\n-        use std::string::String;\n-\n-        let s = String::from(\"foo\").into_boxed_str();\n-        let r: Arc<str> = Arc::from(s);\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_slice() {\n-        let s = vec![1, 2, 3].into_boxed_slice();\n-        let r: Arc<[u32]> = Arc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let b: Box<dyn Display> = box 123;\n-        let r: Arc<dyn Display> = Arc::from(b);\n-\n-        assert_eq!(r.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait_zero_sized() {\n-        use std::fmt::Debug;\n-\n-        let b: Box<dyn Debug> = box ();\n-        let r: Arc<dyn Debug> = Arc::from(b);\n-\n-        assert_eq!(format!(\"{:?}\", r), \"()\");\n     }\n+}\n \n-    #[test]\n-    fn test_from_vec() {\n-        let v = vec![1, 2, 3];\n-        let r: Arc<[u32]> = Arc::from(v);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_downcast() {\n-        use std::any::Any;\n-\n-        let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n-        let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n-\n-        assert!(r1.clone().downcast::<u32>().is_err());\n-\n-        let r1i32 = r1.downcast::<i32>();\n-        assert!(r1i32.is_ok());\n-        assert_eq!(r1i32.unwrap(), Arc::new(i32::max_value()));\n-\n-        assert!(r2.clone().downcast::<i32>().is_err());\n-\n-        let r2str = r2.downcast::<&'static str>();\n-        assert!(r2str.is_ok());\n-        assert_eq!(r2str.unwrap(), Arc::new(\"abc\"));\n+impl<'a, T: 'a + Clone> ArcFromIter<&'a T, slice::Iter<'a, T>> for Arc<[T]> {\n+    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n+        // Delegate to `impl<T: Clone> From<&[T]> for Arc<[T]>`.\n+        //\n+        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n+        // which is even more performant.\n+        //\n+        // In the fall-back case we have `T: Clone`. This is still better\n+        // than the `TrustedLen` implementation as slices have a known length\n+        // and so we get to avoid calling `size_hint` and avoid the branching.\n+        iter.as_slice().into()\n     }\n }\n \n@@ -2150,3 +2127,23 @@ impl<T: ?Sized> AsRef<T> for Arc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Arc<T> { }\n+\n+/// Computes the offset of the data field within `ArcInner`.\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the `ArcInner`.\n+    // Because it is `?Sized`, it will always be the last field in memory.\n+    data_offset_align(align_of_val(&*ptr))\n+}\n+\n+/// Computes the offset of the data field within `ArcInner`.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    data_offset_align(align_of::<T>())\n+}\n+\n+#[inline]\n+fn data_offset_align(align: usize) -> isize {\n+    let layout = Layout::new::<ArcInner<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}, {"sha": "9220f5e0333efa431570f50ca56663d1c1400c4a", "filename": "src/liballoc/sync/tests.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,492 @@\n+use super::*;\n+\n+use std::boxed::Box;\n+use std::clone::Clone;\n+use std::sync::mpsc::channel;\n+use std::mem::drop;\n+use std::ops::Drop;\n+use std::option::Option::{self, None, Some};\n+use std::sync::atomic::{self, Ordering::{Acquire, SeqCst}};\n+use std::thread;\n+use std::sync::Mutex;\n+use std::convert::{From, TryInto};\n+\n+use crate::vec::Vec;\n+\n+struct Canary(*mut atomic::AtomicUsize);\n+\n+impl Drop for Canary {\n+    fn drop(&mut self) {\n+        unsafe {\n+            match *self {\n+                Canary(c) => {\n+                    (*c).fetch_add(1, SeqCst);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support threads\n+fn manually_share_arc() {\n+    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    let arc_v = Arc::new(v);\n+\n+    let (tx, rx) = channel();\n+\n+    let _t = thread::spawn(move || {\n+        let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n+        assert_eq!((*arc_v)[3], 4);\n+    });\n+\n+    tx.send(arc_v.clone()).unwrap();\n+\n+    assert_eq!((*arc_v)[2], 3);\n+    assert_eq!((*arc_v)[4], 5);\n+}\n+\n+#[test]\n+fn test_arc_get_mut() {\n+    let mut x = Arc::new(3);\n+    *Arc::get_mut(&mut x).unwrap() = 4;\n+    assert_eq!(*x, 4);\n+    let y = x.clone();\n+    assert!(Arc::get_mut(&mut x).is_none());\n+    drop(y);\n+    assert!(Arc::get_mut(&mut x).is_some());\n+    let _w = Arc::downgrade(&x);\n+    assert!(Arc::get_mut(&mut x).is_none());\n+}\n+\n+#[test]\n+fn weak_counts() {\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n+\n+    let a = Arc::new(0);\n+    let w = Arc::downgrade(&a);\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(1));\n+    let w2 = w.clone();\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    drop(w);\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    let a2 = a.clone();\n+    assert_eq!(Weak::strong_count(&w2), 2);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(a2);\n+    drop(a);\n+    assert_eq!(Weak::strong_count(&w2), 0);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(w2);\n+}\n+\n+#[test]\n+fn try_unwrap() {\n+    let x = Arc::new(3);\n+    assert_eq!(Arc::try_unwrap(x), Ok(3));\n+    let x = Arc::new(4);\n+    let _y = x.clone();\n+    assert_eq!(Arc::try_unwrap(x), Err(Arc::new(4)));\n+    let x = Arc::new(5);\n+    let _w = Arc::downgrade(&x);\n+    assert_eq!(Arc::try_unwrap(x), Ok(5));\n+}\n+\n+#[test]\n+fn into_from_raw() {\n+    let x = Arc::new(box \"hello\");\n+    let y = x.clone();\n+\n+    let x_ptr = Arc::into_raw(x);\n+    drop(y);\n+    unsafe {\n+        assert_eq!(**x_ptr, \"hello\");\n+\n+        let x = Arc::from_raw(x_ptr);\n+        assert_eq!(**x, \"hello\");\n+\n+        assert_eq!(Arc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+    }\n+}\n+\n+#[test]\n+fn test_into_from_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let arc: Arc<str> = Arc::from(\"foo\");\n+\n+    let ptr = Arc::into_raw(arc.clone());\n+    let arc2 = unsafe { Arc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert_eq!(arc, arc2);\n+\n+    let arc: Arc<dyn Display> = Arc::new(123);\n+\n+    let ptr = Arc::into_raw(arc.clone());\n+    let arc2 = unsafe { Arc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert_eq!(arc2.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn test_cowarc_clone_make_mut() {\n+    let mut cow0 = Arc::new(75);\n+    let mut cow1 = cow0.clone();\n+    let mut cow2 = cow1.clone();\n+\n+    assert!(75 == *Arc::make_mut(&mut cow0));\n+    assert!(75 == *Arc::make_mut(&mut cow1));\n+    assert!(75 == *Arc::make_mut(&mut cow2));\n+\n+    *Arc::make_mut(&mut cow0) += 1;\n+    *Arc::make_mut(&mut cow1) += 2;\n+    *Arc::make_mut(&mut cow2) += 3;\n+\n+    assert!(76 == *cow0);\n+    assert!(77 == *cow1);\n+    assert!(78 == *cow2);\n+\n+    // none should point to the same backing memory\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 != *cow2);\n+}\n+\n+#[test]\n+fn test_cowarc_clone_unique2() {\n+    let mut cow0 = Arc::new(75);\n+    let cow1 = cow0.clone();\n+    let cow2 = cow1.clone();\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    *Arc::make_mut(&mut cow0) += 1;\n+    assert!(76 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    // cow1 and cow2 should share the same contents\n+    // cow0 should have a unique reference\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 == *cow2);\n+}\n+\n+#[test]\n+fn test_cowarc_clone_weak() {\n+    let mut cow0 = Arc::new(75);\n+    let cow1_weak = Arc::downgrade(&cow0);\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1_weak.upgrade().unwrap());\n+\n+    *Arc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(cow1_weak.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_live() {\n+    let x = Arc::new(5);\n+    let y = Arc::downgrade(&x);\n+    assert!(y.upgrade().is_some());\n+}\n+\n+#[test]\n+fn test_dead() {\n+    let x = Arc::new(5);\n+    let y = Arc::downgrade(&x);\n+    drop(x);\n+    assert!(y.upgrade().is_none());\n+}\n+\n+#[test]\n+fn weak_self_cyclic() {\n+    struct Cycle {\n+        x: Mutex<Option<Weak<Cycle>>>,\n+    }\n+\n+    let a = Arc::new(Cycle { x: Mutex::new(None) });\n+    let b = Arc::downgrade(&a.clone());\n+    *a.x.lock().unwrap() = Some(b);\n+\n+    // hopefully we don't double-free (or leak)...\n+}\n+\n+#[test]\n+fn drop_arc() {\n+    let mut canary = atomic::AtomicUsize::new(0);\n+    let x = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n+    drop(x);\n+    assert!(canary.load(Acquire) == 1);\n+}\n+\n+#[test]\n+fn drop_arc_weak() {\n+    let mut canary = atomic::AtomicUsize::new(0);\n+    let arc = Arc::new(Canary(&mut canary as *mut atomic::AtomicUsize));\n+    let arc_weak = Arc::downgrade(&arc);\n+    assert!(canary.load(Acquire) == 0);\n+    drop(arc);\n+    assert!(canary.load(Acquire) == 1);\n+    drop(arc_weak);\n+}\n+\n+#[test]\n+fn test_strong_count() {\n+    let a = Arc::new(0);\n+    assert!(Arc::strong_count(&a) == 1);\n+    let w = Arc::downgrade(&a);\n+    assert!(Arc::strong_count(&a) == 1);\n+    let b = w.upgrade().expect(\"\");\n+    assert!(Arc::strong_count(&b) == 2);\n+    assert!(Arc::strong_count(&a) == 2);\n+    drop(w);\n+    drop(a);\n+    assert!(Arc::strong_count(&b) == 1);\n+    let c = b.clone();\n+    assert!(Arc::strong_count(&b) == 2);\n+    assert!(Arc::strong_count(&c) == 2);\n+}\n+\n+#[test]\n+fn test_weak_count() {\n+    let a = Arc::new(0);\n+    assert!(Arc::strong_count(&a) == 1);\n+    assert!(Arc::weak_count(&a) == 0);\n+    let w = Arc::downgrade(&a);\n+    assert!(Arc::strong_count(&a) == 1);\n+    assert!(Arc::weak_count(&a) == 1);\n+    let x = w.clone();\n+    assert!(Arc::weak_count(&a) == 2);\n+    drop(w);\n+    drop(x);\n+    assert!(Arc::strong_count(&a) == 1);\n+    assert!(Arc::weak_count(&a) == 0);\n+    let c = a.clone();\n+    assert!(Arc::strong_count(&a) == 2);\n+    assert!(Arc::weak_count(&a) == 0);\n+    let d = Arc::downgrade(&c);\n+    assert!(Arc::weak_count(&c) == 1);\n+    assert!(Arc::strong_count(&c) == 2);\n+\n+    drop(a);\n+    drop(c);\n+    drop(d);\n+}\n+\n+#[test]\n+fn show_arc() {\n+    let a = Arc::new(5);\n+    assert_eq!(format!(\"{:?}\", a), \"5\");\n+}\n+\n+// Make sure deriving works with Arc<T>\n+#[derive(Eq, Ord, PartialEq, PartialOrd, Clone, Debug, Default)]\n+struct Foo {\n+    inner: Arc<i32>,\n+}\n+\n+#[test]\n+fn test_unsized() {\n+    let x: Arc<[i32]> = Arc::new([1, 2, 3]);\n+    assert_eq!(format!(\"{:?}\", x), \"[1, 2, 3]\");\n+    let y = Arc::downgrade(&x.clone());\n+    drop(x);\n+    assert!(y.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_from_owned() {\n+    let foo = 123;\n+    let foo_arc = Arc::from(foo);\n+    assert!(123 == *foo_arc);\n+}\n+\n+#[test]\n+fn test_new_weak() {\n+    let foo: Weak<usize> = Weak::new();\n+    assert!(foo.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_ptr_eq() {\n+    let five = Arc::new(5);\n+    let same_five = five.clone();\n+    let other_five = Arc::new(5);\n+\n+    assert!(Arc::ptr_eq(&five, &same_five));\n+    assert!(!Arc::ptr_eq(&five, &other_five));\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support threads\n+fn test_weak_count_locked() {\n+    let mut a = Arc::new(atomic::AtomicBool::new(false));\n+    let a2 = a.clone();\n+    let t = thread::spawn(move || {\n+        for _i in 0..1000000 {\n+            Arc::get_mut(&mut a);\n+        }\n+        a.store(true, SeqCst);\n+    });\n+\n+    while !a2.load(SeqCst) {\n+        let n = Arc::weak_count(&a2);\n+        assert!(n < 2, \"bad weak count: {}\", n);\n+    }\n+    t.join().unwrap();\n+}\n+\n+#[test]\n+fn test_from_str() {\n+    let r: Arc<str> = Arc::from(\"foo\");\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_copy_from_slice() {\n+    let s: &[u32] = &[1, 2, 3];\n+    let r: Arc<[u32]> = Arc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_clone_from_slice() {\n+    #[derive(Clone, Debug, Eq, PartialEq)]\n+    struct X(u32);\n+\n+    let s: &[X] = &[X(1), X(2), X(3)];\n+    let r: Arc<[X]> = Arc::from(s);\n+\n+    assert_eq!(&r[..], s);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clone_from_slice_panic() {\n+    use std::string::{String, ToString};\n+\n+    struct Fail(u32, String);\n+\n+    impl Clone for Fail {\n+        fn clone(&self) -> Fail {\n+            if self.0 == 2 {\n+                panic!();\n+            }\n+            Fail(self.0, self.1.clone())\n+        }\n+    }\n+\n+    let s: &[Fail] = &[\n+        Fail(0, \"foo\".to_string()),\n+        Fail(1, \"bar\".to_string()),\n+        Fail(2, \"baz\".to_string()),\n+    ];\n+\n+    // Should panic, but not cause memory corruption\n+    let _r: Arc<[Fail]> = Arc::from(s);\n+}\n+\n+#[test]\n+fn test_from_box() {\n+    let b: Box<u32> = box 123;\n+    let r: Arc<u32> = Arc::from(b);\n+\n+    assert_eq!(*r, 123);\n+}\n+\n+#[test]\n+fn test_from_box_str() {\n+    use std::string::String;\n+\n+    let s = String::from(\"foo\").into_boxed_str();\n+    let r: Arc<str> = Arc::from(s);\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_from_box_slice() {\n+    let s = vec![1, 2, 3].into_boxed_slice();\n+    let r: Arc<[u32]> = Arc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_from_box_trait() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let b: Box<dyn Display> = box 123;\n+    let r: Arc<dyn Display> = Arc::from(b);\n+\n+    assert_eq!(r.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn test_from_box_trait_zero_sized() {\n+    use std::fmt::Debug;\n+\n+    let b: Box<dyn Debug> = box ();\n+    let r: Arc<dyn Debug> = Arc::from(b);\n+\n+    assert_eq!(format!(\"{:?}\", r), \"()\");\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    let v = vec![1, 2, 3];\n+    let r: Arc<[u32]> = Arc::from(v);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_downcast() {\n+    use std::any::Any;\n+\n+    let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n+    let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n+\n+    assert!(r1.clone().downcast::<u32>().is_err());\n+\n+    let r1i32 = r1.downcast::<i32>();\n+    assert!(r1i32.is_ok());\n+    assert_eq!(r1i32.unwrap(), Arc::new(i32::max_value()));\n+\n+    assert!(r2.clone().downcast::<i32>().is_err());\n+\n+    let r2str = r2.downcast::<&'static str>();\n+    assert!(r2str.is_ok());\n+    assert_eq!(r2str.unwrap(), Arc::new(\"abc\"));\n+}\n+\n+#[test]\n+fn test_array_from_slice() {\n+    let v = vec![1, 2, 3];\n+    let r: Arc<[u32]> = Arc::from(v);\n+\n+    let a: Result<Arc<[u32; 3]>, _> = r.clone().try_into();\n+    assert!(a.is_ok());\n+\n+    let a: Result<Arc<[u32; 2]>, _> = r.clone().try_into();\n+    assert!(a.is_err());\n+}"}, {"sha": "ed46ba8a1b938249dbb3abfa93e67c952d77d7ff", "filename": "src/liballoc/tests.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -0,0 +1,153 @@\n+//! Test for `boxed` mod.\n+\n+use core::any::Any;\n+use core::convert::TryInto;\n+use core::ops::Deref;\n+use core::result::Result::{Err, Ok};\n+use core::clone::Clone;\n+use core::f64;\n+use core::i64;\n+\n+use std::boxed::Box;\n+\n+#[test]\n+fn test_owned_clone() {\n+    let a = Box::new(5);\n+    let b: Box<i32> = a.clone();\n+    assert!(a == b);\n+}\n+\n+#[derive(PartialEq, Eq)]\n+struct Test;\n+\n+#[test]\n+fn any_move() {\n+    let a = Box::new(8) as Box<dyn Any>;\n+    let b = Box::new(Test) as Box<dyn Any>;\n+\n+    match a.downcast::<i32>() {\n+        Ok(a) => {\n+            assert!(a == Box::new(8));\n+        }\n+        Err(..) => panic!(),\n+    }\n+    match b.downcast::<Test>() {\n+        Ok(a) => {\n+            assert!(a == Box::new(Test));\n+        }\n+        Err(..) => panic!(),\n+    }\n+\n+    let a = Box::new(8) as Box<dyn Any>;\n+    let b = Box::new(Test) as Box<dyn Any>;\n+\n+    assert!(a.downcast::<Box<Test>>().is_err());\n+    assert!(b.downcast::<Box<i32>>().is_err());\n+}\n+\n+#[test]\n+fn test_show() {\n+    let a = Box::new(8) as Box<dyn Any>;\n+    let b = Box::new(Test) as Box<dyn Any>;\n+    let a_str = format!(\"{:?}\", a);\n+    let b_str = format!(\"{:?}\", b);\n+    assert_eq!(a_str, \"Any\");\n+    assert_eq!(b_str, \"Any\");\n+\n+    static EIGHT: usize = 8;\n+    static TEST: Test = Test;\n+    let a = &EIGHT as &dyn Any;\n+    let b = &TEST as &dyn Any;\n+    let s = format!(\"{:?}\", a);\n+    assert_eq!(s, \"Any\");\n+    let s = format!(\"{:?}\", b);\n+    assert_eq!(s, \"Any\");\n+}\n+\n+#[test]\n+fn deref() {\n+    fn homura<T: Deref<Target = i32>>(_: T) {}\n+    homura(Box::new(765));\n+}\n+\n+#[test]\n+fn raw_sized() {\n+    let x = Box::new(17);\n+    let p = Box::into_raw(x);\n+    unsafe {\n+        assert_eq!(17, *p);\n+        *p = 19;\n+        let y = Box::from_raw(p);\n+        assert_eq!(19, *y);\n+    }\n+}\n+\n+#[test]\n+fn raw_trait() {\n+    trait Foo {\n+        fn get(&self) -> u32;\n+        fn set(&mut self, value: u32);\n+    }\n+\n+    struct Bar(u32);\n+\n+    impl Foo for Bar {\n+        fn get(&self) -> u32 {\n+            self.0\n+        }\n+\n+        fn set(&mut self, value: u32) {\n+            self.0 = value;\n+        }\n+    }\n+\n+    let x: Box<dyn Foo> = Box::new(Bar(17));\n+    let p = Box::into_raw(x);\n+    unsafe {\n+        assert_eq!(17, (*p).get());\n+        (*p).set(19);\n+        let y: Box<dyn Foo> = Box::from_raw(p);\n+        assert_eq!(19, y.get());\n+    }\n+}\n+\n+#[test]\n+fn f64_slice() {\n+    let slice: &[f64] = &[-1.0, 0.0, 1.0, f64::INFINITY];\n+    let boxed: Box<[f64]> = Box::from(slice);\n+    assert_eq!(&*boxed, slice)\n+}\n+\n+#[test]\n+fn i64_slice() {\n+    let slice: &[i64] = &[i64::MIN, -2, -1, 0, 1, 2, i64::MAX];\n+    let boxed: Box<[i64]> = Box::from(slice);\n+    assert_eq!(&*boxed, slice)\n+}\n+\n+#[test]\n+fn str_slice() {\n+    let s = \"Hello, world!\";\n+    let boxed: Box<str> = Box::from(s);\n+    assert_eq!(&*boxed, s)\n+}\n+\n+#[test]\n+fn boxed_slice_from_iter() {\n+    let iter = 0..100;\n+    let boxed: Box<[u32]> = iter.collect();\n+    assert_eq!(boxed.len(), 100);\n+    assert_eq!(boxed[7], 7);\n+}\n+\n+#[test]\n+fn test_array_from_slice() {\n+    let v = vec![1, 2, 3];\n+    let r: Box<[u32]> = v.into_boxed_slice();\n+\n+    let a: Result<Box<[u32; 3]>, _> = r.clone().try_into();\n+    assert!(a.is_ok());\n+\n+    let a: Result<Box<[u32; 2]>, _> = r.clone().try_into();\n+    assert!(a.is_err());\n+}"}, {"sha": "cf2ad2a8e60338620de2fb9f931006f14d13f594", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -2,6 +2,8 @@ use std::any::Any;\n use std::sync::{Arc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n+use std::iter::TrustedLen;\n+use std::mem;\n \n #[test]\n fn uninhabited() {\n@@ -85,3 +87,122 @@ fn eq() {\n     assert!(!(x != x));\n     assert_eq!(*x.0.borrow(), 0);\n }\n+\n+// The test code below is identical to that in `rc.rs`.\n+// For better maintainability we therefore define this type alias.\n+type Rc<T> = Arc<T>;\n+\n+const SHARED_ITER_MAX: u16 = 100;\n+\n+fn assert_trusted_len<I: TrustedLen>(_: &I) {}\n+\n+#[test]\n+fn shared_from_iter_normal() {\n+    // Exercise the base implementation for non-`TrustedLen` iterators.\n+    {\n+        // `Filter` is never `TrustedLen` since we don't\n+        // know statically how many elements will be kept:\n+        let iter = (0..SHARED_ITER_MAX).filter(|x| x % 2 == 0).map(Box::new);\n+\n+        // Collecting into a `Vec<T>` or `Rc<[T]>` should make no difference:\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+\n+        // Clone a bit and let these get dropped.\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    } // Drop what hasn't been here.\n+}\n+\n+#[test]\n+fn shared_from_iter_trustedlen_normal() {\n+    // Exercise the `TrustedLen` implementation under normal circumstances\n+    // where `size_hint()` matches `(_, Some(exact_len))`.\n+    {\n+        let iter = (0..SHARED_ITER_MAX).map(Box::new);\n+        assert_trusted_len(&iter);\n+\n+        // Collecting into a `Vec<T>` or `Rc<[T]>` should make no difference:\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+        assert_eq!(mem::size_of::<Box<u16>>() * SHARED_ITER_MAX as usize, mem::size_of_val(&*rc));\n+\n+        // Clone a bit and let these get dropped.\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    } // Drop what hasn't been here.\n+\n+    // Try a ZST to make sure it is handled well.\n+    {\n+        let iter = (0..SHARED_ITER_MAX).map(|_| ());\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+        assert_eq!(0, mem::size_of_val(&*rc));\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    }\n+}\n+\n+#[test]\n+#[should_panic = \"I've almost got 99 problems.\"]\n+fn shared_from_iter_trustedlen_panic() {\n+    // Exercise the `TrustedLen` implementation when `size_hint()` matches\n+    // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n+    let iter = (0..SHARED_ITER_MAX)\n+        .map(|val| {\n+            match val {\n+                98 => panic!(\"I've almost got 99 problems.\"),\n+                _ => Box::new(val),\n+            }\n+        });\n+    assert_trusted_len(&iter);\n+    let _ = iter.collect::<Rc<[_]>>();\n+\n+    panic!(\"I am unreachable.\");\n+}\n+\n+#[test]\n+fn shared_from_iter_trustedlen_no_fuse() {\n+    // Exercise the `TrustedLen` implementation when `size_hint()` matches\n+    // `(_, Some(exact_len))` but where the iterator does not behave in a fused manner.\n+    struct Iter(std::vec::IntoIter<Option<Box<u8>>>);\n+\n+    unsafe impl TrustedLen for Iter {}\n+\n+    impl Iterator for Iter {\n+        fn size_hint(&self) -> (usize, Option<usize>) {\n+            (2, Some(2))\n+        }\n+\n+        type Item = Box<u8>;\n+\n+        fn next(&mut self) -> Option<Self::Item> {\n+            self.0.next().flatten()\n+        }\n+    }\n+\n+    let vec = vec![\n+        Some(Box::new(42)),\n+        Some(Box::new(24)),\n+        None,\n+        Some(Box::new(12)),\n+    ];\n+    let iter = Iter(vec.into_iter());\n+    assert_trusted_len(&iter);\n+    assert_eq!(\n+        &[Box::new(42), Box::new(24)],\n+        &*iter.collect::<Rc<[_]>>()\n+    );\n+}"}, {"sha": "266a0d055d5bc1a2a217fa8ccd40a86fcb181875", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -689,7 +689,10 @@ fn test_split_off_empty_left() {\n \n #[test]\n fn test_split_off_large_random_sorted() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let mut data = rand_data(1529);\n+    #[cfg(miri)]\n+    let mut data = rand_data(529);\n     // special case with maximum height.\n     data.sort();\n "}, {"sha": "62ccb53fcea18a936ce3f446489a5de54825adfe", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -10,7 +10,7 @@ fn test_clone_eq() {\n     m.insert(1);\n     m.insert(2);\n \n-    assert!(m.clone() == m);\n+    assert_eq!(m.clone(), m);\n }\n \n #[test]\n@@ -28,7 +28,7 @@ fn test_hash() {\n     y.insert(2);\n     y.insert(1);\n \n-    assert!(hash(&x) == hash(&y));\n+    assert_eq!(hash(&x), hash(&y));\n }\n \n fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)\n@@ -69,6 +69,11 @@ fn test_intersection() {\n     check_intersection(&[11, 1, 3, 77, 103, 5, -5],\n                        &[2, 11, 77, -9, -42, 5, 3],\n                        &[3, 5, 11, 77]);\n+\n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     let large = (0..1000).collect::<Vec<_>>();\n     check_intersection(&[], &large, &[]);\n     check_intersection(&large, &[], &[]);\n@@ -98,6 +103,11 @@ fn test_difference() {\n     check_difference(&[-5, 11, 22, 33, 40, 42],\n                      &[-12, -5, 14, 23, 34, 38, 39, 50],\n                      &[11, 22, 33, 40, 42]);\n+\n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     let large = (0..1000).collect::<Vec<_>>();\n     check_difference(&[], &large, &[]);\n     check_difference(&[-1], &large, &[-1]);\n@@ -143,8 +153,8 @@ fn test_union() {\n #[test]\n // Only tests the simple function definition with respect to intersection\n fn test_is_disjoint() {\n-    let one = [1].into_iter().collect::<BTreeSet<_>>();\n-    let two = [2].into_iter().collect::<BTreeSet<_>>();\n+    let one = [1].iter().collect::<BTreeSet<_>>();\n+    let two = [2].iter().collect::<BTreeSet<_>>();\n     assert!(one.is_disjoint(&two));\n }\n \n@@ -166,6 +176,17 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[1, 2], &[1]), false);\n     assert_eq!(is_subset(&[1, 2], &[1, 2]), true);\n     assert_eq!(is_subset(&[1, 2], &[2, 3]), false);\n+    assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n+                         &[-12, -5, 14, 23, 11, 34, 22, 38, 33, 42, 39, 40]),\n+               true);\n+    assert_eq!(is_subset(&[-5, 11, 22, 33, 40, 42],\n+                         &[-12, -5, 14, 23, 34, 38, 22, 11]),\n+               false);\n+\n+    if cfg!(miri) { // Miri is too slow\n+        return;\n+    }\n+\n     let large = (0..1000).collect::<Vec<_>>();\n     assert_eq!(is_subset(&[], &large), true);\n     assert_eq!(is_subset(&large, &[]), false);\n@@ -371,7 +392,10 @@ fn test_split_off_empty_left() {\n \n #[test]\n fn test_split_off_large_random_sorted() {\n+    #[cfg(not(miri))] // Miri is too slow\n     let mut data = rand_data(1529);\n+    #[cfg(miri)]\n+    let mut data = rand_data(529);\n     // special case with maximum height.\n     data.sort();\n "}, {"sha": "904b3e7e1b07cc4f23bd2ddae5e3063d1e335752", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,6 +1,6 @@\n use std::alloc::{Global, Alloc, Layout, System};\n \n-/// Issue #45955.\n+/// Issue #45955 and #62251.\n #[test]\n fn alloc_system_overaligned_request() {\n     check_overalign_requests(System)\n@@ -12,21 +12,23 @@ fn std_heap_overaligned_request() {\n }\n \n fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n-    let size = 8;\n-    let align = 16; // greater than size\n-    let iterations = 100;\n-    unsafe {\n-        let pointers: Vec<_> = (0..iterations).map(|_| {\n-            allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n-        }).collect();\n-        for &ptr in &pointers {\n-            assert_eq!((ptr.as_ptr() as usize) % align, 0,\n-                       \"Got a pointer less aligned than requested\")\n-        }\n+    for &align in &[4, 8, 16, 32] { // less than and bigger than `MIN_ALIGN`\n+        for &size in &[align/2, align-1] { // size less than alignment\n+            let iterations = 128;\n+            unsafe {\n+                let pointers: Vec<_> = (0..iterations).map(|_| {\n+                    allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n+                }).collect();\n+                for &ptr in &pointers {\n+                    assert_eq!((ptr.as_ptr() as usize) % align, 0,\n+                               \"Got a pointer less aligned than requested\")\n+                }\n \n-        // Clean up\n-        for &ptr in &pointers {\n-            allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n+                // Clean up\n+                for &ptr in &pointers {\n+                    allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "5723a30c0f34f62ec8829fde287e5877694ede5a", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -2,12 +2,13 @@\n #![feature(box_syntax)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n+#![feature(option_flattening)]\n #![feature(pattern)]\n #![feature(repeat_generic_slice)]\n+#![feature(trusted_len)]\n #![feature(try_reserve)]\n #![feature(unboxed_closures)]\n-#![feature(vecdeque_rotate)]\n-#![deny(rust_2018_idioms)]\n+#![feature(associated_type_bounds)]\n \n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;"}, {"sha": "8a26454c389d7c6855b661199084f7e386ebd97b", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -40,12 +40,10 @@ fn test_basic() {\n     assert_eq!(n.pop_front(), Some(1));\n }\n \n-#[cfg(test)]\n fn generate_test() -> LinkedList<i32> {\n     list_from(&[0, 1, 2, 3, 4, 5, 6])\n }\n \n-#[cfg(test)]\n fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n     v.iter().cloned().collect()\n }"}, {"sha": "7854ca0fc16b26936111d78926fff1252df1e960", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -2,6 +2,8 @@ use std::any::Any;\n use std::rc::{Rc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n+use std::mem;\n+use std::iter::TrustedLen;\n \n #[test]\n fn uninhabited() {\n@@ -85,3 +87,118 @@ fn eq() {\n     assert!(!(x != x));\n     assert_eq!(*x.0.borrow(), 0);\n }\n+\n+const SHARED_ITER_MAX: u16 = 100;\n+\n+fn assert_trusted_len<I: TrustedLen>(_: &I) {}\n+\n+#[test]\n+fn shared_from_iter_normal() {\n+    // Exercise the base implementation for non-`TrustedLen` iterators.\n+    {\n+        // `Filter` is never `TrustedLen` since we don't\n+        // know statically how many elements will be kept:\n+        let iter = (0..SHARED_ITER_MAX).filter(|x| x % 2 == 0).map(Box::new);\n+\n+        // Collecting into a `Vec<T>` or `Rc<[T]>` should make no difference:\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+\n+        // Clone a bit and let these get dropped.\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    } // Drop what hasn't been here.\n+}\n+\n+#[test]\n+fn shared_from_iter_trustedlen_normal() {\n+    // Exercise the `TrustedLen` implementation under normal circumstances\n+    // where `size_hint()` matches `(_, Some(exact_len))`.\n+    {\n+        let iter = (0..SHARED_ITER_MAX).map(Box::new);\n+        assert_trusted_len(&iter);\n+\n+        // Collecting into a `Vec<T>` or `Rc<[T]>` should make no difference:\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+        assert_eq!(mem::size_of::<Box<u16>>() * SHARED_ITER_MAX as usize, mem::size_of_val(&*rc));\n+\n+        // Clone a bit and let these get dropped.\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    } // Drop what hasn't been here.\n+\n+    // Try a ZST to make sure it is handled well.\n+    {\n+        let iter = (0..SHARED_ITER_MAX).map(|_| ());\n+        let vec = iter.clone().collect::<Vec<_>>();\n+        let rc = iter.collect::<Rc<[_]>>();\n+        assert_eq!(&*vec, &*rc);\n+        assert_eq!(0, mem::size_of_val(&*rc));\n+        {\n+            let _rc_2 = rc.clone();\n+            let _rc_3 = rc.clone();\n+            let _rc_4 = Rc::downgrade(&_rc_3);\n+        }\n+    }\n+}\n+\n+#[test]\n+#[should_panic = \"I've almost got 99 problems.\"]\n+fn shared_from_iter_trustedlen_panic() {\n+    // Exercise the `TrustedLen` implementation when `size_hint()` matches\n+    // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n+    let iter = (0..SHARED_ITER_MAX)\n+        .map(|val| {\n+            match val {\n+                98 => panic!(\"I've almost got 99 problems.\"),\n+                _ => Box::new(val),\n+            }\n+        });\n+    assert_trusted_len(&iter);\n+    let _ = iter.collect::<Rc<[_]>>();\n+\n+    panic!(\"I am unreachable.\");\n+}\n+\n+#[test]\n+fn shared_from_iter_trustedlen_no_fuse() {\n+    // Exercise the `TrustedLen` implementation when `size_hint()` matches\n+    // `(_, Some(exact_len))` but where the iterator does not behave in a fused manner.\n+    struct Iter(std::vec::IntoIter<Option<Box<u8>>>);\n+\n+    unsafe impl TrustedLen for Iter {}\n+\n+    impl Iterator for Iter {\n+        fn size_hint(&self) -> (usize, Option<usize>) {\n+            (2, Some(2))\n+        }\n+\n+        type Item = Box<u8>;\n+\n+        fn next(&mut self) -> Option<Self::Item> {\n+            self.0.next().flatten()\n+        }\n+    }\n+\n+    let vec = vec![\n+        Some(Box::new(42)),\n+        Some(Box::new(24)),\n+        None,\n+        Some(Box::new(12)),\n+    ];\n+    let iter = Iter(vec.into_iter());\n+    assert_trusted_len(&iter);\n+    assert_eq!(\n+        &[Box::new(42), Box::new(24)],\n+        &*iter.collect::<Rc<[_]>>()\n+    );\n+}"}, {"sha": "4332b2e90fdaf0493deb3f1489137632fa2ede6e", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1108,6 +1108,16 @@ fn test_iterator_last() {\n     assert_eq!(it.last(), Some('m'));\n }\n \n+#[test]\n+fn test_chars_debug() {\n+    let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+    let c = s.chars();\n+    assert_eq!(\n+        format!(\"{:?}\", c),\n+        r#\"Chars(['\u0e28', '\u0e44', '\u0e17', '\u0e22', '\u4e2d', '\u534e', 'V', 'i', '\u1ec7', 't', ' ', 'N', 'a', 'm'])\"#\n+    );\n+}\n+\n #[test]\n fn test_bytesator() {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n@@ -1628,10 +1638,12 @@ mod pattern {\n         }\n     }\n \n-    fn cmp_search_to_vec<'a, P: Pattern<'a>>(rev: bool, pat: P, haystack: &'a str,\n-                                             right: Vec<SearchStep>)\n-    where P::Searcher: ReverseSearcher<'a>\n-    {\n+    fn cmp_search_to_vec<'a>(\n+        rev: bool,\n+        pat: impl Pattern<'a, Searcher: ReverseSearcher<'a>>,\n+        haystack: &'a str,\n+        right: Vec<SearchStep>\n+    ) {\n         let mut searcher = pat.into_searcher(haystack);\n         let mut v = vec![];\n         loop {"}, {"sha": "55edf56345b59a4cb270129610b0318a9f2163dd", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,5 +1,5 @@\n use std::borrow::Cow;\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n use std::mem::size_of;\n use std::{usize, isize};\n \n@@ -566,11 +566,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr) = empty_string.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr) = empty_string.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -590,7 +590,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -629,10 +629,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr) = empty_string.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_string.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -651,7 +651,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {"}, {"sha": "29a22aa0315b048199497108d04b2bb1eac04e46", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 141, "deletions": 11, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,10 +1,8 @@\n-#![cfg(not(miri))]\n-\n use std::borrow::Cow;\n use std::mem::size_of;\n use std::{usize, isize};\n use std::vec::{Drain, IntoIter};\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n \n struct DropCounter<'a> {\n     count: &'a mut u32,\n@@ -946,6 +944,115 @@ fn drain_filter_complex() {\n     }\n }\n \n+#[test]\n+#[cfg(not(miri))] // Miri does not support catching panics\n+fn drain_filter_consumed_panic() {\n+    use std::rc::Rc;\n+    use std::sync::Mutex;\n+\n+    struct Check {\n+        index: usize,\n+        drop_counts: Rc<Mutex<Vec<usize>>>,\n+    };\n+\n+    impl Drop for Check {\n+        fn drop(&mut self) {\n+            self.drop_counts.lock().unwrap()[self.index] += 1;\n+            println!(\"drop: {}\", self.index);\n+        }\n+    }\n+\n+    let check_count = 10;\n+    let drop_counts = Rc::new(Mutex::new(vec![0_usize; check_count]));\n+    let mut data: Vec<Check> = (0..check_count)\n+        .map(|index| Check { index, drop_counts: Rc::clone(&drop_counts) })\n+        .collect();\n+\n+    let _ = std::panic::catch_unwind(move || {\n+        let filter = |c: &mut Check| {\n+            if c.index == 2 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            // Verify that if the filter could panic again on another element\n+            // that it would not cause a double panic and all elements of the\n+            // vec would still be dropped exactly once.\n+            if c.index == 4 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            c.index < 6\n+        };\n+        let drain = data.drain_filter(filter);\n+\n+        // NOTE: The DrainFilter is explictly consumed\n+        drain.for_each(drop);\n+    });\n+\n+    let drop_counts = drop_counts.lock().unwrap();\n+    assert_eq!(check_count, drop_counts.len());\n+\n+    for (index, count) in drop_counts.iter().cloned().enumerate() {\n+        assert_eq!(1, count, \"unexpected drop count at index: {} (count: {})\", index, count);\n+    }\n+}\n+\n+#[test]\n+#[cfg(not(miri))] // Miri does not support catching panics\n+fn drain_filter_unconsumed_panic() {\n+    use std::rc::Rc;\n+    use std::sync::Mutex;\n+\n+    struct Check {\n+        index: usize,\n+        drop_counts: Rc<Mutex<Vec<usize>>>,\n+    };\n+\n+    impl Drop for Check {\n+        fn drop(&mut self) {\n+            self.drop_counts.lock().unwrap()[self.index] += 1;\n+            println!(\"drop: {}\", self.index);\n+        }\n+    }\n+\n+    let check_count = 10;\n+    let drop_counts = Rc::new(Mutex::new(vec![0_usize; check_count]));\n+    let mut data: Vec<Check> = (0..check_count)\n+        .map(|index| Check { index, drop_counts: Rc::clone(&drop_counts) })\n+        .collect();\n+\n+    let _ = std::panic::catch_unwind(move || {\n+        let filter = |c: &mut Check| {\n+            if c.index == 2 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            // Verify that if the filter could panic again on another element\n+            // that it would not cause a double panic and all elements of the\n+            // vec would still be dropped exactly once.\n+            if c.index == 4 {\n+                panic!(\"panic at index: {}\", c.index);\n+            }\n+            c.index < 6\n+        };\n+        let _drain = data.drain_filter(filter);\n+\n+        // NOTE: The DrainFilter is dropped without being consumed\n+    });\n+\n+    let drop_counts = drop_counts.lock().unwrap();\n+    assert_eq!(check_count, drop_counts.len());\n+\n+    for (index, count) in drop_counts.iter().cloned().enumerate() {\n+        assert_eq!(1, count, \"unexpected drop count at index: {} (count: {})\", index, count);\n+    }\n+}\n+\n+#[test]\n+fn drain_filter_unconsumed() {\n+    let mut vec = vec![1, 2, 3, 4];\n+    let drain = vec.drain_filter(|&mut x| x % 2 != 0);\n+    drop(drain);\n+    assert_eq!(vec, [2, 4]);\n+}\n+\n #[test]\n fn test_reserve_exact() {\n     // This is all the same as test_reserve\n@@ -971,6 +1078,7 @@ fn test_reserve_exact() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve() {\n \n     // These are the interesting cases:\n@@ -1013,11 +1121,11 @@ fn test_try_reserve() {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1037,7 +1145,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1060,7 +1168,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1073,6 +1181,7 @@ fn test_try_reserve() {\n }\n \n #[test]\n+#[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n \n     // This is exactly the same as test_try_reserve with the method changed.\n@@ -1100,10 +1209,10 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an overflow!\") }\n         } else {\n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n \n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n             } else { panic!(\"usize::MAX should trigger an OOM!\") }\n         }\n     }\n@@ -1122,7 +1231,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1143,11 +1252,32 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n         } else { panic!(\"usize::MAX should trigger an overflow!\") }\n     }\n \n }\n+\n+#[test]\n+fn test_stable_push_pop() {\n+    // Test that, if we reserved enough space, adding and removing elements does not\n+    // invalidate references into the vector (such as `v0`).  This test also\n+    // runs in Miri, which would detect such problems.\n+    let mut v = Vec::with_capacity(10);\n+    v.push(13);\n+\n+    // laundering the lifetime -- we take care that `v` does not reallocate, so that's okay.\n+    let v0 = unsafe { &*(&v[0] as *const _) };\n+\n+    // Now do a bunch of things and occasionally use `v0` again to assert it is still valid.\n+    v.push(1);\n+    v.push(2);\n+    v.insert(1, 1);\n+    assert_eq!(*v0, 13);\n+    v.remove(1);\n+    v.pop().unwrap();\n+    assert_eq!(*v0, 13);\n+}"}, {"sha": "d49b553fc0217a5161e9493220d25003b2221856", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -1,6 +1,6 @@\n use std::fmt::Debug;\n use std::collections::{VecDeque, vec_deque::Drain};\n-use std::collections::CollectionAllocErr::*;\n+use std::collections::TryReserveError::*;\n use std::mem::size_of;\n use std::{usize, isize};\n \n@@ -44,7 +44,6 @@ fn test_simple() {\n     assert_eq!(d[3], 4);\n }\n \n-#[cfg(test)]\n fn test_parameterized<T: Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n     let mut deq = VecDeque::new();\n     assert_eq!(deq.len(), 0);\n@@ -1169,7 +1168,7 @@ fn test_try_reserve() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr) = empty_bytes.try_reserve(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1189,7 +1188,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should always overflow in the add-to-len\n@@ -1212,7 +1211,7 @@ fn test_try_reserve() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         // Should fail in the mul-by-size\n@@ -1257,7 +1256,7 @@ fn test_try_reserve_exact() {\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocErr) = empty_bytes.try_reserve_exact(MAX_CAP) {\n+            if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n     }\n@@ -1276,7 +1275,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n+            if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n@@ -1297,7 +1296,7 @@ fn test_try_reserve_exact() {\n             if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n         } else {\n-            if let Err(AllocErr) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n             } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {"}, {"sha": "d2798955c46a97105cec55fa5e5f3b4de2def63b", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 204, "deletions": 81, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -56,6 +56,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n use core::hash::{self, Hash};\n@@ -69,7 +70,7 @@ use core::ptr::{self, NonNull};\n use core::slice::{self, SliceIndex};\n \n use crate::borrow::{ToOwned, Cow};\n-use crate::collections::CollectionAllocErr;\n+use crate::collections::TryReserveError;\n use crate::boxed::Box;\n use crate::raw_vec::RawVec;\n \n@@ -432,7 +433,7 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn capacity(&self) -> usize {\n-        self.buf.cap()\n+        self.buf.capacity()\n     }\n \n     /// Reserves capacity for at least `additional` more elements to be inserted\n@@ -497,9 +498,9 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     ///     let mut output = Vec::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -515,7 +516,7 @@ impl<T> Vec<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+    pub fn try_reserve(&mut self, additional: usize) -> Result<(), TryReserveError> {\n         self.buf.try_reserve(self.len, additional)\n     }\n \n@@ -537,9 +538,9 @@ impl<T> Vec<T> {\n     ///\n     /// ```\n     /// #![feature(try_reserve)]\n-    /// use std::collections::CollectionAllocErr;\n+    /// use std::collections::TryReserveError;\n     ///\n-    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, CollectionAllocErr> {\n+    /// fn process_data(data: &[u32]) -> Result<Vec<u32>, TryReserveError> {\n     ///     let mut output = Vec::new();\n     ///\n     ///     // Pre-reserve the memory, exiting if we can't\n@@ -555,7 +556,7 @@ impl<T> Vec<T> {\n     /// # process_data(&[1, 2, 3]).expect(\"why is the test harness OOMing on 12 bytes?\");\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n-    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), CollectionAllocErr>  {\n+    pub fn try_reserve_exact(&mut self, additional: usize) -> Result<(), TryReserveError>  {\n         self.buf.try_reserve_exact(self.len, additional)\n     }\n \n@@ -735,6 +736,75 @@ impl<T> Vec<T> {\n         self\n     }\n \n+    /// Returns a raw pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    /// Modifying the vector may cause its buffer to be reallocated,\n+    /// which would also make any pointers to it invalid.\n+    ///\n+    /// The caller must also ensure that the memory the pointer (non-transitively) points to\n+    /// is never written to (except inside an `UnsafeCell`) using this pointer or any pointer\n+    /// derived from it. If you need to mutate the contents of the slice, use [`as_mut_ptr`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = vec![1, 2, 4];\n+    /// let x_ptr = x.as_ptr();\n+    ///\n+    /// unsafe {\n+    ///     for i in 0..x.len() {\n+    ///         assert_eq!(*x_ptr.add(i), 1 << i);\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// [`as_mut_ptr`]: #method.as_mut_ptr\n+    #[stable(feature = \"vec_as_ptr\", since = \"1.37.0\")]\n+    #[inline]\n+    pub fn as_ptr(&self) -> *const T {\n+        // We shadow the slice method of the same name to avoid going through\n+        // `deref`, which creates an intermediate reference.\n+        let ptr = self.buf.ptr();\n+        unsafe { assume(!ptr.is_null()); }\n+        ptr\n+    }\n+\n+    /// Returns an unsafe mutable pointer to the vector's buffer.\n+    ///\n+    /// The caller must ensure that the vector outlives the pointer this\n+    /// function returns, or else it will end up pointing to garbage.\n+    /// Modifying the vector may cause its buffer to be reallocated,\n+    /// which would also make any pointers to it invalid.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// // Allocate vector big enough for 4 elements.\n+    /// let size = 4;\n+    /// let mut x: Vec<i32> = Vec::with_capacity(size);\n+    /// let x_ptr = x.as_mut_ptr();\n+    ///\n+    /// // Initialize elements via raw pointer writes, then set length.\n+    /// unsafe {\n+    ///     for i in 0..size {\n+    ///         *x_ptr.add(i) = i as i32;\n+    ///     }\n+    ///     x.set_len(size);\n+    /// }\n+    /// assert_eq!(&*x, &[0,1,2,3]);\n+    /// ```\n+    #[stable(feature = \"vec_as_ptr\", since = \"1.37.0\")]\n+    #[inline]\n+    pub fn as_mut_ptr(&mut self) -> *mut T {\n+        // We shadow the slice method of the same name to avoid going through\n+        // `deref_mut`, which creates an intermediate reference.\n+        let ptr = self.buf.ptr();\n+        unsafe { assume(!ptr.is_null()); }\n+        ptr\n+    }\n+\n     /// Forces the length of the vector to `new_len`.\n     ///\n     /// This is a low-level operation that maintains none of the normal\n@@ -878,7 +948,7 @@ impl<T> Vec<T> {\n         assert!(index <= len);\n \n         // space for the new element\n-        if len == self.buf.cap() {\n+        if len == self.buf.capacity() {\n             self.reserve(1);\n         }\n \n@@ -1029,7 +1099,7 @@ impl<T> Vec<T> {\n     pub fn push(&mut self, value: T) {\n         // This will panic or abort if we would allocate > isize::MAX bytes\n         // or if the length increment would overflow for zero-sized types.\n-        if self.len == self.buf.cap() {\n+        if self.len == self.buf.capacity() {\n             self.reserve(1);\n         }\n         unsafe {\n@@ -1094,7 +1164,7 @@ impl<T> Vec<T> {\n         let count = (*other).len();\n         self.reserve(count);\n         let len = self.len();\n-        ptr::copy_nonoverlapping(other as *const T, self.get_unchecked_mut(len), count);\n+        ptr::copy_nonoverlapping(other as *const T, self.as_mut_ptr().add(len), count);\n         self.len += count;\n     }\n \n@@ -1298,6 +1368,40 @@ impl<T> Vec<T> {\n             self.truncate(new_len);\n         }\n     }\n+\n+    /// Consumes and leaks the `Vec`, returning a mutable reference to the contents,\n+    /// `&'a mut [T]`. Note that the type `T` must outlive the chosen lifetime\n+    /// `'a`. If the type has only static references, or none at all, then this\n+    /// may be chosen to be `'static`.\n+    ///\n+    /// This function is similar to the `leak` function on `Box`.\n+    ///\n+    /// This function is mainly useful for data that lives for the remainder of\n+    /// the program's life. Dropping the returned reference will cause a memory\n+    /// leak.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Simple usage:\n+    ///\n+    /// ```\n+    /// #![feature(vec_leak)]\n+    ///\n+    /// fn main() {\n+    ///     let x = vec![1, 2, 3];\n+    ///     let static_ref: &'static mut [usize] = Vec::leak(x);\n+    ///     static_ref[0] += 1;\n+    ///     assert_eq!(static_ref, &[2, 2, 3]);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"vec_leak\", issue = \"62195\")]\n+    #[inline]\n+    pub fn leak<'a>(vec: Vec<T>) -> &'a mut [T]\n+    where\n+        T: 'a // Technically not needed, but kept to be explicit.\n+    {\n+        Box::leak(vec.into_boxed_slice())\n+    }\n }\n \n impl<T: Clone> Vec<T> {\n@@ -1706,9 +1810,7 @@ impl<T> ops::Deref for Vec<T> {\n \n     fn deref(&self) -> &[T] {\n         unsafe {\n-            let p = self.buf.ptr();\n-            assume(!p.is_null());\n-            slice::from_raw_parts(p, self.len)\n+            slice::from_raw_parts(self.as_ptr(), self.len)\n         }\n     }\n }\n@@ -1717,9 +1819,7 @@ impl<T> ops::Deref for Vec<T> {\n impl<T> ops::DerefMut for Vec<T> {\n     fn deref_mut(&mut self) -> &mut [T] {\n         unsafe {\n-            let ptr = self.buf.ptr();\n-            assume(!ptr.is_null());\n-            slice::from_raw_parts_mut(ptr, self.len)\n+            slice::from_raw_parts_mut(self.as_mut_ptr(), self.len)\n         }\n     }\n }\n@@ -1754,13 +1854,12 @@ impl<T> IntoIterator for Vec<T> {\n     fn into_iter(mut self) -> IntoIter<T> {\n         unsafe {\n             let begin = self.as_mut_ptr();\n-            assume(!begin.is_null());\n             let end = if mem::size_of::<T>() == 0 {\n                 arith_offset(begin as *const i8, self.len() as isize) as *const T\n             } else {\n                 begin.add(self.len()) as *const T\n             };\n-            let cap = self.buf.cap();\n+            let cap = self.buf.capacity();\n             mem::forget(self);\n             IntoIter {\n                 buf: NonNull::new_unchecked(begin),\n@@ -1954,16 +2053,14 @@ impl<T> Vec<T> {\n     /// with the given `replace_with` iterator and yields the removed items.\n     /// `replace_with` does not need to be the same length as `range`.\n     ///\n-    /// Note 1: The element range is removed even if the iterator is not\n-    /// consumed until the end.\n+    /// The element range is removed even if the iterator is not consumed until the end.\n     ///\n-    /// Note 2: It is unspecified how many elements are removed from the vector,\n+    /// It is unspecified how many elements are removed from the vector\n     /// if the `Splice` value is leaked.\n     ///\n-    /// Note 3: The input iterator `replace_with` is only consumed\n-    /// when the `Splice` value is dropped.\n+    /// The input iterator `replace_with` is only consumed when the `Splice` value is dropped.\n     ///\n-    /// Note 4: This is optimal if:\n+    /// This is optimal if:\n     ///\n     /// * The tail (elements in the vector after `range`) is empty,\n     /// * or `replace_with` yields fewer elements than `range`\u2019s length\n@@ -2056,6 +2153,7 @@ impl<T> Vec<T> {\n             del: 0,\n             old_len,\n             pred: filter,\n+            panic_flag: false,\n         }\n     }\n }\n@@ -2074,47 +2172,36 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n }\n \n macro_rules! __impl_slice_eq1 {\n-    ($Lhs: ty, $Rhs: ty) => {\n-        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n-    };\n-    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n+    ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n+        where\n+            A: PartialEq<B>,\n+            $($constraints)*\n+        {\n             #[inline]\n-            fn eq(&self, other: &$Rhs) -> bool { self[..] == other[..] }\n+            fn eq(&self, other: &$rhs) -> bool { self[..] == other[..] }\n             #[inline]\n-            fn ne(&self, other: &$Rhs) -> bool { self[..] != other[..] }\n+            fn ne(&self, other: &$rhs) -> bool { self[..] != other[..] }\n         }\n     }\n }\n \n-__impl_slice_eq1! { Vec<A>, Vec<B> }\n-__impl_slice_eq1! { Vec<A>, &'b [B] }\n-__impl_slice_eq1! { Vec<A>, &'b mut [B] }\n-__impl_slice_eq1! { Cow<'a, [A]>, &'b [B], Clone }\n-__impl_slice_eq1! { Cow<'a, [A]>, &'b mut [B], Clone }\n-__impl_slice_eq1! { Cow<'a, [A]>, Vec<B>, Clone }\n+__impl_slice_eq1! { [] Vec<A>, Vec<B>, }\n+__impl_slice_eq1! { [] Vec<A>, &[B], }\n+__impl_slice_eq1! { [] Vec<A>, &mut [B], }\n+__impl_slice_eq1! { [] Cow<'_, [A]>, &[B], A: Clone }\n+__impl_slice_eq1! { [] Cow<'_, [A]>, &mut [B], A: Clone }\n+__impl_slice_eq1! { [] Cow<'_, [A]>, Vec<B>, A: Clone }\n+__impl_slice_eq1! { [const N: usize] Vec<A>, [B; N], [B; N]: LengthAtMost32 }\n+__impl_slice_eq1! { [const N: usize] Vec<A>, &[B; N], [B; N]: LengthAtMost32 }\n \n-macro_rules! array_impls {\n-    ($($N: expr)+) => {\n-        $(\n-            // NOTE: some less important impls are omitted to reduce code bloat\n-            __impl_slice_eq1! { Vec<A>, [B; $N] }\n-            __impl_slice_eq1! { Vec<A>, &'b [B; $N] }\n-            // __impl_slice_eq1! { Vec<A>, &'b mut [B; $N] }\n-            // __impl_slice_eq1! { Cow<'a, [A]>, [B; $N], Clone }\n-            // __impl_slice_eq1! { Cow<'a, [A]>, &'b [B; $N], Clone }\n-            // __impl_slice_eq1! { Cow<'a, [A]>, &'b mut [B; $N], Clone }\n-        )+\n-    }\n-}\n-\n-array_impls! {\n-     0  1  2  3  4  5  6  7  8  9\n-    10 11 12 13 14 15 16 17 18 19\n-    20 21 22 23 24 25 26 27 28 29\n-    30 31 32\n-}\n+// NOTE: some less important impls are omitted to reduce code bloat\n+// FIXME(Centril): Reconsider this?\n+//__impl_slice_eq1! { [const N: usize] Vec<A>, &mut [B; N], [B; N]: LengthAtMost32 }\n+//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, [B; N], [B; N]: LengthAtMost32 }\n+//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &[B; N], [B; N]: LengthAtMost32 }\n+//__impl_slice_eq1! { [const N: usize] Cow<'a, [A]>, &mut [B; N], [B; N]: LengthAtMost32 }\n \n /// Implements comparison of vectors, lexicographically.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2395,11 +2482,6 @@ impl<T> Iterator for IntoIter<T> {\n     fn count(self) -> usize {\n         self.len()\n     }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<T> {\n-        self.next_back()\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2519,11 +2601,6 @@ impl<T> Iterator for Drain<'_, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n-\n-    #[inline]\n-    fn last(mut self) -> Option<T> {\n-        self.next_back()\n-    }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n@@ -2593,10 +2670,6 @@ impl<I: Iterator> Iterator for Splice<'_, I> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.drain.size_hint()\n     }\n-\n-    fn last(mut self) -> Option<Self::Item> {\n-        self.next_back()\n-    }\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n@@ -2697,10 +2770,20 @@ pub struct DrainFilter<'a, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     vec: &'a mut Vec<T>,\n+    /// The index of the item that will be inspected by the next call to `next`.\n     idx: usize,\n+    /// The number of items that have been drained (removed) thus far.\n     del: usize,\n+    /// The original length of `vec` prior to draining.\n     old_len: usize,\n+    /// The filter test predicate.\n     pred: F,\n+    /// A flag that indicates a panic has occured in the filter test prodicate.\n+    /// This is used as a hint in the drop implmentation to prevent consumption\n+    /// of the remainder of the `DrainFilter`. Any unprocessed items will be\n+    /// backshifted in the `vec`, but no further items will be dropped or\n+    /// tested by the filter predicate.\n+    panic_flag: bool,\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n@@ -2711,20 +2794,23 @@ impl<T, F> Iterator for DrainFilter<'_, T, F>\n \n     fn next(&mut self) -> Option<T> {\n         unsafe {\n-            while self.idx != self.old_len {\n+            while self.idx < self.old_len {\n                 let i = self.idx;\n-                self.idx += 1;\n                 let v = slice::from_raw_parts_mut(self.vec.as_mut_ptr(), self.old_len);\n-                if (self.pred)(&mut v[i]) {\n+                self.panic_flag = true;\n+                let drained = (self.pred)(&mut v[i]);\n+                self.panic_flag = false;\n+                // Update the index *after* the predicate is called. If the index\n+                // is updated prior and the predicate panics, the element at this\n+                // index would be leaked.\n+                self.idx += 1;\n+                if drained {\n                     self.del += 1;\n                     return Some(ptr::read(&v[i]));\n                 } else if self.del > 0 {\n                     let del = self.del;\n                     let src: *const T = &v[i];\n                     let dst: *mut T = &mut v[i - del];\n-                    // This is safe because self.vec has length 0\n-                    // thus its elements will not have Drop::drop\n-                    // called on them in the event of a panic.\n                     ptr::copy_nonoverlapping(src, dst, 1);\n                 }\n             }\n@@ -2742,9 +2828,46 @@ impl<T, F> Drop for DrainFilter<'_, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n-        self.for_each(drop);\n-        unsafe {\n-            self.vec.set_len(self.old_len - self.del);\n+        struct BackshiftOnDrop<'a, 'b, T, F>\n+            where\n+                F: FnMut(&mut T) -> bool,\n+        {\n+            drain: &'b mut DrainFilter<'a, T, F>,\n+        }\n+\n+        impl<'a, 'b, T, F> Drop for BackshiftOnDrop<'a, 'b, T, F>\n+            where\n+                F: FnMut(&mut T) -> bool\n+        {\n+            fn drop(&mut self) {\n+                unsafe {\n+                    if self.drain.idx < self.drain.old_len && self.drain.del > 0 {\n+                        // This is a pretty messed up state, and there isn't really an\n+                        // obviously right thing to do. We don't want to keep trying\n+                        // to execute `pred`, so we just backshift all the unprocessed\n+                        // elements and tell the vec that they still exist. The backshift\n+                        // is required to prevent a double-drop of the last successfully\n+                        // drained item prior to a panic in the predicate.\n+                        let ptr = self.drain.vec.as_mut_ptr();\n+                        let src = ptr.add(self.drain.idx);\n+                        let dst = src.sub(self.drain.del);\n+                        let tail_len = self.drain.old_len - self.drain.idx;\n+                        src.copy_to(dst, tail_len);\n+                    }\n+                    self.drain.vec.set_len(self.drain.old_len - self.drain.del);\n+                }\n+            }\n+        }\n+\n+        let backshift = BackshiftOnDrop {\n+            drain: self\n+        };\n+\n+        // Attempt to consume any remaining elements if the filter predicate\n+        // has not yet panicked. We'll backshift any remaining elements\n+        // whether we've already panicked or if the consumption here panics.\n+        if !backshift.drain.panic_flag {\n+            backshift.drain.for_each(drop);\n         }\n     }\n }"}, {"sha": "2643912f6d7d6caed2619450ef7307be05d3b332", "filename": "src/libarena/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -7,7 +7,6 @@ edition = \"2018\"\n [lib]\n name = \"arena\"\n path = \"lib.rs\"\n-crate-type = [\"dylib\"]\n \n [dependencies]\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "690d8344acff96b8667fefe0b10f2972a8e0c650", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 32, "deletions": 230, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90", "patch": "@@ -11,9 +11,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        test(no_crate_inject, attr(deny(warnings))))]\n \n-#![deny(rust_2018_idioms)]\n-#![deny(internal)]\n-\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n #![feature(raw_vec_internals)]\n@@ -99,7 +96,7 @@ impl<T> TypedArenaChunk<T> {\n                 // A pointer as large as possible for zero-sized elements.\n                 !0 as *mut T\n             } else {\n-                self.start().add(self.storage.cap())\n+                self.start().add(self.storage.capacity())\n             }\n         }\n     }\n@@ -113,8 +110,8 @@ impl<T> Default for TypedArena<T> {\n         TypedArena {\n             // We set both `ptr` and `end` to 0 so that the first call to\n             // alloc() will trigger a grow().\n-            ptr: Cell::new(0 as *mut T),\n-            end: Cell::new(0 as *mut T),\n+            ptr: Cell::new(ptr::null_mut()),\n+            end: Cell::new(ptr::null_mut()),\n             chunks: RefCell::new(vec![]),\n             _own: PhantomData,\n         }\n@@ -270,7 +267,7 @@ impl<T> TypedArena<T> {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n-                    new_capacity = last_chunk.storage.cap();\n+                    new_capacity = last_chunk.storage.capacity();\n                     loop {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n                         if new_capacity >= currently_used_cap + n {\n@@ -369,8 +366,8 @@ impl Default for DroplessArena {\n     #[inline]\n     fn default() -> DroplessArena {\n         DroplessArena {\n-            ptr: Cell::new(0 as *mut u8),\n-            end: Cell::new(0 as *mut u8),\n+            ptr: Cell::new(ptr::null_mut()),\n+            end: Cell::new(ptr::null_mut()),\n             chunks: Default::default(),\n         }\n     }\n@@ -405,7 +402,7 @@ impl DroplessArena {\n                     self.end.set(last_chunk.end());\n                     return;\n                 } else {\n-                    new_capacity = last_chunk.storage.cap();\n+                    new_capacity = last_chunk.storage.capacity();\n                     loop {\n                         new_capacity = new_capacity.checked_mul(2).unwrap();\n                         if new_capacity >= used_bytes + needed_bytes {\n@@ -486,9 +483,31 @@ impl DroplessArena {\n         }\n     }\n \n+    #[inline]\n+    unsafe fn write_from_iter<T, I: Iterator<Item = T>>(\n+        &self,\n+        mut iter: I,\n+        len: usize,\n+        mem: *mut T,\n+    ) -> &mut [T] {\n+        let mut i = 0;\n+        // Use a manual loop since LLVM manages to optimize it better for\n+        // slice iterators\n+        loop {\n+            let value = iter.next();\n+            if i >= len || value.is_none() {\n+                // We only return as many items as the iterator gave us, even\n+                // though it was supposed to give us `len`\n+                return slice::from_raw_parts_mut(mem, i);\n+            }\n+            ptr::write(mem.offset(i as isize), value.unwrap());\n+            i += 1;\n+        }\n+    }\n+\n     #[inline]\n     pub fn alloc_from_iter<T, I: IntoIterator<Item = T>>(&self, iter: I) -> &mut [T] {\n-        let mut iter = iter.into_iter();\n+        let iter = iter.into_iter();\n         assert!(mem::size_of::<T>() != 0);\n         assert!(!mem::needs_drop::<T>());\n \n@@ -505,10 +524,7 @@ impl DroplessArena {\n                 let size = len.checked_mul(mem::size_of::<T>()).unwrap();\n                 let mem = self.alloc_raw(size, mem::align_of::<T>()) as *mut _ as *mut T;\n                 unsafe {\n-                    for i in 0..len {\n-                        ptr::write(mem.offset(i as isize), iter.next().unwrap())\n-                    }\n-                    slice::from_raw_parts_mut(mem, len)\n+                    self.write_from_iter(iter, len, mem)\n                 }\n             }\n             (_, _) => {\n@@ -597,218 +613,4 @@ impl SyncDroplessArena {\n }\n \n #[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use test::Bencher;\n-    use super::TypedArena;\n-    use std::cell::Cell;\n-\n-    #[allow(dead_code)]\n-    #[derive(Debug, Eq, PartialEq)]\n-    struct Point {\n-        x: i32,\n-        y: i32,\n-        z: i32,\n-    }\n-\n-    #[test]\n-    pub fn test_unused() {\n-        let arena: TypedArena<Point> = TypedArena::default();\n-        assert!(arena.chunks.borrow().is_empty());\n-    }\n-\n-    #[test]\n-    fn test_arena_alloc_nested() {\n-        struct Inner {\n-            value: u8,\n-        }\n-        struct Outer<'a> {\n-            inner: &'a Inner,\n-        }\n-        enum EI<'e> {\n-            I(Inner),\n-            O(Outer<'e>),\n-        }\n-\n-        struct Wrap<'a>(TypedArena<EI<'a>>);\n-\n-        impl<'a> Wrap<'a> {\n-            fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n-                let r: &EI<'_> = self.0.alloc(EI::I(f()));\n-                if let &EI::I(ref i) = r {\n-                    i\n-                } else {\n-                    panic!(\"mismatch\");\n-                }\n-            }\n-            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n-                let r: &EI<'_> = self.0.alloc(EI::O(f()));\n-                if let &EI::O(ref o) = r {\n-                    o\n-                } else {\n-                    panic!(\"mismatch\");\n-                }\n-            }\n-        }\n-\n-        let arena = Wrap(TypedArena::default());\n-\n-        let result = arena.alloc_outer(|| Outer {\n-            inner: arena.alloc_inner(|| Inner { value: 10 }),\n-        });\n-\n-        assert_eq!(result.inner.value, 10);\n-    }\n-\n-    #[test]\n-    pub fn test_copy() {\n-        let arena = TypedArena::default();\n-        for _ in 0..100000 {\n-            arena.alloc(Point { x: 1, y: 2, z: 3 });\n-        }\n-    }\n-\n-    #[bench]\n-    pub fn bench_copy(b: &mut Bencher) {\n-        let arena = TypedArena::default();\n-        b.iter(|| arena.alloc(Point { x: 1, y: 2, z: 3 }))\n-    }\n-\n-    #[bench]\n-    pub fn bench_copy_nonarena(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = Box::new(Point { x: 1, y: 2, z: 3 });\n-        })\n-    }\n-\n-    #[allow(dead_code)]\n-    struct Noncopy {\n-        string: String,\n-        array: Vec<i32>,\n-    }\n-\n-    #[test]\n-    pub fn test_noncopy() {\n-        let arena = TypedArena::default();\n-        for _ in 0..100000 {\n-            arena.alloc(Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec![1, 2, 3, 4, 5],\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_typed_arena_zero_sized() {\n-        let arena = TypedArena::default();\n-        for _ in 0..100000 {\n-            arena.alloc(());\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_typed_arena_clear() {\n-        let mut arena = TypedArena::default();\n-        for _ in 0..10 {\n-            arena.clear();\n-            for _ in 0..10000 {\n-                arena.alloc(Point { x: 1, y: 2, z: 3 });\n-            }\n-        }\n-    }\n-\n-    #[bench]\n-    pub fn bench_typed_arena_clear(b: &mut Bencher) {\n-        let mut arena = TypedArena::default();\n-        b.iter(|| {\n-            arena.alloc(Point { x: 1, y: 2, z: 3 });\n-            arena.clear();\n-        })\n-    }\n-\n-    // Drop tests\n-\n-    struct DropCounter<'a> {\n-        count: &'a Cell<u32>,\n-    }\n-\n-    impl Drop for DropCounter<'_> {\n-        fn drop(&mut self) {\n-            self.count.set(self.count.get() + 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_typed_arena_drop_count() {\n-        let counter = Cell::new(0);\n-        {\n-            let arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(DropCounter { count: &counter });\n-            }\n-        };\n-        assert_eq!(counter.get(), 100);\n-    }\n-\n-    #[test]\n-    fn test_typed_arena_drop_on_clear() {\n-        let counter = Cell::new(0);\n-        let mut arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n-        for i in 0..10 {\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(DropCounter { count: &counter });\n-            }\n-            arena.clear();\n-            assert_eq!(counter.get(), i * 100 + 100);\n-        }\n-    }\n-\n-    thread_local! {\n-        static DROP_COUNTER: Cell<u32> = Cell::new(0)\n-    }\n-\n-    struct SmallDroppable;\n-\n-    impl Drop for SmallDroppable {\n-        fn drop(&mut self) {\n-            DROP_COUNTER.with(|c| c.set(c.get() + 1));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_typed_arena_drop_small_count() {\n-        DROP_COUNTER.with(|c| c.set(0));\n-        {\n-            let arena: TypedArena<SmallDroppable> = TypedArena::default();\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(SmallDroppable);\n-            }\n-            // dropping\n-        };\n-        assert_eq!(DROP_COUNTER.with(|c| c.get()), 100);\n-    }\n-\n-    #[bench]\n-    pub fn bench_noncopy(b: &mut Bencher) {\n-        let arena = TypedArena::default();\n-        b.iter(|| {\n-            arena.alloc(Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec![1, 2, 3, 4, 5],\n-            })\n-        })\n-    }\n-\n-    #[bench]\n-    pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = Box::new(Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec![1, 2, 3, 4, 5],\n-            });\n-        })\n-    }\n-}\n+mod tests;"}, {"sha": "fa4189409d0e86ad67776c7bd973f12d5802fec6", "filename": "src/libarena/tests.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibarena%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibarena%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "ac07ffb14febdd8ba0f74a7d1a319b1f0ea5f1f4", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "5d0333d5226d20b43a2a8de996742d5b9fb657e1", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "e8a0a88f12a7e30604ff92702c2d9f0476ad9985", "filename": "src/libcore/any.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "b5614010e5c2f2b1730d93092b1fd6c38b7105ab", "filename": "src/libcore/array.rs", "status": "modified", "additions": 287, "deletions": 157, "changes": 444, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "4087333e2cf6dc39f530508663edf84af1b8d75a", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "a337c467131335cdbafe1f60951f31743f317ff4", "filename": "src/libcore/benches/ascii.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "711a8dff2c0b51551fe23fd0cbd9db844521ec7e", "filename": "src/libcore/benches/slice.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fslice.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "8579dbf353e800e8c287bcfd3eecacc9eb7f9451", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "0a870c67518c73a8fd4361971b1c35fc099db0f7", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "e91bf53c5b418c40a2237350581b3db16966477b", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "ec70d396e966d586fcdb1ff2893de24943f85353", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "cb9feb074dd70d58d51c1b95da226ce662ea16eb", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "641621f492baf33bcc9cef66454ff352f065dca1", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 33, "deletions": 29, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "66acc5165fc5b9ad9b2fa3714225a664da3c71cd", "filename": "src/libcore/default.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "eda0e7c518c58290b6f212c2319dae92ee038948", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 184, "deletions": 44, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "15ce2277fa00d9188aad74dc7043f72faa149a3e", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 151, "deletions": 22, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "a2fff913ac720c1475eeb23a6a9be0d3588ff035", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "bd31d25dd034b2063c33b665e9e3d63e50e159cd", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "3b5c9fbff250ae1e654e156e38b36950f489e69d", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "f14ed38b9b0f27c4c5a39bd8450b466a4d07cc3d", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "bf3daa32840d85cb598ee4e0d1ec6ad34be98e1a", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "3b2b28217f9b391cd3dd20fe031701de9e311ae4", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "3acf2ec837d88cae0ca415e45d0c08af150e4686", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "d145f2212f93a639e2c4ab50dff24b5b6b64ef57", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 101, "deletions": 24, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "0b9f7f6b609e7cee770fca3167c5417fc9816613", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "a45173f614ded742bec4edbb59566bc065f6d569", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 86, "deletions": 51, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "a63434abd6c9fc172532d5a27f92c3f0cba96c30", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 555, "deletions": 210, "changes": 765, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "430ceacdd9fab674aad4b958263f1326c2c0b099", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "aba8e84d58be553566165846b39eb2990f2da84b", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "efda3b263cc97fae94f08fb2dda1522424763779", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "183176005ede9605ba289c018d6adbe18f6d69c5", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "818f03303298f7b250d50486ca144b629f0a9954", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 52, "deletions": 76, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "25439136b853839d83d4cf9df900b21676a9b4af", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "006b243ca42aa8c328060987edbf9c90013c2ff4", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "d644787d2c462678e9af0b4ad494d34dc170730c", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 295, "deletions": 91, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "c168d5c8a2eac9e58752c2cb6d4ddedd08bc2ec6", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "6c88a766a2f10eb39eb7c5096b81bd2e78e1f936", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 599, "deletions": 145, "changes": 744, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "89af2528c052a2dea2b2e8834ccca0c9bc191714", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "9fb071d29524bee5abfc0694c77f155da4a1b405", "filename": "src/libcore/mem.rs", "status": "removed", "additions": 0, "deletions": 1435, "changes": 1435, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=963184bbb670c1ffa97fc28a98cd5e8473118859"}, {"sha": "bb353993236289b2ae4d131d9d4352fb34b0b8b4", "filename": "src/libcore/mem/manually_drop.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "9e9e901c76d3ff0d02213e27f5677873c6eabe02", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "87ec05a243d3619c468ae2615772eb00f3f1d07d", "filename": "src/libcore/mem/mod.rs", "status": "added", "additions": 830, "deletions": 0, "changes": 830, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "8ff78166a9f2d83b526382ca6bbf64df56c6dbef", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 123, "deletions": 21, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "d45c04f45afc2b4fe3b4a697dae6814304f00b4f", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 123, "deletions": 21, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "b46e06f8d8ada93b5c8089cef11cfa14dac22e71", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 83, "deletions": 68, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "fd129a306d1c57024d788dc72dfdeea9069616d1", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "3c009d644c64e3f6f3feb98f30e8150b56430cee", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "ce0d3fd01f78fefc030dbe2d2a3b67afbfc7561c", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "b9552eaa1a0e5678c8b66aa6e2af55508416ea9b", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "9cff474a760306be8f639270d67b5fed39802cd1", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "1b4c4218cc15bb95e25ab47e803e6096414fdc1b", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "76fec1020f1eff572d8c8c5890efeffce81bc207", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "8e46830084642b573623723650f280e73671602e", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "259ed36c5788530d05333c8158a7ff884fc28e31", "filename": "src/libcore/option.rs", "status": "modified", "additions": 191, "deletions": 70, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "6efeaf9ee7d2eff9e1a08a0f077412f19c673153", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 215, "deletions": 112, "changes": 327, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "7cc279a9ef2ecb83ce3ac3916b6f0b9273617861", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "b6de9f57b0110439227d2ba8ae5797761595b922", "filename": "src/libcore/ptr.rs", "status": "removed", "additions": 0, "deletions": 3130, "changes": 3130, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=963184bbb670c1ffa97fc28a98cd5e8473118859"}, {"sha": "f5fbd1a6b1325c82cee54711876a97f624aa4831", "filename": "src/libcore/ptr/mod.rs", "status": "added", "additions": 2951, "deletions": 0, "changes": 2951, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "ad3d1ce396ab755c70dd1adc709eec93943f9565", "filename": "src/libcore/ptr/non_null.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "3521dd799795672ab379af6cc25dab307f8ee91e", "filename": "src/libcore/ptr/unique.rs", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "75c329a7d6c10ad4a60d795a1fe58e48f6a69e02", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "8c60a9c1b501d0497aec7faea4154e086f89c16e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 132, "deletions": 58, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "ce5af13d4ca90d4b8552fcd89cbe4033187ac48d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 271, "deletions": 89, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "f73e14f27e092bda780b76cece052b8a4e703e35", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 152, "deletions": 69, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "2f2170f7ff14ce7860d3b219f7e55ce0e2a7365b", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "e8f747f1a67d5fc8c73070b4959c63787893f07e", "filename": "src/libcore/str/lossy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "f20cb7bfbc3bdd21305dd035f3d69678619ef1c2", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 127, "deletions": 73, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "8dfb19fa032960bf9b7cefdc3210875013918ca0", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "fec17c4d1a4df7b111a5ab90b38cd6a956945868", "filename": "src/libcore/task/poll.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftask%2Fpoll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftask%2Fpoll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fpoll.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "65e293642874c3ba730e67484a0c1fd474618f79", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "63537ba23d84dc0edfabc9384a45e7a7a2249b7b", "filename": "src/libcore/tests/alloc.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Falloc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "439ed0c81c8b66e5fdda531c4c9c089b2041185b", "filename": "src/libcore/tests/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fascii.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "200659b91bb4ec696697e0423347c4fbb720cb3c", "filename": "src/libcore/tests/fmt/builders.rs", "status": "modified", "additions": 85, "deletions": 8, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fbuilders.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "d86e21cf40b6e7e36da4238066adf742cd887d58", "filename": "src/libcore/tests/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ffmt%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "a1a27e1d5380ff50f4487ede0e7e08aa24f7ed79", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 347, "deletions": 13, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "a3b108b2e9cea00bc07f9e3f55504336c7f5e222", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "46eacb4200acc154609d3a6f0aaa945d9d7c2d1a", "filename": "src/libcore/tests/num/dec2flt/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fdec2flt%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "c51451708f3ce132d5e5600b83c7d2da85548f42", "filename": "src/libcore/tests/num/flt2dec/estimator.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Festimator.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "c41d35efced6c908d9b3d8fc2057c948f06638e9", "filename": "src/libcore/tests/num/flt2dec/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "d9543793397bfbef336e12b9b0f7a485cd9d4d99", "filename": "src/libcore/tests/num/flt2dec/random.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Frandom.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "dc4d78bfae1096fac4de4641dda8e01c1576112f", "filename": "src/libcore/tests/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "f8bdddfe2e4103e346ad6d5df9f75c044007d87d", "filename": "src/libcore/tests/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "48755ae4c16411914f3cbd7820f618a8718b1ce0", "filename": "src/libcore/tests/ops.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fops.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "ff43fc49f71e39aeb2b866b74b77ab3b8c07853e", "filename": "src/libcore/tests/option.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Foption.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "06c3a78c1698ac831d548abc54fb3a1057ea4e52", "filename": "src/libcore/tests/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fpattern.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "1a6be3a9bbd034558618281c4a325e762d1f6ac6", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "163f8d0ab3797e731d4b51ea58fc0cee4050fbcf", "filename": "src/libcore/tests/result.rs", "status": "modified", "additions": 153, "deletions": 32, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fresult.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "4790152512a396deee39fe8a6a77f21dc3c01963", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 197, "deletions": 15, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "fac70c468c89d77cf6db8e778e76662e5cfb2d04", "filename": "src/libcore/tests/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftests%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Ftime.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "5a0e4388e0325b485f66d4e841dc9c1d7dcd638d", "filename": "src/libcore/time.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftime.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "748917f1d342087493ef73e2aea00fddc2b0ede4", "filename": "src/libcore/unicode/printable.py", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Funicode%2Fprintable.py", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Funicode%2Fprintable.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.py?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "d411dda7dc18fc68247bee349acf18af03d5039b", "filename": "src/libcore/unicode/printable.rs", "status": "modified", "additions": 85, "deletions": 71, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Funicode%2Fprintable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Funicode%2Fprintable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "3fae3a46ada6b7c20be05f336bdb4d2b82745cb8", "filename": "src/libcore/unicode/tables.rs", "status": "modified", "additions": 697, "deletions": 680, "changes": 1377, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "6de5d9e033b9309bd47e336cc6c4a162839ed55f", "filename": "src/libcore/unicode/unicode.py", "status": "modified", "additions": 743, "deletions": 355, "changes": 1098, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "82a9e34c065b1e7acc96fcf362ea3a72c3776495", "filename": "src/libfmt_macros/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibfmt_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibfmt_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2FCargo.toml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "985abaf2c1bd568bd74b8b661c1b1ead6e06cfe4", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 110, "deletions": 331, "changes": 441, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "e2ddb8810e90a64cd58ed4076b5613ec745152fb", "filename": "src/libfmt_macros/tests.rs", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "4a6e41f76031994dc7119d196f8a1cba5ab03eab", "filename": "src/libgraphviz/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibgraphviz%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibgraphviz%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2FCargo.toml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "bb996e5f906d75c888e6b928308d0df2db005462", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 384, "changes": 385, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "2f713579b17fa0416204f8b0d5abc971d1494f91", "filename": "src/libgraphviz/tests.rs", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibgraphviz%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibgraphviz%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "fd144d6b67e759594093cc481450a63005b1c5b2", "filename": "src/libpanic_abort/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_abort%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_abort%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "47cd09f1b0510715a51b1f681c3b2c2e2e0468a8", "filename": "src/libpanic_unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.toml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "8675632638712aa2593f77f1b1bcba0621316680", "filename": "src/libpanic_unwind/dummy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Fdummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Fdummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdummy.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "34128e60d3638bc6bbf2ba04e158e5a4e1432b42", "filename": "src/libpanic_unwind/dwarf/mod.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Fmod.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "1644f37083a5bbdaa3f7f8fc2b44f4f93b6a9982", "filename": "src/libpanic_unwind/dwarf/tests.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Fdwarf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Fdwarf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Ftests.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "236ed15050571e63877944c994afc788b1627f56", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "06e6e768f459c03a36f4ef3324a95284c4cbd00c", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "659e977285e3567b3ed5d46a2f3fe08f4f87f5de", "filename": "src/libpanic_unwind/macros.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Flibpanic_unwind%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/963184bbb670c1ffa97fc28a98cd5e8473118859/src%2Flibpanic_unwind%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fmacros.rs?ref=963184bbb670c1ffa97fc28a98cd5e8473118859"}, {"sha": "809e4619812dec41c90575e81069f039e62e53d4", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "a51e3a9a33d7b542cd823fdbc315bb1ec76e10b2", "filename": "src/libproc_macro/bridge/buffer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fbuffer.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "5c543165bc2b19da1a271b65aa7331da77300b00", "filename": "src/libproc_macro/bridge/client.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibproc_macro%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fclient.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "5c2f9ec9848dda7d26b1b6d5b2545cd70313f5ec", "filename": "src/libproc_macro/bridge/rpc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibproc_macro%2Fbridge%2Frpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Frpc.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "2cde1f65adf9c484ab0aee45fe6c978fda30cbb9", "filename": "src/libproc_macro/bridge/scoped_cell.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fbridge%2Fscoped_cell.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "c0f7714ca211af612fa2cb61fd026056d7ade99e", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "775f84535fbf25b9e17a7561a1f0ec3358703d0b", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "0d12ba01c87a2ed5deb9ba1cdea6f1d42d8c3114", "filename": "src/libprofiler_builtins/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibprofiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibprofiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Flib.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "0222a3dde7ab977e656d83a50685e891f663bd62", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 3, "deletions": 33, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "e8c3914e695ad1c71c214cbf240625e758382fbf", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}, {"sha": "0dad2dda837b53f236a86499a3fa97db7af725cb", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 26, "deletions": 61, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f08b78a12ff119af853cb2bf58468208ea6a90/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=92f08b78a12ff119af853cb2bf58468208ea6a90"}]}