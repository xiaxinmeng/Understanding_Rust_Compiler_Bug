{"sha": "d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzYzRmYmJiYzQ1YWZjN2Q0ODAxODU0OTNiNWNlNzdiNWRhYTE3NDc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-16T16:58:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-16T16:58:13Z"}, "message": "Merge #2862\n\n2862: Move from `from_source` to `SourceBinder` r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "aa12838a1b0c45710bb7657f6f3c34947519484c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa12838a1b0c45710bb7657f6f3c34947519484c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeIJYlCRBK7hj4Ov3rIwAAdHIIAI/z1uDH0H2behyWkjlU9Z7S\nXdU8pis5taR5QWGEt8bI/ObnAF9r+Y1nZeBfvRB0UktwCtHKEXLh1/Wo4I46erNE\nxEsNE1dcse4ZD4zOBtzwJk5VAvYoEKkS1toSd9p6A6hDA6ux+lIdUJgF0I/gN/I6\nHnf+O5YTiA6jhNx7F4Ik+3o8ZKDiduFqwTG4Q7ibt+AYLpFv91xx5Y0ss3SrhabW\nrqvHfDFnlw0AJ8idCjSDF+Df9mAGr0V5+DPCflbuEG1OGm0wrV9ZD6ixwRzwjZJS\nocot199R6CwnXOL5iCNdisjHE9uvgS+vdTi8ttAGkkQtNZ5p1L3rv2W9o8jf3Sc=\n=G4xR\n-----END PGP SIGNATURE-----\n", "payload": "tree aa12838a1b0c45710bb7657f6f3c34947519484c\nparent e614356de10256c64e02f5d0f82cfa39e27b0f07\nparent 846f11c2177f3e3a6348acb67503028180b3c1f8\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1579193893 +0000\ncommitter GitHub <noreply@github.com> 1579193893 +0000\n\nMerge #2862\n\n2862: Move from `from_source` to `SourceBinder` r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "html_url": "https://github.com/rust-lang/rust/commit/d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e614356de10256c64e02f5d0f82cfa39e27b0f07", "url": "https://api.github.com/repos/rust-lang/rust/commits/e614356de10256c64e02f5d0f82cfa39e27b0f07", "html_url": "https://github.com/rust-lang/rust/commit/e614356de10256c64e02f5d0f82cfa39e27b0f07"}, {"sha": "846f11c2177f3e3a6348acb67503028180b3c1f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/846f11c2177f3e3a6348acb67503028180b3c1f8", "html_url": "https://github.com/rust-lang/rust/commit/846f11c2177f3e3a6348acb67503028180b3c1f8"}], "stats": {"total": 736, "additions": 306, "deletions": 430}, "files": [{"sha": "43f0d664b470afef06bb9d560ac9eb8ae7ba2cc4", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -1,6 +1,6 @@\n //! This module defines `AssistCtx` -- the API surface that is exposed to assists.\n use either::Either;\n-use hir::{db::HirDatabase, InFile, SourceAnalyzer};\n+use hir::{db::HirDatabase, InFile, SourceAnalyzer, SourceBinder};\n use ra_db::FileRange;\n use ra_fmt::{leading_indent, reindent};\n use ra_syntax::{\n@@ -142,12 +142,16 @@ impl<'a, DB: HirDatabase> AssistCtx<'a, DB> {\n     pub(crate) fn covering_element(&self) -> SyntaxElement {\n         find_covering_element(self.source_file.syntax(), self.frange.range)\n     }\n+    pub(crate) fn source_binder(&self) -> SourceBinder<'a, DB> {\n+        SourceBinder::new(self.db)\n+    }\n     pub(crate) fn source_analyzer(\n         &self,\n         node: &SyntaxNode,\n         offset: Option<TextUnit>,\n     ) -> SourceAnalyzer {\n-        SourceAnalyzer::new(self.db, InFile::new(self.frange.file_id.into(), node), offset)\n+        let src = InFile::new(self.frange.file_id.into(), node);\n+        self.source_binder().analyze(src, offset)\n     }\n \n     pub(crate) fn covering_node_for_range(&self, range: TextRange) -> SyntaxElement {"}, {"sha": "8db63f762733564e49e1f5a28f3de8a7d011ece4", "filename": "crates/ra_assists/src/assists/add_new.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_new.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -1,5 +1,5 @@\n use format_buf::format;\n-use hir::{db::HirDatabase, FromSource, InFile};\n+use hir::{db::HirDatabase, InFile};\n use join_to_string::join;\n use ra_syntax::{\n     ast::{\n@@ -136,15 +136,16 @@ fn find_struct_impl(\n     let module = strukt.syntax().ancestors().find(|node| {\n         ast::Module::can_cast(node.kind()) || ast::SourceFile::can_cast(node.kind())\n     })?;\n+    let mut sb = ctx.source_binder();\n \n     let struct_ty = {\n         let src = InFile { file_id: ctx.frange.file_id.into(), value: strukt.clone() };\n-        hir::Struct::from_source(db, src)?.ty(db)\n+        sb.to_def(src)?.ty(db)\n     };\n \n     let block = module.descendants().filter_map(ast::ImplBlock::cast).find_map(|impl_blk| {\n         let src = InFile { file_id: ctx.frange.file_id.into(), value: impl_blk.clone() };\n-        let blk = hir::ImplBlock::from_source(db, src)?;\n+        let blk = sb.to_def(src)?;\n \n         let same_ty = blk.target_ty(db) == struct_ty;\n         let not_trait_impl = blk.target_trait(db).is_none();"}, {"sha": "6314be8d4c68fee9f62acfcd5da125dee4ec5462", "filename": "crates/ra_hir/src/from_source.rs", "status": "removed", "additions": 0, "deletions": 265, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/e614356de10256c64e02f5d0f82cfa39e27b0f07/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e614356de10256c64e02f5d0f82cfa39e27b0f07/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffrom_source.rs?ref=e614356de10256c64e02f5d0f82cfa39e27b0f07", "patch": "@@ -1,265 +0,0 @@\n-//! Finds a corresponding hir data structure for a syntax node in a specific\n-//! file.\n-\n-use hir_def::{\n-    child_by_source::ChildBySource, dyn_map::DynMap, keys, keys::Key, nameres::ModuleSource,\n-    ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId, ImplId, ModuleId,\n-    StaticId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n-};\n-use hir_expand::{name::AsName, AstId, MacroDefId, MacroDefKind};\n-use ra_db::FileId;\n-use ra_prof::profile;\n-use ra_syntax::{\n-    ast::{self, AstNode, NameOwner},\n-    match_ast, SyntaxNode,\n-};\n-\n-use crate::{\n-    db::{DefDatabase, HirDatabase},\n-    Const, DefWithBody, Enum, EnumVariant, FieldSource, Function, ImplBlock, InFile, Local,\n-    MacroDef, Module, Static, Struct, StructField, Trait, TypeAlias, TypeParam, Union,\n-};\n-\n-pub trait FromSource: Sized {\n-    type Ast;\n-    fn from_source(db: &impl DefDatabase, src: InFile<Self::Ast>) -> Option<Self>;\n-}\n-\n-pub trait FromSourceByContainer: Sized {\n-    type Ast: AstNode + 'static;\n-    type Id: Copy + 'static;\n-    const KEY: Key<Self::Ast, Self::Id>;\n-}\n-\n-impl<T: FromSourceByContainer> FromSource for T\n-where\n-    T: From<<T as FromSourceByContainer>::Id>,\n-{\n-    type Ast = <T as FromSourceByContainer>::Ast;\n-    fn from_source(db: &impl DefDatabase, src: InFile<Self::Ast>) -> Option<Self> {\n-        analyze_container(db, src.as_ref().map(|it| it.syntax()))[T::KEY]\n-            .get(&src)\n-            .copied()\n-            .map(Self::from)\n-    }\n-}\n-\n-macro_rules! from_source_by_container_impls {\n-    ($(($hir:ident, $id:ident, $ast:path, $key:path)),* ,) => {$(\n-        impl FromSourceByContainer for $hir {\n-            type Ast = $ast;\n-            type Id = $id;\n-            const KEY: Key<Self::Ast, Self::Id> = $key;\n-        }\n-    )*}\n-}\n-\n-from_source_by_container_impls![\n-    (Struct, StructId, ast::StructDef, keys::STRUCT),\n-    (Union, UnionId, ast::UnionDef, keys::UNION),\n-    (Enum, EnumId, ast::EnumDef, keys::ENUM),\n-    (Trait, TraitId, ast::TraitDef, keys::TRAIT),\n-    (Function, FunctionId, ast::FnDef, keys::FUNCTION),\n-    (Static, StaticId, ast::StaticDef, keys::STATIC),\n-    (Const, ConstId, ast::ConstDef, keys::CONST),\n-    (TypeAlias, TypeAliasId, ast::TypeAliasDef, keys::TYPE_ALIAS),\n-    (ImplBlock, ImplId, ast::ImplBlock, keys::IMPL),\n-];\n-\n-impl FromSource for MacroDef {\n-    type Ast = ast::MacroCall;\n-    fn from_source(db: &impl DefDatabase, src: InFile<Self::Ast>) -> Option<Self> {\n-        let kind = MacroDefKind::Declarative;\n-\n-        let module_src = ModuleSource::from_child_node(db, src.as_ref().map(|it| it.syntax()));\n-        let module = Module::from_definition(db, InFile::new(src.file_id, module_src))?;\n-        let krate = Some(module.krate().id);\n-\n-        let ast_id = Some(AstId::new(src.file_id, db.ast_id_map(src.file_id).ast_id(&src.value)));\n-\n-        let id: MacroDefId = MacroDefId { krate, ast_id, kind };\n-        Some(MacroDef { id })\n-    }\n-}\n-\n-impl FromSource for EnumVariant {\n-    type Ast = ast::EnumVariant;\n-    fn from_source(db: &impl DefDatabase, src: InFile<Self::Ast>) -> Option<Self> {\n-        let parent_enum = src.value.parent_enum();\n-        let src_enum = InFile { file_id: src.file_id, value: parent_enum };\n-        let parent_enum = Enum::from_source(db, src_enum)?;\n-        parent_enum.id.child_by_source(db)[keys::ENUM_VARIANT]\n-            .get(&src)\n-            .copied()\n-            .map(EnumVariant::from)\n-    }\n-}\n-\n-impl FromSource for StructField {\n-    type Ast = FieldSource;\n-    fn from_source(db: &impl DefDatabase, src: InFile<Self::Ast>) -> Option<Self> {\n-        let src = src.as_ref();\n-\n-        // FIXME this is buggy\n-        let variant_id: VariantId = match src.value {\n-            FieldSource::Named(field) => {\n-                let value = field.syntax().ancestors().find_map(ast::StructDef::cast)?;\n-                let src = InFile { file_id: src.file_id, value };\n-                let def = Struct::from_source(db, src)?;\n-                def.id.into()\n-            }\n-            FieldSource::Pos(field) => {\n-                let value = field.syntax().ancestors().find_map(ast::EnumVariant::cast)?;\n-                let src = InFile { file_id: src.file_id, value };\n-                let def = EnumVariant::from_source(db, src)?;\n-                EnumVariantId::from(def).into()\n-            }\n-        };\n-\n-        let dyn_map = variant_id.child_by_source(db);\n-        match src.value {\n-            FieldSource::Pos(it) => dyn_map[keys::TUPLE_FIELD].get(&src.with_value(it.clone())),\n-            FieldSource::Named(it) => dyn_map[keys::RECORD_FIELD].get(&src.with_value(it.clone())),\n-        }\n-        .copied()\n-        .map(StructField::from)\n-    }\n-}\n-\n-impl Local {\n-    pub fn from_source(db: &impl HirDatabase, src: InFile<ast::BindPat>) -> Option<Self> {\n-        let file_id = src.file_id;\n-        let parent: DefWithBody = src.value.syntax().ancestors().find_map(|it| {\n-            let res = match_ast! {\n-                match it {\n-                    ast::ConstDef(value) => { Const::from_source(db, InFile { value, file_id})?.into() },\n-                    ast::StaticDef(value) => { Static::from_source(db, InFile { value, file_id})?.into() },\n-                    ast::FnDef(value) => { Function::from_source(db, InFile { value, file_id})?.into() },\n-                    _ => return None,\n-                }\n-            };\n-            Some(res)\n-        })?;\n-        let (_body, source_map) = db.body_with_source_map(parent.into());\n-        let src = src.map(ast::Pat::from);\n-        let pat_id = source_map.node_pat(src.as_ref())?;\n-        Some(Local { parent, pat_id })\n-    }\n-}\n-\n-impl TypeParam {\n-    pub fn from_source(db: &impl HirDatabase, src: InFile<ast::TypeParam>) -> Option<Self> {\n-        let file_id = src.file_id;\n-        let parent: GenericDefId = src.value.syntax().ancestors().find_map(|it| {\n-            let res = match_ast! {\n-                match it {\n-                    ast::FnDef(value) => { Function::from_source(db, InFile { value, file_id})?.id.into() },\n-                    ast::StructDef(value) => { Struct::from_source(db, InFile { value, file_id})?.id.into() },\n-                    ast::EnumDef(value) => { Enum::from_source(db, InFile { value, file_id})?.id.into() },\n-                    ast::TraitDef(value) => { Trait::from_source(db, InFile { value, file_id})?.id.into() },\n-                    ast::TypeAliasDef(value) => { TypeAlias::from_source(db, InFile { value, file_id})?.id.into() },\n-                    ast::ImplBlock(value) => { ImplBlock::from_source(db, InFile { value, file_id})?.id.into() },\n-                    _ => return None,\n-                }\n-            };\n-            Some(res)\n-        })?;\n-        let &id = parent.child_by_source(db)[keys::TYPE_PARAM].get(&src)?;\n-        Some(TypeParam { id })\n-    }\n-}\n-\n-impl Module {\n-    pub fn from_declaration(db: &impl DefDatabase, src: InFile<ast::Module>) -> Option<Self> {\n-        let _p = profile(\"Module::from_declaration\");\n-        let parent_declaration = src.value.syntax().ancestors().skip(1).find_map(ast::Module::cast);\n-\n-        let parent_module = match parent_declaration {\n-            Some(parent_declaration) => {\n-                let src_parent = InFile { file_id: src.file_id, value: parent_declaration };\n-                Module::from_declaration(db, src_parent)\n-            }\n-            None => {\n-                let source_file = db.parse(src.file_id.original_file(db)).tree();\n-                let src_parent =\n-                    InFile { file_id: src.file_id, value: ModuleSource::SourceFile(source_file) };\n-                Module::from_definition(db, src_parent)\n-            }\n-        }?;\n-\n-        let child_name = src.value.name()?.as_name();\n-        let def_map = db.crate_def_map(parent_module.id.krate);\n-        let child_id = def_map[parent_module.id.local_id].children.get(&child_name)?;\n-        Some(parent_module.with_module_id(*child_id))\n-    }\n-\n-    pub fn from_definition(db: &impl DefDatabase, src: InFile<ModuleSource>) -> Option<Self> {\n-        let _p = profile(\"Module::from_definition\");\n-        match src.value {\n-            ModuleSource::Module(ref module) => {\n-                assert!(!module.has_semi());\n-                return Module::from_declaration(\n-                    db,\n-                    InFile { file_id: src.file_id, value: module.clone() },\n-                );\n-            }\n-            ModuleSource::SourceFile(_) => (),\n-        };\n-\n-        let original_file = src.file_id.original_file(db);\n-        Module::from_file(db, original_file)\n-    }\n-\n-    fn from_file(db: &impl DefDatabase, file: FileId) -> Option<Self> {\n-        let _p = profile(\"Module::from_file\");\n-        let (krate, local_id) = db.relevant_crates(file).iter().find_map(|&crate_id| {\n-            let crate_def_map = db.crate_def_map(crate_id);\n-            let local_id = crate_def_map.modules_for_file(file).next()?;\n-            Some((crate_id, local_id))\n-        })?;\n-        Some(Module { id: ModuleId { krate, local_id } })\n-    }\n-}\n-\n-fn analyze_container(db: &impl DefDatabase, src: InFile<&SyntaxNode>) -> DynMap {\n-    let _p = profile(\"analyze_container\");\n-    return child_by_source(db, src).unwrap_or_default();\n-\n-    fn child_by_source(db: &impl DefDatabase, src: InFile<&SyntaxNode>) -> Option<DynMap> {\n-        for container in src.value.ancestors().skip(1) {\n-            let res = match_ast! {\n-                match container {\n-                    ast::TraitDef(it) => {\n-                        let def = Trait::from_source(db, src.with_value(it))?;\n-                        def.id.child_by_source(db)\n-                    },\n-                    ast::ImplBlock(it) => {\n-                        let def = ImplBlock::from_source(db, src.with_value(it))?;\n-                        def.id.child_by_source(db)\n-                    },\n-                    ast::FnDef(it) => {\n-                        let def = Function::from_source(db, src.with_value(it))?;\n-                        DefWithBodyId::from(def.id)\n-                            .child_by_source(db)\n-                    },\n-                    ast::StaticDef(it) => {\n-                        let def = Static::from_source(db, src.with_value(it))?;\n-                        DefWithBodyId::from(def.id)\n-                            .child_by_source(db)\n-                    },\n-                    ast::ConstDef(it) => {\n-                        let def = Const::from_source(db, src.with_value(it))?;\n-                        DefWithBodyId::from(def.id)\n-                            .child_by_source(db)\n-                    },\n-                    _ => { continue },\n-                }\n-            };\n-            return Some(res);\n-        }\n-\n-        let module_source = ModuleSource::from_child_node(db, src);\n-        let c = Module::from_definition(db, src.with_value(module_source))?;\n-        Some(c.id.child_by_source(db))\n-    }\n-}"}, {"sha": "e1c7b7a2020f7c71008bbbbf43182a2251e43fae", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -36,7 +36,6 @@ mod from_id;\n mod code_model;\n \n mod has_source;\n-mod from_source;\n \n pub use crate::{\n     code_model::{\n@@ -45,7 +44,6 @@ pub use crate::{\n         MacroDef, Module, ModuleDef, ScopeDef, Static, Struct, StructField, Trait, Type, TypeAlias,\n         TypeParam, Union, VariantDef,\n     },\n-    from_source::FromSource,\n     has_source::HasSource,\n     source_analyzer::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n     source_binder::SourceBinder,"}, {"sha": "f3150f5784a5662de5e3e324b866652c8144f29c", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 218, "deletions": 34, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -1,22 +1,24 @@\n-//! `SourceBinder` should be the main entry point for getting info about source code.\n+//! `SourceBinder` is the main entry point for getting info about source code.\n //! It's main task is to map source syntax trees to hir-level IDs.\n-//!\n-//! It is intended to subsume `FromSource` and `SourceAnalyzer`.\n \n use hir_def::{\n     child_by_source::ChildBySource,\n     dyn_map::DynMap,\n     keys::{self, Key},\n     resolver::{HasResolver, Resolver},\n-    ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, ImplId, ModuleId, StaticId,\n-    StructFieldId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n+    ConstId, DefWithBodyId, EnumId, EnumVariantId, FunctionId, GenericDefId, ImplId, ModuleId,\n+    StaticId, StructFieldId, StructId, TraitId, TypeAliasId, UnionId, VariantId,\n };\n-use hir_expand::InFile;\n+use hir_expand::{name::AsName, AstId, InFile, MacroDefId, MacroDefKind};\n use ra_prof::profile;\n-use ra_syntax::{ast, match_ast, AstNode, SyntaxNode, TextUnit};\n+use ra_syntax::{\n+    ast::{self, NameOwner},\n+    match_ast, AstNode, SyntaxNode, TextUnit,\n+};\n use rustc_hash::FxHashMap;\n \n-use crate::{db::HirDatabase, ModuleSource, SourceAnalyzer};\n+use crate::{db::HirDatabase, Local, Module, SourceAnalyzer, TypeParam};\n+use ra_db::FileId;\n \n pub struct SourceBinder<'a, DB> {\n     pub db: &'a DB,\n@@ -48,32 +50,27 @@ impl<DB: HirDatabase> SourceBinder<'_, DB> {\n             ChildContainer::ModuleId(it) => it.resolver(self.db),\n             ChildContainer::EnumId(it) => it.resolver(self.db),\n             ChildContainer::VariantId(it) => it.resolver(self.db),\n+            ChildContainer::GenericDefId(it) => it.resolver(self.db),\n         };\n         SourceAnalyzer::new_for_resolver(resolver, src)\n     }\n \n-    pub fn to_def<D, T>(&mut self, src: InFile<T>) -> Option<D>\n-    where\n-        D: From<T::ID>,\n-        T: ToId,\n-    {\n-        let id: T::ID = self.to_id(src)?;\n-        Some(id.into())\n+    pub fn to_def<T: ToDef>(&mut self, src: InFile<T>) -> Option<T::Def> {\n+        T::to_def(self, src)\n+    }\n+\n+    pub fn to_module_def(&mut self, file: FileId) -> Option<Module> {\n+        let _p = profile(\"SourceBinder::to_module_def\");\n+        let (krate, local_id) = self.db.relevant_crates(file).iter().find_map(|&crate_id| {\n+            let crate_def_map = self.db.crate_def_map(crate_id);\n+            let local_id = crate_def_map.modules_for_file(file).next()?;\n+            Some((crate_id, local_id))\n+        })?;\n+        Some(Module { id: ModuleId { krate, local_id } })\n     }\n \n     fn to_id<T: ToId>(&mut self, src: InFile<T>) -> Option<T::ID> {\n-        let container = self.find_container(src.as_ref().map(|it| it.syntax()))?;\n-        let db = self.db;\n-        let dyn_map =\n-            &*self.child_by_source_cache.entry(container).or_insert_with(|| match container {\n-                ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n-                ChildContainer::ModuleId(it) => it.child_by_source(db),\n-                ChildContainer::TraitId(it) => it.child_by_source(db),\n-                ChildContainer::ImplId(it) => it.child_by_source(db),\n-                ChildContainer::EnumId(it) => it.child_by_source(db),\n-                ChildContainer::VariantId(it) => it.child_by_source(db),\n-            });\n-        dyn_map[T::KEY].get(&src).copied()\n+        T::to_id(self, src)\n     }\n \n     fn find_container(&mut self, src: InFile<&SyntaxNode>) -> Option<ChildContainer> {\n@@ -112,19 +109,75 @@ impl<DB: HirDatabase> SourceBinder<'_, DB> {\n                         let def: UnionId = self.to_id(container.with_value(it))?;\n                         VariantId::from(def).into()\n                     },\n-                    // FIXME: handle out-of-line modules here\n+                    ast::Module(it) => {\n+                        let def: ModuleId = self.to_id(container.with_value(it))?;\n+                        def.into()\n+                    },\n                     _ => { continue },\n                 }\n             };\n             return Some(res);\n         }\n \n-        let module_source = ModuleSource::from_child_node(self.db, src);\n-        let c = crate::Module::from_definition(self.db, src.with_value(module_source))?;\n+        let c = self.to_module_def(src.file_id.original_file(self.db))?;\n         Some(c.id.into())\n     }\n+\n+    fn child_by_source(&mut self, container: ChildContainer) -> &DynMap {\n+        let db = self.db;\n+        self.child_by_source_cache.entry(container).or_insert_with(|| match container {\n+            ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n+            ChildContainer::ModuleId(it) => it.child_by_source(db),\n+            ChildContainer::TraitId(it) => it.child_by_source(db),\n+            ChildContainer::ImplId(it) => it.child_by_source(db),\n+            ChildContainer::EnumId(it) => it.child_by_source(db),\n+            ChildContainer::VariantId(it) => it.child_by_source(db),\n+            ChildContainer::GenericDefId(it) => it.child_by_source(db),\n+        })\n+    }\n }\n \n+pub trait ToId: Sized {\n+    type ID: Sized + Copy + 'static;\n+    fn to_id<DB: HirDatabase>(sb: &mut SourceBinder<'_, DB>, src: InFile<Self>)\n+        -> Option<Self::ID>;\n+}\n+\n+pub trait ToDef: Sized + AstNode + 'static {\n+    type Def;\n+    fn to_def<DB: HirDatabase>(\n+        sb: &mut SourceBinder<'_, DB>,\n+        src: InFile<Self>,\n+    ) -> Option<Self::Def>;\n+}\n+\n+macro_rules! to_def_impls {\n+    ($(($def:path, $ast:path)),* ,) => {$(\n+        impl ToDef for $ast {\n+            type Def = $def;\n+            fn to_def<DB: HirDatabase>(sb: &mut SourceBinder<'_, DB>, src: InFile<Self>)\n+                -> Option<Self::Def>\n+            { sb.to_id(src).map(Into::into) }\n+        }\n+    )*}\n+}\n+\n+to_def_impls![\n+    (crate::Module, ast::Module),\n+    (crate::Struct, ast::StructDef),\n+    (crate::Enum, ast::EnumDef),\n+    (crate::Union, ast::UnionDef),\n+    (crate::Trait, ast::TraitDef),\n+    (crate::ImplBlock, ast::ImplBlock),\n+    (crate::TypeAlias, ast::TypeAliasDef),\n+    (crate::Const, ast::ConstDef),\n+    (crate::Static, ast::StaticDef),\n+    (crate::Function, ast::FnDef),\n+    (crate::StructField, ast::RecordFieldDef),\n+    (crate::EnumVariant, ast::EnumVariant),\n+    (crate::MacroDef, ast::MacroCall), // this one is dubious, not all calls are macros\n+];\n+\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n enum ChildContainer {\n     DefWithBodyId(DefWithBodyId),\n@@ -133,6 +186,9 @@ enum ChildContainer {\n     ImplId(ImplId),\n     EnumId(EnumId),\n     VariantId(VariantId),\n+    /// XXX: this might be the same def as, for example an `EnumId`. However,\n+    /// here the children generic parameters, and not, eg enum variants.\n+    GenericDefId(GenericDefId),\n }\n impl_froms! {\n     ChildContainer:\n@@ -142,23 +198,46 @@ impl_froms! {\n     ImplId,\n     EnumId,\n     VariantId,\n+    GenericDefId\n }\n \n-pub trait ToId: Sized + AstNode + 'static {\n+pub trait ToIdByKey: Sized + AstNode + 'static {\n     type ID: Sized + Copy + 'static;\n     const KEY: Key<Self, Self::ID>;\n }\n \n-macro_rules! to_id_impls {\n+impl<T: ToIdByKey> ToId for T {\n+    type ID = <T as ToIdByKey>::ID;\n+    fn to_id<DB: HirDatabase>(\n+        sb: &mut SourceBinder<'_, DB>,\n+        src: InFile<Self>,\n+    ) -> Option<Self::ID> {\n+        let container = sb.find_container(src.as_ref().map(|it| it.syntax()))?;\n+        let db = sb.db;\n+        let dyn_map =\n+            &*sb.child_by_source_cache.entry(container).or_insert_with(|| match container {\n+                ChildContainer::DefWithBodyId(it) => it.child_by_source(db),\n+                ChildContainer::ModuleId(it) => it.child_by_source(db),\n+                ChildContainer::TraitId(it) => it.child_by_source(db),\n+                ChildContainer::ImplId(it) => it.child_by_source(db),\n+                ChildContainer::EnumId(it) => it.child_by_source(db),\n+                ChildContainer::VariantId(it) => it.child_by_source(db),\n+                ChildContainer::GenericDefId(it) => it.child_by_source(db),\n+            });\n+        dyn_map[T::KEY].get(&src).copied()\n+    }\n+}\n+\n+macro_rules! to_id_key_impls {\n     ($(($id:ident, $ast:path, $key:path)),* ,) => {$(\n-        impl ToId for $ast {\n+        impl ToIdByKey for $ast {\n             type ID = $id;\n             const KEY: Key<Self, Self::ID> = $key;\n         }\n     )*}\n }\n \n-to_id_impls![\n+to_id_key_impls![\n     (StructId, ast::StructDef, keys::STRUCT),\n     (UnionId, ast::UnionDef, keys::UNION),\n     (EnumId, ast::EnumDef, keys::ENUM),\n@@ -171,3 +250,108 @@ to_id_impls![\n     (StructFieldId, ast::RecordFieldDef, keys::RECORD_FIELD),\n     (EnumVariantId, ast::EnumVariant, keys::ENUM_VARIANT),\n ];\n+\n+// FIXME: use DynMap as well?\n+impl ToId for ast::MacroCall {\n+    type ID = MacroDefId;\n+    fn to_id<DB: HirDatabase>(\n+        sb: &mut SourceBinder<'_, DB>,\n+        src: InFile<Self>,\n+    ) -> Option<Self::ID> {\n+        let kind = MacroDefKind::Declarative;\n+\n+        let krate = sb.to_module_def(src.file_id.original_file(sb.db))?.id.krate;\n+\n+        let ast_id =\n+            Some(AstId::new(src.file_id, sb.db.ast_id_map(src.file_id).ast_id(&src.value)));\n+\n+        Some(MacroDefId { krate: Some(krate), ast_id, kind })\n+    }\n+}\n+\n+impl ToDef for ast::BindPat {\n+    type Def = Local;\n+\n+    fn to_def<DB: HirDatabase>(sb: &mut SourceBinder<'_, DB>, src: InFile<Self>) -> Option<Local> {\n+        let file_id = src.file_id;\n+        let parent: DefWithBodyId = src.value.syntax().ancestors().find_map(|it| {\n+            let res = match_ast! {\n+                match it {\n+                    ast::ConstDef(value) => { sb.to_id(InFile { value, file_id})?.into() },\n+                    ast::StaticDef(value) => { sb.to_id(InFile { value, file_id})?.into() },\n+                    ast::FnDef(value) => { sb.to_id(InFile { value, file_id})?.into() },\n+                    _ => return None,\n+                }\n+            };\n+            Some(res)\n+        })?;\n+        let (_body, source_map) = sb.db.body_with_source_map(parent);\n+        let src = src.map(ast::Pat::from);\n+        let pat_id = source_map.node_pat(src.as_ref())?;\n+        Some(Local { parent: parent.into(), pat_id })\n+    }\n+}\n+\n+impl ToDef for ast::TypeParam {\n+    type Def = TypeParam;\n+\n+    fn to_def<DB: HirDatabase>(\n+        sb: &mut SourceBinder<'_, DB>,\n+        src: InFile<ast::TypeParam>,\n+    ) -> Option<TypeParam> {\n+        let mut sb = SourceBinder::new(sb.db);\n+        let file_id = src.file_id;\n+        let parent: GenericDefId = src.value.syntax().ancestors().find_map(|it| {\n+            let res = match_ast! {\n+                match it {\n+                    ast::FnDef(value) => { sb.to_id(InFile { value, file_id})?.into() },\n+                    ast::StructDef(value) => { sb.to_id(InFile { value, file_id})?.into() },\n+                    ast::EnumDef(value) => { sb.to_id(InFile { value, file_id})?.into() },\n+                    ast::TraitDef(value) => { sb.to_id(InFile { value, file_id})?.into() },\n+                    ast::TypeAliasDef(value) => { sb.to_id(InFile { value, file_id})?.into() },\n+                    ast::ImplBlock(value) => { sb.to_id(InFile { value, file_id})?.into() },\n+                    _ => return None,\n+                }\n+            };\n+            Some(res)\n+        })?;\n+        let &id = sb.child_by_source(parent.into())[keys::TYPE_PARAM].get(&src)?;\n+        Some(TypeParam { id })\n+    }\n+}\n+\n+impl ToId for ast::Module {\n+    type ID = ModuleId;\n+\n+    fn to_id<DB: HirDatabase>(\n+        sb: &mut SourceBinder<'_, DB>,\n+        src: InFile<ast::Module>,\n+    ) -> Option<ModuleId> {\n+        {\n+            let _p = profile(\"ast::Module::to_def\");\n+            let parent_declaration = src\n+                .as_ref()\n+                .map(|it| it.syntax())\n+                .cloned()\n+                .ancestors_with_macros(sb.db)\n+                .skip(1)\n+                .find_map(|it| {\n+                    let m = ast::Module::cast(it.value.clone())?;\n+                    Some(it.with_value(m))\n+                });\n+\n+            let parent_module = match parent_declaration {\n+                Some(parent_declaration) => sb.to_id(parent_declaration)?,\n+                None => {\n+                    let file_id = src.file_id.original_file(sb.db);\n+                    sb.to_module_def(file_id)?.id\n+                }\n+            };\n+\n+            let child_name = src.value.name()?.as_name();\n+            let def_map = sb.db.crate_def_map(parent_module.krate);\n+            let child_id = *def_map[parent_module.local_id].children.get(&child_name)?;\n+            Some(ModuleId { krate: parent_module.krate, local_id: child_id })\n+        }\n+    }\n+}"}, {"sha": "5913f12b16fdea9486a6a57d6f667a4a0d5e9a97", "filename": "crates/ra_hir_def/src/keys.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fkeys.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -2,7 +2,7 @@\n \n use std::marker::PhantomData;\n \n-use hir_expand::InFile;\n+use hir_expand::{InFile, MacroDefId};\n use ra_syntax::{ast, AstNode, AstPtr};\n use rustc_hash::FxHashMap;\n \n@@ -29,6 +29,8 @@ pub const TUPLE_FIELD: Key<ast::TupleFieldDef, StructFieldId> = Key::new();\n pub const RECORD_FIELD: Key<ast::RecordFieldDef, StructFieldId> = Key::new();\n pub const TYPE_PARAM: Key<ast::TypeParam, TypeParamId> = Key::new();\n \n+pub const MACRO: Key<ast::MacroCall, MacroDefId> = Key::new();\n+\n /// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n /// equal if they point to exactly the same object.\n ///"}, {"sha": "27c12e46c55b4160cd9dfccb6cb911d3be06b886", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -59,12 +59,9 @@ use std::sync::Arc;\n \n use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile};\n use ra_arena::Arena;\n-use ra_db::{CrateId, Edition, FileId, FilePosition};\n+use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n-use ra_syntax::{\n-    ast::{self, AstNode},\n-    SyntaxNode,\n-};\n+use ra_syntax::ast;\n use rustc_hash::FxHashMap;\n \n use crate::{\n@@ -255,35 +252,6 @@ pub enum ModuleSource {\n     Module(ast::Module),\n }\n \n-impl ModuleSource {\n-    // FIXME: this methods do not belong here\n-    pub fn from_position(db: &impl DefDatabase, position: FilePosition) -> ModuleSource {\n-        let parse = db.parse(position.file_id);\n-        match &ra_syntax::algo::find_node_at_offset::<ast::Module>(\n-            parse.tree().syntax(),\n-            position.offset,\n-        ) {\n-            Some(m) if !m.has_semi() => ModuleSource::Module(m.clone()),\n-            _ => {\n-                let source_file = parse.tree();\n-                ModuleSource::SourceFile(source_file)\n-            }\n-        }\n-    }\n-\n-    pub fn from_child_node(db: &impl DefDatabase, child: InFile<&SyntaxNode>) -> ModuleSource {\n-        if let Some(m) =\n-            child.value.ancestors().filter_map(ast::Module::cast).find(|it| !it.has_semi())\n-        {\n-            ModuleSource::Module(m)\n-        } else {\n-            let file_id = child.file_id.original_file(db);\n-            let source_file = db.parse(file_id).tree();\n-            ModuleSource::SourceFile(source_file)\n-        }\n-    }\n-}\n-\n mod diagnostics {\n     use hir_expand::diagnostics::DiagnosticSink;\n     use ra_db::RelativePathBuf;"}, {"sha": "deaacda6cf951d29fa265e5c1be68a7855b1b29c", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -52,15 +52,11 @@ impl<'a> CompletionContext<'a> {\n         original_parse: &'a Parse<ast::SourceFile>,\n         position: FilePosition,\n     ) -> Option<CompletionContext<'a>> {\n-        let src = hir::ModuleSource::from_position(db, position);\n-        let module = hir::Module::from_definition(\n-            db,\n-            hir::InFile { file_id: position.file_id.into(), value: src },\n-        );\n+        let mut sb = hir::SourceBinder::new(db);\n+        let module = sb.to_module_def(position.file_id);\n         let token =\n             original_parse.tree().syntax().token_at_offset(position.offset).left_biased()?;\n-        let analyzer = hir::SourceAnalyzer::new(\n-            db,\n+        let analyzer = sb.analyze(\n             hir::InFile::new(position.file_id.into(), &token.parent()),\n             Some(position.offset),\n         );"}, {"sha": "f403b3bcf2e9a3e912a51b043cc4b8906dff5626", "filename": "crates/ra_ide/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdiagnostics.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -23,6 +23,7 @@ pub enum Severity {\n \n pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic> {\n     let _p = profile(\"diagnostics\");\n+    let mut sb = hir::SourceBinder::new(db);\n     let parse = db.parse(file_id);\n     let mut res = Vec::new();\n \n@@ -108,10 +109,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             fix: Some(fix),\n         })\n     });\n-    let source_file = db.parse(file_id).tree();\n-    let src =\n-        hir::InFile { file_id: file_id.into(), value: hir::ModuleSource::SourceFile(source_file) };\n-    if let Some(m) = hir::Module::from_definition(db, src) {\n+    if let Some(m) = sb.to_module_def(file_id) {\n         m.diagnostics(db, &mut sink);\n     };\n     drop(sink);"}, {"sha": "5a12a619c4ffbc64c30a91701b829581b77da55f", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -24,13 +24,14 @@ pub(crate) fn goto_definition(\n     let original_token = pick_best(file.token_at_offset(position.offset))?;\n     let token = descend_into_macros(db, position.file_id, original_token.clone());\n \n+    let mut sb = SourceBinder::new(db);\n     let nav_targets = match_ast! {\n         match (token.value.parent()) {\n             ast::NameRef(name_ref) => {\n-                reference_definition(db, token.with_value(&name_ref)).to_vec()\n+                reference_definition(&mut sb, token.with_value(&name_ref)).to_vec()\n             },\n             ast::Name(name) => {\n-                name_definition(db, token.with_value(&name))?\n+                name_definition(&mut sb, token.with_value(&name))?\n             },\n             _ => return None,\n         }\n@@ -67,57 +68,56 @@ impl ReferenceResult {\n }\n \n pub(crate) fn reference_definition(\n-    db: &RootDatabase,\n+    sb: &mut SourceBinder<RootDatabase>,\n     name_ref: InFile<&ast::NameRef>,\n ) -> ReferenceResult {\n     use self::ReferenceResult::*;\n \n-    let mut sb = SourceBinder::new(db);\n-    let name_kind = classify_name_ref(&mut sb, name_ref).map(|d| d.kind);\n+    let name_kind = classify_name_ref(sb, name_ref).map(|d| d.kind);\n     match name_kind {\n-        Some(Macro(it)) => return Exact(it.to_nav(db)),\n-        Some(Field(it)) => return Exact(it.to_nav(db)),\n-        Some(TypeParam(it)) => return Exact(it.to_nav(db)),\n-        Some(AssocItem(it)) => return Exact(it.to_nav(db)),\n-        Some(Local(it)) => return Exact(it.to_nav(db)),\n-        Some(Def(def)) => match NavigationTarget::from_def(db, def) {\n+        Some(Macro(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(Field(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(TypeParam(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(AssocItem(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(Local(it)) => return Exact(it.to_nav(sb.db)),\n+        Some(Def(def)) => match NavigationTarget::from_def(sb.db, def) {\n             Some(nav) => return Exact(nav),\n             None => return Approximate(vec![]),\n         },\n         Some(SelfType(imp)) => {\n             // FIXME: ideally, this should point to the type in the impl, and\n             // not at the whole impl. And goto **type** definition should bring\n             // us to the actual type\n-            return Exact(imp.to_nav(db));\n+            return Exact(imp.to_nav(sb.db));\n         }\n         None => {}\n     };\n \n     // Fallback index based approach:\n-    let navs = crate::symbol_index::index_resolve(db, name_ref.value)\n+    let navs = crate::symbol_index::index_resolve(sb.db, name_ref.value)\n         .into_iter()\n-        .map(|s| s.to_nav(db))\n+        .map(|s| s.to_nav(sb.db))\n         .collect();\n     Approximate(navs)\n }\n \n-pub(crate) fn name_definition(\n-    db: &RootDatabase,\n+fn name_definition(\n+    sb: &mut SourceBinder<RootDatabase>,\n     name: InFile<&ast::Name>,\n ) -> Option<Vec<NavigationTarget>> {\n     let parent = name.value.syntax().parent()?;\n \n     if let Some(module) = ast::Module::cast(parent.clone()) {\n         if module.has_semi() {\n             let src = name.with_value(module);\n-            if let Some(child_module) = hir::Module::from_declaration(db, src) {\n-                let nav = child_module.to_nav(db);\n+            if let Some(child_module) = sb.to_def(src) {\n+                let nav = child_module.to_nav(sb.db);\n                 return Some(vec![nav]);\n             }\n         }\n     }\n \n-    if let Some(nav) = named_target(db, name.with_value(&parent)) {\n+    if let Some(nav) = named_target(sb.db, name.with_value(&parent)) {\n         return Some(vec![nav]);\n     }\n "}, {"sha": "9834025d30837028aa5c3a893d68446791c1c1d8", "filename": "crates/ra_ide/src/impls.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fimpls.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{FromSource, ImplBlock};\n+use hir::{Crate, ImplBlock, SourceBinder};\n use ra_db::SourceDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n@@ -12,74 +12,69 @@ pub(crate) fn goto_implementation(\n ) -> Option<RangeInfo<Vec<NavigationTarget>>> {\n     let parse = db.parse(position.file_id);\n     let syntax = parse.tree().syntax().clone();\n+    let mut sb = SourceBinder::new(db);\n \n-    let src = hir::ModuleSource::from_position(db, position);\n-    let module = hir::Module::from_definition(\n-        db,\n-        hir::InFile { file_id: position.file_id.into(), value: src },\n-    )?;\n+    let krate = sb.to_module_def(position.file_id)?.krate();\n \n     if let Some(nominal_def) = find_node_at_offset::<ast::NominalDef>(&syntax, position.offset) {\n         return Some(RangeInfo::new(\n             nominal_def.syntax().text_range(),\n-            impls_for_def(db, position, &nominal_def, module)?,\n+            impls_for_def(&mut sb, position, &nominal_def, krate)?,\n         ));\n     } else if let Some(trait_def) = find_node_at_offset::<ast::TraitDef>(&syntax, position.offset) {\n         return Some(RangeInfo::new(\n             trait_def.syntax().text_range(),\n-            impls_for_trait(db, position, &trait_def, module)?,\n+            impls_for_trait(&mut sb, position, &trait_def, krate)?,\n         ));\n     }\n \n     None\n }\n \n fn impls_for_def(\n-    db: &RootDatabase,\n+    sb: &mut SourceBinder<RootDatabase>,\n     position: FilePosition,\n     node: &ast::NominalDef,\n-    module: hir::Module,\n+    krate: Crate,\n ) -> Option<Vec<NavigationTarget>> {\n     let ty = match node {\n         ast::NominalDef::StructDef(def) => {\n             let src = hir::InFile { file_id: position.file_id.into(), value: def.clone() };\n-            hir::Struct::from_source(db, src)?.ty(db)\n+            sb.to_def(src)?.ty(sb.db)\n         }\n         ast::NominalDef::EnumDef(def) => {\n             let src = hir::InFile { file_id: position.file_id.into(), value: def.clone() };\n-            hir::Enum::from_source(db, src)?.ty(db)\n+            sb.to_def(src)?.ty(sb.db)\n         }\n         ast::NominalDef::UnionDef(def) => {\n             let src = hir::InFile { file_id: position.file_id.into(), value: def.clone() };\n-            hir::Union::from_source(db, src)?.ty(db)\n+            sb.to_def(src)?.ty(sb.db)\n         }\n     };\n \n-    let krate = module.krate();\n-    let impls = ImplBlock::all_in_crate(db, krate);\n+    let impls = ImplBlock::all_in_crate(sb.db, krate);\n \n     Some(\n         impls\n             .into_iter()\n-            .filter(|impl_block| ty.is_equal_for_find_impls(&impl_block.target_ty(db)))\n-            .map(|imp| imp.to_nav(db))\n+            .filter(|impl_block| ty.is_equal_for_find_impls(&impl_block.target_ty(sb.db)))\n+            .map(|imp| imp.to_nav(sb.db))\n             .collect(),\n     )\n }\n \n fn impls_for_trait(\n-    db: &RootDatabase,\n+    sb: &mut SourceBinder<RootDatabase>,\n     position: FilePosition,\n     node: &ast::TraitDef,\n-    module: hir::Module,\n+    krate: Crate,\n ) -> Option<Vec<NavigationTarget>> {\n     let src = hir::InFile { file_id: position.file_id.into(), value: node.clone() };\n-    let tr = hir::Trait::from_source(db, src)?;\n+    let tr = sb.to_def(src)?;\n \n-    let krate = module.krate();\n-    let impls = ImplBlock::for_trait(db, krate, tr);\n+    let impls = ImplBlock::for_trait(sb.db, krate, tr);\n \n-    Some(impls.into_iter().map(|imp| imp.to_nav(db)).collect())\n+    Some(impls.into_iter().map(|imp| imp.to_nav(sb.db)).collect())\n }\n \n #[cfg(test)]\n@@ -210,7 +205,7 @@ mod tests {\n             \"\n             //- /lib.rs\n             #[derive(Copy)]\n-            struct Foo<|>;            \n+            struct Foo<|>;\n             \",\n             &[\"impl IMPL_BLOCK FileId(1) [0; 15)\"],\n         );"}, {"sha": "2dbccfc3b5072682a66bf512f3ee25ae1b1e66a5", "filename": "crates/ra_ide/src/parent_module.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -1,17 +1,23 @@\n //! FIXME: write short doc here\n \n use ra_db::{CrateId, FileId, FilePosition, SourceDatabase};\n+use ra_syntax::{\n+    algo::find_node_at_offset,\n+    ast::{self, AstNode},\n+};\n \n use crate::{db::RootDatabase, NavigationTarget};\n \n /// This returns `Vec` because a module may be included from several places. We\n /// don't handle this case yet though, so the Vec has length at most one.\n pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<NavigationTarget> {\n-    let src = hir::ModuleSource::from_position(db, position);\n-    let module = match hir::Module::from_definition(\n-        db,\n-        hir::InFile { file_id: position.file_id.into(), value: src },\n-    ) {\n+    let mut sb = hir::SourceBinder::new(db);\n+    let parse = db.parse(position.file_id);\n+    let module = match find_node_at_offset::<ast::Module>(parse.tree().syntax(), position.offset) {\n+        Some(module) => sb.to_def(hir::InFile::new(position.file_id.into(), module)),\n+        None => sb.to_module_def(position.file_id),\n+    };\n+    let module = match module {\n         None => return Vec::new(),\n         Some(it) => it,\n     };\n@@ -21,14 +27,11 @@ pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<Na\n \n /// Returns `Vec` for the same reason as `parent_module`\n pub(crate) fn crate_for(db: &RootDatabase, file_id: FileId) -> Vec<CrateId> {\n-    let source_file = db.parse(file_id).tree();\n-    let src = hir::ModuleSource::SourceFile(source_file);\n-    let module =\n-        match hir::Module::from_definition(db, hir::InFile { file_id: file_id.into(), value: src })\n-        {\n-            Some(it) => it,\n-            None => return Vec::new(),\n-        };\n+    let mut sb = hir::SourceBinder::new(db);\n+    let module = match sb.to_module_def(file_id) {\n+        Some(it) => it,\n+        None => return Vec::new(),\n+    };\n     let krate = module.krate();\n     vec![krate.into()]\n }"}, {"sha": "46cba30a38d75dff5c80939b30250207ff49ee84", "filename": "crates/ra_ide/src/references/classify.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fclassify.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -1,6 +1,6 @@\n //! Functions that are used to classify an element from its definition or reference.\n \n-use hir::{FromSource, InFile, Module, ModuleSource, PathResolution, SourceBinder};\n+use hir::{InFile, PathResolution, SourceBinder};\n use ra_prof::profile;\n use ra_syntax::{ast, match_ast, AstNode};\n use test_utils::tested_by;\n@@ -22,7 +22,7 @@ pub(crate) fn classify_name(\n         match parent {\n             ast::BindPat(it) => {\n                 let src = name.with_value(it);\n-                let local = hir::Local::from_source(sb.db, src)?;\n+                let local = sb.to_def(src)?;\n                 Some(NameDefinition {\n                     visibility: None,\n                     container: local.module(sb.db),\n@@ -35,16 +35,7 @@ pub(crate) fn classify_name(\n                 Some(from_struct_field(sb.db, field))\n             },\n             ast::Module(it) => {\n-                let def = {\n-                    if !it.has_semi() {\n-                        let ast = hir::ModuleSource::Module(it);\n-                        let src = name.with_value(ast);\n-                        hir::Module::from_definition(sb.db, src)\n-                    } else {\n-                        let src = name.with_value(it);\n-                        hir::Module::from_declaration(sb.db, src)\n-                    }\n-                }?;\n+                let def = sb.to_def(name.with_value(it))?;\n                 Some(from_module_def(sb.db, def.into(), None))\n             },\n             ast::StructDef(it) => {\n@@ -101,10 +92,9 @@ pub(crate) fn classify_name(\n             },\n             ast::MacroCall(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::MacroDef::from_source(sb.db, src.clone())?;\n+                let def = sb.to_def(src.clone())?;\n \n-                let module_src = ModuleSource::from_child_node(sb.db, src.as_ref().map(|it| it.syntax()));\n-                let module = Module::from_definition(sb.db, src.with_value(module_src))?;\n+                let module = sb.to_module_def(src.file_id.original_file(sb.db))?;\n \n                 Some(NameDefinition {\n                     visibility: None,\n@@ -114,7 +104,7 @@ pub(crate) fn classify_name(\n             },\n             ast::TypeParam(it) => {\n                 let src = name.with_value(it);\n-                let def = hir::TypeParam::from_source(sb.db, src)?;\n+                let def = sb.to_def(src)?;\n                 Some(NameDefinition {\n                     visibility: None,\n                     container: def.module(sb.db),\n@@ -157,10 +147,9 @@ pub(crate) fn classify_name_ref(\n         }\n     }\n \n-    let ast = ModuleSource::from_child_node(sb.db, name_ref.with_value(&parent));\n     // FIXME: find correct container and visibility for each case\n-    let container = Module::from_definition(sb.db, name_ref.with_value(ast))?;\n     let visibility = None;\n+    let container = sb.to_module_def(name_ref.file_id.original_file(sb.db))?;\n \n     if let Some(macro_call) = parent.ancestors().find_map(ast::MacroCall::cast) {\n         tested_by!(goto_def_for_macros);\n@@ -178,12 +167,13 @@ pub(crate) fn classify_name_ref(\n         PathResolution::Def(def) => Some(from_module_def(sb.db, def, Some(container))),\n         PathResolution::AssocItem(item) => Some(from_assoc_item(sb.db, item)),\n         PathResolution::Local(local) => {\n-            let container = local.module(sb.db);\n             let kind = NameKind::Local(local);\n+            let container = local.module(sb.db);\n             Some(NameDefinition { kind, container, visibility: None })\n         }\n         PathResolution::TypeParam(par) => {\n             let kind = NameKind::TypeParam(par);\n+            let container = par.module(sb.db);\n             Some(NameDefinition { kind, container, visibility })\n         }\n         PathResolution::Macro(def) => {"}, {"sha": "1e4226ab9acaef200b21552fbd108161682b4baf", "filename": "crates/ra_ide/src/references/name_definition.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Fname_definition.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -25,6 +25,8 @@ pub enum NameKind {\n #[derive(PartialEq, Eq)]\n pub(crate) struct NameDefinition {\n     pub visibility: Option<ast::Visibility>,\n+    /// FIXME: this doesn't really make sense. For example, builtin types don't\n+    /// really have a module.\n     pub container: Module,\n     pub kind: NameKind,\n }"}, {"sha": "626efb603958e7b16297093af5b1373573b794f4", "filename": "crates/ra_ide/src/references/rename.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences%2Frename.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -63,7 +63,7 @@ fn rename_mod(\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n     let module_src = hir::InFile { file_id: position.file_id.into(), value: ast_module.clone() };\n-    if let Some(module) = hir::Module::from_declaration(db, module_src) {\n+    if let Some(module) = hir::SourceBinder::new(db).to_def(module_src) {\n         let src = module.definition_source(db);\n         let file_id = src.file_id.original_file(db);\n         match src.value {"}, {"sha": "7533692f637159ca73f2afac69a01784d8575d6a", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3c4fbbbc45afc7d480185493b5ce77b5daa1747/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=d3c4fbbbc45afc7d480185493b5ce77b5daa1747", "patch": "@@ -66,8 +66,8 @@ fn runnable_mod(db: &RootDatabase, file_id: FileId, module: ast::Module) -> Opti\n         return None;\n     }\n     let range = module.syntax().text_range();\n-    let src = hir::ModuleSource::from_child_node(db, InFile::new(file_id.into(), &module.syntax()));\n-    let module = hir::Module::from_definition(db, InFile::new(file_id.into(), src))?;\n+    let mut sb = hir::SourceBinder::new(db);\n+    let module = sb.to_def(InFile::new(file_id.into(), module))?;\n \n     let path = module.path_to_root(db).into_iter().rev().filter_map(|it| it.name(db)).join(\"::\");\n     Some(Runnable { range, kind: RunnableKind::TestMod { path } })"}]}