{"sha": "c11fe553df269d6f47b4c48f5c47c08efdd373dc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxMWZlNTUzZGYyNjlkNmY0N2I0YzQ4ZjVjNDdjMDhlZmRkMzczZGM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-10-28T12:27:42Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "Create check_ref method to allow to check coercion with & types", "tree": {"sha": "ec15b76f1c0a3338be520c9bdd83e5b4d0a4286e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec15b76f1c0a3338be520c9bdd83e5b4d0a4286e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c11fe553df269d6f47b4c48f5c47c08efdd373dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c11fe553df269d6f47b4c48f5c47c08efdd373dc", "html_url": "https://github.com/rust-lang/rust/commit/c11fe553df269d6f47b4c48f5c47c08efdd373dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c11fe553df269d6f47b4c48f5c47c08efdd373dc/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2d0ec0eb4cb468fefb66da7af67b9cf8132373e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2d0ec0eb4cb468fefb66da7af67b9cf8132373e", "html_url": "https://github.com/rust-lang/rust/commit/b2d0ec0eb4cb468fefb66da7af67b9cf8132373e"}], "stats": {"total": 183, "additions": 114, "deletions": 69}, "files": [{"sha": "68b067012d3fa72db822c122427a4fa21228484e", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=c11fe553df269d6f47b4c48f5c47c08efdd373dc", "patch": "@@ -28,7 +28,6 @@\n \n #![cfg_attr(test, allow(deprecated))] // rand\n #![cfg_attr(not(stage0), deny(warnings))]\n-#![cfg_attr(not(stage0), feature(safe_suggestion))]\n \n #![feature(alloc)]\n #![feature(allow_internal_unstable)]"}, {"sha": "b4c41a99a6b971715f679d2e62a560c23cb7b2f7", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=c11fe553df269d6f47b4c48f5c47c08efdd373dc", "patch": "@@ -1231,7 +1231,6 @@ impl String {\n     /// assert_eq!(a.len(), 3);\n     /// ```\n     #[inline]\n-    #[cfg_attr(not(stage0), safe_suggestion)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn len(&self) -> usize {\n         self.vec.len()"}, {"sha": "90d752ae6ee297db8100658c6e236c59739d0b4c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=c11fe553df269d6f47b4c48f5c47c08efdd373dc", "patch": "@@ -549,7 +549,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         let expected_found = match values {\n             None => None,\n-            Some(ref values) => match self.values_str(&values) {\n+            Some(values) => match self.values_str(&values) {\n                 Some((expected, found)) => Some((expected, found)),\n                 None => {\n                     // Derived error. Cancel the emitter."}, {"sha": "6246e95faeb4ed95ffa81fa46b483af1969d7c12", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 61, "deletions": 55, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=c11fe553df269d6f47b4c48f5c47c08efdd373dc", "patch": "@@ -19,28 +19,10 @@ use syntax_pos::{self, Span};\n use rustc::hir;\n use rustc::ty::{self, ImplOrTraitItem};\n \n-use hir::def_id::DefId;\n-\n use std::rc::Rc;\n \n use super::method::probe;\n \n-struct MethodInfo<'tcx> {\n-    ast: Option<ast::Attribute>,\n-    id: DefId,\n-    item: Rc<ImplOrTraitItem<'tcx>>,\n-}\n-\n-impl<'tcx> MethodInfo<'tcx> {\n-    fn new(ast: Option<ast::Attribute>, id: DefId, item: Rc<ImplOrTraitItem<'tcx>>) -> MethodInfo {\n-        MethodInfo {\n-            ast: ast,\n-            id: id,\n-            item: item,\n-        }\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Requires that the two types unify, and prints an error message if\n     // they don't.\n@@ -79,41 +61,70 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn check_ref(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>,\n+                 expected: Ty<'tcx>) -> Option<String> {\n+        match (&checked_ty.sty, &expected.sty) {\n+            (&ty::TyRef(_, x_mutability), &ty::TyRef(_, y_mutability)) => {\n+                // check if there is a mutability difference\n+                if x_mutability.mutbl == hir::Mutability::MutImmutable &&\n+                   x_mutability.mutbl != y_mutability.mutbl &&\n+                   self.can_sub_types(&x_mutability.ty, y_mutability.ty).is_ok() {\n+                    if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+                        return Some(format!(\"try with `&mut {}`\", &src.replace(\"&\", \"\")));\n+                    }\n+                }\n+                None\n+            }\n+            (_, &ty::TyRef(_, mutability)) => {\n+                // check if it can work when put into a ref\n+                let ref_ty = match mutability.mutbl {\n+                    hir::Mutability::MutMutable => self.tcx.mk_mut_ref(\n+                                                       self.tcx.mk_region(ty::ReStatic),\n+                                                       checked_ty),\n+                    hir::Mutability::MutImmutable => self.tcx.mk_imm_ref(\n+                                                       self.tcx.mk_region(ty::ReStatic),\n+                                                       checked_ty),\n+                };\n+                if self.try_coerce(expr, ref_ty, expected).is_ok() {\n+                    if let Ok(src) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n+                        return Some(format!(\"try with `{}{}`\",\n+                                            match mutability.mutbl {\n+                                                hir::Mutability::MutMutable => \"&mut \",\n+                                                hir::Mutability::MutImmutable => \"&\",\n+                                            },\n+                                            &src));\n+                    }\n+                }\n+                None\n+            }\n+            _ => None,\n+        }\n+    }\n+\n     // Checks that the type of `expr` can be coerced to `expected`.\n     pub fn demand_coerce(&self, expr: &hir::Expr, checked_ty: Ty<'tcx>, expected: Ty<'tcx>) {\n         let expected = self.resolve_type_vars_with_obligations(expected);\n         if let Err(e) = self.try_coerce(expr, checked_ty, expected) {\n             let cause = self.misc(expr.span);\n             let expr_ty = self.resolve_type_vars_with_obligations(checked_ty);\n             let mode = probe::Mode::MethodCall;\n-            let suggestions = \n-                if let Ok(methods) = self.probe_return(syntax_pos::DUMMY_SP, mode, expected,\n-                                                   checked_ty, ast::DUMMY_NODE_ID) {\n+            let suggestions = if let Some(s) = self.check_ref(expr, checked_ty, expected) {\n+                Some(s)\n+            } else if let Ok(methods) = self.probe_return(syntax_pos::DUMMY_SP,\n+                                                          mode,\n+                                                          expected,\n+                                                          checked_ty,\n+                                                          ast::DUMMY_NODE_ID) {\n                 let suggestions: Vec<_> =\n                     methods.iter()\n-                           .filter_map(|ref x| {\n-                            if let Some(id) = self.get_impl_id(&x.item) {\n-                                Some(MethodInfo::new(None, id, Rc::new(x.item.clone())))\n-                            } else {\n-                                None\n-                            }})\n+                           .map(|ref x| {\n+                                Rc::new(x.item.clone())\n+                            })\n                            .collect();\n                 if suggestions.len() > 0 {\n-                    let safe_suggestions: Vec<_> =\n-                        suggestions.iter()\n-                                   .map(|ref x| MethodInfo::new(\n-                                                    self.find_attr(x.id, \"safe_suggestion\"),\n-                                                                   x.id,\n-                                                                   x.item.clone()))\n-                                   .filter(|ref x| x.ast.is_some())\n-                                   .collect();\n-                    Some(if safe_suggestions.len() > 0 {\n-                        self.get_best_match(&safe_suggestions)\n-                    } else {\n-                        format!(\"no safe suggestion found, here are functions which match your \\\n-                                 needs but be careful:\\n - {}\",\n-                                self.get_best_match(&suggestions))\n-                    })\n+                    Some(format!(\"here are some functions which \\\n+                                  might fulfill your needs:\\n - {}\",\n+                                 self.get_best_match(&suggestions)))\n                 } else {\n                     None\n                 }\n@@ -132,34 +143,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn get_best_match(&self, methods: &[MethodInfo<'tcx>]) -> String {\n+    fn get_best_match(&self, methods: &[Rc<ImplOrTraitItem<'tcx>>]) -> String {\n         if methods.len() == 1 {\n-            return format!(\" - {}\", methods[0].item.name());\n+            return format!(\" - {}\", methods[0].name());\n         }\n-        let no_argument_methods: Vec<&MethodInfo> =\n+        let no_argument_methods: Vec<&Rc<ImplOrTraitItem<'tcx>>> =\n             methods.iter()\n-                   .filter(|ref x| self.has_not_input_arg(&*x.item))\n+                   .filter(|ref x| self.has_not_input_arg(&*x))\n                    .collect();\n         if no_argument_methods.len() > 0 {\n             no_argument_methods.iter()\n-                               .map(|method| format!(\"{}\", method.item.name()))\n+                               .take(5)\n+                               .map(|method| format!(\"{}\", method.name()))\n                                .collect::<Vec<String>>()\n                                .join(\"\\n - \")\n         } else {\n             methods.iter()\n-                   .map(|method| format!(\"{}\", method.item.name()))\n+                   .take(5)\n+                   .map(|method| format!(\"{}\", method.name()))\n                    .collect::<Vec<String>>()\n                    .join(\"\\n - \")\n         }\n     }\n \n-    fn get_impl_id(&self, impl_: &ImplOrTraitItem<'tcx>) -> Option<DefId> {\n-        match *impl_ {\n-            ty::ImplOrTraitItem::MethodTraitItem(ref m) => Some((*m).def_id),\n-            _ => None,\n-        }\n-    }\n-\n     fn has_not_input_arg(&self, method: &ImplOrTraitItem<'tcx>) -> bool {\n         match *method {\n             ImplOrTraitItem::MethodTraitItem(ref x) => {"}, {"sha": "4a63c9679208f1ed2637a9db8e641f87b180d472", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c11fe553df269d6f47b4c48f5c47c08efdd373dc", "patch": "@@ -194,7 +194,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // think cause spurious errors. Really though this part should\n         // take place in the `self.probe` below.\n         let steps = if mode == Mode::MethodCall {\n-            match self.create_steps(span, self_ty) {\n+            match self.create_steps(span, self_ty, &looking_for) {\n                 Some(steps) => steps,\n                 None => {\n                     return Err(MethodError::NoMatch(NoMatchData::new(Vec::new(),\n@@ -247,7 +247,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn create_steps(&self,\n                     span: Span,\n-                    self_ty: Ty<'tcx>)\n+                    self_ty: Ty<'tcx>,\n+                    looking_for: &LookingFor<'tcx>)\n                     -> Option<Vec<CandidateStep<'tcx>>> {\n         // FIXME: we don't need to create the entire steps in one pass\n \n@@ -262,7 +263,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             })\n             .collect();\n \n-        let final_ty = autoderef.unambiguous_final_ty();\n+        let final_ty = match looking_for {\n+            &LookingFor::MethodName(_) => autoderef.unambiguous_final_ty(),\n+            &LookingFor::ReturnType(_) => self_ty,\n+        };\n         match final_ty.sty {\n             ty::TyArray(elem_ty, _) => {\n                 let dereferences = steps.len() - 1;\n@@ -628,13 +632,15 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn matches_return_type(&self, method: &ty::ImplOrTraitItem<'tcx>,\n-                           expected: ty::Ty<'tcx>) -> bool {\n+                               expected: ty::Ty<'tcx>) -> bool {\n         match *method {\n             ty::ImplOrTraitItem::MethodTraitItem(ref x) => {\n                 self.probe(|_| {\n                     let output = self.replace_late_bound_regions_with_fresh_var(\n                         self.span, infer::FnCall, &x.fty.sig.output());\n-                    self.can_sub_types(output.0, expected).is_ok()\n+                    let substs = self.fresh_substs_for_item(self.span, method.def_id());\n+                    let output = output.0.subst(self.tcx, substs);\n+                    self.can_sub_types(output, expected).is_ok()\n                 })\n             }\n             _ => false,"}, {"sha": "e04cc11f15e14dc2deba84907cadc8a7b3b49942", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c11fe553df269d6f47b4c48f5c47c08efdd373dc", "patch": "@@ -652,12 +652,6 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                                    \"internal implementation detail\",\n                                                    cfg_fn!(rustc_attrs))),\n \n-    (\"safe_suggestion\", Whitelisted, Gated(Stability::Unstable,\n-                                           \"safe_suggestion\",\n-                                           \"the `#[safe_suggestion]` attribute \\\n-                                            is an experimental feature\",\n-                                           cfg_fn!(safe_suggestion))),\n-\n     // FIXME: #14408 whitelist docs since rustdoc looks at them\n     (\"doc\", Whitelisted, Ungated),\n "}, {"sha": "decd589e6f4d8632fb15ac905b44baae4372abe3", "filename": "src/test/compile-fail/coerce_suggestions.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Ftest%2Fcompile-fail%2Fcoerce_suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c11fe553df269d6f47b4c48f5c47c08efdd373dc/src%2Ftest%2Fcompile-fail%2Fcoerce_suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce_suggestions.rs?ref=c11fe553df269d6f47b4c48f5c47c08efdd373dc", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn test(_x: &mut String) {}\n+fn test2(_x: &mut i32) {}\n+\n+fn main() {\n+    let x: usize = String::new();\n+    //^ ERROR E0308\n+    //| NOTE expected type `usize`\n+    //| NOTE found type `std::string::String`\n+    //| NOTE here are some functions which might fulfill your needs:\n+    let x: &str = String::new();\n+    //^ ERROR E0308\n+    //| NOTE expected type `&str`\n+    //| NOTE found type `std::string::String`\n+    //| NOTE try with `&String::new()`\n+    let y = String::new();\n+    test(&y);\n+    //^ ERROR E0308\n+    //| NOTE expected type `&mut std::string::String`\n+    //| NOTE found type `&std::string::String`\n+    //| NOTE try with `&mut y`\n+    test2(&y);\n+    //^ ERROR E0308\n+    //| NOTE expected type `&mut i32`\n+    //| NOTE found type `&std::string::String`\n+    //| NOTE try with `&mut y`\n+    let f;\n+    f = box f;\n+    //^ ERROR E0308\n+    //| NOTE expected type `_`\n+    //| NOTE found type `Box<_>`\n+}"}]}