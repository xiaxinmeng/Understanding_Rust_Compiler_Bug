{"sha": "4475e6a095a8fe4459ac8b854ae2336e47aaafe5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NzVlNmEwOTVhOGZlNDQ1OWFjOGI4NTRhZTIzMzZlNDdhYWFmZTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-01T00:03:27Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-13T18:31:48Z"}, "message": "std: connect_timeout requires a positive Duration\n\nThis is only breaking if you were previously specifying a duration\nof zero for some mysterious reason.\n\n[breaking-change]", "tree": {"sha": "5d31a17def0570cbf5ef3d8b9bb7d77dcdc6ab4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d31a17def0570cbf5ef3d8b9bb7d77dcdc6ab4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4475e6a095a8fe4459ac8b854ae2336e47aaafe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4475e6a095a8fe4459ac8b854ae2336e47aaafe5", "html_url": "https://github.com/rust-lang/rust/commit/4475e6a095a8fe4459ac8b854ae2336e47aaafe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4475e6a095a8fe4459ac8b854ae2336e47aaafe5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fdcddb3178d4705db4aee5ee12c05796203658c", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fdcddb3178d4705db4aee5ee12c05796203658c", "html_url": "https://github.com/rust-lang/rust/commit/9fdcddb3178d4705db4aee5ee12c05796203658c"}], "stats": {"total": 36, "additions": 27, "deletions": 9}, "files": [{"sha": "76368ac282139fce68b3462c1f2694cad2059524", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4475e6a095a8fe4459ac8b854ae2336e47aaafe5/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4475e6a095a8fe4459ac8b854ae2336e47aaafe5/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=4475e6a095a8fe4459ac8b854ae2336e47aaafe5", "patch": "@@ -93,21 +93,27 @@ impl TcpStream {\n     }\n \n     /// Creates a TCP connection to a remote socket address, timing out after\n-    /// the specified number of milliseconds.\n+    /// the specified duration.\n     ///\n     /// This is the same as the `connect` method, except that if the timeout\n     /// specified (in milliseconds) elapses before a connection is made an error\n     /// will be returned. The error's kind will be `TimedOut`.\n     ///\n     /// Note that the `addr` argument may one day be split into a separate host\n     /// and port, similar to the API seen in `connect`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails on a `timeout` of zero or negative duration.\n     #[experimental = \"the timeout argument may eventually change types\"]\n     pub fn connect_timeout(addr: SocketAddr,\n                            timeout: Duration) -> IoResult<TcpStream> {\n+        assert!(timeout > Duration::milliseconds(0));\n+\n         let SocketAddr { ip, port } = addr;\n         let addr = rtio::SocketAddr { ip: super::to_rtio(ip), port: port };\n         LocalIo::maybe_raise(|io| {\n-            io.tcp_connect(addr, Some(in_ms_u64(timeout))).map(TcpStream::new)\n+            io.tcp_connect(addr, Some(timeout.num_milliseconds() as u64)).map(TcpStream::new)\n         }).map_err(IoError::from_rtio_error)\n     }\n \n@@ -444,12 +450,6 @@ impl Acceptor<TcpStream> for TcpAcceptor {\n     }\n }\n \n-fn in_ms_u64(d: Duration) -> u64 {\n-    let ms = d.num_milliseconds();\n-    if ms < 0 { return 0 };\n-    return ms as u64;\n-}\n-\n #[cfg(test)]\n #[allow(experimental)]\n mod test {"}, {"sha": "0b647e67a2db63aa89adf4332c7ddb41a7a8a025", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4475e6a095a8fe4459ac8b854ae2336e47aaafe5/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4475e6a095a8fe4459ac8b854ae2336e47aaafe5/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=4475e6a095a8fe4459ac8b854ae2336e47aaafe5", "patch": "@@ -67,11 +67,17 @@ impl UnixStream {\n     ///\n     /// This function is similar to `connect`, except that if `timeout_ms`\n     /// elapses the function will return an error of kind `TimedOut`.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails on a `timeout` of zero or negative duration.\n     #[experimental = \"the timeout argument is likely to change types\"]\n     pub fn connect_timeout<P: ToCStr>(path: &P,\n                                       timeout: Duration) -> IoResult<UnixStream> {\n+        assert!(timeout > Duration::milliseconds(0));\n+\n         LocalIo::maybe_raise(|io| {\n-            let s = io.unix_connect(&path.to_c_str(), Some(in_ms_u64(timeout)));\n+            let s = io.unix_connect(&path.to_c_str(), Some(timeout.num_milliseconds() as u64));\n             s.map(|p| UnixStream { obj: p })\n         }).map_err(IoError::from_rtio_error)\n     }\n@@ -509,6 +515,18 @@ mod tests {\n         assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(100)).is_ok());\n     })\n \n+    iotest!(fn connect_timeout_zero() {\n+        let addr = next_test_unix();\n+        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n+        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(0)).is_ok());\n+    } #[should_fail])\n+\n+    iotest!(fn connect_timeout_negative() {\n+        let addr = next_test_unix();\n+        let _a = UnixListener::bind(&addr).unwrap().listen().unwrap();\n+        assert!(UnixStream::connect_timeout(&addr, Duration::milliseconds(-1)).is_ok());\n+    } #[should_fail])\n+\n     iotest!(fn close_readwrite_smoke() {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();"}]}