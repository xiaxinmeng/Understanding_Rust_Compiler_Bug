{"sha": "b53319a5bb86806d5b97ba0482b0cb260ea6c246", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1MzMxOWE1YmI4NjgwNmQ1Yjk3YmEwNDgyYjBjYjI2MGVhNmMyNDY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-10T20:07:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T17:14:19Z"}, "message": "rand: Delete all doc tests\n\nNone of these actually compile any more!", "tree": {"sha": "20497f04b527a40b942294170dd9945a3f81d5f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20497f04b527a40b942294170dd9945a3f81d5f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b53319a5bb86806d5b97ba0482b0cb260ea6c246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b53319a5bb86806d5b97ba0482b0cb260ea6c246", "html_url": "https://github.com/rust-lang/rust/commit/b53319a5bb86806d5b97ba0482b0cb260ea6c246", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b53319a5bb86806d5b97ba0482b0cb260ea6c246/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "700e627cf727873a472b1876238aac10b932258b", "url": "https://api.github.com/repos/rust-lang/rust/commits/700e627cf727873a472b1876238aac10b932258b", "html_url": "https://github.com/rust-lang/rust/commit/700e627cf727873a472b1876238aac10b932258b"}], "stats": {"total": 456, "additions": 0, "deletions": 456}, "files": [{"sha": "5ba6d8912f2672bcf73c58b0863f54fd18a87167", "filename": "src/librand/distributions/exponential.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Fdistributions%2Fexponential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Fdistributions%2Fexponential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fexponential.rs?ref=b53319a5bb86806d5b97ba0482b0cb260ea6c246", "patch": "@@ -56,18 +56,6 @@ impl Rand for Exp1 {\n ///\n /// This distribution has density function: `f(x) = lambda *\n /// exp(-lambda * x)` for `x > 0`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{Exp, IndependentSample};\n-///\n-/// let exp = Exp::new(2.0);\n-/// let v = exp.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from a Exp(2) distribution\", v);\n-/// ```\n #[derive(Copy, Clone)]\n pub struct Exp {\n     /// `lambda` stored as `1/lambda`, since this is what we scale by."}, {"sha": "1125d09653631cd84bdaa134c9ede52289908e7b", "filename": "src/librand/distributions/gamma.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fgamma.rs?ref=b53319a5bb86806d5b97ba0482b0cb260ea6c246", "patch": "@@ -37,18 +37,6 @@ use super::{IndependentSample, Sample, Exp};\n /// == 1`, and using the boosting technique described in [1] for\n /// `shape < 1`.\n ///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{IndependentSample, Gamma};\n-///\n-/// let gamma = Gamma::new(2.0, 5.0);\n-/// let v = gamma.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from a Gamma(2, 5) distribution\", v);\n-/// ```\n-///\n /// [1]: George Marsaglia and Wai Wan Tsang. 2000. \"A Simple Method\n /// for Generating Gamma Variables\" *ACM Trans. Math. Softw.* 26, 3\n /// (September 2000),\n@@ -184,18 +172,6 @@ impl IndependentSample<f64> for GammaLargeShape {\n /// of `k` independent standard normal random variables. For other\n /// `k`, this uses the equivalent characterisation `\u03c7\u00b2(k) = Gamma(k/2,\n /// 2)`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{ChiSquared, IndependentSample};\n-///\n-/// let chi = ChiSquared::new(11.0);\n-/// let v = chi.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from a \u03c7\u00b2(11) distribution\", v)\n-/// ```\n pub struct ChiSquared {\n     repr: ChiSquaredRepr,\n }\n@@ -242,18 +218,6 @@ impl IndependentSample<f64> for ChiSquared {\n /// This distribution is equivalent to the ratio of two normalised\n /// chi-squared distributions, that is, `F(m,n) = (\u03c7\u00b2(m)/m) /\n /// (\u03c7\u00b2(n)/n)`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{FisherF, IndependentSample};\n-///\n-/// let f = FisherF::new(2.0, 32.0);\n-/// let v = f.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from an F(2, 32) distribution\", v)\n-/// ```\n pub struct FisherF {\n     numer: ChiSquared,\n     denom: ChiSquared,\n@@ -287,18 +251,6 @@ impl IndependentSample<f64> for FisherF {\n \n /// The Student t distribution, `t(nu)`, where `nu` is the degrees of\n /// freedom.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{StudentT, IndependentSample};\n-///\n-/// let t = StudentT::new(11.0);\n-/// let v = t.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from a t(11) distribution\", v)\n-/// ```\n pub struct StudentT {\n     chi: ChiSquared,\n     dof: f64"}, {"sha": "77e53248607ca91abb4c4b67a4ecb8b1e138ea79", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=b53319a5bb86806d5b97ba0482b0cb260ea6c246", "patch": "@@ -90,24 +90,6 @@ pub struct Weighted<T> {\n /// `IndependentSample` traits. Note that `&T` is (cheaply) `Clone` for\n /// all `T`, as is `usize`, so one can store references or indices into\n /// another vector.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{Weighted, WeightedChoice, IndependentSample};\n-///\n-/// let mut items = vec!(Weighted { weight: 2, item: 'a' },\n-///                      Weighted { weight: 4, item: 'b' },\n-///                      Weighted { weight: 1, item: 'c' });\n-/// let wc = WeightedChoice::new(&mut items[..]);\n-/// let mut rng = rand::thread_rng();\n-/// for _ in 0..16 {\n-///      // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n-///      println!(\"{}\", wc.ind_sample(&mut rng));\n-/// }\n-/// ```\n pub struct WeightedChoice<'a, T:'a> {\n     items: &'a mut [Weighted<T>],\n     weight_range: Range<usize>"}, {"sha": "ac3fe6510ebcdeb5b7c3b6cb206daa783fe0a13a", "filename": "src/librand/distributions/normal.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fnormal.rs?ref=b53319a5bb86806d5b97ba0482b0cb260ea6c246", "patch": "@@ -72,19 +72,6 @@ impl Rand for StandardNormal {\n ///\n /// This uses the ZIGNOR variant of the Ziggurat method, see\n /// `StandardNormal` for more details.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{Normal, IndependentSample};\n-///\n-/// // mean 2, standard deviation 3\n-/// let normal = Normal::new(2.0, 3.0);\n-/// let v = normal.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from a N(2, 9) distribution\", v)\n-/// ```\n #[derive(Copy, Clone)]\n pub struct Normal {\n     mean: f64,\n@@ -121,19 +108,6 @@ impl IndependentSample<f64> for Normal {\n ///\n /// If `X` is log-normal distributed, then `ln(X)` is `N(mean,\n /// std_dev**2)` distributed.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand;\n-/// use std::rand::distributions::{LogNormal, IndependentSample};\n-///\n-/// // mean 2, standard deviation 3\n-/// let log_normal = LogNormal::new(2.0, 3.0);\n-/// let v = log_normal.ind_sample(&mut rand::thread_rng());\n-/// println!(\"{} is from an ln N(2, 9) distribution\", v)\n-/// ```\n #[derive(Copy, Clone)]\n pub struct LogNormal {\n     norm: Normal"}, {"sha": "8406c76cc1bbc4b915a1c1d0a694b74da5a4eeda", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=b53319a5bb86806d5b97ba0482b0cb260ea6c246", "patch": "@@ -32,23 +32,6 @@ use distributions::{Sample, IndependentSample};\n /// including `high`, but this may be very difficult. All the\n /// primitive integer types satisfy this property, and the float types\n /// normally satisfy it, but rounding may mean `high` can occur.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand::distributions::{IndependentSample, Range};\n-///\n-/// fn main() {\n-///     let between = Range::new(10, 10000);\n-///     let mut rng = std::rand::thread_rng();\n-///     let mut sum = 0;\n-///     for _ in 0..1000 {\n-///         sum += between.ind_sample(&mut rng);\n-///     }\n-///     println!(\"{}\", sum);\n-/// }\n-/// ```\n pub struct Range<X> {\n     low: X,\n     range: X,"}, {"sha": "f9163bb449ba66cf2dc7c1390e1c81080fce0ce3", "filename": "src/librand/lib.rs", "status": "modified", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=b53319a5bb86806d5b97ba0482b0cb260ea6c246", "patch": "@@ -143,17 +143,6 @@ pub trait Rng : Sized {\n     /// with new data, and may panic if this is impossible\n     /// (e.g. reading past the end of a file that is being used as the\n     /// source of randomness).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand, core)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut v = [0; 13579];\n-    /// thread_rng().fill_bytes(&mut v);\n-    /// println!(\"{:?}\", &v[..]);\n-    /// ```\n     fn fill_bytes(&mut self, dest: &mut [u8]) {\n         // this could, in theory, be done by transmuting dest to a\n         // [u64], but this is (1) likely to be undefined behaviour for\n@@ -179,38 +168,13 @@ pub trait Rng : Sized {\n     }\n \n     /// Return a random value of a `Rand` type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut rng = thread_rng();\n-    /// let x: usize = rng.gen();\n-    /// println!(\"{}\", x);\n-    /// println!(\"{:?}\", rng.gen::<(f64, bool)>());\n-    /// ```\n     #[inline(always)]\n     fn gen<T: Rand>(&mut self) -> T {\n         Rand::rand(self)\n     }\n \n     /// Return an iterator that will yield an infinite number of randomly\n     /// generated items.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut rng = thread_rng();\n-    /// let x = rng.gen_iter::<usize>().take(10).collect::<Vec<usize>>();\n-    /// println!(\"{:?}\", x);\n-    /// println!(\"{:?}\", rng.gen_iter::<(f64, bool)>().take(5)\n-    ///                     .collect::<Vec<(f64, bool)>>());\n-    /// ```\n     fn gen_iter<'a, T: Rand>(&'a mut self) -> Generator<'a, T, Self> {\n         Generator { rng: self, _marker: PhantomData }\n     }\n@@ -226,69 +190,24 @@ pub trait Rng : Sized {\n     /// # Panics\n     ///\n     /// Panics if `low >= high`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut rng = thread_rng();\n-    /// let n: usize = rng.gen_range(0, 10);\n-    /// println!(\"{}\", n);\n-    /// let m: f64 = rng.gen_range(-40.0f64, 1.3e5f64);\n-    /// println!(\"{}\", m);\n-    /// ```\n     fn gen_range<T: PartialOrd + SampleRange>(&mut self, low: T, high: T) -> T {\n         assert!(low < high, \"Rng.gen_range called with low >= high\");\n         Range::new(low, high).ind_sample(self)\n     }\n \n     /// Return a bool with a 1 in n chance of true\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut rng = thread_rng();\n-    /// println!(\"{}\", rng.gen_weighted_bool(3));\n-    /// ```\n     fn gen_weighted_bool(&mut self, n: usize) -> bool {\n         n <= 1 || self.gen_range(0, n) == 0\n     }\n \n     /// Return an iterator of random characters from the set A-Z,a-z,0-9.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let s: String = thread_rng().gen_ascii_chars().take(10).collect();\n-    /// println!(\"{}\", s);\n-    /// ```\n     fn gen_ascii_chars<'a>(&'a mut self) -> AsciiGenerator<'a, Self> {\n         AsciiGenerator { rng: self }\n     }\n \n     /// Return a random element from `values`.\n     ///\n     /// Return `None` if `values` is empty.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let choices = [1, 2, 4, 8, 16, 32];\n-    /// let mut rng = thread_rng();\n-    /// println!(\"{:?}\", rng.choose(&choices));\n-    /// assert_eq!(rng.choose(&choices[..0]), None);\n-    /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {\n             None\n@@ -298,20 +217,6 @@ pub trait Rng : Sized {\n     }\n \n     /// Shuffle a mutable slice in place.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand, core)]\n-    /// use std::rand::{thread_rng, Rng};\n-    ///\n-    /// let mut rng = thread_rng();\n-    /// let mut y = [1, 2, 3];\n-    /// rng.shuffle(&mut y);\n-    /// println!(\"{:?}\", y);\n-    /// rng.shuffle(&mut y);\n-    /// println!(\"{:?}\", y);\n-    /// ```\n     fn shuffle<T>(&mut self, values: &mut [T]) {\n         let mut i = values.len();\n         while i >= 2 {\n@@ -362,33 +267,9 @@ impl<'a, R: Rng> Iterator for AsciiGenerator<'a, R> {\n /// the same stream of randomness multiple times.\n pub trait SeedableRng<Seed>: Rng {\n     /// Reseed an RNG with the given seed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{Rng, SeedableRng, StdRng};\n-    ///\n-    /// let seed: &[_] = &[1, 2, 3, 4];\n-    /// let mut rng: StdRng = SeedableRng::from_seed(seed);\n-    /// println!(\"{}\", rng.gen::<f64>());\n-    /// rng.reseed(&[5, 6, 7, 8]);\n-    /// println!(\"{}\", rng.gen::<f64>());\n-    /// ```\n     fn reseed(&mut self, Seed);\n \n     /// Create a new RNG with the given seed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![feature(rand)]\n-    /// use std::rand::{Rng, SeedableRng, StdRng};\n-    ///\n-    /// let seed: &[_] = &[1, 2, 3, 4];\n-    /// let mut rng: StdRng = SeedableRng::from_seed(seed);\n-    /// println!(\"{}\", rng.gen::<f64>());\n-    /// ```\n     fn from_seed(seed: Seed) -> Self;\n }\n \n@@ -484,16 +365,6 @@ impl Rand for XorShiftRng {\n /// Use `Closed01` for the closed interval `[0,1]`, and the default\n /// `Rand` implementation for `f32` and `f64` for the half-open\n /// `[0,1)`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand::{random, Open01};\n-///\n-/// let Open01(val) = random::<Open01<f32>>();\n-/// println!(\"f32 from (0,1): {}\", val);\n-/// ```\n pub struct Open01<F>(pub F);\n \n /// A wrapper for generating floating point numbers uniformly in the\n@@ -502,16 +373,6 @@ pub struct Open01<F>(pub F);\n /// Use `Open01` for the closed interval `(0,1)`, and the default\n /// `Rand` implementation of `f32` and `f64` for the half-open\n /// `[0,1)`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand::{random, Closed01};\n-///\n-/// let Closed01(val) = random::<Closed01<f32>>();\n-/// println!(\"f32 from [0,1]: {}\", val);\n-/// ```\n pub struct Closed01<F>(pub F);\n \n #[cfg(test)]"}, {"sha": "287a23cf1d1b68a90d77ad2633880978f0273130", "filename": "src/librand/reseeding.rs", "status": "modified", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Freseeding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibrand%2Freseeding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freseeding.rs?ref=b53319a5bb86806d5b97ba0482b0cb260ea6c246", "patch": "@@ -99,34 +99,6 @@ impl<S, R: SeedableRng<S>, Rsdr: Reseeder<R> + Default>\n }\n \n /// Something that can be used to reseed an RNG via `ReseedingRng`.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// # #![feature(rand)]\n-/// use std::rand::{Rng, SeedableRng, StdRng};\n-/// use std::rand::reseeding::{Reseeder, ReseedingRng};\n-///\n-/// struct TickTockReseeder { tick: bool }\n-/// impl Reseeder<StdRng> for TickTockReseeder {\n-///     fn reseed(&mut self, rng: &mut StdRng) {\n-///         let val = if self.tick {0} else {1};\n-///         rng.reseed(&[val]);\n-///         self.tick = !self.tick;\n-///     }\n-/// }\n-/// fn main() {\n-///     let rsdr = TickTockReseeder { tick: true };\n-///\n-///     let inner = StdRng::new().unwrap();\n-///     let mut rng = ReseedingRng::new(inner, 10, rsdr);\n-///\n-///     // this will repeat, because it gets reseeded very regularly.\n-///     let s: String = rng.gen_ascii_chars().take(100).collect();\n-///     println!(\"{}\", s);\n-/// }\n-///\n-/// ```\n pub trait Reseeder<R> {\n     /// Reseed the given RNG.\n     fn reseed(&mut self, rng: &mut R);"}, {"sha": "e11a5818966fa2125e1d2796c7bb2b9eb41cb4f9", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b53319a5bb86806d5b97ba0482b0cb260ea6c246/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=b53319a5bb86806d5b97ba0482b0cb260ea6c246", "patch": "@@ -54,174 +54,6 @@\n //! -   On some systems (e.g. FreeBSD, OpenBSD and Mac OS X) there is no difference\n //!     between the two sources. (Also note that, on some systems e.g. FreeBSD, both `/dev/random`\n //!     and `/dev/urandom` may block once if the CSPRNG has not seeded yet.)\n-//!\n-//! # Examples\n-//!\n-//! ```rust\n-//! # #![feature(rand)]\n-//! use std::rand;\n-//! use std::rand::Rng;\n-//!\n-//! let mut rng = rand::thread_rng();\n-//! if rng.gen() { // random bool\n-//!     println!(\"isize: {}, usize: {}\", rng.gen::<isize>(), rng.gen::<usize>())\n-//! }\n-//! ```\n-//!\n-//! ```rust\n-//! # #![feature(rand)]\n-//! use std::rand;\n-//!\n-//! let tuple = rand::random::<(f64, char)>();\n-//! println!(\"{:?}\", tuple)\n-//! ```\n-//!\n-//! ## Monte Carlo estimation of \u03c0\n-//!\n-//! For this example, imagine we have a square with sides of length 2 and a unit\n-//! circle, both centered at the origin. Since the area of a unit circle is \u03c0,\n-//! we have:\n-//!\n-//! ```text\n-//!     (area of unit circle) / (area of square) = \u03c0 / 4\n-//! ```\n-//!\n-//! So if we sample many points randomly from the square, roughly \u03c0 / 4 of them\n-//! should be inside the circle.\n-//!\n-//! We can use the above fact to estimate the value of \u03c0: pick many points in the\n-//! square at random, calculate the fraction that fall within the circle, and\n-//! multiply this fraction by 4.\n-//!\n-//! ```\n-//! # #![feature(rand)]\n-//! use std::rand;\n-//! use std::rand::distributions::{IndependentSample, Range};\n-//!\n-//! fn main() {\n-//!    let between = Range::new(-1f64, 1.);\n-//!    let mut rng = rand::thread_rng();\n-//!\n-//!    let total = 1_000_000;\n-//!    let mut in_circle = 0;\n-//!\n-//!    for _ in 0..total {\n-//!        let a = between.ind_sample(&mut rng);\n-//!        let b = between.ind_sample(&mut rng);\n-//!        if a*a + b*b <= 1. {\n-//!            in_circle += 1;\n-//!        }\n-//!    }\n-//!\n-//!    // prints something close to 3.14159...\n-//!    println!(\"{}\", 4. * (in_circle as f64) / (total as f64));\n-//! }\n-//! ```\n-//!\n-//! ## Monty Hall Problem\n-//!\n-//! This is a simulation of the [Monty Hall Problem][]:\n-//!\n-//! > Suppose you're on a game show, and you're given the choice of three doors:\n-//! > Behind one door is a car; behind the others, goats. You pick a door, say No. 1,\n-//! > and the host, who knows what's behind the doors, opens another door, say No. 3,\n-//! > which has a goat. He then says to you, \"Do you want to pick door No. 2?\"\n-//! > Is it to your advantage to switch your choice?\n-//!\n-//! The rather unintuitive answer is that you will have a 2/3 chance of winning if\n-//! you switch and a 1/3 chance of winning if you don't, so it's better to switch.\n-//!\n-//! This program will simulate the game show and with large enough simulation steps\n-//! it will indeed confirm that it is better to switch.\n-//!\n-//! [Monty Hall Problem]: http://en.wikipedia.org/wiki/Monty_Hall_problem\n-//!\n-//! ```\n-//! # #![feature(rand)]\n-//! use std::rand;\n-//! use std::rand::Rng;\n-//! use std::rand::distributions::{IndependentSample, Range};\n-//!\n-//! struct SimulationResult {\n-//!     win: bool,\n-//!     switch: bool,\n-//! }\n-//!\n-//! // Run a single simulation of the Monty Hall problem.\n-//! fn simulate<R: Rng>(random_door: &Range<usize>, rng: &mut R) -> SimulationResult {\n-//!     let car = random_door.ind_sample(rng);\n-//!\n-//!     // This is our initial choice\n-//!     let mut choice = random_door.ind_sample(rng);\n-//!\n-//!     // The game host opens a door\n-//!     let open = game_host_open(car, choice, rng);\n-//!\n-//!     // Shall we switch?\n-//!     let switch = rng.gen();\n-//!     if switch {\n-//!         choice = switch_door(choice, open);\n-//!     }\n-//!\n-//!     SimulationResult { win: choice == car, switch: switch }\n-//! }\n-//!\n-//! // Returns the door the game host opens given our choice and knowledge of\n-//! // where the car is. The game host will never open the door with the car.\n-//! fn game_host_open<R: Rng>(car: usize, choice: usize, rng: &mut R) -> usize {\n-//!     let choices = free_doors(&[car, choice]);\n-//!     rand::sample(rng, choices.into_iter(), 1)[0]\n-//! }\n-//!\n-//! // Returns the door we switch to, given our current choice and\n-//! // the open door. There will only be one valid door.\n-//! fn switch_door(choice: usize, open: usize) -> usize {\n-//!     free_doors(&[choice, open])[0]\n-//! }\n-//!\n-//! fn free_doors(blocked: &[usize]) -> Vec<usize> {\n-//!     (0..3).filter(|x| !blocked.contains(x)).collect()\n-//! }\n-//!\n-//! fn main() {\n-//!     // The estimation will be more accurate with more simulations\n-//!     let num_simulations = 10000;\n-//!\n-//!     let mut rng = rand::thread_rng();\n-//!     let random_door = Range::new(0, 3);\n-//!\n-//!     let (mut switch_wins, mut switch_losses) = (0, 0);\n-//!     let (mut keep_wins, mut keep_losses) = (0, 0);\n-//!\n-//!     println!(\"Running {} simulations...\", num_simulations);\n-//!     for _ in 0..num_simulations {\n-//!         let result = simulate(&random_door, &mut rng);\n-//!\n-//!         match (result.win, result.switch) {\n-//!             (true, true) => switch_wins += 1,\n-//!             (true, false) => keep_wins += 1,\n-//!             (false, true) => switch_losses += 1,\n-//!             (false, false) => keep_losses += 1,\n-//!         }\n-//!     }\n-//!\n-//!     let total_switches = switch_wins + switch_losses;\n-//!     let total_keeps = keep_wins + keep_losses;\n-//!\n-//!     println!(\"Switched door {} times with {} wins and {} losses\",\n-//!              total_switches, switch_wins, switch_losses);\n-//!\n-//!     println!(\"Kept our choice {} times with {} wins and {} losses\",\n-//!              total_keeps, keep_wins, keep_losses);\n-//!\n-//!     // With a large number of simulations, the values should converge to\n-//!     // 0.667 and 0.333 respectively.\n-//!     println!(\"Estimated chance to win if we switch: {}\",\n-//!              switch_wins as f32 / total_switches as f32);\n-//!     println!(\"Estimated chance to win if we don't: {}\",\n-//!              keep_wins as f32 / total_keeps as f32);\n-//! }\n-//! ```\n \n #![unstable(feature = \"rand\")]\n "}]}